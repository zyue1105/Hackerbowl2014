[{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5764498551996416","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"Difference between A record and CName?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The A record maps a name to one or more IP addresses, when the IP are known and stable. The CNAME record maps a name to another name. It should only be used when there are no other records on that name."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6509608940077056","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"Name some DNS records and their purposes.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"NS - Name server record A record - Assigning IP address to a  domain/sub-domain MX - record - pointing the mail exchanger record for the domain so all emails are routed to the mx record which usually is a subdomain or domain name with a valid A record. CNAME - canonical name record makes one domain name an alias of another"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6247401723527168","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"Difference between inner join and left join?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"INNER JOIN: Returns all rows when there is at least one match in BOTH tables LEFT JOIN: Return all rows from the left table, and the matched rows from the right table RIGHT JOIN: Return all rows from the right table, and the matched rows from the left table FULL JOIN: Return all rows when there is a match in ONE of the tables  From W3Schools website."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5098624002293760","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"What is the default port for mysql?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"3306"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"3306"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6004339189481472","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"4","title":"What is inside a packet?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"A packet is one unit of binary data capable of being routed through a computer network. To improve communication performance and reliability, each message sent between two network devices is often subdivided into packets by the underlying hardware and software."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"which packet you are talking about ,any way you can use wireshark to get the exact content of a packet ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"A gift. Usually!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"A packet can contains many many datas. Either on the physical plane or the digital volume (or any disruptive synergistic advances made which we are unaware of). It could contain Quantum data like Schrodinger's pussy or Dick Feynman's squiggly.  IN ANY CASE, TO DETERMINE WHAT IS INSIDED THE PACKET, CHECK THE LABEL! HA HA HA HA."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5163800265228288","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"2","title":"Difference between Active and Passive FTP?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can find your answer here:  slacksite.com/other/ftp.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In active mode, the client sends the server the IP address and port number on which the client will listen so the server has to initiate the data connection. Here port 21 is control and port 20 is data on the server side. In Passive mode, the client sends a PASV command to the server and receives an IP address and port number in return for data transfer. Here port 21 is control and a random port >1024 is used for data on the server side. This is useful when the client is behind firewall and not accepting incoming connections."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6271593529475072","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"1","title":"I type www.Amazon.com into the browser and click go, explain in detail what happens?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Browser will contact DNS (Domain Name Server) to get the IP address. 2. DNS sends back the IP address to the Browser. 3. Browser will establish a TCP connection with the web server at port 80. 4. Browser will retrieve HTML code. 5. Browser will display the page based on HTML content.."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5971990569549824","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"24","title":"An array is given like {3,6,10,4,5,7,8}.  Pick any two number suppose 10 and then 7, as 10 >7, it's an inversion, now if you choose 3 & 5, 3<5,  it's not an inversion.    So you have to write a program to calculate total no of such inversion, in a given array. You can use extra space of O(n).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Modify mergesort to return inversions also (while sorting the input array). Normally mergesort returns \"void\" so you can make it return \"int\" to also return number of inversions.  The main change is to modify the merge routine inside mergesort (which usually returns nothing, but now will return an integer which is the count of the number of inversions BETWEEN elements in left array and right array).  When merging the left half array L and right half array R, we usually have two counters i_L and i_R pointing into the two arrays (pointing at the current numbers we are comparing and considering for placement in the output array).  So when you do the comparison, if L[i_L] <= R[i_R], you will move L[i_L] into the merged array as normal and increment i_L++.  So no change for this case (please note, include the = case as part of this case, not the next one).  What is different now is if  L[i_L] > R[i_R], you will move R[i_R] .. blah blah as usual but you will ALSO increment a counter like:  crossing_count += L.length - i_L  Why?  Because the element R[i_R] you are moving into merged array is inverted with respect to all the remaining elements in the L array (and there are L.length - i_L ) of them.  So that's what you do.  You modify merge subroutin to increment a counter whenever something from the the right array is picked to be placed in the merged array. And you increment it by the number of remaining elements in the L array.  Convince yourself that this will count ALL the crossing inversions (inversions between elements in L and R).   How does it look overall when the new merge function is placed in mergesort?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I told him to create a tree with array data from start, if it is going left in the tree, keep increasing total inversion count, if it is going right do nothing, at the end you will have total no of inversions. He seems to be satisfied with the algo, but not with my code, did so many boundary errors."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \nmain() \n{ \n        int a[7] = {3,6,10,4,5,7,8},i,j,count = 0; \n \n        for(i = 0;i<6;i++) \n        { \n                for(j = i+1;j<7;j++) \n                { \n                        if(a[i] > a[j]) \n                        { \n                                count++; \n                                printf(\"{%d,%d}\\n\",a[i],a[j]); \n                        } \n                } \n        } \n \n        printf(\"no of inversions :%d\\n\",count); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"obviously, no of nodes in right side of the current node in the tree will be added to the total number of inversions, while going to left, for that purpose all the nodes has to keep the count of number of nodes to its right, which can be tracked while creating the tree itself, idea was to tweak the tree creation code, so that these features could be fit. But I couldn't produce it in limited time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Maybe I have not understood the question correctly but I really do not see any need to use any data structure to compute number of inversions.  If we just need to get number of inversions, we need to calculate number of pairs (x,y) where x > y. Imagine the array in a sorted fashion. If x=largest number, then there can be (n-1) pairs using the other elements. Similarly, if x=2nd largest, there can be (n-2) pairs using remaining elements, and so on.  So, total number of inversions = 1+2+3+...+(n-1) = n*(n-1)/2."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about finding the Longest Decreasing subsequence in the array from 1 to n and then suppose the size is n then the number of inversions can be (n-1) + (n-2) + (n-3) + .......+ 1 = (n-1)*n / 2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think there is vagueness in the question. What does the examiner intend to do? Sort the array? Or just a comparison between different elements"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If there is no duplication, picking any 2 numbers should always be the inversion.  3 - 0 3,6 - 1 (6,3) -> 0 +1 3,6,10 -  3 (6,3)(10,6)(10,3) -> 1 + 2 3,6,10,4 -  6 (6,3)(10,6)(10,3)(4,3)(6,4),(10,4) -> 3 + 3 3,6,10,4,5 -  10 (6,3)(10,6)(10,3)(4,3)(6,4),(10,4)(5,3)(6,5)(10,5)(5,4) -> 6 + 4 3,6,10,4,5,7 - 10 + 5 3,6,10,4,5,7,8 - 15 + 6  : : :  f(n) = f(n-1) + (n - 1)  So running the function n times will get the answer.  function getNumberOfInversion(data) {     var prev = 0;     var result = 0;     for(var i = 1;i<=data.length;i++) {         result = prev + (i-1);         prev = result;     }     return result; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about sort it first,   After the array is sorted, we do the binary search. Each side will calculate the number of inversion."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"So from my interpretation, an inversion is just anytime a number is greater than any other number in the list regardless of where they are situated in the array. So this gives us the ability to sort the array and not alter the results.  So in my JS implementation in O(nlgn) time: 1. Sort the input array  time: O(nlgn)  2. Keep track of all duplicate values in array. We do this with a JS object (which acts as a set).  -- key = duplicated value -- value = array of indexes   time: O(n)  3. Starting from the end of the array, we look at its index.  The number of inversions for that number and every other number to the left of it will be equal to: =it's array index - the number of duplicates of that particular value in question that are to the left  eg. for [1,2,2]  for 2(end value): the number of inversions = 2 - 1 = 1 for 2(middle value): the number of inversions = 1 - 0 = 1 for 1 (first value): the number of inversions = 0 - 0 = 0  time: O(n)  try running this in jsfiddle:     jsfiddle.net/    7v7XN/1/"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6311825561878528","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"31","title":"Given an Array, replace each element in the Array with its Next Element(To its RHS) which is Larger than it. If no such element exists, then no need to replace. Ex:  i/p: {2,12,8,6,5,1,2,10,3,2} o/p:{12,12,10,10,10,2,10,10,3,2}","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"C++ Version:  O(n2) version:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question is asking to replace each element with the next element in the list which is larger than it.   Which is not at all clear from the phrase \"Next Largest Element\"."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include   main() {         int a[10] = {2,12,8,6,5,1,2,10,3,2},i,j;          for(i = 0;i<9;i++)         {                 for(j = i+1;j<10;j++)                 {                         if(a[i] < a[j])                         {                                 a[i] = a[j];                                 break;                         }                 }         }          for(i = 0;i<=9;i++)         {                 printf(\"%d \",a[i]);         } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class ReplaceNextGreaterElement { \n \n public static void main(String[] args) { \n  int a[] = { 2, 12, 8, 6, 5, 1, 2, 10, 3, 2 }; \n  greaterElement(a); \n  display(a); \n } \n  \n public static void display(int a[]) \n { \n  for(int a1:a) \n  { \n   System.out.print(a1+\",\"); \n  } \n } \n \n public static void greaterElement(int a[]) { \n  int len = a.length; \n  for (int i = 0; i < len-1; i++) { \n   for (int j = 0; j < len-1; j++) { \n \n    if(a[j]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this is a solution in C#. The number of arrays used can be minimized further. The time complexity is o(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can be solved in O(n) with two pointers. 1) slow and fast pointer initially points to zero'th element. 2) start moving fast pointer forward until its in increasing order. 3) on fast pointer reach a element that is less than prev.  4) start copying fast[i-1] to slow[j] until j reaches i-1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Just go from right to left keeping the max value found so far. Replace every element with such value (which can be the current element). O(N) time and O(1) space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"#include  \n#include  \n \nusing namespace std; \n \nint main() \n{ \n    int A[] = {2,12,8,6,5,1,2,10,3,2}; \n    const int N = sizeof(A) / sizeof(A[0]); \n \n    int m = A[N - 1]; \n \n    for (int i = N - 2; i >= 0; i--) { \n        m = max(m, A[i]);   // m = max(A[i], A[i+1], .... A[N-1] \n        A[i] = m; \n    } \n \n    for_each(A, A + N, [](int n) { cout << n << \" \"; }); \n    cout << endl; \n} \n// output: 12 12 10 10 10 10 10 10 3 2"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5198302274387968","download_status":"DOWNLOAD_DONE","votes":"-4","answersCount":"9","title":"Inorder traversal of binary tree","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"/* Iterative method using stack */ \nInordertraversal(struct btree *root)    \n{ \n while(1) \n {    \n  while( root ) \n  { \n   push(root); \n   root = root->left; \n  } \n  if(Isstackempty(S)) \n   return; \n  printf( S(top)->data); \n  root = pop(S); \n  root = root->right; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void inorder(Node n){ \n if(n.left != null){ \n  inorder(n.left); \n } \n System.out.printlin(n.value); \n if(n.right != null){ \n  inorder(n.right); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@mahdi.oraei - Could you give a solution without using recursion?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Before Algorithm I Should Say Something Here In This Recursion Stack Is Maintained By The Compiler It Intern Take care Of All The Things.Recursion Makes Coder To Do But MAke The Computer To Do More  Algorithm: #include struct tree { int data; struct tree *left; struct tree *right; } main() { struct tree *tree1=newnode(1); tree1->left=newnode(2); tree1->right=newnode(3); tree1->left->left=newnode(4); tree1->left->right=newnode(5); } void inorder(struct tree *tree1) { if(tree1==NULL) { return; } inorder(tree1->left); printf(\" %d\",tree1->data); inorder(tree1->right); } struct tree *newnode(int data) { struct tree *tree1; tree1=(struct tree *)malloc(sizeof(struct tree); tree1->left=NULL; tree1->right=NULL; return tree1; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void InOrder(Node root) \n{ \n  if(root != NULL) \n   { \n       InOrder(root.left); \n       System.out.println(root.data); \n      InOrder(root.right); \n  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5159516840656896","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"16","title":"There is a dictionary of billion words and there is one method provided String getWord(int index); We can give it index and it will return the String on that index . Now word is given to us we have to find out its index. O(logn) solution was required.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"If we know the size of the dictionary then a straight forward BINARY SEARCH is perfect enough.  If we don't know the size, instead we're only given the query method, then we need to find the index range [st, ed] first, where getWord[st] < theGivenWord < getWord[ed], by REPEATED DOUBLING.  So, try to query at index 1, 2, 4, 8, 16, ..., 2^k,... and find the [st, ed].  After knowing [st,ed], do binary search...  The overall time is O(logn) still."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the dictionary itself is sorted, this can be a simple binary search. Look up the 0.5 billion index, and see if the word should lie in the first half of the dictionary or the second. And then iterate this process, each time cutting the dictionary size by half. If the word exists, you'll get it in O(logn). If not, that also will be known in O(logn). Only thing is that you'd need to implement a proper comparator for strings."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"string WordTobeSearch = \"Repeat\"; string str_left, str_right; 1. Apply binary search for word from index start to end using at index = 1, 2, 4, 8, 16, ....,i, 2i, ....end.      if(WordTobeSearch ==getWord(i))  {   return i; //index of WordTobeSearch   } else{   str_left = getWord(i); // str_left < WordTobeSearch    str_right = getWord(2i); //str_right > WordTobeSearch  } apply procedure 1. from index i to 2i. until element is not find. or search space is exhausted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Following code causes mlogn, where m is length of given string. This can be optimized little without any change in the complexity."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Binary search"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The Trie is a better implementation for dictionary, and the search complexity will be O(n).  But the space complexity is bit of a concern if it is in term of billion of words.  Prefix tree could be another way that could provide you with O(nlogn) complexity."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Binay search will give O(log n) soln: maxidx = maximum index of the dictionary W: Word whose idx is to be found"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"2. Trie could be a ok solution, but  a) Its not mentioned dictionary is implemented as a trie b) Lookup is O(n) which is > O(log n) for binary search"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using the dictionary data structure of c#"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5950229446656000","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"20","title":"Frog can jump 1 or 2 steps write the code to find out number of ways to go up to n steps","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"The number of ways to jump to n steps is the n-th Fibonacci number!  F[n] = F[n-1] + F[n-2]; F1 = 1; F2 = 2;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorry to use a static variable, but could make the codes a little clear"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static     {         storeSteps[1] = 1;         storeSteps[2] = 2;     }          public static int calculateSteps(int number)     {         if(storeSteps[number] != 0)             return storeSteps[number];                          int steps = 0;         steps = calculateSteps(number-1)+calculateSteps(number-2);         storeSteps[number] = steps;                  return steps;              }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a typical recursion question. Simply speaking, it's a problem like: choosing from set{*,*,*....} to form a sum of N."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int jumpSteps(int step) {  if (step == 1)   return 1;  else if (step == 2)   return 2;   return jumpSteps(step - 1) + jumpSteps(step - 2); }  int main() { cout<}   Explanation : (1,1,1,1) (1,1,2) (1,2,1) (2,1,1) (2,2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int jump(int n){  int prev=0;  int cur=1;  for(int i=1;i<=n;i++){   int temp=cur;   cur+=prev;   prev=temp;  }  return cur; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is another DP problem, with two steps 1, 2. It is a Fibonacci  sequence as mentioned above. But what if Frog can jump S1, S2 ... Sn steps?   The number of ways to n is equal to N[n-S1] + N[n-S2] + .. N[n-Sn] if (n-Si) > 0, N[0] + 1 if n = Si N[0] equals 0  The time complexity is equal to n x S, n is the sum and S is number of jumps frog has The space complexity is equal to n"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class FrogJump { \n/* \n * Frog can jump 1 or 2 steps. \n * Find ways to cover n steps. \n * Question asked at amazon.com \n */ \n int max; \n int ways=0; \n public int jump(int current){ \n  //System.out.println(current); \n  if(currentmax){ \n   return 0; \n  } \n  return 0; \n } \n  \n public static void main(String[] args){ \n  FrogJump fj=new FrogJump(); \n  fj.max=5; \n  fj.jump(0); \n  System.out.println(fj.ways); \n   \n } \n  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since the frog can jump only 1 or 2 steps, the number of combinations of 1's and 2's to reach to a given sum 'n' is given by (n+1)th term of the Fibonacci Series where  f[0] = 0; f[1] = 1; f[2] = 1; f[3] = 2;  f[4] = 3 f[5] = 5; f[6] = 8; f[7] = 13 and so on.   So if n =5, then the number of possible steps will be (n+1)th term which is the 6th term in the fibonacci series whose value is 8.  Possible combinations : 1+1+1+1+1 = 1+1+1+2 = 1+1+2+1 = 1+2+1+1 = 2+1+1+1 = 2+2+1 = 2+1+2 = 1+2+2  Similarly, n = 6, then the number of possible steps will be (n+1)th term which is the 7th term in the fibonacci series whose value is 13.  Possible Combinations: 1 1 1 1 1 1 1 1 1 1 2 1 1 1 2 1 1 1 2 1 1 1 2 1 1 1  2 1 1 1 1  1 1 2 2  1 2 1 2 2 1 1 2 2 1 2 1 2 2 1 1  1 2 2 1 2 2 2   Java Code :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int func(int n,int index,int* memo) { \n    if(index<=n) { \n        if(memo[index]!=-1) \n            return memo[index]; \n        memo[index]=func(n,index+1,memo)+func(n,index+2,memo); \n        return memo[index]; \n    } \n    return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int func(int n,int index,int* memo) { \n    if(index<=n) { \n        if(memo[index]!=-1) \n            return memo[index]; \n        memo[index]=func(n,index+1,memo)+func(n,index+2,memo); \n        return memo[index]; \n    } \n    return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* Frog can jump 1,2,3 ( n different) steps write the code to find out number of ways to go up to n steps */ \n \nint distance[n]; \nint jumps[] = {1,2,3}; \ndistance[0] = 0; \nint jump(int n) \n{ \n if(n==0) \n  return 0; \n if(distance[n] != -1) \n  return distance[n]; \n int ans = 0; \n for(int i=0; i=jump[i]; i++) \n { \n  if (n==jump[i]) \n   ans++; \n  ans+ = jump(n-jump[i]); \n }  \n return distance[n] = ans; \n} \n \n/* Example \ndistance[0] = 0; \ndistance[1] = 1; \ndistance[2] = 1+1 = 2 (1,1) (2) \ndistance[3] = 1+2+1=4 (1,1,1) (2,1) (1,2) (3) \ndistance[4] = 4+2+1=7 (1,1,1,1) (2,2) (2,1,1) (1,2,1) (1,1,2) (3,1) (1,3) \ndistance[5] = 7+4+2=13 (1,1,1,1,1) (1,1,1,2)(1,1,2,1)(1,2,1,1)(2,1,1,1)(1,1,3)(1,3,1)(3,1,1)(2,3)(3,2)(2,2,1)(2,1,2)(1,2,2) \n*/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void findPath(int num, char[] path, int count) {   if(num < 0)   {    return;   }   if (num == 0) {    System.out.println(\"path :: \" + (new String(path)));    return;   } else {     if ((num - 1) >= 0) {     path[count]='1';     path[count+1]='\\0';     findPath(num-1, path, count+1);    }     if ((num - 2) >= 0) {     path[count]='2';     path[count+1]='\\0';     findPath(num-2, path, count+1);    }   }   }  void frogPath() {   int num = 10;   char[] path = new char[num+1];   findPath(num, path, 0);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Of Course We Can Calculate The No Of Steps By Using combinations.But It Takes Long Time.But It Follows Fibonacci Pattern"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6153780563279872","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"11","title":"Program to check whether undirected graph is a tree or not?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is a tree IFF if both 1) it is connected 2) has no cycles  So use DFS from any node s: [Assuming below that vertices are integer labelled from 0 to ... N-1. ]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"DFS from only one vertex! If there is no back edge and all of the vertices become black, the graph is tree.!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Followed the same approach and tested the code, it works"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6050804427390976","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"3","title":"You are given points of 2D plane and an integer n, return n number of points close to origin (0,0)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"(1)find out each point's distance from origin. (2)If the order of the n points is needed, we can use a min-heap or just sort them up, else the quick selection algorithm works."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Calculate distance of each point from the origin. Sort them based on the distance. Return first n numbers."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5705431074734080","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"5","title":"Design a musical jukebox using object-oriented principles","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"In any object-oriented design question, you first want to start off with asking your  interviewer some questions to clarify design constraints. Is this jukebox playing CD?  Records? MP3s? Is it a simulation on a computer, or is it supposed to represent a  physical jukebox? Does it take money, or is it free? And if it takes money, which  currency? And does it deliver change?    Unfortunately, we don't have an interviewer here that we can have this dialogue with.  Instead, we'll make some assumptions. We'll assume that the jukebox is a computer  simulation that closely mirrors physical jukeboxes, and we'll assume that it's free.  Now that we have that out of the way, we'll outline the basic system components.  ? Jukebox  ? CD  ? Song  ? Artist  ? Playlist  ? Display (displays details on the screen)    Now, let??s break this down further and think about the possible actions.  ? Playlist creation (includes add, delete, and shuffle)  ? CD selector  ? Song selector  ? Queuing up a song  ? Get next song from playlist    A user also can be introduced:  ? Adding  ? Deleting  ? Credit information    Each of the main system components translates roughly to an object, and each action  translates to a method. Let's walk through one potential design.    The Jukebox class represents the body of the problem. Many of the interactions  between the components of the system, or between the system and the user, are  channeled through here."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4632503952343040","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"1","title":"Construct an iterator of iterator  Here is the below question format:  // E next(); // Boolean hasNext();  // input: Iterator> // output: Iterator  // [[1], [2, 3]] => [1, 2, 3]","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; \nimport java.util.Iterator; \n \npublic class Problem implements Iterator { \n Iterator> iter; \n Iterator iter2; \n \n Problem(Iterator> iter) { \n  this.iter = iter; \n  if (iter.hasNext()) \n   this.iter2 = iter.next(); \n } \n \n @Override \n public boolean hasNext() { \n  if (iter2 != null) { \n   if (iter2.hasNext()) \n    return true; \n  } \n  while (iter.hasNext()) { \n   iter2 = iter.next(); \n   if (iter2.hasNext()) \n    return true; \n  } \n  return false; \n } \n \n @Override \n public E next() { \n  if (iter2 != null) { \n   if (iter2.hasNext()) \n    return iter2.next(); \n  } \n  if (iter.hasNext()) { \n   iter2 = iter.next(); \n   return this.next(); \n  } \n  return null; \n } \n \n @Override \n public void remove() { \n  // TODO Auto-generated method stub \n \n } \n \n public static void main(String[] args) { \n  // I am making an iterator of iterator here. \n  ArrayList> integers = new ArrayList>(); \n  for (int i = 0; i < 10; i++) { \n   ArrayList temp = new ArrayList(); \n   for (int j = 0; j < i; j++) { \n    temp.add(i); \n   } \n   integers.add(temp); \n  } \n  ArrayList> iter = new ArrayList>(); \n  for (int i = 0; i < integers.size(); i++) { \n   iter.add(integers.get(i).iterator()); \n  } \n  Iterator> iterator = iter.iterator(); \n \n  // Now I pass the iterator of iterator to the class problem. Problem is \n  // actually an iterator since I implement Iterator \n  @SuppressWarnings({ \"rawtypes\", \"unchecked\" }) \n  Problem p = new Problem(iterator); \n  while (p.hasNext()) { \n   System.out.println(p.next()); \n  } \n } \n \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5640239645196288","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"20","title":"Check if two binary search tree have the same in-order traversal in O(1) space","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"1, find the minimum of each binary search tree 2. call successor for each binary search tree"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"there's a way to do O(1) space tree traversal, which is called Morris Traversal. the idea is to add additional right link to a right leaf node's successor"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Here goes the logic: 1. Find first element in tree T1 as well as T2 while doing an inorder search (this is equivalent to finding smallest element in the tree.  - This can be starting from root, if left child is not null, leftmost child is the least node  - If no left child for root, root itself 2. Compare the two values, if not same return false else 3. Call inorder successor on both trees and find next smallest element 4. GO to step 2 5. If both the trees are exhausted (be careful here), return true else false (one is subset of other)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Could this possibly be solved using iterators? Get an iterator for each tree, then just keep checking is tree1.next().equals(tree2.next())"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"GZ_Penny, where did you get the question from?  How would you traversal on a single tree without a O(h) space stack (implicity via recursion or explicity container) ??????  Bad question."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Don't know what GC_PENNY is dreaming, but the \"best\" solution if parent pointers are not available seems to be (to me):  2 stacks, one for each tree.  Iteratively in order traverse each tree using independent stacks but check intermittently after each iteration in the obvious way for equality (and break if a no math condition is detected)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The Inorder of BSTs will be equal if both trees contain same elements .  We can check if two BSTs contains same elements by XORing all the elements in the tree with the other ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void isSame(node* root1, node* root2, bool& isSame) {     if( root1==NULL && root2 ==NULL) {          isSame = true;          return;      }      if( (root1 == NULL && root2 != NULL) || (root1!=NULL && root2!=NULL) {         isSame = false;         return;       }       isSame(root1->left, root2->left, isSame);       if( root1->data != root2->data){                 isSame = false;                 return;       }       isSame( root1->right, root2->right, isSame);      }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(1) space is impossible. you must use either recursive method or a stack to traverse the tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"public bool AreSame(Node a, Node b) \n        { \n            if (a == null && b==null) \n                return true; \n            if (a == null || b == null) \n                return false; \n            return AreSame(a.Left , b.Left) && a.Val == b.Val && AreSame(a.Right , b.Right); \n        }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5103437989543936","download_status":"DOWNLOAD_DONE","votes":"4","answersCount":"40","title":"There are many sorted arrays. Find a minimum range, so that in each array there's at least one integer within this range.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Here is my idea.   (A) Let's take the smallest element from each array. For each element we will remember from which array did we take it. Sort them and add to the queue this way : the smallest element will be on the first place.  (B) After this, we know the first and the last element. Let's count length of the interval. Next step is to pop element (let's call it x) and push next to x element, from the same array. Calculate length of the interval and repeat (B) until one of the arrays reaches its upper bound."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class minArrayRa?nge \n{ \n  public static void main(Strin?g args[]) \n  { \n \n  int [][] arrArrays=?{{3,4,5}, { 5, 58, 62}, {212, 434, 3333}}; \n  int []range=ge?tMinRange(?arrArrays)?; \n  System.out?.println(\"Min range = ?min = \"+range[0] + \" max = \" + range[1]); \n  } \n \n static int [] getMinRang?e(int [][] arrArrays) \n { \n \n  int max=-99999?, min=99999; \n  for ( int i=0; i < arrArrays.?length; i++) \n  { \n  if(max < arrArrays[?i][0]) \n  { \n  max=arrArr?ays[i][0]; \n  } \n \n  if(min > arrArrays[?i][0]) \n  { \n  min=arrArr?ays[i][0]; \n  } \n } \n \n int a[]= { min, max}; \n return a; \n \n} \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"WRONG SOLUTION (misunderstood the question) You need to find maximal value among all minimums, and minimal value among all maximums. If maximal minimum is less than minimal maximum, than you can use a range of size one, it may be any number within that range."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about first merge all sorted array and then traverse the merged list while keeping a window, make sure elements inside the window can be found in every original lists and keep updating the smallest window size."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I used divide and conquer strategy and it works. Yet, there can be one improvement and that is optimizing the size of nums array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class FindRangeEachArrayContainingAtleats1Integer { \n \n public static void main(String[] args) { \n \n  int a[] = { 1, 2, 3, 5 }; \n  int b[] = { 3, 5, 6, 7 }; \n  int c[] = { 2, 8, 9, 11 }; \n \n  Set se = new HashSet<>(); \n \n  for (int i = 0; i < a.length; i++) { \n   se.add(a[i]); \n  } \n  for (int i = 0; i < b.length; i++) { \n   se.add(b[i]); \n  } \n  for (int i = 0; i < c.length; i++) { \n   se.add(c[i]); \n  } \n  int length = se.size(); \n  int i = 0,min=0,max=0; \n  for (int a1 : se) { \n   if (i == 0) { \n     \n    min=a1; \n   } \n   i++; \n \n   if (i == length) { \n    max=a1; \n   } \n  } \n \n   System.out.println(\"Range is={ \"+min+ \",.....,\"+ max + \" } \"); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import sys \nfrom heapq import * \n \na1 = [1,6,8,10] \na2 = [3,9,20] \na3 = [6,10,20] \n \niters = [iter(a) for a in (a1, a2, a3)] \n \nheap = [(it.next(), it) for it in iters] \nheapify(heap) \n \nmin_range = (sys.maxint, (0,0)) \nmax_element = None \n \nwhile heap: \n    v, it = heappop(heap) \n \n    if max_element and v-max_element > 0: \n        min_range = min(min_range, (v-max_element, (max_element, v)), key=lambda x:x[0]) \n \n    max_element = max(v, max_element) \n \n    try: \n        heappush(heap, (it.next(), it)) \n    except: \n        break \n \nprint min_range[1]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please correct me if I am wrong but there is a simple greedy algorithm for this. Sort all the numbers from all the arrays. Start scanning numbers from the smallest (startNum)and stop at a number (stopNum) as soon as a number from each array has been scanned at least once (we know the array from which a number is taken from). save (stopNum,startNum). Next select, the next smallest number as the startNum for a new scan. Repeat till the end of the sorted array. Find the min range amongs the saved (stopNum,startNum) and that would be the answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The minimum possible range will be,  Min (Max value of each array) -- Max(Min value of each array).  Is this right ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Implementation of GK idea as Java Code."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I tested this for several of the inputs suggested above. Seems to work. Let me know if it breaks for any input. Use C++11 to compile it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This makes me think of Suffix Tree. Build up the tree, find the smallest common sub arr."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the best way to do it is to create a tree which once you print it in order gives all the elements of all the arrays sorted, then while creating that tree, for each element in the tree create a bit string which its size is the number of arrays and each bit says wether or not its contained by that array. At last pick the biggest numbers(they are contained by most of the arrays) and continue on their right and left until you fill your string with ones example(111111). Later compare your intervals which you traversed to find their minimum: Time complexity for creating the tree and the binaries for m arrays of size n:  O(m*n*log(m*n)) Time Complexity for traversing the fully sorted array and finding minimum interval(which it can be optimized) at worst case scenario is: O ((m)^2*n)  I'll write a code and post the link when I get the chance! but I don't think its necessary!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Previous comment is mine! :) Forgot to sign in! :D"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class ListOfArrays { \n ArrayList> listArray;  // list of sorted arrays \n ArrayList minIndexList;  // this list maintains the current index position within each array \n int minArray; \n boolean bFinal=false;  \n \n private class Interval { \n  Integer min= Integer.MAX_VALUE, max=Integer.MIN_VALUE; \n  boolean bFirst=true; \n \n \n  void setMinInterval() { \n   int low=Integer.MAX_VALUE,high=Integer.MIN_VALUE; \n   for(int i=0;ihigh) { \n     high=listArray.get(i).get(minIndexList.get(i)); \n    } \n   } \n   if((bFirst==true) || ((long) (high-low)<(long) (max - min))){ \n    min=low; \n    max=high; \n    bFirst=false; \n   } \n  } \n \n \n \n  public String toString() { \n   return String.format(\"[%d %d]\", min, max); \n  } \n } \n \n ListOfArrays(ArrayList> arrays) { \n  listArray=arrays; \n \n } \n \n ///////////////////// \n // \n ///////////////////// \n private void removeMin() { \n  int i = minArray; \n  if(minIndexList.get(i)(); \n \n \n \n  // init index list to 0th element \n  for(int i=0;i> arrays = new ArrayList>(); \n  ArrayList a,b,c,d,e,f ; \n  a= new ArrayList(); \n  a.add(2);a.add(10);a.add(20);a.add(53); \n \n  b= new ArrayList(); \n  b.add(1);b.add(5);b.add(52);b.add(54); \n \n  c= new ArrayList(); \n  c.add(23);c.add(24);c.add(53);c.add(55); \n \n  d= new ArrayList(); \n  d.add(5);d.add(6);d.add(7);d.add(52); \n \n  e= new ArrayList(); \n  e.add(24);e.add(28);e.add(50);e.add(52); \n \n  f= new ArrayList(); \n  f.add(3);f.add(21);f.add(51);f.add(53); \n \n  arrays.add(a);arrays.add(b);arrays.add(c); \n  arrays.add(d);arrays.add(e);arrays.add(f); \n  ListOfArrays m = new ListOfArrays(arrays); \n  Interval v = m.findMinRange(); \n  System.out.println(\"INPUT: \"+arrays.toString()); \n  System.out.println(\"OUTPUT: \"+v.toString()); \n \n } \n \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5205362126880768","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"0","title":"Write down the top ten testcases for sanity check of Templerun app in android based mobile. Testcases should appear in priority order?"}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5763491516383232","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"program to pruning a binary tree","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You need to define pruning, as it can mean a lot of things. In the most general sense, you can be pruning either the breadth or the height of the tree.   The most common is to prune all the leaf nodes. Something like this might work:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"deleting a node directly would result in dangling pointers, so first check if any of the child node is leaf or not and if leaf then remove the child reference and free memory."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6206746368409600","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"VLC player installable is crashing. Debug","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Definitely the depended file / library missing!!!"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5867650110455808","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"While playing NFS most wanted on a desktop, the application crashes. Debug the scenario?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Check RAM size, than Graphics Card.Basically look for the Hardware issues. Than, if not Hardware , U gotto look for the code where is the Memory leak !!! and  dependency libraries. Moreover, the deadlock scenarios are very common , so look for thread Mingling. those are Very Basics I think I would start with."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5125946302529536","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"15","title":"Find the kth largest node in an unsorted linked list. ( Is quick select (selection algorithm) applicable on linked list (not array?)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Selection algorithm is applicable on  linked lists."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There are two broad types/variants of the partition subroutines used for Quick(sort/select):  1) One broad type only has pointers/indices going from left to right"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"will the MAX heap help here?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Building a heap might work out or for kth greatest number maintain k + 1 pointers. Just try it with 2nd largest and 3rd largest element and check if k + 1 pointer funda works or not."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"getKthLargestInLL( linkedList, K ){ \n for( int i = 1; i<= K; i++ ){ \n  NODE node = findMax( linkedList ); \n  if( node == linkedList ) \n   linkedList = linkedList.next; \n } \n} \n \nNODE findMax( linkedList ){ \n Node maxNode = null; \n Node preMaxNode = null; \n Node lastNode = null; \n while( linkedList != null ){ \n  if( maxNode == null || maxNode.data < linkedList.data ){ \n   maxNode = linkedList; \n   preMaxNode = lastNode; \n  } \n  lastNode = linkedList; \n  linkedList = linkedList.next; \n } \n if( lastNode != null ) \n  lastNode.next = maxNode.next; \n return maxNode; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algorithm: We consider last node as the pivot and then partition the linked list using that pivot element. All the nodes smaller than the pivot will come before the pivot node and all the nodes greater than the pivot will come after the pivot node in the modified linked list. We pass the pivot element back to the calling method and see if the pivot is the desired kth element, in case it is we just return the pivot.  In case the position of the pivot is greater than the desired position, say k then we run the algorithm on the left side of the pivot node(i,e. from the head to the node prior to the pivot node).  In case the position of pivot is less than the desired position, we run the algorithm on the nodes that are on the right side of the pivot node( i,e node next to pivot to the tail) and decrease the distance by i(i being the position of the pivot in the linked list).  Code: #include  #include  using namespace std;  struct node {     int data;     struct node *next; };   /* Insert a node at the beginning of linked list */ void push(struct node** head_ref, int new_data) {     struct node* new_node = new node;     new_node->data  = new_data;     new_node->next = (*head_ref);     (*head_ref)    = new_node; }   /* A utility function to print linked list */ void printList(struct node *node) {     while (node != NULL)     {         cout<data<<\"\\t\";         node = node->next;     }     cout<}   // Returns the last node of the list struct node *getTail(struct node *cur) {     while (cur != NULL && cur->next != NULL)         cur = cur->next;     return cur; }  struct node *partition(struct node **head, struct node **tail) {  struct node *p,*q,*pivot=*tail,*temp;  p=*head;  while(p!=pivot)  {   if(p->data<=pivot->data)   {    q=p;    p=p->next;   }   else if(p->data>pivot->data)   {    if(p==*head)    {     *head=(*head)->next;    }    else{    q->next=p->next;    }    temp=p->next;    (*tail)->next=p;    p->next=NULL;    *tail=p;    p=temp;   }  }  return pivot; }  void quicksort(struct node **head, struct node **tail) {  if(*head==NULL || *head==*tail)  return;    struct node *p, *n;  p=partition(head,tail);   n=*head;  if(n!=p)  {  while(n->next!=p) n=n->next;  n->next=NULL;  quicksort(head,&n);  n->next=p;  }  quicksort(&(p->next),tail);   return; }  void quickSort(struct node **head) {  struct node *n=getTail(*head);  quicksort(head,&n);  return; }  struct node *kthElementHelper(struct node **head, struct node **tail, int k) {  int i=1;  struct node *p,*n,*res,*temp;  p=partition(head,tail);  n=*head;    if(n==p)  {  if(i!=k) return kthElementHelper(&(n->next),tail,k-1);  else return p;  }    while(n->next!=p)  {   n=n->next;   i=i+1;  }  i=i+1;  if(k==i) return p;  else if(k {   n->next=NULL;   res= kthElementHelper(head,&n,k);   n->next=p;  }  else if(k>i)  {   temp=(*tail)->next;   (*tail)->next=NULL;   res= kthElementHelper(&(p->next),tail,k-i);   (*tail)->next=temp;  }  return res; }  struct node *kthElement(struct node **h,int k) {  struct node *n=getTail(*h);  return kthElementHelper(h,&n,k); }  int main() {     struct node *a = NULL;     int k=3;     push(&a, 5);     push(&a, 20);     push(&a, 4);     push(&a, 3);     push(&a, 30);     push(&a, 1);       cout << \"Linked List before calling the Method \\n\";     printList(a);             cout<<\"\\nk is: \"<<<<\"kth largest element is: \"<data<<      cout << \"Linked List after calling the method \\n\";     printList(a);       return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Maintain a binary search tree of k nodes. Scan the input list, if current node value is larger than the smallest value of the tree nodes, remove that node and insert current node value into the binary search tree.   Time complexity is O(nlogk)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"quickSelect logic for a linked list Need to know the tail of the list for the logic to work."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"If we can modify this linked list:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5428979330711552","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"0","title":"Test Google advertisements. Basically the expectation is to get the requirement, assume certain things and come up with test strategies. E.g : UI, Backend, Compatibility, Accessibility etc.  On the fly question were asked"}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4846025567109120","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"37","title":"Given a number in an array form, Come up with an algorithm to push all the zeros to the end. Expectation : O(n) solution","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"the original order/arrangement of zeroes is not conserved once they have been pushed to the end."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"void movezeros(int arr[],int n) {       int i,end=n-1;      for(i=0;i    {        if(arr[end]==0)  {   end--;   continue;  }  if(arr[i]==0)  {   arr[i]=arr[i]+arr[end];   arr[end]=arr[i]-arr[end];   arr[i]=arr[i]-arr[end];   i++;  }        } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"here my c++ solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void removeZeros(int arr[], int n) \n{ \n    int i, pos = 0; \n    //copy nonzero numbers to the front \n    for(i = 0; i < n; ++i){ \n        if(arr[i] != 0) arr[pos++] = arr[i]; \n    } \n    //fill tail with zeros \n    for(i = pos; i < n; ++i) arr[i] = 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If one of the array element contains say 10 or 300?? int[] arr = {10, 300, 20, 4}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This O(n) solution iterates over the array with two indexes. If an element is not 0, we copy it to the position of the first index (and advance both indexes), if it is a 0 then we only advance the second index, counting the 0s encountered. When the second index gets to the end, we will have filled up the non-zero digits at the beginning, so we just need to make sure to fill the remaining elements at the end with 0s."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args){ \n  int[] noArrayform = {0,2,0,1,4,5,6,7,0,1,2,3,4,5,0,0,1,4,0}; \n  int[] outputArray = new int[noArrayform.length]; \n  int loopCount = 0; \n  int outputLength = 0; \n \n   \n  //copy the non zero values to the new output array \n  while(loopCount"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would use partition idea in the quick sort. A pointer at the beginning and a pointer at the end. Whenever the beginning pointer encounters a zero, swap the first pointers value with the second one. Then while there is an immediate zero before the second pointer move the second pointer back. Do it while (first pointer < second pointer)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class PushZero { public static void main(String...v){   ArrayDeque num = new ArrayDeque<>();      int arr[] = {1,3,5,0,0,4,6,0};   for(int i=0;i   if(arr[i]==0){     num.addLast(arr[i]);    }    else{     num.addFirst(arr[i]);    }   }   System.out.println(num.size());   for(Iterator itr = num.iterator();itr.hasNext();)  {       System.out.println(itr.next());     } } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void pushZero(int *array, int length) { \n    int zerocount = 0; // var to hold the num of Zeros in the given string \n    //Loop through all the elements of the array \n     \n    for (int i = 0; i < length; i++) { \n        // if element = 0, do nothing, just increment the count \n        if (0 == array[i]) { \n         zerocount++; \n      continue; \n     } \n         \n        //if not, then based on the zerocount, swap the elements \n     if (0 != zerocount) { \n      array[i - zerocount] = array[i]; \n      array[i] = 0; \n     } // end if \n    } // end for \n} // end pushZero()"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can use Partition, which uses \"n - 1\" comparisons and at most \"n - 1\" swaps using a customized comparator which assumes \"0\" is the largest number. Comparator code follows:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/** * Manuel. * Assuming there are 13 integers. Btw: I think the complexity reamins O(n) although I  * have outer loop here. */ #include   void inline swap(int *a, int *b); void pushZeros(int (&arr)[13]); void printArr(int (&arr)[13]);  int main() { int size= 13;  int arr[13]={1,2,3,0,0,0,-3,-4,0,0,1,0,0};  printArr(arr);  std::cout<<\"After pushing the zeros\"<<'\\n';  pushZeros(arr); printArr(arr);   return -1;  }  void printArr(int (&arr)[13]) {  for(int i=0; i < 13 ; i++)  {   std::cout<<\" \"< } }   void pushZeros(int (&arr)[13]) {    int *ptr1= arr;  int *ptr2= arr+ 13 -1;       while(ptr1 < ptr2)  {   while(*ptr1!=0 ) ptr1++;   while(*ptr2==0)  ptr2--;   if(ptr1 < ptr2) swap(ptr1, ptr2);   else break;    ptr1++;   ptr2--;   }    }  void inline swap(int *a, int *b) {  int c= *a;  *a= *b;   *b= c;   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args)  {   int[] array={1,2,0,3,4,0,3};   int length = array.length;   int multiplier = (int)Math.pow(10, length-1);   int num = 0;   for(int i=0;i   num = num + multiplier*array[i];    if(array[i]!=0)     multiplier=multiplier/10;   }   System.out.println(num);    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(int[] array)  {    int length = array.length;   int multiplier = (int)Math.pow(10, length-1);   int num = 0;   for(int i=0;i {    num = num + multiplier*array[i];    if(array[i]!=0)   multiplier=multiplier/10;   }  System.out.println(num);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this is a variant of dutch national flag problem. The solution is simple and can be achieved in o(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  //WAP to shift all zeroes to the end of the array using namespace std;  void sift(int a[],int n) {      int i=0,j=n-1,t;      while(i     {                 while(a[j]==0)                 {                            j--;                 }                   while(a[i]!=0)                  {                  i++;                                    }                  if(i                 {                     t=a[i];                     a[i]=a[j];                     a[j]=t;                  }      }      cout<<\"\\nArray is now:\";      for(int k=0;k       cout<}                                                                               int main() {      int a[100],n;      cout<<\"\\nEnter the number of elements:\";      cin>>n;      for(int i=0;i      cin>>a[i];       sift(a,n);       getch();       return 0;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \nusing namespace std; \n \nvoid moveZeroToEnd( int * data,size_t size) \n{ \n    if(!size) return; \n    size_t lastNonZeroPosition=size-1; \n    while(lastNonZeroPosition&&(!data[lastNonZeroPosition])) lastNonZeroPosition-- ; \n \n    for(size_t i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"j = len(a)  for i in range(j):  while (a[j-1] ==0):   j = j-1  if i == j:   break  if a[i] == 0 and a[j-1] !=0:   temp = a[i]   a[i] = a[j-1]   a[j-1] = temp   j = j-1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// Given a number in an array form, Come up with an algorithm to push all the zeros to the end.  \n// Expectation: O(n) solution \n \n#include  \n \nvoid print(int *arr, size_t size) \n{ \n using namespace std; \n \n for (size_t i = 0; i < size; ++i) \n  cout << arr[i] << ' '; \n cout << endl; \n} \n \nvoid pushZeroToEnd(int *arr, size_t size) \n{ \n int *start = arr; \n int *end = arr + size - 1; \n \n while (start < end) \n { \n  // Find first zero \n  while (*start != 0) ++start; \n \n  // Find last not zero \n  while (*end == 0) --end; \n \n  // Swap \n  *start++ = *end; \n  *end-- = 0; \n } \n} \n \nint main() \n{ \n int arr[] = { 1, 3, 0, 0, 0, 2, 0, 5, 4, 0, 3, 9, 0, 8, 0, 0 }; \n \n size_t size = sizeof(arr) / sizeof(int); \n \n print(arr, size); \n pushZeroToEnd(arr, size); \n print(arr, size); \n \n std::cin.get(); \n \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) \n{ \n int[] input = new int[]{ 0,5,6,0,0,2,4,0}; \n int nzpos = 0; //non-zero-position \n        int DigitToPush = 0; \n for(int i = 0 ; i < input.length; i++) \n { \n  if(arr[i] == DigitToPush)  \n   continue; \n  else \n   input[nzpos++] = input[i]; \n } \n // by this time all nonzero are at correct place; now fill-out rest of zeroes \n for(int j = nzpoz; j < input.length() ; j++) \n {  \n  input[j] = DigitToPush; \n } \n \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void swap(int[] a) {  int i = 0;  int j = a.length() - 1;  //[1,2,0,3,0,5,6,0,8,0]  while(j>i) {   if(a[i] == 0) {    while(j>i) {     if(a[j] != 0) {      int temp = a[j];      a[j] = a[i];      a[i] = temp;      break;     }     j--;    }   }   i++;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void swap(int[] a) {  int i = 0;  int j = a.length() - 1;  //[1,2,0,3,0,5,6,0,8,0]  while(j>i) {   if(a[i] == 0) {    while(j>i) {     if(a[j] != 0) {      int temp = a[j];      a[j] = a[i];      a[i] = temp;      break;     }     j--;    }   }   i++;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void swap(int[] a) {  int i = 0;  int j = a.length() - 1;  //[1,2,0,3,0,5,6,0,8,0]  while(j>i) {   if(a[i] == 0) {    while(j>i) {     if(a[j] != 0) {      int temp = a[j];      a[j] = a[i];      a[i] = temp;      break;     }     j--;    }   }   i++;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void swap(int[] a) {  int i = 0;  int j = a.length() - 1;  //[1,2,0,3,0,5,6,0,8,0]  while(j>i) {   if(a[i] == 0) {    while(j>i) {     if(a[j] != 0) {      int temp = a[j];      a[j] = a[i];      a[i] = temp;      break;     }     j--;    }   }   i++;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do a naive quiqsort implementation"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void PushZereosToEnd(int* arr,int len) {  int posZero = -1;   for(int i = 0; i < len; i++)  {   if(arr[i] == 0 && posZero == -1) //this is the zero index fisrt time    posZero = i;    else if(arr[i] != 0 && posZero != -1) //need to swap   {    int temp = arr[i];    arr[i] = arr[posZero];    arr[posZero] = temp;    posZero++;   }  }   for(int i = 0; i < len; i++)   std::cout<}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int size = (sizeof(arr) / sizeof(int) ) - 1;   for(int i = size,  j = size; i >=0 ;  i--){        if(a[i] == 0){            for(int k = i; k != j; k++){                a[k] = a[k+1];            }            a[j] = 0;            j--;        }    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void zeromove(int *a, int len) \n{ \n        int zero_start = 0; \n        int nonzero_pos = 0; \n \n        while(nonzero_pos < len) { \n                if (a[zero_start]) { \n                        zero_start++; \n                        nonzero_pos++; \n                } else if (!a[nonzero_pos]) { \n                        nonzero_pos++; \n                } else { \n                        swap(a[zero_start++], a[nonzero_pos++]); \n                } \n        } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"void moveZero(int a[]) {  int arrSize = sizeof(a)/sizeof(int);  int end = arrSize - 1;   for (int i = 0; i < arrSize; i++)  {   if ( a[i] == 0 )   {    std::swap(a[i], a[end]);    end--;   }   if (i == end)    break;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"void moveZero(int a[]) {  int arrSize = sizeof(a)/sizeof(int);  int end = arrSize - 1;   for (int i = 0; i < arrSize; i++)  {   if ( a[i] == 0 )   {    std::swap(a[i], a[end]);    end--;   }   if (i == end)    break;  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6460589673021440","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"0","title":"Was asked to explain Current QA and roles in detail. How was automation implemented and basis of the same?"}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5698049099694080","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"37","title":"You are given an array with numbers - [11, 3, 11, 11, 3, 2, 0, -2, 2]  You are supposed to write a function that returns the number that appears \"odd\" number of times.   The solution is obviously using HashMap. But that takes O(n) to create the HashMap and O(n) to lookup. How can one eliminate the second O(n) yet keeping the HashMap?  Hint: Do you really need to count frequency of occurrence of each digit?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"You can do this using only one HashSet. Add new element to HashSet if its not already in the HashSet - else, remove it from the HashSet. This will make sure by the end of the iteration - the HashSet will only have the odd* occurring elements. Accessing elements in a HashSet is O(1) complexity. The overall time-complexity is O(n) for the linear traversal of the array elements."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this: (1)use two HashSets instead of one HashMap, one for those numbers occurred odd times so far, let's call it oddSet, while the other for those occurred even times being evenSet. (2)iterate to next number, if it has been in oddSet, we remove it from oddSet and add it to evenSet, otherwise we add it into oddSet and remove it from evenSet. (3)finally, those numbers that occurred odd times are all in oddSet."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"XOR  works when there is exactly one number that occurs odd number of times and also there should not be any 0 in the array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why not doing it like sql?  You can use group by the same number with count. Then return the number that has odd count? of course, if this is an interview, they probably won't let you use the easy and best way to do it unless you interview for microsoft.  Lambdas in C# str.GroupBy(n => n).Select(s => new {num = s.Key, count = s.Count()}).Where(g => (g.count %2) != 0);  you can use Quaere  in Java."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include    int getOddOccurrence(int ar[], int ar_size) {      int i;      int res = 0;       for (i=0; i < ar_size; i++)              res = res ^ ar[i];             return res; }   /* Diver function to test above function */ int main() {      int ar[] = {2, 3, 5, 4, 5, 2, 4, 3, 5, 2, 4, 4, 2};      int n = sizeof(ar)/sizeof(ar[0]);      printf(\"%d\", getOddOccurrence(ar, n));      return 0; }   But it works only for +ve integers"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Find oddnumber in array public Set getListOfOddNumbers(int[] number) {  Set oddNumbersSet = new HashSet (number.length);  if(number.length<0 || number==null)  {   return oddNumbersSet;  }    int i;  //Iterate each element in the array  for(i=0;i     if(oddNumbersSet.contains(number[i]))   {    oddNumbersSet.remove(number[i]);    }   else   {    oddNumbersSet.add(number[i]);   }  }  return oddNumbersSet;   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Find oddnumber in array \npublic Set getListOfOddNumbers(int[] number) \n{ \n Set oddNumbersSet = new HashSet (number.length); \n if(number.length<0 || number==null) \n { \n  return oddNumbersSet; \n } \n  \n int i; \n //Iterate each element in the array \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Find oddnumber in array \npublic Set getListOfOddNumbers(int[] number) \n \n Set oddNumbersSet = new HashSet (number.length); \n if(number.length<0 || number==null) \n  \n  return oddNumbersSet; \n  \n  \n int i; \n //Iterate each element in the array \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Find oddnumber in array \npublic Set getListOfOddNumbers(int[] number) \n \n Set oddNumbersSet = new HashSet (number.length); \n if(number.length<0 || number==null) \n  \n  return oddNumbersSet; \n  \n  \n int i; \n //Iterate each element in the array \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Find oddnumber in array \npublic Set getListOfOddNumbers(int[] number) \n \n Set oddNumbersSet = new HashSet (number.length); \n if(number.length<0 || number==null) \n  \n  return oddNumbersSet; \n  \n  \n int i; \n //Iterate each element in the array \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Find oddnumber in array \npublic Set getListOfOddNumbers(int[] number) \n \n Set oddNumbersSet = new HashSet (number.length); \n if(number.length<0 || number==null) \n  \n  return oddNumbersSet; \n  \n  \n int i; \n //Iterate each element in the array \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Find oddnumber in array \npublic Set getListOfOddNumbers(int[] number) \n \n Set oddNumbersSet = new HashSet (number.length); \n if(number.length<0 || number==null) \n  \n  return oddNumbersSet; \n  \n  \n int i; \n //Iterate each element in the array \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Find oddnumber in array \npublic Set getListOfOddNumbers(int[] number) \n \n Set oddNumbersSet = new HashSet (number.length); \n if(number.length<0 || number==null) \n  \n  return oddNumbersSet; \n  \n  \n int i; \n //Iterate each element in the array \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"when you have a new number, just to search if it's already in the hashmap, 1) if it's in the hash map, delete it. 2) otherwise, add it to the hash map At the end, all the numbers in the hash map should have odd occurrences."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Use radix sort, complexity is O(n). Then scan the list again."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"If there is only one number which appears odd number of times you can  XOR all numbers and at the end you will get the 'odd' number. In you example there are multiple 'odd' numbers 11,0,-2 so you have to count them. To do that you can use HashMap or to save some space sort numbers and keep running counter."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5198021759336448","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"10","title":"Give 2 arrays of size 7 and 3 which are sorted such that the last 3 blocks in first array are empty, merge the arrays in a sorted manner in the most efficient way. E.g:-  a[7] = [4, 10, 11, 20__, __, __] b[3] = [1,3,7]","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"merge sort from right to left, placing the result in \"a\" as you go. return a."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Set two pointers at the very last number of the two arrays. Compare with the two numbers at the pointers, put the bigger one at the end of first array and move that pointer one left. Continue this process until both pointer move at the head of the arrays."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* \na[] is the bigger array;  \nb[] is the smaller array;  \nn is the size of bigger array; \nm is the size of smaller array \n*/ \nmerge(int a[], int b[], int n, int m) \n{ \n int c[n]; \n int i = n-m-1; \n int j = m-1; \n int k = n-1; \n while(i>=0 && j>=0 && k>=0) \n { \n  if(a[i] > b[j]) \n  { \n   c[k] = a[i]; \n   i--; \n  } \n  else \n  { \n   c[k] = b[j]; \n   j--; \n  } \n  k--; \n } \n if(i<0) \n { \n  while(j>=0 && k>=0) \n  { \n   c[k] = b[j]; \n   k--; \n   j--; \n  } \n } \n else if(j<0) \n { \n  while(i>=0 && k>=0) \n  { \n   c[k] = a[i]; \n   k--; \n   i--; \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int[] mergeSortedArray(int[] array1, int sizeA, int[] array2) {  int i=sizeA;  int j = array2.length-1;  int k = array1.length -1;    while(k>=0 && i>=0 && j>=0)  {   if(array1[i] > array2[j])   {    array1[k]=array1[i];    k--;    i--;   }   else   {    if(j>=0)    {    array1[k]=array2[j];    }    k--;    j--;   }     }  return array1; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The empty space in a is equal to the number of element in b, so we can merge from last element without extra space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) \n{ \n int[] arr1=new int[]{7,10,11,20,0,0,0}//0 at the end should be assumed as empty space \n int arr2 = new int[]{1,3,7}; \n  \n int i2=arr2.length() -1; \n int i1 = arr1.length()  -1 - i2; \n int j = arr1.length()-1; \n \n while(i1>0 && i2 > 0 && j > 0) \n { \n  if(arr1[i1] > arr2[i2])   \n    arr[j--] = arr[i1--]; \n  else \n    arr[j--] = arr[i2--]; \n } \n \n if(i2>=0) \n { \n  while(i2>=0) \n  { \n   arr[j--] = arr[i2--] \n  } \n } \n \n if(i1>=0) \n { \n  while(i1>=0) \n  { \n   arr[j--] = arr[i1--] \n  } \n } \n \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static int a[7] = {4, 10, 11, 20, 0, 0, 0}; static int a_len = 4; static int b[3] = {1, 3, 7};  void merge_sort() {         int store_pos = 6;         int a_cur = a_len-1;         int b_cur = 2;         while(a_cur >= 0 && b_cur >= 0) {                 if (a[a_cur] > b[b_cur]) {                         a[store_pos--] = a[a_cur--];                 } else {                         a[store_pos--] = b[b_cur--];                 }         }          if (a_cur < 0) {                 memmove(a, b, (b_cur+1)*sizeof(int));         } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Are we allowed to use O(1) extra space?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4845432031150080","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"9","title":"Given a linked list like a1-a2-a3-a4-b1-b2-b3-b4. Convert it into a1-b1-a2-b2-a3-b3-a4-b4.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"reArrange(ll){ \naList= ll; \n while(ll.data != b1 ) \n  ll = ll.next; \nbList = ll; \nll = aList; //initialized ll to original start \n \nwhile( aList != null && bList != null ){ \n aListNextNode = aList.next; \n aList.next = bList ; \n aList = aListNextNode; \n bListNextNode = bList.next; \n bList.next = aListNextNode; \n bList = bListNextNode; \n} \nreturn ll; \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static Node transformList(Node head, int n){   Node temp1, temp2, midNode=null;   Node start = head;   temp1 = head;   for(int i=0; i   midNode = temp1.getNext();    temp1 = midNode;   }      Node swapIndex = reverseList(midNode.getNext());   System.out.println(\"swap is \"+swapIndex.data);   midNode.setNext(null);      return mergeList(head, swapIndex);     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node startNode = head; \n \nNode midNode = getMidNode(head); \n \nwhile(startNode!=null&&midNode!=null) \n{ \nNode startTemp = startNode.getNext(); \nNode midTemp = midNode.getNext(); \nstartNode.setNext(midNode); \nmideNode.setNext(startTemp); \nstartNode = startTemp; \nmidNode = midTemp; \n \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void transform(SingleLLNode header) { \n        int count = 0; \n        SingleLLNode current = header; \n        while(current != null) { \n            count++; \n            current = current.next; \n        } \n        int start = count/2,iteration = 1; \n        while(start > 1) { \n            int i = 0; \n            current = header; \n            while(i< start) { \n                current = current.next; \n                i++; \n            } \n            i = 0; \n            while (i < iteration) { \n                int temp = current.data; \n                current.data = current.next.data; \n                current.next.data = temp; \n                i++; \n                current = current.next.next; \n            } \n            iteration++; \n            start--; \n        } \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class Link { \n public String data; \n public Link next; \n \n Link() { \n \n } \n \n public Link(String data) { \n  this.data = data; \n \n } \n} \n \nclass InsertLinkList { \n private Link first; \n \n InsertLinkList() { \n  first = null; \n } \n \n public void intializeLink(String data) { \n  Link a = new Link(data); \n  if (first == null) { \n   first = a; \n   a.next = null; \n  } else { \n   a.next = first; \n   first = a; \n  } \n \n } \n \n public void display(InsertLinkList lin) { \n  while (first != null) { \n   System.out.println(first.data); \n   first = first.next; \n  } \n } \n \n public void display1(InsertLinkList lin) { \n \n  Link first1 = first; \n  Link first3 = first; \n \n  while (first1.next != null) { \n   System.out.println(first3.data); \n   first1 = first3.next.next.next; \n   System.out.println(first1.data); \n   first3 = first3.next; \n \n  } \n } \n} \n \npublic class LinkedLista1b1a2b2 { \n \n public static void main(String[] args) { \n \n  InsertLinkList lin = new InsertLinkList(); \n  lin.intializeLink(\"b3\"); \n  lin.intializeLink(\"b2\"); \n  lin.intializeLink(\"b1\"); \n \n  lin.intializeLink(\"a3\"); \n  lin.intializeLink(\"a2\"); \n  lin.intializeLink(\"a1\"); \n \n  lin.display1(lin); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Output-  a1 b1 a2 b2 a3 b3"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node rearrange(Node head, Node b1) {  Node p1 = head;  Node p2,p2_start = head;    if (head == null)   return;  while(p1 != b1)   p2 = p2.next;  Node p1_end = p2;  while(p1!=p2_start && p2!=null)  {   Node t1 = p1.next;   Node t2 = p2;      if (t2!=null)     p1.next = t2;   else    //if number of b < number of a   {    p1_end = null;    return head;   }   if (t1!=p2_start)   {    p1.next.next = t1;    p1 = p1.next.next;    p2 = p2.next;   }   else    //if number of a < number of b   {    p1.next = p2;    return head;   }  }  return head; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* This code works for any no of nodes */ \n \nalternate(struct list *a) \n{ \n struct list mid,temp,*fptr=a,*sptr=a;  \n int i =0;  \n /* find the middle of the list  */ \n while(fptr->next !=  NULL) \n { \n  if(i==0) \n  { \n   fptr=fptr->next; \n   i=1; \n  }else \n  { \n   fptr=fptr->next; \n   sptr=sptr->next; \n   i=0; \n  } \n } \n  \n fptr = a; \n temp = fptr->next; \n mid = sptr; \n /* Now sptr in the middle of the list and fptr start of the list */ \n while(sptr) \n { \n  if (sptr == fptr || sptr == temp) \n   break; \n  fptr->next = sptr; \n  sptr = sptr->next; \n  fptr = fptr->next; \n  if (!sptr || temp == mid) \n   break; \n  fptr->next = temp; \n  temp = temp->next; \n  fptr = fptr->next; \n   \n } \n if(sptr) \n  fptr->next = sptr; \n} \n \nTime Complexity : O(n) Space Complexity : O(1) \n \nSame can be achieved by Dynamic programming but takes O(nlog(n))"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5117473942667264","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"A Desktop Java application which was working till yesterday crashes today --- no help from Java debugger. How do u go about debugging this?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Delta :- Change in the environment would be my primary concern. Like , Updates from the OS or the dependent library."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"1- how about enabling java console and run the app again, then see what console says on application crash. 2- Checking the application logs (if available). 3- Checking java environment (including path, CLASS_PATH etc) for possible issues."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If there is crash of application means that application gave core dump . So analyze the core dump  to know the cause . There can be many reason from crash .. h/w bus fault/socket closures etc .."}]}}]