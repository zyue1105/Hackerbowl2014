[{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5811291046281216","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"Asked to explain how to check Binary tree is BST?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public boolean isValid(Node root) { \n     return isValidBST(root, Integer.MIN_VALUE, \n          Integer.MAX_VALUE); \n} \nprivate boolean isValidBST(Node node, int MIN, int MAX) { \n     if(node == null) \n         return true; \n     if(node.value > MIN  \n         && node.value < MAX \n         && isValidBST(node.left, MIN, node.value) \n         && isValidBST(node.right, node.value, MAX)) \n         return true; \n     else  \n         return false; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do inorder traversal of the tree if the inorder traversal is sorted then it is a BST otherwise not."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4702055612547072","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"0","title":"Find Nodes which are at \"K\" distance from given node."}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6531642961166336","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"Find In order predecessor in BST.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Right most child of the left subtree of a given node is the inorder predecessor."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5410604957302784","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"asked me about assembly line problem.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"geeksforgeeks.org/dynamic-programming-set-34-assembly-line-scheduling/"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6001815795531776","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"asked me to solve Knapsack Problem","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"geeksforgeeks.org/dynamic-programming-set-10-0-1-knapsack-problem/"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5472001514799104","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"Asked to explain how to check Binary tree is BST?  then asked me to write whole code of it.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the inorder traversal of a binary tree is in sorted order then the tree is a binary tree."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6614501470240768","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"0","title":"Find Nodes which are at \"K\" distance from given node. explain logic and write full code with all boundary conditions."}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4673691648524288","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"Find In order predecessor in BST. explain logic and write full code with all boundary conditions.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Psuedocode for Predecessor of Tree"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5740921664569344","download_status":"DOWNLOAD_DONE","votes":"-9","answersCount":"2","title":"Given n array return true if there exist a element from each array whose sum is zero","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For those who r not getting the question.i will explain.nyway nice question karan ok now for those who r not getting the question,this question is about picking one element from  each array of total n array and add up these number to make it zero.hope it is clear.  will post solution soon. I have a solution but that is not proper (as we make n^n different set ,among these set we have to find one set whose sum is zero) but this way is not proper."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"karans199228 ? why do the useless question posters usually have stupid account names like this ?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5945705571024896","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"11","title":"Compare time complexity of insert and search functions in HashMap, Array, Linked List and Queue","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"[ Avg / Worst Case ] \n                                     Insert                 Search \nHMap                            1/n                        1/n    \nUnorderedArray            1/1                        n/n     \nUnordLinkedList            1/1                        n/n \nQueue"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"HashMap : Insert - O(1), search (by key) O(1) Array : Insert - O(1), search O(n)  Linked List : Insert - O(n), search O(n) Queue : Insert (by front pointer) - O(1), search O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"HashMap Search - O(1) uses non-duplicate keys, map.get(key),                                   Insert O(1) map.put(key,value)  Array- Insert (at the end) O(1), Insert in the middle O(n), Search O(n)  LinkedList- Insert O(1), Search O(n) Queue: same as LinkedList"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think we should consider sorted and unsorted situations for array, linked-list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if the queue uses array internally  Insert - O(1), search O(n), dequeueO(1) If the queue uses hash map internally Insert - O(1), search O(1), dequeueO(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"------------------  |Insert*              |  Search -------------------|----------------------------------------------------------- HashMap | O(1)   | O(1) --------------------------------------------------------------------------------  Array        | O(1)   | O(n) --------------------------------------------------------------------------------  LinkedList | O(1)   | O(n) --------------------------------------------------------------------------------  Queue      | O(1)   | O(n) --------------------------------------------------------------------------------  *Assuming insertion at the end"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5674452213825536","download_status":"DOWNLOAD_DONE","votes":"-5","answersCount":"29","title":"Find largest element in an array","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"#include  \n \nmain() \n{ \n        int a[5] = {10,2,100,50,101},index=0,big; \n        big = a[0]; \n \n        for(index = 1;index < 5;index++) \n        { \n                if(a[index] > big) \n                { \n                        big = a[index]; \n                } \n        } \n \n        printf(\"biggest element :%d\\n\",big); \n} \n \noutput : biggest element :101"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Quicksort will be best. After the first iteration the pivot is in the right position and all values left are smaller than pivot and all values to the right are larger than the pivot. Now do the same iteration again on the right subarray till you set the last element. Avg: O(logN). Worst case (already sorted array): O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"So, there's plenty of explanation on how/why to do a QuickSort, but in my opinion, something MAJOR is left out here, which is to *Ask your interviewer questions before answering!* QuickSort can quickly become the wrong answer with some detail.  1. Is the list sorted? Probably not, but worst case you get \"no\" and best case, you're applauded for being thorough.  2. Can I sort the list? And if not, do I have the memory to copy then sort the list? A no here means that again QuickSort is out.  3. How big is the list? If you've got an int array list of a constant size 5, QuickSort is sort of using the broad sword when the butter knife will do.  All a bit pedantic here perhaps, but keeping this mindset is vital."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do a quicksort.  After the first iteration the pivot is in the right position and all values left are smaller than pivot and all values to the right are larger than the pivot.  Sort the array left of the pivot and you have the largest element, or just do comparisons. Best case, if pivot is the largest number. Worst case, if pivot is the smallest number. Average case, O(log N)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a is an array max=a[1] for i 2 to n  if(a[i]>max)   max=a[i]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void main() {  int max,i=0,a[10];  max=a[0];  while(i<10)  {   if(max=a[i])    max=a[i];  }  printf(\"max=%d\",max); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.If the array is sorted the largest element can be found at the end of array 2.If the array is not sorted traverse through the array find the max 3.If there are frequent insert options that can be taking place on the array along with the finding largest element,          -   sort the array first          -   do the insert options in the sorted order          -   find largest element at the end of array"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the input sequence has been sorted,use binary search.If not,i think there should just has a algorithm with O(N)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the input sequence has been sorted,use binary search.If not,i think there should just has a algorithm with O(N)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Have you tried using a hashmap?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I see people have commented using Bubble Sort. For those people who say Bubble Sort is stupid, How about you do only one iteration of Bubble Sort which will be O(n)[Now please note I am not saying n iterations of Bubble Sort] and the last element will always be the max. Think about it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Given an array of arbitrary length int i = 0; int max = array[0]; while(array[i] != '\\0') {  if(array[i] > max)  {   max = array[i];  }  i++; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"1. Bubble sort in increasing order 2. Linear scan to end of array, and grab last element (which should be max)  O(n^2) + O(n) . Easy."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Hi, Please help me to understand why we need of bubble sort. This can be achieved simply traversing array once which is O(n-1). {{class Maxinarray {   public static void main(String[] args) {     int[] a={1,5,6,8,90,4,3,2,2};  int max=a[0];  for(int i=1;i {  if(a[i]>max) max=a[i];  }  System.out.println(\"Max is=\"+max);  } } }}}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4874896538599424","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"55","title":"An integer array contains elements in increasing order till some point and then decreasing order , return  the index of maximum number. Solution should be less than O(n). Ex - {1,2,3,4,5,3,1}","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Finding maximum of a convex function. Hint: ternary search."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class FindMax { \n \n public int getMax(int[] arr) \n { \n  int r = getMaxRecursive(arr, 0 , arr.length-1); \n  return r; \n } \n  \n // a simple binary search O(logn) \n private int getMaxRecursive(int[] arr, int start, int end) \n { \n  if (start > end) \n  { \n   return -1; \n  } \n   \n  int mid = (start + end)/2; \n  if ( (mid-1) >= 0 && arr[mid] > arr[mid-1] \n        && (mid+1) < arr.length && arr[mid] > arr[mid+1]) \n  { \n   return arr[mid]; \n  } \n   \n  // increasing case e.g. 1,2,4, so the key must be in right half  \n  if ((mid-1)>= 0 && arr[mid-1] < arr[mid] \n       && (mid+1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"iterate the array till,next element is greater then current element. if next element is less then current element return current element."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int t=0; int n; int a[]=new int[n];        // 'a' is array name & 'n' is it's size   for(int i=0;i   {     if(t<=a[i])     {      t=a[i];      }      else     {      System.out.println(i-1);      break;     }    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here is solution for this problem in O(log n ).  it makes use of binary search."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \nusing namespace std; \n \nint findMax(vector& A) \n{ \n    int lb = 0; \n    int rb = A.size() - 1; \n \n    while (lb < rb) { \n        int m = (rb - lb) / 2 + lb; \n \n        if (A[m] < A[m + 1]) \n            lb = m + 1;  \n        else  \n            rb = m; \n    } \n \n    return lb; \n} \n \nint main() \n{ \n    vector A = {1,2,3,4,5,9, 11, 88, 4, 3,1}; \n \n    cout << \"max = \" << A[findMax(A)] << endl; \n    return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int findMaxIndex(int a[],int count) {  for(int i=0; i {   if(a[i] > a[i+1])    return i;  }  return count-1; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int findMaxIndex(int a[],int count) \n{ \n for(int i=0; i a[i+1]) \n   return i; \n } \n return count-1; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Complexity : O(log n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static int getMaxIndex(int[] arr) { \n int left=0,right = arr.length-1; \n //arr[left] >= anything to left of it, arr[right] >= anything to right of it \n \n while(leftarr[right]) return left; else return right; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"interpret the array as a min heap, return the index where the min heap invariant is violated"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"return the 2*(last index+1) where the min heap variant is valid... not the index where the invariant is violated."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"arr = [2, 3, 4, 5, 6, 6, 3, 2, 1]  a,b = 0, len(arr)  while a != b:     e = int((a+b)/2)     # increasing or equal                                                                                                                                                                                                                                                                                                          if arr[e+1] - arr[e] > 0:         a = e+1     else:         b=e  print(\"Array: \", str(arr)) print(\"Maximum: \" + str(arr[a]))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"arr = [2, 3, 4, 5, 6, 6, 3, 2, 1] \n \na,b = 0, len(arr) \n \nwhile a != b: \n    e = int((a+b)/2) \n    # increasing or equal                                                                                                                                                                                                                                                                                                      \n    if arr[e+1] - arr[e] > 0: \n        a = e+1 \n    else: \n        b=e \n \nprint(\"Array: \", str(arr)) \nprint(\"Maximum: \" + str(arr[a]))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int findHighest(int[] array,int left,int right) {   int mid=(left+right)/2;      if(array[mid] > array[mid+1]) {    return array[mid];   } else if(array[mid] > array[mid-1]) {    left=mid+1;   } else {    right=mid;   }      return findHighest(array, left, right);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nint main(){ \n \n int a[] = {2, 3, 4, 5, 6, 6, 3, 2, 1}; \n int i; \n for( i=0;i<(sizeof(a)/sizeof(int));i++){ \n  if(a[i]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Will work in any case"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n \nint getIndex(int a[],int left,int right) \n{ \n    if(left>right) \n      return left; \n    int mid=(left+right)/2; \n    if(a[mid]>=a[mid-1] && a[mid]>=a[mid+1]) \n       return mid; \n    else if(a[mid]>=a[mid-1]) \n       return getIndex(a,mid+1,right); \n    else \n       return getIndex(a,left,mid-1); \n} \n \nint main() \n{ \n    int a[100],i,n; \n    scanf(\"%d\",&n); \n    for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include using namespace std; int main() {int a[20]; cout<<\"Enter the numbers in the array\"<for(int i=0;i<20;i++) {cin>>a[i];         } int j; while(a[j+1]>a[j]) {j=j+1; } cout<system(\"pause\"); return 0;     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int getMaxNumber(int [] array){ \n  int start = 0; \n  int end = array.length-1; \n  while ( start <= end){ \n   int mid = start + (end -start)/2; \n   if ( mid == array.length-1)return -1; \n   if(  array[mid] > array[mid-1] && array[mid] > array[mid+1]){ \n    return array[mid]; \n   }else \n   if( array[mid] < array[mid+1]){ \n    start = mid+1; \n   }else if( array[mid] < array[mid-1]){ \n    end = mid-1; \n   } \n  } \n  return -1; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Indexof {   /**   * @param args   */  public static void main(String[] args) {   // TODO Auto-generated method stub   int array[]={1,2,3,4,5,6,7,8,9,11,23,24,35,67,89,56,45,34,23,12,10,9,8,7,6,5,4,3,2};   for(int i=0;i   if(array[i]-array[i+1]>=0){     System.out.println(i);     break;    }   }  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Indexof { \n \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n  // TODO Auto-generated method stub \n  int array[]={1,2,3,4,5,6,7,8,9,11,23,24,35,67,89,56,45,34,23,12,10,9,8,7,6,5,4,3,2}; \n  for(int i=0;i=0){ \n    System.out.println(i); \n    break; \n   } \n  } \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include   int findMax(int* array, int size, int base) {   if (size == 2)   {     if (array[1] > array[0])       return base + 1;      return base;   }    if (size == 1)     return base;    int mid = size / 2;   if (array[mid + 1] > array[mid])   {     return findMax(array + mid + 1, size - mid - 1, mid + 1);   }   else   {     return findMax(array, mid + 1, 0);   } }  int main() {   int array[] = {7,8,1,2,3,4,5};    std::cout << findMax(array, sizeof(array) / sizeof(int), 0);   return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"u can do this using binary search in log(n) time. As its given first increase then decrease mean u have to sorted array in one array.  Do binary search and find if the mid number if it is greater than its left element and that of right ,u r done ,else if left is greater and right is also greter then set low as mid,and similarly for other side"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I don't intend to be negative. However, I am finishing up my software engineering degree and am beginning my job search I came across this site for practice problems. What I would like to know is this seriously the level of my competition for jobs, there seems to be a complete lack of understanding of basics including big O notation and the use of data structures and how they relate to solving a problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here's a solution in python"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package com.practice; \n \n \n \npublic class Practice2 { \n  \n public static final void main(String[] args){ \n   \n  int arr[] = {1,2,3,4,5,5,3,1}; \n   \n  int  p = arr.length/2; \n   \n  if(arr[p-1] <= arr[p] && arr[p] >= arr[p+1]) { \n    \n   System.out.println(p); \n    \n    \n  } else if( arr[p-1] >= arr[p] ) { \n   for(int i = p-1 ; i >= 0; i-- ) { \n    if(arr[i] > arr[p]) { \n     p--; \n    } else { \n     System.out.println(p); \n     break; \n    } \n   } \n  } else if (arr[p+1] >= arr[p]) { \n   for(int i = p+1 ; i < arr.length; i++) { \n    if(arr[i] > arr[p]) { \n     p++; \n    } else { \n     System.out.println(p); \n     break; \n    } \n   } \n  } \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Another non recursive solution.  int FindMax(int *arr, int start, int end) {  int subStart = start;  int subEnd = end;   while (subStart < subEnd)  {    int median = (subStart + subStart) / 2;    if(arr[median] > arr[median+1] && arr[median] >= arr[median-1])    return median;      // Let us assume a left case   if( arr[median] <= arr[median+1] )    subStart = median+1;   else if( arr[median] > arr[median+1] && arr[median] < arr[median-1])    subEnd = median-1;  }   return -1; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include void main() {  int arr[]={2,3,6,7,9,10,45,60,70,80,100,55,50,10,9,8,7,6,5,4,3,2,1,0,-1};    int a=sizeof(arr);    int b=sizeof(int);    int high=a/b;    printf(\"%d\\n\",high);    int low=0;    int mid;    for(int i=0;i<(high+low)/2;i++)    {     mid=(high+low)/2;       if(arr[mid]>arr[mid-1] && arr[mid]>arr[mid+1])       {        printf(\"%d\",arr[mid]);          break;       }     else if(arr[mid]>arr[mid-1])        low=mid;       else if(arr[mid]>arr[mid+1])        high=mid;    }    getch(); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"b = [1,2,3,4,5,5,10,11,32,23,12,3,2,1,0] \n \ndef findMaxIndex(): \n    mx = b[0] \n    mxidx = 0 \n    for i in range (1, len(b)): \n        if b[i] >= mx: \n            mx = b[i] \n            mxidx+= 1 \n            continue \n        else: \n            break \n    print 'Max Index is...', mxidx \n    print 'Max number is...', b[mxidx] \n         \nfindMaxIndex()"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Can be done in logn time... Divide the array in two equal parts and compare the numbers at end of first part and begining of second part. If the later is greater, continue the same process with second part, else check if a[i]>a[i-1], i is the ans otherwise continue the same with first part until u get a point i where a[i-1]a[i+1]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public static void main(String[] args)    {        int[] arr = {1,2,3,4,5,3,1};        Arrays.sort(arr);        int result = arr[arr.length-1];        System.out.println(result);     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Easiest and best answer ;0))"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6434700885229568","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"9","title":"An integer array contains elements in increasing order till some point and then decreasing order , return  the index of maximum number. Solution should be less than O(n).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"current_max = 0 \nfor(i = 0; i < array.length; i++){ \n if(list[i] < current_max){ \n  return i-1 \n } \n current_max = list[i] \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for ( i = 0 ; i < array.legth - 1  ;  i ++ ) \n{ \n       if(array[i] > array[i+1]) \n      return i; \n    else  if( array[ array.length - 1 - i ]   > array[ array.length - i - 2 ] ) \n      return i; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Main {     public static void main(String[] args) throws Exception     {          int[] array = {1,2,2,2,3,3,4,5,6,5,3,3,2,2,2,1};          int left = 0;         int right = array.length - 1;         while (left != right)         {             if (array[left] < array[right])                 left++;             else                 right--;         }         System.out.println(left);     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"perform binary search. Find center, compare with its adjacent elements and recursively search on larger side."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Dupe thread."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int getBiggestInt(int[] array, int start, int end){ \n  int mid_index; \n  int ret_value; \n  int left_value = -1; \n  int right_value = -1; \n  int current_index; \n  boolean bLeft = true; \n  boolean bRight = true; \n   \n  if(end-start == 1) \n   ret_value = array[start]; \n  else if(end-start == 2){ \n   ret_value = array[start]>=array[start+1]?array[start]:array[start+1]; \n  }else{ \n   mid_index = (start+end)/2; \n   current_index = mid_index - 1; \n   while(bLeft && current_index >= start ){ \n    if(array[mid_index] > array[current_index]){ \n     left_value = array[mid_index]; \n     bLeft = false; \n    }else if (array[mid_index] == array[current_index]){ \n     current_index --;       \n    }else{ \n     left_value = getBiggestInt(array,0,current_index + 1); \n     bLeft = false; \n    } \n   } \n   current_index = mid_index + 1; \n   while(bRight && current_index < end){ \n    if(array[mid_index] > array[current_index]){ \n     right_value = array[mid_index];           \n     bRight = false; \n    }else if (array[mid_index] == array[current_index]){ \n     current_index ++; \n    }else{ \n     right_value = getBiggestInt(array,current_index,end); \n     bRight = false; \n    } \n   } \n   ret_value = left_value > right_value ? left_value : right_value; \n  } \n  return ret_value; \n } \n \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"b = [1,2,3,4,5,5,10,11,32,23,12,3,2,1,0] \n \ndef findMaxIndex(): \n    mx = b[0] \n    mxidx = 0 \n    for i in range (1, len(b)): \n        if b[i] >= mx: \n            mx = b[i] \n            mxidx+= 1 \n            continue \n        else: \n            break \n    print 'Max Index is...', mxidx \n    print 'Max number is...', b[mxidx] \n         \nfindMaxIndex()"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please check the below code..  public class ArrayInIncreasingDecreasingorder {   public static void main(String args[]){   int arr[] = {1,2,9, 5,4,3,2};   System.out.println(\"Largest index :\" +findLargestIndex(arr, 0, arr.length -1));  }   private static int findLargestIndex(int[] arr, int low, int high) {   if (high < low)  return -1;    int mid = (low + high)/2;         System.out.println(low+\" :\"+high+\": \"+mid);      if(mid < high && arr[mid] == Math.max(arr[mid], arr[mid+1]) &&     arr[mid] == Math.max(arr[mid], arr[mid-1])){     return mid;   }else if(mid > low && arr[mid-1] == Math.max(arr[mid], arr[mid-1]) &&     arr[mid-1] == Math.max(arr[mid-1], arr[mid-2])){    return (mid-1);   }else if(arr[mid]>= arr[low]){    return findLargestIndex(arr, mid+1, high);   }else{    return findLargestIndex(arr, low, mid-1);   }  } }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4790221258358784","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"13","title":"Given a larger integer buffer/array (say size, x), now given a window size (say, n) and a number (say, k). Windows starts from the 1st element and keeps shifting right by one element. The objective is to find the minimum k numbers present in each window.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"One simple approach is to track index of current min, while sliding window. Say array is  [5, 2, 1, 3, 6, 7, 8, 2] , n = 4, k = 5 loop i = 0; i < k; So when i=0: you need to find min([5,2,1,3]) = 1 at j= 2  Now, you don't need to re-calculate min as long as i <=j < k That is for i = 0..2, min =  [1,1,1] Now at i = 3: window is [3, 6, 7, 8] : min = 3 at j = 3 i = 4: [6,7,8,2]: min = 2 at j = 8  The worst case run time would be O(k*n) when the entire array X is sorted in increasing order. However, if we assume random uniform distribution it will be O(m*n) where m < k  Above algorithm can be modified a little to use a min-Heap of size k, where each node stores"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use a binary search tree for storing the n elements. Basically the window size. Use a hash map with index in the original array as the key anf the address ot the poniter value in the BST as the value. For printing the k minimum elements just have to do in-order traversal of the tree. And as the qindow slides keep on deleting and adding the nodes to the BST. The complexity for insertion in the BST is logn and deletion is also logn. For finding the element in the hashmap would take o(1). The creation of BST would take o(nlogn)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void highestFeedPerSecond(int[] array,int k) throws InterruptedException { \n  LinkedList minimum=new LinkedList(); \n  for(int i=0;i myMinQueue) { \n  int minimum=Integer.MAX_VALUE; \n  for(Integer myInteger:myMinQueue) { \n   if(myInteger"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \n#include  \n#include  \n#include  \n#include  \nusing namespace std; \n \n/* \n * @param is: input string stream \n * @param N:  window size \n * @param K:  The biggest K elements in the window \n */ \nvoid findKMin(stringstream & is, int N, int K) \n{ \n    assert(N >= K); \n     \n    // all the numbers in the window in the original order \n    queue::iterator> Q;   \n     \n    // The numbers in the window in sorted order \n    multiset S; \n     \n    int x; \n     \n    while (is >> x) { \n        if (Q.size() == N) { \n            auto pos = Q.front(); \n            Q.pop(); \n            S.erase(pos); \n        } \n              \n        auto pos = S.insert(x); \n        Q.push(pos); \n         \n        if (Q.size() == N) { \n            auto pos = S.begin(); \n            for (int i = 0; i < K; i++) \n                cout << *pos++ << \" \"; \n            cout << endl; \n        } \n    } \n} \n \nint main() \n{ \n    string data(\"5 2 1  3  6  7  8  2 9 1 3 11 13 15 16\"); \n     \n    cout << \"data = \" << data << endl; \n     \n    stringstream ss(data); \n    findKMin(ss, 5, 4); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Build a max heap of size k which will hold the min k elements and the max of them at the root. When new integer comes compare it with root and if less than root, then delete root and insert the new element and heapify downwards. The complexity will be O(x(log k))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@nharryp that doesnt work what happens if the element that was left out of k in previous window of N is now a candidate for k elements in the current window. Your algorithm has no way to track this.  Maintaining heap of window size in an array and returning first k elements of the array is something that would work"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@nharryp Your solution would be correct if it was not a sliding window, but just an increasing window."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class ArrayInWindows {   /**   * @param args   */  public static void main(String[] args) {   // TODO Auto-generated method stub   int arr[] = {3,4,5,6,7,2,1,10,9,5};   int n=3, k=5;   System.out.println(\"Minimum elements of \"+k+\" windows - \");   int min = arr[0];   for(int i=1; i<(n+k-1); i++){    if(i >= arr.length) break;    if(arr[i] < min){     min = arr[i];    }    if(i>n-2) System.out.print(\" \"+min);   }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please ignore the above code..  Below code is correct  /**  *   */ package com.arrays;  /**  * @author adityagaitonde  *  */ public class KMinimumElements {      private static void buildMaxHeap(int[] arr, int k) {    int heapSize = k;    for(int i= k/2; i>= 0; i--){     maxheapify(arr, i, heapSize);    }   }      private static int removeMax(int[] arr, int n, int heapSize) {     swap(arr, 0, n);      maxheapify(arr, 0, heapSize);     return heapSize;   }      private static void maxheapify(int[] arr, int index, int heapSize) {    int left = (index << 1) +1;    int right = left +1;        int largest = -1;    if(left < heapSize && arr[left] > arr[index]){     largest = left;    }else{     largest = index;    }    if(right < heapSize && arr[right] > arr[largest]){     largest = right;    }        if(largest != index){     swap(arr, largest, index);     maxheapify(arr, largest, heapSize);    }   }      private static void swap(int arr[], int index1, int index2) {    int temp = arr[index1];    arr[index1] = arr[index2];    arr[index2] = temp;   }    public static void main(String[] args) {    int arr[] = {3,4,5,6,7,2,1,10,0,5};    int n=6, k=3;    for(int i = 0; i < arr.length; i++){     if(i == (k-1)){      buildMaxHeap(arr, k);     }else if(i > k-1){      if(arr[i] < arr[0]){       removeMax(arr, i, k);      }     }     if(i>= n-1) printValues(arr,k);    }   }    private static void printValues(int[] arr, int k) {    System.out.println(\"----------------------------------------------------\");    for(int i=0; i    System.out.print(arr[i]+\" \");    }    System.out.println();   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi, Could anyone please explain the question. I did not understand it.  We have a large array n a window which is a small array. One edge of the window is at the beginning n now it slides Right by one position.   This is what I could understand from the problem statement. Anybody please explain me the question."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5752996830904320","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"30","title":"There is a village in which parent prefer to have at least 1 boy. So they keep doing child until they get their first boy and then they stop doing children. What is ratio of girl/boy in such town after infinite years.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"LOL  :)  You really made this board fully of joy! I like your answer very much. Anyway I will give my way to approve the result."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I believe the answer is - there is eventually no one left. Eventually, you have all boys (whats left of them) and the next generation cannot proceed. This is because as each generation passes, you will have the possibility of having less girls than boys. When that happens, the next set of parents will less than the previous set. The boys who did not get married will die and not replace themselves for the next generation. On an infinite cycle, its inevitable that the boys will reduce. The girls could have been more than the boys in any given generation, but that is inconsequential becuase the excess girls cannot marry. Therefore, the number of boys can never increase."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think it's one, because even you have more boys than girls, but one boy can only married to one girl. So this make the ratio to 1 in infinite years. The boys who don't have wife will die without children."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Expected number of children N = 1/2 + 2/2^2 + 3/2^3 + ...  2N = 1 + 2/2 + 3/2^2 + 4/2^3 + ...  N = 1 + 1/2 + 1/2^2 + ... = 2.  Thus we would expect the ratio of 1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"our typical indian family... boy.. SOLUTION!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming having a village with 64 families.  After they all have their babies, the village will have 32 baby boys and 32 baby girls. The number of boys = number of girls. Now, 32 families who had boys will stop having babies.  Of the remaining 32 families... 16 will have boys and 16 will have girls. The \"total\" number of baby boys  = total number of baby girls = 32+16=48  Now, we have 16 families still going at it... of these, 8 boys and 8 girls will come out. Total number of boys = total number of girls = 32+16+8 = 56  Now, 8 couples will produce 4 boys and 4 girls. We have 60 boys and 60 girls total.  Next, 4 couples will have 2 boys and 2 girls. 62 boys and 62 girls  2 couples left... 63 boys and 63 girls  And finally we have only 1 couple left... Ignoring this pop couple who have had 8 babies in a row... As counter-intuitive as it looks, we can see that the ratio of baby boys/baby girls remains constant."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The ratio is 1. Think about it this way. Given \"N\", \"N / 2\" of families will have a single boy. The other \"N / 2\" will have a girl as a first child.  Now let's assume the second \"N / 2\" give their first-born (girl) to the first \"N / 2\" family. So we have \"N / 2\" families with 1 boy and 1 girl, and \"N / 2\" families where they keep trying until they get a boy. By recursion, you find that the ratio has to be one."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The expected number of boys is 1, since they keep making babies until getting a boy :)  The expected number of children is C = 1/2 + 2/2^2 + 3/2^3 + ... + k/2^k + ...  With some tricks we can find that C = 2.  Thus in average each family have 2 children, 1 boy, 1 girl!  Tricks:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have a different thought. If we consider the fact that human has limited life span, eventually someone will die. In infinite time, don't u think there will be no one left because there there will be less and less girl to match a man?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Probability of having a boy=Probability of having a girl = 1/2  if a family has n children one among them is boy n-1 girls and1 boy  probability of having n children = 1/(2^n) because n-1 fails(n-1 girl children) * 1 pass(a boy)=1/(2^n-1)*1/2  now the expected number of children in each family is E[x]=Summation {number of children*probability of having them}  E[x]=1/2 + 2/2^2 + 3/2^3 + ... + k/2^k + ...  E[x]=2(already proven by many)  this means we can expect 2 children in each family but we know that each family has at least 1 boy that's why they stopped(except infinity case). that is 1 boy and 1girl so ratio is 1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"\"...they keep doing child...\"  What the? That's disgusting!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question asks what will be the population of the village after infinite years. This question has definitely incomplete data. The answer depends on probability for each generation that a given couple will have boy or a girl.   Lets say that for 1st generation (adam and eve) the probability of having boy is 0.25. Which means adam and eve will have to procreate 4 times and 4th child will be a boy. Population after 1st generation will be 4. Now population for 2nd generation also depends on probability of having a boy which can be any number. Hence to predict population for a given generation, we need probability distribution for random variable for the event having a boy which is not given.  If we assume uniform distribution of .25, then the infinite series will not converge and hence the answer is infinity.  The series can converge only if PDF can be such that infinite series can converge.   Hope the answer helps"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"probability will be =1/2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"every male wil have exactly ONE male child,  number of girls may be 0,1,2,3,4,5......till a male child is born.  hence girls go on continuously increasing  , but boys remain the same . hence girls / boys >>>>>>large."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"probability of having:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5434428369141760","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"36","title":"You are given a large set of integers, which are not sorted. Figure out a method to retrieve the largest 1000 elements, in O(n) run time","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Use the selection rank algorithm.  Pick a random element in the array and use it as a ??pivot??. Move all elements smaller than that element to one side of the array, and all elements larger to the other side. ??If there are exactly i elements on the right, then you just find the smallest element on that side. ??Otherwise, if the right side is bigger than i, repeat the algorithm on the right. If the right side is smaller than i, repeat the algorithm on the left for i ??C right.size().  cc book problem"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Technically, you could go through the array 1000 times and each time get the max value which is smaller than the previous max value you had already found. This is exactly This will almost require 2000(n) comparisons.  Another approach, with an extra O(n) space is this: 1) Build a Max-Heap in O(N) time and space (I guess will take around 3n swaps and compares). 2) Extract-Max 1000 time which takes at worst 2000 log(N) time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Loop over the numbers and put them into an array of size 1000. Keep track of the index and value of the lowest number, when you need to replace it, loop over the array for the new lowest.  Should be 1001n or O(n) unless I'm missing something."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include       \n#include  \n#include  \n \nusing namespace std; \n \nconst int K = 1000; \nconst int N = 100000; \n \nint main () { \n    vector v; \n \n    for (int i = 0; i < K; i++) { \n        int d = rand(); \n        v.push_back(d); \n    } \n \n    // create a min-heap with K elements \n    make_heap (v.begin(),v.end(), greater()); \n \n    for (int i = 0; i < N; i++) { \n        int d = rand(); \n \n        // if the new number is greater than the min value of the heap \n        // remove the min value from the heap, and add the new value in  \n        // the heap \n        if (d > v.front()) { \n            pop_heap (v.begin(),v.end(), greater());  \n            v.pop_back(); \n \n            v.push_back(d); \n            push_heap (v.begin(),v.end(), greater()); \n        } \n    } \n \n    sort_heap (v.begin(),v.end(), greater()); \n \n    for (int i : v) cout << i << \" \";  \n    cout << endl; \n \n    return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Define a special data structure backed by doubly linked list with support of following features (1) Add(Element) which can add up to 1000 elements in the list (2) An internal var SIZE to record correct element size and each Add function check SIZE (3) An internal var currentMIN to store current smallest item (4) An internal pointer points to Node storing the var for currentMin (5) When doing add(Element) if element > currentMin, then we append this new element to head of the list and remove the node storing currentMin  After insertion to this list from item 0 to n, then we will get a list storing only the largest 1000 elements"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Find 1001th smallest element in O(n) time using the Kth smallest logic. All the elements on less than this element is the answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"max heap of 1000 size can work.as it take time complexity of n* log(1000) here log(1000) is constant,so time complexity is 0(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We have to use augmented data structure. We have to create a balanced binary search tree. Node structure will be like"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Heap is always the best way to find 'k' min or max numbers....."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"before you answer this question, you should ask  1) how big is the dataset, if it's huge and cannot fit in memory, you can use a minheap 2) otherwise, use selection algorithm.  3) can you change the data, since sort will change the array 4) how much extra space you can use Ask these questions before you give a solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using partition, till we pivot index is equal to 1000 \npublic static int partition(int arr[], int left, int right) { \n  int pivot = arr[(left+right)/2]; \n  int j = 0; \n  int y = 0; \n  int pivotIndex = (left+right)/2; \n \n  for (j = left, y = right; j < y;) { \n   if (arr[j] >= pivot && arr[y] <= pivot) { \n    if (j == pivotIndex) { \n     pivotIndex = y; \n \n    } else if (y == pivotIndex) { \n     pivotIndex = j; \n    } \n    int temp = arr[j]; \n    arr[j] = arr[y]; \n    arr[y] = temp; \n \n   } \n \n   if (arr[j] < pivot) { \n    j++; \n   } \n   if (arr[y] > pivot) { \n    y--; \n   } \n \n  } \n  return pivotIndex; \n } \n  \n  \n public static void finKthIndex(int[] arr,int k) \n { \n   int pivotIndex =-1 ; \n  int left =0; \n  int right = arr.length-1; \n  do \n  { \n    \n    pivotIndex = partition(arr, left, right); \n   if(pivotIndex==k) \n   { \n    System.out.println(\"Got it\"); \n   } else if(pivotIndex > k) \n   { \n    right = pivotIndex; \n     \n   } else \n   { \n    left = pivotIndex; \n   } \n     \n     \n  } \n  while(pivotIndex!=k); \n   \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use a min heap of size 1000 and compare every element of array with top of heap. If the element is bigger than insert it in the heap. When all the elements in the array are processed , you get the result in the heap."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5196263842643968","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"18","title":"You are given a large set of integers, which are not sorted. Figure out a method to retrieve the largest 1000 elements, in O(n) time.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use median of medians, O(n), to get 1000th largest then scan array picking out all numbers >= the one you got from above Runtime: O(n) worst case ------------------------ or you can use QuickSelect for 1000th largest (expected linear, but worst case with low probability to be quadratic)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use Selection Rank algoritm  Pick a random element in the array and use it as a ??pivot??. Move all elements smaller than that element to one side of the array, and all elements larger to the other side. ??If there are exactly i elements on the right, then you just find the smallest element on that side. ??Otherwise, if the right side is bigger than i, repeat the algorithm on the right. If the right side is smaller than i, repeat the algorithm on the left for i ??C right.size().  cc book problem"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this Divide the array into 1000 chunks and then run findMaxNumber in each parallely ?."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i think one pass bubble sort will give us the max in O(n) time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Well use Median of Medians to find the 1000th Number. In theory MOM is fast but in practice it works better if we choose a random number as the pivot. The algorithm to find the 1000th largest number is O(n). Once we find the 1000th number in once scan(O(n)) we can find the 1000 largest numbers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use Bubble sort ,instead of running it n times  run it 1000 times only."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5739818260627456","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"8","title":"Say you were assigned the task to optimize a website, what would you do first?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"developer.yahoo.com list for performance  Make Fewer HTTP Requests Use a Content Delivery Network (CDN) Add Expires or Cache-Control Header Gzip Components Put Stylesheets at Top Put Scripts at Bottom Avoid CSS Expressions Make JavaScript and CSS External Reduce DNS Lookups Minify JavaScript and CSS Avoid Redirects Remove Duplicate Scripts Configure ETags Make Ajax Cacheable Flush Buffer Early Use GET for Ajax Requests Postload Components Preload Components Reduce the Number of DOM Elements Split Components Across Domains Minimize Number of iframes Avoid 404s Reduce Cookie Size Use Cookie-Free Domains for Components Minimize DOM Access Develop Smart Event Handlers Choose  Over @import Avoid Filters Optimize Images Optimize CSS Sprites Do Not Scale Images in HTML Make favicon.ico Small and Cacheable Keep Components Under 25 KB Pack Components Into a Multipart Document Avoid Empty Image src  developer.yahoo.com/performance/rules.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a very generic question and thrown to check the Web development skills. The answer at high level would include: 1. Enabling gzip compression for the responses. 2. enabling caching for the static content. e.g. images, headers, logos, CSSs, js 3. Paginating the the large resultsets These are at very high level without considering the scalability, high availability. Those aspects open different chapters altogether."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First you have to profile the website, then find the bottleneck and try to fix it. It may be a DB indexing problem or something else."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"IMO, we need to understand what Optimize means. For example, at a very high level, it could mean one of the following"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"0. Profile the site using Chrome dev tools and check the Audits panel 1. Cache static resources to reduce HTTP requests 2. Minify/Merge JS and CSS files to reduce file size and bandwidth 3. Use CDN to increase the number of files simultaneously downloaded 4. Use Redis to reduce DB accesses 5. Buy a more powerful server 6. Cache jQuery objects when possible 7. Put  tags at the bottom of the HTML <br/>8. Prevent to much DOM manipulation <br/>9. Use varnish or nginx reverse proxy <br/>10. Enable gzip compression in the server <br/>11. Use Connection: keep-alive header in order to reuse existing TCP connection and prevent additional TCP handshakes <br/>12. Use SVG sprite instead of separate images for icons to reduce HTTP requests <br/>13. Remove unused scripts and CSS styles</p> \n  <span class=\"author\"> \n    \n   -  \n     <a href=\"/user?id=5170766232420352\" onmouseover=\"popup(5170766232420352);\">saringan.emanuel</a> \n     on March 11, 2014 <span><a style=\"display: none;\" class=\"authorShow5170766232420352 adminShow\" href=\"/editcomment?id=5053833600303104\">Edit</a> | <a href=\"/flagcomment?id=5053833600303104\">Flag</a> </span> \n    \n    \n   <a onclick=\"javascript:insertReply('question', 5053833600303104, 5739818260627456);\" class=\"replyButton\" id=\"replyButton5053833600303104\">Reply</a> \n   <div class=\"clearance\"></div>    \n    \n  </span> \n  </div> \n </div> \n <div class=\"clearance\"></div> \n</div> \n   \n    \n   <div id=\"insertReplyHere5053833600303104\" style=\"margin-left: 70px; display: none;\"></div> \n   \n<div class=\"clearance\"></div> \n</div> \n \n </div><div id=\"commentThread5102660399136768\"> \n    <div class=\"collapsedComment \" id=\"collapsedComment5102660399136768\" onclick=\"javascript:uncollapseComment(5102660399136768);\">Comment hidden because of low score. Click to expand.</div> \n<div class=\"uncollapsedComment\" id=\"uncollapsedComment5102660399136768\"> \n<a name=\"comment5102660399136768\"></a> \n \n<div class=\"comment\"> \n \n <div class=\"votesWrapper\" id=\"votes5102660399136768\"> \n   \n  <div class=\"arrowUp authorHide6083593809952768\" onclick=\"javascript:vote(1, 5102660399136768, 'comment')\" id=\"arrowUp5102660399136768\"></div> \n  <div class=\"arrowUpDisabled authorShow6083593809952768\" style=\"display: none;\"></div> \n  <div class=\"votesNet\" id=\"votesNet5102660399136768\">0</div> \n  <div class=\"arrowDown  authorHide6083593809952768\" onclick=\"javascript:vote(-1, 5102660399136768, 'comment')\" id=\"arrowDown5102660399136768\"></div> \n  <div class=\"arrowDownDisabled authorShow6083593809952768\" style=\"display: none;\" id=\"arrowDown5102660399136768\"></div> \n  <div class=\"votesCount\" id=\"votesCount5102660399136768\">of <span id=\"votesCountActual5102660399136768\">0</span> vote</div> \n  <div class=\"clearance\"></div>  \n   \n </div> \n <div class=\"commentMain\"> \n  <div class=\"commentBody\"> \n         \n   <p>Use AWS Cloud front. <br/> <br/>caching static content <br/>caching dynamic content for a small time ( 1sec, 1 minute, depend) <br/>Route your data to the closest server ( CDN ) <br/>tcp optimizations:  keep alive connections to reuse connections and avoid 3wayhanshake</p> \n  <span class=\"author\"> \n    \n   -  \n     <a href=\"/user?id=6083593809952768\" onmouseover=\"popup(6083593809952768);\">.?????`???.??`???.??.?????`???.?><(((?></a> \n     on March 12, 2014 <span><a style=\"display: none;\" class=\"authorShow6083593809952768 adminShow\" href=\"/editcomment?id=5102660399136768\">Edit</a> | <a href=\"/flagcomment?id=5102660399136768\">Flag</a> </span> \n    \n    \n   <a onclick=\"javascript:insertReply('question', 5102660399136768, 5739818260627456);\" class=\"replyButton\" id=\"replyButton5102660399136768\">Reply</a> \n   <div class=\"clearance\"></div>    \n    \n  </span> \n  </div> \n </div> \n <div class=\"clearance\"></div> \n</div> \n   \n    \n   <div id=\"insertReplyHere5102660399136768\" style=\"margin-left: 70px; display: none;\"></div> \n   \n<div class=\"clearance\"></div> \n</div> \n \n </div><div id=\"commentThread5757957383913472\"> \n    <div class=\"collapsedComment \" id=\"collapsedComment5757957383913472\" onclick=\"javascript:uncollapseComment(5757957383913472);\">Comment hidden because of low score. Click to expand.</div> \n<div class=\"uncollapsedComment\" id=\"uncollapsedComment5757957383913472\"> \n<a name=\"comment5757957383913472\"></a> \n \n<div class=\"comment\"> \n \n <div class=\"votesWrapper\" id=\"votes5757957383913472\"> \n   \n  <div class=\"arrowUp authorHide5196147467485184\" onclick=\"javascript:vote(1, 5757957383913472, 'comment')\" id=\"arrowUp5757957383913472\"></div> \n  <div class=\"arrowUpDisabled authorShow5196147467485184\" style=\"display: none;\"></div> \n  <div class=\"votesNet\" id=\"votesNet5757957383913472\">0</div> \n  <div class=\"arrowDown  authorHide5196147467485184\" onclick=\"javascript:vote(-1, 5757957383913472, 'comment')\" id=\"arrowDown5757957383913472\"></div> \n  <div class=\"arrowDownDisabled authorShow5196147467485184\" style=\"display: none;\" id=\"arrowDown5757957383913472\"></div> \n  <div class=\"votesCount\" id=\"votesCount5757957383913472\">of <span id=\"votesCountActual5757957383913472\">0</span> vote</div> \n  <div class=\"clearance\"></div>  \n   \n </div> \n <div class=\"commentMain\"> \n  <div class=\"commentBody\"> \n         \n   <p>I would check why the optimisation is necessary</p> \n  <span class=\"author\"> \n    \n   -  \n     <a href=\"/user?id=5196147467485184\" onmouseover=\"popup(5196147467485184);\">Satish Kumar</a> \n     on March 16, 2014 <span><a style=\"display: none;\" class=\"authorShow5196147467485184 adminShow\" href=\"/editcomment?id=5757957383913472\">Edit</a> | <a href=\"/flagcomment?id=5757957383913472\">Flag</a> </span> \n    \n    \n   <a onclick=\"javascript:insertReply('question', 5757957383913472, 5739818260627456);\" class=\"replyButton\" id=\"replyButton5757957383913472\">Reply</a> \n   <div class=\"clearance\"></div>    \n    \n  </span> \n  </div> \n </div> \n <div class=\"clearance\"></div> \n</div> \n   \n    \n   <div id=\"insertReplyHere5757957383913472\" style=\"margin-left: 70px; display: none;\"></div> \n   \n<div class=\"clearance\"></div> \n</div> \n \n</div> \n<div class=\"social_share_buttons\"> \n <div class=\"social_share_button subscribe_button\"> \n <div class=\"is_subscribed_items\"> \n  <div class=\"subscribe_image subscribe_image_subscribed\"> </div> \n  <div class=\"subscribe_text\">Email me when people comment.</div> \n </div> \n <div class=\"is_unsubscribed_items\"> \n  <div class=\"subscribe_image subscribe_image_unsubscribed\"> </div> \n  <div class=\"subscribe_text\">Email me when people comment.</div>    \n </div> \n <div class=\"subscribe_loading_items\"> \n  <div class=\"subscribe_image subscribe_image_loading\"> </div> \n  <div class=\"subscribe_text\">Loading...</div>    \n </div> \n <div class=\"subscribe_loading_error\"> \n  <div class=\"subscribe_image subscribe_image_error\"> </div> \n  <div class=\"subscribe_text\">An error occurred in subscribing you.</div>    \n </div>    \n <div class=\"clearance\"></div>  \n</div> \n \n</div> \n<br/><br/> \n<script>function validate(){return true;}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6040954054115328","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"3","title":"2 players place the knight in his desired postion (input taken from user) on chess board.The knights move in valid knight postions in chess.2 knights move one after the other.game ends when any one knight reaches bottom right corner.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"LOL what?  Input from user? Right end? Second corner? Which reaches first? HUH"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I guess the question is given the initial position of 2 knights which one of them will win.  A logic similar to BFS can be used to find out min number of steps needed to go from 1 cell to another. Once you reach the bottom of the cell stop. Do the same for the other knight. The one with lesser number of steps is the winner."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Taking the starting position of each knight, and all valid positions for him to move to, find shortest path between his position and the end point. Essentially shortest path in a graph."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5971731193790464","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"35","title":"In a Binary tree, every element(node's value) must contain the sum of its left and right sub-trees. Follow up question: how would you solve this if you can ONLY increment the value of a node Eg. If a node??s value is 20 and its sub-tree sum is 10, the node??s value can??t be set to 10 because you can only increment. How would you solve this if you can ONLY increment the value of a node  Further clarifications. 1. You can make assumption that leaf nodes retain their original value and does not change. 2. \"Sum of its left and right subtrees\" means sum of all nodes' values in its left subtree + sum of all nodes' values in its right subtree.  PS: I am asking this question coz I am not sure of its solution myself. Hence seeking experts' advice.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I don't not fully understand the question precisely.  What about leaf nodes?  Are you saying only the leaf nodes have values that can vary, and the rest of the tree just ripple sums these up to root?  Anyways, for the restriction, why can't you define your own += using a loop on ++ ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Part 1:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I attached a simple implementation in Java. The idea I used is this: 1- Flood an increment command from root (this is recursive). 2- When a node receives the command, it calls INC (add + 1), calls it for parent and calls it for its children. However, there is a flag to make sure children are called only once. To get the number of nodes in the tree, this method must be called from the root of the tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the idea is to just use increment (++) then we can first assign the maximum of the two child nodes and then increment times the minimum of the two child nodes to get to the sum. Complexity should be O(N + max-min) where N is the total number of nodes; max is the maximum value of all of the leaf nodes and min the minimum value."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can someone explain the steps in plain english ? we all can write code, its about finding best algo"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void bt_root_equal2_sum_left_right(node **root) \n{ \n        if(*root==NULL) return; \n        int sum = get_sum((*root)->left)+get_sum((*root)->right); \n        if((*root)->data < sum) \n        { \n                (*root)->dat = sum; \n        } \n        bt_root_equal2_sum_left_right(&(*root)->left); \n        bt_root_equal2_sum_left_right(&(*root)->right); \n} \n \nint get_sum(node *root) \n{ \n        if(root==NULL) return 0; \n        return root->data+get_sum(root->left)+get_sum(root->right); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"\"You can make assumption that leaf nodes retain their original value and does not change. \" I understand this statement as following: leaf nodes don't satisfy the sum of subtrees condition, because otherwise all nodes would be 0, but I am allowed to increment their value just like other nodes.  I would first observe that once leaves are set up, the tree is fixed. But depending on your choice of leaves it might be impossible to construct the tree, based on the constraint.  Does the number of changes I make or the sum of increments I make hurt my score? If not find the maximum value, make all leaves max+1 and then ripple the sums up to the root.  If yes I am not sure how to get the optimal solution but for each node check the sum of the nodes of its subtree. You don't need to set values for the intermediate nodes for this, simply multiply the relative depths of each leaf's value.  If sum > value: It's OK, you should increment the value. If sum < value: You should increment one of the leaves. Take action only when all nodes satisfy the first condition, if any of them doesn't, then increment a leaf node and check again.  In this solution I am not utilizing swaps."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"SummationTree(Node node){ \n if(node == null) \n  return 0; \n  \n int totalSum = SummationTree(node.left) + SummationTree(node.right); \n int nodeValue = node.value;  \n if( totalSubTreeSum > nodeValue ) \n  node.value = totalSubTreeSum; \n return totalSubTreeSum + nodeValue; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algorithm: We recursively call the function for left and right subtree. This method will update the root's value if the sum of the nodes of the left subtree and the right subtree nodes is greater than the root's value. The function returns back the total sum of root, left subtree nodes and the right subtree node's value.  int toSumTree(struct node *root) {     int leftSum,rightSum,n=root->data;     if(root->left!=NULL) leftSum=toSumTree(root->left);     if(root->right!=NULL) rightSum=toSumTree(root->right);     if(root->left!=NULL && root->right!=NULL)     {      if(n     {       root->data=leftSum+rightSum;      }      return n+leftSum+rightSum;     }         else if(root->left!=NULL && root->right==NULL)     {      if(n     {       root->data=leftSum;      }      return n+leftSum;     }         else if(root->left==NULL && root->right!=NULL)     {      if(n< rightSum)      {       root->data=rightSum;      }      return n+rightSum;     }          return n; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Recursive approach:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void stepDown (Node root) { \n \nif ( root == null )  \nreturn; \n \nNode LC = root.left; \nNode RC = root.right; \nboolean l1 = false; \nboolean l2 = false; \n \nif ( LC != null ) { \n l1 = checkIsLeaf (LC); \n } \nif ( RC != null ) { \n l2 = checkIsLeaf (RC); \n } \n \n \nif ( l1 == false ) \n stepDown (LC); \n \nif ( l2 == false ) \n stepDown (RC); \n \nroot.info = LC.info + RC.info; \nreturn; \n \n} \n \nboolean checkIsLeaf (Node root) { \n \n if ( root == null ) \n  return false; \n  \n else if ( root.left == null && root.right == null ) \n  return true; \n else \n  return false; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think we have to do post order traversal  and set node value as"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"an elegant solution is given at geeksforgeeks.org/convert-an-arbitrary-binary-tree-to-a-tree-that-holds-children-sum-property/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public int changeTree(node root){ \n   if (root==null)return; \n  int left=changeTree(root.left); \n  int right=changeTree(root.right); \n  return root.data=left+right; \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Use postorder traversal and increment sum according to below cases ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Cut and paste this code into your editor to get the answer"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5098399858688000","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"13","title":"In Amazon web site, the product items has to show with different attributes combination for clothers.  Example:  color - red blue green size - XL X M S pattern - checks lines    so output should be in below format in different combinations:  red - xL - checks red - xL - lines red - X - checks red - x - lines red - M - checks : : green - S - checks green - S - lines   Note:- In above example, no. of attributes is 3. but attributes can be N.  Below is the code, I have written. Hope it will be useful for anyone.     This is an non-recursive logic which will work for large value of N. time Complexity is O(n2).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"#include  \n#include  \n#include  \n \nusing namespace std; \n \n/* find the next enumeration */ \nbool hasNext(vector& limits, vector& perm) \n{ \n    const int N = limits.size(); \n \n    for (int i = 0; i < N; i++) { \n        perm[i]++; \n        if (perm[i] < limits[i]) \n            return true; \n        for (int j = 0; j <= i; j++) \n            perm[j] = 0; \n    } \n \n    return false; \n} \n \nint main() \n{ \n    vector> map = {  // things to enumerate \n        { \"Checks\", \"Lines\" }, \n        { \"XL\", \"X\", \"M\", \"S\" }, \n        { \"Red\", \"Blue\", \"Green\"}}; \n \n    const int N = map.size(); \n    vector perm(N, 0); \n    vector limits(N); \n \n    for(int i = 0; i < N; i++) \n        limits[i] = map[i].size(); \n \n    do { \n        for (int i = N - 1; i >= 0; i--) \n            cout << map[i][perm[i]] << \"\\t\"; \n        cout << endl; \n    } while (hasNext(limits, perm)); \n    return 0; \n} \n \n/* output: \nRed     XL      Checks \nRed     XL      Lines \nRed     X       Checks \nRed     X       Lines \nRed     M       Checks \nRed     M       Lines \nRed     S       Checks \nRed     S       Lines \nBlue    XL      Checks \nBlue    XL      Lines \nBlue    X       Checks \nBlue    X       Lines \nBlue    M       Checks \nBlue    M       Lines \nBlue    S       Checks \nBlue    S       Lines \nGreen   XL      Checks \nGreen   XL      Lines \nGreen   X       Checks \nGreen   X       Lines \nGreen   M       Checks \nGreen   M       Lines \nGreen   S       Checks \nGreen   S       Lines \n*/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We fix the problem using DFS. Here's code in C++:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Below is the code, I have written , not able to do within time in written test. Hope it will be useful for anyone.  This is an non-recursive logic which will work for large value of N. time Complexity is O(n2)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"call the method as attrib(lol);  //lol = list of lists"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"As simple as this, hope code is self explanatory:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is recursive way of doing, since we are printing all n^m ( i.e pow(n,m)) combinations, I think complexity cannot be less O(n^m), is there a way less than O(n^m), Any thoughts?  {{ //call print as print(attr,0,\"\");  //the print  print(String[][] attr, int row, String line){  //last row of attributes  if(row == attr.length -1){   for( int i = 0; i < attr[row].length; i++){    System.out.println(line+\"-\"+attr[row][i]);   }  }else{   for( int e = 0; e < attr[row].length; e++){    //recurse for next row attributes    print(attr,++row,line+\"-\"+attr[row][e]);   }  } } }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is recursive way of doing, since we are printing all n^m ( i.e pow(n,m)) combinations, I think complexity cannot be less O(n^m), is there a way less than O(n^m), Any thoughts?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; \nimport java.util.List; \n \npublic class ProductCombinationInAmazon { \n \n public void print(List> catalog) \n { \n        List list = catalog.get(0); \n         \n        for(int i =1 ; i < catalog.size() ; i++) \n        { \n         List list1 = catalog.get(i); \n         List merged = new ArrayList(); \n         for(String str1 : list) \n         { \n          for(String str2 : list1) \n          { \n           merged.add(str1+\" \"+str2); \n          } \n         } \n         list = merged; \n        } \n         \n        for(String str : list) \n        { \n         System.out.println(str); \n        } \n } \n  \n  \n /** \n  * @param args \n  */ \n public static void main(String[] args) \n { \n  List list1 = new ArrayList(); \n  list1.add(\"Red\"); \n  list1.add(\"Blue\"); \n  list1.add(\"Green\"); \n   \n  List list2 = new ArrayList(); \n  list2.add(\"XL\"); \n  list2.add(\"X\"); \n  list2.add(\"M\"); \n  list2.add(\"S\"); \n   \n  List list3 = new ArrayList(); \n  list3.add(\"Check\"); \n  list3.add(\"Lines\"); \n \n  List> list4 = new ArrayList>(); \n  list4.add(list1); \n  list4.add(list2); \n  list4.add(list3); \n  new ProductCombinationInAmazon().print(list4); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void Main(string[] args) \n        { \n            string[][] arr = { new[] { \"red\", \"blue\", \"green\" }, new[] { \"XL\", \"X\", \"M\", \"S\" }, new[] { \"checks\", \"lines\"} }; \n            var res = new string[arr.Length]; \n            PerformPrinting(arr , 0 , res); \n        } \n \n        private static void PerformPrinting(string[][] arr, int i, string[] res) \n        { \n            if (i == arr.Length) \n                Print(res); \n            else \n            { \n                for (int j = 0; j < arr[i].Length; j++) \n                { \n                    res[i] = arr[i][j]; \n                    PerformPrinting(arr, i + 1, res); \n                } \n            } \n        } \n \n        static void Print(string[] res) \n        { \n            Console.WriteLine(String.Join(\"-\" , res)); \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"cloths = { \n'colors':['red','blue','green','white','yellow'], \n'size'  :['s','m','xl','xxl'], \n'pattern' :['checks','lines'], \n'models'  :['tshirt','shirt'] \n} \n \ndef combin(keys): \n    #print (keys) \n    if len(keys) == 1: \n        return cloths[keys[0]] \n    if keys: \n        key = keys[0] \n        r = combin(keys[1:]) \n        rt = [] \n        for ii in cloths[key]: \n            for jj in r: \n                rt.append(ii+'-'+jj) \n        return rt \n             \n         \n         \n             \nif __name__ == '__main__': \n    k = list(cloths.keys()) \n    k = sorted(k) \n    #print (sorted(k)) \n    rt = combin(k) \n    pprint.pprint (rt)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this question is more about the OO Design.  As you would see something common in all of these are that these are attributes and they all have the same property ... they print their values.  so, if we have common interface say attributes:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My non-recursive implementation in Javascript."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6628183994531840","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"6","title":"There is a file which contains N words. There may be M anagrams in that file, K words on each anagrams. K>=1, M>=1, N>=1. You need to write an algorithm which will create one list for each anagram with k words and group all M lists with one data structure","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Can some help me understand the problem its not clear? Thanks"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just a small improvement to above solution.We can also  create keys entries  on number of each alphabets present. For eg: word :singasong key : a1g2i1o1n2s2 . This will reduce the size of key and  can be done in one pass."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@pavan can u pls post the solution for this.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Not a complete soln, but gives the logic. Idea is to read all the words from the file into a vector compare each word again others in the vector and if it is anagram, store their indices in a map where key is the anagram string and value is a vector of indices."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Hash with KEY=stringsort of string, VALUE=ArrayList of all strings with this KEY  Duhhhhhhhhhhhhhh (GOOGLE IT DUHHH)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5164759787765760","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"9","title":"Find your own method to balance an unbalanced binary tree.(you must not use existing methods like AVL, red black or b trees)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"O(n) method...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Heapify the binary tree after getting into an array. O(n) solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.) Flatten the input tree  [inplace ] 2.) Use Binary search to create a balanced tree it just needs to be a tree and not a BST"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can we change the root of this tree ??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"From Wikipedia: A balanced binary tree is commonly defined as a binary tree in which the depth of the left and right subtrees of every node differ by 1 or less...  So, in theory, we could maintain depth of the left and right subtrees in each node. At the root node, we will have the degree of imbalance between the left and right subtrees. If left subtree has more depth, then we move nodes from left to right subtree until the imbalance has been corrected to a difference of <= 1. Perhaps a recursive approach may be useful...  I have not coded this up, but will try now...just thought I will post the idea first."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4978435516530688","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"12","title":"Convert a sorted integer Array to balanced binary search tree. This is very simple one and I could do it in O(n) time and O(1)extra space","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"In C++:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"So you had 20 Amazon interviews back to back????  Stop posting your study questions!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"MakeTree(Int arr[],int start,int end) {  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"MakeTree(Int arr[],int start,int end)  {   int mid=(start+end)/2;   node* temp =(node*)malloc(sizeof(node));  temp->val=arr[mid];  if(start==end)  {   temp->left=Null;   temp->right=Null;  }  else  {   temp->left=makeTree(arr,start,mid-1);   temp->right=makeTree(arr,mid+1,end);  }  return temp; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Isn't a sorted array already a balanced heap. If parent = index i, then left child= 2*1+1, right child =2*i+2.  Just traverse array in this this order and populate your BST."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static Node ConvertToTree(int[] input, int lowerIndex, int higherIndex) \n        { \n            if (lowerIndex < higherIndex) \n            { \n                var mid = (higherIndex - lowerIndex) / 2 + lowerIndex; \n                var n = new Node(input[mid]); \n                n.left = ConvertToTree(input, lowerIndex, mid); \n                n.right = ConvertToTree(input, mid + 1, higherIndex);  \n                return n; \n            } \n            return null; \n             \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am building the tree from bottom up, and it is non-recursive. If N = 2^m then the algorithm runs in O(1) space and returns a perfectly balanced tree with \"N\" elements. If N = 2^m + k, then the algorithm runs in O(1) space, but first build a tree that might have \"m\" extra nodes. Then these nodes will be removed."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Take the median of the array as the root of the tree. For sake of clarity let's call it original_median.  Now , take the median of the array to the left of the original_median and make it the left child  and similarly the median of the array to the right of the original_median and make it the right child. Recursively apply it to the left child and right child."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5495823383134208","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"11","title":"Given 2 sorted linked list , merge them into single sorted list. Change the pointers, don't copy data","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"List merge(List head1, List head2) { \n List result = null; \n if (head1.data < head2.data) { \n  result = head1; \n  result.next = merge(head1.next,head2); \n } \n else { \n  result = head2; \n  result.next = merge(head1,head2.next); \n } \n return result; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static LinkedList MergeLinkedLists(LinkedList p1, LinkedList p2) \n        { \n            LinkedList newHead = new LinkedList(); \n             \n            if (p1 == null && p2 == null) return null; \n            if (p1 != null && p2 == null) return p1; \n            if (p1 == null && p2 != null) return p2; \n \n            Node Head1 = p1.Head; \n            Node Head2 = p2.Head; \n \n            while (Head1 != null && Head2 != null) \n            { \n                if (Head1.Data < Head2.Data) \n                { \n                    newHead.Add(Head1); \n                    Head1 = Head1.Next; \n                } \n                else if (Head1.Data == Head2.Data) \n                { \n                    newHead.Add(Head1); \n                    Head1 = Head1.Next; \n                    newHead.Add(Head2); \n                    Head2 = Head2.Next; \n                } \n                else \n                { \n                    newHead.Add(Head2); \n                    Head2 = Head2.Next; \n                } \n            } \n \n            if (Head1 != null) \n            { \n                newHead.Current.Next = Head1; \n            } \n \n            if (Head2 != null) \n            { \n                newHead.Current.Next = Head2; \n            } \n            return newHead; \n        } \n \n \n        public static void TestMergeLinkedLists() \n        { \n            LinkedList p1 = new LinkedList(); \n            LinkedList p2 = new LinkedList(); \n \n            p1.Add(new Node(3)); \n            p1.Add(new Node(4));            \n \n            p2.Add(new Node(1)); \n            p2.Add(new Node(1)); \n            p2.Add(new Node(1)); \n            p2.Add(new Node(7)); \n \n            Console.Write(\"List1 = \"); \n            p1.Print(); \n \n            Console.Write(\"List2 = \"); \n            p2.Print(); \n \n            Console.WriteLine(\"---------------------------\"); \n            LinkedList lst = MergeLinkedLists(p1,p2); \n \n            lst.Print(); \n        }       \n \n       public class LinkedList \n    { \n        private Node _Head; \n        private Node _Current; \n        public Node Head \n        { \n            get \n            { \n                return _Head; \n            } \n            set \n            { \n                _Head = value; \n            } \n        } \n \n        public Node Current \n        { \n            get \n            { \n                return _Current; \n            } \n            set \n            { \n                _Current = value; \n            } \n        } \n        public LinkedList(Node pH) \n        { \n            _Head = pH; \n            _Current = _Head; \n        } \n        public LinkedList() \n        { \n            _Head = null; \n            _Current = null; \n        } \n        public void Add(Node pD) \n        { \n            if (pD == null) return; \n \n            if (_Current != null) \n            { \n                _Current.Next = pD; \n                _Current = _Current.Next; \n            } \n            else \n            { \n                _Head = pD; \n                _Current = _Head; \n            } \n        } \n \n        public void Print() \n        { \n            Node pH = _Head; \n            while (pH != null) \n            { \n                if (pH.Next != null) \n                    Console.Write(pH.Data.ToString() + \"->\"); \n                else \n                    Console.Write(pH.Data.ToString()); \n \n                pH = pH.Next; \n            } \n            Console.WriteLine(\"\"); \n        } \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node* merge(node* & p1,node* & p2) {  if(p1==NULL)   return p2;  if(p2==NULL)   return p1;  node* temp;  if(p1->val>p2->val)  {   temp=p1;   p1=p2;   p2=temp;  }  temp=NULL;  node* temp1 = p1;    while(p1!=NULL && p2!=NULL)  {   while(p1->val<=p2->val)   {    temp=p1; // store the previous node;    if(p1->next==NULL)    {     p1->next=p2;     return temp1;    }    p1=p1->next;   }   temp->next=p2;// insert the node in first list   while(p2->next!=NULL&&p2->next->valval)    p2=p2->next;   temp=p2->next;   p2->next=p1;   p2=temp;  }  return temp1; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node* merge(node* & p1,node* & p2) \n{ \n if(p1==NULL) \n  return p2; \n if(p2==NULL) \n  return p1; \n node* temp; \n if(p1->val>p2->val) \n { \n  temp=p1; \n  p1=p2; \n  p2=temp; \n } \n temp=NULL; \n node* temp1 = p1; \n  \n while(p1!=NULL && p2!=NULL) \n { \n  while(p1->val<=p2->val) \n  { \n   temp=p1; // store the previous node; \n   if(p1->next==NULL) \n   { \n    p1->next=p2; \n    return temp1; \n   } \n   p1=p1->next; \n  } \n  temp->next=p2;// insert the node in first list \n  while(p2->next!=NULL&&p2->next->valval) \n   p2=p2->next; \n  temp=p2->next; \n  p2->next=p1; \n  p2=temp; \n } \n return temp1; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node* merge(node* la, node* lb) \n{ \n \n  // either one is empty return other \n  if(!la)  \n    return lb; \n  else if (!lb) \n    return la; \n     \n     \n  node *head; \n  if(la->d < lb->d) { \n    head = la; \n    la = la->next; \n  } else { \n    head = lb; \n    lb = lb->next; \n  }  \n   \n  node *p = head; \n \n  while(la && lb) { \n    if(la->d < lb->d) { \n      p->next = la; \n      p = la;  \n      la = la->next; \n    } else { \n      p->next = lb; \n      p = lb;  \n      lb = lb->next; \n    } \n  }  \n   \n  if(la) \n    p->next = la; \n  else \n    p->next = lb; \n     \n  return head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Take a new pointer say merged_pointer and point it to the lesser of the two start pointer , next keep on comparing the two linked list and keep on connecting the lesser to the merged_pointer. Whichever pointer was less that pointer will be moved to the next position. Keep on doing this until the end of one of the linked list is reached and then point the merged_pointer to the rest of the other linked list. This is very similar to the merge algorithm."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"void merge(struct node *head1,struct node *head2) \n{ \n     struct node *result=NULL; \n     while(head1!=NULL && head2!=NULL) \n     { \n          if(head1->val < head2->val) \n          { \n             result = addnode(result,head1->val); \n             head1=head1->next; \n          } \n          else \n          { \n             result = addnode(result,head2->val); \n             head2=head2->next; \n          } \n     } \n     if(head1==NULL) \n     { \n        while(head2!=NULL) \n        { \n           result = addnode(result,head2->val); \n           head2=head2->next; \n        } \n     } \n     else \n     { \n         while(head1!=NULL) \n        { \n           result = addnode(result,head1->val); \n           head1=head1->next; \n        } \n     } \n     printlist(result); \n     printf(\"\\n\"); \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5916343362650112","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"Given a read only linked list with next and random pointer , clone the list","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This problem was already discussed many times. I've chosen the most elegant idea and implemented it  If we want to copy such linked list we should do following steps:  1) Create copy for each node and insert it next to node. Example: was A->B->C became A->A'->B->B'->C->C'  2) Copy random links Example: if there were connection A->C let's make connection A'->C'   3) Remove link between original node and it's copy (separate copy and original)  Totally we need to traverse three times through linked list (O(3N)) and O(1) extra memory Here is C# implementation."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"The method I came across uses  container of C++ STL. A map is actually an associative array which has a key and a value associated with that key.  Steps: (The code syntax isn't coming properly in comments so check online)  1. Copy the original list to new list with next pointers intact, leave arbit pointers for now  2. While copying make a map"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"DUHHH.  USE A HASH TABLE DUHHH.  Create cloned nodes and hash  (key=cloned from, valu=clone itself)   Use that somehow, okay?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6328056243290112","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"It was a design question. You have to design a game. it has different types of monsters and different weapons. hero would shoot monster. each monster would have some initial health. Each weapon would do some predefined damage to monster. when its health gets 0, monster would die/disappear. and there would be multiple levels. based on level, monster and their behavior would change.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I am not sure what's the best solution for this. The below is my example."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"dude stop asking homeworks."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6225032594325504","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"Given 2 rectangles , find whether they are overlapping or not.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"So you had 20 Amazon interviews back to back????  Stop posting your study questions!  This question is easier solved in the negative.  Check for truthness of    NOT( triangles do not overlap)  DUHHHHHHHHHH (GOOGLE IT, which is what you are doing and posting fake interview questions because you couldn't understand the short explanations you found via GOOLE, AM I RIGHT???????)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6533385476374528","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"2","title":"delete all the nodes from a binary tree that lie on a path whose sum from root to leaf is less than a given value K. Twist was that the node values can be any integer. It may be a negative number.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class DeleteAllNodesOnAPath { \n    static class Node \n    { \n     int data; \n     Node left; \n     Node right; \n     public Node( int data ) \n     { \n      this.data = data; \n     } \n    } \n     \n    public Node deleteNode(Node root, int sum) \n    { \n        deleteNodeRecursive(root, sum); \n     return root; \n    } \n     \n     \n private boolean deleteNodeRecursive(Node root, int sum) { \n     if (root == null) \n     { \n      return sum >=0 ? false : true; \n     } \n     sum = sum- root.data; \n  boolean lValue = deleteNodeRecursive(root.left, sum); \n  boolean rValue = deleteNodeRecursive(root.right, sum); \n        boolean isLeftValid = true; \n        boolean isRightValid = true; \n  if (!lValue) \n  { \n   isLeftValid = false; \n   root.left = null; \n  } \n   \n  if (!rValue) \n  { \n   isRightValid = false; \n   root.right = null; \n  } \n  if (!isLeftValid && !isRightValid) \n  { \n   return false; \n  } \n  else \n  { \n   return true;    \n  } \n } \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n   \n//                         40 \n//                          /    \\  \n//                        10      100     \n//                                /  \\ \n//                              60   150     \n   \n      Node root = new Node(40); \n      root.left = new Node(10); \n      root.right = new Node(100); \n      root.right.right = new Node(150); \n      root.right.left = new Node(60); \n \n      root = new DeleteAllNodesOnAPath().deleteNode(root, 210); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node exploreAll (Node root, int sum, int val ) {//val is the threshold value set \n if (root == null) \n  return root; \n \n Node LC = root.left; \n Node RC = root.right; \n \n if ( LC!= null )  \n  Node status1 = exploreAll (LC,sum+root.data,val); \n  \n if ( RC != null )  \n  Node status2 = exploreAll (RC,sum+root.data,val); //can store root.data in a temporary variable to save one computation.// \n \n checkLeft (status1, root, RC, LC); \n checkRight (status2, root, LC, RC); \n \n if ( LC == null && RC == null ) { \n  if ( sum + root.data < val ) { \n   root = null; \n   return root; \n  } \n } \n \n return root; \n} \n \nvoid checkLeft (Node status1, Node root, Node RC, Node LC) { \n if ( root != null && status1 == null ) { \n  if ( RC != null ) { \n   if ( root.parent != null ) { \n    if ( root.parent.left == root )  \n     root.parent.left = RC; \n    else \n     root.parent.right = RC; \n   } \n   else { \n    Node newNode = new Node (); \n    newNode.left = LC; \n    newNode.right = RC; \n   } \n  } \n } \n root = null; \n} \n \nvoid checkRight (Node status2, Node root, Node LC, Node RC) { \n if ( root != null && status2 == null ) { \n  if ( LC != null ) { \n   if ( root.parent != null ) { \n    if ( root.parent.left == root )  \n     root.parent.left = LC; \n    else \n     root.parent.right = LC; \n   } \n   else { \n    Node newNode = new Node (); \n    newNode.left = LC; \n    newNode.right = RC; \n   } \n  } \n } \n root = null; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5727709741187072","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"Data structure to push, pop and find min element in O(1) time.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Answer is stack. Push and Pop is O(1). For find_min, you can maintain a seperate stack which stores the min element so far and you can pop the element from this stack if the element is popped from the main stack.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"GOOGLE IT!!!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class MinStack  { \n    \npublic push(T val) { \n    m_data.push(val); \n    if (val > m_mins.top()) { \n        m_mins.push(m_mins.top()); \n    } else { \n        m_mins.push(val); \n    } \n} \n   \npublic T pop() { \n    m_mins.pop(); \n    return m_data.pop(); \n} \n \npublic T min() { \n    return m_mins.top(); \n} \n    \nprivate Stack m_data; \nprivate Stack m_mins; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5764498551996416","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"Difference between A record and CName?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The A record maps a name to one or more IP addresses, when the IP are known and stable. The CNAME record maps a name to another name. It should only be used when there are no other records on that name."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6509608940077056","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"Name some DNS records and their purposes.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"NS - Name server record A record - Assigning IP address to a  domain/sub-domain MX - record - pointing the mail exchanger record for the domain so all emails are routed to the mx record which usually is a subdomain or domain name with a valid A record. CNAME - canonical name record makes one domain name an alias of another"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6247401723527168","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"Difference between inner join and left join?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"INNER JOIN: Returns all rows when there is at least one match in BOTH tables LEFT JOIN: Return all rows from the left table, and the matched rows from the right table RIGHT JOIN: Return all rows from the right table, and the matched rows from the left table FULL JOIN: Return all rows when there is a match in ONE of the tables  From W3Schools website."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5098624002293760","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"What is the default port for mysql?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"3306"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"3306"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6004339189481472","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"4","title":"What is inside a packet?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"A packet is one unit of binary data capable of being routed through a computer network. To improve communication performance and reliability, each message sent between two network devices is often subdivided into packets by the underlying hardware and software."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"which packet you are talking about ,any way you can use wireshark to get the exact content of a packet ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"A gift. Usually!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"A packet can contains many many datas. Either on the physical plane or the digital volume (or any disruptive synergistic advances made which we are unaware of). It could contain Quantum data like Schrodinger's pussy or Dick Feynman's squiggly.  IN ANY CASE, TO DETERMINE WHAT IS INSIDED THE PACKET, CHECK THE LABEL! HA HA HA HA."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5163800265228288","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"2","title":"Difference between Active and Passive FTP?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can find your answer here:  slacksite.com/other/ftp.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In active mode, the client sends the server the IP address and port number on which the client will listen so the server has to initiate the data connection. Here port 21 is control and port 20 is data on the server side. In Passive mode, the client sends a PASV command to the server and receives an IP address and port number in return for data transfer. Here port 21 is control and a random port >1024 is used for data on the server side. This is useful when the client is behind firewall and not accepting incoming connections."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6271593529475072","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"1","title":"I type www.Amazon.com into the browser and click go, explain in detail what happens?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Browser will contact DNS (Domain Name Server) to get the IP address. 2. DNS sends back the IP address to the Browser. 3. Browser will establish a TCP connection with the web server at port 80. 4. Browser will retrieve HTML code. 5. Browser will display the page based on HTML content.."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5971990569549824","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"24","title":"An array is given like {3,6,10,4,5,7,8}.  Pick any two number suppose 10 and then 7, as 10 >7, it's an inversion, now if you choose 3 & 5, 3<5,  it's not an inversion.    So you have to write a program to calculate total no of such inversion, in a given array. You can use extra space of O(n).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Modify mergesort to return inversions also (while sorting the input array). Normally mergesort returns \"void\" so you can make it return \"int\" to also return number of inversions.  The main change is to modify the merge routine inside mergesort (which usually returns nothing, but now will return an integer which is the count of the number of inversions BETWEEN elements in left array and right array).  When merging the left half array L and right half array R, we usually have two counters i_L and i_R pointing into the two arrays (pointing at the current numbers we are comparing and considering for placement in the output array).  So when you do the comparison, if L[i_L] <= R[i_R], you will move L[i_L] into the merged array as normal and increment i_L++.  So no change for this case (please note, include the = case as part of this case, not the next one).  What is different now is if  L[i_L] > R[i_R], you will move R[i_R] .. blah blah as usual but you will ALSO increment a counter like:  crossing_count += L.length - i_L  Why?  Because the element R[i_R] you are moving into merged array is inverted with respect to all the remaining elements in the L array (and there are L.length - i_L ) of them.  So that's what you do.  You modify merge subroutin to increment a counter whenever something from the the right array is picked to be placed in the merged array. And you increment it by the number of remaining elements in the L array.  Convince yourself that this will count ALL the crossing inversions (inversions between elements in L and R).   How does it look overall when the new merge function is placed in mergesort?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I told him to create a tree with array data from start, if it is going left in the tree, keep increasing total inversion count, if it is going right do nothing, at the end you will have total no of inversions. He seems to be satisfied with the algo, but not with my code, did so many boundary errors."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \nmain() \n{ \n        int a[7] = {3,6,10,4,5,7,8},i,j,count = 0; \n \n        for(i = 0;i<6;i++) \n        { \n                for(j = i+1;j<7;j++) \n                { \n                        if(a[i] > a[j]) \n                        { \n                                count++; \n                                printf(\"{%d,%d}\\n\",a[i],a[j]); \n                        } \n                } \n        } \n \n        printf(\"no of inversions :%d\\n\",count); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"obviously, no of nodes in right side of the current node in the tree will be added to the total number of inversions, while going to left, for that purpose all the nodes has to keep the count of number of nodes to its right, which can be tracked while creating the tree itself, idea was to tweak the tree creation code, so that these features could be fit. But I couldn't produce it in limited time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Maybe I have not understood the question correctly but I really do not see any need to use any data structure to compute number of inversions.  If we just need to get number of inversions, we need to calculate number of pairs (x,y) where x > y. Imagine the array in a sorted fashion. If x=largest number, then there can be (n-1) pairs using the other elements. Similarly, if x=2nd largest, there can be (n-2) pairs using remaining elements, and so on.  So, total number of inversions = 1+2+3+...+(n-1) = n*(n-1)/2."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about finding the Longest Decreasing subsequence in the array from 1 to n and then suppose the size is n then the number of inversions can be (n-1) + (n-2) + (n-3) + .......+ 1 = (n-1)*n / 2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think there is vagueness in the question. What does the examiner intend to do? Sort the array? Or just a comparison between different elements"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If there is no duplication, picking any 2 numbers should always be the inversion.  3 - 0 3,6 - 1 (6,3) -> 0 +1 3,6,10 -  3 (6,3)(10,6)(10,3) -> 1 + 2 3,6,10,4 -  6 (6,3)(10,6)(10,3)(4,3)(6,4),(10,4) -> 3 + 3 3,6,10,4,5 -  10 (6,3)(10,6)(10,3)(4,3)(6,4),(10,4)(5,3)(6,5)(10,5)(5,4) -> 6 + 4 3,6,10,4,5,7 - 10 + 5 3,6,10,4,5,7,8 - 15 + 6  : : :  f(n) = f(n-1) + (n - 1)  So running the function n times will get the answer.  function getNumberOfInversion(data) {     var prev = 0;     var result = 0;     for(var i = 1;i<=data.length;i++) {         result = prev + (i-1);         prev = result;     }     return result; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about sort it first,   After the array is sorted, we do the binary search. Each side will calculate the number of inversion."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"So from my interpretation, an inversion is just anytime a number is greater than any other number in the list regardless of where they are situated in the array. So this gives us the ability to sort the array and not alter the results.  So in my JS implementation in O(nlgn) time: 1. Sort the input array  time: O(nlgn)  2. Keep track of all duplicate values in array. We do this with a JS object (which acts as a set).  -- key = duplicated value -- value = array of indexes   time: O(n)  3. Starting from the end of the array, we look at its index.  The number of inversions for that number and every other number to the left of it will be equal to: =it's array index - the number of duplicates of that particular value in question that are to the left  eg. for [1,2,2]  for 2(end value): the number of inversions = 2 - 1 = 1 for 2(middle value): the number of inversions = 1 - 0 = 1 for 1 (first value): the number of inversions = 0 - 0 = 0  time: O(n)  try running this in jsfiddle:     jsfiddle.net/    7v7XN/1/"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6311825561878528","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"31","title":"Given an Array, replace each element in the Array with its Next Element(To its RHS) which is Larger than it. If no such element exists, then no need to replace. Ex:  i/p: {2,12,8,6,5,1,2,10,3,2} o/p:{12,12,10,10,10,2,10,10,3,2}","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"C++ Version:  O(n2) version:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question is asking to replace each element with the next element in the list which is larger than it.   Which is not at all clear from the phrase \"Next Largest Element\"."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include   main() {         int a[10] = {2,12,8,6,5,1,2,10,3,2},i,j;          for(i = 0;i<9;i++)         {                 for(j = i+1;j<10;j++)                 {                         if(a[i] < a[j])                         {                                 a[i] = a[j];                                 break;                         }                 }         }          for(i = 0;i<=9;i++)         {                 printf(\"%d \",a[i]);         } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class ReplaceNextGreaterElement { \n \n public static void main(String[] args) { \n  int a[] = { 2, 12, 8, 6, 5, 1, 2, 10, 3, 2 }; \n  greaterElement(a); \n  display(a); \n } \n  \n public static void display(int a[]) \n { \n  for(int a1:a) \n  { \n   System.out.print(a1+\",\"); \n  } \n } \n \n public static void greaterElement(int a[]) { \n  int len = a.length; \n  for (int i = 0; i < len-1; i++) { \n   for (int j = 0; j < len-1; j++) { \n \n    if(a[j]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this is a solution in C#. The number of arrays used can be minimized further. The time complexity is o(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can be solved in O(n) with two pointers. 1) slow and fast pointer initially points to zero'th element. 2) start moving fast pointer forward until its in increasing order. 3) on fast pointer reach a element that is less than prev.  4) start copying fast[i-1] to slow[j] until j reaches i-1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Just go from right to left keeping the max value found so far. Replace every element with such value (which can be the current element). O(N) time and O(1) space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"#include  \n#include  \n \nusing namespace std; \n \nint main() \n{ \n    int A[] = {2,12,8,6,5,1,2,10,3,2}; \n    const int N = sizeof(A) / sizeof(A[0]); \n \n    int m = A[N - 1]; \n \n    for (int i = N - 2; i >= 0; i--) { \n        m = max(m, A[i]);   // m = max(A[i], A[i+1], .... A[N-1] \n        A[i] = m; \n    } \n \n    for_each(A, A + N, [](int n) { cout << n << \" \"; }); \n    cout << endl; \n} \n// output: 12 12 10 10 10 10 10 10 3 2"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5159516840656896","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"16","title":"There is a dictionary of billion words and there is one method provided String getWord(int index); We can give it index and it will return the String on that index . Now word is given to us we have to find out its index. O(logn) solution was required.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"If we know the size of the dictionary then a straight forward BINARY SEARCH is perfect enough.  If we don't know the size, instead we're only given the query method, then we need to find the index range [st, ed] first, where getWord[st] < theGivenWord < getWord[ed], by REPEATED DOUBLING.  So, try to query at index 1, 2, 4, 8, 16, ..., 2^k,... and find the [st, ed].  After knowing [st,ed], do binary search...  The overall time is O(logn) still."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the dictionary itself is sorted, this can be a simple binary search. Look up the 0.5 billion index, and see if the word should lie in the first half of the dictionary or the second. And then iterate this process, each time cutting the dictionary size by half. If the word exists, you'll get it in O(logn). If not, that also will be known in O(logn). Only thing is that you'd need to implement a proper comparator for strings."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"string WordTobeSearch = \"Repeat\"; string str_left, str_right; 1. Apply binary search for word from index start to end using at index = 1, 2, 4, 8, 16, ....,i, 2i, ....end.      if(WordTobeSearch ==getWord(i))  {   return i; //index of WordTobeSearch   } else{   str_left = getWord(i); // str_left < WordTobeSearch    str_right = getWord(2i); //str_right > WordTobeSearch  } apply procedure 1. from index i to 2i. until element is not find. or search space is exhausted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Following code causes mlogn, where m is length of given string. This can be optimized little without any change in the complexity."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Binary search"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The Trie is a better implementation for dictionary, and the search complexity will be O(n).  But the space complexity is bit of a concern if it is in term of billion of words.  Prefix tree could be another way that could provide you with O(nlogn) complexity."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Binay search will give O(log n) soln: maxidx = maximum index of the dictionary W: Word whose idx is to be found"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"2. Trie could be a ok solution, but  a) Its not mentioned dictionary is implemented as a trie b) Lookup is O(n) which is > O(log n) for binary search"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using the dictionary data structure of c#"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5950229446656000","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"20","title":"Frog can jump 1 or 2 steps write the code to find out number of ways to go up to n steps","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"The number of ways to jump to n steps is the n-th Fibonacci number!  F[n] = F[n-1] + F[n-2]; F1 = 1; F2 = 2;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorry to use a static variable, but could make the codes a little clear"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static     {         storeSteps[1] = 1;         storeSteps[2] = 2;     }          public static int calculateSteps(int number)     {         if(storeSteps[number] != 0)             return storeSteps[number];                          int steps = 0;         steps = calculateSteps(number-1)+calculateSteps(number-2);         storeSteps[number] = steps;                  return steps;              }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a typical recursion question. Simply speaking, it's a problem like: choosing from set{*,*,*....} to form a sum of N."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int jumpSteps(int step) {  if (step == 1)   return 1;  else if (step == 2)   return 2;   return jumpSteps(step - 1) + jumpSteps(step - 2); }  int main() { cout<}   Explanation : (1,1,1,1) (1,1,2) (1,2,1) (2,1,1) (2,2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int jump(int n){  int prev=0;  int cur=1;  for(int i=1;i<=n;i++){   int temp=cur;   cur+=prev;   prev=temp;  }  return cur; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is another DP problem, with two steps 1, 2. It is a Fibonacci  sequence as mentioned above. But what if Frog can jump S1, S2 ... Sn steps?   The number of ways to n is equal to N[n-S1] + N[n-S2] + .. N[n-Sn] if (n-Si) > 0, N[0] + 1 if n = Si N[0] equals 0  The time complexity is equal to n x S, n is the sum and S is number of jumps frog has The space complexity is equal to n"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class FrogJump { \n/* \n * Frog can jump 1 or 2 steps. \n * Find ways to cover n steps. \n * Question asked at amazon.com \n */ \n int max; \n int ways=0; \n public int jump(int current){ \n  //System.out.println(current); \n  if(currentmax){ \n   return 0; \n  } \n  return 0; \n } \n  \n public static void main(String[] args){ \n  FrogJump fj=new FrogJump(); \n  fj.max=5; \n  fj.jump(0); \n  System.out.println(fj.ways); \n   \n } \n  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since the frog can jump only 1 or 2 steps, the number of combinations of 1's and 2's to reach to a given sum 'n' is given by (n+1)th term of the Fibonacci Series where  f[0] = 0; f[1] = 1; f[2] = 1; f[3] = 2;  f[4] = 3 f[5] = 5; f[6] = 8; f[7] = 13 and so on.   So if n =5, then the number of possible steps will be (n+1)th term which is the 6th term in the fibonacci series whose value is 8.  Possible combinations : 1+1+1+1+1 = 1+1+1+2 = 1+1+2+1 = 1+2+1+1 = 2+1+1+1 = 2+2+1 = 2+1+2 = 1+2+2  Similarly, n = 6, then the number of possible steps will be (n+1)th term which is the 7th term in the fibonacci series whose value is 13.  Possible Combinations: 1 1 1 1 1 1 1 1 1 1 2 1 1 1 2 1 1 1 2 1 1 1 2 1 1 1  2 1 1 1 1  1 1 2 2  1 2 1 2 2 1 1 2 2 1 2 1 2 2 1 1  1 2 2 1 2 2 2   Java Code :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int func(int n,int index,int* memo) { \n    if(index<=n) { \n        if(memo[index]!=-1) \n            return memo[index]; \n        memo[index]=func(n,index+1,memo)+func(n,index+2,memo); \n        return memo[index]; \n    } \n    return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int func(int n,int index,int* memo) { \n    if(index<=n) { \n        if(memo[index]!=-1) \n            return memo[index]; \n        memo[index]=func(n,index+1,memo)+func(n,index+2,memo); \n        return memo[index]; \n    } \n    return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* Frog can jump 1,2,3 ( n different) steps write the code to find out number of ways to go up to n steps */ \n \nint distance[n]; \nint jumps[] = {1,2,3}; \ndistance[0] = 0; \nint jump(int n) \n{ \n if(n==0) \n  return 0; \n if(distance[n] != -1) \n  return distance[n]; \n int ans = 0; \n for(int i=0; i=jump[i]; i++) \n { \n  if (n==jump[i]) \n   ans++; \n  ans+ = jump(n-jump[i]); \n }  \n return distance[n] = ans; \n} \n \n/* Example \ndistance[0] = 0; \ndistance[1] = 1; \ndistance[2] = 1+1 = 2 (1,1) (2) \ndistance[3] = 1+2+1=4 (1,1,1) (2,1) (1,2) (3) \ndistance[4] = 4+2+1=7 (1,1,1,1) (2,2) (2,1,1) (1,2,1) (1,1,2) (3,1) (1,3) \ndistance[5] = 7+4+2=13 (1,1,1,1,1) (1,1,1,2)(1,1,2,1)(1,2,1,1)(2,1,1,1)(1,1,3)(1,3,1)(3,1,1)(2,3)(3,2)(2,2,1)(2,1,2)(1,2,2) \n*/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void findPath(int num, char[] path, int count) {   if(num < 0)   {    return;   }   if (num == 0) {    System.out.println(\"path :: \" + (new String(path)));    return;   } else {     if ((num - 1) >= 0) {     path[count]='1';     path[count+1]='\\0';     findPath(num-1, path, count+1);    }     if ((num - 2) >= 0) {     path[count]='2';     path[count+1]='\\0';     findPath(num-2, path, count+1);    }   }   }  void frogPath() {   int num = 10;   char[] path = new char[num+1];   findPath(num, path, 0);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Of Course We Can Calculate The No Of Steps By Using combinations.But It Takes Long Time.But It Follows Fibonacci Pattern"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5763491516383232","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"program to pruning a binary tree","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You need to define pruning, as it can mean a lot of things. In the most general sense, you can be pruning either the breadth or the height of the tree.   The most common is to prune all the leaf nodes. Something like this might work:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"deleting a node directly would result in dangling pointers, so first check if any of the child node is leaf or not and if leaf then remove the child reference and free memory."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6153780563279872","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"11","title":"Program to check whether undirected graph is a tree or not?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is a tree IFF if both 1) it is connected 2) has no cycles  So use DFS from any node s: [Assuming below that vertices are integer labelled from 0 to ... N-1. ]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"DFS from only one vertex! If there is no back edge and all of the vertices become black, the graph is tree.!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Followed the same approach and tested the code, it works"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5698049099694080","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"37","title":"You are given an array with numbers - [11, 3, 11, 11, 3, 2, 0, -2, 2]  You are supposed to write a function that returns the number that appears \"odd\" number of times.   The solution is obviously using HashMap. But that takes O(n) to create the HashMap and O(n) to lookup. How can one eliminate the second O(n) yet keeping the HashMap?  Hint: Do you really need to count frequency of occurrence of each digit?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"You can do this using only one HashSet. Add new element to HashSet if its not already in the HashSet - else, remove it from the HashSet. This will make sure by the end of the iteration - the HashSet will only have the odd* occurring elements. Accessing elements in a HashSet is O(1) complexity. The overall time-complexity is O(n) for the linear traversal of the array elements."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this: (1)use two HashSets instead of one HashMap, one for those numbers occurred odd times so far, let's call it oddSet, while the other for those occurred even times being evenSet. (2)iterate to next number, if it has been in oddSet, we remove it from oddSet and add it to evenSet, otherwise we add it into oddSet and remove it from evenSet. (3)finally, those numbers that occurred odd times are all in oddSet."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"XOR  works when there is exactly one number that occurs odd number of times and also there should not be any 0 in the array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why not doing it like sql?  You can use group by the same number with count. Then return the number that has odd count? of course, if this is an interview, they probably won't let you use the easy and best way to do it unless you interview for microsoft.  Lambdas in C# str.GroupBy(n => n).Select(s => new {num = s.Key, count = s.Count()}).Where(g => (g.count %2) != 0);  you can use Quaere  in Java."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include    int getOddOccurrence(int ar[], int ar_size) {      int i;      int res = 0;       for (i=0; i < ar_size; i++)              res = res ^ ar[i];             return res; }   /* Diver function to test above function */ int main() {      int ar[] = {2, 3, 5, 4, 5, 2, 4, 3, 5, 2, 4, 4, 2};      int n = sizeof(ar)/sizeof(ar[0]);      printf(\"%d\", getOddOccurrence(ar, n));      return 0; }   But it works only for +ve integers"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Find oddnumber in array public Set getListOfOddNumbers(int[] number) {  Set oddNumbersSet = new HashSet (number.length);  if(number.length<0 || number==null)  {   return oddNumbersSet;  }    int i;  //Iterate each element in the array  for(i=0;i     if(oddNumbersSet.contains(number[i]))   {    oddNumbersSet.remove(number[i]);    }   else   {    oddNumbersSet.add(number[i]);   }  }  return oddNumbersSet;   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Find oddnumber in array \npublic Set getListOfOddNumbers(int[] number) \n{ \n Set oddNumbersSet = new HashSet (number.length); \n if(number.length<0 || number==null) \n { \n  return oddNumbersSet; \n } \n  \n int i; \n //Iterate each element in the array \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Find oddnumber in array \npublic Set getListOfOddNumbers(int[] number) \n \n Set oddNumbersSet = new HashSet (number.length); \n if(number.length<0 || number==null) \n  \n  return oddNumbersSet; \n  \n  \n int i; \n //Iterate each element in the array \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Find oddnumber in array \npublic Set getListOfOddNumbers(int[] number) \n \n Set oddNumbersSet = new HashSet (number.length); \n if(number.length<0 || number==null) \n  \n  return oddNumbersSet; \n  \n  \n int i; \n //Iterate each element in the array \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Find oddnumber in array \npublic Set getListOfOddNumbers(int[] number) \n \n Set oddNumbersSet = new HashSet (number.length); \n if(number.length<0 || number==null) \n  \n  return oddNumbersSet; \n  \n  \n int i; \n //Iterate each element in the array \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Find oddnumber in array \npublic Set getListOfOddNumbers(int[] number) \n \n Set oddNumbersSet = new HashSet (number.length); \n if(number.length<0 || number==null) \n  \n  return oddNumbersSet; \n  \n  \n int i; \n //Iterate each element in the array \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Find oddnumber in array \npublic Set getListOfOddNumbers(int[] number) \n \n Set oddNumbersSet = new HashSet (number.length); \n if(number.length<0 || number==null) \n  \n  return oddNumbersSet; \n  \n  \n int i; \n //Iterate each element in the array \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Find oddnumber in array \npublic Set getListOfOddNumbers(int[] number) \n \n Set oddNumbersSet = new HashSet (number.length); \n if(number.length<0 || number==null) \n  \n  return oddNumbersSet; \n  \n  \n int i; \n //Iterate each element in the array \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"when you have a new number, just to search if it's already in the hashmap, 1) if it's in the hash map, delete it. 2) otherwise, add it to the hash map At the end, all the numbers in the hash map should have odd occurrences."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Use radix sort, complexity is O(n). Then scan the list again."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"If there is only one number which appears odd number of times you can  XOR all numbers and at the end you will get the 'odd' number. In you example there are multiple 'odd' numbers 11,0,-2 so you have to count them. To do that you can use HashMap or to save some space sort numbers and keep running counter."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5198302274387968","download_status":"DOWNLOAD_DONE","votes":"-4","answersCount":"9","title":"Inorder traversal of binary tree","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"/* Iterative method using stack */ \nInordertraversal(struct btree *root)    \n{ \n while(1) \n {    \n  while( root ) \n  { \n   push(root); \n   root = root->left; \n  } \n  if(Isstackempty(S)) \n   return; \n  printf( S(top)->data); \n  root = pop(S); \n  root = root->right; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void inorder(Node n){ \n if(n.left != null){ \n  inorder(n.left); \n } \n System.out.printlin(n.value); \n if(n.right != null){ \n  inorder(n.right); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@mahdi.oraei - Could you give a solution without using recursion?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Before Algorithm I Should Say Something Here In This Recursion Stack Is Maintained By The Compiler It Intern Take care Of All The Things.Recursion Makes Coder To Do But MAke The Computer To Do More  Algorithm: #include struct tree { int data; struct tree *left; struct tree *right; } main() { struct tree *tree1=newnode(1); tree1->left=newnode(2); tree1->right=newnode(3); tree1->left->left=newnode(4); tree1->left->right=newnode(5); } void inorder(struct tree *tree1) { if(tree1==NULL) { return; } inorder(tree1->left); printf(\" %d\",tree1->data); inorder(tree1->right); } struct tree *newnode(int data) { struct tree *tree1; tree1=(struct tree *)malloc(sizeof(struct tree); tree1->left=NULL; tree1->right=NULL; return tree1; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void InOrder(Node root) \n{ \n  if(root != NULL) \n   { \n       InOrder(root.left); \n       System.out.println(root.data); \n      InOrder(root.right); \n  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6050804427390976","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"3","title":"You are given points of 2D plane and an integer n, return n number of points close to origin (0,0)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"(1)find out each point's distance from origin. (2)If the order of the n points is needed, we can use a min-heap or just sort them up, else the quick selection algorithm works."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Calculate distance of each point from the origin. Sort them based on the distance. Return first n numbers."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5705431074734080","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"5","title":"Design a musical jukebox using object-oriented principles","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"In any object-oriented design question, you first want to start off with asking your  interviewer some questions to clarify design constraints. Is this jukebox playing CD?  Records? MP3s? Is it a simulation on a computer, or is it supposed to represent a  physical jukebox? Does it take money, or is it free? And if it takes money, which  currency? And does it deliver change?    Unfortunately, we don't have an interviewer here that we can have this dialogue with.  Instead, we'll make some assumptions. We'll assume that the jukebox is a computer  simulation that closely mirrors physical jukeboxes, and we'll assume that it's free.  Now that we have that out of the way, we'll outline the basic system components.  ? Jukebox  ? CD  ? Song  ? Artist  ? Playlist  ? Display (displays details on the screen)    Now, let??s break this down further and think about the possible actions.  ? Playlist creation (includes add, delete, and shuffle)  ? CD selector  ? Song selector  ? Queuing up a song  ? Get next song from playlist    A user also can be introduced:  ? Adding  ? Deleting  ? Credit information    Each of the main system components translates roughly to an object, and each action  translates to a method. Let's walk through one potential design.    The Jukebox class represents the body of the problem. Many of the interactions  between the components of the system, or between the system and the user, are  channeled through here."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4632503952343040","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"1","title":"Construct an iterator of iterator  Here is the below question format:  // E next(); // Boolean hasNext();  // input: Iterator> // output: Iterator  // [[1], [2, 3]] => [1, 2, 3]","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; \nimport java.util.Iterator; \n \npublic class Problem implements Iterator { \n Iterator> iter; \n Iterator iter2; \n \n Problem(Iterator> iter) { \n  this.iter = iter; \n  if (iter.hasNext()) \n   this.iter2 = iter.next(); \n } \n \n @Override \n public boolean hasNext() { \n  if (iter2 != null) { \n   if (iter2.hasNext()) \n    return true; \n  } \n  while (iter.hasNext()) { \n   iter2 = iter.next(); \n   if (iter2.hasNext()) \n    return true; \n  } \n  return false; \n } \n \n @Override \n public E next() { \n  if (iter2 != null) { \n   if (iter2.hasNext()) \n    return iter2.next(); \n  } \n  if (iter.hasNext()) { \n   iter2 = iter.next(); \n   return this.next(); \n  } \n  return null; \n } \n \n @Override \n public void remove() { \n  // TODO Auto-generated method stub \n \n } \n \n public static void main(String[] args) { \n  // I am making an iterator of iterator here. \n  ArrayList> integers = new ArrayList>(); \n  for (int i = 0; i < 10; i++) { \n   ArrayList temp = new ArrayList(); \n   for (int j = 0; j < i; j++) { \n    temp.add(i); \n   } \n   integers.add(temp); \n  } \n  ArrayList> iter = new ArrayList>(); \n  for (int i = 0; i < integers.size(); i++) { \n   iter.add(integers.get(i).iterator()); \n  } \n  Iterator> iterator = iter.iterator(); \n \n  // Now I pass the iterator of iterator to the class problem. Problem is \n  // actually an iterator since I implement Iterator \n  @SuppressWarnings({ \"rawtypes\", \"unchecked\" }) \n  Problem p = new Problem(iterator); \n  while (p.hasNext()) { \n   System.out.println(p.next()); \n  } \n } \n \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5205362126880768","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"0","title":"Write down the top ten testcases for sanity check of Templerun app in android based mobile. Testcases should appear in priority order?"}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5103437989543936","download_status":"DOWNLOAD_DONE","votes":"4","answersCount":"40","title":"There are many sorted arrays. Find a minimum range, so that in each array there's at least one integer within this range.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Here is my idea.   (A) Let's take the smallest element from each array. For each element we will remember from which array did we take it. Sort them and add to the queue this way : the smallest element will be on the first place.  (B) After this, we know the first and the last element. Let's count length of the interval. Next step is to pop element (let's call it x) and push next to x element, from the same array. Calculate length of the interval and repeat (B) until one of the arrays reaches its upper bound."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class minArrayRa?nge \n{ \n  public static void main(Strin?g args[]) \n  { \n \n  int [][] arrArrays=?{{3,4,5}, { 5, 58, 62}, {212, 434, 3333}}; \n  int []range=ge?tMinRange(?arrArrays)?; \n  System.out?.println(\"Min range = ?min = \"+range[0] + \" max = \" + range[1]); \n  } \n \n static int [] getMinRang?e(int [][] arrArrays) \n { \n \n  int max=-99999?, min=99999; \n  for ( int i=0; i < arrArrays.?length; i++) \n  { \n  if(max < arrArrays[?i][0]) \n  { \n  max=arrArr?ays[i][0]; \n  } \n \n  if(min > arrArrays[?i][0]) \n  { \n  min=arrArr?ays[i][0]; \n  } \n } \n \n int a[]= { min, max}; \n return a; \n \n} \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"WRONG SOLUTION (misunderstood the question) You need to find maximal value among all minimums, and minimal value among all maximums. If maximal minimum is less than minimal maximum, than you can use a range of size one, it may be any number within that range."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about first merge all sorted array and then traverse the merged list while keeping a window, make sure elements inside the window can be found in every original lists and keep updating the smallest window size."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I used divide and conquer strategy and it works. Yet, there can be one improvement and that is optimizing the size of nums array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class FindRangeEachArrayContainingAtleats1Integer { \n \n public static void main(String[] args) { \n \n  int a[] = { 1, 2, 3, 5 }; \n  int b[] = { 3, 5, 6, 7 }; \n  int c[] = { 2, 8, 9, 11 }; \n \n  Set se = new HashSet<>(); \n \n  for (int i = 0; i < a.length; i++) { \n   se.add(a[i]); \n  } \n  for (int i = 0; i < b.length; i++) { \n   se.add(b[i]); \n  } \n  for (int i = 0; i < c.length; i++) { \n   se.add(c[i]); \n  } \n  int length = se.size(); \n  int i = 0,min=0,max=0; \n  for (int a1 : se) { \n   if (i == 0) { \n     \n    min=a1; \n   } \n   i++; \n \n   if (i == length) { \n    max=a1; \n   } \n  } \n \n   System.out.println(\"Range is={ \"+min+ \",.....,\"+ max + \" } \"); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import sys \nfrom heapq import * \n \na1 = [1,6,8,10] \na2 = [3,9,20] \na3 = [6,10,20] \n \niters = [iter(a) for a in (a1, a2, a3)] \n \nheap = [(it.next(), it) for it in iters] \nheapify(heap) \n \nmin_range = (sys.maxint, (0,0)) \nmax_element = None \n \nwhile heap: \n    v, it = heappop(heap) \n \n    if max_element and v-max_element > 0: \n        min_range = min(min_range, (v-max_element, (max_element, v)), key=lambda x:x[0]) \n \n    max_element = max(v, max_element) \n \n    try: \n        heappush(heap, (it.next(), it)) \n    except: \n        break \n \nprint min_range[1]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please correct me if I am wrong but there is a simple greedy algorithm for this. Sort all the numbers from all the arrays. Start scanning numbers from the smallest (startNum)and stop at a number (stopNum) as soon as a number from each array has been scanned at least once (we know the array from which a number is taken from). save (stopNum,startNum). Next select, the next smallest number as the startNum for a new scan. Repeat till the end of the sorted array. Find the min range amongs the saved (stopNum,startNum) and that would be the answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The minimum possible range will be,  Min (Max value of each array) -- Max(Min value of each array).  Is this right ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Implementation of GK idea as Java Code."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I tested this for several of the inputs suggested above. Seems to work. Let me know if it breaks for any input. Use C++11 to compile it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This makes me think of Suffix Tree. Build up the tree, find the smallest common sub arr."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the best way to do it is to create a tree which once you print it in order gives all the elements of all the arrays sorted, then while creating that tree, for each element in the tree create a bit string which its size is the number of arrays and each bit says wether or not its contained by that array. At last pick the biggest numbers(they are contained by most of the arrays) and continue on their right and left until you fill your string with ones example(111111). Later compare your intervals which you traversed to find their minimum: Time complexity for creating the tree and the binaries for m arrays of size n:  O(m*n*log(m*n)) Time Complexity for traversing the fully sorted array and finding minimum interval(which it can be optimized) at worst case scenario is: O ((m)^2*n)  I'll write a code and post the link when I get the chance! but I don't think its necessary!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Previous comment is mine! :) Forgot to sign in! :D"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class ListOfArrays { \n ArrayList> listArray;  // list of sorted arrays \n ArrayList minIndexList;  // this list maintains the current index position within each array \n int minArray; \n boolean bFinal=false;  \n \n private class Interval { \n  Integer min= Integer.MAX_VALUE, max=Integer.MIN_VALUE; \n  boolean bFirst=true; \n \n \n  void setMinInterval() { \n   int low=Integer.MAX_VALUE,high=Integer.MIN_VALUE; \n   for(int i=0;ihigh) { \n     high=listArray.get(i).get(minIndexList.get(i)); \n    } \n   } \n   if((bFirst==true) || ((long) (high-low)<(long) (max - min))){ \n    min=low; \n    max=high; \n    bFirst=false; \n   } \n  } \n \n \n \n  public String toString() { \n   return String.format(\"[%d %d]\", min, max); \n  } \n } \n \n ListOfArrays(ArrayList> arrays) { \n  listArray=arrays; \n \n } \n \n ///////////////////// \n // \n ///////////////////// \n private void removeMin() { \n  int i = minArray; \n  if(minIndexList.get(i)(); \n \n \n \n  // init index list to 0th element \n  for(int i=0;i> arrays = new ArrayList>(); \n  ArrayList a,b,c,d,e,f ; \n  a= new ArrayList(); \n  a.add(2);a.add(10);a.add(20);a.add(53); \n \n  b= new ArrayList(); \n  b.add(1);b.add(5);b.add(52);b.add(54); \n \n  c= new ArrayList(); \n  c.add(23);c.add(24);c.add(53);c.add(55); \n \n  d= new ArrayList(); \n  d.add(5);d.add(6);d.add(7);d.add(52); \n \n  e= new ArrayList(); \n  e.add(24);e.add(28);e.add(50);e.add(52); \n \n  f= new ArrayList(); \n  f.add(3);f.add(21);f.add(51);f.add(53); \n \n  arrays.add(a);arrays.add(b);arrays.add(c); \n  arrays.add(d);arrays.add(e);arrays.add(f); \n  ListOfArrays m = new ListOfArrays(arrays); \n  Interval v = m.findMinRange(); \n  System.out.println(\"INPUT: \"+arrays.toString()); \n  System.out.println(\"OUTPUT: \"+v.toString()); \n \n } \n \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5125946302529536","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"15","title":"Find the kth largest node in an unsorted linked list. ( Is quick select (selection algorithm) applicable on linked list (not array?)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Selection algorithm is applicable on  linked lists."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There are two broad types/variants of the partition subroutines used for Quick(sort/select):  1) One broad type only has pointers/indices going from left to right"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"will the MAX heap help here?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Building a heap might work out or for kth greatest number maintain k + 1 pointers. Just try it with 2nd largest and 3rd largest element and check if k + 1 pointer funda works or not."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"getKthLargestInLL( linkedList, K ){ \n for( int i = 1; i<= K; i++ ){ \n  NODE node = findMax( linkedList ); \n  if( node == linkedList ) \n   linkedList = linkedList.next; \n } \n} \n \nNODE findMax( linkedList ){ \n Node maxNode = null; \n Node preMaxNode = null; \n Node lastNode = null; \n while( linkedList != null ){ \n  if( maxNode == null || maxNode.data < linkedList.data ){ \n   maxNode = linkedList; \n   preMaxNode = lastNode; \n  } \n  lastNode = linkedList; \n  linkedList = linkedList.next; \n } \n if( lastNode != null ) \n  lastNode.next = maxNode.next; \n return maxNode; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algorithm: We consider last node as the pivot and then partition the linked list using that pivot element. All the nodes smaller than the pivot will come before the pivot node and all the nodes greater than the pivot will come after the pivot node in the modified linked list. We pass the pivot element back to the calling method and see if the pivot is the desired kth element, in case it is we just return the pivot.  In case the position of the pivot is greater than the desired position, say k then we run the algorithm on the left side of the pivot node(i,e. from the head to the node prior to the pivot node).  In case the position of pivot is less than the desired position, we run the algorithm on the nodes that are on the right side of the pivot node( i,e node next to pivot to the tail) and decrease the distance by i(i being the position of the pivot in the linked list).  Code: #include  #include  using namespace std;  struct node {     int data;     struct node *next; };   /* Insert a node at the beginning of linked list */ void push(struct node** head_ref, int new_data) {     struct node* new_node = new node;     new_node->data  = new_data;     new_node->next = (*head_ref);     (*head_ref)    = new_node; }   /* A utility function to print linked list */ void printList(struct node *node) {     while (node != NULL)     {         cout<data<<\"\\t\";         node = node->next;     }     cout<}   // Returns the last node of the list struct node *getTail(struct node *cur) {     while (cur != NULL && cur->next != NULL)         cur = cur->next;     return cur; }  struct node *partition(struct node **head, struct node **tail) {  struct node *p,*q,*pivot=*tail,*temp;  p=*head;  while(p!=pivot)  {   if(p->data<=pivot->data)   {    q=p;    p=p->next;   }   else if(p->data>pivot->data)   {    if(p==*head)    {     *head=(*head)->next;    }    else{    q->next=p->next;    }    temp=p->next;    (*tail)->next=p;    p->next=NULL;    *tail=p;    p=temp;   }  }  return pivot; }  void quicksort(struct node **head, struct node **tail) {  if(*head==NULL || *head==*tail)  return;    struct node *p, *n;  p=partition(head,tail);   n=*head;  if(n!=p)  {  while(n->next!=p) n=n->next;  n->next=NULL;  quicksort(head,&n);  n->next=p;  }  quicksort(&(p->next),tail);   return; }  void quickSort(struct node **head) {  struct node *n=getTail(*head);  quicksort(head,&n);  return; }  struct node *kthElementHelper(struct node **head, struct node **tail, int k) {  int i=1;  struct node *p,*n,*res,*temp;  p=partition(head,tail);  n=*head;    if(n==p)  {  if(i!=k) return kthElementHelper(&(n->next),tail,k-1);  else return p;  }    while(n->next!=p)  {   n=n->next;   i=i+1;  }  i=i+1;  if(k==i) return p;  else if(k {   n->next=NULL;   res= kthElementHelper(head,&n,k);   n->next=p;  }  else if(k>i)  {   temp=(*tail)->next;   (*tail)->next=NULL;   res= kthElementHelper(&(p->next),tail,k-i);   (*tail)->next=temp;  }  return res; }  struct node *kthElement(struct node **h,int k) {  struct node *n=getTail(*h);  return kthElementHelper(h,&n,k); }  int main() {     struct node *a = NULL;     int k=3;     push(&a, 5);     push(&a, 20);     push(&a, 4);     push(&a, 3);     push(&a, 30);     push(&a, 1);       cout << \"Linked List before calling the Method \\n\";     printList(a);             cout<<\"\\nk is: \"<<<<\"kth largest element is: \"<data<<      cout << \"Linked List after calling the method \\n\";     printList(a);       return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Maintain a binary search tree of k nodes. Scan the input list, if current node value is larger than the smallest value of the tree nodes, remove that node and insert current node value into the binary search tree.   Time complexity is O(nlogk)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"quickSelect logic for a linked list Need to know the tail of the list for the logic to work."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"If we can modify this linked list:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5640239645196288","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"20","title":"Check if two binary search tree have the same in-order traversal in O(1) space","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"1, find the minimum of each binary search tree 2. call successor for each binary search tree"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"there's a way to do O(1) space tree traversal, which is called Morris Traversal. the idea is to add additional right link to a right leaf node's successor"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Here goes the logic: 1. Find first element in tree T1 as well as T2 while doing an inorder search (this is equivalent to finding smallest element in the tree.  - This can be starting from root, if left child is not null, leftmost child is the least node  - If no left child for root, root itself 2. Compare the two values, if not same return false else 3. Call inorder successor on both trees and find next smallest element 4. GO to step 2 5. If both the trees are exhausted (be careful here), return true else false (one is subset of other)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Could this possibly be solved using iterators? Get an iterator for each tree, then just keep checking is tree1.next().equals(tree2.next())"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"GZ_Penny, where did you get the question from?  How would you traversal on a single tree without a O(h) space stack (implicity via recursion or explicity container) ??????  Bad question."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Don't know what GC_PENNY is dreaming, but the \"best\" solution if parent pointers are not available seems to be (to me):  2 stacks, one for each tree.  Iteratively in order traverse each tree using independent stacks but check intermittently after each iteration in the obvious way for equality (and break if a no math condition is detected)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The Inorder of BSTs will be equal if both trees contain same elements .  We can check if two BSTs contains same elements by XORing all the elements in the tree with the other ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void isSame(node* root1, node* root2, bool& isSame) {     if( root1==NULL && root2 ==NULL) {          isSame = true;          return;      }      if( (root1 == NULL && root2 != NULL) || (root1!=NULL && root2!=NULL) {         isSame = false;         return;       }       isSame(root1->left, root2->left, isSame);       if( root1->data != root2->data){                 isSame = false;                 return;       }       isSame( root1->right, root2->right, isSame);      }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(1) space is impossible. you must use either recursive method or a stack to traverse the tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"public bool AreSame(Node a, Node b) \n        { \n            if (a == null && b==null) \n                return true; \n            if (a == null || b == null) \n                return false; \n            return AreSame(a.Left , b.Left) && a.Val == b.Val && AreSame(a.Right , b.Right); \n        }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5867650110455808","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"While playing NFS most wanted on a desktop, the application crashes. Debug the scenario?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Check RAM size, than Graphics Card.Basically look for the Hardware issues. Than, if not Hardware , U gotto look for the code where is the Memory leak !!! and  dependency libraries. Moreover, the deadlock scenarios are very common , so look for thread Mingling. those are Very Basics I think I would start with."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5117473942667264","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"A Desktop Java application which was working till yesterday crashes today --- no help from Java debugger. How do u go about debugging this?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Delta :- Change in the environment would be my primary concern. Like , Updates from the OS or the dependent library."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"1- how about enabling java console and run the app again, then see what console says on application crash. 2- Checking the application logs (if available). 3- Checking java environment (including path, CLASS_PATH etc) for possible issues."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If there is crash of application means that application gave core dump . So analyze the core dump  to know the cause . There can be many reason from crash .. h/w bus fault/socket closures etc .."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6206746368409600","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"VLC player installable is crashing. Debug","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Definitely the depended file / library missing!!!"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4846025567109120","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"37","title":"Given a number in an array form, Come up with an algorithm to push all the zeros to the end. Expectation : O(n) solution","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"the original order/arrangement of zeroes is not conserved once they have been pushed to the end."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"void movezeros(int arr[],int n) {       int i,end=n-1;      for(i=0;i    {        if(arr[end]==0)  {   end--;   continue;  }  if(arr[i]==0)  {   arr[i]=arr[i]+arr[end];   arr[end]=arr[i]-arr[end];   arr[i]=arr[i]-arr[end];   i++;  }        } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"here my c++ solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void removeZeros(int arr[], int n) \n{ \n    int i, pos = 0; \n    //copy nonzero numbers to the front \n    for(i = 0; i < n; ++i){ \n        if(arr[i] != 0) arr[pos++] = arr[i]; \n    } \n    //fill tail with zeros \n    for(i = pos; i < n; ++i) arr[i] = 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If one of the array element contains say 10 or 300?? int[] arr = {10, 300, 20, 4}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This O(n) solution iterates over the array with two indexes. If an element is not 0, we copy it to the position of the first index (and advance both indexes), if it is a 0 then we only advance the second index, counting the 0s encountered. When the second index gets to the end, we will have filled up the non-zero digits at the beginning, so we just need to make sure to fill the remaining elements at the end with 0s."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args){ \n  int[] noArrayform = {0,2,0,1,4,5,6,7,0,1,2,3,4,5,0,0,1,4,0}; \n  int[] outputArray = new int[noArrayform.length]; \n  int loopCount = 0; \n  int outputLength = 0; \n \n   \n  //copy the non zero values to the new output array \n  while(loopCount"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would use partition idea in the quick sort. A pointer at the beginning and a pointer at the end. Whenever the beginning pointer encounters a zero, swap the first pointers value with the second one. Then while there is an immediate zero before the second pointer move the second pointer back. Do it while (first pointer < second pointer)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class PushZero { public static void main(String...v){   ArrayDeque num = new ArrayDeque<>();      int arr[] = {1,3,5,0,0,4,6,0};   for(int i=0;i   if(arr[i]==0){     num.addLast(arr[i]);    }    else{     num.addFirst(arr[i]);    }   }   System.out.println(num.size());   for(Iterator itr = num.iterator();itr.hasNext();)  {       System.out.println(itr.next());     } } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void pushZero(int *array, int length) { \n    int zerocount = 0; // var to hold the num of Zeros in the given string \n    //Loop through all the elements of the array \n     \n    for (int i = 0; i < length; i++) { \n        // if element = 0, do nothing, just increment the count \n        if (0 == array[i]) { \n         zerocount++; \n      continue; \n     } \n         \n        //if not, then based on the zerocount, swap the elements \n     if (0 != zerocount) { \n      array[i - zerocount] = array[i]; \n      array[i] = 0; \n     } // end if \n    } // end for \n} // end pushZero()"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can use Partition, which uses \"n - 1\" comparisons and at most \"n - 1\" swaps using a customized comparator which assumes \"0\" is the largest number. Comparator code follows:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/** * Manuel. * Assuming there are 13 integers. Btw: I think the complexity reamins O(n) although I  * have outer loop here. */ #include   void inline swap(int *a, int *b); void pushZeros(int (&arr)[13]); void printArr(int (&arr)[13]);  int main() { int size= 13;  int arr[13]={1,2,3,0,0,0,-3,-4,0,0,1,0,0};  printArr(arr);  std::cout<<\"After pushing the zeros\"<<'\\n';  pushZeros(arr); printArr(arr);   return -1;  }  void printArr(int (&arr)[13]) {  for(int i=0; i < 13 ; i++)  {   std::cout<<\" \"< } }   void pushZeros(int (&arr)[13]) {    int *ptr1= arr;  int *ptr2= arr+ 13 -1;       while(ptr1 < ptr2)  {   while(*ptr1!=0 ) ptr1++;   while(*ptr2==0)  ptr2--;   if(ptr1 < ptr2) swap(ptr1, ptr2);   else break;    ptr1++;   ptr2--;   }    }  void inline swap(int *a, int *b) {  int c= *a;  *a= *b;   *b= c;   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args)  {   int[] array={1,2,0,3,4,0,3};   int length = array.length;   int multiplier = (int)Math.pow(10, length-1);   int num = 0;   for(int i=0;i   num = num + multiplier*array[i];    if(array[i]!=0)     multiplier=multiplier/10;   }   System.out.println(num);    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(int[] array)  {    int length = array.length;   int multiplier = (int)Math.pow(10, length-1);   int num = 0;   for(int i=0;i {    num = num + multiplier*array[i];    if(array[i]!=0)   multiplier=multiplier/10;   }  System.out.println(num);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this is a variant of dutch national flag problem. The solution is simple and can be achieved in o(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  //WAP to shift all zeroes to the end of the array using namespace std;  void sift(int a[],int n) {      int i=0,j=n-1,t;      while(i     {                 while(a[j]==0)                 {                            j--;                 }                   while(a[i]!=0)                  {                  i++;                                    }                  if(i                 {                     t=a[i];                     a[i]=a[j];                     a[j]=t;                  }      }      cout<<\"\\nArray is now:\";      for(int k=0;k       cout<}                                                                               int main() {      int a[100],n;      cout<<\"\\nEnter the number of elements:\";      cin>>n;      for(int i=0;i      cin>>a[i];       sift(a,n);       getch();       return 0;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \nusing namespace std; \n \nvoid moveZeroToEnd( int * data,size_t size) \n{ \n    if(!size) return; \n    size_t lastNonZeroPosition=size-1; \n    while(lastNonZeroPosition&&(!data[lastNonZeroPosition])) lastNonZeroPosition-- ; \n \n    for(size_t i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"j = len(a)  for i in range(j):  while (a[j-1] ==0):   j = j-1  if i == j:   break  if a[i] == 0 and a[j-1] !=0:   temp = a[i]   a[i] = a[j-1]   a[j-1] = temp   j = j-1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// Given a number in an array form, Come up with an algorithm to push all the zeros to the end.  \n// Expectation: O(n) solution \n \n#include  \n \nvoid print(int *arr, size_t size) \n{ \n using namespace std; \n \n for (size_t i = 0; i < size; ++i) \n  cout << arr[i] << ' '; \n cout << endl; \n} \n \nvoid pushZeroToEnd(int *arr, size_t size) \n{ \n int *start = arr; \n int *end = arr + size - 1; \n \n while (start < end) \n { \n  // Find first zero \n  while (*start != 0) ++start; \n \n  // Find last not zero \n  while (*end == 0) --end; \n \n  // Swap \n  *start++ = *end; \n  *end-- = 0; \n } \n} \n \nint main() \n{ \n int arr[] = { 1, 3, 0, 0, 0, 2, 0, 5, 4, 0, 3, 9, 0, 8, 0, 0 }; \n \n size_t size = sizeof(arr) / sizeof(int); \n \n print(arr, size); \n pushZeroToEnd(arr, size); \n print(arr, size); \n \n std::cin.get(); \n \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) \n{ \n int[] input = new int[]{ 0,5,6,0,0,2,4,0}; \n int nzpos = 0; //non-zero-position \n        int DigitToPush = 0; \n for(int i = 0 ; i < input.length; i++) \n { \n  if(arr[i] == DigitToPush)  \n   continue; \n  else \n   input[nzpos++] = input[i]; \n } \n // by this time all nonzero are at correct place; now fill-out rest of zeroes \n for(int j = nzpoz; j < input.length() ; j++) \n {  \n  input[j] = DigitToPush; \n } \n \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void swap(int[] a) {  int i = 0;  int j = a.length() - 1;  //[1,2,0,3,0,5,6,0,8,0]  while(j>i) {   if(a[i] == 0) {    while(j>i) {     if(a[j] != 0) {      int temp = a[j];      a[j] = a[i];      a[i] = temp;      break;     }     j--;    }   }   i++;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void swap(int[] a) {  int i = 0;  int j = a.length() - 1;  //[1,2,0,3,0,5,6,0,8,0]  while(j>i) {   if(a[i] == 0) {    while(j>i) {     if(a[j] != 0) {      int temp = a[j];      a[j] = a[i];      a[i] = temp;      break;     }     j--;    }   }   i++;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void swap(int[] a) {  int i = 0;  int j = a.length() - 1;  //[1,2,0,3,0,5,6,0,8,0]  while(j>i) {   if(a[i] == 0) {    while(j>i) {     if(a[j] != 0) {      int temp = a[j];      a[j] = a[i];      a[i] = temp;      break;     }     j--;    }   }   i++;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void swap(int[] a) {  int i = 0;  int j = a.length() - 1;  //[1,2,0,3,0,5,6,0,8,0]  while(j>i) {   if(a[i] == 0) {    while(j>i) {     if(a[j] != 0) {      int temp = a[j];      a[j] = a[i];      a[i] = temp;      break;     }     j--;    }   }   i++;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do a naive quiqsort implementation"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void PushZereosToEnd(int* arr,int len) {  int posZero = -1;   for(int i = 0; i < len; i++)  {   if(arr[i] == 0 && posZero == -1) //this is the zero index fisrt time    posZero = i;    else if(arr[i] != 0 && posZero != -1) //need to swap   {    int temp = arr[i];    arr[i] = arr[posZero];    arr[posZero] = temp;    posZero++;   }  }   for(int i = 0; i < len; i++)   std::cout<}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int size = (sizeof(arr) / sizeof(int) ) - 1;   for(int i = size,  j = size; i >=0 ;  i--){        if(a[i] == 0){            for(int k = i; k != j; k++){                a[k] = a[k+1];            }            a[j] = 0;            j--;        }    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void zeromove(int *a, int len) \n{ \n        int zero_start = 0; \n        int nonzero_pos = 0; \n \n        while(nonzero_pos < len) { \n                if (a[zero_start]) { \n                        zero_start++; \n                        nonzero_pos++; \n                } else if (!a[nonzero_pos]) { \n                        nonzero_pos++; \n                } else { \n                        swap(a[zero_start++], a[nonzero_pos++]); \n                } \n        } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"void moveZero(int a[]) {  int arrSize = sizeof(a)/sizeof(int);  int end = arrSize - 1;   for (int i = 0; i < arrSize; i++)  {   if ( a[i] == 0 )   {    std::swap(a[i], a[end]);    end--;   }   if (i == end)    break;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"void moveZero(int a[]) {  int arrSize = sizeof(a)/sizeof(int);  int end = arrSize - 1;   for (int i = 0; i < arrSize; i++)  {   if ( a[i] == 0 )   {    std::swap(a[i], a[end]);    end--;   }   if (i == end)    break;  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5428979330711552","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"0","title":"Test Google advertisements. Basically the expectation is to get the requirement, assume certain things and come up with test strategies. E.g : UI, Backend, Compatibility, Accessibility etc.  On the fly question were asked"}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5198021759336448","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"10","title":"Give 2 arrays of size 7 and 3 which are sorted such that the last 3 blocks in first array are empty, merge the arrays in a sorted manner in the most efficient way. E.g:-  a[7] = [4, 10, 11, 20__, __, __] b[3] = [1,3,7]","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"merge sort from right to left, placing the result in \"a\" as you go. return a."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Set two pointers at the very last number of the two arrays. Compare with the two numbers at the pointers, put the bigger one at the end of first array and move that pointer one left. Continue this process until both pointer move at the head of the arrays."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* \na[] is the bigger array;  \nb[] is the smaller array;  \nn is the size of bigger array; \nm is the size of smaller array \n*/ \nmerge(int a[], int b[], int n, int m) \n{ \n int c[n]; \n int i = n-m-1; \n int j = m-1; \n int k = n-1; \n while(i>=0 && j>=0 && k>=0) \n { \n  if(a[i] > b[j]) \n  { \n   c[k] = a[i]; \n   i--; \n  } \n  else \n  { \n   c[k] = b[j]; \n   j--; \n  } \n  k--; \n } \n if(i<0) \n { \n  while(j>=0 && k>=0) \n  { \n   c[k] = b[j]; \n   k--; \n   j--; \n  } \n } \n else if(j<0) \n { \n  while(i>=0 && k>=0) \n  { \n   c[k] = a[i]; \n   k--; \n   i--; \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int[] mergeSortedArray(int[] array1, int sizeA, int[] array2) {  int i=sizeA;  int j = array2.length-1;  int k = array1.length -1;    while(k>=0 && i>=0 && j>=0)  {   if(array1[i] > array2[j])   {    array1[k]=array1[i];    k--;    i--;   }   else   {    if(j>=0)    {    array1[k]=array2[j];    }    k--;    j--;   }     }  return array1; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The empty space in a is equal to the number of element in b, so we can merge from last element without extra space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) \n{ \n int[] arr1=new int[]{7,10,11,20,0,0,0}//0 at the end should be assumed as empty space \n int arr2 = new int[]{1,3,7}; \n  \n int i2=arr2.length() -1; \n int i1 = arr1.length()  -1 - i2; \n int j = arr1.length()-1; \n \n while(i1>0 && i2 > 0 && j > 0) \n { \n  if(arr1[i1] > arr2[i2])   \n    arr[j--] = arr[i1--]; \n  else \n    arr[j--] = arr[i2--]; \n } \n \n if(i2>=0) \n { \n  while(i2>=0) \n  { \n   arr[j--] = arr[i2--] \n  } \n } \n \n if(i1>=0) \n { \n  while(i1>=0) \n  { \n   arr[j--] = arr[i1--] \n  } \n } \n \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static int a[7] = {4, 10, 11, 20, 0, 0, 0}; static int a_len = 4; static int b[3] = {1, 3, 7};  void merge_sort() {         int store_pos = 6;         int a_cur = a_len-1;         int b_cur = 2;         while(a_cur >= 0 && b_cur >= 0) {                 if (a[a_cur] > b[b_cur]) {                         a[store_pos--] = a[a_cur--];                 } else {                         a[store_pos--] = b[b_cur--];                 }         }          if (a_cur < 0) {                 memmove(a, b, (b_cur+1)*sizeof(int));         } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Are we allowed to use O(1) extra space?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6460589673021440","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"0","title":"Was asked to explain Current QA and roles in detail. How was automation implemented and basis of the same?"}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4845432031150080","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"9","title":"Given a linked list like a1-a2-a3-a4-b1-b2-b3-b4. Convert it into a1-b1-a2-b2-a3-b3-a4-b4.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"reArrange(ll){ \naList= ll; \n while(ll.data != b1 ) \n  ll = ll.next; \nbList = ll; \nll = aList; //initialized ll to original start \n \nwhile( aList != null && bList != null ){ \n aListNextNode = aList.next; \n aList.next = bList ; \n aList = aListNextNode; \n bListNextNode = bList.next; \n bList.next = aListNextNode; \n bList = bListNextNode; \n} \nreturn ll; \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static Node transformList(Node head, int n){   Node temp1, temp2, midNode=null;   Node start = head;   temp1 = head;   for(int i=0; i   midNode = temp1.getNext();    temp1 = midNode;   }      Node swapIndex = reverseList(midNode.getNext());   System.out.println(\"swap is \"+swapIndex.data);   midNode.setNext(null);      return mergeList(head, swapIndex);     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node startNode = head; \n \nNode midNode = getMidNode(head); \n \nwhile(startNode!=null&&midNode!=null) \n{ \nNode startTemp = startNode.getNext(); \nNode midTemp = midNode.getNext(); \nstartNode.setNext(midNode); \nmideNode.setNext(startTemp); \nstartNode = startTemp; \nmidNode = midTemp; \n \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void transform(SingleLLNode header) { \n        int count = 0; \n        SingleLLNode current = header; \n        while(current != null) { \n            count++; \n            current = current.next; \n        } \n        int start = count/2,iteration = 1; \n        while(start > 1) { \n            int i = 0; \n            current = header; \n            while(i< start) { \n                current = current.next; \n                i++; \n            } \n            i = 0; \n            while (i < iteration) { \n                int temp = current.data; \n                current.data = current.next.data; \n                current.next.data = temp; \n                i++; \n                current = current.next.next; \n            } \n            iteration++; \n            start--; \n        } \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class Link { \n public String data; \n public Link next; \n \n Link() { \n \n } \n \n public Link(String data) { \n  this.data = data; \n \n } \n} \n \nclass InsertLinkList { \n private Link first; \n \n InsertLinkList() { \n  first = null; \n } \n \n public void intializeLink(String data) { \n  Link a = new Link(data); \n  if (first == null) { \n   first = a; \n   a.next = null; \n  } else { \n   a.next = first; \n   first = a; \n  } \n \n } \n \n public void display(InsertLinkList lin) { \n  while (first != null) { \n   System.out.println(first.data); \n   first = first.next; \n  } \n } \n \n public void display1(InsertLinkList lin) { \n \n  Link first1 = first; \n  Link first3 = first; \n \n  while (first1.next != null) { \n   System.out.println(first3.data); \n   first1 = first3.next.next.next; \n   System.out.println(first1.data); \n   first3 = first3.next; \n \n  } \n } \n} \n \npublic class LinkedLista1b1a2b2 { \n \n public static void main(String[] args) { \n \n  InsertLinkList lin = new InsertLinkList(); \n  lin.intializeLink(\"b3\"); \n  lin.intializeLink(\"b2\"); \n  lin.intializeLink(\"b1\"); \n \n  lin.intializeLink(\"a3\"); \n  lin.intializeLink(\"a2\"); \n  lin.intializeLink(\"a1\"); \n \n  lin.display1(lin); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Output-  a1 b1 a2 b2 a3 b3"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node rearrange(Node head, Node b1) {  Node p1 = head;  Node p2,p2_start = head;    if (head == null)   return;  while(p1 != b1)   p2 = p2.next;  Node p1_end = p2;  while(p1!=p2_start && p2!=null)  {   Node t1 = p1.next;   Node t2 = p2;      if (t2!=null)     p1.next = t2;   else    //if number of b < number of a   {    p1_end = null;    return head;   }   if (t1!=p2_start)   {    p1.next.next = t1;    p1 = p1.next.next;    p2 = p2.next;   }   else    //if number of a < number of b   {    p1.next = p2;    return head;   }  }  return head; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* This code works for any no of nodes */ \n \nalternate(struct list *a) \n{ \n struct list mid,temp,*fptr=a,*sptr=a;  \n int i =0;  \n /* find the middle of the list  */ \n while(fptr->next !=  NULL) \n { \n  if(i==0) \n  { \n   fptr=fptr->next; \n   i=1; \n  }else \n  { \n   fptr=fptr->next; \n   sptr=sptr->next; \n   i=0; \n  } \n } \n  \n fptr = a; \n temp = fptr->next; \n mid = sptr; \n /* Now sptr in the middle of the list and fptr start of the list */ \n while(sptr) \n { \n  if (sptr == fptr || sptr == temp) \n   break; \n  fptr->next = sptr; \n  sptr = sptr->next; \n  fptr = fptr->next; \n  if (!sptr || temp == mid) \n   break; \n  fptr->next = temp; \n  temp = temp->next; \n  fptr = fptr->next; \n   \n } \n if(sptr) \n  fptr->next = sptr; \n} \n \nTime Complexity : O(n) Space Complexity : O(1) \n \nSame can be achieved by Dynamic programming but takes O(nlog(n))"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5685761642856448","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"7","title":"Design news aggregator like google news, without using pull, push or page crawl. Explain how are you going to scale it.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How can we get information if we are not allowed to pull or push (page crawl is kind of pull) ??  I can think of only this: catching broadcast information should be aggregated ..  Further lights?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"with some assumptions, like pull model:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@Saurabh: Any ideas on how to scale this? Say, the number of sources have increased manifold.   Also, in general case, how will a news aggregator work on a push mechanism ever? Is it like each of the news source will \"push\" their states/news/information to a preconfigured server/location?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5867650110455808","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"While playing NFS most wanted on a desktop, the application crashes. Debug the scenario?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Check RAM size, than Graphics Card.Basically look for the Hardware issues. Than, if not Hardware , U gotto look for the code where is the Memory leak !!! and  dependency libraries. Moreover, the deadlock scenarios are very common , so look for thread Mingling. those are Very Basics I think I would start with."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5117473942667264","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"A Desktop Java application which was working till yesterday crashes today --- no help from Java debugger. How do u go about debugging this?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Delta :- Change in the environment would be my primary concern. Like , Updates from the OS or the dependent library."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"1- how about enabling java console and run the app again, then see what console says on application crash. 2- Checking the application logs (if available). 3- Checking java environment (including path, CLASS_PATH etc) for possible issues."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If there is crash of application means that application gave core dump . So analyze the core dump  to know the cause . There can be many reason from crash .. h/w bus fault/socket closures etc .."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6206746368409600","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"VLC player installable is crashing. Debug","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Definitely the depended file / library missing!!!"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4846025567109120","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"37","title":"Given a number in an array form, Come up with an algorithm to push all the zeros to the end. Expectation : O(n) solution","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"the original order/arrangement of zeroes is not conserved once they have been pushed to the end."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"void movezeros(int arr[],int n) {       int i,end=n-1;      for(i=0;i    {        if(arr[end]==0)  {   end--;   continue;  }  if(arr[i]==0)  {   arr[i]=arr[i]+arr[end];   arr[end]=arr[i]-arr[end];   arr[i]=arr[i]-arr[end];   i++;  }        } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"here my c++ solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void removeZeros(int arr[], int n) \n{ \n    int i, pos = 0; \n    //copy nonzero numbers to the front \n    for(i = 0; i < n; ++i){ \n        if(arr[i] != 0) arr[pos++] = arr[i]; \n    } \n    //fill tail with zeros \n    for(i = pos; i < n; ++i) arr[i] = 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If one of the array element contains say 10 or 300?? int[] arr = {10, 300, 20, 4}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This O(n) solution iterates over the array with two indexes. If an element is not 0, we copy it to the position of the first index (and advance both indexes), if it is a 0 then we only advance the second index, counting the 0s encountered. When the second index gets to the end, we will have filled up the non-zero digits at the beginning, so we just need to make sure to fill the remaining elements at the end with 0s."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args){ \n  int[] noArrayform = {0,2,0,1,4,5,6,7,0,1,2,3,4,5,0,0,1,4,0}; \n  int[] outputArray = new int[noArrayform.length]; \n  int loopCount = 0; \n  int outputLength = 0; \n \n   \n  //copy the non zero values to the new output array \n  while(loopCount"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would use partition idea in the quick sort. A pointer at the beginning and a pointer at the end. Whenever the beginning pointer encounters a zero, swap the first pointers value with the second one. Then while there is an immediate zero before the second pointer move the second pointer back. Do it while (first pointer < second pointer)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class PushZero { public static void main(String...v){   ArrayDeque num = new ArrayDeque<>();      int arr[] = {1,3,5,0,0,4,6,0};   for(int i=0;i   if(arr[i]==0){     num.addLast(arr[i]);    }    else{     num.addFirst(arr[i]);    }   }   System.out.println(num.size());   for(Iterator itr = num.iterator();itr.hasNext();)  {       System.out.println(itr.next());     } } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void pushZero(int *array, int length) { \n    int zerocount = 0; // var to hold the num of Zeros in the given string \n    //Loop through all the elements of the array \n     \n    for (int i = 0; i < length; i++) { \n        // if element = 0, do nothing, just increment the count \n        if (0 == array[i]) { \n         zerocount++; \n      continue; \n     } \n         \n        //if not, then based on the zerocount, swap the elements \n     if (0 != zerocount) { \n      array[i - zerocount] = array[i]; \n      array[i] = 0; \n     } // end if \n    } // end for \n} // end pushZero()"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can use Partition, which uses \"n - 1\" comparisons and at most \"n - 1\" swaps using a customized comparator which assumes \"0\" is the largest number. Comparator code follows:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/** * Manuel. * Assuming there are 13 integers. Btw: I think the complexity reamins O(n) although I  * have outer loop here. */ #include   void inline swap(int *a, int *b); void pushZeros(int (&arr)[13]); void printArr(int (&arr)[13]);  int main() { int size= 13;  int arr[13]={1,2,3,0,0,0,-3,-4,0,0,1,0,0};  printArr(arr);  std::cout<<\"After pushing the zeros\"<<'\\n';  pushZeros(arr); printArr(arr);   return -1;  }  void printArr(int (&arr)[13]) {  for(int i=0; i < 13 ; i++)  {   std::cout<<\" \"< } }   void pushZeros(int (&arr)[13]) {    int *ptr1= arr;  int *ptr2= arr+ 13 -1;       while(ptr1 < ptr2)  {   while(*ptr1!=0 ) ptr1++;   while(*ptr2==0)  ptr2--;   if(ptr1 < ptr2) swap(ptr1, ptr2);   else break;    ptr1++;   ptr2--;   }    }  void inline swap(int *a, int *b) {  int c= *a;  *a= *b;   *b= c;   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args)  {   int[] array={1,2,0,3,4,0,3};   int length = array.length;   int multiplier = (int)Math.pow(10, length-1);   int num = 0;   for(int i=0;i   num = num + multiplier*array[i];    if(array[i]!=0)     multiplier=multiplier/10;   }   System.out.println(num);    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(int[] array)  {    int length = array.length;   int multiplier = (int)Math.pow(10, length-1);   int num = 0;   for(int i=0;i {    num = num + multiplier*array[i];    if(array[i]!=0)   multiplier=multiplier/10;   }  System.out.println(num);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this is a variant of dutch national flag problem. The solution is simple and can be achieved in o(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  //WAP to shift all zeroes to the end of the array using namespace std;  void sift(int a[],int n) {      int i=0,j=n-1,t;      while(i     {                 while(a[j]==0)                 {                            j--;                 }                   while(a[i]!=0)                  {                  i++;                                    }                  if(i                 {                     t=a[i];                     a[i]=a[j];                     a[j]=t;                  }      }      cout<<\"\\nArray is now:\";      for(int k=0;k       cout<}                                                                               int main() {      int a[100],n;      cout<<\"\\nEnter the number of elements:\";      cin>>n;      for(int i=0;i      cin>>a[i];       sift(a,n);       getch();       return 0;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \nusing namespace std; \n \nvoid moveZeroToEnd( int * data,size_t size) \n{ \n    if(!size) return; \n    size_t lastNonZeroPosition=size-1; \n    while(lastNonZeroPosition&&(!data[lastNonZeroPosition])) lastNonZeroPosition-- ; \n \n    for(size_t i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"j = len(a)  for i in range(j):  while (a[j-1] ==0):   j = j-1  if i == j:   break  if a[i] == 0 and a[j-1] !=0:   temp = a[i]   a[i] = a[j-1]   a[j-1] = temp   j = j-1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// Given a number in an array form, Come up with an algorithm to push all the zeros to the end.  \n// Expectation: O(n) solution \n \n#include  \n \nvoid print(int *arr, size_t size) \n{ \n using namespace std; \n \n for (size_t i = 0; i < size; ++i) \n  cout << arr[i] << ' '; \n cout << endl; \n} \n \nvoid pushZeroToEnd(int *arr, size_t size) \n{ \n int *start = arr; \n int *end = arr + size - 1; \n \n while (start < end) \n { \n  // Find first zero \n  while (*start != 0) ++start; \n \n  // Find last not zero \n  while (*end == 0) --end; \n \n  // Swap \n  *start++ = *end; \n  *end-- = 0; \n } \n} \n \nint main() \n{ \n int arr[] = { 1, 3, 0, 0, 0, 2, 0, 5, 4, 0, 3, 9, 0, 8, 0, 0 }; \n \n size_t size = sizeof(arr) / sizeof(int); \n \n print(arr, size); \n pushZeroToEnd(arr, size); \n print(arr, size); \n \n std::cin.get(); \n \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) \n{ \n int[] input = new int[]{ 0,5,6,0,0,2,4,0}; \n int nzpos = 0; //non-zero-position \n        int DigitToPush = 0; \n for(int i = 0 ; i < input.length; i++) \n { \n  if(arr[i] == DigitToPush)  \n   continue; \n  else \n   input[nzpos++] = input[i]; \n } \n // by this time all nonzero are at correct place; now fill-out rest of zeroes \n for(int j = nzpoz; j < input.length() ; j++) \n {  \n  input[j] = DigitToPush; \n } \n \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void swap(int[] a) {  int i = 0;  int j = a.length() - 1;  //[1,2,0,3,0,5,6,0,8,0]  while(j>i) {   if(a[i] == 0) {    while(j>i) {     if(a[j] != 0) {      int temp = a[j];      a[j] = a[i];      a[i] = temp;      break;     }     j--;    }   }   i++;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void swap(int[] a) {  int i = 0;  int j = a.length() - 1;  //[1,2,0,3,0,5,6,0,8,0]  while(j>i) {   if(a[i] == 0) {    while(j>i) {     if(a[j] != 0) {      int temp = a[j];      a[j] = a[i];      a[i] = temp;      break;     }     j--;    }   }   i++;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void swap(int[] a) {  int i = 0;  int j = a.length() - 1;  //[1,2,0,3,0,5,6,0,8,0]  while(j>i) {   if(a[i] == 0) {    while(j>i) {     if(a[j] != 0) {      int temp = a[j];      a[j] = a[i];      a[i] = temp;      break;     }     j--;    }   }   i++;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void swap(int[] a) {  int i = 0;  int j = a.length() - 1;  //[1,2,0,3,0,5,6,0,8,0]  while(j>i) {   if(a[i] == 0) {    while(j>i) {     if(a[j] != 0) {      int temp = a[j];      a[j] = a[i];      a[i] = temp;      break;     }     j--;    }   }   i++;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do a naive quiqsort implementation"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void PushZereosToEnd(int* arr,int len) {  int posZero = -1;   for(int i = 0; i < len; i++)  {   if(arr[i] == 0 && posZero == -1) //this is the zero index fisrt time    posZero = i;    else if(arr[i] != 0 && posZero != -1) //need to swap   {    int temp = arr[i];    arr[i] = arr[posZero];    arr[posZero] = temp;    posZero++;   }  }   for(int i = 0; i < len; i++)   std::cout<}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int size = (sizeof(arr) / sizeof(int) ) - 1;   for(int i = size,  j = size; i >=0 ;  i--){        if(a[i] == 0){            for(int k = i; k != j; k++){                a[k] = a[k+1];            }            a[j] = 0;            j--;        }    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void zeromove(int *a, int len) \n{ \n        int zero_start = 0; \n        int nonzero_pos = 0; \n \n        while(nonzero_pos < len) { \n                if (a[zero_start]) { \n                        zero_start++; \n                        nonzero_pos++; \n                } else if (!a[nonzero_pos]) { \n                        nonzero_pos++; \n                } else { \n                        swap(a[zero_start++], a[nonzero_pos++]); \n                } \n        } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"void moveZero(int a[]) {  int arrSize = sizeof(a)/sizeof(int);  int end = arrSize - 1;   for (int i = 0; i < arrSize; i++)  {   if ( a[i] == 0 )   {    std::swap(a[i], a[end]);    end--;   }   if (i == end)    break;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"void moveZero(int a[]) {  int arrSize = sizeof(a)/sizeof(int);  int end = arrSize - 1;   for (int i = 0; i < arrSize; i++)  {   if ( a[i] == 0 )   {    std::swap(a[i], a[end]);    end--;   }   if (i == end)    break;  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5428979330711552","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"0","title":"Test Google advertisements. Basically the expectation is to get the requirement, assume certain things and come up with test strategies. E.g : UI, Backend, Compatibility, Accessibility etc.  On the fly question were asked"}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5198021759336448","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"10","title":"Give 2 arrays of size 7 and 3 which are sorted such that the last 3 blocks in first array are empty, merge the arrays in a sorted manner in the most efficient way. E.g:-  a[7] = [4, 10, 11, 20__, __, __] b[3] = [1,3,7]","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"merge sort from right to left, placing the result in \"a\" as you go. return a."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Set two pointers at the very last number of the two arrays. Compare with the two numbers at the pointers, put the bigger one at the end of first array and move that pointer one left. Continue this process until both pointer move at the head of the arrays."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* \na[] is the bigger array;  \nb[] is the smaller array;  \nn is the size of bigger array; \nm is the size of smaller array \n*/ \nmerge(int a[], int b[], int n, int m) \n{ \n int c[n]; \n int i = n-m-1; \n int j = m-1; \n int k = n-1; \n while(i>=0 && j>=0 && k>=0) \n { \n  if(a[i] > b[j]) \n  { \n   c[k] = a[i]; \n   i--; \n  } \n  else \n  { \n   c[k] = b[j]; \n   j--; \n  } \n  k--; \n } \n if(i<0) \n { \n  while(j>=0 && k>=0) \n  { \n   c[k] = b[j]; \n   k--; \n   j--; \n  } \n } \n else if(j<0) \n { \n  while(i>=0 && k>=0) \n  { \n   c[k] = a[i]; \n   k--; \n   i--; \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int[] mergeSortedArray(int[] array1, int sizeA, int[] array2) {  int i=sizeA;  int j = array2.length-1;  int k = array1.length -1;    while(k>=0 && i>=0 && j>=0)  {   if(array1[i] > array2[j])   {    array1[k]=array1[i];    k--;    i--;   }   else   {    if(j>=0)    {    array1[k]=array2[j];    }    k--;    j--;   }     }  return array1; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The empty space in a is equal to the number of element in b, so we can merge from last element without extra space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) \n{ \n int[] arr1=new int[]{7,10,11,20,0,0,0}//0 at the end should be assumed as empty space \n int arr2 = new int[]{1,3,7}; \n  \n int i2=arr2.length() -1; \n int i1 = arr1.length()  -1 - i2; \n int j = arr1.length()-1; \n \n while(i1>0 && i2 > 0 && j > 0) \n { \n  if(arr1[i1] > arr2[i2])   \n    arr[j--] = arr[i1--]; \n  else \n    arr[j--] = arr[i2--]; \n } \n \n if(i2>=0) \n { \n  while(i2>=0) \n  { \n   arr[j--] = arr[i2--] \n  } \n } \n \n if(i1>=0) \n { \n  while(i1>=0) \n  { \n   arr[j--] = arr[i1--] \n  } \n } \n \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static int a[7] = {4, 10, 11, 20, 0, 0, 0}; static int a_len = 4; static int b[3] = {1, 3, 7};  void merge_sort() {         int store_pos = 6;         int a_cur = a_len-1;         int b_cur = 2;         while(a_cur >= 0 && b_cur >= 0) {                 if (a[a_cur] > b[b_cur]) {                         a[store_pos--] = a[a_cur--];                 } else {                         a[store_pos--] = b[b_cur--];                 }         }          if (a_cur < 0) {                 memmove(a, b, (b_cur+1)*sizeof(int));         } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Are we allowed to use O(1) extra space?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6460589673021440","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"0","title":"Was asked to explain Current QA and roles in detail. How was automation implemented and basis of the same?"}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4845432031150080","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"9","title":"Given a linked list like a1-a2-a3-a4-b1-b2-b3-b4. Convert it into a1-b1-a2-b2-a3-b3-a4-b4.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"reArrange(ll){ \naList= ll; \n while(ll.data != b1 ) \n  ll = ll.next; \nbList = ll; \nll = aList; //initialized ll to original start \n \nwhile( aList != null && bList != null ){ \n aListNextNode = aList.next; \n aList.next = bList ; \n aList = aListNextNode; \n bListNextNode = bList.next; \n bList.next = aListNextNode; \n bList = bListNextNode; \n} \nreturn ll; \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static Node transformList(Node head, int n){   Node temp1, temp2, midNode=null;   Node start = head;   temp1 = head;   for(int i=0; i   midNode = temp1.getNext();    temp1 = midNode;   }      Node swapIndex = reverseList(midNode.getNext());   System.out.println(\"swap is \"+swapIndex.data);   midNode.setNext(null);      return mergeList(head, swapIndex);     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node startNode = head; \n \nNode midNode = getMidNode(head); \n \nwhile(startNode!=null&&midNode!=null) \n{ \nNode startTemp = startNode.getNext(); \nNode midTemp = midNode.getNext(); \nstartNode.setNext(midNode); \nmideNode.setNext(startTemp); \nstartNode = startTemp; \nmidNode = midTemp; \n \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void transform(SingleLLNode header) { \n        int count = 0; \n        SingleLLNode current = header; \n        while(current != null) { \n            count++; \n            current = current.next; \n        } \n        int start = count/2,iteration = 1; \n        while(start > 1) { \n            int i = 0; \n            current = header; \n            while(i< start) { \n                current = current.next; \n                i++; \n            } \n            i = 0; \n            while (i < iteration) { \n                int temp = current.data; \n                current.data = current.next.data; \n                current.next.data = temp; \n                i++; \n                current = current.next.next; \n            } \n            iteration++; \n            start--; \n        } \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class Link { \n public String data; \n public Link next; \n \n Link() { \n \n } \n \n public Link(String data) { \n  this.data = data; \n \n } \n} \n \nclass InsertLinkList { \n private Link first; \n \n InsertLinkList() { \n  first = null; \n } \n \n public void intializeLink(String data) { \n  Link a = new Link(data); \n  if (first == null) { \n   first = a; \n   a.next = null; \n  } else { \n   a.next = first; \n   first = a; \n  } \n \n } \n \n public void display(InsertLinkList lin) { \n  while (first != null) { \n   System.out.println(first.data); \n   first = first.next; \n  } \n } \n \n public void display1(InsertLinkList lin) { \n \n  Link first1 = first; \n  Link first3 = first; \n \n  while (first1.next != null) { \n   System.out.println(first3.data); \n   first1 = first3.next.next.next; \n   System.out.println(first1.data); \n   first3 = first3.next; \n \n  } \n } \n} \n \npublic class LinkedLista1b1a2b2 { \n \n public static void main(String[] args) { \n \n  InsertLinkList lin = new InsertLinkList(); \n  lin.intializeLink(\"b3\"); \n  lin.intializeLink(\"b2\"); \n  lin.intializeLink(\"b1\"); \n \n  lin.intializeLink(\"a3\"); \n  lin.intializeLink(\"a2\"); \n  lin.intializeLink(\"a1\"); \n \n  lin.display1(lin); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Output-  a1 b1 a2 b2 a3 b3"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node rearrange(Node head, Node b1) {  Node p1 = head;  Node p2,p2_start = head;    if (head == null)   return;  while(p1 != b1)   p2 = p2.next;  Node p1_end = p2;  while(p1!=p2_start && p2!=null)  {   Node t1 = p1.next;   Node t2 = p2;      if (t2!=null)     p1.next = t2;   else    //if number of b < number of a   {    p1_end = null;    return head;   }   if (t1!=p2_start)   {    p1.next.next = t1;    p1 = p1.next.next;    p2 = p2.next;   }   else    //if number of a < number of b   {    p1.next = p2;    return head;   }  }  return head; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* This code works for any no of nodes */ \n \nalternate(struct list *a) \n{ \n struct list mid,temp,*fptr=a,*sptr=a;  \n int i =0;  \n /* find the middle of the list  */ \n while(fptr->next !=  NULL) \n { \n  if(i==0) \n  { \n   fptr=fptr->next; \n   i=1; \n  }else \n  { \n   fptr=fptr->next; \n   sptr=sptr->next; \n   i=0; \n  } \n } \n  \n fptr = a; \n temp = fptr->next; \n mid = sptr; \n /* Now sptr in the middle of the list and fptr start of the list */ \n while(sptr) \n { \n  if (sptr == fptr || sptr == temp) \n   break; \n  fptr->next = sptr; \n  sptr = sptr->next; \n  fptr = fptr->next; \n  if (!sptr || temp == mid) \n   break; \n  fptr->next = temp; \n  temp = temp->next; \n  fptr = fptr->next; \n   \n } \n if(sptr) \n  fptr->next = sptr; \n} \n \nTime Complexity : O(n) Space Complexity : O(1) \n \nSame can be achieved by Dynamic programming but takes O(nlog(n))"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5796662664495104","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"16","title":"Suppose there is array contains 100 unsorted elements ...say a[1] to a[100]. find out the minimum and maximum value in the range of a[25] to a[75].","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"If the question is really just to find the min and max in a[25],...,a[75], I don't see the point of specifying the start and end locations instead of just finding the min and max in the whole array. I think we need some clarification.  Anyway, if it is really just to find the min and max, here is a slightly better way to do it:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I agree with you. My mistake I meant"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I don't see the need to use any sorting technique.... We could just start the index from 25 and scan up to 75 and simultaneously find max and min and this is 0(n)....one might argue tree is better but there's an overhead constructing the tree itself so simple scan will suffice..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"What about a merge sort in O (n log n) from  index 25 to 75.   so that Min = a[25] and Max = a[75]."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Segment Trees if the queries is too high.. or just do a min,max"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"#include \"stdio.h\" \n \nvoid printMinMaxInRange(int start, int end, int array[]) \n{ \n int i = 0; \n int min = end; \n int max = start; \n while (i <= ((end - start) / 2)) \n { \n  if (array[i+start] > array[max]) \n   max = i + start; \n  if (array[end - i] > array[max]) \n   max = end - i; \n  if (array[i+start] < array[min]) \n   min = i + start; \n  if (array[end - i] < array[min]) \n   min = end - i; \n  i++; \n } \n printf(\"max %d at index %d\\nmin %d at index %d\\n\", \n  array[max],max,array[min],min); \n} \n \n \nint main(int argc, char *argv[]) \n{ \n srand(time(NULL)); \n int a[101]; \n int i = 1; \n while (i < 101) \n { \n  a[i] = rand() % 1000; \n  i++; \n } \n printMinMaxInRange(25,75,a); \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5681997104021504","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"14","title":"Write a prog in any language you are comfortable, which takes 2 strings as an input and then finds the first occurrence of the first string in the second string. The function should return the index in the second string where the match was found.   Tip : The basic algorithm here is to iterate through the second string and when the char matches the first char in the 1st string., check if subsequent substring is a match, and return if it is.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def prefix(st, text, str_len): \n    i = 0 \n    while st[i] == text[i] and str_len: \n        str_len -= 1 \n        if str_len: \n            i += 1 \n \n    if not str_len: \n        return True \n    else: \n        return ord(st[i]) - ord(text[i]) \n \n \ndef strstr(st, text): \n    str_len = len(st) \n    for i in range(len(text) - len(st)+1): \n        if type(prefix(st, text[i:], str_len)) == bool: \n            return i \n \n    return -1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the program is going to be used only once. What the tip suggests is good enough. Taking O(nm) time, where n is the length of the longer string and m is the length of the shorter one.  If it is going to be used many times for checking different substrings, first build the surffix tree of the long string. Then checking a substring of length m only takes O(m) time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use KMP algo."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int getSubStringStartingPosition(char[] st1, char[] st2) \n { \n  int pos=0; \n  boolean flag=false; \n   \n  int k=0; \n  for (int i=0; i<=st1.length-1; ++i) \n  { \n   if ((k <= st2.length-1) && (st1[i]==st2[k])) \n   { \n    //System.out.println(\"found..\"+st2[k]); \n    if (!flag) \n    { \n     pos=i; \n    } \n      \n    flag=true; \n    k++; \n   } \n   else \n   { \n    System.out.println(\"not found..\"+st1[i]); \n    if (flag && k <=st2.length-1) \n    { \n     System.out.println(\"found an extra character in the middle..\"); \n     pos=-1; \n    } \n   } \n  } \n  return pos; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"????  var indexOf = function(search, target){  for(var k = 0; k < search.length; k++){      if(search[k] = target[0]){              var found = true;          for(var j = 0; j < target.length; j++){                  found = found & (search[k + j] == target[j]);                      }                  if(found){              return k;                  }              }  }  return -1;   }  console.log(indexOf('this works','works')); console.log(indexOf('AAAB','AAB'));  ????"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public String findThisInString(String string1, String string2) \n { \n  int index = string1.indexOf(string2); \n  return String.format(\"Found '%s' at index: %d\", string2, index); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public String findThisInString(String string1, String string2) \n { \n  int index = string1.indexOf(string2); \n  return String.format(\"Found '%s' at index: %d\", string2, index); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"KMP (easy if you know that)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"KMP (easy if you know that)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"he easy C++ way to do this is to use std::string::find:  std::string s = \"apple\"; std::string sub = \"ple\"; auto index = s.find(sub); //std::string::npos if not found The way for C would be strstr:  const char *s = \"apple\"; const char *sub = \"ple\"; const char *pos = strstr(s, sub); //NULL if not found"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Worst case Complexity : O(n)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5474060859342848","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"7","title":"In the Amazon Office, Employees are use to sit in cubical offices and all the offices are connected with some other offices, but they are not arranged in any well defined order. Offices are connected means they are sharing their walls with other offices. There are two types of Employees in Amazon i.e. 'Testers' and 'Developers'. Manager of Amazon don't want any 'Tester' and 'Developer' to sit in nearby cubical office, it means there should not be any shared wall between two 'Testers'/'Developers'.  Input:- First line consist of an integer n, which is number of common walls. Next n lines consist of 2 integers a and b, which represents the Office Number between which the wall is being shared. Output: - Print 'Yes', if condition of the manager can be satisfied and print 'No' if not.  Example: - 1-2-3     |    4 Office number 2 is sharing its 3 walls with Office 1,3 & 4.....that is why if Office 2 has a 'Developer' than Office 1,3 & 4 cannot have any 'Developer'.  INPUT:- 3 1 2 2 3 2 4 Output: - Yes  Any better approach then DFS i.e. O(V+E)..??","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Do we know how many offices is reserved for developers and testers?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"How it is yes in your example ? You cannot sit anybody in cubicle 2 as every cubicle is adjacent to it, then how will place them in cubicle 2 ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Construct a graph and see whether it is bipartite or not.   Let us say u represent a developer node by red color and tester by green color, walls as edges . If no two adjacent nodes have same color then Answer to the manager question is YES or else it is a NO"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this is typical two colors problem. You can start at any office with for example tester in it, then check all directly connect offices, if there is one that has tester, then report no. Otherwise, assign all the neighbor offices with mark developer, so on and forth. Time complexity is O(E), space complexity is O(V)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is simply a 2 coloring theorem. A graph is 2 colorable if and only if it has no circuit of odd length. Finally if it is a tree it is obviously 2 colorable."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is can be done in two ways: 1. Check if there is odd number of cycle. If it is then it is NO 2. If it is even number of cycle the print yes 3.If it doesn't contain cycle print yes.   -This is a bi-partite graph.   Second method: DFS Check if there is an edge from child to parent. If it is then check whether the parent is \"Tester or Developer\". If it is same as child then Print NO. Otherwise \"Yes\"."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6448780970819584","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"10","title":"Search in a row wise and column wise sorted matrix","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Assuming both sorted in strictly increasing order:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"can't we do a binary search across rows and column? start at the middle row and move up and down till we narrow down the row and then the same thing on the columns. O(log rows * log cols )"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"sorted in row+column means you can just \"flat out\" the matrix into an array to do a binary search.  turn: 1 3 4 5 6 6 7 7 9 9 10 10 12 17 29 31  into: 1 3 4 5 6 6 7 7 9 9 10 10 12 17 29 31  we don't need to \"physically\" rearrange the matrix into an array by coping or something.   As@chriscow made a good point that the biggest problem with binary search is that we don't know what row/column to continue for the iteration. We can work on that:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6010811243823104","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"3","title":"Give some practical applications of binary search trees","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Binary Search Tree - Used in many search applications where data is constantly entering/leaving, such as the map and set objects in many languages' libraries. Binary Space Partition - Used in almost every 3D video game to determine what objects need to be rendered. Binary Tries - Used in almost every high-bandwidth router for storing router-tables. Hash Trees - used in p2p programs and specialized image-signatures in which a hash needs to be verified, but the whole file is not available. Heaps - Used in implementing efficient priority-queues, which in turn are used for scheduling processes in many operating systems, Quality-of-Service in routers, and A* (path-finding algorithm used in AI applications, including robotics and video games). Also used in heap-sort. Huffman Coding Tree (Chip Uni) - used in compression algorithms, such as those used by the .jpeg and .mp3 file-formats. GGM Trees - Used in cryptographic applications to generate a tree of pseudo-random numbers. Syntax Tree - Constructed by compilers and (implicitly) calculators to parse expressions. Treap - Randomized data structure used in wireless networking and memory allocation. T-tree - Though most databases use some form of B-tree to store data on the drive, databases which keep all (most) their data in memory often use T-trees to do so."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Attaching another great resource, use of different data structures in linux kernel - cstheory.stackexchange.com/questions/19759/core-algorithms-deployed/19773#19773"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"java.util.TreeMap  and java.util.TreeSet classes of JAVA."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5075779650060288","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"13","title":"given a bst, find the in-order successor of a given node. th nodes dont have a pointer to parent","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"A basic inorder traversal can solve the problem as other posters have pointed out. But it is wasteful. In the case the target is in the right subtree of the root, traversing the whole left subtree is useless.  In fact, a modified binary search is more suitable here. Notice that"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.We can traverse tree in inorder manner. 2. We will have two pointers prev and current. 3.When prev is equal to the node given  current pointer will b our answer.  Correct me If I m wrong."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"directly walk thru the whole BST is not ideal.   One possible solution is this -   1. you check the given target node, and see if the node has a right child, if it has the successor is the most left element in the right child tree (let me know if you can't understand this part.)  2. if the given target node doesn't have a right child, means you need to figure out the element that is just bigger than the target, because the target has no right child, it can tell that by itself, so what to do next is to utilize and walk thru the BST , keep a track of the most recent element that is bigger than the target element until we find the element.   Return Null if such element doesn't exist."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"find a node with a given value, keeping track of parent too"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"NODE * inorder_successor(NODE *p, NODE *nodeToBeSearched) \n{ \n static bool found =0; \n if (p == NULL) \n  return NULL; \n else \n { \n        if (p == nodeToBeSearched) { \n            return p; \n        } \n        else \n        { \n            NODE *nodefound = inorder_successor(p->left, nodeToBeSearched); \n            if (nodefound != NULL) { \n                if (!found) { \n                    found = 1; \n                    return p; \n                } \n                else \n                    return nodefound; \n            } \n            else \n            { \n                return inorder_successor(p->right, nodeToBeSearched); \n            } \n        } \n    } \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5880722858442752","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"7","title":"Given a log file from a website which contains the user ID and the accessed URL, find the TOP \"sequence\" of 3 urls amongst ALL visitors of the website. The sequence of urls have to be in sequence as they are accessed.  My solution is Two hashtables and one MaxUrl object. One hashtable userName as key and url sequence as value, where url sequence is three url contatenated by a special character like '#' (google#amazon#yahoo). This value is in FIFO manner. For each value, we check with the second hashtable and see if they exist before, if yes, increment the count, if no, insert the new sequence with count set to 0. So second hashtable url sequence as key and count as value. Keep a curr_Max to store the current max count, when exceeded, updates max_urlSequence.  Any suggestion?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"there is one log entry per user?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can use Priority Queue (represented by Doubly linked List), having pointers to both head and tail. Also maintain a hashtable which maps to nodes based on URL."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Create a hash map with the user Ids as a key(s), the value of a particular user would point to another hash map with indexes representing the sequence of {3} websites and a value that is the count of that sequence. After generating the data structure, simply iterate through the users and their sequence of {3} values and store the maximum sequence until you've gone through both hash maps."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can use a TRIE data structure, where every entry is a URL and we build the TRIE in the same order as in the log. At the leaf node we maintain the count of the sequence"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"You can always check your previous question id=5664748918013952 :)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5646963089342464","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"3","title":"How to design a zoo in oop? Some basic ideas are to have an abstract Animal class and have birds, mammal extend from it. Also have a class called Cages with different size. Zoo will contain a list of animal, list of cages, probably some workers. What else should I add and how could we improve the design? Thanks.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Different behaviors of animals like walkable, flyable can be interface which can allow you define/implement behaviors for different animals."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \nusing namespace std; \n \nclass CareTaker \n{ \n    private: \n    public: \n       virtual void PrintDetails() = 0; \n}; \n \nclass IndividualCareTaker : public CareTaker \n{ \n    string sCareTakerName_; \n    int iAge_; \n    public: \n        void PrintDetails(); \n}; \n \nclass GroupCareTaker \n{ \n    list lCareTakers_; \n    public: \n        void PrintDetails() \n        { \n        } \n}; \n \nenum ECageType \n{ \n    CAGE_METAL, \n    CAGE_WOOD \n}; \n \nclass Cage \n{ \n    private: \n        ECageType eType_; \n}; \n \nclass FlyingType \n{ \n    public: \n        virtual void Fly() = 0; \n}; \n \nclass CanFly : public FlyingType \n{ \n    public: \n        void Fly() \n        { \n            cout << \"Can Fly\" << endl; \n        } \n}; \n \nclass CannotFly : public FlyingType \n{ \n    public: \n        void Fly() \n        { \n            cout << \"Can not Fly\" << endl; \n        } \n}; \n \nclass Animal \n{ \n    private: \n        Cage* pCageForAnimal_; \n        CareTaker* pAnimalCareTaker_; \n        string sAnimalName_; \n    public: \n        const Cage* GetItsCage(); \n        const CareTaker* GetItsCareTaker(); \n        const string& GetItsName(); \n        virtual void PrintItsDetails() = 0; \n}; \n \nclass Birds : public Animal \n{ \n    private: \n        FlyingType* pItsFlyingType; \n    public: \n        bool SetFlyingType(FlyingType* flyingType); \n        void PrintItsDetails(); \n \n}; \n \nclass Mammals : public Animal \n{ \n    private: \n        int iNumberOfLegs_; \n        bool bDangerous_; \n    public: \n        void PrintItsDetails(); \n}; \n \nclass Zoo \n{ \n    private: \n        list lAnimalList_; \n    public: \n        void DisplayAllAnimals(); \n        void GetCountOfAnimals(); \n};"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Strategy design pattern"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6109164921159680","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"30","title":"There is a large file( 1TB) containinig braces. Question is to check for their balance. I said will use a counter, will increment on an open brace and decrement on an close brace. If counter goes negative or counter is non zero at the end of the file, braces are not balanced. Otherwise balanced. Followup question was to make this process parallel ( meaning to see if this problem can be solved through parallelism, like dividing the  the problem into sub problem....)  Remember the file is very large.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"If \"( = 1\" and \") = -1\". We should check the same two conditions: 1. The total sum of the brackets is 0 2. We never go negative at any point of time.  This can easily be done with one chunk, if we will do it on multiple chunks, then there is two numbers that we need to report per chunk: 1. Sum of all brackets. 2. Lowest negative number that was found during processing this chunk.  The last step is to \"merge\" the results. We need to sequentially add the total sum of the brackets, and we also need to check that at any chunk, the previousChunksSum + CurrentLowestNegativeNumber is always above zero."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"The OP's approach for the initial problem was correct. Namely, something like"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This required a stack data structure to validate the structure. Because with count we will not be able to differentiate between - \"{123*}23 }{\" & \"{123*{23 }}\".  First string is in invalid. Algorithm:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@Ajeet..  Infact, the problem is very clear that it is a very large file, so stacks and linkedlists will runout of space. Can you explain more how to use bitvector?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the braces are balanced, (going by the counter method by @ajeet) you will end up with sum 0.  Hence even you may divide the file into chunks, with help of some marker method or use a file system which gives you chunks of file and then put each chunk for counting the braces. Each parallel process will end up in a number. These numbers again should add up to 0."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can do this with stacks and in parallel as well. Using the bit-vector still won't solve it as the file size is huge. 1TB / 8 = 128GB, so even with bit-vector you would need RAM to be bigger than 128GB.  So, I am using the map-reduce model here:  The huge file will be split into small parts (Hadoop does this for us) that can easily fit into the main memory.  Mapper pseudo-code: Input: (k1, v1) where k1 is byte-offset in the file, v1 is the text Output: (k2,v2) where k2 is the byte-offset in the file, v2 is a stack which has braces in it"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"OK, something messing up my replies. I will not paste code for this now :)  Formatting issue with earlier reply. Some mistakes in this solution: - be more careful with push and pops in the stacks  - need to invert every stack after the first one in reducer, to do the merge correctly  - if the first stack (ordering by byte-offset in file) itself starts with a closing parenthesis, then there is simply no chance of file being valid. Mappers need to maintain a static volatile boolean fag to mark this occurrence (to avoid unnecessary computation)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Break the 1TB file into number of cores system has, eg if system has 4 cores than 250 GB each file block size  Now make a thread which will process each file block  Within the thread  Use ArrayList     while file encounters character either '{'  or '}'      if last index value is '{' and current value is '}; then remove both of them from list      else add the value to list;   return list;  Once these threads have runned on the different files they will produce Arraylists equal to number of cores say eg 4  Then check the ArrayLists  if all arraylists are empty : then print balanced  else  for i=0 to arraylist.size     check for pairs of bracket: if found remove the index from list  if arraylist is empty now then : print balanced  else print unbalanced;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) break the 1TB data into n number of chunks. 2) for each chunk call a function say CHECKCOUNT to check difference between opening and closing braces.  NOTE : always start comparing after first opening braces. 3) return value of this number is   0 if number of opening braces equal to number of closing braces.  (-ve value) if number of closing braces are greater then opening braces.  (+ve value) if number of opening braces are greater then closing braces. 4) store the return values into some arrays. 5) now you have a array with zero's, +ve and -ve number 6) user devide and conquere technique to add adjacent numbers 7) in the end if you have zero means success otherwise failure"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6345092675665920","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"7","title":"There is a king, who has got 1000 bottles of Rum with him, of which One bottle contains poison. And he has any number of slaves. He has got 1 hour to decide which bottle contains Poison, and any slave who even takes a sip of the poison, dies within an hour. How many least number of slaves does the king need to use, to make out which bottle contains poison.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Hi,   The answer is 2.   to find out the the bottles has to be arranged in 25 X 40 grid.  and totally 65 slaves has to be used.  Slaves has to sip rum from a column or a row.  so if a slave sip the rum from row i will die similarly column j will die.  so the ith row jth column contains poisoned bottle"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"The answer is still 10.  (2 power 10 = 1024)  List numbers until 1000 in binary format vertically.  Each 1 represents a slave and with the combination of slaves you can find the poisoned rum. 8 =  2 power 3. So three slaves"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"There might be many ways to solving this problem but main idea is to identify poisonous bottle with minimum slaves and time. My solution will take 10 prisoner and 1hour time.  Name 10 prisoners as P0 to P10 Name 1000 bottles in binary Ex bottle 1 as 0001, bottle as 0101....bottle 10 as 1010 etc  Ask prisoner P0 to drink from Bottle 1 (00000000001) Ask prisoner P1 to drink from Bottle 1 and 2 (00000000001,00000000010) . . . Ask prisoner P10 to drink from  Bottle 1...Bottle1000  Finally after 1 hour see which prisoner has died suppose if prisoner 1,4 has died the poisoned bottle is 5.  This solution will even hold good for 1024 prisoners."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"10 slaves. Name slaves from 0 to 9. Give the each bottle a number from 1 to 1000 and represent the number in binary format. If the ith digit of the binary number is 1, let ith slave to drive this bottle. After an hour, if the ith slave die, the ith digit of poisoned bottle is 1, otherwise 0.  For example, assume bottle number 3 contains poison,  3 = 0000000011  Then slave 0 and slave 1 need to drive this bottle. After an hour, they die..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Divide the 1000 bottles into 2 halves and accumulate drops of each half two form two glasses of wine. Have a slave drink each glass. Check which one of them dies. Take the corresponding half and repeat the process.   No of slaves = log2(1000) ~ log2(1024) =10"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi Anon123, your approach might be correct, but don't think the answer is.  As per your solution, would need to wait for the slave to die in each of 10 iterations which might be more than 1 hr."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"suppose"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5657066563698688","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"11","title":"You need to write this program again, without using any library methods. Take the following inputs from user and print the following output.  1  1 1  11 0  011 1  0111 0  00111 0  000111 0  0000111  i.e if user types 1 then 1 will be at printed right shift, and 0 will be printed left shift.  Note: There is no definite count of number of Inputs user wants to give, or sequence of inputs user wants to give. User can give any number of inputs, and it should display the result as above.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Just keep a count of the number of zeros and the number of ones, since they can't be intermingled. No data structure even required."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public void addElements(int k) { \n  DoubleSidedLnkedList node = new DoubleSidedLnkedList(k); \n  if (head == null) { \n   head = node; \n   temp = node; \n  } else if (k == 0) { \n   while (temp.previous != null) { \n    temp=temp.previous; \n   } \n   node.next = temp; \n   temp.previous=node; \n  } \n  else{ \n   while (temp.next != null) { \n    temp=temp.next; \n   } \n   node.previous = temp; \n   temp.next=node; \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can try and solve this using linked list implementation. If input is one you add it at the end of the linked list, if the input is zero you add it at the start. Each time user inputs something, just print the whole linked list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public Node buildList(int input, Node head) { \n Node temp = new Node(); \n Node tempHead = head; \n if (input == null || head == null) \n  return null; \n   \n if (head.value == null){ // first element \n  head.value = input; \n  return head; // all done! \n } \n if (input == 1) // add to the end of the list \n  while(tempHead.next != null) // iterate to the end of the list \n   tempHead = tempHead.next; \n  temp.value = input; \n  tempHead.next = temp \n else if (input == 0){ // add to beginning \n  temp.value = input; \n  temp.next = head; \n  tempHead = temp; // assign this as the new head \n } \n \n return tempHead;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{ { {#include #include int a[50],b[50],count=0; void zero(int ,int ); void display(); void zero(int p,int q) {  int i;  for(i=q;i>=0;i--)  {   b[i+1]=b[i];  }  b[0]=p; } void display(int i) {  int j;  for(j=0;j<=i;j++)   printf(\"%d\",b[j]); } void main() {  int i,j;  clrscr();  i=0;  while(i<50)  {      scanf(\"%d\",&a[i]);       if(a[i]==0)       { zero(a[i],i);         count++;       }      else if(a[i]==1)       { b[count]=a[i];   count++;       }       else   break;       printf(\"\\t\");      display(i);      printf(\"\\n\");      i++;   }  getch();  exit (1); } } } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \nusing namespace std; \n \nint main() { \n    int c1=0, c0=0; \n    char in; \n    while(1){ \n        cin>>in; \n        if(in=='1') c1++; \n        else if(in=='0') c0++; \n        else break; \n        for(int i=c0; i>0; i--) \n            cout<<0; \n        for(int i=c1; i>0; i--) \n            cout<<1; \n        cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"did without datastructure"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static String s =\"\";    public static void main(String args[])  {   Scanner in = new Scanner(System.in);   while (in.hasNext())    {   String str = in.nextLine();   if(str.equals(\"1\") || str.equals(\"0\"))   {   String s1 = testmethod(str);    System.out.println(\"s= \"+s1);   }   else    return; // break; can also be used here.      }  }    public static String testmethod(String args)  {      if(args.equals(\"0\"))   {    s = args+s;       }   else if(args.equals(\"1\"))   {    s = s+args;   }      return s;  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5920511267700736","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"6","title":"You have got 2 strings(S1, S2) and 1 character(c1). All inputs to be taken from user. You need to check for the character c1 in String S1, and wherever you find the character, you need to replace it with the string S2. Next Write all possible test cases to test the program. It can be possible that the character c1 is appearing more than once in the String s1. Clause - You are not allowed to use any Java Library methods in it. Not even charAt() method.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void replaceCharacter(String s1, String s2, char c) { \n \nStringBuilder builder = new StringBuilder( \"\", s1.length); \n \nforeach(char toCheck in s1) { \n if( (int) c == (int) toCheck) { \n  builder.append(s2) \n } else { \n  builder.append(toCheck); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If you cannot even use .length then I would do it inside a while loop and not a for loop. To improve the big O notation you can use recursing while dividing the array I guess. Not too sure about that."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"couldn't find any other way of reading char from console.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void find_and_replace(char **S1, const char ch, const char* S2) \n{ \n char* str1 = strdup(*S1); \n int m=0; \n while(str1[m] != '\\0') \n { \n  if(str1[m] != ch) \n  { \n   m++; \n  } \n  else \n  { \n   str1 = realloc(str1, strlen(str1) + strlen(S2)); \n   memcpy(str1 + m + strlen(S2), str1 + m + 1, strlen(str1 + m + 1)); \n   strncpy(str1 + m, S2, strlen(S2)); \n   m += strlen(S2); \n  } \n } \n *S1 = str1; \n} \n \nint main() \n{ \n char* S1 = \"this is a test\"; \n char* S2 = \"blah\"; \n char ch = 't'; \n printf(\"%s\\n\", S1); \n find_and_replace(&S1, ch, S2); \n printf(\"%s\\n\", S1); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Represent the Strings as char[], scan the first string once, to count the number of times that char c is present, now calculate the length of the final string, and fill it from backwards O(2n) = O(n)  Example: abcdcdef and xyz are 2 strings, represent them as a char[],  given char c, now scan first string, we find c twice, so the final string length is 8 - 1 + 3 - 1 + 3 = 12, create a new char[] and fill it from backwards with the first string, but when u hit c, fill it with the second string xyz instead of the c."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6255485162356736","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"There is a website, which is working fine in US, but not working in India. Debug the scenario.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Is there any Network problem (i.e. if the website requires more network bandwidth to load and that is not present in india) 2. If the site is blocked by Internet service provider  3. If the site blocked by the browser as the site may contain some restricted images  4. If the website is developed for only one version of browser and in india the browser version is different"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{1. Is there any Network problem (i.e. if the website requires more network bandwidth to load and that is not present in india)} {2. If the site is blocked by Internet service provider } {3. If the site blocked by the browser as the site may contain some restricted images } {4. If the website is developed for only one version of browser and in india the browser version is different}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.Check Internet Connection 2.Check whether site is blocked in India 3.Check Whether user entered com or in 4.Check whether user is blocked this site in Browser settings 5.Check whether user is blocked this site in anti virus settings 6.Check whether amazon server is down which is maintaining India 7.Check whether that user is blocked  like fraud user 8.Check spelling mistake in URL"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"also check timezone loading issues"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4656932862296064","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"You have a Movie file, which is not getting played in VLC player. Debug the scenario.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use Cyberlink PowerDVD"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. VlC not installed properly 2. Video file can be corrupt 3. Play file in n and n-1 version of vlc 4. File is not downloaded properly 5. Reinstall VLC if not installed properly 6. There is no video card installed in system."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Video file is corrupt VLC Player is corrupt Sound card is damaged Video card is damaged size of the video file is too big  resolution of video is not supported file format is not supported by VLC buffer space in vlc is exhausted problem in laptop screen"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Check the format of file, for example if its .mp4, does our version of VLC support .mp4? 2) Check if codecs are updated properly. 3) Check if VLC having issues running other movies in diff format( say .avi) 4) Is VLC generating ant crash log while playing that movie file, if yes what they suggest. 5) Is there some problem while image rendering which might due to the failure if graphics driver. 6) Check if VLC has relased any bug update for such issues, if yes, then update it and then check"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5617192120877056","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"11","title":"5! = 5 * 4 * 3 * 2 * 1 = 120 (it contains 1 zero).    How many zeroes will be contained in 100! then. Explain with logic.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"public int countTrailingZerosOfFactorial(int n) { \n    int count = 0; \n    for (int powerOfFive = 5; n / powerOfFive > 0; powerOfFive *= 5) { \n        count += n / powerOfFive; \n    } \n    return count; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"24. Factorize multiples of 5 5 = 5x1 10 = 5x2 15 = 5x3 20 = 5x2x2 ... 25 = 5x5 (one extra 5) .. 50 = 5x5x2 (one extra 5) ... 75 = 5x5x3 (one extra 5) .. 100 = 5x5x4 (one extra 5)  All of the 20 multiples of 5 up to 100 have one 5 each. The multiples 25,50,75 & 100 have one extra 5 each. Hence the total number of 5s = 24. Each of these twenty four 5s when multiplied by 2(which are at least 50 in number) yields a zero and hence the total number of 0s = 24."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The easiest way is to check the maximum power of 5 which can be there in factorial.  10=5x2 If we  are calculating the factorial then n!=n x n-1 .... 1= A x 5^p x 2^q, hence it will depend on the value of p which will define the number of zeros.  Steps to find the max number of 5 is  If the number is say Z then max power of 5  p= z/(5) +z/(25) + z/(125)...z/(5^n) till z/(5^n) results a integer number."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int Zeros(int n) { int k=0,nb=0; while(pow(5,k+1)<=n) { k=k+1; nb=nb+n/pow(5,k); } return nb; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"f(n) = n/5 + f(n/5); base case: f(n)=0 iff n<5"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class CalculateNumberOfZeros { \n \n public static void main(String[] args) { \n   \n  findMaxPowerof5(100); \n } \n \n public static void findMaxPowerof5(int num) { \n  LinkedList link = new LinkedList(); \n  int totPower = 0; \n  for (int i = 1; i <= num; i++) { \n   if (Math.pow(5, i) <= num) { \n    totPower += num / Math.pow(5, i); \n   } \n  } \n \n  System.out.println(\"Number of zero=\" + totPower); \n \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"def f(n): \n if n==1: \n  return 0 \n if n%10==0: \n  c=0 \n  a=n \n  while a%10==0: \n   a=a/10 \n   c=c+1 \n  return c+f(n-1) \n if n%5==0: \n  c=0 \n  a=n \n  while a%5==0: \n   a=a/5 \n   c=c+1 \n  return c+f(n-1) \n return f(n-1)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4794611360858112","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"How will you test Photo upload feature in facebook, to a Newly created album, to an already existing album, as a standalone photo. Write all negative test cases as well.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Format is incorrect 2. Size of the file is very large 3. Internet connection is very slow. 4. If upload is taking time then check the speed"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4849794342191104","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"A company has developed a browser. The browser has a Private browsing mode, like Incognito mode in Chrome browser. How will you test that browser on a mobile. Write all possible test cases for it.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Launch the incognite mode. 2. Browser through different website and close browser . Check for history , cookies . The data should have been deleted. 3. Browser a site and download , Bookmark some page. Exit browser. Bookmark and Downloaded file should be saved . 4. Check for compatibility in different OS and mobile sizes - > Compatibility test. 5. UI Test - > The browser should be scaled up. 6. Use private browsing and regular browsing in different tabs and check for results. 7. Switch between private and Regular browsing mode and observe behavior. 8. Stress test - > Open and close browser for 500 times.It should not crash."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4785236420329472","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"6","title":"One can serialize a BST by storing its in-order plus one of pre-order or post-order notations. what makes in-order mandatory?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"As alex said a BST can be reconstructed from the preorder traversal alone.  It appears the question should actually have been for a binary tree. For binary trees none of three traversals inorder, preorder or postorder alone can uniquely identify the tree. For a binary tree inorder traversal and either a postorder or preorder traversal can uniquely identify the tree.  Importance/Requirement of Inorder traversal: The inorder sequence will resolve the left-right problem, and the other sequence (pre or post) will tell us the roots of the various subtrees. For example, if inorder is CBA, and preorder is CAB, then we know that C is at the root, and both B and A are in the right subtree"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Suppose if u persist preorder only postorder than how would u identify that which element will come to the left or which element will come to the right. 2. this will lead us to the different BST from the one which we persisted. 3.So by using only one traversal we will get differnet BSTs with same elements."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Nothing makes it mandatory. BST is restorable from preorder in O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"dcsdcsdcscsdcsdcsdcdsc"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5261402801438720","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"3","title":"Given a tree, generate all paths. Note : all paths..not just the ones starting from root","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n) Solution will be to use recursion in each node to append the path generated from it via right subtree and via left subtree in a list"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Generate all paths"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5859868208529408","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"14","title":"Implement a function which returns list of all nodes in a binary tree having a given number of leaves, say k . Also mention complexity.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"it can be done with a modified post-order traverse. To simplify things, i'll put it in recursive style:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Complexity O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"We have to use Bottom up approach 1. Traverse the tree in postorder manner. 2.While traversing keep count of the leaf nodes 3. add nodes who have k leaves to list 4. At the end LIst will contain the ans"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Have a recursive method called getNoOfLeaves(). The base case of recursion returns 1 for leaf nodes. During the bubbling up(unwinding) of the recursive calls, sum up the number of leaves from both it's children and check if it equals to the given k. If yes, add the node to a list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Complexity O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int CountLeafeNodes(Node* root) \n { \n  if(root==NULL)return 0; \n  if(root->left==NULL&&root->right==NULL)return 1; \n  return CountLeafeNodes(root->left)+CountLeafeNodes(root->right); \n }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4890375709786112","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"10","title":"Given a set of intervals, how to find the interval with maximum number of overlaps (not the length of the overlap).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"You have already asked the same question id=5131269318901760, haven't you?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Assuming the intervals begin and end at integral values, sort the intervals using their begin values. Using an auxiliary array aux[n], where n is the maximum end value of all the intervals"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Let S = {[a1,b1],[a2,b2],...,[an,bn]} be the set of intervals.   1. Create the following array: array = {(a1,start),(b1,end),(a2,start),(b2,end),...,(an,start),(bn,end)} (the first coordinate is a number and the second coordinate is a label). 2. Sort the array according to lexicographic order where start3. Initialize count=0 (count will mark the current number of overlapping intervals). 4. Initialize maxCount=0 (maxCount will mark the maximum number of overlapping intervals). 5. Define maxStart (maxStatr will mark the start of the interval with maximum overlapping intervals). 6. Initialize maxInterval = null (maxInterval will mark the interval with maximum overlapping intervals). 7. Iterate over the sorted array (beginning to end):  7.1. Increment count whenever you encounter a value whose label is start (x,start). 7.2. Decrement count whenever you encounter a value whose label is end (x,end). 7.3. If count>=maxCount then set maxStart to the current number value of the array element (the x in (x,label)) and set maxCount=count. 7.4. If the current array element is labeled end and after updating count it equals to maxCount-1 it means that the current array point marks the end of the maximum overlapping interval. So we set maxInterval to the interval (maxStart,current_array_element.x). 8. return maxInterval.  Complexity: O(nlogn) worst-case run-time complexity where n is the number of intervals. Space complexity is O(n) for the additional array.  Java Implementation: snipt.org/Bfjaf0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I understand one common approach is to create an array = {(a1,start),(b1,end),(a2,start),(b2,end),...,(an,start),(bn,end)} (the first coordinate is a number and the second coordinate is a label). Sort the array according to lexicographic order where start  What I don't understand when we create the array, we are essentially separating the start time and end time from each interval. So each start time and end time will lose their identify of which interval they belongs to. When we walk through the array, it would not make sense if we just increment/decrement the count without knowing each coordinate corresponds to which interval. If we use a hashmap and map each coordinate to their interval, there might be issues with duplicate start times and end times.  How should we solve this issue?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class MaximumOverlap { \n \n    public static void main(String[] args) { \n \n        int[] start = {1, 2, 3, 6}; \n        int[] finish = {6, 7, 5, 8}; \n \n        QuickSort quick = new QuickSort(); \n \n        quick.quickSort(finish, 0, finish.length - 1); \n        quick.quickSort(start, 0, start.length - 1); \n \n        int s = 0, f = 0; \n        int[] count = new int[finish[finish.length - 1] + 1]; \n        int max = 0; \n         int index = 0; \n        for (int i = start[0]; i <= finish[finish.length - 1]; i++) { \n \n \n            count[i] = count[i - 1]; \n            if (s < start.length && i == start[s]) { \n                count[i]++; \n                s++; \n            } \n            if (f < finish.length && i == finish[f]) { \n                count[i]--; \n                f++; \n            } \n \n            if (max < count[i]) { \n                max = count[i]; \n                index=i; \n            } \n        } \n \n        int k; \n        for(k=index;k"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why dont we create a node for each interval point. and mark node visited each time you pass by."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5919901415899136","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"15","title":"Replace each node with the sum of all greater nodes in a given BST?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"1. apply reverse inorder 2. keep track of sum of nodes while traversing 3. change the value of roots while traversing"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"How about:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Each node will receive some values from left subtree and from right subtree.  2) That node will change its value with : selfvalue + sum of value received from right subtree 3) That node will return new pair of values to its parent: < sum of left subtree value, node's new value > I can explain algo with an example:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Reverse Inorder traversal which lists the nodes in descending followed by sum at each node works perfectly well"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi Guys, what does 'greater nodes' really means?  Nodes which values are great than what it is originally?  If so, in a sorted tree situation, only the right sub tree?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what do you mean by greater nodes ? Please give detail example of it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class ReplaceBST { \n \n    private static List list = new LinkedList(); \n    private static List  nodeList = new LinkedList(); \n \n    public static void replace(Node root) { \n        if(root == null) return; \n \n        replace(root.left); \n        list.add(root.value); \n        nodeList.add(root); \n        replace(root.right); \n    } \n \n    public static void inOrderTreeWalk(Node root) { \n        if(root == null) return; \n \n        inOrderTreeWalk(root.left); \n        System.out.println(root.value); \n        inOrderTreeWalk(root.right); \n    } \n \n    public static void main(String[] args) { \n        Node node1 = new Node(1); \n        Node node2 = new Node(2); \n        Node node3 = new Node(3); \n        Node node4 = new Node(4); \n        Node node5 = new Node(5); \n        Node node6 = new Node(6); \n        Node node7 = new Node(7); \n \n        node4.left = node2; \n        node2.left = node1; \n        node1.right = node3; \n        node4.right = node6; \n        node6.left = node5; \n        node6.right = node7; \n \n        replace(node4); \n        int cumul = 0; \n \n        for(int i = list.size() - 1;i >= 0;i--) { \n            nodeList.get(i).value = cumul; \n            cumul += list.get(i); \n        } \n \n        inOrderTreeWalk(node4); \n \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"in C"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"replace_with_greater_node(self, sum): \n if self == None: \n  return \n replace_with_greater_node(self.right, sum) \n temp = self.value \n sum = sum + temp \n self.value = sum \n  \n replace_with_greater_node(self.left,sum)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4787357697966080","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"11","title":"How will you Serialize and Deserialize the binary tree?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"***serialization***  1. traverse tree using level order traversal 2. If a node dont have left or right child while serializing in its place serialize $(or any other sentinel value)  ***deserialization*** 1.read values from file (It is in level order) 2. if value is not sentinel thn it is a node add it to tree  3. make it child of its parent if current loop count is odd it is left child else it is right child 4. if it is a sentinel value set null in the left or right(whichever it is) pointer of parent  complexity o(n) for both operations"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Serialize node recursively as  NODE LEFT RIGHT  use ^ if node doesn't have a right child A binary tree"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what kind of binary tree, just simple BT or BST?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution 1. Store each value with its parent (0 parent if it is the root) also specifying if it is left or right child Solution 2. Store the inorder and preorder traversal (or inorder and postorder).  From these it is easy to get the original tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do level by level traversal of the tree and serialize nodes. For Eg:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think serialization should be done for two traversal for same BST 1. Preorder/Postorder and Inorder 2. While de-serializing create the tree by using both traversal. This will make sure that order of tree doesn't change"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have thise as an answer to your question. Only problem in this solution is I am failing to guess where EOF file is encountering. {{    public void serializeBinaryTree(BTNode root, ObjectOutputStream oos) throws IOException{       //if nde is null then put some #       String s = \"#\";       if(root==null){        oos.writeObject(\"#\");       }else{        oos.writeObject(\" \"+root.data);        serializeBinaryTree(root.left,oos);        serializeBinaryTree(root.right,oos);       }      }            public void dserializeBinaryTree() throws IOException, ClassNotFoundException{       //if nde is null then put some #       String node = null;        FileInputStream fin = new FileInputStream(\"Tree.ser\");      ObjectInputStream ois = new ObjectInputStream(fin);      Scanner input = new Scanner(\"Tree.ser\");      while(true){       System.out.println((String) ois.readObject());      }          } }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Serialization of binary tree:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5759618034696192","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"20","title":"Given an integer array find all pythogorean triplets. a^2 + b^2 = c^2 print the a,b,c and their indexes","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"a little changed 3sum question.   1. get the square of the array.  2. iterate from the last element of the array, let us say i, make it as the target sum. and use 2 pointer, one is from 0 and the other one is from i-1. if the current sum > target, right pointer --; else left pointer ++ ;   run time O(n^2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Square up each of the elements of the array and put them in a hash table. This requires O(n) extra space.  Then for all of the n^2 combinations of elements, check if their sum of their squares exists  in the hash table with O(n^2) time complexity.  A complete graph of the elements with nodes holding the squares of elements may also get the job done. Running DFS from each node and traversing a depth of up to 3 levels, can help check for the existence of Pythagorean squares."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming the numbers are whole numbers, not fractional  1. Get the maximum and minimum number of given array and store square numbers into hashing DS.  2. Store squares from minimum to that maximum number in a hashing DS (if it's not suitable then use BST for fast searching). Tag immediate lowest square with each element. Ex: Maximum number is 10 and minimum is 2. Store 2 ^2 to 10^2. For 16 tag 9.  3. Iterate the hash table, suppose 16 found go to previous hash table/tree and find possible triplet. So for 16, tagged number is 9 now remaining is 7 and 7 does not exist. Result is cancel. Suppose 25 found, tagged number is 16 then find 9, both found. Now find 16 and 9 in original list.  The complexity depends on the range given. For large range space should be high."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Note when sorting the original list, you may lose the index information, so probably we should generate a index map that map the index from sorted array to the origina array's index. This algorithm may be O(n^2)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I did answered along the same line that most of you have answered. However, interviewer gave following remark to my answer.  1. If input array has negative numbers? in which case, squaring it could result in printing invalid Pythagorean triplets. 2. If we have sort, then we will loose the index numbers which we have retrieve to print the Triplets. 3. Interviewer seems to be in agreement with time complexity. i.e O(n^2)*log(n).      [O(n^2) to pick two numbers] * [O(log n) for binary search]. But for binary search, i would have to sort and it is erroneous. Here i was caught!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Nothing but a 3-sum question. Easy.  O(n^2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can we avoid sorting and just use hashtable if space is not a constraint, it takes O(1) time to lookup the element."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{ \n \npublic class FindPythagoreanTripltes { \n \n public static void main(String[] args) { \n  findPythagoreanTriplets(); \n } \n  \n  \n  \n public static void findPythagoreanTriplets() \n { \n   \n  int arr[]= { 3,6,9,4,8,5,10,12,15 }; \n   \n  for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"/** \n* Step1: Square each of the elements in the array [O(n)] \n* Step2: Sort the array [O(n logn)] \n* Step3: Find all the pairs whose sum is equal to the an element in the array [O(n logn)] \n* \n* Time Complexity: O(n2) \n*/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"It can be done in O(n) because the numbers are integers. Pythagorean integers are 3,4,5. and all of the multiplications od them like 6,8,10, .... Put all the elments in a hash map. After that iterate through the elements and look for the corresponding other 2 missing. This way we would obtain duplicates but these can easily be avoided if we look only for multiplications of 3, instead of 3,4,5."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4847461101207552","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"9","title":"Write a Program for Dictionary which has functionality of lookup and insert . This program should be able to add words on the fly   I wrote simple code using HashTable   follow up   1) Now we are getting too many words what happens  me: Hashtable will dynamically resize resulting into performance hit . Also they might get hashed to same location as well as we might run out of main memory   2) Okay you are out of main memory , How will you scale this program  me: I will create buckets of HashTable lets say 26 buckets for one for each alphabet and would put them on different machines   3) Lets say you are out of memory on those machines too  me: Okay I need to put them on secondary storage . Here we can have fileSystem or Database . I chose database . I will create simple DB schema of BucketNumber and word .   I will use buckets on main memory as cache , if we are not able to find a word in the bucket then query databse with bucket number and words then remove the least number times looked up word (every time we lookup a word we increament the count i.e value in key,value pair on hashtable) from that bucket and add this word .   I mentioned that bottleneck in this case will be every time a word is not present we need to query DB which usually has high latency which will result into performance hit   4) Lets say we are okay with latency but what if we are getting inserting words between that are only between only in two buckets ex. words starting from a and b only.  Now that I think about it, is it better to do this in a trie? What do you guys think?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Trie is better from HashTable with respect to space complexity. If you have to words with common prefix e.g abc abcde you still have to create to separate keys in HT whereas in trie the words share common prefix part. But if access time is the most important factor the HT is better. So I think you should have explained both approaches and compare their pros and cons."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think he questioned about memory since you are storing everything in the hash table. Here is the implementation with using B-tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"You could use MD5 function to generate string for each input and use the resulting string as key in your HashMap, for example:  - md5(\"abc\") = \"900150983cd24fb0d6963f7d28e17f72\" - md5(\"abcd\") = \"e2fc714c4727ee9395f324cd2e7f331f\"  you would have less probability of key clashes on this case."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5757534975557632","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"42","title":"Determine whether an interger is a multiple of 5 in O(logn) time complexity. You cannot use / and %.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"public boolean isMultiplesOfFive(int a) { \n int mask = 5; \n while ((mask << 1) < a) { \n  mask <<= 1; \n } \n \n while (mask >= 5) { \n  if (a >= mask) { \n   a -= mask; \n  } \n  mask >>= 1; \n } \n return a == 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Here is simple code in java. Steps are as following 1. Divisibility can be checked by checking whether last digit is 0 or 5. 2. Since complexity should be o(logn) . 3. If number is odd we can add 5 in it. 5. After that we have to check whether last digit is 0 or not. 6. Now u we can multiply it with 0.1 and after that we can cast it again in int. 7.Then multiply with ten. 8.After all these processes we should get the old number back; 9.If we dont get it number is not divisible."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Another weird solution could be:  Convert the number into string and check if the last character in the string is either a 5 or 0. If yes, then the number is multiple of 5. else not."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A multiple of 5 means the number can be divided by 10 directly or by 10 after +5, so it turns out to be the question: how to determine the given number can be divided by 10, without / or %, you can use bit operation to determine."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how is this one?  bool isMultiplyOf5(int n) {     bool is5 = false;     int i = 0;     int cur = 5;     for (; i < n; i ++) {         if (cur*5 > n) {             n -= cur;                          if (n == 5 || n == 0) {                 is5 = true;                 break;             }             else if (n < 5 && n > 0) {                 break;             }             else if(n > 5)             {                 cur = 5;                 continue;             }         }         else if(cur == n)         {             is5 = true;             break;         }         else         {             cur *= 5;                      }     }          return is5; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"One way to solve in Python could be  def isMultipleOfFive(x):     if int(list(str(x))[-1]) in [0,5]:         return True     else:         return False"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int division(int tempdividend, int tempdivisor) {       int quotient = 1;       if (tempdivisor == tempdividend) {         remainder = 0;         return 1;      } else if (tempdividend < tempdivisor) {         remainder = tempdividend;         return 0;      }         do{          tempdivisor = tempdivisor << 1;         quotient = quotient << 1;       } while (tempdivisor <= tempdividend);         /* Call division recursively */      quotient = quotient + division(tempdividend - tempdivisor, divisor);       return quotient;  }     void main() {        printf (\"\\nEnter the Dividend: \");       scanf(\"%d\", &dividend);       printf(\"\\nEnter the Divisor: \");       scanf(\"%d\", &divisor);           printf(\"\\n%d / %d: quotient = %d\", dividend, divisor, division(dividend, divisor));       printf(\"\\n%d / %d: remainder = %d\", dividend, divisor, remainder);       getch();  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \nint main (int argc, char *argv[]) \n{ \n   int size=0; \n \n   size = strlen(argv[1]); \n \n   if ( argv[1][size-1]  == '0' ||  argv[1][size -1] == '5' ) \n       printf(\"\\nNumber divisible 5\"); \n   else \n       printf(\"\\nNumber Not divisible 5\"); \n \n \n   return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool isDivisibleBy5(int a) \n{ \n if(a&1) \n { \n  if((a+5) & 1) \n   return false; \n  else \n   return true; \n } \n else \n { \n   if((a+5) & 1) \n   return true; \n  else \n   return false; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include void main() { char *s; int k,i=0; printf(\"enter number\"); gets(s); while(*(s+i)!='\\0') { i=i+1; } i=i-1; if(*(s+i)== '5' || *(s+i) =='0') { printf(\"divisible by 5\"); } else { printf(\"undivisible by 5\"); }  getch(); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Having a string as input, the problem becomes only checking wether the last char of the string is equals to 0 or 5.  In python, it would be:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about doing a binary search? Let's assume the input is n. If n is a multiple of  5, then it can be written that n = 5*x.  We set low = 1, high = n, and try to find x using a binary search. Note that since w can't use / operator, we need to use right shift for computing mid = (low + high) >> 1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool divisabelBy5 (unsigned int n) {     if (n < 5)         return false;      n -= 5;      if (n & 0x1)          return false;      n >>= 1;      int d = 0;      while (n) {         if (n & 0x1) d += 2;         if (n & 0x2) d += 4;         if (n & 0x4) d += 8;         if (n & 0x8) d += 6;          if (d >= 20) d -= 20;         else if (d >= 10) d -= 10;                    n >>= 4;     }      return d == 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static boolean mask(int a){   int maskValue = 5;   boolean result = false;   if(a   return result;   while(a>=maskValue){    a -= maskValue;   }   if (a == 0)    result = true;   else    result = false;   return result;    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public boolean test(int n) \n{ \nint temp=n*0.1; \ntemp=temp*10; \nif(n-temp==0 || n-temp==5) \n{ \nreturn true; \n} \nelse \n{ \nreturn false; \n} \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool check(int a){ \n    int mask = 5; \n    if(a < 0) a*=-1;  // if a is -ve \n    if(a < mask) return 0;  // False \n    while((mask << 2) < a){ \n        count++; \n        mask=mask << 2; \n    } \n    if (mask==a) return 1;  // True \n    return check(a-mask); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algo:- 1. if number is greater than 5, check if odd. If odd, subtract 5. 2. if even, divide by 2. until it becomes an odd. 3. check in n=5.  The number will finally reduce to 5.  code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I feel i am missing something crucial here. if the number ends with a 0 or a 5, it is definitely divisible by 5. this is not a good question"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just found another way from geeks for geeks website. A number n can be a mulpile of 5 in two cases. When last digit of n is 5 or 10. If last bit in binary equivalent of n is set (which can be the case when last digit is 5) then we multiply by 2 using n<<=1 to make sure that if the number is multpile of 5 then we have the last digit as 0. Once we do that, our work is to just check if the last digit is 0 or not, which we can do using float and integer comparison trick."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just found another way from geeks for geeks website. A number n can be a mulpile of 5 in two cases. When last digit of n is 5 or 10. If last bit in binary equivalent of n is set (which can be the case when last digit is 5) then we multiply by 2 using n<<=1 to make sure that if the number is multiple of 5 then we have the last digit as 0. Once we do that, our work is to just check if the last digit is 0 or not, which we can do using float and integer comparison trick."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"think about how division is implemented on computer? 5 is 101; 20 is 10100;  if you left shift 101 for 2 bit, you will get 20, so ...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"bool check(int a) {    float b =  ((float)(a << 1 )) * 0.1;    int c =  b;    return  c * 5 = = a; }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4663193985089536","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"10","title":"Find the LCA (least common ancesstor) of k nodes of a given binary tree. Later extend this for n ary tree.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can solve it using stacks. Search each node in the tree and construct stacks which contain paths from root to given node. E.g"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do a breadth first search and collect the number of \"target nodes\" found at each node and below. the moment this count becomes the number of nodes to be searched at any node, store it's pointer and keep returning it all the way up and exit."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"That should have been depth first search."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The stack method is the right one.  1. Construct k sets (array) and populate it with inorder traversal path of each node. 2. For each node in set 1 , see whether it is present in set 2... set n"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using a BFS you can find it. You don't care about the path but length of the path when performing the search."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Its a sample code for k=3 where n1, n2 and n3 are 3 nodes. Can be generalized further by taking n1, n2, n3 in array. Basic idea is when we find a node, parent is updated that node is found. So parent can see if total k nodes are found till now or not."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Find the path for each node, and compare the path."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this: walk the tree N times looking up for target nodes keeping a hash table with visited counter for each node in the order of when a node was first found. Once all nodes are found, traverse the hash table from the back and find the first node that has the counter of N."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* Function to find LCA of n1 and n2. The function assumes that both \n   n1 and n2 are present in BST */ \nstruct node *lca(struct node* root, int n1, int n2) \n{ \n    if (root == NULL) return NULL; \n  \n    // If both n1 and n2 are smaller than root, then LCA lies in left \n    if (root->data > n1 && root->data > n2) \n        return lca(root->left, n1, n2); \n  \n    // If both n1 and n2 are greater than root, then LCA lies in right \n    if (root->data < n1 && root->data < n2) \n        return lca(root->right, n1, n2); \n  \n    return root; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static TreeNode LCA(TreeNode root, TreeNode[] nodes) {   if (root == null) {    return null;   }    for(int i=0;i   if (root == nodes[i]) {     findCount++;     return root;    }   }       TreeNode leftRoot = LCA(root.left, nodes);   TreeNode rightRoot = LCA(root.right, nodes);   if (leftRoot != null && rightRoot != null) {    // if child1 and child2 are on both sides    return root;    }    // either one of child1 or child2 is on one side    // OR child1 or child2 is not in L&R subtrees   return (leftRoot != null) ? leftRoot : rightRoot;  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5652220229976064","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"17","title":"Given a Binary tree and a arbirary node of that tree , find all the nodes at a Distance of K from that Node .Nodes DON??T have parent pointers","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be done by BFS algorithm and you only consider nodes that at distance K from the given node. The given node is the parent of the tree we need to parse. A java code for this problem can be like that"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I can think of 2 solutions for it  1) Run DFS on the tree to find parent of each node. Now this tree becomes a graph. Run BFS/DFS to find all nodes at distance K  2) Use the concept of rotating trees as in red black trees. First take the tree with root at the starting node (arbitrary node) and find all nodes at level K. These are all the nodes at distance K in the sub tree. Then remove all child nodes from the starting node and do multiple rotations so that this node becomes the root. Now find all nodes at level K The union of both of these is the solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I was thinking along similar lines as Arrantinsane. I split the problem into two parts: + From the binary tree root, see if the target node can be found at specified distance/depth. + From the target node, find all nodes at specified distance/depth.  Here is my pseudo code."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This problem can be divided into two parts:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void printAtLevel(Node *treenode, int level) \n{ \n if(treenode==NULL) \n  return; \n if(level==1) \n { \n  printf(\" %d \",treenode->data); \n } \n else if(level > 0) \n { \n  printAtLevel(treenode->right, level-1); \n  printAtLevel(treenode->left, level-1); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int distance; public static ArrayList result;  public void findKth(Node root, Node target){  findKth(root, -1, target); }  private int findKth (Node n, int k, Node target ){  if( n == null ){   return k;   }  if(n == target){   k= distance;  }  if(k == 0){   result.add(n);   return k++;  }  if(k == -1){   int temp 1 = findKth( n.left , k, target);   int temp2 = findKth (n.right , k , target);  }else{   int temp 1 = findKth( n.left , --k, target);   int temp2 = findKth (n.right , --k , target);  }  if((temp1-distance)==distance || (temp2-distance) == distance ){   result.add(n);  }  return temp1== -1? temp2++ : temp1++; }  O(n) complexity, any opinion?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we have to print all nodes which are child of desired nodes and are child of parent nodes."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"void printKDistant(node *root , int k)     \n{ \n   if(root == NULL)  \n      return; \n   if( k == 0 ) \n   { \n      printf( \"%d \", root->data ); \n      return ; \n   } \n   else \n   {       \n      printKDistant( root->left, k-1 ) ; \n      printKDistant( root->right, k-1 ) ; \n   } \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4672122920108032","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"35","title":"Given an array of +ve as well as -ve numbers, find out whether it is possible or not to convert it to 0 by adding/subtracting operations on all the elements.  e.g arr[]={1,2,3} YES (1+2-3)  arr[]={3,6,2} 3+6-2 != 0 3-6-2 !=0 -3-6-2 !=0 -3-6+2 !=0 -3+6-2 !=0 -3+6+2 !=0 3-6+2 !=0 3+6+2 !=0  Hence ans= NO","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"bool IsPossible(int arr[], int n, int sum) \n{ \n if (n == 1) return sum == abs(arr[0]); \n return IsPossible(arr, n-1,  sum + arr[n-1]) || IsPossible(arr, n-1,  sum - arr[n-1]); \n \n} \nint main() \n{ \n    int arr[]={1,2,3}; \n printf(IsPossible(arr, 3, 0) ? \"yes\\n\" : \"no\\n\"); \n \n    int arr2[]={3,6,2}; \n printf(IsPossible(arr2, 3, 0) ? \"yes\\n\" : \"no\\n\"); \n \n    return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"DP problem (partition problem) Recurrence relation: Assume P[i,j] be true if a subset of {a[1], a[2]..., a[j]} sums to i and false otherwise. P[sum/2][N] is what we want to calculate. P[i,j] is true if ether P[i,j-1] is true or P[i - a[j], j-1] is true.  Here is the code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"1. Make all numbers non-negative by multiplying -1 to negative elements O(n) 2. Sort the numbers O(nlogn) 3. Find total sum  4. leftSum = 0, rightSum = TotalSum, foundMidpoint = false; for i = 1 to length of array { leftSum += a[i]; rightSum -= a[i]; if(leftSum == righSum) { foundMidpoint = true; break; } }  if(!foundMidPoint) return false; else return true;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Step 1: - get SUM of all the elements. Step 2: - if(SUM%2==1) printf(\"no\")                else    find subsequence with sum = SUM/2 Step 3: - if such subsequence exist then printf(\"Yes\");   else printf(\"No\");"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Code to generate all 2pwd N combinations. Using bit operations."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Partition problem. NP-Hard."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static boolean find(int array []){ \n  int sum = 0;  \n  for (int i = 0 ;isum){ \n   return false; \n  }else{ \n   for (int i = start ;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Ignoring the signs (if there are negative or positive) find the largest among them.  eg1: {-1,2,-3,5,-3}----------------> largest is 5 eg2: {-7,1,2,4}---------------------->largest is 7  2)find the sum of all remaning  elemets, say is \"x\", then check whether    \"largest - x \" or largest + x\" equals to zero. eg1:x =  -5---- the chk comes to zero eg2: x = 7-----the chk comes to zero.  I think this will work and we dont have to chk for all combination."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class SumZeroPossible {  public static void main(String[] args) {   int a[] = { -2, 2,4 };   int sum = a[0];   char sign[] = new char[a.length-1];   boolean ab = isSumZeroPossible(a, 1, sign, sum);   System.out.println(ab);   if(ab){    System.out.print(a[0]);    for (int i = 0; i < sign.length; i++) {     System.out.print(sign[i]);     System.out.print(a[i + 1]);      }    }  }   private static boolean isSumZeroPossible(int[] a, int i, char[] sign,int sum) {   if (sum == 0 && i == a.length)    return true;   else if (i == a.length)    return false;   else {    sign[i - 1] = '-';    if (isSumZeroPossible(a, i + 1, sign, sum - a[i]))     return true;    sign[i - 1] = '+';    if (isSumZeroPossible(a, i + 1, sign, sum + a[i]))     return true;   }   return false;  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static boolean canGetZeroResult(int[] arr) { \n        // Bad input \n        if (arr == null || arr.length == 0) { \n            return false; \n        } \n \n        return canGetZeroResult(arr, 0, 0, 0); \n    } \n \n    private static boolean canGetZeroResult(int[] arr, int i, int addResult, int subtractResult) { \n \n        // Past the end of the array: did we end up at zero? \n        if (i > arr.length - 1) { \n            return addResult == 0 || subtractResult == 0; \n        } \n \n        // Both add to and subtract the current element from the two results you have currently - each call makes two more calls \n        return canGetZeroResult(arr, i + 1, addResult + arr[i], addResult - arr[i]) \n                || canGetZeroResult(arr, i + 1, subtractResult + arr[i], subtractResult - arr[i]); \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is the bit counter solution to generate combinations in Java"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Find the maximum number. 2. If the sum of all numbers is = 0 or twice the maximum. I think this will give you the correct output"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a partition problem. The basic idea is to know if there is s subset of elements that can sum up to k .. where k is the sum of all elements in the array. The trick is to know how to find the elements that can sum up to K but consider that:  For any number on the array, there are two options: 1- Take it 2- Ignore it. For each of these options, you have to try all other possibilities for other number. This lead to 2^n performance.  A Java implementation"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The first recursive version is easier to code.  We can also use DFS (backtrack) to search the entire array.  The complexity is also O(2^n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// Use DFS to judge whether we have get a zero...  public boolean check(int[] a) {  return DFS(a, 0, 0); }  public boolean DFS(int[] a, int i, int sum) {  if ( i == a.length )    return sum==0;  return DFS(a,i+1, sum+a[i]) || DFS(a, i+1, sum-a[i]); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can create a tree in the following way: 1. Root of the tree is element zero 2. Start from i = 0. Add A[i] as left child and -A[i] as right child to each of the existing leaf nodes  Now the problem is finding if there is a path from root to any leaf with sum 0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void test(int[] array) {   // Base case    int number = (int) Math.pow(2, array.length);    for (int i = 0; i < number; i++) {     int j = i;    int index = array.length-1;    int sum = 0;    int[] temp = array;    while (j > 0) {      if ((j & 1) == 1 && index>-1) {      temp[index] *= -1;     }     sum += temp[index];     j >>= 1;     index--;    }     if (sum == 0 && index == -1) {      for (int ptr = 0; ptr < temp.length; ptr++) {      System.out.println(temp[ptr]);     }     return;    }    }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can use DP here to reduce the time complexity from O(2^n)  1. Convert the -ve integers in the array to +ve (i.e. take their absolute values) 2. Find the sum of the array  3. if sum is odd => no solution exists, return  4. else find if a subset of array elements exists that adds up to sum/2 , use DP here to find that subset (subset sum problem)  5. if yes, then the array elements can be added to yield an effective sum of 0  Here's my code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Step 1: convert the array into absulte values (O(n)) Step 2: sort descently (O(nLog n)) Step 3: Loop over values from biggest to lowest applying (O(n)):    - If total sum is bigger than 0, substract the value from it.    - If total sum is zero or smaller, add the value to it.  At the end, if numbers can be combined to sum zero, sum will be zero. Total time: O(n)  Here's the Python code:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5555260974170112","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"7","title":"Write a function to check if two rectangles defined as below, have common area or not. The functions take the top left and bottom right coordinate as input and return 1 if they have common area, otherwise return 0.   // you can write your additional functions here int doesRectOverlap(rect ra, rect rb){ /* For your reference struct rect{ int topx,topy,botx,boty; }; The above has already been declared please do not redclare */","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Do it this way .. Make a rectangle d covering both the rectangles.. the length and width of this new rectangle has to be less than the sum of both the rectangles for any overlap"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int doesRectOverlap(rect ra, rect rb){  \n if ((rb.topy < ra.boty) || (ra.topy < rb.boty) || (rb.topx > ra.botx) || (ra.topx > rb.botx)) \n  return 0; do not overlap \n return 1; // do overlap. \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Anonymous, ZhenyiLuo: Your algorithm is flawed.   You need to check: \"Do the rectangles overlap vertically?\" AND \"Do the rectangles overlap horizontally?\". You can't just do one or the other."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int doesRectOverlap(rect ra, rect rb){   if ( rb.topy > ra.boty || rb.boty < ra.topy || rb.topx > ra.botx || rb.botx < ra.topx)   return 0; do not overlap  return 1; // do overlap. }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int doesrect(struct rect ra,struct rect rb) \n{ \n    struct rect temp; \n    temp.topx = (ra.topx(ra.botx-ra.topx + rb.botx-rb.topx)) || ((temp.topy-temp.boty)>(ra.topy-ra.boty + rb.topy-rb.boty))) \n       return 0; \n    return 1; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6203547599241216","download_status":"DOWNLOAD_DONE","votes":"-2","answersCount":"3","title":"Find a triplet that sum to a given value in an array of integers. I know it can be done in O(n^2) with either using a hashmap(space O(n)) or pre-sorting(space O(1)) the array. Is there any way to do this better than O(n^2)?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This problem is called 3-SUM and there is no currently known way to solve it faster than O(n^2). This is actually an important problem because a number of problems that are not known to admit sub-quadratic time solutions can be reduced to this one in sub-quadratic time, which means we'd have asymptotically faster algorithms for all of them if we could solve this one in less than O(n^2). You would likely win some kind of prize if you managed to give such a solution.  FFT can solve the problem in O(N + R log R) where R is the range of the numbers and N is the number of elements, but since R can be very large in comparison to N, this solution is not general."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int a[] = {3, 1, 4, 2, 9, 10, 33, 42, 2, 0, 6}; \n    int N = sizeof(a) / sizeof(*a); \n \n    sort(a, a + N); \n    int K = 12; \n \n    for (int i = 0; i < N - 3; i++) { \n        for (int j = i + 1; j < N - 2; j++) { \n            int diff = K - a[i] - a[j]; \n            int *t = lower_bound(a + j, a + N, diff); \n \n            if (t != a + N && *t == diff) { \n                cout << \"(\" << a[i] << \", \" << a[j] << \", \" << *t << \")\" << endl; \n            } \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am avoiding additional comparisons while comparing partialSum with K:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6246597667061760","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"12","title":"Given a set of numbers, find those numbers that occur odd number of times. I used the hash table approach where  I insert the count (no. of times occurred as of now) of the current number whose hash I am making. Time complexity: O(n). Space complexity: O(n).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Here is a simple pythonic answer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void TestMethod3(int [] arrayofnumbers) \n        { \n            Dictionary numberAndOccurance = new Dictionary(); \n            foreach (int number in arrayofnumbers) \n            { \n                try \n                { \n                    numberAndOccurance.Add(number, 1); \n                } \n                catch (ArgumentException) \n                { \n                    numberAndOccurance[number] = numberAndOccurance[number] + 1; \n                }                 \n            } \n            foreach (var outNo in numberAndOccurance) \n            { \n                if (outNo.Value % 2 == 1) \n                    Console.WriteLine(outNo.Key);     \n            } \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int main(int argc, char** argv)  \n{ \n    int a[] = {1, 2, 1, 3, 2, 4, 4, 5, 4}; \n    int N = sizeof(a) / sizeof(*a); \n     \n    map count; \n     \n    for (int i = 0; i < N; i++) { \n        if (count.find(a[i])!= count.end()) \n            count[a[i]]++; \n        else  \n            count[a[i]] = 1; \n    } \n     \n    for (map::iterator iter = count.begin(); iter != count.end(); iter++) { \n        if (iter->second % 2) \n            cout << iter->first << \" \"; \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void findOdd(int[] arr)         {             Hashtable ht = new Hashtable();             for (int i = 0; i < arr.Length; i++)             {                 ht[arr[i]] = 0;             }              for (int i = 0; i < arr.Length; i++)             {                 ht[arr[i]] = (int)ht[arr[i]] + 1;             }              IDictionaryEnumerator ide = ht.GetEnumerator();             while (ide.MoveNext())             {                 if (((int)ht[ide.Key]) % 2 == 1)                 {                     Console.Write(ide.Key+\" \");                 }             }         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the number is not very big, I'd like to use bitmap.  Less memory than hashmap and in same speed."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If numbers are not in any specific range, I think the solution would be through Hashtable. But, if the numbers are in range 1 to n where n is the size of array, it could be done in constant space and O(n) time.  Logic:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simplest way is to use hashing and XOR. I'll just use an array, since there are no space restrictions in the question.  Pseudocode:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Use XOR operator. Sequentially XOR all the numbers. And at the end (assuming only one number has odd number of occurrences) the number with odd number of occurrences will remain."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5632873147138048","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"Design a program that would select which elevator in a building would be the most efficient, based on where the elevator is located and headed and where the user is located and headed.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"This question is poorly defined with several vague terms and without stating the objective clearly. I am assuming that selecting the *most efficient* elevator means the user should be able to reach his destination in the least amount of time and the lift movement should also be minimum.   Though the problem has been posed as an optimization problem, there are some serious caveats for it to be one. The problem in reality is inherently probabilistic in nature for the state of the system is ever changing and unpredictable.   An attempt can however be made to find out an optimal choice at a given snapshot of the system when a user wants to navigate. This includes several assumptions like the wait time at each lift is constant and is uniform across all the lifts and independent across the lifts.   If we assume there are k lifts and floor numbers start from 0 and go up to  'max_floor' we can have 3 arrays to manage the state of the system.  updown[1..k]:  holding 0/1 to denote whether the lifts are moving up(=0) or down(=1)  currfloor[1..k]  current floor the lift is on nextfloor[1..k]  floor the lift is headed to. If nextfloor[] were a two dimensional array with all future stops registered, the problem would get tougher..  If the user currently on 'presentFloor', and wishes to go to 'destFloor', based on the user's choice to go up or down, we select a subset of the lifts from updown[] array.   For the selected subset of lifts, compute the values vi = mi/ni, where mi = f(presentFloor, destFloor, nextFloor[i], i) and ni=g(presentFloor, currentFloor[i], i)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"LiftName(Current floor, Destination floor) Destination floor = -1  if lift is still A(4,0) B(2,4) C(0,-1) D(1,0) E(2,-1)  Passenger P(1,4)  DistA = Dist(4,0,1,4) DistB = Dist(4,0,1,4) DistC = Dist(4,0,1,4) DistD = Dist(4,0,1,4) DistE = Dist(4,0,1,4)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5118048302268416","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"10","title":"Print all the elements in an array that have occurred an odd number of times. I know we can XOR all numbers, but that only solves the problem where there is only one odd number in the array. But I was asked to find all of them. Another method I can think of is to keep one hashset, then walk through the array, if the number is in the map, remove it. If the number is not present, add it. But this requires O(n) space. Is there any way to do this with O(n) time and O(1) space?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"I believe in case when there are several odd numbers you can solve it in two ways: 1) The one which you have already mentioned using HashSet-Time O(n), Space O(n) 2) Sort the array and then iterate keeping the running counter of the current number. When you reach a new  number check if the counter is odd and print number if it is. Time O(nlogn), Space O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Only 1 bit is required to store whether the number has occurred odd number of times. So if all the numbers in the list are positive, then we have 1 bit in each array index. When iterating through the array, read the value 'x' after ignore the most significant bit (since it indicates odd or not), index into the array at position 'x' and toggle the most significant bit. Then go through the array again and if the most significant bit is set, then the corresponding index has occurred odd number of times."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Another way, without extra memory - sort, and then simply iterate through array. O(n logn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can use count sort algorithm here."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//the solution given works only when the range of numbers in the array is not more than n,i have taken assumption that range is between 0 to n-1. solution is O(n) time and O(1) space. //"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we can use XOR to partition the array recursively, the base case is all elements in current partition is identical, then, if the size of this partition is odd, print the first elements of the partition."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5681506135572480","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"12","title":"Given an array of numbers find the maximum count of duplets and triplets such that there sum is a multiple of three. Number that has appeared once can??t be included anywhere else.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"9","title":"Divide the numbers into 3 groups: \nA = { x | x % 3 == 0}, P = |A|    \nB = { x | x % 3 == 1}, Q = |B| \nC = { x | x % 3 == 2}, R = |C| \n \nTo pick 2 numbers whose sum is a multiple of 3 we can: \n  (1) pick 2 from A which have C(P,2) cases \n  (2) pick 1 from B, and 1 from C, which has Q*R cases \n \nTo pick 3 numbers whose sum is a multiple of 3 we can: \n  (1) pick 3 from A, which has C(P,3) cases \n  (2) pick 3 from B, which has C(Q,3) cases \n  (3) pick 3 from C, which has C(R,3) cases \n  (4) pick 1 from A, 1 from B, and 1 from C, which has P*Q*R cases"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In addition to the DP solution , I think we can also use this:  consider this class:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question asks for \"maximum\" number of duplets/triplets and also specifies that number included once cannot be used again. Considering this, I would modify the solution provided by \"Westlake\" as below:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is some C# code I put together. It's probably not the most efficient, but it works."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Looks like the problem for DP."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"why to go for DP unnecessary , i think we can do in generally linear time using boolean hash map as mentioned above: below is not actual code,but i think it should work ...please comment guys.."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4780502829498368","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"34","title":"Given a stream of characters, find the first non-repeating character in the stream. You can go through this stream only once","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"LinkedHashMap will solve this"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \nusing namespace std; \n \n#define ASSERT(x); \nconst int TOTAL_ALPHABET = 26; \n \n//  \n// input - the input stream to search \n// size - size of the input stream in characters \n//  \n// returns first non repeat charcter if found else returns char equivalent of -1 \nchar firstnonrepeatingcharacter(char* input, int size) \n{ \n char result = -1; \n char char_index[TOTAL_ALPHABET]; \n int char_count[TOTAL_ALPHABET] = {0}; \n int chartoint; \n int charindex = -1;  \n  \n // scan the input once O(n) \n for (int i = 0; i < size; i++) \n { \n  chartoint = tolower(input[i])-'a'; \n  if (++char_count[chartoint] == 1) \n  { \n   ASSERT(charindex <= TOTAL_ALPHABET); \n   char_index[++charindex] = tolower(input[i]); \n  } \n } \n \n // scan char index array to find first letter with char count 1 O(1) operation \n for (int i = 0; i <= charindex; i++) \n { \n  if (char_count[char_index[i]-'a'] == 1) \n   return char_index[i]; \n } \n return result; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package pck;  import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set;  public class FirstNonRpt {   public static void main(String[] args)  {      //Input String   String str=\"abad\";            char[] input=str.toCharArray();         //set of character till visited   Set set=new HashSet();         //list of chars (to maintain order)   List list=new ArrayList();         for(int i=0;i  {        Character data=new Character(input[i]);          //if fetched char has already been visited,it will be removed from list(because we are removing Object will be done O(n)    //else it will be added in set as well as in list      if(!set.contains(data))      {       set.add(data);       list.add(data);      }      else      {       list.remove(data);      }   }            //first char in list will be our desired result   if(list!=null && list.size()>0)   System.out.println(list.get(0));      else   System.out.println(\"None\");  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class test{ string s = \"abcba\"; char[] c = s.toCharArray(); List l = c.ArrayasList(); for(i=0;iif(l.indexof(i)-l.lastindexof(i)==0){ system.out.println(list.get(i)); }  }      }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#in Ruby  str = \"II have many words\" mm = {} str.each_char do |x|   mm.merge! x => 1 if mm.delete(x).nil? end  puts mm.keys[0]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.LinkedHashMap; \nimport java.util.Map; \nimport java.util.Map.Entry; \n \n \npublic class FindNonRepeatingChar { \n \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n \n  Map map=new LinkedHashMap(); \n   \n  String s = \"fabcdefcbeaghiadkl\"; \n  char[] stream = s.toCharArray(); \n   \n  char firstNonRepeatingChar='\\0'; \n  int arrayLength=stream.length; \n  for(int index=0;index obj : map.entrySet()) \n  { \n  \n   if(obj.getValue().equals(1)) \n   { \n    System.out.print(\"First non-repeating character in the stream : \"+ obj.getKey()); \n    break; \n   } \n  } \n   \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Groovy Code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how this stream look like? AAAAAAAAAAABAAA? where B is first non-repeating character(except first A)?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If we are talking about letters only, than it is probably better to use 2 bitmasks instead of hash tables. So if we meet letter first time we set the corresponding bit to 1 in the first bitmask, if second (we check the first bitmask) then to second bitmask. Then xor both bitmasks and get LSB."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution in C++ below. I keep track of the position where each character which has appeared only once so far was. I do it using an array of integers with constant size (the size of the alphabet) :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am not sure about the space complexity but time complexity could be O(n) ??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In Python"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package problemSets; \n \npublic class FirstNonRepeatingCharacter { \n \n public static void main(String[] args) { \n   \n  Character[] data = {'a','a','b','b','c','c','c','d','e','d'}; \n \n  int j = 0; \n  int matches = 0; \n  for (int i = 0; i < data.length; i++) { \n    \n   if (data[i] != data[j]) { \n    if (matches == 1) { \n     break; \n    } else { \n     data[j] = data[i]; \n     matches = 1; \n    } \n   } else { \n    matches++; \n   }  \n  } \n   \n  System.out.println(data[j]); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static char getFirstNonRepeatingChar(char[] streamChars) \n { \n  int[] charTracker = new int[256]; // assumming aschii \n  for(int i=0; i< charTracker.length; i++) \n  { \n   charTracker[i]=0; \n  } \n   \n  LinkedList observedCharsQueue = new LinkedList(); // implement queue interface in java \n  // track the count of the chars we observe and also use the queue to know what we have seen first \n  for(int i=0; i < streamChars.length; i++) \n  { \n   int index = (int)streamChars[i]; \n   if(charTracker[index] == 0) \n   { \n    observedCharsQueue.add(streamChars[i]);  \n   } \n   charTracker[index]++; \n  } \n   \n  // now that the tracking is done let return the char the meets the requirement. \n  while(observedCharsQueue.isEmpty() == false) \n  { \n   Character ch = observedCharsQueue.remove(); \n   int index = (int)ch.charValue(); \n   if(charTracker[index] == 1)  \n   { \n    return ch.charValue();   // we have the char we are looking for... \n   } \n  }   \n  // no luck! \n  return '\\0';"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This gives the 1st non repeating char (feed string into char array first). in On^2 time. However, it seems that the amortized complexity wud be much less. Please correct me if anything is wrong in this."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Having counter variable initialized to 1  2. Store each character from start in hash map with key as the counter variable value 3. Insert this counter variable value into a min Heap 4. increment Counter variable 5.     Before adding a character to a check if the character already exists in the the hash map, If it exists delete the character in the hashmap and delete the corresponding the counter variable value from the min heap and update the heap 6 once the stream is scanned completely, extract root of min heap and display the corresponding value from the hasp map"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void bruteForce(int [] n){       for(int i = 0; i < n.length; i++){         boolean flag = false;         for(int j = i+1; j < n.length; j++){          if(n[i] == n[j])             flag = true;           else             continue;         }//end of for         if(flag){           continue;         }         else{           System.out.println(\"First non repeating character = \"+n[i]);           break;         }       }//end of for i        }//end of bruteFore method"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algo Using C#:  1. Create a dictionary with a key being the character of the stream and value being its occurance. 2. Parse the stream 1 character at a time and add the key value pair in the dictionary. Make sure that you catch exception for the already existing key. 3. in Case of exception of already existing key increment the value of the key.  after the stream is completely parsed. the first key with the value 1 is the First non repeated character in the stream."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"string s = \"he did thataa\"; \n             \n            LinkedList charList = new LinkedList(); \n            LinkedList repeated = new LinkedList(); \n            for (int i = 0; i < s.Length; i++) \n            { \n                string  temp = s.Substring(i,1); \n                if(repeated.Contains(temp)) \n                { \n                    continue; \n                     \n                } \n                else \n                { \n                    if (charList.Contains(temp)) \n                    { \n                        charList.Remove(temp); \n                        repeated.AddFirst(temp); \n                    } \n                    else \n                        charList.AddLast(temp); \n                }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Extra int array, size = 26 2. One scan to test case 3. Array: a[index] > 0  indicate its position in string add  one(Why add 1? to avoid the first char is non repeat char)   a[index]==0  indicate this char doesn't appear at all   a[index]<0  this char has duplication"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would create a   class Item { char data; int byteIndex;}  List items = new List(); // or use Array if the stream size is known/given.  while( scanning through stream of chars){ // O(n)   items.add(new Item(data, byteIndex));       }   sort on items with comparable function on data which is char. // using merge sort : O(nlogn)    scan this sorted list till end, compare adjacent items and keep hold of their min byteIndex, and finally this min byteIndex is the first occurance of non-repeating char."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* \n    Karumanchi book Hashing Problem 13-14 \n    Give an algorithm for finding the first non-repeated character in a string. For example, the first non-repeated character \n    in the string \"abzddab\" is 'z' \n    Solution: Create a hash table and read the characters in the input string. Keep count of the number of times \n    each character appears. After reading the input string, we can read the hash table entries to see which entry has \n    a count equal to 1. \n    O(2n) -> O(n) time complexity, O(n) space for the count values \n     */ \n    public static char firstNonRepeatedChar(char[] string) \n    { \n        int i; \n        int[] count = new int[256]; \n        for (i = 0; i < string.length; i++) \n        { \n            count[i] = 0; \n        } \n        for (i = 0; i < string.length; i++) \n        { \n              count[string[i]]++; //new character found so increase counter at specified character value \n        } \n        //loop through the char array again and if the count is 1, then it is the first non-repeated character \n        for (i = 0; i < string.length; i++) \n        { \n            if (count[string[i]] == 1) \n            { \n                System.out.println(string[i]); \n                break; \n            } \n        } \n        if (i == string.length) \n        { \n            System.out.println(\"No non-repeated characters\"); \n        } \n        return 0; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"string value = \"fabcdefcbeaghiadkl\";             char[] array = value.ToCharArray();             int k=0;             char d='\\0';                          for (int i = 0; i < array.Length; i++)             {                 k = 0;                 for(int j = 0; j < array.Length; j++)                 {                     if (i == j)                     {                         continue;                     }                     else                     {                         if (array[i] == array[j])                         {                             break;                         }                         else                         {                             k++;                             if (k > array.Length-2)                             {                                 d = array[i];                                 break;                             }                         }                     }                 }                 if (k > array.Length-2)                 {                     d = array[i];                     break;                 }             }               Console.WriteLine(d);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"import java.util.*; \npublic class NonRepeatingCharacters { \n \n public static void main(String[] args) { \n   \n  //char c [] = {'a', 'b', 'c','d','a'}; \n  String s = \"abcda\"; \n  char c [] = s.toCharArray(); \n   \n   \n  HashMap  hm = new HashMap (); \n    \n  int i =0; \n  while(i < c.length){ \n   char a = c[i]; \n   if(hm.containsKey(a)) \n    hm.put(a, true); \n   else \n    hm.put(a, false); \n   i++; \n     \n  } \n   \n  Set set = hm.entrySet(); \n  Iterator ir = set.iterator(); \n   \n  while(ir.hasNext()){ \n    \n   Map.Entry m = (Map.Entry) ir.next(); \n   if(m.getValue().toString()== \"false\") \n    System.out.println(\"Non Repeting Chars: \"+m.getKey()); \n    \n  } \n   \n } \n \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6073345162346496","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"9","title":"Search in a rotated array for a given integer, it can be rotated clockwise or anticlockwise. Handle both","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can you clarify the question? You have an array and you are searching for a value in it. that's a simple sequential search. or is the array sorted? what role does roration play?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"first find the index at which it was rotated  - split the array into two equal array  - compare first and last element of sub arrays  - one of the subarrays is skewed i.e. has first element greater than last element  - call the function recursively for the skewed subarray  once you have the this index, you can do a simple binary search  complexity is log n for finding the skew index and again log n for binary search"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Interesting problem. I am assuming that the array is sorted before rotation. The algorithm would be:  1. binary search to find the \"kink\" in the series of numbers - O(n) worst case 2. modified binary search to find the number of interest - O(log n) Here is some code (not tested, but outlines the idea):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  #include  #include   class question { public:  enum turn  {   clockwise,   counter_clockwise,  };  void set_array(std::vector& value)  {   m_array = value;   index_array();  }  void index_array(void)  {   m_index.clear();   int array_index, array_max = (int)m_array.size();   for (array_index = 0; array_index < array_max; ++array_index)   {    m_index[m_array[array_index]] = array_index;   }   m_shift = 0;  }  void rotate(const turn direction)  {   if (m_array.size() > 1)   {    int front_value, back_value, new_size;    switch (direction)    {    case clockwise:     front_value = m_array.front();     m_array.erase(m_array.begin());     m_array.push_back(front_value);     --m_shift;     if ((m_shift < 0) && ((unsigned int)abs(m_shift) >= m_array.size()))     {      m_shift += m_array.size();     }     break;    case counter_clockwise:     back_value = m_array.back();     new_size = m_array.size() - 1;     m_array.resize(new_size);     m_array.insert(m_array.begin(), back_value);     ++m_shift;     if (m_shift >= (int)m_array.size())     {      m_shift -= m_array.size();     }     break;    default:     break;    }   }  }  bool search(const int value, int& offset)  {   std::map::iterator it = m_index.find(value);   bool rc = false;   if (it != m_index.end())   {    offset = m_index[value] + m_shift;    rc = true;   }   return rc;  } private:  std::vector m_array;  std::map m_index;  int m_shift; };  int main(int argc, char** argv) {  static int values[] = { 4, 6, 7, 8, 3, 1, 0, 4, 5, 2 };  const unsigned int value_count = sizeof(values) / sizeof(int);  std::vector input_values(values, values + value_count);  question iq5;  int offset, value;  iq5.set_array(input_values);  iq5.rotate(question::clockwise);  iq5.rotate(question::clockwise);  iq5.rotate(question::counter_clockwise);  value = 14;  if (iq5.search(value, offset))  {   std::cout << value << \" at index \" << offset << std::endl;  }  else  {   std::cout << value << \" not found\" << std::endl;  }  value = 3;  if (iq5.search(value, offset))  {   std::cout << value << \" at index \" << offset << std::endl;  }  else  {   std::cout << value << \" not found\" << std::endl;  }  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"github.com/techpanja/interviewproblems/blob/master/src/arrays/searchrotatedsortedarray/SearchInRotatedSortedArray.java"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Recursive Solution that sorts both clockwise and anticlockwise."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the array is not sorted then one has to go with the linear search.  Algorithm:  Assuming that the array is sorted. Assuming the number to be found is x.  1. Taking any element as the first element create a simple array of the elements. 2. Break the array from a place where the number order changes from ascending to descending or descending to ascending.  a. If the Break is for ascending to descending. Compare the first element of the first array with x.   i. If x is less than the first element of the first array. Reject the first array.   ii. If x is more than the first element of the first array. Reject the second array.   iii. Compare the last last element of the accepted array with x.    iv. if x is less. break the array into two from middle and repeat step i-iv.   v. if x is more. Then the element does not exist in the given array.    b. If the Break is for descending to ascending. Compare the first element of the first array with x.   i. If x is more than the first element of the first array. Reject the first array.   ii. If x is less than the first element of the first array. Reject the second array.   iii. Compare the last last element of the accepted array with x.    iv. if x is more. break the array into two from middle and repeat step i-iv.   v. if x is less. Then the element does not exist in the given array."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5694959181103104","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"11","title":"How would you design a social network and find or keep track of someone's oldest friend in a social network? Oldest friend means the friend that you have added for the longest time period. My solution to the first question is to represent friendship in a graph , storing a list of friends in each User object, and use breadth-first-search to find connection. Not sure about the second question though. My idea is either keep a reference to the oldest friend as a member field, or have a double linked list of users sorted by the start date of friendship.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can the oldest friend change in the case of current oldest friend gets removed from friend list,  If so, need to maintain timestamp or some counter like # of friends along with list of friends.  Otherwise, it is oldest friend is like a primary key for a person, can be stored."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The oldest friend will be the 1st friend added unless it gets removed. So I think an \"ID\" and \"Valid\" column in relationship database will be able to get the answer, right? In Rails, it could look like this:  user.friends.find_by_valid(true) #it will return the 1st valid friends ordered by ID."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Adjacency list representation of the friendship graph is good enough for this problem. The first one in the list is your first friend, delete him then second guy comes to the front."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Adjacency list representation of the friendship graph is good enough for this problem. The first one in the list is your first friend, delete him then second guy comes to the front."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Adjacency list representation of the friendship graph is good enough for this problem. The first one in the list is your first friend, delete him then second guy comes to the front."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Adjacency list representation of the friendship graph is good enough for this problem. The first one in the list is your first friend, delete him then second guy comes to the front."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Adjacency list representation of the friendship graph is good enough for this problem. The first one in the list is your first friend, delete him then second guy comes to the front."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Adjacency list representation of the friendship graph is good enough for this problem. The first one in the list is your first friend, delete him then second guy comes to the front."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Adjacency list representation of the friendship graph is good enough for this problem. The first one in the list is your first friend, delete him then second guy comes to the front."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Keep friends in"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we can use a graph representation. Now on a avg each user has around 200 friends(max is like 5k-10k). we can put them into a heap as the unfriend operation happens very rarely and find oldest will be happening frequently. Solution lot depends on the conditions and the frequency of different operations and space constraints. That will be part of followup questions.  Another thing that can be done here is that we can have a doubly linkedlist of graph nodes based on order of time when the friend was added. this will optimize all get, delete and add operations but at cost of memory."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5089673332391936","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"5","title":"Design the system for Amazon website where if you purchase an item X , it shows \"Customers who bought X also bought A,B,C items\".   Assume: if a customer buys A,B,C items in his history then they are all related and each one should appear in others","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"isn't it a database issue?  consider 3 database tables: \"users\", \"items\", \"categories\" and 1 association table, \"deals\", which contains 2 columns: user_id and item_id.  Through these 4 tables, we can have the followings associations:  * an user has bought many items. * an item belongs to one category.  so 'Users who bought item X also bought items' can be accomplished by the following steps:  1. get users from deals table where 'item_id' = 'X' 2. for each user, find all the items he bought that belongs to the same category as 'X'. 3. merge all user's item arrays."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is an association mining problem. There are many good algorithms such as \"Apriori\", \"Frequent Pattern Mining\". That could be used here.  General Idea: 1. List the items the user bought {X,Y,A,B,C} for each user in a separate line. 2. Count the subset {X,A,B,C} in all user transactions and then count the subset {X}. 3. Then you can calculate measures such as \"support\" and \"Confidence\" to measure the probability."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Shouldn't it be like: Each item contain customer list who has purchased this item. lets say Item X is purchased by Customer A, Customer B, Customer C & Customer D  Now, each customer also contain its itemHistory. Customer A: X, a, b, c Customer B: X, b, c, d Customer C: X, e, f Customer D: X, d, g  So if customer A buy item X, then it should be suggested a, b, c, d, e, f, g or should customer be suggested only common items, like: b ,c ,d only ?  For case 2, there will be additional check to filter out common items. Now problem converts to finding common items in the list of list of items (list)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Prefix tree is the best suitable data structure for this, used in frequent pattern mining. google for FP tree"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6150642728960000","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"3","title":"Design Coffee Shop? Follow up: Extend this to handle multiple coffee shops (Ex like starbucks and across countries)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Putting only classes and interfaces:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I think ..it's solution should \"Decorator Design pattern\""},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is there any further clarification about the questions?   Design a sales system, hr system or ...?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5648912434069504","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"4","title":"How to design a file system in OOP. I believe we can use composite pattern to model in which we create an abstract class say Entry, and have directories and files extend from it. In Directories, it has a List. How should we write the remove method so that it will recursively remove all of its sub-directories and sub-files then do parent.remove(this)? Also, how should we take read/write permission into account?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"According to Cracking the code interview, the solution doesn't recursively delete the sub-directories and files, it just calls parent.remove(entry), which will remove the given entry from its parent's list. Is this the right way to do it? I thought we are supposed to delete all of its sub-directories and files before we go to its parent and move it from the list."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4861339986034688","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"14","title":"Lucky numbers are those numbers which contain only \"4\" and/or \"5\". For example 4, 5, 44, 54,55,444 are lucky numbers while 457, 987 ,154 are not.  Lucky number sequence is one in which all lucky numbers exist in increasing order for example 4,5,44,45,54,55,444,445,454,455...  Now we concatenate all the lucky numbers (in ascending order) to make a lucky string \"4544455455444445454455...\"  Given n, your task is to find the nth digit of the lucky string. If the digit is 4 then you have to print \"Hacker\" else you have to print \"Earth\".  Input: first line contain number of test cases T , next T line contain a single interger n.  Output: For each test case print \"Hacker\"(without quotes) if nth digit of lucky string is \"4\" else print \"Earth\"(without quotes) if nth digit of lucky string is \"5\".   Constraints: 1<=t<=10^5 1<=n<=10^15","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"To find the number of digits in the largest lucky number till which point, we get: (sum_of_all_digits_in_lucky_string_so_far) >= n we need to iterate over all lucky numbers. Note, that for a lucky number with k digits, there are at most 2^k lucky numbers that you can generate. So, there are (k*2^k) digits altogether, for this k digit lucky number series. So we want to find the k for which the following is true:  SUM(k*2^k) <= n < SUM((k+1)*2(k+1))  This can be done simply by iterating in a while loop and finding the sum like so:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"// Think of this as a list of all binary combinations from 2^1 to 2^N 0,1;00,01,10,11;000,001,010,... \n         \n        int n = 10; // input \n         \n        int curPow = 1; \n        int skipCount = 0; \n        String numbersInRange = \"\"; \n         \n        // Find the 'bit' range \n        // If we're looking for the position 10th (0-based index) => 0,1;00,01,10,11;'0'00,001, it will be in the 2^3 range \n        // We also need to remember how far we skip (in this case, we skip 2^1 (2 digits) and 2^2 (8 digits) == 10 total ) \n        while ( ( skipCount + Math.pow( 2, curPow ) * curPow ) <= n ) { \n             \n            skipCount += Math.pow( 2, curPow ) * curPow; \n \n            curPow++; \n        } \n         \n        // Create all the posible combnation of the 2^X (x=3 in this case) \n        for ( int x = 0; x < Math.pow( 2, curPow ); x++ ) { \n             \n \n            String bin = Integer.toBinaryString( x ); \n            int paddedCount = curPow - bin.length(); \n             \n            for ( int y = 0; y < paddedCount; y++ ) { \n                 \n                bin = \"0\" + bin; \n            } \n                         \n            numbersInRange += bin; \n        } \n        System.out.println( numbersInRange ); \n        System.out.println( \"skipcount: \" + skipCount ); \n        System.out.println( \"i = \" + numbersInRange.charAt( n - skipCount ) ); \n        // Now map 0 => 4 and 1 => 5 \n \n     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"The luck string is ordered like this:  str length    number   examples 1             2^1      4, 5 2             2^2      44,45,54,55 3             2^3      444,445,454,455,544,545,554,555 ...  So this question can be tranlated to find the size of luck_string and its offset to the array of string with the same size.  A verified solution in ruby as below:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use two queues... 1st queue add numbers with unit place as 4 2nd queue add numbers with unit place as 5 Find min of both queues and add it to result string in form of digits. do it till our result string is more than n. get nth digit"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String args[]) throws IOException  {   String finalString = \"\";   for(int i = 1; i <= 100000; i++ )   {    int ref = i, num = 0;    boolean flag = true;    while(ref != 0)    {     num = ref%10;     ref /= 10;     if((num != 4) && (num != 5))     {      flag = false;      break;     }    }    if(flag)    {     finalString = finalString + i;    }   }   BufferedReader br = new BufferedReader(new InputStreamReader(System.in));   int n = -1;     while(n != 0)   {   System.out.println(\"Enter 0 to Exit\");   System.out.println(\"Enter your Value of N : \");   n = Integer.parseInt(br.readLine());   if(n<=0)   {    continue;   }   n = Integer.parseInt(finalString.substring(n-1, n));   if(n == 5)   {    System.out.println(\"Earth\");   }   else   {    System.out.println(\"Hacker\");   }   }   System.out.println(\"Ends\");  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int get45(int n) { \n        int mask = 1; \n        int sum = 0; \n        int k = 0; \n \n        do { \n            sum += k * (mask << k); \n            k++; \n        } \n        while (n > sum + k * (mask << k)); \n \n        int remainder = n - sum; \n        int pos = remainder / k; \n        int mod = remainder % k; \n        int tmp = 0; \n \n        for(int i = 0;i < pos;i++) { \n             tmp++; \n        } \n \n        if((tmp & (mask << (k - mod - 1))) != 0) { \n            return 5; \n        }  else { \n            return 4; \n        } \n \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nusing namespace std; \n \nint main(int argc, char **argv) \n{ \n    int T, i; \n    unsigned long long int n, sum, p, q, j; \n \n    cin >> T; \n    for (i = 1; i <= T; i++) { \n        cin >> n; \n        sum = 0; \n        j = 1; \n        do { \n            sum += j * (1 << j); \n            j++; \n        } while (sum < n); \n        j--; \n        n = n - (sum - j * (1 << j)); \n        //cout << n << endl; \n        p = (n - 1) / j; \n        q = (n - 1) % j; \n        if ((p & (1 << (j - q - 1))) == 0) { \n            cout << \"Hacker\" << endl; \n        } else { \n            cout << \"Earth\" << endl; \n        } \n \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \"stdafx.h\" \n#include  \n#include  \n \nint* BinaryValue(int ,int); \nint _tmain(int argc, _TCHAR* argv[]) \n{ \n while (1) \n { \n  int vPrev = 0, v = 0; \n  int position; \n  int*arrN = 0; \n  int result = 0; \n  int flag = 0; \n  int inc = 0; \n  printf(\"\\nEnter the position within the string \"); \n  scanf_s(\"%d\", &position); \n \n  for (int bitcount = 1; bitcount < 16; bitcount++)//checks till 2^15 th digit in the string; \n  { \n   if (flag == 1) \n    break; \n   v += bitcount * ((int)pow(2.0, bitcount)); \n   if (v > position) \n   { \n    int k = 0, kPrev = 0; \n    for (k = vPrev; k <= v;) \n    { \n     if (k > position) \n     { \n      arrN = BinaryValue(inc - 1, bitcount); \n      result = arrN[position - kPrev]; \n      if (result == 0) \n      { \n       result = 4;//considered 4 to be binary 0 \n       printf(\"Hacker\"); \n      } \n      else \n      { \n       result = 5;//considered 5 to be binary 1 \n       printf(\"Earth\"); \n      } \n \n      flag = 1; \n      break; \n     } \n     kPrev = k; \n     k += bitcount; \n     inc++; \n    } \n   } \n   vPrev = v; \n  } \n  free(arrN); \n } \n return 0; \n} \n \nint* BinaryValue(int given, int bitcount) \n{ \n int  n = 0; \n int* arrN; \n arrN = (int*)malloc(sizeof(int)*bitcount); \n for (n = bitcount - 1; n >= 0; n--) \n { \n  arrN[n] = given % 2; \n  given /= 2; \n } \n //for (int m = 0; m < bitcount; m++) \n // printf(\"%d\", arrN[m]); \n return arrN; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Solution implemented in c++  #include  #include    //create a function that returns a string that takes in a string named T and an unsigned integer ( to save memory ) named n.  //Assuming T is the actual LuckyString and not the number of Lucky Strings needing to be executed. (!IMPORTANT) //the keyword unsigned assumes an unsigned integer in c++ std::string findLuckyString(std::string T, unsigned n){  //IMPLEMENT CONTRAINTS HERE OR IN PARAMETERS  /* Sine contraints for this problem are very vague, I did not implemnent them.   Do they mean storage as in the decimal value or the binary value. This MUST be clarified(!IMPORTANT)  */  //We loop through the string until we find the proper index.  for (int i = 0; i < T.length(); i++){       //checks the index to see if it is matching    if(n == i){    //if the index is a 5, we will return a string titled \"Hacker\"    if(T[i] == '5'){     return \"Earth\";    }//end if    else if(T[i] == '4'){     // if the index is a 4, then the function returns a string titled \"Earth\"     return \"Hacker\";    }//end else   }//end if  }//end loop  //if the index is out of bounds OR the string does no consist of all 5s and 4s, then the input is invalid nd will return the string below  return \"invalid input! Check string input to make sure '5's and '4's are present and that n is a valid index in the string\"; }  int main(){   //test the function with some values. all index's start at 0!  std::cout << findLuckyString(\"544544\", 4) << std::endl;  std::cout << findLuckyString(\"555554455333\", 7) << std::endl;  std::cout << findLuckyString(\"544544\", 10) << std::endl;  std::cout << findLuckyString(\"67823\", 3) << std::endl;  system(\"PAUSE\"); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using C#  public void TestMethod2(int nthdigit)         {             var alphabet = \"45\";              string tempLuckyString = \"\";             int digitstosub = 0;             int tempcheck = 1;             int temp = 0;             while (tempcheck < nthdigit)             {                 temp++;                 if(temp ==1)                 {                     tempcheck = (int)(Math.Pow(2, temp)) * temp;                 }                 else                 {                     digitstosub = tempcheck;                     tempcheck = (int)(Math.Pow(2, temp)) * temp + tempcheck;                 }             }             int newdigit = nthdigit - digitstosub;             int Noofdigitswithtemp = (int)(Math.Pow(2, temp)) * temp;              var q = alphabet.Select(x => x.ToString());             for (int i = 0; i < temp - 1; i++)             {                 q = q.SelectMany(x => alphabet, (x, y) => x + y);             }             foreach (var item in q)             {                 tempLuckyString = tempLuckyString + item;                 if (tempLuckyString.Length > newdigit)                     break;             }              var theElement = tempLuckyString.ElementAt(newdigit-1);             Console.WriteLine(theElement);         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"generate all 1, 2, 3 .. combinations of 4, 5 and keep appending them. If the length of string is greater then n return the nth value."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for example :  public void returnNthLucky() {    String s = \"\";    int k = 1;    while(s.length < n) {       List l = generate(k, {4, 5});       s += appendAll(l);    } }  public generate(int k, string[] sym, List l, String s) {    if (s.length == k) {      l.add(s);    }    for( k : sym) {       generate(k, sym, l, s + k);     } }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5245749356920832","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"3","title":"Problem Statement There are three types of tickets and stations available in CodeCountry A, B and C. Tickets of type A can only be bought at stations of type A and end at a station of type B. Tickets of type B can only be bought at stations of type B and end at a station of type C. Similarly, tickets of type C can only be bought at stations of type C and end at a station of type A. Also, you can only travel from station i to station j if j > i, i.e. you can only move forward and if the ticket type bought at station i ends at station j. The cost of a ticket is j x j if you travel a distance of j. For example if you start at Station 3 and end at station 5 the cost is 2 x 2=4. Now, you want to travel from Station 1 to Station N using trains in CodeCountry. You are given the type of each station. Output the minimum cost of the journey. Note that station N will also have a type and you must reach it using a ticket of compatible type. Output -1 if it is not possible to reach from station 1 to station N  Input Format The first line contains the number of test cases T. This is followed by T lines one for each test case. Each test case consists of a string representing the types of each station. The i-th character of the string represents the i-th station's type.  Output Format Output the minimum cost of the journey, one line per test case.  Constraints The number of test cases is atmost 50. There will be atleast 2 stations and atmost 15 stations. The first station (station 1) is always of type A.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Make a weighted graph for each station for possible stations. problem reduces to finding the shortest path on the graph"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"dynamic programming - similar to geeksforgeeks.org/minimum-number-of-jumps-to-reach-end-of-a-given-array/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"function validate(){return true;}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6588887669407744","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"15","title":"Given a number N, now find the smallest number K such that product of digits of K is equal to N. If there is no such K then return -1. Suppose N = 100, then K = 455 N=26, K = -1","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Number should be as small as possible (e.g. 40 -> 58, not 85), easily remedied by following the procedure and adding the digit to a priority queue if the next product is >= 10.  However, the above algorithm still doesn't work for 12. The algorithm will follow 2 * 2 * 3 -> 4 * 3 -> 34, but the answer ought to be 26.  Operating on the principle of using fewest digits by combining as many small factors as possible is nice, but instead of an array of single digit primes, consider using all digits from 9 to 2:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int productOfDigitsEqualToNumber(int inputNumber) { \n        if (0 <= inputNumber && inputNumber <= 9) { \n            return inputNumber; \n        } \n        if (inputNumber < 0) { \n            inputNumber = Math.abs(inputNumber); \n        } \n        int smallestNumber = 0; \n        int factor = 1; \n        while (inputNumber > 1) { \n            for (int i = 9; i > 1; i--) { \n                if (inputNumber % i == 0) { \n                    inputNumber = inputNumber / i; \n                    smallestNumber = smallestNumber + i * factor; \n                    factor = factor * 10; \n                    if (inputNumber == 1) { \n                        return smallestNumber; \n                    } \n                    break; \n                } else if (i == 2) { \n                    return -1; \n                } \n            } \n        } \n        return -1;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. To be the smallest number, all the digits have to be in ascending order. 2. To get those digits, keep dividing N with numbers from 2 thru 9 (Lets say this is \"i\" in a for loop of  2 thru 9). 3. If N is divisible by i, divide and store the result of the division back in N. Keep this \"i\" as left most digit of the result. If N is still divisible, repeat this step without incrementing the for loop counter (i). 4. One more last point, to get the lowest number run the loop in reverse, i.e. from 9 thru 2. 5. Finally after all divisions done, we should get N = 1 for a success use case. Else make the result as -1. 6. Break from the loop if you get N = 1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// divide the number from 9 to 2 // if given number is divided by more then once from one digit then divide    record all the divider    and then sort the divider in ascending order"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// divide the number from 9 to 2 // if given number is divided by more then once from one digit then divide    record all the divider    and then sort the divider in ascending order"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the below solution will do.  [1] Find the largest single digit divisor of given number, this digit will form the rightmost digit of K [2] Next repeat [1] to find the next largest single digit divisor of the quotient of [1] which is less than or equal to digit found in [1]. The digit so found is the immediate left digit of K [3] If no digit could be found and quotient is > 9 return -1  Examples:      N        K       Quotient -----------------------------------    40         8         5               58         1 K=58       N        K       Quotient -----------------------------------    26         2         13  As Quotient is > 13, so K =-1      N        K       Quotient -----------------------------------    12         6         2               26         1  K=26"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be done using recursion as below."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Yet another solution: }}}  public static int calculateSmallestK(int N) {    int K = -1;   int buf = N;   int order = 1;    while ( buf > 9) {    if(isPrime(buf)) return -1;    for (int i = 9; i >= 2; i--) {     if (buf % i == 0) {      if (K==-1) K=0;      buf = buf / i;      K += i * order;      order *= 10;      i=9;     }    }   }   return K;  }    static boolean isPrime(int n) {      for(int i=2;i         if(n%i==0)              return false;      }      return true;  } }}}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Yet another solution in plain java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"1) Divide number in multiple of 2,3,5,7 of number. For given number: 2 * 2 * 5 *5 \n2) Backward, keep on multiplying adjacent number as long as multiple is a single digit (< 10) and create new digit and put new digit in place of that number. for given number: 4 * 5* 5 \n3) repeat step 2, u wont have to do it much.concatenate digits in sorted order. Result it: 455 \n4) if number can not be divided into multiple of 2, 3, 5, 7 only, then return -1 \n \nExample: 40 =>  2 * 2 * 2 * 5 = 8 * 5 =  5 * 8 = 40 \nExample: 1260 => 2 * 2 * 3 * 3 * 5 * 7 = 4 * 9 * 5 *  7 = 4 * 5 * 7 * 9 = 4579 \nExample: 12 => 2 * 2 * 3 = 2 * 6 = 26"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"static void Main(string[] args) \n        { \n            int sayi = Convert.ToInt32(Console.ReadLine()); \n            //iteration number \n            int donmeSayisi = sayi / 2; \n            //list of numbers that can divide \"sayi\"  \n            List bolenListesi = new List(); \n            for (int i = 2; i <= donmeSayisi; i++) \n            { \n                if (sayi % i == 0) \n                { \n                    bolenListesi.Add(i); \n                    sayi = sayi / i; \n                    i--; \n                } \n            } \n            //returns -1 \n            if (bolenListesi.Any(a => a > 9) || bolenListesi.Count == 0) \n            { \n                Console.WriteLine(-1); \n            } \n            //returns number \n            else \n            { \n                int donme = bolenListesi.Count - 1; \n                for (int i = donme; i >0 ; i--) \n                { \n                    if (bolenListesi[i] * bolenListesi[i - 1] < 10) \n                    { \n                        bolenListesi[i] = bolenListesi[i] * bolenListesi[i - 1]; \n                        bolenListesi.RemoveAt(i - 1); \n                    } \n                } \n                //Sort it \n                List liste = new List(); \n                for (int i = 0; i < bolenListesi.Count; i++) \n                { \n                    liste.Add(0); \n                } \n                foreach (int item in bolenListesi) \n                { \n                    int c = 0; \n                    foreach (int item1 in bolenListesi) \n                    { \n                        if (item > item1) \n                        { \n                            c++; \n                        } \n                    } \n                    int b = liste.Count(a => a == item); \n                    liste[c + b] = item; \n                } \n                bolenListesi = liste; \n                bolenListesi.RemoveAll(a=>a<1); \n                Console.WriteLine(string.Join(\"\", bolenListesi)); \n            } \n            Console.ReadLine();  \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"How about this?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6051283794395136","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"6","title":"Given 2D matrix of chars, you can find substring by moving in any [of 8]direction inside the range. Get the list of sorted palindromes without duplicate which are available inside all possible substring in the Matrix.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is there a minimum length specified? If no, then even a single letter is a palindrome. Also we cannot traverse a position again right? For example : a[0][0] --> a[1][0] then again a[0][0]? is this possible?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1- palindrome length should greater than 1 2- yes, we can not visit same position again"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Palindrome2D { \n \n \n    static char[][] matrix = new char[][]{ \n            {'a', 'b', 'c', 'd'}, \n            {'c', 'b', 'a', 'c'}, \n            {'c', 'a', 'a', 'c'}, \n            {'a', 'b', 'c', 'd'}}; \n \n    static int MAX = (matrix.length * matrix.length) / 2; \n \n    static int[][] move = new int[][]{ \n            {0, 1}, \n            {1, 0}, \n            {0, -1}, \n            {-1, 0}}; \n \n    static Stack positions = new Stack(); \n    static Map count = new HashMap(); \n    static Set palindromes = new HashSet(); \n \n    public static void main(String arg[]) { \n        int[][] visited = new int[matrix.length][matrix.length]; \n \n \n        for (int i = 0; i < matrix.length; i++) { \n            for (int j = 0; j < matrix.length; j++) { \n                if (count.get(matrix[i][j]) == null) { \n                    count.put(matrix[i][j], 0); \n                } \n \n                count.put(matrix[i][j], count.get(matrix[i][j]) + 1); \n            } \n        } \n \n        for (int i = 0; i < matrix.length; i++) { \n            for (int j = 0; j < matrix.length; j++) { \n                if (count.get(matrix[i][j]) != 1) { \n                    find(0, visited, i, j, \"\" + matrix[i][j]); \n                } \n            } \n        } \n    } \n \n    private static void find(int phase, int[][] visited, int i, int j, String str) { \n        count.put(matrix[i][j], count.get(matrix[i][j]) - 1); \n        visited[i][j] = 1; \n \n        if (phase == 0) { \n            positions.add(new Position(i, j)); \n        } \n \n        if (phase == 2) { \n            if (positions.empty()) { \n                if (!palindromes.contains(str)) { \n                    palindromes.add(str); \n                    System.out.println(str); \n                } \n \n                visited[i][j] = 0; \n                count.put(matrix[i][j], count.get(matrix[i][j]) + 1); \n                return; \n            } \n        } \n \n        for (int[] aMove : move) { \n            int newI = i + aMove[0]; \n            int newJ = j + aMove[1]; \n \n            if (newI < 0 || newJ < 0) { \n                continue; \n            } \n \n            if (newI >= matrix.length || newJ >= matrix.length) { \n                continue; \n            } \n \n            if (visited[newI][newJ] == 1) { \n                continue; \n            } \n \n            if (phase == 0 && count.get(matrix[newI][newJ]) == 0) { \n                continue; \n            } \n \n            if (positions.size() > MAX) { \n                continue; \n            } \n \n            if (phase == 0) { \n                positions.add(new Position(newI, newJ)); \n                find(2, visited, newI, newJ, str + matrix[newI][newJ]); \n                positions.pop(); \n                find(2, visited, newI, newJ, str + matrix[newI][newJ]); \n                find(0, visited, newI, newJ, str + matrix[newI][newJ]); \n            } \n \n            if (phase == 2) { \n                Position p = positions.peek(); \n                if (matrix[newI][newJ] == matrix[p.x][p.y]) { \n                    positions.pop(); \n                    find(2, visited, newI, newJ, str + matrix[newI][newJ]); \n                    positions.add(p); \n                } \n            } \n        } \n \n        if (phase == 0) { \n            visited[i][j] = 0; \n            count.put(matrix[i][j], count.get(matrix[i][j]) + 1); \n            positions.pop(); \n        } \n    } \n \n    static class Position { \n        int x; \n        int y; \n \n        Position(int x, int y) { \n            this.x = x; \n            this.y = y; \n        } \n    } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The above snippet should print sequence also: abcdccdcba"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this should work, The idea is that we iterative check for all the palindromes in all  four directions, forward, downward, back diagonal, front diagonal. Checking in eight directions is not required since you will get the same palindrome again which you don't want. Also to sort by length and remove duplicate, i use a map and an multimap, multimap keeps array sortedby key which is length in this case. In the end we dump the map on to the STDOUT. There are still some missing corner cases, since i wrote this in an online test and didnot have enough time to cover all corners."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5627710193795072","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"12","title":"Find the digits count in the number from Range 0-n For Example: Input range 0-10 count[0]=2 . . . count[9] =1","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int countDigits(int num) {       int rem = num;  int count = 0;       while(rem > 0){            rem = rem / 10 ;   count ++;  }    return count ;      }   void digitsCountFrom(int from, int to) {  int *digitsCount = (int *) malloc( to *sizeof(int)) ;  int i,k ;       for(i=from, k=0 ; i<=to; i++, k++)  {   digitsCount[k] = countDigits(i);         printf(\"digitsCount[%d] : %d\\n\",i,digitsCount[k] );  }       free(digitsCount);     digitsCount = NULL ; }   int main(int argc, const char * argv[]) {     digitsCountFrom(1,100) ;          return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I guess i was not clear. Counting digit means  total number of occurrences of digits 0,,1,2,3,4,5..9 in that range."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This works for 2 digit. Not sure how to make it dynamic for all."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a very naive implementation goes like to iterate from 0 to N. Parse each digit and add digits to digit array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"geekyjumps.blogspot.in/2014/01/given-number-n-now-find-number-of.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The solution is simpler than iterating from 0 to n and counting the digits: This solution is O(log n) instead of O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How will we modify this code if we want to get the number of digits within a range? Here the range is assumed to be 0-n."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void getcount(int n) \n{ \n     int digits[10]; \n     int i,pow; \n     for(i=0;i<10;i++) \n        digits[i]=0; \n     digits[0]=1; \n     for(i=1;i<=n;i++) \n     { \n        pow=i; \n        while(i>0) \n        { \n            digits[i%10] += 1; \n            i=i/10; \n        } \n        i=pow; \n     } \n     for(i=0;i<10;i++) \n        printf(\"count %d is %d\\n\",i,digits[i]);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.HashMap; import java.util.Map;  public class CountDigits {   public static void main(String args[]) {   countDigits(1, 200);   }   private static void countDigits(int i, int j) {   HashMap numCnt = new HashMap<>();   //map   for (int n = i; n <= j; n++) {    String num = String.valueOf(n);    for (int k = 0; k < num.length(); k++) {     if (numCnt.containsKey(String.valueOf(num.charAt(k)))){      numCnt.put(String.valueOf(num.charAt(k)), numCnt.get(String.valueOf(num.charAt(k))) + 1);     } else {      numCnt.put(String.valueOf(num.charAt(k)), 1);     }    }   }   for (Map.Entry ele : numCnt.entrySet()) {    System.out.println(\"Number\" + ele.getKey() + \",Count:\"      + ele.getValue());   }  }  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5971029612560384","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"7","title":"Imagine you're designing a Web Service for a phone application that returns a list of suggested Words that may complete a given string the user types.  For example, if the user writes \"ap\", a list of suggested words may contain [\"apple\", \"application\", \"aptitude\", ...]. Assume English only words and no misspelling.  I gave a solution with tries and interviewer asked for an alternative solution (I was thinking something along the lines of hashing but time ran out and I couldn't put together anything concrete). I mentioned a couple ways I could optimize my idea, but felt short on that area. For example, ways to return smaller lists, ranking, caching, etc.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Trie is good option but the problem with trie is that it wastes a lot of memory. Ternary tree can be used instead of trie."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Google prefix search, it is distinct problem in search. Also trie will be ok. But what will you do with typos and request with a few words?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use TreeSet as dictinary to hold all the possible valid strings, and for each word typed by user invoke a webservices, which return all the string with prefix typed by user."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"suffix tree will be good option. Nodes will be allocated only when they are required."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would also start with trie. Second option is the compressed trie. Last one is hashing: If we are talking about the real words it is hard to imagine the dictionary with the elements length more than 10 average. Also we probably don't want to store more than 10-20 suggestions for user (we can update frequency or use other idea to choose the right words) but for each prefix (or prefix hash and length) we can store a set of suggestions. Of course we store only prefixes we have in the dictionary. So in other words we use the prefix with length X as the key and words (only 10 best as values)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Imp thing here is it is designed for a mobile. I think best you can do apart from TRIE is store all the words in 26 files. Words starting with each unique alphabet in English each file (a-z 26 files). Inside the file you will have words with similar prefix just like in TRIE on different lines. So when user types first three letters of the word you know where exactly to search !"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6331397635571712","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"12","title":"Determine if a tree is a valid BST with no duplicated values. (This means that if the binary tree has a duplicated number it should return \"invalid\" even if it's an actual BST)  I gave an O(n) solution and interviewer seemed happy with it.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"It can be done as follows:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can use same normal BST verification with min and max but at each recursive call, need to check if root->data is not same as left or right data."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can use same normal BST verification with min and max but at each recursive call, need to check if root->data is not same as left or right data."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can be done with two traversal:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"\"need to check if root->data is not same as left or right data\" why this check is required at all? can't we simply go with min/max ..that itself insures that there is no element in left subtree less than or equal to it and similar in right subtree"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"modify the inorder traversal and at each recursive call instead of printing the root, add the root.key into a array with constraint that this root.key> array[lastIndex]."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do in-order traversal, items will be in order if BST (if previous items is larger than next, not a BST) and you can check for duplicate by comparing the last item with the next item  One traversal O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Insert the elements of the tree in to an array doing an inorder traversal  2) Check if the array is sorted and doesnt contain duplicates."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5100302302707712","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"15","title":"Given a sorted 2D matrix. Find the median.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can do something similar to the QuickSelect approach for finding the K-th smallest element of an unsorted 1D array. In QuickSelect:  1. Pick a pivot 2. Partition the 1D array into \"< pivot\" and \"> pivot\" 3.1 If # \"< pivot\" == K-1, pivot is the K-th element.  3.2 If # \"< pivot\" < K-1, pick a new pivot in the \"> pivot\" partition and repeat. 3.3 If # \"< pivot\" > K-1, pick a new pivot in the \"< pivot\" partition and repeat.  With random pivot, the mean complexity is O(n) in an array of size n.  For this problem, given matrix M[][] of m rows and n columns, sorted both row- and column-wise. We can do this: 1. Pick a pivot 2. Start a walk from the top-right of M, move left if current element >= pivot, move down otherwise. 3. The left-most element in each row visited in step 2 partitions M into \"< pivot\" and \"> pivot\". Pick the new pivot similar to the 1D case.  Here is my complete Java code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Its just my thought and I am not sure if this will work  Solution 1:            If we consider ith row and ith column to be a chunk, then the top right element in the inverted L will be the median. Then use the concept similar to median of median algorithm to eliminate the top chunk and bottom chunk and follow procedure similar to median of median algo  Solution 2: With the below method we might be more efficient, but the algo is not complete   Sort the elements in the leading diagonal. In case n is odd, the middle element will be the median.  In case n is even, we need to find all the elements between the 2 middle elements which will give us the median. ( Little more time as to be invested to come up with a precise algorithm for this part)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use heap operations. repeat removing the first number and swap until you find the median."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Code for Heap extractMin operation described by Jim: NOTE- Median when n is odd is assumed to be at floor(n/2)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int KthSmallest2D(){ \n  int[][] matrix = {{1,2,3,101,102}, {4,5,6,103,104}, {7,8,9,105,106}, {10,11,107,108,109}, {12,50,110,111,112}}; \n   \n  int pivot = 0, lr=0, lc=0, m=matrix.length-1, n= matrix[0].length-1, hr = m, hc = n; \n   \n  int K = 13, num = 0; \n   \n  while(lr <= hr && lr <= m){ \n   index pi = get2DPivot(matrix, lr, lc, hr, hc, m,n); \n   pivot = pi.val; \n   index ix = get2DPartition(matrix, lr, lc, hr, hc, pi, m ,n); \n    \n   num = (n+1)*ix.row+ix.col; \n   if(num == K-1 ) \n    return pivot; \n   else if(num < K-1){ \n    if(ix.col == n){ \n     lr = ix.row + 1; \n     lc = 0; \n    }else{ \n     lr = ix.row; \n     lc = ix.col + 1; \n    } \n     \n   }else{ \n    if(ix.col == 0){ \n     hr = ix.row - 1; \n     hc = n; \n    }else{ \n     hr = ix.row; \n     hc = ix.col-1; \n    } \n   } \n    \n  } \n   \n  return -1; \n } \n  \n public static index get2DPivot(int[][] mat, int lr, int lc, int hr, int hc, int m, int n){ \n  index pivot = new index(); \n  ArrayList ar = new ArrayList(); \n  for(int i = lr; i<= hr; i++){ \n   if(i == lr){ \n    index temp = new index(); \n    temp.row = lr; \n    if(lr != hr) \n     temp.col = lc+ (n-lc)/2; \n    else \n     temp.col = lc+ (hc-lc)/2; \n    temp.val = mat[temp.row][temp.col]; \n    ar.add(temp); \n   }else if(i == hr){ \n    index temp = new index(); \n    temp.row = hr; \n    temp.col = hc/2; \n    temp.val = mat[temp.row][temp.col]; \n    ar.add(temp); \n   }else{ \n    index temp = new index(); \n    temp.row = i; \n    temp.col = n/2; \n    temp.val = mat[temp.row][temp.col]; \n    ar.add(temp); \n   } \n  } \n   \n  int size = ar.size(); \n  pivot = ar.get(size/2);   \n  return pivot; \n } \n  \n public static index get2DPartition(int[][] mat, int lr, int lc, int hr, int hc, index pivot, int m, int n){ \n  index ix = new index(); \n  // swap pivot with hr, hc \n  int temp = mat[hr][hc]; \n  mat[hr][hc] = pivot.val; \n  mat[pivot.row][pivot.col] = temp; \n  int j= lr,k = lc;  \n  while(true){ \n    \n   while(!(j == hr && k == hc) && mat[j][k] < pivot.val){ \n    k++; \n    if(k > n){ \n     j++; \n     k =0; \n    } \n   } \n   int c = (hc-1 >= 0)?hc-1:n; \n   int r = (hc-1 >= 0)?hr:hr-1; \n    \n   while(!(r == j && c == k) && mat[r][c] >= pivot.val){ \n    c--; \n    if(c < 0){ \n     r--; \n     c = n; \n    } \n   } \n    \n   if( j < r || (j == r && (k < c))){ \n    temp = mat[r][c]; \n    mat[r][c] = mat[j][k]; \n    mat[j][k] = temp; \n   }else{ \n    mat[hr][hc] = mat[j][k]; \n    mat[j][k] = pivot.val; \n    break; \n   }    \n  } \n  ix.row = j; \n  ix.col = k; \n  ix.val = pivot.val; \n  return ix; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"if(row%2!=0&&col%2!=0){// if odd number of element \n   int midRow= row/2; \n   int midCol=col/2; \n   System.out.println(\"median is : \"+matrix[midRow][midCol]); \n  } \n  else //if even number of elements \n  { \n   int midrow1=0,midrow2=0,midcol1=0,midcol2=0; \n   if(row%2==0){ \n    midrow1=row/2; \n    midrow2=midrow1-1; \n   } \n   if(row%2!=0){ \n    midrow1=row/2; \n    midrow2=midrow1; \n   } \n   if(col%2==0){ \n    midcol1=col/2; \n    midcol2=midcol1-1; \n   } \n   if(col%2!=0){ \n    midcol1=col/2; \n    midcol2=midcol1; \n   } \n   int median = matrix[midrow1][midcol1]+matrix[midrow2][midcol2]; \n   System.out.println(\"median is elseloop :\"+median/2); \n  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5462987762565120","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"11","title":"Given a number N, now find the number of occurrences of each digit 0..9 from 0 to N Eg: i/p: 12 o/p: 2 5 2 1 1 1 1 1 1 1","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what we can do in this question is initialize an array like this:- arr={1,0,0,0,0,0,0,0,0,0}  this array represent the occurrence of a digit as arr[0] for 0 occurrence, arr[1] for 1 occurrence....  Now,  if(n!=0) { for(int i=1;i{ while(i!=0) { int rem= i%10; arr[rem]= arr[rem]+1; //this increase the value of rem digit by 1 in arr array //for ex:- //if the value of i is 456 then //rem will be 456%10 i.e 6 and now arr[rem] will be //arr[6] and it will increased by 1.  i=i/10; } } } for(int i=0; i<=9; i++) cout< \n   \n    \n   -  \n     reyanshjain91 \n     on January 27, 2014 Edit | Flag  \n    \n    \n   Reply"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int[] array = new int[10]; \n  Arrays.fill(array, 0); \n  array[0]++; \n  int N= 12; \n  for(int i=1;i<=N;i++){ \n \n   int temp=i; \n   while(temp>0){ \n    int rem= temp%10; \n    array[rem]++; \n    temp=temp/10; \n   } \n \n  } \n  for(int k=0;k<10;k++){ \n   System.out.println(array[k]);  \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":">>> candidates = range(0,13) \n>>> for i in range(0,10): \n print 'Occurences of %s' % (i) \n reduce (str.__add__, map (lambda x: str(x), candidates)).count(str(i)) \n \n  \nOccurences of 0 \n2 \nOccurences of 1 \n5 \nOccurences of 2 \n2 \nOccurences of 3 \n1 \nOccurences of 4 \n1 \nOccurences of 5 \n1 \nOccurences of 6 \n1 \nOccurences of 7 \n1 \nOccurences of 8 \n1 \nOccurences of 9 \n1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"main() \n{ \nint a[10], range, rem=0,quot =0, i; \n \nprintf(\"\\n What range you want ? : \"); \nscanf(\"%d\",&range); \n \nbzero(a,10*sizeof(int)); \na[0] =1; \n \nwhile(range) \n        { \n                if(range < 10) \n                { \n                        rem = range%10; \n                        a[rem] +=1; \n                        range--; \n                } \n                else \n                { \n                        quot    =       range/10; \n                        a[quot] +=1; \n                        rem     =       range%10; \n                        a[rem] +=1; \n                        range--; \n                } \n \n        } \n \nprintf(\"\\n\"); \nfor(i=0; i < 10; i++) \nprintf(\"Num of %ds %d\\n\", i,a[i]); \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My approach would be to count appearances of each digit according to the number of digits in the range instead of the range itself, in other words I'll count the number of appearances of each digit 0-9 as the lsb, the 2nd digit from the lsb, the 3rd digit from the lsb and so forth. This would result in an O(logn) algorithm.  Given n and some digit 0<=d<=9, how do we count the number of times the digit d appears in n? First, we'll need to divide it to two cases: d=0 and 1<=d<=9.  1. 1<=d<=9. We want to count how many times d appears in the range 0...n as the i-th digit (from the lsb). Let k = 10^(i+1). How many times does d appear as the i-th digit in the range 0...k? It's easy to see that it appears exactly k/10 times (For example: How many times does the digit 1 appear as the second digit in the range 0...100? It appears exactly 10 times for the numbers 10,11,12,...,19). The same applies to the range k+1,...,2k and so on.  Hence, (n/k)*(k/10) is the number of appearances (of d as the i-th digit) in the range 0...Integer(n/k)*k.  We're not done yet though because there may be a remainder from the division of n by k which we didn't handle. Let us look at the remainder 0 <= n % k < k. If (n % k) / (k/10)  is greater than d that means the remainder (n % k) > d*(k/10) which means that the digit d appears as the i-th digit in the remainder k/10 times as well (For example: for the number n=120 and d=1, the remainder n % 100 = 20. Then, 20/10 = 2 > 1 which means that there are 10 more appearances of 1 as the i-th digit in the remainder: 10,11,12,...,19).  If (n % k)/(k/10)All that's left is to handle the case where (n % k)/(k/10)==d. In this case, the number of appearances would be (n % k) % (k/10) + 1 (1 is added because the count starts from 0). For example: n=115 and d=1: (115 % 100) / (100/10) == 1 and (115 % 100) % 10 +1 = 5+1=6 which accounts for the appearance of d=1 as the 2nd digit in the numbers 110 (10 in the remainder), 111 (11), ... , 115 (15). These observations allow us to calculate the number of appearances of 1<=d<=9 as the i-th digit in the range 0...n with O(1) run-time complexity.  2. d=0. This case is slightly trickier because 0 cannot appear as msb (We cannot count 10 appearances of 0 as the 2nd digit in the range 10). Still, we'll try and solve it with a similar but slightly modified approach. Let us look again at (n/k) - k is the same as in (1), the number of appearances of 0 as the i-th digit in the range 0...k-1 is 0 because all the numbers in that range have i digits or less. On the other hand, in the range k...2k-1 it appears k/10 times (For instance, d=0 appears 0 times as the 2nd digit in the range 0...99 but it appears appears 10 times in as the 2nd digit in the range 100...199 and another 10 times in the range 200...299). So the number of appearances of d=0 as the i-th digit in the range 0...Integer(n/k)*k is Math.max((n/k)-1,1)*(k/10). As before, we're not quite done yet because n/k might have a remainder. But the remainder n % k has at most i digits, when should we count d=0 as msb considering that remainder? Using the same idea as in (1), we'll count it relative to k/10. If n % k >= k/10 that means we need to count k/10 appearances in the remainder (For instance: n=110, n % 100 = 10 and 10 >= 100/10 which means we have 10 appearances in the remainder:  100(00), 101(01),...,109(09)). If n % k < k/10 then the number of appearances is (n % (k/10)) + 1.  The resulting (slightly confusing) code is:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include void main(){  int n,i,temp,rem;    int arr[]={0,0,0,0,0,0,0,0,0,0};    printf(\"Enter the number: \");    scanf(\"%d\",&n);    for(i=0;i<=n;i++){     temp=i;       if(temp!=0){       while(temp!=0){        rem=temp%10;          arr[rem]+=1;          temp=temp/10;       }      }      else       arr[0]+=1;    }    for(i=0;i<10;i++)     printf(\"\\nNumber of %ds is: %d\",i,arr[i]);    getch(); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"geekyjumps.blogspot.in/2014/01/given-number-n-now-find-number-of.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// Find number of occurrences of 0 to 9 upto 1 to 100 \n \npublic class FindNumOfOccurrences { \n public static void main(String[] args) { \n  findCount(9); \n } \n  \n \n public static void findCount(int num) \n { \nint count=0; \n   \n  for(int i=0;i<100;i++) \n  { \n   int a=i/10; \n   int b=i%10; \n    \n   if(a==num) \n    count++; \n    \n   if(b==num) \n    count++; \n  } \n   \n  System.out.println(\"Number of \"+ num +\"'s= \"+count); \n } \n  \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4724898538717184","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"18","title":"You are given an array A with elements 0 to n-1, numbers can be repeated in the array. Create n sets where  S[i]={a[i],a[a[i]],a[a[a[i]]]??}. Set has all elements unique. Find the size of the largest set.  Input:  First line contains n, size of the array. n<1000  Next lines contains n numbers, each element of the array  Output  Prints one number: Size of the largest set.  Sample Test Case:  Input: {3,1,2,0}  Output: 2  Explanation:  Four possible sets are  {3,0},{1},{2}{0,3}","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"As per question, input array will have numbers from 0 to n-1 only for array size n with probability of duplicates. Based on that 1) Initialise array S of size n with 0 2) iterate through array and increment S[i] by 1 each time a[i] is accessed. 3) recursively call index a[i] and add return value to S[i] and do as step 2. 4) breakpoint: if  i and a[i] is equal return 0, else if S[i] is non-zero then return S[i]; Complexity : O(n) as each index will be accessed once only"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include using namespace std;  int main(int argc, char **argv) {     int N;     int max, result;     int i, j;      cin >> N;     int *visit_num = new int[N];     int *data = new int[N];     int *st = new int[N];     int top;     bool *is_visited = new bool[N];     for (i = 0; i < N; i++) {         cin >> data[i];     }     for (i = 0; i < N; i++) {         visit_num[i] = 0;         is_visited[i] = false;     }     result = -1;     for (i = 0; i < N; i++) {         if (visit_num[i] != 0) {             continue;         }         j = i;         top = -1;         do {             st[++top] = j;             is_visited[j] = true;             j = data[j];         } while (is_visited[j] == false);         max = top + 1;         if (visit_num[j] != 0) {             max += visit_num[j];         }         if (max > result) {             result = max;         }         for (j = 0; j <= top; j++, max--) {             visit_num[st[j]] = max;         }     }     cout << result << endl;     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// Keeps a count of the depth (number of rucursive calls) \nint count; \n \n// Stores the visited elements' INDEX \nint* done; \n \n// Returns the number of calls possible without going \n// beyond bounds and makes sure it does not visit \n// already visited elements \nvoid get_depth_for(int *i, int m, int size) \n{ \n // We continue only if the index is within bounds \n if(m < size) \n { \n  // To know if the node has been visited aleady \n  int found = 0; \n  for(int x=0; x"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"solution in Ruby.  To avoid array search, use 2 hashes to  1. detect duplicate set, determined by the a[i] 2. detect duplicate number in a set.  The computation complexity is O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Recursive Version"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4532415284379648","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"11","title":"Given an array of integers. Remove minimum number of elements from the array such that the largest and the smallest number does not differ by more than two times.In other words if x is the minimum of the remaining elements in the array and y is the maximum than y<=2x.  Find the minimum number of numbers that has to be removed from the array so that the largest and the smallest number differed in no more than two times.  Input:  First line contains n(2<=n<=10^5), the size of the array  Second line contains n integers, the elements of the array.  Output:  Single integer - the minimum number of elements to be removed from the array.  Sample Test Case:  Input: {4,5,3,8,3,7}  Output: 2  Note: In the above sample you can remove the fourth and the sixth measurement results (values 8 and 7). Then the maximum of the remaining values will be 5, and the minimum one will be 3. Or else, you can remove the third and fifth results (both equal 3). After that the largest remaining result will be 8, and the smallest one will be 4.  You do not need to write full code. Just fill out the given function.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"1) Sort the array \n2) Scan array from 0 to n/2 \n3) for each element i in array: \na) find index of a number which is <= 2*a[i]. Take diff of array size - index of the number.  add this diff with index i (away from 0th index). make it min \nb) repeat step 3.a and take min"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Same qns was asked to me. I sorted the array then started from the end comparing with a[0]. If a[0]x2 >= a[end] then fine else keep on decrementing. Answer is the number of decrements made. It passed 3 out of 4 test cases."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int min_elems(int a[],int end,int start) //a is sorted array \n{ \n if(start >= end) return 999; \n if(a[end] <= 2*a[start]) return 0; \n return 1+min(min_elems(a,end,start+1) ,min_elems(a,end-1,start)); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int find_min_no_of_elem(int *arr, int size) {         int i,j, temp;         int index[size];         int count=0;         //Sort the array         for(i=0;i        {                 for(j=0;j                        if(*(arr+j) > *(arr+j+1))                         {                                 temp = *(arr+j);                                 *(arr+j) = *(arr+j+1);                                 *(arr+j+1) = temp;                         }         }         //find the distance         for(i=0;i        {                 for(j=i;j                {                         if(*(arr+i)*2 < *(arr+j))                         {                                 index[i] = j;                                 break;                         }                         else                                 index[i]=0;                 }         }             for(i=0;i        {                 if(index[i]!=0)                         count++;         }         return count; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Arrays; \nimport java.util.Scanner; \n \npublic class test1 { \n \n public static void main(String[] args) { \n  \n  Scanner s = new Scanner(System.in); \n  int len = s.nextInt(); \n  int a [] = new int[len],i=0,start=0,start1=0,end=len-1,end1=len-1,count=0,count1=0; \n  boolean done=false,done1=false; \n  \n while(s.hasNextInt()) \n { \n   \n  a[i]= s.nextInt(); \n  i++; \n  if (i==len)break; \n } \n Arrays.sort(a); \n  \n  \n  for(i=0;i"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6693217491746816","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"6","title":"you have a array which says the order of alphabets say [abcdef....z]. now use this array to sort, constraint is 'a' can be swapped one time 'b' two times, and for sorting you can use only swap.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is it a random swap or element next to it?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the input array contains more than a string starting with  'a', how can you sort with the constraint that we can use only one swap for strings starting with 'a'? Am not I not understanding it clearly? Please explain."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This looks to me more like a Selection sort."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"\"and for sorting you can use only swap\" what does above statement mean? if we can sort without swapping then like using insertion sort...i think with both(bubble/selection sort) , we may need more than one swap for a like bacabd  also in selection sort,if we can swap with last minimum then i think it can also work..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"bubble sort can be good. since it sorts in descending order. :)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5104497948884992","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"Design a job scheduler.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"class Job \n{ \n  Device targetDevice; \n  int Pages; \n  bytes[] data; \n  JobStatus Status; \n} \nenum JobStatus {} \neunm DeviceStatus {} \nenum DeviceType {} \n \nclass Device \n{ \n  string Name; \n  DeviceType Type; \n  DeviceStatus Status; \n  string Description; \n  //properties \n} \n \nclass Printer : Device \n{ \n   public void Print(); \n} \n \nclass Scheduler \n{ \n  List Devices; \n  List Jobs; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can you please give some more inputs, like: what kind of job scheduler, in what area? Printer Job scheduler, OS job scheduler or any other type job scheduler, there must be little more follow up inputs, please share in brief ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"same as Task scheduler program provided in windows"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"printer job scheduler"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5469781192867840","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"1","title":"you have n different array, all are sorted. form one array of size n whose range is min. meaning in resultant array diff of a[0] to a[n-1] is min.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question is not very clear to me . My Approach acc to what I have understood  is -  1. merge the sorted arrays (n in number) and sort them.(merge sort for the n arrays) 2. Find 'n' adjacent number in the resultant array with the condition : last_num- first_num = minimum."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6291986613010432","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"21","title":"You are given numbers from 1 through 100 in an array, there is one number missing, find that one","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"My understanding of the problem is that there is an unsorted array containing 98 ints between 1 and 100,  thus missing one value in that range.   The sum of numbers 1 through 100 is equal to (101*100)/2 = 5050 If we take the sum of the numbers in our array and subtract it from 5050 the result should  be the one missing int.   Easy enough to code but I'm on mobile"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"One possible solution is the sum solution which was already suggested. The problem with this solution is that for a general n (n=100 in the original problem), calculating the sum may cause overflow (for example n > sqrt(Integer.MAX_VALUE)).  Another solution is to use the xor operator. Recall that xor is commutative, associative and also satisfies the following: 1. a xor a = 0 2. 0 xor a = a  Using these observation, it's easy to see the following: missing_element = 1 xor 2 xor ... xor n xor arr[0] xor arr[1] xor ... xor arr[n-2] (the array has n-1 elements)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it mean we have an array with 98 elements; and every cell has a unique value from 1 to 100   1. sort array  2. apply binary search to go over array and cheek values.  So, array[49] must be equal to 50, if it 's 49 - then check left part, it it's 50 - check right part"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The solution suggested above:  (Sum of natural number from 1 to 100) - (sum of all the elements present in the given array) will give the missing number and infact smart way too :)  I can also think of another solution just let me know if this is efficient enough or not :   Sort the array in increasing order(if not already given in sorted fashion). Then the difference of any two consecutive number should be 1, wherever its not that is our culprit .  Java code for the same:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int[] dizi = new int[100]; \n            for (int i = 1; i < 101; i++) \n            { \n                dizi[i-1] = i; \n            } \n            //dizi[69]=70  \n            //delete it from array to see is it working \n            dizi[69] = 0; \n            for (int i = 1; i < 100; i++) \n            { \n                if (dizi[i]-dizi[i-1]!=1) \n                { \n                    Console.WriteLine(i+1); \n                    break; \n                } \n            } \n            Console.ReadLine();"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. First sum up all numbers from 1 thru 100. Lets say its SUM. 2. Loop thru the input array. Substract each item from SUM. You will have the missing number in SUM finally."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class FindMissingNumber { \n  \n public static void main(String[] args) { \n   \n  findDuplicateNumber(10); \n } \n  \n  \n public static void findDuplicateNumber(int num) \n { \n  int sum=10*(11)/2; \n   \n  int sum1=1+2+3+5+6+7+8+9+10; \n   \n  int num1=sum-sum1; \n  System.out.println(num1); \n   \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the solution of the missing number is"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"sum the numbers and subtract it by 5050."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5717292071518208","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"11","title":"Suppose you are given one number decomposed in binary representation.  Input :   101011 Output : 000000  Needs to write algo and tell the approach in how efficiently we can flip the given input numbers to all zero's  Interviewer not mentioned about time complexity but it should be very efficient.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Can't you just return 0 regardless of the input?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Is anything wrong in either of following two?  1. number & 0; 2. number ^ number;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"XOR the number with itself.  You can do this in a language like Java or C# with a simple number ^ number;  The result of an XOR between two bits is only 1 when one, but not both, of the bits are 1.  Logically, you can see that if you XOR a number with itself, any 1 bits will go to zero because 1 ^ 1 = 0. Any bits that are 0 will stay zero, because 0 ^ 0 = 0. So any number XOR'd with itself is always 0."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just calculate the number of set bits. These need to be flipped. I guess this would be a respectable answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"number & 0 is the expected answer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"n & ~n"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just return 0. Don't care of any inputs."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"XOR and AND : if using XOR then first check if number = 1 then input[i] ^ 1;  if using AND then directly input[i] & 0;"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6233087981649920","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"15","title":"Given an input like:        [2, 4]     [1, 2]     [3, 6]     [1, 3]     [2, 5]  Use it to reconstruct this binary tree:","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"1) Map each input like Map>; key - parentId, value children's list. 2) Recursively reconstruct the tree. Code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"-Create Map m for each entry in given list   check if first int is available in map       if yes, create the child and and it to left if left if null else to the right    if it is not available, create root, create child and assign as left child and add to Map  you can find the root and return it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Imagine a list containing root of trees. For example, if we find an element (1,2) and next (3,4). We store them as two trees with roots 1 & 3.  2. So, as soon as we traverse through a list, we check the parent and child present in each treelist.  3. If parent and child both not found in any tree, append the tree in the list with parent as root.  3. If parent found and child not found in any tree, append the child to left or right of parent by checking. 4. If parent not found and child found in tree (child will be obviously in the root of the tree in the list, if not, then child already has parent -- not possible throw exception, not implemented in the code below),   5. If parent and child found, make child as left or right child of parent by checking, remove the child from the list of trees."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It can be done by keeping following type of map: map > Key: node's key pair.first = Tree node of Parent of Key pair.second = Tree Node of Key  parsing each input line, if key exist then update its parent and child else add key to map."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can as well represent a tree in an array  for node i, left child is 2i+1 and right child is 2i+2  An array is always sorted -"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.  create a matrix like in this case   6* 6 matrix  2. traverse the matrix in DFS manner  and create a binary tree accordingly"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There are so many good solutions here but I want to share mine too ok? Suggestions are always welcome."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In my algorithm : Each node also contains an additional pointer to its parent, not just the left and right child.  recontstructTree() is called for each pair of numbers.  Traverse() does a pre-order traversal of the tree and prints the resulting tree.  I have tested the code and it works fine. Let me know if any questions."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The main concern here is identifying root node.  a) To start with, we maintain a HashMap to store the information already given. 2->{4,5} 1->{2,3} 3->{6} b) Now in order to find the root,      for each of the key in the keySet     -> Find if key is present in atleast one of the value set. If yes, that is not the root.     -> There will be only one key element not present in any of the value sets, and that will be root."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A fast o(3n) solution by me.  It won't fail on LOOPS (return nulls) and won't break on multiple roots (returns the latest)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"#include #include #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include #include  #include  #include #include  #include  #include  #define ull unsigned long long  #define pi 3.141592653589793 #define graphAY_SIZE(A) sizeof(A)/sizeof(A[0]) #define PB push_back #define INF 1<<10 using namespace std; struct node {  int data;  struct node*left;  struct node*right;  struct node*par; }; mapmymap; struct node* insert(int num) {  struct node*temp =(struct node*)malloc(sizeof(struct node));  temp->data = num;  temp->par =NULL;  temp->left = NULL;  temp->right =NULL;  return temp; } void join(struct node*x,struct node*y) {  if((x)->left==NULL)  (x)->left =y;  else  (x)->right = y;  (y)->par =x; } struct node*get_root(struct node*z) {  if(z->par==NULL)  return z;  else  {   return get_root(z->par);  } } void inorder(struct node*t) {  if(t!=NULL)  {   inorder(t->left);   cout<data<<\" \";   inorder(t->right);  }  else  return; } int main() {  int a,b;  while(scanf(\"%d%d\",&a,&b)==2)  {   if(mymap.find(a)==mymap.end())   mymap[a] = insert(a);   if(mymap.find(b)==mymap.end())   mymap[b] = insert(b);   join(mymap[a],mymap[b]);  }  struct node*t =get_root(mymap[b]);  inorder(t);  return 0; }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6010596227022848","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"You as a developer are tasked to create an application that builds invoices that are send out to the company??s clients. Invoices are sent to the client??s address and the client should pay the invoice amount by a given date otherwise fees could incur. The client should be able to see detailed information about the items they are being billed for, like item cost, tax, quantity, etc. The client can be billed for products and/or services. Services are not taxable and product tax varies by client zip code.   Using the objected oriented language of your choice; design an object model for this application.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"typedef long ID; \n \n \nClass Client \n{ \n ID clientId; \n string Name; //This can be struct will details \n string location;  //This can be struct will details \n ID zipcode; //Again this can be part of location \n list transactionIDs;  \n \n public: \n list< Transaction > getTransactions () { return transactionIDs; } \n int getPincode () { return zipcode;} \n string getClientDetails() {return Name;} //Like: first name, last name, age, gender etc \n}; \n \nclass Product \n{ \n ID productId; \n double productCost; \n string productName; \n public: \n ID getProductID () {return productId}; \n string getProductName () {return productName; } \n double getProductCost () {return productCost; } \n}; \n \nclass Service  \n{ \n  ID serviceId; \n double serviceCost; \n string serviceName; \n public: \n ID getServiceID (); \n string getServiceName (); \n double getServiceCost (); \n}; \nstruct trxDetail \n{ \n enum typeOfTransaction; \n ID itemId; \n int itemQuatity; \n}; \nclass Transaction \n{ \n client clientName; \n timestamp purchaseDate; \n timestamp dueDate; \n ID transactionID; \n trxDetail purchasedItem; \npublic: \n client getClient (); \n ID getTransactionID (); \n date getTransactionDate (); \n date getTransactionDueDate (); \n trxDetails getTransactionDetail (); \n //long transactionCost (); // can be calculated using serviceCost/ProductCost & quantity. tax can be added at time of invoice generation \n //addTransaction (client, transactiontime, duedata, ); \n}; \n \nclass taxDetails \n{ \n ID zipcode; \n double taxAmount; \npublic: \n double getTax (); \n}; \n \nclass invoiceManagement \n{ \n map clientMap; \n map serviceMap; \n map productMap; \n map transactionMap; \n map taxMap; \n static invoiceManagement *instance; \n \npublic: \n static invoiceManagement  *getInstance () \n { \n  if (instance == NULL) \n  {  \n   instance = new invoiceManagement; \n  } \n  return instance; \n } \n Client getClient ( ID clientId ) {  return clientMap[clientID]; } \n Service getService (ID serviceId ) { return serviceMap[serviceID];  } \n Product getProduct (ID productId ) { return productMap[productID];  } \n Transaction getTransaction (ID transactionId ) { return transactionMap[transactionID];  } \n taxDetails getTaxDetails (ID zipcode ) { return taxMap[zipcode];  } \n \n}; \n \nclass invoice \n{ \n invoiceManagement *IM; \npublic: \n invoice () { IM = invoiceManagement::getInstance(); } \n \n void generateInvoice (ID clientID) \n { \n  Client *client = IM->getClient (clientID); \n  list trxList= client-> getTransactions (); \n \n  //print: customer details, address \n  for (trx: trxList) \n  { \n   trxDetail td = trx. getTransactionDetail (); \n   ID zipcode =  client->getzipcode(); \n   string clientname = client->getClientDetails (); \n   timestamp duedate = trx.getDueDate (); \n   timestamp trxdate = trx.getTransactionDate (); \n   double unitcost = 0; \n   double tax = 0; \n   string name = \"\"; \n   int quantity = 0; \n   if (td.type == PRODUCT) \n   { \n    quantity = td.quantity; \n    Product product = IM->getProduct (td.itemID); \n    unitcost = product.getCost (); \n    name = product.getName (); \n    tax = IM.->getTaxDetails (zipcode); \n   } \n   else if (td.type == SERVICE) \n   { \n    quantity = td.quantity; \n    Service service = IM->getProduct (td.itemID); \n    unitcost = service.getCost (); \n    name = service.getName (); \n   } \n \n   int totalCost = unitcost * quantity + tax; \n   //print: name, unit cost, quantity, totalcost, due date, transaction date \n  } \n } \n};"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Create following classes -invoice -customers -Collector -InvoiceManagement -Items <--Services/products -BillProcessor(IRuleEngine) -IRuleEngine"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Appreciate the effort, although you have not used inheritance at all. One use might be while inheriting product and services from the item."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6233120529448960","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"12","title":"Write a routine to reverse every k nodes in a given linked list input : 1,2,3,4,5,6   k:3 output : 3,2,1,6,5,4","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"3 pointers, p, p->next, p->next->next, do the reverse, then repeat..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static Node swapElRec(Node head, int k) {          if (head == null) {             return null;         }          Node current = head;         Node next = head.next;         head.next = null;          int i = 0;         while (next != null && i < k - 1) {             Node temp = next.next;             next.next = current;             current = next;             next = temp;              i++;         }          if (next != null) {             head.next = swapElRec(next, k);         }          return current;     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void kreverse(int k) { \n        SingleLLNode prev = null; \n        SingleLLNode temp = this.next; \n        int count=0; \n        SingleLLNode header = this; \n        while(temp!= null) { \n            header.next = temp; \n            temp =temp.next; \n            header.next.next = prev; \n            prev = header.next; \n            count++; \n            if (count == k) { \n                while(count > 0) { \n                    header = header.next; \n                    count--; \n                } \n                prev = null; \n            } \n        } \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void reversek ( node ** head, int k) { \n    node *current = *head; \n    node *next = NULL; \n    node * tmp, tmp1; \n    int i; \n    int flag =0; \n    assert(current!=NULL); \n    while ( current ) { \n         tmp1 = current; \n         next = NULL; // initially treating the last node as NULL \n         for (i=0; inxt;  \n             current -> nxt = next; \n             next = current; \n             current = tmp; \n        } \n        if (flag = 0) \n            *head = next; \n        flag = 1; \n         \n        tmp1 -> nxt = current; //now copying the correct next node previously assigned as NULL \n   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Solution { \n   \n public static void reverseKNodesLinkedList(List list, int k) {      \n     int len = list.size(); \n     int i = 0; \n     int k1 = 0; \n     int kTemp = 0; \n      \n     while ( i + k <= len) {    \n         k1 = i + k - 1; \n         kTemp = i + k; \n         while (i < kTemp && i < k1) {             \n             Integer temp = list.get(i); \n             list.set(i, list.get(k1)); \n             list.set(k1, temp); \n              \n             i++; \n             k1--;             \n         }      \n         if (i < kTemp) { \n          i = kTemp; \n         } \n     }         \n }  \n \n public static void main(String[] args) { \n         List list = new LinkedList();          \n         list.add(1); \n         list.add(2); \n         list.add(3); \n         list.add(4); \n         list.add(5); \n         list.add(6); \n         list.add(7); \n         list.add(8); \n         list.add(9); \n         list.add(10); \n          \n         reverseKNodesLinkedList(list, 5); \n \n         Iterator iter = list.iterator(); \n         while (iter.hasNext()) { \n             System.out.print(iter.next() + \",\"); \n         }                 \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/** \n *  \n */ \npackage linkedlist; \n \n \nimport linkedlist.LinkedList; \nimport linkedlist.Node; \n \npublic class ReverseKLL { \n \n /** \n  * @param args \n  */ \n  \n Node reverseKLL ( int k , Node head ) { \n   \n  if ( head == null ) \n   return head; \n  if ( k == 0 ) \n   return head; \n   \n  Node t = null; \n  Node tNext = null; \n   \n  if ( head != null ) \n   t = head.getNext(); \n   \n  if ( t != null ) \n   tNext = t.getNext(); \n   \n  int k1 = k; \n  Node headNew = head; \n  Node tNew = t; \n  Node tNextNew = tNext; \n   \n  boolean terminated = false; \n   \n  while ( k1 > 1 && tNew != null ) { \n       \n   tNew.setNext(headNew); \n   headNew = tNew; \n   tNew = tNextNew; \n    \n   if ( tNextNew != null ) \n    tNextNew = tNextNew.getNext(); \n    \n   k1--; \n  } \n   \n  if ( tNew == null ) \n   terminated = true; \n   \n  if ( terminated ) \n   head.setNext(null); \n   \n  t = tNew; \n  if ( t != null ) \n   head.setNext(reverseKLL(k,t)); \n   \n  return headNew; \n } \n  \n public static void main(String[] args) { \n  // TODO Auto-generated method stub \n  Object[] a = {1,2,3,4,5,6,7}; \n  int k = 4; \n   \n  LinkedList ll = new LinkedList (a); \n  Node head = ll.getLL(); \n   \n  ReverseKLL o = new ReverseKLL(); \n  head = o.reverseKLL(k, head); \n   \n  ll.display(head); \n   \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n/2):O(1) time:space"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void kReverse(Node * st, int k){ \n  Node *p, *s1, e1; \n  int i; \n  if(k<2) \n   return; \n  p = null; \n  s1 = e1= st; \n  while(s1!=null){ \n   for(i=0; i< k-1 || e1 != null; i++, e1= e1->nxt); \n    \n   reverseList(s1,e1); \n    \n   if(p==null) \n    st = s1; \n   p = e1; \n   s1 = p->nxt; \n   e1 = s1; \n  } \n } \n  \n public static void reverseList( Node * start, Node * end){ \n  Node *p, *q; \n  p = start; \n  while(start != end){ \n   q = start -> nxt; \n   start -> nxt = end -> nxt; \n   end -> nxt = start; \n   start = q; \n  } \n  end = p; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  struct list *newnode(int data); int count1=1; struct list {   int data;   struct list *next; }*p,*p1,*p3,*p4; main() {     struct list *root1;    struct list *root=newnode(1);    root->next=newnode(2);    root->next->next=newnode(3);    root->next->next->next=newnode(4);    root->next->next->next->next=newnode(5);    root->next->next->next->next->next=newnode(6);    root->next->next->next->next->next->next=newnode(7);    root->next->next->next->next->next->next->next=newnode(8);    printf(\" Before Doing Swapping \");    printf(\"\\n\");    linkedlist(root);    printf(\"\\n\");    int count =no_nodes(root);    root1=root;    do_swap(root,root1,count,3);    printf(\" After Doing Swapping \");    printf(\"\\n\");    linkedlist(root);    printf(\"\\n\"); } void linkedlist(struct list *tree) {     while(tree!=NULL)     {         printf(\" %d\",tree->data);         tree=tree->next;     } } void do_swap(struct list *root,struct list *root1,int count,int n) {  int count1=count-n;  int i=1;  int j1=1;  if(count1==n)  {      printf(\" Cannot Be Done \");      exit(0);  }  if(n>count)  {      printf(\" Larger Size Cannot Be Done \");      exit(0);  }  while(i<=n-1)  {      if(i==n-1)      {          p=root->next;          p1=root->next->next;          i++;      }      else      {          root=root->next;          i++;      }  }  while(j1<=count1)  {      if(j1==count1)      {          p3=root1->next;          p4=root1->next->next;          j1++;      }      else      {          root1=root1->next;          j1++;      }  }  root->next->next=NULL;  root->next=NULL;  root1->next->next=NULL;  root1->next=NULL;  root->next=p3;  p3->next=p1;  root1->next=p;  p->next=p4; }  int no_nodes(struct list *tree2) {     while(tree2!=NULL)     {         count1++;         tree2=tree2->next;     }     return count1-1; }  struct list *newnode(int data) {     struct list *tree1=(struct list *)malloc(sizeof(struct list));     tree1->data=data;     tree1->next=NULL;     return tree1; }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5751792134520832","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"14","title":"Find all nodes that are at a distance k from leaf nodes","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Fixed Solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Post-order traverse for the tree, calculate all depths in left tree (e.g., 3, 4), and all depths in right tree (e.g., 2, 3), and combine the results into one list (2, 3, 4), then add '1' to each elements, we will have (3, 4, 5), and get back to parent node.  If 'k' is in the new list, or 'k-1' is in the combined list, output the current node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void levelTraversal(Tree root, int level) { \n        if (root == null) { \n            return; \n        } \n        if (level == 1) { \n            System.out.print(root.value + \"->\"); \n        } else { \n            levelTraversal(root.left, level - 1); \n            levelTraversal(root.right, level - 1); \n        } \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int findHeight(TreeNode root) { \n  if(root == null || (root.left == null && root.right == null)) \n   return 0; \n  else  \n   return Math.max(findHeight(root.left), findHeight(root.right))+1; \n } \n public static void findNodesKFromLeaf(TreeNode root, int k) { \n  if(root == null)  \n   return; \n   \n  findNodesKFromLeaf(root.left,k); \n  findNodesKFromLeaf(root.right,k); \n   \n  int lefth = findHeight(root.left); \n  int righth = findHeight(root.right); \n   \n  if(Math.max(lefth, righth) +1  == k) { \n   System.out.println(root.value); \n  } \n   \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct distk { \n  int k1; \n  int k2; \n} \n   \n distk printnodek( node *root, int k) { \n    if (root == NULL)  \n        return k; \n \n    struct dk; \n    dk.k1 = printnodek(root->left, k); \n    dk.k2 = printnodek(root->right,k); \n    if (dk.k1==0 || dk.k2==0) \n        printf(\"Node was %d\", root->data); \n    dk.k1--; \n    dk.k2--; \n    return dk; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList;  class Box{  Box(String data, Box list[]){   this.data=data;   this.items=list;  }  String data;  Box items[] ;  }  public class TreeStructure {  static ArrayList kthNodes= new ArrayList();  public static void main(String[] args) {   Box items1[]={new Box(\"2\",null),new Box(\"2\",null)};   Box items2[]={new Box(\"2\",null),new Box(\"2\",null)};   Box items[]={new Box(\"1\",items1),new Box(\"1\",items2)};   Box start= new Box(\"root\",items);       findKNodes(start);      for(Box b:kthNodes)   System.out.println(\"Data is \"+b.data);  }  private static void findKNodes(Box start) {   find(start,0);    }   private static void find(Box start, int i) {   if(start==null)    return;   if(i==2)      kthNodes.add(start);   else if(start.items!=null){ i++;    //System.out.println(start.data+\"  \"+start.items.length);   for(Box b:start.items)    find(b,i);   }    }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void findKDistantLeafNodes(TreeNode root, int k) {          if(root == null) return;          // non leaf          if( reachableToLeafNode(root, k) ) {             System.out.print(\"** \" + root.data + \" **\");          }          findKDistantLeafNodes(root.left, k);         findKDistantLeafNodes(root.right, k);     }         public static boolean reachableToLeafNode(TreeNode root, int k) {       if (root == null) return false;      if (root.left == null && root.right == null && k ==0 ) return  true;       return reachableToLeafNode(root.left, k -1) || reachableToLeafNode(root.right, k -1);      }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void printFromLeaf(TreeNode root, int k)  {   if(root == null)    return;    printFromLeaf(root.getLeft(), k);   printFromLeaf(root.getRight(), k);    int leftHeight = getHeight(root.getLeft());   int rightHeight = getHeight(root.getRight());    if(leftHeight+1 == k || rightHeight+1 == k)    System.out.printf(\" \"+ root.data);   }   static int getHeight(TreeNode root)  {   if(root == null || (root.getLeft() == null && root.getRight() == null))    return 0;   else   {    return Math.max(getHeight(root.getLeft()),getHeight(root.getRight()))+1;   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Write a recursive function to calculate the height , if height(node) = k , push them into a stack finally pop out everything from the stack ( Note take height of leaf node =0) ------------- Time Complexity : O(n) ------------ Space Complexity : O(1)  Optimed solution for time :-  memoize the recursion i.e - store the heights of every  node you calculate in a hash table   and then check first if the hash map has a value of height for this node in recursion  if present return the value from hash map , else do the recursion Time Complexity ------------- O(n) Space Complexity ----------- O(n)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5955807912919040","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"11","title":"Integer V lies strictly between integers U and W if U < V < W or if U > V > W. A non-empty zero-indexed array A consisting of N integers is given. A pair of indices (P, Q) where 0 ?? P < Q < N is said to have adjacent values if no value in the array lies strictly between values A[P] and A[Q], and in addition A[P] ?? A[Q]. For example, in array A such that:   A[0] = 0    A[1] = 3    A[2] = 3   A[3] = 7    A[4] = 5    A[5] = 3   A[6] = 11   A[7] = 1 the following pairs of indices have adjacent values:   (0, 7),   (1, 4),   (1, 7),   (2, 4),   (2, 7),   (3, 4),   (3, 6),   (4, 5),   (5, 7). For example, indices 4 and 5 have adjacent values because the values A[4] = 5 and A[5] = 3 are different, and there is no value in array A that lies strictly between them ? the only such value could be the number 4, which is not present in the array. Given two indices P and Q, their distance is defined as abs(P?Q), where abs(X) = X for X ?? 0, and abs(X) = ?X for X < 0. For example, the distance between indices 4 and 5 is 1 because abs(4 ? 5) = (5 ? 4) = 1. Write a function: class Solution { public int solution(int[] A); } that, given a non-empty zero-indexed array A consisting of N integers, returns the minimum distance between indices of this array that have adjacent values. The function should return ?1 if no adjacent indices exist. For example, given array A such that:   A[0] = 1    A[1] = 4    A[2] = 7   A[3] = 3    A[4] = 3    A[5] = 5 the function should return 2 because: indices 1 and 3 are adjacent because A[1] ?? A[3] and the array does not contain any value that lies strictly between A[1] = 4 and A[3] = 3; the distance between these indices is abs(1 ? 3) = 2; no other pair of adjacent indices that has a smaller distance exists. Assume that: N is an integer within the range [1..40,000]; each element of array A is an integer within the range [?2,147,483,648..2,147,483,647]. Complexity: expected worst-case time complexity is O(N*log(N)); expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments). Elements of input arrays can be modified.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Can we solve it like this: 1. create an array B with the same length as the input array, 2. initialize the elements' values as the indices, i.e. B[i]=i 3. use heapsort(since it has the best worst-case big O) to sort A, when swap values, remember to swap values in B, because we want to maintain the invariant: orig(A[i])==A[B[i]] 4. after the sort is done, we have: any two adjacent elements in A have adjacent values 5. scan through the A, and record the minimum distance in array B."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi,  I think sorting can solve the problem. Create new array B storing all pairs of (A[i], i).  Sort B by the value A[i] first, then by the index i. In the sorted B we just have to check two consecutive elements to calculate the required minimum.  Am I wrong?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"\"the function should return 2 because: \nindices 1 and 3 are adjacent because A[1] ?? A[3] and the array does not contain any value that lies strictly between A[1] = 4 and A[3] = 3; \""},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"g"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I received this programming challenge from Amazon and I used the same approach: sorting the array and keeping track of indices from original array. I used Arrays.sort for sorting, which is a variation of MergeSort when sorting arrays of Object, and has worst case O(n logn) time and O(n) space complexity. What I didn't realize when I submitted the solution was that I needed to take care of cases when the sorted array contains a sequence of equal values. The elements at either ends of such sequences need to be compared with each element in the sequence to find the element with the closest original index. You can see my solution below and please leave a comment if you find anything wrong with the program."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6318457771524096","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"6","title":"Explain output of following code:","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"x=0 y=0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"x!=x (x is not equal to x) is a boolean expression which evaluates to false but it is not stored in any other variable.  x=!x (the value of not x is stored in x), here ! is logical not operator, since x=10, x is considered true in C now !x is false which evaluates to 0 in C"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"x=0;y=0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"! of any nonzero value gives \"ZERO\".so x will  be \"ZERO\".And for y,as first operand is 0 total expression evaluvates to \"ZERO\".so y will be \"ZERO\"."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5709517308297216","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"8","title":"Explain the output of the following code:","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"x=0 y=0  x = !x -> x = 0 y = !x&&!y -> y=0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"00"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Could you tell how x!=x works. I dont know how does the ! operator works in this manner."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi not sure about the c code, but if this is to write in java, it will certainly throw error on line"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"x turns 1 y turns zero"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5712388493934592","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"50","title":"Given a number N, find the smallest 3 digits number  such that product of its digits is equal to N.For example for N=100 , 3 digits number is  455.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"/* \n * Given a number N, \n * find the smallest 3 digits number such that product of its digits is equal to N. \n * For example for N=100 , 3 digits number is 455. \n */ \n \n public class Min3DigtProdEqualN { \n \n  public int findMin3DigitNum(int givenN){ \n    \n   for(int i=100;i<1000;i++){ \n    if(givenN==getProductOfDigits(i)) \n     return i; \n     \n   } \n    \n   return -1; \n  } \n   \n public int getProductOfDigits(int num){ \n    \n   int product=1; \n   do{ \n    int a=num%10; \n    product*=a; \n    num/=10; \n   }while(num>0); \n   return product; \n  } \n  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Sweep for all digits.  It takes much less than it looks like since not all digits divide N.  Test case for 27: answer 139"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \nusing namespace std; \n \nint product(int N) \n{ \n    if(N/10 == 0) \n        return N; \n    else \n        return (N%10) * product(N/10); \n} \nint findMumber(int  N) \n{ \n    int digits = 0; \n    int temp = N; \n    while(temp = temp / 10 ) \n        digits++; \n \n    int start = pow(10, digits); \n    int i = start + 1; \n    for (; ; ++i) \n    { \n  if (product(i) == N) \n            break; \n    } \n    return i; \n} \n \nint main() \n{ \n    cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void findThreeDigitNumber(int num) \n { \n  int r=0; \n  if(num>=1) \n  { \n  for(int i=1;i<10;i++) \n  { \n  if(num % i==0) \n  { \n   int temp=num/i; \n   for(int j=1;j<10;j++) \n   { \n    if(temp%j==0 && temp/j<10) \n    { \n     r=(temp/j)*100+(j)*10+num/temp; \n    } \n   } \n  } \n  }} \n  System.out.println(r); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* accepts input for no of digits and the number for the product to be checked */ \n \nint main() \n{ \n int digits,N,min; \n \n digits = atoi(argv[1]); /* no of digits */ \n N = atoi(argv[2]);  /* This the number to be checked for the product */ \n \n min = 1 << (digits -1 ); \n while ( min <  (1 << digits)) \n {  \n  if ( N == product(N)) \n   return min;  \n  min++; \n } \n printf(\" Product not present \\n\"); \n  \n return 0; \n} \n \nint product (int n) \n{ \n if ( n == 0) \n  return 1; \n return((n % 10) * product(n/10)); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think it is all about getting the factors of the number N and then sort it in increasing order. Right now I am not able to think in which cases it won't work."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"find the product of smallest 3 digit number of the given number N. \n \n/* accepts input for no of digits and the number for the product to be checked */ \n \nint main() \n{ \n int digits,N,min=1; \n \n digits = atoi(argv[1]); /* no of digits */ \n N = atoi(argv[2]);  /* This the number to be checked for the product */ \n \n for(i=0; i< digits; min = min*10);  \n digits = min*10; \n while (min < digits) \n {  \n  if ( N == product(min)) \n   return min;  \n  min++; \n } \n printf(\" Product not present \\n\"); \n  \n return 0; \n} \n \nint product (int n) \n{ \n if ( n == 0) \n  return 1; \n return((n % 10) * product(n/10)); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static  int? FindNumber (int input) \n  \n { \n  for (int i=1;i<10;i++) \n  { \n   if (input%i!=0) \n    continue; \n   int result = input/i; \n   for (int j=1;j<10;j++) \n { \n  if (result %j!=0 || (result/j )>9) \n   continue; \nint requiredNumber = result/j+j*10+i*100; \nreturn requiredNumber; \n } \n } \n //there is no solution \n return null; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package assignment; class Assignment {     public static void main(String[] args) {               int i=100;        while(i<1000)       {              System.out.println(\"2nd loop\"+i);           int s=i;           int p=1;           while(i>0)       {           System.out.println(\"i=\"+i);             int n=i%10;             p=p*n;             i=i/10;           }            System.out.println(p);            if(p==Integer.parseInt(args[0]))           {             System.out.printf(\"Number is %d\",s);             break ;           }           else           {           i=s+1;           System.out.println(\"i=\"+i);   }       }}}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"e.g. 600  the factor of 600 is factorArray[] = {2,2,2,3,5,5} first step multiply factorArray[len -2]factorArray[len -3] which is 2 and 3. then sort and get {2,2,5,5,6} repeat above step {2,5,6,10} and then {6, 10, 10}   the answer is {6, 10, 10}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"e.g. 600  the factor of 600 is factorArray[] = {2,2,2,3,5,5} first step multiply factorArray[len -2]factorArray[len -3] which is 2 and 3. then sort and get {2,2,5,5,6} repeat above step {2,5,6,10} and then {6, 10, 10}   the answer is {6, 10, 10}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Let's try this efficient version:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If we divide the number n by 9 ... 2 until n > 1 then we will get the smallest number  If n = 100 then n / 9 = x n / 8 = x n / 7 = x n / 6 = x n / 5 = 10  now n = 10 then  n / 9 = x n / 8 = x n / 7 = x n / 6 = x n / 5 = 2  now n = 2 then  n / 9 = x n / 8 = x n / 7 = x n / 6 = x n / 5 = x n / 4 = x n / 3 = x n / 2 = 1  2x5x5 = 100. So, 255 is the smallest number.  If n = 12 then  n / 9 = x n / 8 = x n / 7 = x n / 6 = 2  now n = 2  n / 9 = x n / 8 = x n / 7 = x n / 6 = x n / 5 = x n / 4 = x n / 3 = x n / 2 = 1  so, 2 * 6 = 12. i.e. 1 x 2 x 6 = 12 that's why 126 is the smallest number"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be done using recursion as below."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int findThreeDigitNumber(int target) { \n int maxDigit = 9; \n int i \n int tempAnswer = 0; \n while (maxDigit > 0 && tempAnswer<100) { \n  if( (target%maxDigit) == 0) { \n   tempAnswer += (10^i) * maxDigit; \n   target /= maxDigit; \n  } else { \n   maxDigit--; \n  } \n } \n if (target==1 && tempAnswer>100) { \n  return tempAnswer; \n } else { \n  return -1; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"step-1 : Divide the number with 9 to 2. step-2: if a divisor is greater than 9, then solution is not possible step-3: arrange the numbers in increasing order, step-4: print the array Ex: 100 (factors: 5,5,4)---> (4,5,5)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"step-1 : Divide the number with 9 to 2. step-2: if a divisor is greater than 9, then solution is not possible step-3: arrange the numbers in increasing order, step-4: print the array Ex: 100 (factors: 5,5,4)---> (4,5,5)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool dfs(int idx, int target, int product, vector& buf){ \n if(idx == 3){ \n  if(target == porduct) return true; \n  return false; \n } \n if(product > target) return false; \n for(int i = 1; i < 10; i++){ \n  buf.push_back(i); \n  bool b = dfs(idx+1, target, product*i, buf); \n  if(b) return true; \n  buf.pop_back(); \n } \n return false; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Not a complete solution, just breaking the problem into reasonable parts a) Prime factorize the given number 'N' b) Put the factors in an array in ascending order c) Aim to multiply the elements of the array in such a way that the result has just 3 elements in the array.  e.g N = 40 Factorization = 2,2,2,5 Array = 1,2,2,2,5 Possible combinations: 185, 245  -> 185->158 (By sorting in ascending order)  e.g N = 60 Factorization = 2,2,3,5 Array: 1,2,2,3,5 Possible combinations: 265, 435 -> 256 -> 256  Note: We can't combine any prime factor above 3 (i.e. 5,7) with any other prime factor since it would cause a two digit resultant. So, all we need to optimize is the product of factors of 2 and 3 only."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static String solution(long givenN) {         List result = new ArrayList();         while (givenN > 1) {              int k = 9;             while (givenN % k > 0) {                 k = k - 1;             }             if (k > 1) {                 givenN /= k;                 result.add(k);             } else {                 result.clear();                 result.add(\"Cannot be written as a product of digits because \"+givenN+\" is a prime number\");                 break;             }         }         Collections.reverse(result);         StringBuilder sb = new StringBuilder();         for (Object o : result) {             sb.append(o);         }         return sb.toString();     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"pseudo code:   Find the smallest factors of N   e.g. N= 100  sorted array of factors = 2,2,5,5   Then club smallest factors to make a bigger factor starting from the beginning of the  array till the array contains only 3 factors  i.e. sorted array of factors = (2*2),5,5 -> (4,5,5). By multiplying the digits by corresponding powers of 10  the output can be obtained."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n#include \n#include \n \n \n \nbool isPrime(const int &x) \n{ \n for(int i=2;i=2;i--) \n { \n  if(N%i==0 && !isPrime(N/i)) \n  { \n   out = i; \n   N = N/i; \n   break; \n  } \n } \n \n for(int i=9;i>=2;i--) \n { \n  if(N%i==0 && isPrime(N/i)) \n  { \n   out = out + (i*10); \n   out = out + ((N/i)*100); \n   break; \n  } \n \n } \n \n std::cout<<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class HelloWorld{       public static void main(String []args){            int first=0,second=0,third=0;      int N=64;      int remainder=0;           for(int i=9;i>0;i--){                    if(N%i==0){             first=i;             remainder=N/first;             break;          }                }     for(int i=first;i>0;i--){         if(remainder%i==0){             second=i;             remainder=remainder/second;             break;          }     }          for(int i=second;i>0;i--){         if(remainder%i==0){             third=i;             break;          }     }     System.out.println(\"Hello World \"+third+second+first);                         } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class HelloWorld{ \n \n     public static void main(String []args){ \n      \n     int first=0,second=0,third=0; \n     int N=64; \n     int remainder=0; \n     \n     for(int i=9;i>0;i--){ \n          \n         if(N%i==0){ \n            first=i; \n            remainder=N/first; \n            break; \n         } \n          \n     } \n    for(int i=first;i>0;i--){ \n        if(remainder%i==0){ \n            second=i; \n            remainder=remainder/second; \n            break; \n         } \n    } \n     \n    for(int i=second;i>0;i--){ \n        if(remainder%i==0){ \n            third=i; \n            break; \n         } \n    } \n    System.out.println(\"Hello World \"+third+second+first); \n     \n         \n     \n     } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def find_dig_factor(n): \n #Factors 2- 9, least number \n i, factors=9, [] \n while True: \n  if not (n%i): \n   n= n/i \n   factors.append(i)  \n  else: \n   i-=1 \n  if n is 1: \n   break \n  elif i is 1: \n   return None \n \n return int(\"\".join(map (str, reversed(factors))))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//  The program hasnt been thoroughly tested although basic cases have gone through; //  The 3 digits can only be 999 max; //  So use the biggest digit to divide the N (and its remaining) as earliest as possible to yield the possible 3 digit number as quickest as possible;  //  Once we get the 3 digits, sort them to get the smallest number. //  Time and space: O(1), very limited extra space required  //  Limitation: if the requirement is changed to 4 digits instead of 3, findNumber() needs written.   //                   The improvement for the function is to take only one digit to be sorted: findNumber(int & iN, int iTh, int &iDigit);  //                   so recursive can occur easily for any number of digits   //                  When iN = 0 or iN = 1, the function is quite clumsy although it works. //  I am sure the program can be improve a bit, but I am a bit numb at the moment.   #include  using namespace std;  const int ci999 = 729; const int ci99  = 81; const int ci9   = 9;  int findNumber(int iN, int iNumDigit, int & iFirst, int & iSecond, int & iThird) {     int iReturn = 0;        int iNumerator = 1;     if(iN == 0)     {         iReturn = iN;     }     else if(iN == 1)     {         if(iNumDigit == 3)         {             iFirst = 1;              iSecond = 1;              iThird = 1;         }         else         {             iReturn = iN;         }      }     else if(iN % 9 == 0)     {         iNumerator = 9;     }     else if(iN % 8 == 0)     {         iNumerator = 8;     }     else if(iN % 7 == 0)     {         iNumerator = 7;     }     else if(iN % 6 == 0)     {         iNumerator = 6;     }     else if(iN % 5 == 0)     {         iNumerator = 5;     }     else if(iN % 4 == 0)     {         iNumerator = 4;     }     else if(iN % 3 == 0)     {         iNumerator = 8;     }     else if(iN % 2 == 0)     {         iNumerator = 2;     }     else  // 2/3 digit prime number     {         cout << \"prime number\" << endl;         iReturn = -1;     }         if(iReturn != -1 && iReturn != -2)     {          if(iNumDigit == 3)         {             iFirst = iNumerator;             iSecond = iN/iNumerator;                    if(iSecond <= 9)             {                 iThird = iFirst;                 iFirst = 1;              }             else             {                 iReturn = findNumber((iN/iNumerator), (iNumDigit - 1), iFirst, iSecond, iThird);             }         }          else if(iNumDigit == 2)         {             iSecond = iNumerator;             iThird = iN / iNumerator;             if(iThird > 9)             {                 return -1;             }         }     }     return iReturn; }  int findMin(int & iFirst, int & iSecond, int & iThird) {     int iTmp = -1;     if(iFirst >= iSecond)     {         //  981         if(iSecond > iThird)         {             iTmp = iFirst;                 iFirst = iThird;             iThird = iTmp;         }         else   // 918         {             iTmp = iFirst;             iFirst = iSecond;             iSecond = iTmp;         }     }     // 891     if(iSecond > iThird)     {         iTmp = iSecond;         iSecond = iThird;         iThird = iTmp;      }     return 1; }  int validate(int iN, int iNumDigit) {     int iReturn = 0;     if((iN < 0)      ||((iNumDigit == 3 && iN > ci999))      ||(iNumDigit == 2 && iN > ci99)      ||(iNumDigit == 1 && iN <= ci9))     {         iReturn = -1;     }     return iReturn; }  int main() {     int iN = 11;     int iFirst = 0;     int iSecond = 0;     int iThird = 0;      if(validate(iN, 3) == 0)     {         if(findNumber(iN, 3, iFirst, iSecond, iThird) == -1)         {             cout << iN << \" doesnt have such a combination\" << endl;         }         else         {             cout << \"iN \" << iN << \" iFirst \" << iFirst << \" iSecond \" << iSecond << \" iThird \" << iThird << endl;              findMin(iFirst, iSecond, iThird);              cout << \"iN \" << iN << \" iFirst \" << iFirst << \" iSecond \" << iSecond << \" iThird \" << iThird << endl;         }     }     else    // iN is out of a valid range     {         cout << iN << \" is out side of a valid range\"  << endl;     }      return 1; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int find_min(int n) \n{ \n int i,j,k,pro=1,temp,temp2; \n for(i=1;i<10;i++) \n { \n  pro*=i; \n  for(j=0;j<10;j++) \n  { \n   temp=pro; \n   pro*=j; \n   for(k=0;k<10;k++) \n   { \n    temp2=pro; \n    pro*=k; \n    if(pro==n) \n     return (i*100+j*10+k); \n    pro=temp2; \n   } \n   pro=temp; \n  } \n  pro=1; \n } \n return -1; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int n = 100;      ArrayList a = new ArrayList();      for(int i= 1;i<10;i++)      {      if ((n%i)==0)      a.add(i);             }      System.out.println(a);      for(int i = 0;i     {       for(int j=0;j       for(int k=0;k       {         if((a.get(i)*a.get(j)*a.get(k))==n)           System.out.println(a.get(i)+\"\"+a.get(j)+\"\"+a.get(k));                   }             }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int n = 100;      ArrayList a = new ArrayList();      for(int i= 1;i<10;i++)      {      if ((n%i)==0)      a.add(i);             }      System.out.println(a);      for(int i = 0;i     {       for(int j=0;j       for(int k=0;k       {         if((a.get(i)*a.get(j)*a.get(k))==n)           System.out.println(a.get(i)+\"\"+a.get(j)+\"\"+a.get(k));                   }             }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{ int n = 100;      ArrayList a = new ArrayList();      for(int i= 1;i<10;i++)      {      if ((n%i)==0)      a.add(i);             }      System.out.println(a);      for(int i = 0;i     {       for(int j=0;j       for(int k=0;k       {         if((a.get(i)*a.get(j)*a.get(k))==n)           System.out.println(a.get(i)+\"\"+a.get(j)+\"\"+a.get(k));                   }             } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's an idea:  Initialize m to n and initialize an empty integer stack: mul. Iterate from 9 to 1 and do the following: while m divides i (i is the current iteration value) push i into the mul stack and divide m by i.  Stop each of the loops above if the number of elements in the stack is equal to 3. Notice that the mul stack will contain digits in an increasing order (from the head) whose multiplication is either n or a smaller number that divides n. The multiplication will be equal to n if and only if the variable m is equal to 1. Notice that if m is greater than 1 it means that there is no 3 digit number whose digit multiplication is equal to n (every such number has more than 3 digits).  Finally, if m is 1 then we can just return the number which is constructed from the digits in the mul stack. Another thing to note is that the case for 0 should be handled separately (return 100).  Complexity: Because we push 3 elements at most to the stack and then stop, the run-time complexity is O(1) worst case. Space complexity is O(1) as well."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import sys \n \ndef get_product_of_digits(i): \n    product = 1 \n    while(i > 0): \n        tmp = i%10 \n        product = product*tmp \n        i=i/10 \n    return product \n \ndef get_min_3_digit(givenN): \n    for i in range(100,1000): \n        if get_product_of_digits(i) == givenN: \n            return i; \n    return -1 \n \ndef main(): \n    givenN = int(sys.argv[1]) \n    if givenN < 0: \n        print(\"given < 0\") \n    else: \n        print get_min_3_digit(givenN) \n \nif __name__ == '__main__': \n    main()"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public static void findThreeDigitNumber(int num) \n { \n  int r=0; \n  if(num>=1) \n  { \n  for(int i=1;i<10;i++) \n  { \n  if(num % i==0) \n  { \n   int temp=num/i; \n   for(int j=1;j<10;j++) \n   { \n    if(temp%j==0 && temp/j<10) \n    { \n     r=(temp/j)*100+(j)*10+num/temp; \n    } \n   } \n  } \n  }} \n  System.out.println(r); \n }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5753456971218944","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"16","title":"Given a function ??f??? in which 0 occurs with probability 0.4 and 1 occurs with probability 0.6. Using function ??f??? deduce a new function ??f1??? such that both 0 and 1 occurs with probability 0.5","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"while (true) \n{ \n int c0 = 0; \n int c1 = 0; \n \n for (int i=0; i < 3; ++i) \n { \n  if (f() == 1) \n   c1++; \n } \n \n for (int i=0;i<2;i++) \n { \n  if (f() == 0) \n   c0++; \n } \n \n return (c1 > c0) ? 1 : 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can you explain your logic?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Data: P(0) = 0.4 P(1) = 0.6  Observation: P(0) * P(1) = P(1) * P(0) = 0.4 * 0.6 = 0.6 * 0.4 The probability of generating pairs (0, 1) and (1, 0) is equal.   Solution: Generate the pair of numbers: a) num1 = f(); b) num2 = f(); Keep generating num2 till num1 == num2. Once you generated two different numbers return num1. Hence P(1) = P(0) = 0.5  Code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This problem could be regarded as fair coin and biased coin problem, please refer to: wiki- fair coin problem"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This problem could be regarded as fair coin and biased coin problem, please refer to: wiki- fair coin problem"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"fdsdfssdf"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"f1(): \nif [f() + {1 - f()}] == 2: \n return 1 \nelse \n return 0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"f1(x) = f(x) + (-1)^x * 0.1"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5394117727092736","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"14","title":"Subset Sum Given a target value and a list of numbers to pick from, pick numbers from the list such that the numbers picked add up to the target value. For example, if given a target value of 150 and a list of numbers to pick from consisting of 1, 2, 100, 22 and 28, the correct answer would be 100, 22 and 28 because 100 + 22 + 28 =150. If given a target value of 30 and the sample numbers to pick from were 1, 2, 100, 22 and 28, the correct answer would be 28 and 2 because 28 + 2 = 30. NOTE: Once you use a number from the list you cannot pick it again. NOTE: If no combination of numbers adds up to the requested value, the correct answer is \"No combination matches\". NOTE: There can be more than one correct answer. For example, for target value 3 and list 1, 2 and 3 the correct answer would be either: 1, 2 or 3. You only need to return 1 correct answer not all of them. Write a program that takes a list of numbers from the command line. The first number is the target value and the reminder of the numbers (however many there may be) is the set of numbers you have to pick from. The program should either output a subset whose sum equals the target or \"No combination matches\" if no such subset exists. We would prefer you use Java or C# on this program, but you can use another procedural language if you don't know Java or C#. For example, the following inputs should yield the following results: SubsetSum 15 1 2 3 5 7 10 {3,7,5} SubsetSum 9 1 2 3 5 7 10 {2,7} SubsetSum 100 1 2 3 5 7 10 No combination matches","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public class Solution { \n \n public static boolean isSubsetSum(int set[], int n, int sum) \n { \n     // The value of subset[i][j] will be true if there is a subset of set[0..j-1] \n     //  with sum equal to i \n     boolean[][] subset = new boolean[sum+1][n+1]; \n   \n     // If sum is 0, then answer is true \n     for (int i = 0; i <= n; i++) \n       subset[0][i] = true; \n   \n     // If sum is not 0 and set is empty, then answer is false \n     for (int i = 1; i <= sum; i++) \n       subset[i][0] = false; \n   \n      // Fill the subset table in botton up manner \n      for (int i = 1; i <= sum; i++) \n      { \n        for (int j = 1; j <= n; j++) \n        { \n          subset[i][j] = subset[i][j-1]; \n          if (i >= set[j-1]) \n            subset[i][j] = subset[i][j] || subset[i - set[j-1]][j-1]; \n        } \n      } \n      boolean found = subset[sum][n]; \n \n      // printing values found \n      if (found) { \n    for (int i = sum; i > 0; i--) { \n     for (int j = n; j > 0; j--) { \n      while (subset[i][j] == false) { \n       if (i >= set[j]) { \n        i = i - set[j]; \n        System.out.println(\"[\" + i + \",\" + j + \"]\" + \"--->\" \n          + set[j]); \n       } \n       while (i > 0 && j > 0 && subset[i][j] != false) { \n        j--; \n       } \n      } \n     } \n    } \n      } \n  \n      return found; \n } \n  \n public static void printSubsetSum(int[] set, int sum) { \n  int n = set.length; \n    if (isSubsetSum(set, n, sum) == true) { \n        System.out.println(\"Found SubsetSum\"); \n     } \n     else { \n      System.out.println(\"No combination matches\"); \n     } \n \n } \n  \n public static void main(String args[]) { \n  int set[] = {1, 2, 3, 5, 7, 10};   \n  int sum = 15; \n  printSubsetSum(set, sum); \n     \n  int set2[] = {1, 2, 3, 5, 7, 10};   \n  int sum2 = 9; \n  printSubsetSum(set2, sum2); \n \n  int set3[] = {1, 2, 3, 5, 7, 10};   \n  int sum3 = 100; \n  printSubsetSum(set3, sum3); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"DP solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A brutal method:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Minor change to return only one matching subset:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Would this be the equivalent of using Combinatorics to find all combinations of the values in the input array and for each resulting set, try and sum it up to the target value in O(2^n) time?  Haven't tried this yet, but this is the first thing that comes to mind."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This sorts the numbers from highest to smallest, and then starts with the highest number, adding it to the next consecutively until it reaches the target or higher. In the case it's higher, it skips that number and moves on. Doing this for every possible set starting with the highest number. If it can't find a solution with the highest number, it then moves to the next highest and repeats. By starting with the highest number, often the answer if found fairly quickly. Sort of like making change for a purchase - you start with quarters if possible and then move to dimes, nickles, pennies, etc.  Downside: I made my own LinkedList which may not have been necessary but it works."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class Program \n    { \n        static void Main(string[] args) \n        { \n            int[] subset = { 1, 2, 3, 5, 7, 10, 90 }; \n            Console.WriteLine(\"Beginning 15 : \"); \n            int sum = 15; \n            HashSet resultSet = SubsetSumFn(subset, sum); \n            foreach (int i in resultSet) \n                Console.WriteLine(i); \n            Console.WriteLine(\"Beginning 9 : \"); \n            sum = 9; \n            resultSet = SubsetSumFn(subset, sum); \n            foreach (int i in resultSet) \n                Console.WriteLine(i); \n            Console.WriteLine(\"Beginning 100 : \"); \n            sum = 100; \n            resultSet = SubsetSumFn(subset, sum); \n            foreach (int i in resultSet) \n                Console.WriteLine(i); \n \n            Console.ReadLine(); \n        } \n \n        private static HashSet SubsetSumFn(int[] subset, int sum) \n        { \n            HashSet resultSet = new HashSet(); \n            int setSummetion = subset.Sum(p => p); \n            //Check whether the summetion is less than the subset summetion \n            if (setSummetion < sum) \n                return resultSet; \n            else if (setSummetion == sum) \n            { \n                for (int i = 0; i < subset.Length; i++) \n                { \n                    resultSet.Add(subset[i]); \n                } \n                return resultSet; \n            } \n            else if (subset.Contains(sum)) \n            { \n                resultSet.Add(sum); \n                return resultSet; \n            } \n            int differenceBetweenSetSummetionAndSum = setSummetion - sum; \n            List neglectedIndices = new List(); \n            //Make nested loops using recursion \n            for (int i = 2; i < subset.Length; i++) \n            { \n                neglectedIndices = FindNumber(differenceBetweenSetSummetionAndSum, i, subset, 0, neglectedIndices); \n                foreach (int idx in neglectedIndices) \n                    Console.WriteLine(\"neglect index : \" + idx + \" with value : \" + subset[idx]); \n                if (neglectedIndices.Count > 0) \n                    break; \n            } \n            if (neglectedIndices != null && neglectedIndices.Count > 0) \n            { \n                for (int i = 0; i < subset.Length; i++) \n                { \n                    if (!neglectedIndices.Contains(i)) \n                        resultSet.Add(subset[i]); \n                } \n            } \n            return resultSet; \n        } \n \n        private static List FindNumber(int differenceBetweenSetSummetionAndSum, int forsNumber, int[] subset, int accumlation, List neglectedIndices) \n        { \n            for (int i = 0; i < subset.Length; i++) \n            { \n                if (neglectedIndices.Contains(i)) \n                    continue; \n \n                if (forsNumber > 1) \n                { \n                    FindNumber(differenceBetweenSetSummetionAndSum, forsNumber - 1, subset, subset[i] + accumlation, neglectedIndices); \n                    if (neglectedIndices.Count == 0) \n                        continue; \n                    else \n                    { \n                        neglectedIndices.Add(i); \n                        return neglectedIndices; \n                    } \n                } \n                if (accumlation + subset[i] == differenceBetweenSetSummetionAndSum) \n                { \n                    neglectedIndices.Add(i); \n                    break; \n                } \n                else \n                { \n                    continue; \n                } \n            } \n            return neglectedIndices; \n        } \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I believe my answer is not acceptable...    But I least I came up with something that works ok.  I will spend more time to get a better answer ( without peeking! I really will do it on my own )"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"An easy solution: have all set and their sum. The find out which is equal to the sum"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5466631807434752","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"write test cases for a game on pc and mobile device and you can play that game on pc and pause it on pc and again resume this game on mobile.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Questions to interviewer: 1.Where is the game hosted 2.What type of game is it (Ex: Role playing, Arcade, Strategy, Kids etc) 3.What the the supported platforms (PC and mobile are mentioned, but need specifics like is it supported on Andriod, iOS, windows, linux etc) 4.Can it be played offline? 5.What modes do you have single user,  multi user ? 6.How does the user get authenticated in case of multi user, does it work integrate with game center, google play or does the game have custom server and authentication? 7.Need more specifics about how many devices can the user stop/resume the game 8.In case of mobile what happens to the game if the user gets a call 9.What type of test cases are needed ? (Sanity, Install rollback, Functional, Performance, Usability) 10. Are there in-game purchases?  High level test scenarios:  1. Test the downloads 2. Validate prerequisites like space, cpu, memory, OS, architecture, GPU etc 3. Install / Rollback tests 4. Functionality tests like the game should be working as per reqmt specs  a) Validate game play  b) In-game help  c) In-game tutorial  d) Does the game exit cleanly  e) Validate if the game is able to identify the device it is executing on and is able to relay the relevant info to server. 5. Performance  a) Response times  b) Measure and reportthe load the game poses to the system (CPU, RAM, HDD, GPU) 6.Help guides and support docs need to be validated for errors"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5698327039442944","download_status":"DOWNLOAD_DONE","votes":"-2","answersCount":"12","title":"How to design an elevator system. Main thing to worry about is how would you notify the elevator that it needs to move up or down. and also if you are going to have a centralized class to control this behavior and how could you distribute the control.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Elevator \n        private int weightApplied \n        private int passengerNumber; \n        private String elevatorID; \n        private int floorNumber \n        private int capacity \n        private boolean started \n        private String direction \n        private String state \n        private boolean goingUp \n        private boolean doorsOpen \n        private PriorityQueue pq//PQ that gives priority to different floors based on floorNumber, non-preemptive priority scheduling \n \n        void go_up(int floorNumber); \n        void go_down(int floorNumber); \n        boolean isStarted(boolean start); \n        boolean setStarted(boolean start); \n        void load_passengers(); \n        void unload_passengers(); \n        etc... \n        getters and setters for all instance variables... \n    Passenger extends Elevator \n        private int destinationFloor; \n \n        int current_destination(int destinationFloor)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"*repose with format corrected* \n \npublic class Elevator { \n  \n public static final int MAX_FLOORS = 50; \n  \n // upward floor queue \n private PriorityQueue floors_up = new PriorityQueue(MAX_FLOORS); \n  \n // downward floor queue \n private PriorityQueue floors_down = new PriorityQueue(MAX_FLOORS, new Comparator(){ \n  public int compare(Integer arg0, Integer arg1) { \n   return arg1.compareTo(arg0); \n  } \n }); \n  \n // effective floor queue \n private PriorityQueue floors = floors_up; \n  \n // current floor \n private int current = 0; \n \n public void userCallAt(int where) { \n  setTarget(where); \n } \n  \n public void setTarget(int target) { \n   \n  // ignore if target is current \n  if (target == current) { \n   return; \n  } \n   \n  // add target to right queue \n  if (floors == floors_up) { \n   if (target < current) { \n    floors_down.offer(target); \n   } else { \n    floors_up.offer(target); \n   } \n  } else { \n   if (target > current) { \n    floors_up.offer(target); \n   } else { \n    floors_down.offer(target); \n   } \n  } \n   \n  // swap queue to turn around the elevator \n  if (floors.isEmpty()) { \n   floors = (floors == floors_up ? floors_down : floors_up); \n  } \n } \n  \n public int getTarget() { \n   \n  if (!floors.isEmpty()) { \n   return floors.peek(); \n  } \n   \n  if (floors_up.isEmpty() && floors_down.isEmpty()) { \n   return current; \n  } \n   \n  floors = (floors == floors_up ? floors_down : floors_up); \n  return floors.peek(); \n } \n  \n public int getCurrent() { \n  return current; \n } \n  \n public void step(int target) { \n  if (target > current) { \n   current++; \n  } else { \n   current--; \n  } \n } \n  \n public void stop() { \n  floors.poll(); \n } \n  \n public void move() { \n   \n  while (getCurrent() != getTarget()) { \n   do { \n    step(getTarget()); \n   } while (getCurrent() != getTarget()); \n   stop(); \n  } \n   \n } \n  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think we dont need so much variables and methods ... as per my approach  we need   enum Motion {  Going_Up, Going_Down, Stoped }  Class Lift {  int current Floor;  int priorityQueue nextFloorToStop;  int LiftId; }  Class LiftController {  array of lifts;  queue Allrequests;   public void CallLift(int floorIndex)  {   }   public void int NearestLift(int floorIndex)  {   }   public void bool IsMovingInSameDirection(int liftId, int FloorIndex)  {   } }  If No lift is available to take request then add that request in AllRequest queue else add it in lift's queue. When when lift comes to stop (after completing its all floor stops) then it will notify controller class to  check if there is any request pending in \"allRequest Queue\"."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Elevator {    public static final int MAX_FLOORS = 50;    // upward floor queue  private PriorityQueue floors_up = new PriorityQueue(MAX_FLOORS);    // downward floor queue  private PriorityQueue floors_down = new PriorityQueue(MAX_FLOORS, new Comparator(){   public int compare(Integer arg0, Integer arg1) {    return arg1.compareTo(arg0);   }  });    // effective floor queue  private PriorityQueue floors = floors_up;    // current floor  private int current = 0;   public void userCallAt(int where) {   setTarget(where);  }    public void setTarget(int target) {      // ignore if target is current   if (target == current) {    return;   }      // add target to right queue   if (floors == floors_up) {    if (target < current) {     floors_down.offer(target);    } else {     floors_up.offer(target);    }   } else {    if (target > current) {     floors_up.offer(target);    } else {     floors_down.offer(target);    }   }      // swap queue to turn around the elevator   if (floors.isEmpty()) {    floors = (floors == floors_up ? floors_down : floors_up);   }  }    public int getTarget() {      if (!floors.isEmpty()) {    return floors.peek();   }      if (floors_up.isEmpty() && floors_down.isEmpty()) {    return current;   }      floors = (floors == floors_up ? floors_down : floors_up);   return floors.peek();  }    public int getCurrent() {   return current;  }    public void step(int target) {   if (target > current) {    current++;   } else {    current--;   }  }    public void stop() {   floors.poll();  }    public void move() {      while (getCurrent() != getTarget()) {    do {     step(getTarget());    } while (getCurrent() != getTarget());    stop();   }     }   }  *code for demo idea*"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6206431334236160","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"3","title":"write test area and test case for a pen drive","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Note : Here i am assuming the generic functionalities of pen drive, but it would be good if yiu can clarify the functionalities from the interviewer before writing test cases.  Test Case1: Objective : To test the drivers functionality of the pendrive. Steps: 1.Connect the pendrive to the system. 2.Check the connected device info (In case of windows open the my computer or device manager, but in case of linux check /media folder)  Exp result : Pendrive must be visible in the devices info.  Test Case 2: Objective : To test the copy functionality of the pendrive. Assumption: test folder is present in the computer and it's size is below the maximum memory size of the pendrive. Steps: 1. Connect the pendrive to the system. 2. Open the pendrive. copy test folder from system to pendrive. 4. Open the pendrive check the folders present in the pendrive. 5. Remove the pendrive from computer 6. Now again connect the pendrive to the system and check the files present in pendrive.  Exp result : After Step 3, Step 6 test folder must present in the Pendrive.  Test Case3: Objective : To test the maximum allowed memory functionality of the pendrive. Assumption:  1. test1 folder is present in the computer and it's size is exactly equal to the maximum allowed size of the pendrive. 2. test2 folder is present in the computer and it's size is exactly equal to the maximum allowed size of the pendrive.  Steps: 1. Connect the pendrive to the system. 2. Open the pendrive. copy test1 folder from system to pendrive. 3. Now copy test2 folder from system to pendrive. 4. Remove the pendrive from computer 5. Now again connect the pendrive to the system and check the files present in pendrive.  Exp result : After Step 3 user must get some error message like ??No more space???. After Step 5 test1 folder must be present in the pendrive and test2 folder must not be present in the pendrive.   Test Case 4: Objective : To test the parallel copy functionality of the pendrive Assumption:  test1,test2 folders are present in the computer and their total size are below the maximum allowed memory size of the pendrive.  Steps: 1. Connect the pendrive to the system. 2. Open the pendrive. copy test1 folder from system to pendrive. 3. While test1 folder is copying now in parallel copy test2 folder from system to pendrive. 4. Remove the pendrive from computer 5. Now again connect the pendrive to the system and check the files present in pendrive.  Exp result : After Step 5 both test1 and test2 folders must be present in the pendrive.  Test Case 5: Objective : To test the copy functionality of pendrive in case of device interuption. Assumption:  1.test1 folder is present in the computer and it's size is exactly equal to the maximum allowed size of the pendrive.  2.test1 folder contain 5 files namely file1, file2, file3, file4, file5.  Steps: 1. Connect the pendrive to the system. 2. Open the pendrive. copy test1 folder from system to pendrive, once after completion of file 3 copy forcefully disconnect the pendrive from system. 4. Remove the pendrive from computer 5. Now again connect the pendrive to the system and check the files present in pendrive.  Exp result : After Step 5 test1 folder must be present in the pendrive and it must contain file1, file2, file3 files.  I have covered very few test cases, similarly we can extend the idea of writing cases for other functionality. Suggestions are highly appreciated."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Similarly we can test for format functionality, copying files from pendrive to system etc."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Questions to the interviewer 1. Is the pen drive USB 2.0 or 3.0 compatible 2. Size (storage) of the pen drive 3. Does it have an LED indicator 4. What are the other features available? 5. MTBF  I can think of some more cases. Performance: 1. Validate the read throughput as per spec  2. Validate the write throughput as per spec 3. Repeat 1 and 2 for various file sizes and measure the numbers 4. Check the durability of the pen drive.  Cosmetics and conformance: 1. Validate if the size of the pen drive is as per reqmt spec 2. Validate if the shape of the pen drive is as per reqmt spec 3. Validate if the logo, model numbers of the pen drive is mentioned as per reqmt spec  Functionality: 1. Validate on all possible OSes 2.On older OSes like windows 98, pen drive needs driver to be installed, check if proper drivers are available for it and there needs to be validation done for them as well. 3. Validate if the pen drive works on (non computer) devices like TVs, Music systems etc (This is a nice to have test, as long as the pen drive is USB complaint we need not get to greater details)  Help and Support: 1. The pen drive should have proper help and support docs, these docs are needing to be validated for correctness  Durability: 1. The pen drive needs to be tested for durability like drop tests"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6236375846223872","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"13","title":"find whether a  number is palindrome or not if number is not palindrome ( i.e 112 ) make it in a palindrome form and check if it is palindrome or not. Example -  121 this is a palindrome number but 112 is not palindrome so make it 121 and check.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"The logic to check a palindrome is easy and not included here.  Case 1: the digits in the number are capable of forming a palindrome number 1) capture frequencies of each digits in an array 2) all frequencies will be even or there will be only 1 digit with odd frequency 3) In case of former append a string of half the frequency of a digit to the output string e.g. '22'+outputString+'22' 4) In case of latter make the odd frequency digit as the central digit in the output string. Now repeat the above step for the rest of the digits.  Case2: In case the digits in the number are not capable of forming a palindrome number and we have to creating the palindrome by adding/removing min number of digits 1) Same as above case 2) To identify case 2 the logic is that if there are more than 1 digit with odd frequency then it cannot be converted into a palindrome. 3) add/remove digits to make all frequencies even except 1 4) repeat steps of case 1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Not sure if you can use Java APIs, but here is the most elegant solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static bool IsNumberPalin(int number) \n        { \n            int msbdiv = 10; // find highest power of 10 that is smaller than number \n            while (number / msbdiv != 0) \n            { \n                msbdiv *= 10; \n            } \n \n            msbdiv /= 10; \n \n            while (number >= 10) \n            { \n                // find msb and lsb \n                int msb = number / msbdiv; \n                int lsb = number % 10; \n \n                if (msb != lsb) return false; \n                 \n                // shrink the number by removing msb and lsb. \n                number = number % msbdiv; // remove msb \n                number /= 10;             // remove lsb \n \n                // update msb, since number is 2 digit smaller. \n                msbdiv /= 100; \n            } \n            return true; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Converting to strings, and solving for a palindrome probably won't impress the interviewer, although you can mention it.  There is a way to reverse a number and then compare it against the original, but you can face overflow problems.  A more clever way to do this is you need to check if the left most digit is the same as the right most digit, strip them both and repeat while the number != 0."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static bool IsPalindrome(int n) \n        { \n            while (n > 0) \n            { \n                // last digit \n                var l = n % 10; \n \n                // first digit calculation by dividing to closest power of 10 \n                var powerOf10 = 1; \n                while (n / powerOf10 > 10) \n                { \n                    powerOf10 *= 10; \n                } \n \n                var m = n / powerOf10; \n \n                if (l != m) \n                { \n                    return false; \n                } \n \n                // cut first and last digits \n                n = (n % powerOf10) / 10; \n            } \n \n            return true; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For Korser code, a small correction:  while (n / powerOf10 > 10)   >>>>>> while (n / powerOf10 >= 10)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.io.BufferedReader; \nimport java.io.IOException; \nimport java.io.InputStreamReader; \n \npublic class CheckPalindrome { \n \n public static void main(String[] args) throws IOException { \n  BufferedReader obj = new BufferedReader(new InputStreamReader(System.in)); \n  System.out.println(\"Enter the number\"); \n  int input1 = Integer.parseInt(obj.readLine()); \n  boolean isPalindrome = checkPalindrome(input1); \n  if (isPalindrome) { \n   System.out.println(\"The input is Palindrome\"); \n  } else { \n   boolean isPalindromePossible = checkifPalindromePossible(input1); \n   if(!isPalindromePossible) \n   { \n    System.out.println(\"Palindrome number not possible\"); \n   } \n  } \n } \n \n private static boolean checkifPalindromePossible(int number) { \n  int digitsCount[] = new int[10]; \n  int remainder = 0, numberOfDigitsWithOddCount = 0, inputLength = 0,temp=number; \n  while (number > 0) { \n   remainder = number % 10; \n   digitsCount[remainder]++; \n   number /= 10; \n   inputLength++; \n  } \n  for (int i = 0; i < 10; i++) { \n   if (digitsCount[i] % 2 == 1) { \n    numberOfDigitsWithOddCount++; \n   } \n  } \n  if (numberOfDigitsWithOddCount > 1) \n   return false; \n  else { \n   char[] characterArray=new char[inputLength]; \n   int charPlace = 0; \n   for (int i = 0; i < 10; i++) { \n    if (digitsCount[i] % 2 == 0 && digitsCount[i] > 0) { \n     characterArray[charPlace]=  (char) ('0' + i); \n     characterArray[inputLength - charPlace-1]=(char) ('0' + i); \n     charPlace++; \n    } else if (digitsCount[i] % 2 == 1) { \n     characterArray[(int) Math.ceil(inputLength / 2)]=(char) ('0' + i); \n    } \n     \n   } \n   System.out.println(String.valueOf(characterArray)); \n   return true; \n  } \n } \n \n private static boolean checkPalindrome(int input1) { \n  int temp = input1, rem = 0, temp2 = 0; \n  while (temp > 0) { \n   rem = temp % 10; \n   temp2 = temp2 * 10 + rem; \n   temp /= 10; \n  } \n  if (input1 == temp2) \n   return true; \n  return false; \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@martin1990: Could you please explain the algorithm of your code. I do not seem to understand \"digitsCount[remainder]++;\"  Question to interviewer: How are you supposed to make the given number a palindrome? Can we remove digits? or alter their positions to make it a palindrome?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5130214535331840","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"13","title":"Given a binary search tree of n nodes, find all the pair of  nodes whose sum is equal to a given number k in O(n) time and constant space.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"They only way to do this in O(n) with O(1) space is to solve the next inorder traversal and the reverse inorder traversal.  One is the inverse of the other.  Because the BST is already sorted, you start the algo off with the left most child and the right most child and see if they sum up to the value.  If they sum up, find next inorder of left, and reverse inorder of right.  If sum is less then sum, advance left and advance right if it's greater than sum.  Do this until left node data  is greater than right node data.  Voila!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Inorder and Reverse Inorder simultaneously. Reference: hxxp://geeksforgeeks.org/find-a-pair-with-given-sum-in-bst/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void findPairs(TreeNode root, int target)  {   dfs(root);   while(head!=tail && tail.right!=head)   {    if(head.val + tail.val == target)    {     System.out.println(\"[\" + head.val + \",\" + tail.val + \"]\");     head = head.right;     tail = tail.left;    }    else if(head.val + tail.val > target)    {     tail = tail.left;    }    else head = head.right;   }  }    private void dfs(TreeNode root)  {   if(root == null) return;   dfs(root.left);   if(pre!=null)   {    pre.right = root;    root.left = pre;   }   else   {    head = root;   }   pre = root;   tail = root;   dfs(root.right);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The definition is vague, if by pairs it means connected nodes then it's simple dfs. If not then the only solution I can think of is to use a HashSet and then traverse which is O(n) for both time and space"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming parent nodes are available, implement successor and predecessor, and do something similar to the sorted array solution of two pointers, decrementing one (predecessor) and incrementing the other (successor).  This will be O(n) time and O(1) space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Convert the tree to sorted doubly linked list. Then follow the same procedure as in case of array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"an implementation based on comment of Nascent:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6274606423867392","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"9","title":"You are given a n-ary tree. print all the nodes bottom up except for the right most node at each level.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simply.pass a flag to the recursive function mentioning whether or not it is the rightmost node. By definition, root is also the rightmost(as well as the leftmost node) and hence, technically it should not get printed. If the interviewer wants so, we can make an exception to this, by exploiting the fact that root node can always be known.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"do BSF, for each level create a linked list and put it in a stack,   then for each element on the stack print out the list, when printing check if next. next == null, if so, terminate the print loop  time complexity = time to build the stack of linked lists + time to pop lists and print them out   time complexity = traverse time + time to pop lists and print them out   traverse time = O(N)  time to pop lists and print them out  = O(N)  time complexity = 2 * O(N) = O(N)  space complexity = O(N)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If N is huge and the depth of the tree is K, such that K nodes can fit in memory but N nodes can not than the above solution will not work. Also note, that time complexity O(N) with space complexity O(N) gives you a total complexity of O(N^2). traversing the tree K times, each time printing a single depth, is much simpler. this is easy to do with a time complexity of O(K*N) and a space complexity of O(K) holding only 1 brunch at a time (printing when finding the next node). this gives a total complexity of O(K^2*N)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.*; \n \npublic class Solution { \n \nclass Node { \n \n    private Node parent; \n    private List childs; \n    private Character data; \n     \n    public Character getData() { \n     return data; \n    } \n     \n    public Node getParent() { \n    return parent; \n    } \n       public void setData(Character d) { \n        this.data = d; \n    } \n    public void setParent(Node parent) { \n        this.parent = parent; \n    } \n    public List getChilds() { \n        return childs; \n    } \n \n public void addChild(Node child) { \n     if(childs == null) { \n         childs = new ArrayList(); \n     } \n     childs.add(child); \n } \n} \n \nclass LevelMapHandler { \n \n    Map> levelMap; \n     \n    public void addNodeToLevel(int level, Node node) { \n     \n        if (levelMap == null) { \n            levelMap = new HashMap>(); \n        } \n         \n        List nodesAtLevel = levelMap.get(level); \n         \n        if (nodesAtLevel == null) { \n        nodesAtLevel = new ArrayList(); \n        } \n         \n        if (nodesAtLevel.contains(node)) { \n            System.out.println(\"error : node \" + node.getData() + \" already in List of level \" + level); \n        } \n        nodesAtLevel.add(node); \n         \n        levelMap.put(level, nodesAtLevel ); \n     \n    } \n    public Map> getLevelMap(){ \n    return levelMap; \n    } \n} \n \n/* \n1 \n     2           3         4 \na   b           c         d e \n*/ \npublic Node buildTestTree() { \n \nNode root = new Node(); \nroot.setParent(null); \nroot.setData('1'); \n \nNode n2 = new Node(); \nn2.setParent(root); \nn2.setData('2'); \n \nNode n3 = new Node(); \nn3.setParent(root); \nn3.setData('3'); \n \nNode n4 = new Node(); \nn4.setParent(root); \nn4.setData('4'); \n \nroot.addChild(n2); \nroot.addChild(n3); \nroot.addChild(n4); \n \nNode na = new Node(); \nna.setParent(n2); \nna.setData('a'); \n \nNode nb = new Node(); \nnb.setParent(n2); \nnb.setData('b'); \n \nn2.addChild(na); \nn2.addChild(nb); \n \nNode nc = new Node(); \nnc.setParent(n3); \nnc.setData('c'); \n \nn3.addChild(nc); \n \nNode nd = new Node(); \nnd.setParent(n4); \nnd.setData('d'); \n \nNode ne = new Node(); \nne.setParent(ne); \nne.setData('e'); \n \nn4.addChild(nd); \nn4.addChild(ne); \n \nreturn root; \n} \n \npublic void loadLevelMap(Node root, int level, LevelMapHandler levelMapHandler) { \n \n    if (root == null) return; \n     \n    // print root ? \n    if (root.getData() != null) { \n       levelMapHandler.addNodeToLevel(level, root); \n    } \n     \n    if (root.getChilds() != null && !root.getChilds().isEmpty()) { \n        for (Node child : root.getChilds()) { \n            loadLevelMap(child, level + 1, levelMapHandler); \n        } \n    } \n     \n} \n \npublic void printAllExceptRightMost(Map> mapLevel) { \n for (Map.Entry> entry : mapLevel.entrySet()) \n { \n     List nodeList = entry.getValue(); \n     Integer level = entry.getKey();    \n     int n = nodeList.size(); \n      \n     for (int i = 0; i < n-1; i++) { \n         Node node = nodeList.get(i); \n         System.out.println(level + \" - \" + node.getData()); \n     } \n } \n} \n \npublic void execute() { \n     Node root = buildTestTree(); \n     LevelMapHandler levelMapHandler = new LevelMapHandler(); \n     loadLevelMap(root, 0, levelMapHandler); \n     printAllExceptRightMost(levelMapHandler.getLevelMap()); \n} \n \npublic static void main(String[] args) { \n Solution sol = new Solution(); \n sol.execute();   \n} \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.*; \n \npublic class Solution { \n \nclass Node { \n \n    private Node parent; \n    private List childs; \n    private Character data; \n     \n    public Character getData() { \n     return data; \n    } \n     \n    public Node getParent() { \n    return parent; \n    } \n       public void setData(Character d) { \n        this.data = d; \n    } \n    public void setParent(Node parent) { \n        this.parent = parent; \n    } \n    public List getChilds() { \n        return childs; \n    } \n \n public void addChild(Node child) { \n     if(childs == null) { \n         childs = new ArrayList(); \n     } \n     childs.add(child); \n } \n} \n \nclass LevelMapHandler { \n \n    Map> levelMap; \n     \n    public void addNodeToLevel(int level, Node node) { \n     \n        if (levelMap == null) { \n            levelMap = new HashMap>(); \n        } \n         \n        List nodesAtLevel = levelMap.get(level); \n         \n        if (nodesAtLevel == null) { \n        nodesAtLevel = new ArrayList(); \n        } \n         \n        if (nodesAtLevel.contains(node)) { \n            System.out.println(\"error : node \" + node.getData() + \" already in List of level \" + level); \n        } \n        nodesAtLevel.add(node); \n         \n        levelMap.put(level, nodesAtLevel ); \n     \n    } \n    public Map> getLevelMap(){ \n    return levelMap; \n    } \n} \n \n/* \n1 \n     2           3         4 \na   b           c         d e \n*/ \npublic Node buildTestTree() { \n \nNode root = new Node(); \nroot.setParent(null); \nroot.setData('1'); \n \nNode n2 = new Node(); \nn2.setParent(root); \nn2.setData('2'); \n \nNode n3 = new Node(); \nn3.setParent(root); \nn3.setData('3'); \n \nNode n4 = new Node(); \nn4.setParent(root); \nn4.setData('4'); \n \nroot.addChild(n2); \nroot.addChild(n3); \nroot.addChild(n4); \n \nNode na = new Node(); \nna.setParent(n2); \nna.setData('a'); \n \nNode nb = new Node(); \nnb.setParent(n2); \nnb.setData('b'); \n \nn2.addChild(na); \nn2.addChild(nb); \n \nNode nc = new Node(); \nnc.setParent(n3); \nnc.setData('c'); \n \nn3.addChild(nc); \n \nNode nd = new Node(); \nnd.setParent(n4); \nnd.setData('d'); \n \nNode ne = new Node(); \nne.setParent(ne); \nne.setData('e'); \n \nn4.addChild(nd); \nn4.addChild(ne); \n \nreturn root; \n} \n \npublic void loadLevelMap(Node root, int level, LevelMapHandler levelMapHandler) { \n \n    if (root == null) return; \n     \n    // print root ? \n    if (root.getData() != null) { \n       levelMapHandler.addNodeToLevel(level, root); \n    } \n     \n    if (root.getChilds() != null && !root.getChilds().isEmpty()) { \n        for (Node child : root.getChilds()) { \n            loadLevelMap(child, level + 1, levelMapHandler); \n        } \n    } \n     \n} \n \npublic void printAllExceptRightMost(Map> mapLevel) { \n for (Map.Entry> entry : mapLevel.entrySet()) \n { \n     List nodeList = entry.getValue(); \n     Integer level = entry.getKey();    \n     int n = nodeList.size(); \n      \n     for (int i = 0; i < n-1; i++) { \n         Node node = nodeList.get(i); \n         System.out.println(level + \" - \" + node.getData()); \n     } \n } \n} \n \npublic void execute() { \n     Node root = buildTestTree(); \n     LevelMapHandler levelMapHandler = new LevelMapHandler(); \n     loadLevelMap(root, 0, levelMapHandler); \n     printAllExceptRightMost(levelMapHandler.getLevelMap()); \n} \n \npublic static void main(String[] args) { \n Solution sol = new Solution(); \n sol.execute();   \n} \n \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5115222951985152","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"10","title":"You are given an unsorted integer array consisting of 1's and 0's. You need to rearrange the array with alternating groups of 0's and 1's. The group length is determined by the function f(x)  f(0) = 1 f(1) = 2 f(n) = [square of f(n-1) - square of f(n-2)]  if you run out of either 1's or 0's, then fill the array with whatever is left.  input: 0,0,1,0,1,1,1,0,0,1,0,0,1,1,0,0  output: 0, 1,1, 0,0,0, 1,1,1,1,1, 0,0,0,0,0  f(1) = 1 f(2) = 2 f(3) = sqr(f(2)) - sqr(f(1)) = 3 f(4) = sqr(f(3)) - sqr(f(2)) = 5 f(5) = sqr(f(4)) - sqr(f(3)) = 16  here we don't have enough 0's left to fill the last group. So, we add the five 0's that were left.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int main(int argc, char** argv) \n{ \n    int d; \n    int zeros = 0; \n    int ones = 0; \n \n    while (cin >> d) { \n        if (d == 0) \n            zeros++; \n        else if (d == 1) \n            ones++; \n        else { \n            cout << \"bad number\"; \n            return -1; \n        } \n    } \n \n    int fprev = 1; \n    int f = 2; \n \n    for (int i = 0; zeros && i < fprev; i++, zeros--) { \n        cout << \"0 \"; \n    } \n \n    int flag = 1; \n    while (zeros || ones) { \n        if (flag == 1)  { \n            flag = 0; \n \n            for (int i = 0; ones && i < f; i++, ones--)   \n                cout << \"1 \"; \n        } \n        else  { \n            flag = 1; \n            for (int i = 0; zeros && i < f; i++, zeros--) \n                cout << \"0 \"; \n        } \n        int t = f * f - fprev * fprev; \n        fprev = f; \n        f = t; \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static int[] AlternatingArray(int[] input) \n        { \n            int[] output = new int[input.Length]; \n \n            int ones = 0, zeros = 0; \n \n            for(int i = 0; i < input.Length; ++i) \n            { \n                if (input[i] == 0) \n                    zeros++; \n                else if (input[i] == 1) \n                    ones++; \n                else \n                    throw new Exception(\"Only accepting 1s and 0s\"); \n            } \n \n            if(zeros == 0 || ones == 0) \n            { \n                Array.Copy(input, output, input.Length); \n                return output; \n            } \n \n            int k = 0; \n            int n = 2; \n            int num = 0; \n             \n            output[k++] = 0; \n            zeros--; \n \n            bool IsZeroGroup = false; \n \n            while(true) \n            { \n                if ((ones + zeros) == 0) \n                    return output; \n                num = get_f(n++); \n                if(IsZeroGroup) \n                { \n                    if(num <= zeros) \n                    { \n                        zeros -= num; \n                        for(int j = 0; j < num; j++) \n                        { \n                            output[k] = 0; \n                            k++; \n                        } \n                        IsZeroGroup = false; \n                    } \n                    else \n                    { \n                        for(int j = 0; j < ones; j++) \n                        { \n                            output[k] = 1; \n                            k++; \n                        } \n                        return output; \n                    } \n                } \n                else \n                { \n                    if(num <= ones) \n                    { \n                        ones -= num; \n                        for(int j = 0; j < num; j++) \n                        { \n                            output[k] = 1; \n                            k++; \n                        } \n                        IsZeroGroup = true; \n                    } \n                    else \n                    { \n                        for(int j = 0; j < zeros; j++) \n                        { \n                            output[k] = 0; \n                            k++; \n                        } \n                        return output; \n                    } \n                } \n            } \n        } \n \n        static int get_f(int n) \n        { \n            if (n <= 1) \n                return 1; \n            else if (n == 2) \n                return 2; \n            else \n                return (get_f(n - 1) * get_f(n-1)) - (get_f(n - 2) * get_f(n - 2));"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Easy one.  Sort the input array on the lines of  'Dutch National Flag'  sorting scheme so all 0s come to the left and 1s come to the right. Take 2 pointers/indexes - P1 pointing to the start of the subarray with 0s and P2 pointing to the start of the subarray with 1s. For ex:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void reArrange(int[] arr){ \n  int countZero = 0, countOne = 0; \n  //count 0s and 1s..O(n) \n  for (int i=0; i<=arr.length-1;i++){ \n   if (arr[i]==0) \n    countZero++; \n   else \n    countOne++; \n  } \n   \n  int currentDigit = arr[0]; \n     int groupCount = 1; \n     int functionValue, previous1FunctionValue = 0, previous2FunctionValue = 0; \n     outerwhile: while (true) \n         { \n             if (groupCount == 1) \n                 functionValue = 1; \n             else if (groupCount == 2) \n                 functionValue = 2; \n             else \n                 functionValue = (int) Math.pow(previous1FunctionValue, 2) - (int) Math.pow(previous2FunctionValue, 2); \n             for (int i = 0; i < functionValue; ++i) \n             { \n                 System.out.print(currentDigit); \n                 if (currentDigit == 0) \n                  countZero--; \n                 else  \n                  countOne--; \n                // totalPrintCount++; \n                 if (countZero <= 0 ){ \n                  for (int j = 0; j< countOne; j++) \n                   System.out.print(1); \n                  break outerwhile; \n                 } \n                 else if (countOne <=0){ \n                  for (int j = 0; j< countZero; j++) \n                   System.out.print(0); \n                     break outerwhile; \n                 }     \n             } \n             currentDigit ^=1; \n             previous2FunctionValue = previous1FunctionValue; \n             previous1FunctionValue = functionValue; \n             groupCount++; \n         } \n   \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void rearrangeArray(int[] A) \n { \n  int zeros = 0; \n  int ones = 0; \n  int aLen = A.length; \n \n  for(int i = 0; i < aLen; i++) \n  { \n   if (A[i] == 0) zeros++; \n   if (A[i] == 1) ones++; \n  } \n \n  int f1 = 1; \n  int f2 = 2; \n  int fn = 1; \n  int curIdx = 0; \n  boolean isZeros = true; \n   \n  while(fn < aLen) \n  { \n   if (fn == 1 && isZeros) \n   { \n    if (zeros > 0) \n    { \n     A[curIdx++] = 0; \n     zeros--; \n    } \n    isZeros = false; \n    f1 = fn; \n    fn = 2; \n   } \n   else if ( fn == 2 && !isZeros) \n   { \n    while(curIdx <= fn && ones > 0) \n    { \n     A[curIdx++] = 1; \n     ones--; \n    } \n    isZeros = true; \n    f2 = fn; \n    fn = f2*f2 - f1*f1; \n    f1 = f2; \n    f2 = fn; \n   } \n   else \n   { \n    if (isZeros) \n    { \n     int cnt = 0; \n     while(cnt < fn && zeros > 0) \n     { \n      A[curIdx++] = 0; \n      zeros--; \n      cnt++; \n     } \n     isZeros = false; \n    } \n    else \n    { \n     int cnt = 0; \n     while(cnt < fn && ones > 0) \n     { \n      A[curIdx++] = 1; \n      ones--; \n      cnt++; \n     } \n     isZeros = true; \n    } \n     \n    fn = f2*f2 - f1*f1; \n    f1 = f2; \n    f2 = fn; \n   } \n  } \n   \n  while(zeros > 0) \n  { \n   A[curIdx++] = 0; \n   zeros--; \n  } \n   \n  while(ones > 0) \n  { \n   A[curIdx++] = 1; \n   ones--; \n  } \n \n  for(int i = 0; i < aLen; i++) \n   System.out.print(A[i] + \" \"); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"[Step 1] Given an unsorted array of 0's and 1's, count the number of 0's and 1's (takes O(N)).  [Step 2] Rearrange the array by (i) computing the group length as given in the problem and (ii) putting that number of 0's (or 1's), checking whether we have sufficient number of 0's (or 1's) (O(N)). Stop when we run out of 0's (or 1's).  [Step 3] Append to the array whatever is left"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is easy to see that S(n) = f(0) + f(1) + f(2) + ... + f(n) = sqr(f(n-1)) + 2 (This is a typical example of telescopic series where expressions cancels out cross wise) Hence F(n) = S(n) - S(n-1). I use this in getF() function to get F(n) & S(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public static void doTheThing(int arr[]) \n    { \n        int currentDigit = arr[0]; \n        int groupCount = 1; \n        int functionValue, previous1FunctionValue = 0, previous2FunctionValue = 0; \n        int totalPrintCount = 0; \n       outerwhile: while (true) \n        { \n            if (groupCount == 1) \n                functionValue = 1; \n            else if (groupCount == 2) \n                functionValue = 2; \n            else \n                functionValue = (int) Math.pow(previous1FunctionValue, 2) - (int) Math.pow(previous2FunctionValue, 2); \n            for (int i = 0; i < functionValue; ++i) \n            { \n                System.out.print(currentDigit); \n                totalPrintCount++; \n                if (totalPrintCount >= arr.length) \n                    break outerwhile; \n            } \n            currentDigit ^=1; \n            previous2FunctionValue = previous1FunctionValue; \n            previous1FunctionValue = functionValue; \n            groupCount++; \n        } \n    }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5662220524453888","download_status":"DOWNLOAD_DONE","votes":"-2","answersCount":"4","title":"array where indexes correspond to the tree node number of a parent node, and values correspond to current tree node number., root having number -1 Write code to recreate a tree. (I was confusing about what the array index and value really represent)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Would you give an example."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a) did you mean value inside each array element refers to parent? (i.e. index = node number and value = parent number) b) if answer to a) is no, i.e. index = parent number and value = node number, then root node should have a value = index and not -1. otherwise its parent will be the node with number equal to root's index number."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just to clarify, does that mean, every node in the tree has exactly one child?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"is It a heap?   If so, there is not need to recreated:  Parent of node i  =  i/2 Left node for node i = i*2 Right node for node i = (i*2) + 1"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5652684421988352","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"8","title":"How to find the smallest number with just 0 and 7 which is divided by a given number?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Initially choose some number k  of the form 7x10^x for some x, where k > the given number N.  Suppose k = 7000,  1. Place a 7 one position at a time and see if N divides k. For ex: 7007, 7070,7700. 2. Then place 2 7's at positions and see like in 7077, 7707, 7770 etc. and test if N divides k.  In essence, the problem is asking to generate the possible combinations of 7's and 0's and then check for divisibility. The problem is combinatorial in nature and my solution has exponential time complexity in the number of digits of N."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"print 0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question is kind of vague. Could you clarify? The smallest number in what?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Suppose n has m digits. We will generate all m, m+1,m+2 ,m+3.. digit numbers comprising of digits 0 and 7 in the increasing order and then check for each generated number if it is divisible by n.  Suppose n is 3812. In this case we will generate all the 4,5,6.. digit numbers consisting of 0 and 7 through combination, for ex the first one will be 7000, 2nd 7007, 3rd 7070, 4th 7077, 5th 7700, likewise and check for each generated number if it is divisible by n. We will keep on generating the numbers until and unless we find one which is divisible by n.  In other case, suppose n is 8812.  In this case we will start from generating 5 digit numbers consisting of 0 and 7 as the maximum 4 digit number 7777 is smaller than the n itself."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use 2 queues: queue1: for numbers with 0 at unit place queue2: for numbers with 7 at unit place get minimum of these two queues.Check if it is divisible by n. if yes return it else insert in queues as per the critetia."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"unless i'm missing something very obvious, wouldn't any combination of 0 *and* 7 will be divisible by 7 ? so if an integer N is divisible by any combination of 0 and 7 - it is divisible by 07 - which is obviously be smallest of any such combination. This is because"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6173581343981568","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"6","title":"I have recently attended Amazon Interview and got rejected after design round, its happened three times with Amazon in 2 year, i always getting rejected because of design round. please help me to know how should i answer an design question. questions like 1) design elevator control system 2) design whisper-sync feature (used in Amazon instant video platform) they ask me to design End to end HLD LLD i did not get what exactly differ in both, i explain as a algorithm wise, but could not properly by HLD and LLD.  i mean i searched alot, but could not found a way to answer such question.  Any help will be good for me.  Thanks,","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"High Level Design (HLD) is the overall system design - covering the system architecture and database design. It describes the relation between various modules and functions of the system. data flow, flow charts and data structures are covered under HLD. \n \nLow Level Design (LLD) is like detailing the HLD. It defines the actual logic for each and every component of the system. Class diagrams with all the methods and relation between classes comes under LLD. Programs specs are covered under LLD."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"3 interviews in 2 months? Seriously? You must be really lucky or the company must be desperately looking to hire someone. From what I know after working at Amazon for 4 years, you have to wait for 6 months before you get another crack at it.   Anyhoo, try reading head first design patterns to learn the philosophy behind design patterns and how they help object oriented programmers. Try and read about large scale systems such as big table, wikimedia etc. to figure out how large scale systems are built and deployed."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can you share the design questions you were asked?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5827166595973120","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"What are Unit and Integrationtesting.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Unit Testing : testing of a single module is called unit testing. Developer does unit testing. If you are testing a single function of a class then it is Unit testing.  Integration Testing : After integrating more than one modules if we do testing then it is called integration testing."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5144999423377408","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"8","title":"WAP fibonoccaci series using recursion and after completion asked to to write using iteration.  write testcases for the above","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Recursion"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/** \n     * Recursive O(n) method to calculate Fibonacci numbers \n     * @pre n >= 1 \n     * @param fibCurrent The current Fibonacci number \n     * @param fibPrevious The previous Fibonacci number \n     * @param n The count of Fibonacci numbers left to calculate \n     * @return The value of the Fibonacci number calculated so far \n     */ \n    private static int fibo(int fibCurrent, int fibPrevious, int n) { \n        if (n == 1) { \n            return fibCurrent; \n        } else { \n            return fibo(fibCurrent + fibPrevious, fibCurrent, n - 1); \n        } \n    } \n    /** \n     * Wrapper method for calculating Fibonacci numbers \n     * @pre n >= 1 \n     * @param n The position of the desired Fibonacci number \n     * @return The value of the nth Fibonacci number \n     */ \n    public static int fibonacciStart(int n) { \n        if (n <= 0) \n        { \n            throw new IllegalArgumentException(); \n        } \n        return fibo(1, 0, n); \n    } \n    public static int fibonacciIterative(int n) \n    { \n         int a = 1; \n        int b = 1; \n        int c = 0; \n        for (int i = 2; i < n; i++) //i < n, not i <= n \n        { \n            c = a+b; \n            b = a; \n            a = c; \n        } \n        return c; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi, what does WAP stand for? Thanks"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"cool"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think it would be better if you used dynamic programming for the recursive version. This kind of question is the kind of question where I believe they look at this optimization thingy, as the problem is otherwise quite simple:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5475659660918784","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"0","title":"how do you test elevator","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.Sound an alert when weight of the persons in elevator exceeds the capacity of the elevator. 2.When clicked on particular Number(0,1,2,3,4....) button. It should reach there otherwise sound an alert.  3. Where to use. 4. How many floors are there 5. What is the maximum capacity of the elevator . 6. What is the style of the door whether these are of glass or iron or some other material) 7.It should be capable of moving up and down. 8. Whether it is safe to be inside it or not  9. What is the performance  10.Light is there or not ? 11.Fan is there or not ? 12.What does it uses a rope-pully system or magnetic style system."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4852851285164032","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"1","title":"Difference between blackbox and whitebox","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Black Box Testing is a software testing method in which the internal structure/ design/ implementation of the item being tested is NOT known to the tester and vice versa for White Box"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6702347652694016","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"17","title":"In a book with N pages, pages are numbered from 1 to N. Find out how many times each digit occurs in that book.   You are expected to complete the function getDigitslnBook, which takes an integer as input and  prints how many times each digits occur, one in a line.  The Nth line in the output denotes how many times the integer N-1 occurs in page numbers.  Constrains:    N will be between 1 and 1,000,000,000, inclusive. The output will fit in an integer.  Sample lnputOO: 7  Sample Outputo : 0          1 0 0   Explanation : The page numbers are 1,2, 3,4, 5, 6 and 7.   Sample lnput01: 11  Sample Output01: 1 4             Explanation: Digit 1occurs 4 times, at 1,10 and 11.Rest of the digits occurs only once.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorry the sample input output did not come properly.  please find it here.   drive.google.com/file/d/0B2MCIfvwfpg2WW1XdjgwS282Q1U"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If I understand you question correctly you want to count all digits from numbers in range <1 - n>. I'm not sure if there is any better approach then brute force:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This problem can be solved very efficiently with recursion. The algorithm below runs in O(log(n))."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include    main() {     int num = 0;  printf(\" ENter a page number\");  scanf(\"%d\" , &num);  int pos =1;  int r;  int count[10], c,i, tpos;  for(c = 0 ; c < 10 ; c++)     count[c] =0;       while(num > 0)  {         r = num%10;         num = num/10;         for(i = 0; i <10 ; i++)         {                 tpos = pos/10;                 while(tpos > 0)                 {                     count[i] +=r* tpos;                     tpos= tpos/10;                 }                 if(i <= r)                     count[i] += 1;         }         pos = pos*10;  }  count[0]-=2;  for(i = 0; i < 10 ; i ++)  {      printf(\"\\n number %d , count % d\", i , count[i]);  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This was an online test and My solution passed only 10 out of 15 cases. remaining 5 cases timed out.  My solution was for i =1 to n , convert i to string and concatenation string. at the end find the number of occurrence in the string."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can be solved depending on the number of digits.  First lets identify the pattern of frequency of usage of each digit  0-9  : 1 10-99 : 10+10 100-999 : 100+100+100  let N be the input number and A be an array to store frequency of digits Scan the number from left to right and extract each digit out of it. Let the digit be k and position be j e.g. N = 4375 for k = 4, j = 3"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"initialize an array of int[10] from 0 .. 9 for each i in N keep getting reminder of i / 10 and increment array for each value found."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Any other efficient code, this is creating millions of strings and destroying."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Best Explantation for this problem stackoverflow.com/questions/20945790/count-the-number-of-ks-between-0-and-n"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a simple and pretty straightforward solution in Java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int[] countOccur(int n){   int[] occurence = new int[10];   int count = getshiftCount(n, occurence, 0, 1);   for (int i = 0; i < 10; i++){    occurence[i] += count;   }   if (n > 10){    occurence[0]--;   }   return occurence;  }   private int getshiftCount(int n, int[] occurence, int last, int power) {   int grade = n / 10;   int remainder = n % 10;   for (int i = 0; i < remainder; i++){    if (grade == 0 && i == 0){     continue;    }    occurence[i] += power;   }   occurence[remainder] += last + 1;   if (grade > 0){    return grade + getshiftCount(grade, occurence, remainder * power + last, power * 10);   } else {    return 0;   }  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4655994848149504","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"13","title":"Consider 0 as water and 1 as land. Write code in C to find out whether there is pool in the following matrices.  11111 10001 10001 11111 above matrix is pool  11111 11001 11001 10111 11111 above matrix is NOT pool  11111 11001 11001 10001 11111 above matrix is pool  11111 11101 11001 10001 11111 above matrix is pool","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Updating the approach : Count the number of connected components consisting of 0's. If count == 1 => pool, else non-pool.  Connected Component search can be performed in 4 directions only i.e. left-right-up-down."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I assume that the pool hast to consist of at least two 0s. Java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int check(int a[][100],int i,int j) \n{ \n    int count = a[i-1][j] + a[i+1][j] + a[i][j-1] + a[i][j+1]; \n    if(count<4) \n       return 1; \n    return 0; \n} \n \nvoid modify(int a[][100],int i,int j) \n{ \n     if(i<0 || i>=M || j<0 || j>=N || a[i][j]==1) \n        return; \n     a[i][j]=1; \n     modify(a,i-1,j); \n     modify(a,i+1,j); \n     modify(a,i,j-1); \n     modify(a,i,j+1); \n} \n \nint poolpresent(int a[][100]) \n{ \n    int found=0; \n    int i,j; \n    for(j=0;j"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Some clarifications would help:  a. Can we assume that the input will always be given a 5 by 4 matrix?  b. Would it be okay to assume that the 'outer' rows/columns will never have 0s?  c. What happens if there is a single zero in the center of the array?  Will this be considered as a pool?  To me, this problem seems clearer if we explicitly specify that the goal is to determine if there is a _single_ pool in the matrix."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class PoolOfZeros {     public static void main(String[] args) {         byte[][] array = {                 {1,1,1,1,1},                 {1,0,1,0,1},                 {1,0,1,0,1},                 {1,0,1,0,1},                 {1,0,0,0,1},                 {1,1,1,1,1}         };            boolean poolPresent = true;         boolean zeroFound = false;         if (!checkBorder(array)) {             System.out.println(\"Border not present.\");             poolPresent = false;         } else {              for (int i = 1; i                for (int j = 1; j < (array[i].length)-1; j++) {                     if (array[i][j] == 0) {                         // Found first 0 element;                         zeroFound = true;                         markZeroAndTraverse(array, i, j);                         break;                     }                 }                 if (zeroFound) {                     break;                 }             }         }          for (int i = 1; i            for (int j = 1; j < array[i].length-1; j++) {                 if (array[i][j] == 0) {                     poolPresent = false;                 }             }         }         System.out.println(\"Pool present: \" + (poolPresent && zeroFound));     }      private static void markZeroAndTraverse(byte[][] array, int i, int j) {         if (array[i][j] == 0) {             array[i][j] = 2;         } else {             return;         }         markZeroAndTraverse(array,i-1,j);         markZeroAndTraverse(array,i+1,j);         markZeroAndTraverse(array,i,j-1);         markZeroAndTraverse(array,i,j+1);     }      private static boolean checkBorder(byte[][] array) {         for (int i = 0; i            int colLength = array[i].length;             if (i == 0 || i == array.length-1) {                 for (int j = 0; j                    if (array[i][j] != 1) {                         return false;                     }                 }             } else {                 if (array[i][0] != 1 || array[i][colLength-1] != 1) {                     return false;                 }             }          }         return true;     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void reduce(int **a, int i, int j, int *m, int *n) \n{ \n  int k, l, c1, c2, c3, c4; \n  while(1) \n  { \n    if(i-1 && !a[i-1][j]) \n    { \n      for(k = 0; k < *n; k++) \n        a[i][k] &= a[i-1][k]; \n         \n      for(k = i; k < *m; k++) \n        for(l = 0; l < *n; l++) \n          a[k-1][l] = a[k][l]; \n      *m = *m - 1; \n    } \n     \n    if(j-1 && !a[i][j-1]) \n    { \n      for(k = 0; k < *m; k++) \n        a[k][j] &= a[k][j-1]; \n         \n      for(l = j; l < *n; l++) \n        for(k = 0; k < *m; k++) \n          a[k][l-1] = a[k][l]; \n      *n = *n - 1; \n    } \n     \n    if(i+1 < *m && !a[i+1][j]) \n    { \n      for(k = 0; k < *n; k++) \n        a[i][k] &= a[i+1][k]; \n         \n      for(k = i+1; k < *m; k++) \n        for(l = 0; l < *n; l++) \n          a[k-1][l] = a[k][l]; \n      *m = *m - 1; \n    } \n     \n    if(j+1 < *n && !a[i][j+1]) \n    { \n      for(k = 0; k < *m; k++) \n        a[k][j] &= a[k][j+1]; \n         \n      for(l = j+2; l < *n; l++) \n        for(k = 0; k < *m; k++) \n          a[k][l-1] = a[k][l]; \n      *n = *n - 1; \n    } \n     \n    c1 = (i-1)?a[i-1][j] : 1; \n    c2 = (j-1)?a[i][j-1] : 1; \n    c3 = (i+1 < *m)?a[i+1][j] : 1; \n    c4 = (j+1 < *n)?a[i][j+1] : 1; \n     \n     \n    if(c1 && c2 && c3 && c4) \n      return; \n  } \n} \n \nint check(int **a, int m, int n) \n{ \n  int i, j, flag; \n  flag = 1; \n   \n  for(i = 0; i < m && flag; i++) \n    for(j = 0; j < n; j++) \n      if(!a[i][j]) \n      { \n        reduce(a, i, j, &m, &n); \n        flag = 0; \n        break; \n      } \n       \n  for(i = 0; i < m; i++) \n    for(j = 0; j < n; j++) \n      if(!a[i][j]) \n        if(flag) \n          return 0; \n        else \n          flag = 1; \n  return flag; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n \n \n \nint checkpool(int arr[4][4]) \n{ \n for(int i=0;i < (int)(sizeof(arr)/sizeof(int));i++) \n { \n  if(arr[i][i]==arr[i][3]&&arr[i][i]==1) \n  return 1; \n } \n return 0; \n} \nint main() \n{ \n int array[4][4] = {0,0,0,0, \n        1,1,1,0, \n        1,1,0,1, \n        1,0,1,1}; \n         \nint answer = checkpool(array);         \nif(answer==1) \n{ \n printf(\"There is pool\"); \n} \nelse \n{ \n printf(\"There is no pool\"); \n} \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Classic line fill algorithm: traverse the matrix until you find a 0 (i.e. water) then start filling the \"reachable\" water with a different color. Do a second traversal of the matrix to see if there are any uncoloured places left.  Possible optimizations: 1) After you have found a water drop and filled in the matrix, set a boolean foundWater = true. Carry on traversing and if uncolored water found again and foundWater==true, then you can terminate. 2) Use bytes instead of ints (I was too lazy to change the solution)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5664942795522048","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"12","title":"Given a string S1, convert it to another string S2 (Anagram) by swapping only adjacent elements. Print all the intermediate strings formed.  eg: s1: abcde s2: bcdae  output: bacde,bcade, bcdae.  like wise.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"label each character in s2 with1 to n, s2: bcdae n2:12345 convert s1 to a array of number according to the labels, s1: abcde n1: 41235  the next is to sort 41235 using bubble sort ??????????????: 41235 14235 12435 12345"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It still seems like a simple BFS where you only check possible cases (adjacent swaps only)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \nvoid convertString(std::string& str1, std::string& str2) { \n   if (str1.empty() || str2.empty()) { \n        std::cout << \"Empty String Input\" << std::endl; \n        return; \n   } \n \n   if (str1.size() != str2.size()) { \n        std::cout << \"Unequal String Size in Input\" << std::endl; \n        return; \n   } \n \n   if (str1.compare(str2) == 0) { \n        std::cout << \"Equal String in Input\" << std::endl; \n        return; \n   } \n \n   std::string workStr1(str1); \n \n   for (int i=0; ii; k--) { \n            char c = workStr1.at(k); \n            workStr1.at(k) = workStr1.at(k-1); \n            workStr1.at(k-1) = c; \n \n            std::cout << workStr1 << std::endl; \n        } \n   } \n} \n \nint main() { \n   std::string str1(\"abcdea\"); \n   std::string str2(\"deaabc\"); \n \n   convertString(str1, str2); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private void transpose(String source, String destination) { \n   \n  if(source.length() != destination.length()) { \n   return; \n  } \n  for(int i=0;i< source.length()-1;i++) { \n   char a= source.charAt(i); \n   char b = source.charAt(i+1); \n   if(checkCharOrder(a , b, destination)) { \n    source = swapAdjacent(i,i+1,source); \n   } \n   if(source.equals(destination)) { \n    System.out.println(\"Strings match now \" + source +  \" \"+ destination ); \n    return; \n   } \n  } \n } \n \n private String swapAdjacent(int i, int j, String source) { \n  StringBuilder string = new StringBuilder(source); \n  char temp = source.charAt(i); \n  string.setCharAt(i, source.charAt(i+1)); \n  string.setCharAt(i+1, temp); \n  System.out.println(string.toString()); \n  return string.toString(); \n } \n \n private boolean checkCharOrder(char a, char b, String destination) { \n  int indexOfA = destination.indexOf(a); \n  int indexOfB = destination.indexOf(b); \n  return ( indexOfA > indexOfB); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void swap(char *s,char *t) \n{ \n     char temp=*s; \n     *s=*t; \n     *t=temp; \n} \n \nvoid transpose(char s1[],char s2[]) \n{ \n     int i=0,j=0,index=0; \n     printf(\"%s\\t\",s1); \n     while((s1[i]==s2[i]) && i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class SwapLikeAnagram { \n \n public static void swapAnagram(String str) { \n \n  for (int i = 0; i < str.length(); i++) { \n   str = charValues(str, i); \n  } \n } \n \n public static String charValues(String str, int i) { \n  String newString = \"\"; \n  char[] ch = str.toCharArray(); \n  if (i < str.length() - 1) { \n   char ch1 = ch[i]; \n   ch[i] = ch[i + 1]; \n   ch[i + 1] = ch1; \n \n   for (Character ch5 : ch) { \n    System.out.print(ch5); \n    newString += ch5; \n   } \n   System.out.println(); \n  } \n  return newString; \n } \n \n public static void main(String[] args) { \n \n  String str = \"abcde\"; \n \n  swapAnagram(str); \n \n } \n \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4586596565254144","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"18","title":"Given a matrix, you need to create another matrix such that the value (i,j) is either -1, 0 or 1. 1 - if multiplication of all values in ith row and jth column is greater than 0. -1 - if multiplication of all values in ith row and jth column is less than 0. 0 - if multiplication of all the values in ith row and jth column is 0.  e.g. 1 2 3 1 1 0 -1 2 -1 1 1 1  o/p -1 0 -1 1 0 0 0 0 1 0 1 -1","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can solve this problem by storing the product of all rows in a rows array and then the product of all column in a column array. Then, we will be simple multiplication of the rows and column.  Code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"One easier solution is to calculate the multiplication of all elements in i'th rows(int[] rowMul) and j'th columns(int[] colMul). So total 3+4=7 multiplication. Later just go through the matrix to do"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/*  Running time is terrible */  Original[n][n]; result[n+1][n+1];  for(row =0; row < NumOfRow; row++) {  result[row][n] = 1;   for(col=0;col {     result[row][n] = result[row][n] * Original[row][col]  //last row cell   result[n][col] = result[row][n] * Original[row][col]  //last col cell  }  }  for(row =0; row < NumOfRow; row++) {  for(col=0;col {   if(result[row][n] * result[n][col] > 0)   {    result[row][col] = 1;   }   else if (result[row][n] * result[n][col] == 0)   {    result[row][col] = 0;   }   else   {    result[row][col] = -1;   }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This cpp code worked perfectly fine with no error:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Create to auxiliary arrays  - 'row' where row[i] contains multiplication for i-th row - (-1 if product is < 0 ; 1 if  product > 0; 0 if product == 0)  - 'col'  where col[j] contains multiplication for j-th column. Rules are the same as for rows I think the rest is self explaining if you check the implementation. Code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. One way could be to store just the locations of 0s and negative numbers. e.g. if (i,j) contains 0, then (i,:) = 0 and (:,j) = 0.   2. Similar will be the case with any negative number (keeping a track of number of negative numbers : -1 if odd and 1 if even)  3. Rest all values will be 1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think my below code is a partial dynamic program  I have used a dictionary to store the values of column. multiplying the column values will take at most len(column) and after that theta(1) amortized running time.  And the inner for loop will be skipped if the multiplication of row values = 0.  If I'm wrong or any other improvement can be done for the efficiency, pls post it!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(N) - Using TreeMap"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package code;  public class Matrix {    public static void main(String[] args)  {     int[][] matrix={{1,2,3,1},{1,0,-1,2},{-1,1,1,1}};      int[] row=new int[3];   int[] col=new int[4];         for(int i=0;i<3;i++)   {    row[i]=1;   }   for(int j=0;j<4;j++)   {    col[j]=1;   }      for(int i=0;i<3;i++)   {        for(int j=0;j<4;j++)    {       if(matrix[i][j]<0)       {       if(row[i]!=0)       {       row[i]=-row[i];       }                     if(col[j]!=0)       {      col[j]=-col[j];       }              }       else if(matrix[i][j]==0)       {        row[i]=0;        col[j]=0;       }           }   }            /*for(int i=0;i  {    System.out.println(\"row: \"+row[i]);   }      for(int j=0;j  {    System.out.println(\"col: \"+col[j]);   }*/     int[][] output=new int[row.length][col.length];      for(int i=0;i  {    for(int j=0;j   {     if(row[i]==0||col[0]==0)      output[i][j]=0;          if((row[i]==col[j])&&(row[i]!=0))      output[i][j]=1;          if((row[i]==-1&&col[j]==1)||(row[i]==1&&col[j]==-1))     {      output[i][j]=-1;     }    }   }         for(int i=0;i  {    System.out.println();    for(int j=0;j     System.out.print(output[i][j]+\" \");   }     }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"matrix=[[1, 2, 3, 1], [1, 0, -1, 2], [-1, 1, 1, 1]]  def column_multiplication(rows,col_elem):     col_result=1     while rows>0:         col_result=col_result * matrix[rows-1][col_elem]         rows=rows-1     return col_result  def rows_multiplication(col,row_elem):     rows_result=1     while col>0:         rows_result=rows_result * matrix[row_elem][col-1]         col=col-1     return rows_result  def main():     print \"Given Matrix : \", matrix     rows=len(matrix)     col=len(matrix[0])     new_matrix=[ [ None for i in range(col) ] for j in range(rows) ]     for row_elem in range(rows):         for col_elem in range(col):             col_result=column_multiplication(rows,col_elem)             rows_result=rows_multiplication(col,row_elem)             if col_result * rows_result == 0:                 new_matrix[row_elem][col_elem]= 0             elif col_result * rows_result > 0:                 new_matrix[row_elem][col_elem]= 1             elif col_result * rows_result < 0:                 new_matrix[row_elem][col_elem]= -1     print \"Result Matrix : \", new_matrix  if __name__==\"__main__\":     main()"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static int[][] findMult(int[][] arr) \n { \n   \n \n  int[][] result = new int[arr.length][arr[0].length]; \n  int mult =1; \n  for(int i=0; i 0) \n    { \n     result[i][j] = 1; \n      \n    }else if(mult < 0) \n    { \n     result[i][j] = -1; \n    }else \n    { \n     result[i][j] = 0; \n    } \n     \n    mult = 1; \n   } \n    \n    \n  } \n  return result; \n   \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"matrix=[[1, 2, 3, 1], [1, 0, -1, 2], [-1, 1, 1, 1]]  def column_multiplication(rows,col_elem):     col_result=1     while rows>0:         col_result=col_result * matrix[rows-1][col_elem]         rows=rows-1     return col_result  def rows_multiplication(col,row_elem):     rows_result=1     while col>0:         rows_result=rows_result * matrix[row_elem][col-1]         col=col-1     return rows_result  def main():     print \"\\nGiven Matrix : \", matrix, \"\\n\"     rows=len(matrix)     col=len(matrix[0])     new_matrix=[ [ None for i in range(col) ] for j in range(rows) ]     for row_elem in range(rows):         for col_elem in range(col):             col_result=column_multiplication(rows,col_elem)             rows_result=rows_multiplication(col,row_elem)             if col_result * rows_result == 0:                 new_matrix[row_elem][col_elem]= 0             elif col_result * rows_result > 0:                 new_matrix[row_elem][col_elem]= 1             elif col_result * rows_result < 0:                 new_matrix[row_elem][col_elem]= -1     print \"Result Matrix : \", new_matrix  if __name__==\"__main__\":     main()"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int[][] computeIndicators(int[][] inputMatrix){ \n  int rows = inputMatrix.length; \n  int cols = inputMatrix[0].length; \n  int[] rowIndicators = new int[rows]; \n  int[] colIndicators = new int[cols]; \n  int[][] outputMatrix = new int[rows][cols];   \n   \n  for(int i = 0; i < rows; i++){ \n   int rowIndicator = 1; \n   for(int j = 0; j < cols; j++){ \n    rowIndicator *= inputMatrix[i][j];  \n   } \n   if(rowIndicator > 0) rowIndicators[i] = 1; \n       else if(rowIndicator == 0) rowIndicators[i] = 0; \n    else rowIndicators[i] = -1; \n  } \n \n  for(int i = 0; i < cols; i++){ \n   int colIndicator = 1; \n   for(int j = 0; j < rows; j++){ \n    colIndicator *= inputMatrix[j][i];  \n   } \n   if(colIndicator > 0) colIndicators[i] = 1; \n       else if(colIndicator == 0) colIndicators[i] = 0; \n    else colIndicators[i] = -1; \n  } \n \n  for(int i = 0; i < rows; i++){ \n   for(int j = 0; j < cols; j++){ \n    outputMatrix[i][j] = rowIndicators[i] * colIndicators[j]; \n   } \n  } \n \n  return outputMatrix;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int[][] getMatrix01(int[][] a) { \n \nint r = a.length; \nint c = a[0].length; \nint[][] b = new int[r][c]; \n \nfor (int i = 0; i < r; i++) { \n     \n    for (int j = 0; j < c; j++) { \n      \n     int result = 1; \n      \n     for (int i2 = 0; i2 < r; i2++) { \n        result *= a[i2][j];      \n     } \n \n     for (int j2 = 0; j2 < c; j2++) { \n         result *= a[i][j2]; \n     } \n       \n     if (result > 0) { \n         b[i][j] = 1; \n     } else if (result < 0) { \n         b[i][j] = -1; \n     } else { \n         b[i][j] = 0; \n     } \n     \n    } \n} \n     \n return b; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6499596339511296","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"A number of intersecting bridges is given.Remove minimum number of bridge to make remaining bridges non-intersecting.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the bridges are modeled as edges of a graph, the question seem to be essentially asking for a graph planarity testing algorithm."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is a problem that can be solved using greedy technique.  Algorithm: 1: Sort the set of bridges in descending order of their no of intersection. (high intersecting at top). 2: Check if there exist an intersection in the current set of bridges. 3: If intersection exists:  3.1 Remove the top bridge.  3.2 Go to step 2 4:  If intersection doesn't exits we are done. Return the set of bridges or count."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here we try to find the number of bridges we can retain without causing an intersection.  Model the bridges as nodes in a graph and intersections as edges between nodes.  Now, we try to build a new graph adding nodes to an empty graph. At each step, we have choice of adding or not adding a node from the original graph to the new graph.  Tested this with some test sets. Looks like working. Please let me know if it fails for a case."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5071568031973376","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"12","title":"Given linked list as a-x-b-y-c-z output it as a-b-c-z-y-x that is reverse alternate element and append to end of list","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"ListNode *curr,*second = NULL; \n \ncurr = head; \n \nwhile(curr!=NULL && curr->next!=NULL) \n{ \n temp = curr->next; \n \n curr->next = temp->next; \n \n temp->next = second; \n \n second = temp; \n \n prev = curr; \n \n curr = curr->next; \n} \n \nprev->next = second;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Possible solution: Parse the list and push alternate nodes on the stack. Then pop and add at the end."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Thanks for the question. This was surprisingly tricky to get right...I made mistakes. I think part of the reason was that I underestimated the question :-(  The foll code works for 1, 1-901, 1-901-2, 1-901-2-902."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This might do it:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void ReverseAltNodes(struct Node *&node) {  if(!node || !node->next)   return;  struct Node *last=node;  while(last->next)   last=last->next;  struct Node *t=node;  while(t && t!=last && t->next!=last)  {   struct Node *next=t->next;   if(!next){    break;   }   t->next=next->next;   struct Node *s=last->next;   last->next=next;   next->next=s;   t=t->next;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void getList(LinkedList head){ \n  if(head == null) \n   return; \n  int i=1; \n  Stack S = new Stack(); \n  while(head != null){ \n   int d = head.getData(); \n   if(i%2==0) \n    S.push(d); \n   else \n    System.out.print(\" \"+d); \n   head = head.getNext(); \n   i++; \n  } \n  while(!S.isEmpty()){ \n   System.out.print(\" \"+S.pop()); \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void getList(LinkedList head){ \n  if(head == null) \n   return; \n  int i=1; \n  Stack S = new Stack(); \n  while(head != null){ \n   int d = head.getData(); \n   if(i%2==0) \n    S.push(d); \n   else \n    System.out.print(\" \"+d); \n   head = head.getNext(); \n   i++; \n  } \n  while(!S.isEmpty()){ \n   System.out.print(\" \"+S.pop()); \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A recursive solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct Node { \n   Node(char d) : data(d), next(0) {} \n   char  data; \n   Node* next; \n}; \n \ninline void ADD(Node*& t, Node* n) \n{ \n    n->next = 0; t->next = n; t = n; \n} \n \nint main(int argc, char** argv) \n{ \n    Node* head = new Node('a'); \n    Node* tail = head; \n \n    ADD(tail, new Node('x')); \n    ADD(tail, new Node('b')); \n    ADD(tail, new Node('y')); \n    ADD(tail, new Node('c')); \n    ADD(tail, new Node('z')); \n \n    for (Node* p = head; p->next != tail; p = p->next) { \n        Node* t = p->next; \n        p->next = t->next; \n        t->next = tail->next; \n        tail->next = t; \n    } \n \n    for (Node* n = head; n; n = n->next) cout << n->data; cout << endl; \n    cout << endl; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static Node reverseAlternateElement(Node start) { \n  if(start==null || start.next==null) \n   return start; \n  Node startCopy=start; \n  Node second= start.next; \n  Node secondCopy=second; \n  while(second!=null && second.next!=null){ \n   start.next=second.next; \n   start=start.next; \n   second.next=start.next; \n   second=second.next; \n  } \n  start.next=secondCopy; \n  return startCopy; \n   \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node f(node x) \n{ \n a_head = x \n b_head = x.next \n a=a_head, b = b_head; \n  \n while((a!=null) && (b != null)) \n { \n  a.next = b.next \n  a = a.next \n  b.next = a.next \n  b = b.next \n } \n a.next = b_head \n return a_head; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6189859303587840","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"17","title":"Given a Text String T: abbbacctlkjlkcccaaabbb and pattern string P: ab[.]*c[.]*b, Find all occurances of P in T","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"considering we allow pattern string like a*b, a.*b., etc, character '.' means matching any character once, a star ('*') means matching previous character 0 ~ infinite times. (a* means matching '','a','aa','aaa',...; and .* means matching any string, including empty string)   we can solve this problem using dp: 1) parse pattern: pattern string 'ab*c' parsed to {{'a',false},{'b',true},{'c',false}}, the second bool value in each pair indicates whether the corresponding character is followed by a star ('*') 1) consider matching string of length m with parsed pattern of length n, we use f(i, j) to denote the matching result of string.substr(i) and pattern subsequence starting at j. f(i,j)=1 means a match while f(i,j)=0 means mismatch 2) we have the base case f(m,n) = true, since empty string matches empty pattern sequence. 3) for all 0 =< i < m, we have f(i,n) = false, since non-empty string will always mismatches empty pattern 4) for all 0=< j < n, we have f(m, j) = true if and only if pattern[j] to pattern[n-1] are all with stars. 5) for other cases, we can match from the end to head, we have: f(i, j) =  a) pattern[j] is with star:   a1) if pattern[j]=='.' || pattern[j]==str[i]: f(i,j) = f(i,j+1) || f(i+1,j+1) //we ignore current pattern character or use it to match current character in string   a2) otherwise, f(i,j) = f(i,j+1) //we can only ignore current pattern character to get a match  b) pattern[j] is without star:   b1) if pattern[j]=='.' || pattern[j]==str[i]: f(i,j) = f(i+1,j+1)   b2) otherwise f(i,j) = false 6) for all 0=< i < m, if f(i, 0) = true, it means substring starting from position i and ending at the tail of the string matches the whole pattern 7) previous steps will find occurances of matching substrings ending with the end of given string  8)since we want to find all occurances (ending at all possible positions), we simply match string.substr(0, len)  with the whole pattern, for all 0 < len <= string.length().  9) time complexity O((m^2) *n), space complexity O(m*n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Answer:  abbbacctlkjlkcccaaab abbbacctlkjlkcccaaabb abbbacctlkjlkcccaaabbb  I think it is not possible to implement it in a 45 minutes interview.  Maybe you only need to provide an idea as Murali Mohan  answered."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Answer:  abbbacctlkjlkcccaaab abbbacctlkjlkcccaaabb abbbacctlkjlkcccaaabbb  I think it is not possible to implement it in a 45 minutes interview.  Maybe you only need to provide an idea as Murali Mohan  answered."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I did spend some time about putting idea of DFA/NDFA to use but couldn't materialize in reasonable time.  Key idea that I used is - Init =>  ===== Treat different parts of pattern as small(sub)Strings  For one match => =========== Fix (i)th subString into InputString and then go on to fix for all remaining subString(s) into remaining of InputString  Terminating conditions => ===================  if we'r matching last subString => print the Match (we know position of all subStrings)  To find all matches => Find-next-Match of (i)th string and call match for remaining of InputString  Below is the pseudo-code I used  :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"To find patterns using regular expressions, one needs to be build an NFA and it's equivalent DFA."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"am not sure if this is correct. But you can get the count using regex pattern matching."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6140059795324928","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"9","title":"Given a Text String T: aaabbbzzccc and pattern string P: ab , Find all occurances of P in T","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"simple kmp"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"#include \n#include \n \nint occur(char[],char[]); \n \nint occur(char sent[],char pattern[]) \n{ \n \n int count=0; \n \n for(int i=0,j=i;sent[i]!='\\0';) \n { \n  if(sent[i+j]==pattern[j]&&pattern[j]!='\\0') \n  { \n   j++; \n    \n    \n  } \n    else if(j==strlen(pattern)) \n  { \n   count++; \n   i=i+j; \n   j=0; \n  } \n  else \n  { \n   i++; \n   j=0; \n    \n  } \n   \n } \n return count; \n} \n \nint main() \n{ \n char sent[] = \"aabaabaaabbbabababddfggaabbbasab\"; \n char pattern[] = \"aba\"; \n int result = occur(sent,pattern); \n printf(\"\\nNo of Occurrences --- > %d\",result); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void countOccurence(String str, String pattern) \n    { \n    int n = 0, i = 0; \n    while (i < str.length() \n            && (i = str.indexOf(pattern, i)) != -1) { \n        ++n; \n        ++i; \n    } \n    System.out.println(\"n: \" + n); \n   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class FindPatternOccurrences { \n \n public static void main(String[] args) { \n  String str = \"aabababcfdc\"; \n  String pattern = \"ab\"; \n  matchPattern(str, pattern); \n } \n \n public static void matchPattern(String str, String pattern) { \n \n  int count = 0; \n  for (int i = 0; i < str.length() - 1; i++) { \n   String str1 = str.substring(i, i + 2); \n   if (str1.equals(pattern)) \n    count++; \n  } \n  System.out.println(\"NUmber of occurrences= \" + count); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This prints the number of occurrences of the pattern:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6007303497056256","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"3","title":"Given a m*n matrix representing a maze wherein some of the positions are not reachable, find all paths from (0,0) to (m,n) using dynamic programming","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Interesting problem. Very similar to the TopCoder problem  found here:  http :// community.topcoder.com/stat?c=problem_statement&pm=1889  Assume (0, 0) is top-left corner, and (m, n) is bottom-right.  Then, the basic idea is:  1. Let K(i, j) be the ways in which you can get to (m, n) from (i, j). 2. In a highly compressed formula, the recurrence relation is:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I created the solution below for this problem. I don't think it is optimal, I think it could be improved but it works.  The results it throws seem to be backwards in terms of (X, Y), but I think that is because the way I declared the char array that represents the maze.  The maze I created is shown below. The \"#\" means obstacle, \".\" means free path, \"+\" is used by the algorithm to mark cells each recursion has visited and G marks the goal.  Maze: .##.... .##.##. .....#. #.##.#. #.#..#. #.#.### #......"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5126907007860736","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"19","title":"Given array of N integers ranging from 0 to N-1. Output maximum repeating integer. Use only O(1) memory.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"We know that the numbers present in the array are in the range 0 to n-1.  We traverse the array from left to right and for each element ,a[i], we increment the value at the index a[i]  by n. In case the value at any index is more than (n-1) then we know that the index's value has been incremented because that index is the value we have already encountered while traversing the array. To know the exact value at that index we take mod of n and get the original value. Again considering that value say v as the index, we increment the value at the index v by n. After we are done traversing once, we again traverse the array from left to right and find out which index's value has been incremented maximum times. We can do that by dividing the value by n. We can restore the original value of the array by taking mod of n for each element.  #include  using namespace std;  int getMaxRepeatedNum(int *a,int m,int n) {  int i,k,max=0,p=0;  for(i=0;i {   k=a[i]%n;   a[k]+=n;  } /* for(i=0;i cout< for(i=0;i {   k=a[i]/n;   a[i]=a[i]%n;   if(k>max)   {    max=k;    p=i;   }  } /* for(i=0;i cout< return p; }  int main() {  int a[]={3,1,6,3,2,0,4,4,3,1,3,0,2,5,6};  int m=sizeof(a)/sizeof(a[0]),n=7;  cout<<\"Most repeated number is: \"< return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sort the numbers using Radix Sort, since the numbers are between some range, O(n) t.c. . Then go for linear search for the required answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Cool solution. We have to be concerned about the overflow though (the value of an element can be incremented by n^2). Nice one anyways."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There are not enough info in the question, like can the array hold negative numbers and can we modify the array? If we can modify the array, should we reconstruct it at the end? I assume the answer to these questions is yes yes no.  The solution resembles applying a permutation to an array with minor differences. Since there are no negative numbers in the array, we can use negative numbers to mark cells as visited. Lets call the array A. The algorithm would be:  0. ind := 0 1. starting from ind, find the leftmost index i such that A[i] >= 0. ind := i (terminate if ind >= A.length) 2. a := A[i] 3. A[i] := -infinity (-infinity means we haven't seen i in the array so far) 4. while A[a] >= 0   5.     temp := A[a]; A[a] = -1; a :=temp 6. /*here A[a] should be negative*/ 7. if A[a] = -infinity then A[a] = -1 else A[a] := A[a] -1 8. go to step 1  At the end just scan through the array and find the minimum value in the array that is not - infinity."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int majority(int *a, int n) \n{ \n  int i, count; \n   \n  if(n == 0) \n    return -1; \n   \n  if(n == 1) \n    return a[0]; \n   \n  for(i = 0, count = 0; i < n; i += 2) \n    if(a[i] == a[i+1]) \n      a[count++] = a[i]; \n       \n  if(n%2 && a[0] == a[n-1]) \n    a[count++] = a[0]; \n     \n  return majority(a, count); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Well, since we know the range of the inputs, we could bucket sort the array in O(n) and scan the resulted list in O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* 1. Sort the array using Quick sort. O(nlogn) */ \n/* 2. scan the array using 2 pointers to complete in O(n) */ \n \ncheckfreq(int a[], int n) \n{ \n int ffreq =0,freq =1, num = -1, *fptr =a, *sptr=a+1; \n for(int i=1; i< n; i++,sptr++) \n { \n  if(*fptr == *sptr) \n  { \n   ++freq; \n    \n  }else \n  { \n   if(freq > ffreq) \n   { \n    freq = ffreq; \n    num = *fptr; \n   } \n   fptr = sptr; \n   freq = 1; \n  } \n } \n \n printf(\" Max repeating Number : %d with frequency : %d \\n\", num, ffreq); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class MaxRepeating { \n int[] mIntArray; \n int mMax; \n public MaxRepeating(int[] readIntArray) { \n  mIntArray = readIntArray; \n  mMax = readIntArray.length; \n } \n \n public int getMaxRepeatingNumberIndex() { \n  for(int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why don't we sort the array and use the HashMap which contains only one value.  Example: 1,3,2,4,2,6,7,4,5,4 After Sorting: 1,2,2,3,4,4,4,5,6,7  Now, iterate over this array, maintain a count variable for each repeated number. For example: for number 2, count: 2.  For 4, we get count 3, since this is greater than getCount(2), we simply delete that number from the hashmap and insert this new value."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since there is  no time limitation as such ... why not just perform a heap sort and keep counting the top of maxHeap ... O(1) space would be used by two variables ... one which keeps the previous max and the other one that keeps the current max.  In this case, you also get the O(nlog(n)) time complexity"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int findMostRepeatingNumber(int[] arr){ \n  int k = arr.length; \n  for(int num : arr){ \n   arr[num%k] +=k; \n  } \n  int max = 0; \n   \n  for(int i =0; iarr[max]){ \n    max = i; \n   } \n  } \n  return max; \n }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6249258466410496","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"34","title":"In Amazon's interview, Round 2 they asked question:  Write a program to print inorder traversal of two trees.   Both values must be printed alternatively.  e.g. if inorder traversal of tree 1 is 10, 15, 20 and tree 2 is 100, 150, 200 then it should print 10, 100, 15, 150, 20, 200.  I tried printing it recursively by calling 2 functions recursively (f1 calls f2, then f2 calls f1 and so on).  I don't know where my approach is going wrong? I know there are other ways to do it as well but in this approach what is the mistake?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The problem is that your are visiting any node in the trees twice. For explanation, have a look at the following lines you wrote:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think a good solution would be to first find the minimum node of each subtree. after that you can start comparing the values and advance the node which was printed to be its sucssesor. This does assume the each node has a pointer to his father. In this approach every node would be visited twice therefore you get linear time complexity and o(1) space complexity."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can't we do inorder traversals of the two trees separately in two separate queues and then dequeue and print the data of the nodes alternatively?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can't we do inorder traversals of the two trees separately in two separate queues and then dequeue and print the data of the nodes alternatively?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Recurse the two trees simultaneously. Essentially, we are printing the nodes at the same level and side in the two trees. It can be easily extended to sum (or any operation on) the corresponding nodes  of the two trees."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The easiest way is to write a inorder tree iterator."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void inOrderTraversal(BST root) { \n  if (root != null) { \n   inOrderTraversal(root.left); \n   System.out.println(root.num); \n   inOrderTraversal(root.right); \n  } \n } \n \n void alternateInOrderTraversal(BST root1, BST root2) { \n  if (root1 != null && root2 != null) { \n   alternateInOrderTraversal(root1.left, root2.left); \n   System.out.println(root1.num + \" \" + root2.num); \n   alternateInOrderTraversal(root1.right, root2.right); \n  } else { \n   if (root1 != null) { \n    inOrderTraversal(root1); \n   } else if (root2 != null) { \n    inOrderTraversal(root2); \n   } \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here is an iterative approach,let me know what u guys think"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There are 2 parts to this question in order traversal and printing alternatively. Both cannot be done simultaneously because of the difference in structure and size of the 2 trees. So lets preprocess the tree first and then print it alternatively. There is a concept of right in threaded tree where each node points to the next in order successor (you can find more online). Once this is done  in order traversal in both the trees will be just like traversing through a linked list and hence printing alternatively will be easy. Now the question is how to convert this tree into a threaded tree. Its a lot easier to construct such a tree from scratch, but in this case we need to convert the current one. Here is a pseudo code for it"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This may not be the cleanest implementation, but it's pretty straight forward.  Given that the tree structures may be different, using a single recursive function is not possible. Instead, we can use an iterative approach modified to iterate through both trees.  Here is an iterative solution of inorder traveral...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Three approaches:  1) Using two stacks and simulation in-order traversal using stacks alternately. 2) Using get_next() alternately. Find lowest elements using get_first() at first. 3) Using recursion. Use auxiliary parameter which tells in what tree to recurse.  The first two is trivial. Just have a look at third approach:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void inorder(struct Tree1 node_tree1, struct Tree2 node_tree2, int bool)              {                 if((node_tree1 != null) && (found == 0))                  {                   inorder(node_tree1->left,node_tree2,1);                   printf(\"%d\",node_tree1->data);                   inorder(node_tree1->right,node_tree2,1);                  }                 if((node_tree2 != null) && (found == 1))                  {                   inorder(node_tree1,node_tree2->left,0);                   printf(\"%d\",node_tree2->data);                   inorder(node_tree,node_tree2->right,0);  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I suppose we can do this: (1)inorder traverse and transform each tree into a linked list (2)print the two linked lists alternately"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think what we can do is search for the smallest element in both tree And after that keep on calling inorder successor for both of them alternatively until you reach the largest element."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5636471859970048","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"5","title":"Given a timer time() with nanosecond accuracy and given the interface interface RealTimeCounter:     void increment()     int getCountInLastSecond()     int getCountInLastMinute()     int getCountInLastHour()     int getCountInLastDay() implement the interface. The getCountInLastX functions should return the number of times increment was called in the last X.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class C1_33RealTimeCounter { \n \n    static class Timer { \n \n        /* \n          timer in nanoseconds accurracy \n         */ \n        public static long time() { \n            return new Date().getTime() * 1000; \n        } \n \n        /** \n         * \n         * @param start the start time in nanoseconds \n         * @param end  the end time in nanoseconds \n         * @return \n         */ \n        public static int diff(long start, long end) { \n            return (int) (end - start) / 1000000; \n        } \n    } \n \n    class CyclicBuffer { \n \n        int[] data = new int[86400]; \n        int beginOffset = 0; \n        int endOffset = 0; \n \n        /** \n         * \n         * @param value current counter value \n         * @param seconds how many seconds passed since last append \n         */ \n        public void append(int value, int seconds) { \n            for(int i = 1; i <= seconds; i ++) { \n                endOffset = (endOffset + i) % data.length;  \n                data[endOffset] = value; \n            } \n            beginOffset = (beginOffset + seconds) % data.length; \n        } \n         \n        public int get(int distanceFromEnd) { \n            int offset = (endOffset + data.length - distanceFromEnd) % data.length; \n            return (int)data[offset]; \n        } \n    } \n \n    private int counter = 0; \n    private long lastIncrementTime = -1; \n    private CyclicBuffer buffer = new CyclicBuffer(); \n \n    public void increment() { \n        long currentTime = Timer.time(); \n \n        if(lastIncrementTime < 0)  \n            lastIncrementTime = currentTime; \n \n        int secondsSinceLastIncrement = Timer.diff(lastIncrementTime, currentTime); \n        counter ++; \n        buffer.append(counter, secondsSinceLastIncrement); \n    } \n \n    public int getCountInLastSecond() { \n        return buffer.get(0) - buffer.get(1); \n         \n    } \n \n    public int getCountInLastMinute() { \n        return buffer.get(0) - buffer.get(60); \n    } \n \n    public int getCountInLastHour() { \n        return buffer.get(0) - buffer.get(3600); \n    } \n \n    public int getCountInLastDay() { \n        return buffer.get(0) - buffer.get(86399); \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"extract day/hour/minute/second part in timestamp, and use them as key, each time to increment(), if key doesn't change, increase counter for that key, otherwise update key and reset counter to 1. In getCountInLastX(), get day/hour/minute/second part from current Date(), and compare them with existing keys, if not match, return 0, otherwise return counter for that key."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class RealTimeCounterImpl implements RealTimeCounter{ \n     \n    //factor for seconds = 1; \n    //factor for minutes = 60; \n    //factor for hour = 1200; \n    //factor for day = 1200*24; \n    long getOneRange(long end, long factor){ \n        long elapsedTime = end - (1000000000 * factor);         \n        return elsapsedTime; \n    } \n     \n    /* \n    *    Keep saved the following data: \n    *    - first time we incremented the counter \n    *    - count in last day \n    *    - count in last hour \n    *    - count in last minute \n    *    - count in last second \n    * \n    */ \n     \n    int countInLastDay = 0; \n    int countInLastHour = 0; \n    int countInLastMinute = 0; \n    int countInLastSecond = 0; \n     \n    long timeFirstInsertLastDay = 0; \n    long timeFirstInsertLastHour = 0; \n    long timeFirstInsertLastMinute = 0; \n    long timeFirstInsertLastSecond = 0; \n \n    void increment(){ \n        long currentTime = time(); \n         \n        long start = getOneRange(currentTime, 1); \n         \n        if (timeFirstInsertLastSecond == 0 || timeFirstInsertLastSecond < start) { \n            timeFirstInsertLastSecond  = currentTime; \n            countInLastSecond = 1; \n        }else{ \n            countInLastSecond++; \n        } \n \n //the same should be done for the other three increments \n    } \n         \n    int getCountInLastSecond(){ \n        return countInLastSecond; \n    } \n     \n    int getCountInLastMinute(){ \n        return countInLastMinute; \n    } \n     \n    int getCountInLastHour(){ \n        return countInLastHour; \n    } \n     \n    int getCountInLastDay(){ \n        return countInLastDay; \n    } \n     \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.HashMap; \nimport java.util.Map; \nimport java.util.Map.Entry; \n \n \npublic class Counter { \n \n private enum StatsType { \n  SEC(1000), MIN(60000), HOUR(3600000), DAY(24*60*60*1000), MONTH(30*24*60*60*1000); \n  private final long divisor; \n  StatsType(int d) { \n   this.divisor = d; \n  }  \n } \n  \n static class Stats { \n  long key = 0; \n  long count = 0; \n  StatsType t; \n  Stats(StatsType t) { \n   this.t = t; \n  }   \n } \n  \n static class StatsPair {   \n  Stats cur; \n  Stats saved; \n  public StatsPair(Stats cur, Stats saved) { \n   this.cur = cur; \n   this.saved = saved; \n  } \n } \n  \n Map tab; \n  \n Counter() { \n  tab = new HashMap();   \n  for(StatsType t : StatsType.values()) \n   tab.put(t, new StatsPair(new Stats(t), new Stats(t))); \n } \n  \n  \n public void incr() { \n  long curMs = System.currentTimeMillis(); \n  for(Entry e: tab.entrySet()) { \n   StatsPair sp = e.getValue(); \n   StatsType ty = e.getKey(); \n   long curKey  =  curMs/ty.divisor; \n    \n   if( sp.cur.key != curKey ) { \n    sp.saved.key = sp.cur.key; \n    sp.saved.count = sp.cur.count; \n    sp.cur.key = curKey; \n    sp.cur.count = 0; \n    //System.out.println(\"moved to saved [\" + ty + \"] \" + sp.saved.key + \" \" + sp.saved.count); \n   } \n   ++sp.cur.count; \n  } \n     \n  //System.out.println(tab); \n } \n \n private long getCountInLast(StatsType ty) { \n  long last = System.currentTimeMillis()/ty.divisor - 1; \n  StatsPair sp = tab.get(ty); \n  if ( sp.cur.key  == last ) \n   return sp.cur.count; \n  else if ( sp.saved.key == last )  \n   return sp.saved.count; \n  return 0; \n } \n  \n public long getCountInLastSec() { \n  return getCountInLast(StatsType.SEC); \n } \n  \n public long getCountInLastMin() { \n  return getCountInLast(StatsType.MIN); \n } \n  \n public long getCountInLastHour() { \n  return getCountInLast(StatsType.HOUR); \n } \n  \n /** \n  * @param args \n  * @throws InterruptedException  \n  */ \n public static void main(String[] args) throws InterruptedException { \n \n  Counter c = new Counter(); \n  for(int i=0; i<100; i++) \n   c.incr(); \n  Thread.sleep(2000); \n  for(int i=0; i<50; i++) \n   c.incr(); \n  System.out.println(c.getCountInLastSec()); \n  Thread.sleep(1000); \n  System.out.println(c.getCountInLastSec()); \n  Thread.sleep(60000); \n   \n  System.out.println(c.getCountInLastMin()); \n  System.out.println(c.getCountInLastHour()); \n   \n \n } \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5692203355602944","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"3","title":"Given a list of pairs (a,b) where a is the number of a node and b is its parent, construct a tree and return the root.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Assuming input is a list of strings each of the form \"a,b\""},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.HashMap; \nimport java.util.HashSet; \nimport java.util.StringTokenizer; \n \n/** \n * Objective: To return root node, given pairs of child, parent nodes \n * of the tree. \n *  \n * @author Sunil \n * \n */ \npublic class Node { \n \n HashSet children = new HashSet(); \n boolean hasParent = false; \n int data; \n \n public static void main(String[] args) { \n  // Sample input \n  Node root = constructTree(new String[]{\"3,2\",\"4,2\",\"7,5\",\"8,5\",\"2,1\",\"5,1\"}); \n  System.out.println(\"Root node: \"+root.data); \n } \n \n private static Node constructTree(String[] strings) { \n  if(strings == null) { \n   System.out.println(\"Provide tree input!\"); \n   return null; \n  } \n  HashMap nodeMap = new HashMap(); \n  for (int i = 0; i < strings.length; i++) { \n   try { \n    StringTokenizer str = new StringTokenizer(strings[i],\",\"); \n    int child = Integer.parseInt(str.nextToken()); \n    int parent = Integer.parseInt(str.nextToken()); \n    Node c = nodeMap.get(child); \n    if(c == null) { // Node not yet added \n     c = new Node(); \n     c.data = child; \n     nodeMap.put(child, c); \n    } \n    Node p = nodeMap.get(parent); \n    if(p == null) { // Node not yet added \n     p = new Node(); \n     p.data = parent; \n    } \n    // Add child to parent node \n    c.hasParent = true; \n    p.children.add(c);     \n    nodeMap.put(parent, p);   \n   } catch(Exception ex) { \n    System.out.println(\"Invalid tree input!\"); \n    return null; \n   } \n  } \n  for(Node node: nodeMap.values()) { \n   if(!node.hasParent) \n    return node; // Found the root \n  } \n  return null; // If root not found return null \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// for pair i, the child is children[i], parent is parents[i] \n    public BinaryTreeNode convert(int[] children, int[] parents) { \n        HashMap nodes = new HashMap<>(); \n \n        // resolve root \n        int rootValue = this.getRootValue(children, parents); \n        BinaryTreeNode root = new BinaryTreeNode(rootValue); \n        nodes.put(rootValue, root); \n \n        for(int i = 0; i < children.length; i ++) { \n            int child = children[i]; \n \n            BinaryTreeNode childNode = nodes.get(child); \n            if(childNode == null) { \n                childNode = new BinaryTreeNode(child); \n                nodes.put(child, childNode); \n            } \n \n            int parent = parents[i]; \n            BinaryTreeNode parentNode = nodes.get(parent); \n            if(parentNode == null) { \n                parentNode = new BinaryTreeNode(parent); \n                nodes.put(parent, parentNode); \n            } \n            // set parent child relationship \n            childNode.setParent(parentNode); \n            if(parentNode.getLeftChild() == null) \n                parentNode.setLeftChild(childNode); \n            else \n                parentNode.setRightChild(childNode); \n        } \n \n        return root; \n    } \n \n \n \n    private int getRootValue(int[] children, int[] parents) { \n        HashSet ancestors = new HashSet<>(); \n        for(int parent : parents) \n            ancestors.add(parent); \n        for(int child : children) \n            ancestors.remove(child); \n        return ancestors.iterator().next(); \n    }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5752143919185920","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"9","title":"Given a set of Lego bricks of height 1, 2, 3, and 4, each colored differently, write a program to compute the number of ways of constructing a tower of height n??1.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"f(1) = 1 f(2) = 2 f(3) = 4 f(4) = 8 f(n) = f(n-1) + f(n-2) + f(n-3) + f(n-4), n > 4 In matrix form: f(n)       1 1 1 1   f(n-1) f(n-1)     1 0 0 0   f(n-2) f(n-2)  =  0 1 0 0 * f(n-3) f(n-3)     0 0 1 0   f(n-4) while matrix multiplication could be done with O(logN)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I like your approach."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Could someone please explain the logic behind uuuouou's approach?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5713145616138240","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"5","title":"Create a data structure that has fast insertion, removal, membership testing, and random selection.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"LinkedList is fast for insertion and deletion except random selection. In this scenario I think HashTable may be appropriate."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Given object T which can return some unique key T.key(), maintain an Array object and a HashMap Store the object in the array and the index of the array in the hash table at the location T.key() . This gives you random access (via array), insert, and deletion in constant O(1) time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"An ideal solution would be to use HashTable + Doubly linked list.  In the hash table store value of element as key and its address as the hash value.(Just like LRU cache.)  The random selection part won't work in constant time though."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about a BST and a Hash map?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6274004188921856","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"19","title":"Write code to find the next least node in a binary search tree given a node?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"All answers so far are incorrect. What you are looking for here is the \"successor\" of the current node. For the given question, I assume all nodes have a pointer two its parent. Otherwise, we need a O(N^2) solution.  There are two cases:  (1) the current node has a right subtree (2) the right subtree of the current node is NULL.  For (1), the successor is the leftmost child of the right subtree For (2), we have to go up towards the root till we find a parent node, whose left subtree contains the current node.  Also, note that the node might be the largest element in the tree, and hence there is no successor. In this case, the code returns NULL.  here is the pseudo code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Climb the tree. Go to the node. See where the leaves are pointing. Go there and yes, you have found the solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The next least node is either the right child or the leftmost child in the right subtree"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public Node nextLeast(Node n) {  node left = n.left;  while (left.right != null) {   left = left.right;  }  return left; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"n.left?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \n \nusing namespace std; \n \ntypedef struct tree TREE; \n \nstruct tree { \n int val; \n struct tree *left; \n struct tree *right; \n}; \n \ntypedef struct tree TREE; \n \nTREE* makenode(int val) { \n  \n TREE* node = (TREE *)malloc(sizeof(struct tree *)); \n node->val = val; \n node->right = NULL; \n node->left = NULL; \n  \n return node; \n} \n \nint findNextLeast(TREE* root, int n){ \n  \n if(root == NULL) \n  return -1; \n  \n if(root->val == n) \n  return n; \n   \n int l = findNextLeast(root->left, n); \n if(l == n) \n  return root->val; \n  \n int r = findNextLeast(root->right, n); \n if(r != -1) \n  return r; \n  \n return -1; \n  \n} \n \nint main () { \n  \n TREE * root = makenode(10); \n root->left = makenode(5); \n root->right = makenode(15); \n  \n root->left->left = makenode(2); \n root->left->right = makenode(8); \n  \n root->right->left = makenode(12); \n root->right->right = makenode(17); \n  \n int ret = findNextLeast(root, 8); \n  \n if(ret != -1) \n  printf(\"\\nThe next least : %d\", ret);  \n  \n  \n  \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assume we have parent pointer to the node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can someone just explain what next least node means in simple words before giving any code. Giving an example is important even in interviews. It will also be helpful to people here. Thanks!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the solution should be to traverse the tree using inOrder traversal 1. Store this traversal in an array arr[] 2. get the element mentioned in the problem 3. The number at the position i-1 is the next least number.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node *getOneLastLeast(Node* root){    if(root == NULL)   return NULL;   if( heightBST(root->left) == 1)   return root;  else   return ( getOneLastLeast(root->left)); }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5089178136084480","download_status":"DOWNLOAD_DONE","votes":"-4","answersCount":"2","title":"why do you choose Amazon?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Want to work on maintaining their millions of lines of existing spaghetti code."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I want free prime card membership. And discounts!"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5179510290907136","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"6","title":"You are given an unsorted array of integers that contain duplicate numbers.   Only one number is duplicated odd number of duplications, other numbers are repeated even number of duplications.   Find this number.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Take XOR of all the numbers of array. Resulting number in XOR is the answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can do this in O(nlgn) by sorting the array and searching  To do it in O(n) I think you need O(n) extra space. You can use a hash map and then hash the numbers as you see. If the number is not present in the HashMap, you add it. If it is already present you remove it. In the end the only number remaining in the hash map will be the number you need."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"XOR all numbers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"XOR all the numbers and get the result in O(n) with no extra space"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"As the others pointed out, just use XOR. Example in Java"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The Logic Is if Number Is repated Even Number Of Times Then By Doing Xor It Becomes 0.But The Odd Number Times Element By Doing Xor It gives ItS value. #include int arr[]={5,4,3,3,4,1,1}; main() { int i,count=0; for(i=0;i<=6;i++) { count^=arr[i]; } printf(\" %d\",count); }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5151731381960704","download_status":"DOWNLOAD_DONE","votes":"-2","answersCount":"1","title":"Design a meeting scheduler. The solution I came up with was to create an array of intervals for each day, so if intervals is 15 mins, then array size would be 24*4. However, if interval is small, that will substantially increase the size of the array, and that might be considered as a waste of space, though it supports O(1) look up. I was wondering if there is any other way to do this. I think we might be able to keep a sorted array of meetings sorted by start time, so look up would be O(logn). But insertion in the middle of the array would take O(n) since it requires data shifting.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Intervals is not great. Probably good as initial point but what if I want a meeting from 11:14 exactly. So you probably want a BST for intervals."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5720778041458688","download_status":"DOWNLOAD_DONE","votes":"-2","answersCount":"10","title":"Design a meeting scheduler. One way is to use an array to represent each interval, like every 15 mins. Although it provides O(1) look up, if interval is small, it seems like we are wasting a lot of space. Any alternative approach that can save space? If we keep a sorted array of meetings sorted by start time, look up will be O(logn), but inserting the new meeting in the middle of the array will require shifting elements, which is O(n).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about bitmap approach ?  \n \nIf each slot is 30 minute, so there are 48 slots each day. In this case, long type variable (64 bits) is enough to mark meeting slots in whole day. We can use two long variable for each day. First long variable mark the start slot of one meeting, and second long variable mark the duration slot of that meeting, but keep start slot excluded since it's already marked in first long variable.  \n \nSuppose meeting A is from slot n (n is 0-based index) and duration m slots, so \n \n  begin_marker      = begin_marker OR (1<> 1 \n  meeting_marker = meeting_marker XOR (1 << n - 1) \n  meeting_marker = meeting_marker AND (begin_marker OR duration_marker) \n \nto check if two meetings collide \n \n  (meeting_marker_a AND meeting_marker_b) != 0 \n \nBy this way, only array long[7][2] is required for scheduling meeting within one week \n \n* idea only *"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A very simple idea would be to use an hashset, i.e., O(1) for both insertion and lookup. Time slotting need to be predefined, or it can be hard to nadle collision between a meeting starting at 9:01 vs a meeting starting at 9. So, if we decide resolution is half an hour, meeting 9-->10 would occupy two entries in hashSet (9_930 and 930_10).  Example in java below (well, not really much to do)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about a heap of start times. Gives O(lg n) insert and deletes. Not as fast as a hash-map though. But you can have meeting of any width."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"C++ implementation of Ankit's way  insert o(lgN) lookup o(1) delete o(lgN)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.io.ObjectInputStream.GetField; \nimport java.util.HashMap; \nimport java.util.Map; \nimport java.util.Set; \nimport java.util.TreeSet; \n \n \npublic class MeetingSchedular { \n \n /** \n  * @param args \n     *Design a meeting scheduler. One way is to use an array to represent each interval,  \n     *like every 15 mins. Although it provides O(1) look up, if interval is small,  \n     *it seems like we are wasting a lot of space. Any alternative approach that can save space?  \n     *If we keep a sorted array of meetings sorted by start time, look up will be O(logn),  \n     *but inserting the new meeting in the middle of the array will require shifting elements, which is O(n). \n  */ \n  \n Set meetingShedularSet=new TreeSet(); \n Map map=new HashMap(); \n  \n  \n public static void main(String[] args) { \n  // TODO Auto-generated method stub \n  MeetingSchedular ms=new MeetingSchedular(); \n  ms.addMeeting(new Meeting(900, 1000)); \n  ms.addMeeting(new Meeting(1030, 1100)); \n  ms.addMeeting(new Meeting(1101, 1130)); \n  ms.addMeeting(new Meeting(1131, 1245)); \n  ms.addMeeting(new Meeting(1105, 1145)); \n  ms.addMeeting(new Meeting(1205, 1345)); \n   \n  Meeting meeting=ms.getMeeting(900, 1000); \n  if(meeting!=null) \n  { \n  System.out.println(\"Meeting is sheduled at : \"+meeting.getStartTime()); \n  } \n  else \n  { \n   System.out.println(\"Meeting does not exist\"); \n  } \n   \n   \n \n } \n  \n public void addMeeting(Meeting meeting) \n { \n  if(!meetingShedularSet.contains(meeting)) \n  { \n  meetingShedularSet.add(meeting); \n  map.put(String.valueOf(meeting.getStartTime()+meeting.getEndTime()), meeting); \n  } \n  else \n  { \n   System.out.println(\"Meeting with start time :\"+meeting.getStartTime()+\" and end time :\"+meeting.getEndTime()+\" is conflicting with other meeting\"); \n  } \n } \n  \n public Meeting getMeeting(int startTime,int endTime) \n { \n  return map.get(String.valueOf(startTime+endTime)); \n } \n \n} \n \n \nclass Meeting implements Comparable \n{ \n private Integer startTime; \n private Integer endTime; \n  \n  \n Meeting(int startTime,int endTime) \n { \n  this.startTime=startTime; \n  this.endTime=endTime; \n } \n \n \n public Integer getStartTime() { \n  return startTime; \n } \n \n \n public Integer getEndTime() { \n  return endTime; \n } \n \n \n @Override \n public int compareTo(Meeting o) { \n \n  if(o.getStartTime().compareTo(this.endTime)>0) \n  { \n   return 1; \n  } \n  else if(o.getEndTime().compareTo(this.startTime)<0) \n  { \n   return -1; \n  } \n  else \n  { \n  return 0; \n  } \n } \n  \n  \n  \n  \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6557932665700352","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"Given a binary tree, convert it into another binary tree whose in-order representation would have its elements listed in sorted order","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"A binary search tree already has the property that an in-order traversal will give elements in sorted order.  So, all we need to do here is to take the given binary tree and convert it into a BST. Do a DFS or BFS of given binary tree, and for each node encountered place them into the new BST."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If you want to maintain the structure of the Tree do the following..  1) Perform any traversal on the Binary tree and store the elements in array. 2) Sort the array. 3) Do a inorder traversal and copy the elements in the array to the tree..  This will create a BST maintaining the structure of the tree..  Complexity : O(n log n) - sorting."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"covert binary tree to BST. Inorder traversal of BST gives element in sorted order."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There are two ways of doing this. If memory is not an issue, traverse the tree, put all elements into an array, sort and then put the elements into a BST. If memory is a little constrained, add all elements into the BST directly. Both approaches are in O(nlogn) but the former should be a bit faster and the BST could be made balanced without self-balancing. O(nlogn) should be the best complexity for this question as well."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4900350167351296","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"18","title":"Given a binary search tree of n nodes, find all the pair of  nodes whose sum is equal to a given number k in O(n) time and constant space.(algo+code)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"The problem itself is tricky, it says constant space but doesn't require it to be storage efficient.   The solution is:   int maxValue = tree.getMaxValue() // by keeping visiting right most branch  int[] array = new int[maxValue] // not storage efficient for each node value in the tree, set array[value] = 1 // O(n)  for each node value in the tree, check whether array[K-value] exists. If exists, print the pair. // O(n)  Thus the solution is O(n) and the storage is a constant value depending the largest node value."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"1) convert the given BST into an sorted array A with in-order traverse, 2) two index (i=0, j=arraysize-1) 3) loop over: 3.a) if A[i]+A[j]>k => j--; 3.b) if A[i]+A[j] i++; 3.c) output (i,j)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ok, if we can modify the input BST, we can first convert it into a double linked list, and do the same. the time complexity will be O(n), and space O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would say this cannot be done in O(n).  It is necessary that we examine each element and look for existence of its pairs that sums to k. It would take O(n) just to go through each element. In my view, the best possible is O(nlog n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"delete not good."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why do we need a sorted array in this case?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In-order traversal of BST sorts data in ascending order as A B C D E F G if you 1. Traverse the left subtree. 2. Visit the root. 3. Traverse the right subtree.   and you can sort it in deciding order G F E D C B A if you 1. Traverse the right subtree. 2. Visit the root. 3. Traverse the left subtree.  it can be done without recursion so you can imagine we've got a sorted array A B C D E F G and we have pointers/reference at head and tail, and we can use them to traverse across 'virtual' array to find  pair of nodes whose sum is equal to a given number k  time complexity is O(n) and space complexity is O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Improving on zouzhile's idea, 1 we can create an array A of size k  2. Initialise the array with null 2. Do an inorder traversal of the tree (O(n))till a node with value k or greater than k arrives. And setting the array A[node.value] = 1 (or a pointer to the node using perhaps a hashmap) 3. Traverse the array and for each A[i]!=null, find if A[k-i] is null. If not null then, then we have a pair and from this pair of indices of A, we can get the nodes. Runtime is O(n) and space is constant with respect to k."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5001071982280704","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"Rotate a 2-D Matrix by 90 degrees","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Does it mean \"Transpose of a matrix\" ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming a (n x n ) matrix This is simple solution but not necessarily intuitive ... The steps are for a clockwise rotation:  1. Transpose the matrix  2. Swap column i with column (n-i)  Reason - When you rotate a matrix (let's say clockwise) you are moving the first row to last column , second row to second last column and likewise and when you transpose a matrix , you are moving the first row to first column ,                     second to second and likewise so all you have to do after transposing the matrix is just swap the first column with last and second with second last and so on Time Complexity - O(n2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First of all the Matrix has to be nxn (square) M[n][n]  This can be done in a simpler repetition of the step  for outermost to innermost ring (n/2 rings)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int a[5][5] = { {1,2,3,4,5}, {6,7,8,9,10}, {11,12,13,14,15}, {16,17,18,19,20}, {21,22,23,24,25} }; \n \n int n = 5; \n for(int i=0; i"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5752609117831168","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"Print all the cycles in a directed graph","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This can be done by doing a DFS of the directed graph where you maintain these attributes while doing the DFS: 1) Previsit numbers for nodes, the clock value when you are about to visit a node 2) Postvisit numbers for nodes, the clock value when you are leaving the node after it has been explored 3) Parent/Ancestor information. For every node, record its ancestor/parent as you do the DFS.  Directed graphs have the property that cycles are always found when DFS reveals a back-edge. A back-edge means that if you are looking at an edge (u,v) during traversal, you will see that (pre, post) pair for u is contained within (pre, post) pair of v.  Whenever you spot a back-edge during DFS, just use parent information to back-trace the cycle."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do a DFS of directed graph. Maintain these attributed while doing DFS, - previsit numbers for nodes - postvisit numbers for nodes - parent/ancestor information for nodes  Directed graph has cycles where DFS reveals back-edges. Back edges means when you have an edge (u,v) such that (pre,post) pair of u is contained in that of v.  Whenever you get a back edge, use parent information to back-trace the cycle."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can generate the minimum spanning tree (MST) of the graph, which is rather simple with BFS. Any graph edges not in the MST is possible to introduce a cycle.   For each edge not in MST, let source_vertex be the source of the edge, and end_vertex be the end of the edge. If end_vertex is ancestor of source_vertex, then there is a loop between source_vertex and end_vertex. The loop can be identified by calling getParent() from source_vertex, until meet the end_vertex."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"my earlier comment about MST is not right.   The following code is tested to work well."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6214111943720960","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"14","title":"Given n, find the smallest number for which product of the digits is n, if no such number exists, print -1","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"int getnumber(int n) \n{ \n    if(n==0|| n==1) \n       return -1; \n    int i=9; \n    int num=0; \n    int pow=1; \n    while(i>0) \n    { \n        while(n%i==0 && i>1) \n        { \n           num=i*pow + num; \n           pow=pow*10; \n           n=n/i; \n        } \n        i--; \n    } \n    if(n!=1) \n       return -1; \n    return num; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I hav idea how to decide whether we can do it or not. We need to factorize number in prime factors. If among of themat least one prime that is greater than 10 - we cannot do it ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Factor n into primes (assuming n is not an RSA kind of number). The simplest and most obvious number whose digits multiply to give n is simply these primes concatenated.  However, we need to find the smallest number. So, for that we will need to multiply all pairs of 2's, 2's and 3's and pairs of 3's. This is because only these are less than 10: 2*2=4, 2*3=6, 3*3=9. Once, we have multiplied all such pairs, we just need to check for any primes > 7. If no such prime, we just arrange the digits in ascending order and get the smallest number.  example: lets say n=2520=2*2*2*3*5*7*3, then we can group this as (2*2), (2*3), 5,7,3. Sort the digits to give 34567."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Instead of factoring the number, all we need to do, is to check whether the number can be formed by a combination of 2,3,5,7  (since no other prime number like 11,13 can be represented as a single digit)  So we go ahead , get the maximum power of 2 in the number, let's say w. similarly we go ahead with 3,5 ,7 , and let's say we get x,y,z and then if (2^w )*(3^x)*(5*y)(7^z) == number itself, the smallest number would be (2222....) w times ...(3333...) x times (5555....)y times (777...)z times  else print -1  Worst case time complexity - O(logn)  Wonder if we can optimize it further ...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include   int main() {  int test;  scanf(\"%d\",&test);    for(int i=0;i   {       long long int n;       scanf(\"%lld\",&n);              int A[10]={0};              for(int j=9;j>0;j--)         {          if(n==1)            break;                      while(n%j==0)            {               A[j]++;               n/=j;            }         }                if(n>1)       {        printf(\"-1\\n\");        continue;       }             for(int j=2;j<10;j++)    {     while(A[j]>0)       {         A[j]--;         printf(\"%d\",j);       }    }          printf(\"\\n\");      } return 0;    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \nint main() \n{ \n int test; \n scanf(\"%d\",&test); \n  \n for(int i=0;i0;j--) \n        { \n         if(n==1) \n           break; \n            \n         while(n%j==0) \n           { \n              A[j]++; \n              n/=j; \n           } \n        } \n         \n      if(n>1) \n      { \n       printf(\"-1\\n\"); \n       continue; \n      } \n      \n      for(int j=2;j<10;j++) \n   { \n    while(A[j]>0) \n      { \n        A[j]--; \n        printf(\"%d\",j); \n      } \n   }   \n       printf(\"\\n\");   \n   } \nreturn 0;    \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int product() {  int i,j,k, test, temp,temp1 = 1, remain, factor=0, found = 0;  int A[10]={0};   printf(\"enter the number \\n\");  scanf(\"%d\",&test);    temp = test;  i = 9;  j = 0;   while (i>= 2)  {   factor = 0;   while((temp%i == 0) && (temp > 0))   {    factor = 1;    A[j] = i;    printf(\"filling is A[%d] is %d \\n\", j,A[j]);    j++;    temp /= i;   }   temp1 = 1;   if (factor)   {    k = j-1;     for (; k>=0; k--)    {     printf(\"factor at A[%d] is %d \\n\", k,A[k]);     temp1 *= A[k];     if (temp1 == test)     {      printf(\"factor found %d \\n\", temp1);      found = 1;      break;     }    }   }      if (found)    break;   temp = test;   i--;      }     j--;   if (found)  {   for (; j>=0; j--)   {    printf(\"factor is A[%d] is %d \\n\", j,A[j]);   }  }else  {   printf(\"factor is not found \\n\");   return -1;  }  return 0;    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is the code I came up with, to print the smallest number with the digits product equal to the number."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6305783725686784","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"6","title":"Given an array of integers (+ve and -ve), give a contiguous set of numbers that add to 1 Eg. 4 3 5 -3 -1 2 -3 10 2 Ans: 5 -3 -1 2 -3","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Are you sure that example is correct? 5-3-1+2-3 = 0, not 1.  Anyway, one possible solution is to maintain a HashSet of partial sums. Partial sum is defined as follows: partial_sum[0] = 0 partial_sum[i] = input[0] + input[1] + ... + input[i-1]  Notice that in order to find a sub-array whose elements sum to a given number k, it would suffice to find 0<=i<=input.length such that:  k = partial_sum[j] - partial_sum[i] = input[i] + input[i+1] + ... + input[j-1]  This is equivalent to finding an index ipartial_sum[i] = partial_sum[j] - k  Using this observation, iterate over the input array and maintain the following: 1. Current partial sum (partial_sum[i+1]) where i is the current index 2. A HashSet of the previous partial sums: hashset = {partial_sum[0], partial_sum[1],...,partial_sum[i]}. At the end of each iteration we add the current partial sum to the hashset.  During each iteration, check whether the hashset contains partial_sum[j+1]-k. If it does then all that's left is to find an appropriate index i such that:  partial_sum[i] = partial_sum[j+1] - k and return the sub-array from i to j.  Notice the found i will satisfy i<=j because of (2) above.  Complexity: O(n) average run-time complexity with O(n) space complexity."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Typical DP problem, by the way, do you need the longest sequence, or anyone is fine. If no longest constraint, the python code below could solve the problem:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"stackoverflow.comquestions5534063zero-sum-subarray  you could subtract 1 from all elements and search for the largest zero subarray :)  I guess it should be O(n), but i haven't coded it yet"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5667426494578688","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"Write a function which checks a Red-Black-Tree that the max depth isn't > than 2* min depth. It must return a boolean.  boolean checkdepth(){}  no class variables","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool is_balanced(Node* node, int& depth) \n{ \n if( !node ) return true; \n \n int left=depth, right=depth; \n is_balanced(node->left, left); \n is_balanced(node->right, right); \n depth = max(left,right)+1; \n \n return abs(left-right)<2; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool IsBalanced(Node root) \n{ \n int max = MaxDepth(curr); \n int min = MinDepth(curr); \n \n return max/min < 2; \n} \n \nint MaxDepth(Node curr) \n{ \n if(curr == null) return 0; \n \n return Math.Max(MaxDepth(curr.Left) + 1, MaxDepth(curr.Right) + 1); \n} \n \nint MinDepth(Node curr) \n{ \n if(curr == null) return 0; \n \n return Math.Min(MinDepth(curr.Left) + 1, MinDepth(curr.Right) + 1); \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5125659319861248","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"37","title":"Shopkeeper want sells in the packs of 20,9 and 6. Given an n, you need to find whether its possible to buy the items or not.For example n=21, you can buy 2 packs of 6 and one pack of 9(2*6 + 9)  Output 1 if possible and 0 if not  Test cases: 1) n=47 ==> possible, output = 1 2) n=7  ===> not possible, output = 0","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"dp"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"this problem can be solved in constant time.  the trick is to note that, if there is a solution, there would be a solution in which the number of 9s is either 0 or 1, and the number of 20s will be 0, 1, or 2. the rest will be all 6s.  reason: any set of three 20s can be substituted by 10 of 6s. any two 9s can be substituted by three 6s.  so, we consider the six cases of 0-1 pack of 9s and 0-2 pack of 20s and see if the rest is divisable by 6.  o(1) time o(1) space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use dynamic programming.  Given N packs and M items (N=3 and M=21 in the above example),  construct a boolean matrix A of size (N+1, M+1). A[i][j] is true if A[i][j-1] is true or A[i-packs[k]][j] is true for any k \\in N  The solution takes O(N^2M) time O(NM) space"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/*Shopkeeper want sells in the packs of 20,9 and 6.  \nGiven an n, you need to find whether its possible to buy the items or not. \nFor example n=21, you can buy 2 packs of 6 and one pack of 9(2*6 + 9)  \nOutput 1 if possible and 0 if not */ \n \nTest cases:  \n1) n=47 ==> possible, output = 1  \n2) n=7 ===> not possible, output = 0 \nclass assign2 \n{ \n  public static void main(String[] x) \n  {  int j=  calculate(x[0]); \n        System.out.println(j); \n  } \n  public static int calculate(String str) \n  {       int i=Integer.parseInt(str); \n          int count6=0,count20=0,count9=0; \n          count6=i/6; \n           int n=i%6; \n        if(n==0) \n        { \n            \n     return 1; \n        } \n        else \n        { \n            \n            switch(n) \n        { \n             \n            case 1: if(count6>8) \n            { \n              count6=count6-8; \n              count20=2; \n              count9=1; \n              return 1; \n           } \n            else \n            { \n            return 0; \n            } \n            \n            case 2: \n              if(count6>3) \n            { \n              count6=count6-3; \n              count20=1;count9=0; \n              return 1; \n            } \n            else \n            { \n            return 0; \n            } \n            \n            case 3:if(count6>1) \n            { \n               count6=count6-1; \n               count9=1; \n               count20=0; \n                 return 1; \n            } \n              else \n              { \n              return 0; \n              } \n            \n            case 4: \n              if(count6>9) \n            { \n              count6=count6-9; \n              count20=1; \n              count9=0; \n     return 1; \n            } \n              else {return 0;} \n            \n               \n            case 5:  if(count6>4) \n            { \n                     count6=count6-4; \n                     count20=1; \n                     count9=1; \n                    return 1; \n            } \n            else \n            { \n                return 0; \n            } \n        } \n     } \n  return 0; \n} \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Recursive solution. Little bit easier to understand."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void check(N){ \nint N=21; \nfor (int i=0; i<=N/9+1; i++) \n    for (int j=0; i<=N/6+1; i++) \n        for (int k=0; i<=N/20+1; i++) \n            if (i*9+j*6+k*20==N){ \n                cout<<<\",\"<<<\",\"<<<<\"Output: 1\"; \n  return; \n            } \ncout<<\"output: 0\"<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A python recursive solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int canBuy(int n){ \n vector dp(n+1, 0); \n vector packs{6,9,20}; \n dp[0]=1; \n for(int i=0; i<=n; i++) \n  for(vector::iterator itr=packs.begin(); itr!=packs.end(); itr++){ \n   if(i-*itr < 0) \n    break; \n   if(dp[i-*itr] == 1) \n    dp[i]=1; \n  } \n return dp[n]; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A greedy approach O(n) time O(1) space :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"dp"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How did you approach this solution??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static boolean isFeasible(int[] items, int value) {          if(value < 0)              return false;          if(value == 0)              return true;          boolean total = false;          for(int i =0 ;i             total |= isFeasible(items, value - items[i]);         }          return total;      }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is not a general solution and only works in this case. Coded in C/C++."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A simple recursive solution . It is like a*pack1 + b*pack2 + c*pack3 = n .   Here is complete code   #include"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.LinkedList; \n \n//shopkeeper wants to sell only in weights of 20,9 and 6 \n \npublic class SetOfWeights { \n  \n  \n public void findWeights(int totWeight) \n { \n  LinkedList maxWeight=new LinkedList(); \n  LinkedList midWeight=new LinkedList(); \n  LinkedList minWeight=new LinkedList(); \n   \n  int weight1=20,weight2=9,weight3=6; \n   \n  int multiple=0; \n  \n  int i1=0; \n  while(totWeight>multiple) \n  {   \n   maxWeight.add(multiple); \n   i1++; \n   multiple=weight1*i1; \n  } \n  multiple=0;i1=0; \n  while(totWeight>multiple) \n  {   \n   midWeight.add(multiple); \n   i1++; \n   multiple=weight2*i1; \n  } \n  multiple=0;i1=0; \n  while(totWeight>multiple) \n  {   \n   minWeight.add(multiple); \n   i1++; \n   multiple=weight3*i1; \n  } \n   \n  //display(); \n  for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Many of the solution here used 3 for loops .. using them here is ok, because we know we have 3 options 20,9,6  What if we have large set of options then making that no of for loops will not be a good solution.   Better use recursion or backtracking algo:  Hint of backtracking ....  we should make logic which runs like:  20, 9, 6         20, 9, 6, 6         ... till this sum <= desired value when all combination with one 20 and one 9 are over then work for   20, 9 , 9 , 6  20, 9 , 9 , 6, 6 ...   and so on ... till we get valid sum or all over options get exhausted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A Python iterative solution with two loops. The solution has O(nm) runtime and O(n) space complexity where  n: amount being tested m: number of possible values for the packs"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include using namespace std; class M {     private:         int flag;     public:         M() {             flag=0;         }                  void shoekeeper(int n) {             if (n==0) {                 flag=1;                 return;                 } else {                 if (n<0) {                     return;                 }                 shoekeeper(n-20);                 shoekeeper(n-9);                 shoekeeper(n-6);             }         }                            int getFlag() {             return flag;         }    }; int main() {     M n;     n.shoekeeper(7);     if (n.getFlag()) {         cout<<\"YES\"<    } else {         cout<<\"NO\"<    }     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Stack; public class Backtrack {   static Stack stack= new Stack();  static int[] options = {6, 9, 20};    public static boolean recurse(int remainder) {   if(remainder == 0) {    return true;   }   if(remainder < options[0]){    return false;   }      boolean value = false;   for(int i:options) {    stack.push(i);    value = recurse(remainder-i);    if(value)     break;    stack.pop();   }   return value;  }    public static void main(String[] args) {   System.out.println( recurse(47) );   System.out.println( recurse(7) );  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include using namespace std ;  int createOrder(const int iOrder, map & iOrdertodelivered) {  map l_storedorder;  int l_order = iOrder;  int count20 = 0 ,count9 = 0 ,count6 = 0;  do{   // check it is multiple of gieven packs   if( (l_order%20 ) == 0)   {        count20 = count20+(l_order/20);    break;   }   if( (l_order%9) == 0)   {    count9 = count9+(l_order/9);    break;   }      if( (l_order%6) == 0)   {    count6 = count6+(l_order/6);    break;   }         // Now atart with 6 if it has reminder    if(l_order > 6 )   {    l_order = l_order -6;    count6++;    if(l_order > 9 )    {     l_order = l_order -9;     count9++;     if(l_order > 20)     {            l_order = l_order -20;      count20++;     }    }   }   else   {    return -1;   }     }while(1);    // fill the sequence   if(count20 > 0)  {   l_storedorder.insert(std::pair(20,count20));  }  if(count9 >0 )  {   l_storedorder.insert(std::pair(9,count9));  }  if(count6 > 0)  {   l_storedorder.insert(std::pair(6,count6));  }  iOrdertodelivered = l_storedorder;  return 0; } int main(int argc, char *argv[]) {  int l_order =0;  map l_storedorder;  cout<<\"Enter order made to shopkeeper\"< cin>>l_order;    // Now shopker only deliver order in the form of 30 9 and 6 packs   cout<<\"user ordered  \"<<   int rc = createOrder(l_order,l_storedorder);  if(rc == 0)  {   // print map to find order   cout<<\" Order Successful : Breakup \"<  std::map::iterator  it = l_storedorder.begin();   cout<<\"Packs\"<<\"     \"<<\"Quantity\"<  for(;it != l_storedorder.end();++it)   {    cout<<\"  \"<first<<\"           \"<second<  }  }  else  {   cout<<\"Invalid Order \"< }  return 0;   }  Result :  nitesh@nitesh-PC ~ # ./a Enter order made to shopkeeper 21 user ordered  21  Order Successful : Breakup Packs     Quantity   6           2   9           1  nitesh@nitesh-PC ~ # ./a Enter order made to shopkeeper 47 user ordered  47  Order Successful : Breakup Packs     Quantity   6           3   9           1   20           1  nitesh@nitesh-PC ~ # ./a Enter order made to shopkeeper 47 user ordered  47  Order Successful : Breakup Packs     Quantity   6           3   9           1   20           1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"x, y, z, n >= 0 20x + 9y + 6z = n > 21x + 9y + 6z = n + x > 7x + 3y + 2z = (n + x) / 3 because 3y + 2z >= 0 and <>1 So calculate x = 0, x = 1, x = 2 > if (n+2) % 3 = 0, n >=40, n <> 43. return true if (n+1) % 3 = 0, n >=20, n <> 23. return true if n % 3 = 0, n <> 3. return true other return false"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"def possible(number): \n        number = int(number) \n        print number \n        if number == 0: \n                return 1 \n        if number < 6: \n                return 0 \n        if number%6 == 0 or number%9 == 0 or number%20 == 0: \n                return 1 \n        if number >= 20: \n                number = number - 20 \n                return possible(number%20) \n        if number >= 9: \n                number = number - 9 \n                return possible(number%9) \n        if number >= 6: \n                number = number - 6 \n                return possible(number%6) \n        return 0"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4864707844374528","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"13","title":"Given a string, rearrange the string to a palindrome and return the palindrome if present or -1 Example: i/p  abb ab o/p bab -1","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"the idea is:  1) build a Map where K = char present in String, V = num. of occurrences of char 2) validate if palindrome can be generated by rule: all counts for each char must be even, except 1 char that can have an odd count of occurences. 3) if palindrome can be generated, build a new string distributing each group of chars at the start and end of string, if there is an odd count of a specific char C place C at the middle of String, and distribute the remaining. 4) return resulting string.  Solution in Java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Consider 2 cases: 1) String contains odd number of characters. Then the number of all characters in the string should be even except one character which is located in the middle. 2) String contains even number of characters. Then all characters should be even.  For simplicity I assumed that there are only English capital letters. If not its minor fix to change it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public String arrange(String value) {         char[] data = value.toCharArray();          // check the char value range         char largestChar = data[0];         char smallestChar = data[0];         for(char curr : data) {             if(curr > largestChar)                 largestChar = curr;             if(curr < smallestChar)                 smallestChar = curr;         }   int[] counters = new int[largestChar - smallestChar + 1];          // generate the char counters   for(char curr : value.toCharArray()) {    int index = curr - smallestChar;    counters[index] ++;   }          // detect palindrome by assigning the palindrome array symmetrically   char[] palindrome = new char[value.length()];         int palindromeOffset = 0; // point to next used space   for(int i = 0; i < counters.length; i ++) {    char charValue = (char) (smallestChar + i);             int count = counters[i];             if(count % 2 == 0) {                 // the amount of current char is even number                                  // symmetrically set the char in palindrome                 count /= 2;                 while(count > 0) {                     palindrome[palindromeOffset] = charValue;                     palindrome[palindrome.length - palindromeOffset - 1] = charValue;                     palindromeOffset ++;                     count --;                 }             } else {                 // the amount of current char is odd number                 if(palindrome.length % 2 == 0 || palindrome.length % 2 == 0 && palindrome[palindrome.length/2] != 0)                     // palindrome's length is even number                     // or palindrome.length is odd number, the only central char has been occupied                     // (palindrome only allows on char is in odd number)                     return null;                 palindrome[palindrome.length/2] = charValue;                  // symmetrically set the char in palindrome                 count /= 2;                 while(count > 0) {                     palindrome[palindromeOffset] = charValue;                     palindrome[palindrome.length - palindromeOffset - 1] = charValue;                     palindromeOffset ++;                     count -- ;                 }             }    }   return new String(palindrome);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public String arrange(String value) { \n        char[] data = value.toCharArray(); \n \n        // check the char value range \n        char largestChar = data[0]; \n        char smallestChar = data[0]; \n        for(char curr : data) { \n            if(curr > largestChar) \n                largestChar = curr; \n            if(curr < smallestChar) \n                smallestChar = curr; \n        } \n        int[] counters = new int[largestChar - smallestChar + 1]; \n \n        // generate the char counters \n for(char curr : value.toCharArray()) { \n  int index = curr - smallestChar; \n  counters[index] ++; \n } \n \n        // detect palindrome by assigning the palindrome array symmetrically \n char[] palindrome = new char[value.length()]; \n        int palindromeOffset = 0; // point to next used space \n for(int i = 0; i < counters.length; i ++) { \n     char charValue = (char) (smallestChar + i); \n            int count = counters[i]; \n            if(count % 2 == 0) { \n                // the amount of current char is even number \n                 \n                // symmetrically set the char in palindrome \n                count /= 2; \n                while(count > 0) { \n                    palindrome[palindromeOffset] = charValue; \n                    palindrome[palindrome.length - palindromeOffset - 1] = charValue; \n                    palindromeOffset ++; \n                    count --; \n                } \n            } else { \n                // the amount of current char is odd number \n                if(palindrome.length % 2 == 0 || palindrome.length % 2 == 0 && palindrome[palindrome.length/2] != 0) \n                    // palindrome's length is even number \n                    // or palindrome.length is odd number, the only central char has been occupied \n                    // (palindrome only allows on char is in odd number) \n                    return null; \n                palindrome[palindrome.length/2] = charValue; \n \n                // symmetrically set the char in palindrome \n                count /= 2; \n                while(count > 0) { \n                    palindrome[palindromeOffset] = charValue; \n                    palindrome[palindrome.length - palindromeOffset - 1] = charValue; \n                    palindromeOffset ++; \n                    count -- ; \n                } \n            } \n \n } \n return new String(palindrome); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorry for the first submit where the code whitespaces are totally messed up."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n) time and O(n) space"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Some c# code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include int arr[256]; void main() {  char str[50],index;  int i,j=0,len,k=0,oddcount=0;    scanf(\"%s\",str);  len=strlen(str);  for(i=0;i  arr[str[i]]++;   for(i=0;i<256;i++)  {  if(arr[i]%2!=0)  {  oddcount++;  index=(char)i;  }  }  if((len%2==0 && oddcount==0) || (len%2!=0 && oddcount==1))   {       (oddcount==1)?str[len/2]=index:printf(\"\\n\");       for(i=0;i<256;i++)       {   if(arr[i]>0)   {    for(j=0;j   {      str[k]=str[len-1-k]=(char)i;      k++;    }    }        }       printf(\"\\n String is : %s\",str);   }else   printf(\"sorry can't make palindrome\"); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public String getPalindrome(String s) { \n if (s == null) \n  return null; \n Map letters = new HashMap(); \n for (int i = 0; i < s.length(); i++) { \n  char c = s.charAt(i); \n  if (!letters.containsKey(c)) \n   letters.put(c, 1); \n  else \n   letters.put(c, letters.get(c) + 1); \n } \n char[] result = new char[s.length()]; \n int i = 0, j = result.length - 1; \n Character middle = null; \n for (Entry e : letters.entrySet()) { \n  int val = e.getValue(); \n  char c = e.getKey(); \n  if (val % 2 != 0) { \n   if (middle == null && s.length() % 2 != 0) { \n    middle = c; \n    val--; \n   } else \n    return \"-1\"; \n  } \n  for (int k = 0; k < val / 2; k++) { \n   result[i++] = c; \n   result[j--] = c; \n  } \n } \n if (middle != null) \n  result[result.length / 2] = middle; \n return new String(result); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sort the string and swap contiguous elements to the beginning and to the end. Complexity  O ( N long N ) + O ( N )  Space complexity  O ( 2N )"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.HashMap; \nimport java.util.Set; \n \npublic class ReArrangeToPalindrome { \n \n HashMap hmp = new HashMap(); \n \n public void isPalindromePossible(String str) { \n  int i = 0; \n  char[] ch = str.toCharArray(); \n  if (ch.length == 0) { \n   System.out.println(\"Empty String\"); \n   return; \n  } else if (ch.length == 1) { \n   System.out.println(\"---PalinDrome---\"); \n   return; \n  } \n \n  while (i != ch.length) { \n \n   if (hmp.containsKey(ch[i])) { \n    hmp.put(ch[i], hmp.get(ch[i]) + 1); \n   } else { \n    hmp.put(ch[i], 1); \n   } \n   i++; \n  } \n \n  findPalinDrome(); \n \n } \n \n public void findPalinDrome() { \n  Set ch1 = hmp.keySet(); \n  int k = 0; \n  for (Character ch : ch1) { \n \n   if (hmp.get(ch) % 2 == 0) { \n \n   } else { \n    k++; \n    if (k % 2 == 0) { \n     System.out.println(\"---No Palindrome---\"); \n     return; \n    } \n \n   } \n \n  } \n  System.out.println(\"---PalinDrome---\"); \n \n } \n \n public static void main(String[] args) { \n \n  ReArrangeToPalindrome rp = new ReArrangeToPalindrome(); \n  String str = \"axcdbcacba\"; \n  rp.isPalindromePossible(str); \n \n } \n \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5627358342021120","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"11","title":"Write a routine to reverse every k nodes in a given linked list without using additonal memory.  input : 1,2,3,4,5,6   k:3 output : 3,2,1,6,5,4","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the function that works with a LinkedList class that I implemented."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void reverse_every_k(Node*& head, int k) \n{ \n Node *prev, *cur, *tmp, *new_head; \n prev = NULL;  cur = head; \n while( cur ) { \n  *tmp_prev = prev;  \n  Node *tmp_tail = cur;    \n   \n  int cnt = k; \n  while( cnt>0 ) { \n   tmp = cur->next; \n   cur->next = prev; \n   prev = cur; \n   cur = tmp; \n   cnt--; \n   if( !cur ) break; \n  } \n   \n  if( !tmp_prev )  \n   new_head = prev; \n  else  \n   tmp_prev->next = prev; \n \n  tmp_tail->next = cur; \n  prev = tmp_tail; \n } \n head = new_head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node* reverseKnodes(Node *curnt, int k){ \n    Node *temp = NULL; \n    Node *prev = NULL; \n     \n    while(curnt != NULL && k > 0){ \n        temp = curnt ->next; \n        curnt->next = prev; \n        prev = curnt; \n        curnt = temp; \n        k--; \n    } \n     \n    temp = prev; \n     \n    while(temp->next != NULL) \n        temp = temp->next; \n    temp->next = curnt; \n    curnt = prev; \n    return curnt; \n} \n \n \nNode* ReverseSpecial(Node *n, int k){ \n    Node *head = n; \n    Node *tail = n; \n     \n    int i = 0; \n    while(n != NULL && i < k){ \n        n = n->next; \n        if(i < k - 1) \n            tail = tail->next; \n        i++; \n    } \n     \n    if(n != NULL) \n        tail->next = ReverseSpecial(n, k); \n     \n    head = reverseKnodes(head, k); \n     \n    return head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private LinkedListNode Reverse(LinkedListNode head, int k) \n        { \n            LinkedListNode current = head; \n            LinkedListNode last = null; \n            int i =0; \n            while(current != null) \n            { \n                i++; \n                if(i%k == 0) \n                { \n                    head.Next = Reverse(current.Next, k); \n                    break; \n                } \n \n                LinkedListNode next = current.Next; \n                current.Next = last; \n                current = next; \n            } \n            return current; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public Node reverse(Node head, int k) { \n        // after reverse, the return node is \n        // the last node in the first K nodes in the original list \n        // which is also the head node in the reversed list \n        Node returnNode = null; \n \n        // for the ith K sub list, the two \"previous\" pointers \n        // would point to the (i-1)th K sub list's head and tail \"after\" reverse \n        // This means, after reversing 3,2,1, previousTail points to 3 and previousHead points 1 \n        Node previousTail = null; \n        Node previousHead = null; \n \n        while(head != null) { // not reached the end of the list \n            Node tail = head; \n            for(int i = 1; i < k & tail.next() != null; i ++) { \n                tail = tail.next(); \n            } \n            Node nextHead = tail.next(); \n            reverse(head, tail); \n            if( previousHead == null || previousTail == null) { \n                // first K sub list \n                previousHead = tail; \n                previousTail = head; \n                returnNode = tail; \n            } else \n                previousTail.setNext(tail); \n \n            head.setNext(nextHead); \n            head = nextHead; \n        } \n        return returnNode; \n    } \n \n    private Node reverse(Node current, Node tail) { \n        if(current == tail) { \n            return current; \n        } \n \n        Node next = reverse(current.next(), tail); \n        next.setNext(current); \n        return current; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static Node reverseList (Node head, int k) { \n    Node ret_value = null; \n \n    int counter = 0; \n    Node previous = null; \n    Node headSequence = head; \n    while (head != null) { \n        counter++; \n        if ( counter <= k) { \n            Node next = head.next; \n            head.next = previous; \n            previous = head;  \n            head = next; \n        } else { \n            counter = 0; \n            headSequence.next = head; \n            if ( !ret_value ) \n  ret_value = previous; \n            previous = null; \n        } \n    } \n     \n    return previous; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct node * reverse(struct node *head) \n{ \n     struct node *p=(struct node *) malloc(sizeof(struct node)); \n     struct node *q=(struct node *) malloc(sizeof(struct node)); \n     struct node *temp=(struct node *) malloc(sizeof(struct node)); \n     temp=head; \n     p=head->next; \n     head->next=NULL; \n     while(p!=NULL) \n     { \n         q=p->next; \n         p->next=head; \n         head=p; \n         p=q; \n     } \n     return temp; \n} \n \nvoid revert(struct node *head,int k) \n{ \n     int counter=0,found=0; \n     struct node *p=(struct node *) malloc(sizeof(struct node)); \n     struct node *q=(struct node *) malloc(sizeof(struct node)); \n     struct node *start=(struct node *) malloc(sizeof(struct node)); \n     while(head!=NULL) \n     { \n          p=head; \n          while(counter++next; \n          if(head==NULL) \n             break; \n          q=head->next; \n          head->next=NULL; \n          if(found==0) \n          { \n             start=head; \n             found=1; \n          } \n          head=q; \n          while(--counter>0 && head!=NULL) \n             head=head->next; \n          if(head==NULL) \n             head=q; \n          reverse(p)->next=head; \n          counter=0; \n          head=q; \n     } \n     while(start != NULL) \n     { \n        printf(\"%d\\t\",start->val); \n        start = start->next; \n     } \n     printf(\"\\n\"); \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5194979655811072","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"11","title":"An array is given representing the colors of n jars, colors have values 0-99. When two jars are mixed the resulting volume is same as volume of one jar. Smoke is color1*color2?? and resulting color is (color1+color2)% 100. Keep on mixing colors such that you end up with just one jar with minimum smoke.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Yet another gem from Amazon. I have a solution for this, which I will post shortly."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do not use the jar with color 0, mix other jars  in any order you want. Then use the color 0 at last step, then you will have the color with smoke 0. Am I missing something?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my attempt: Lets say there is an array of n elements int[] arr = new int[n]; 1) Sort array 2) For every element a[i] find its perfect matching pair. By perfect matching pairs I mean elements a[i], a[j]  which sum a[i] + a[j] % 100 is the closest to  0. 2) Mix them and insert new element on its position in the original array so that it is taken in to account during the next 'search and merge' phase. 3) Repeat the process till there is only one element. Eg."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I'm guessing that the question is missing an important constraint. That we should only mix colors that are next to each other.   I say this because I've found this problem on other sites and they include that constraint. for example: spoj dot com/problems/MIXTURES/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use induction to show that for a sequence of numbers: n, n+1, n+2, n+3....n+k the minimum value of form x1*y1+x2*y2+..... is n(n+k) + (n+1)(n+k-1) + .... and then claim that (1,99), (2,98)....is the solution."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4651291556970496","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"27","title":"Second Question is to Encode a String  aaaabbccdd -> a4b2c2d2 In minimun space and time complexity","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Java Code: code is simple,effective and easy to understand.  public class Encrypt {  public static void main(String[] args) {   String string=\"aaaabbccdd\";   StringBuffer sb=new StringBuffer(\"\");   int count=0;   char str=string.charAt(0);   for(int i=0;i  {    if(str==string.charAt(i))    {     count++;    }    else    {     sb=sb.append(str);     str=string.charAt(i);     sb.append(count);     count=1;    }   }   System.out.println(sb);   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is it for contiguous characters only? For eg : What should happen for strings like aabbaaccaa? Should it be a2b2a2c2a2 OR a6b2c2?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Did the interviewer allow to use extra space to store the result? If input string array should be used for output,  abc would expand to a1b1c1 so that the input string array would be not enough."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"string getStringFromNumber(int i) \n{ \n ostringstream ss; \n ss << i; \n return ss.str(); \n} \nvoid printFormattedString1(string iStr) \n{ \n string finalStr = \"\"; \n //int counter = 0; \n int characters[256] = {0}; \n int totalChars = iStr.length(); \n for(int i = 0; i < totalChars; ++i) \n { \n  counter++; \n  characters[int(iStr[i])]++; \n } \n \n for(int j = 0; j < 256; ++j) \n { \n  counter++; \n  if(characters[j]) \n  { \n   finalStr += char(j); \n   finalStr += getStringFromNumber(characters[j]); \n  } \n } \n \n //cout<<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution to the former one :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java Code:  public class StringCompApp {    public static String StringComp(String str) {      int tail=0;   int count=1;   String compStr = \"\";      for (int j=1; j   if(str.charAt(j) == str.charAt(tail)) {     tail++;     count++;    }    else {     compStr = compStr + str.charAt(tail) + count;     System.out.println(\"compStr: \" + compStr);     tail++;     count = 1;    }       }   //for the last character count   compStr = compStr + str.charAt(tail) + count;    return compStr;  }  public static void main(String[] args) {      String str1 = \"aaaabbcccdefgg\";   String compstr1;      compstr1 = StringComp(str1);      System.out.println(\"Compressed Str: \" + compstr1);   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do a single scan of the string and collect and print the data as below. Space complexity is constant, time is linear:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void encodeString(String input)  {   char[] inputArray = input.toCharArray();   int charCounter = 1;   int arrayIndex = 0;   char tmpChar = inputArray[0];   String encodeString=\"\";      System.out.println(\"Method 1:\");   for (int i = 1; i < inputArray.length; i++) {    if(tmpChar == inputArray[i])     charCounter++;    else    {     // 1. You can just go on printing new string as and when you find it. In this case in the end you wont have it stored anywhere.     // 2. We copy encoded string to new string. So space increases     // 3. You can modify your current char array with encoded string. When encoding is over you can insert special char to mark the end.     //    The catch here is there should be no such char which occurs only once since then you will exceed char array limit. Ex abc -> a1b1c1 which goes beyond limit of char array.     System.out.print(tmpChar+Integer.toString(charCounter));     encodeString=encodeString+tmpChar+ Integer.toString(charCounter);     inputArray[arrayIndex]=tmpChar;     arrayIndex++;     if(((String)Integer.toString(charCounter)).toCharArray().length>1)     {      char[] charCounterArray = ((String)Integer.toString(charCounter)).toCharArray();      for (int j = 0; j < charCounterArray.length; j++) {       inputArray[arrayIndex]=charCounterArray[j];       arrayIndex++;      }     }     else     {      inputArray[arrayIndex]=((String)Integer.toString(charCounter)).charAt(0);      arrayIndex++;     }      tmpChar = inputArray[i];     charCounter =1;         }   }   // collecting final char   System.out.print(tmpChar+Integer.toString(charCounter));   System.out.println();      encodeString = encodeString+tmpChar+charCounter;   System.out.println(\"Method 2: \"+encodeString);      inputArray[arrayIndex]=tmpChar;   arrayIndex++;   if(((String)Integer.toString(charCounter)).toCharArray().length>1)   {    char[] charCounterArray = ((String)Integer.toString(charCounter)).toCharArray();    for (int j = 0; j < charCounterArray.length; j++) {     inputArray[arrayIndex]=charCounterArray[j];     arrayIndex++;    }   }   else   {    inputArray[arrayIndex]=((String)Integer.toString(charCounter)).charAt(0);    arrayIndex++;   }   // Marking end of collection in original array   inputArray[arrayIndex]='*';      System.out.println(\"Method 3: \");   for (int i = 0; i < inputArray.length; i++) {    if(inputArray[i]=='*')     break;    System.out.print(inputArray[i]);   }   System.out.println();     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \nint main(){ \n std::string input = \"abbeeecccd\"; \n char lastChar = input[0]; \n int count = 0; \n for (auto x : input){ \n  if (lastChar != x){ \n   printf(\"%c%d\", lastChar, count); \n   count = 0; \n   lastChar = x; \n  } \n  count++; \n } \n printf(\"%c%d\", lastChar, count); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Scanner;  public class Strin{  public static void main(String[] args){   Scanner obj = new Scanner(System.in);   char a[]= new char[100];   int len,i,j,k,x=1;   String str;   String str1=\"\";   System.out.println(\"Enter String\");   str=obj.nextLine();   len=str.length();   for (i=0;i   a[i]=str.charAt(i);   }   for(i=0;i   if(a[i]!=' '){     for(j=(i+1);j    while(a[j]==a[i]){      x++;      for(k=j;k       a[k]=a[k+1];      }      len--;     }          }     str1=str1+a[i]+x+' ';     x=1;    }   }   System.out.println(\"New String= \"+str1);  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.StringBuilder; \n \npublic class Encoding { \n \n protected static StringBuilder encodedStr = new StringBuilder(); \n \n private static void encodeStr(char[] c, int start) { \n  int count = 1; \n \n  if (start > c.size -1) { \n   return; \n  } \n \n  encodedStr.add(c[start]); \n \n  while (c[count + start - 1] == c[count + start]) { \n   count++; \n  } \n  encodedStr.add(count); \n \n  encodeStr(c, start+count); \n } \n \n public static String encodeStr(String str) { \n  encodeStr(str.toCharArray(), 0); \n  return encodedStr.toString(); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String args[]){ \n          String str = \"aaaabbbbcccddddefgh\"; \n          StringBuilder sbr = new StringBuilder(\"\"); \n          int count=0; \n          for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Scanner; public class Encript {               public static void main(String [] arg){         int count=1;         String s1=\"\",s2=\"\";         Scanner in=new Scanner(System.in);         s1=in.nextLine();                  System.out.print(\"The encripted stirng is....\");         for(int i=0;i        {    if(s1.charAt(i)==s1.charAt(i+1))                 count++;             else             {                 System.out.print(s1.charAt(i));                 System.out.print(count);                 count=1;             }         }          System.out.print(s1.charAt(s1.length()-1));                 System.out.print(count);     }   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what if continous aaa... array will be more than 256?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void Encrypt(){    String in=\"aaaabbbcccccccdddgggggg\";    StringBuilder sb=new StringBuilder(\"\");    int count=0;    char c=in.charAt(0);    for (int i = 0; i < in.length(); i++) {     if(c==in.charAt(i)) count++;     else {      sb=sb.append(c);      sb.append(count);      c=in.charAt(i);      count=1;     }    }    sb.append(c);    sb.append(count);    System.out.println(sb.toString());   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void Encrypt(){  \nString in=\"aaaabbbcccccccdddgggggg\";  \nStringBuilder sb=new StringBuilder(\"\");  \nint count=0;  \nchar c=in.charAt(0);  \nfor (int i = 0; i < in.length(); i++) {  \nif(c==in.charAt(i)) count++;  \nelse {  \nsb=sb.append(c);  \nsb.append(count);  \nc=in.charAt(i);  \ncount=1;  \n}  \n}  \nsb.append(c);  \nsb.append(count);  \nSystem.out.println(sb.toString());  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This one could use a little more optimization. encode function will not reallocate string buffer. I used strdup in main to avoid access violations."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public String encodeString( String s ){ \n  if ( s == null || s.isEmpty()) return \"\"; \n  char curChar = s.charAt(0); \n  int counter = 0; \n  for ( int i = 0; i < s.length; i += 1){ \n   char newChar = s.charAt(i); \n   if ( newChar == curChar ) counter += 1; \n   else{ \n    s.replaceFirst(\"\"+curChar+\"+\",\"\"+curChar+counter); \n    curChar = newChar; \n    counter = 0; \n   }   \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include  void Encode(char ch[], int size) {   char abc[10]=\"\",abd[10]=\"\";   int i,j,flag=0,size1;   for(i=0;i  {    flag=ch[i]-97;        if(abc[flag]>0)    {     abc[flag]++;    }    else    {     abc[flag]=1;     abd[flag]=ch[i];    }    }   size1=strlen(abc);   for(j=0;j   printf(\"%c%d\",abd[j],abc[j]);  }  int main() {  char buf[] = \"aaaabadbaccdbd\";  int size = sizeof(buf)/sizeof(buf[0]);    Encode(buf, size);  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"char ch; \n     char arr[3]=\"\\0\"; \n     int count = 0; \n     char input[] = \"aaaabbccdddddeeee\"; \n     char result[50] = \"\\0\"; \n     int i; \n     ch = input[0]; \n     for ( i = 0 ; input[i] != '\\0'; i++ ) \n     { \n        if( input[i] == ch ) \n        { \n           count++; \n           continue; \n        } \n        else \n        { \n           ch = input[i]; \n           snprintf( arr,sizeof(arr),\"%c%d\", input[i-1], count); \n           strcat( result, arr); \n           count = 1; \n           continue; \n        } \n     } \n    printf(\"%s\\n\", result);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this? create a HashMap, for a given string length check each character in the hash map If(!Map.containsKey(key))   Map.put(\"character\", count) else Map.put(\"character\", count+1)."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5636453975457792","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"12","title":"First question is You have two numbers represented by a linked list, where each node contains a single digit. Write a function that adds the two numbers and returns the sum as a linked list","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming the LinkedList head starts at the least significant digit for both a and b:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I really didn't understand this part of code.  if (resultP == null) {     resultP = new ListNode();   } else {    resultP.next = new ListNode();    resultP = resultP.next();   }  could you please explain it"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The point of 'resultP' is it's a pointer (aka reference) to the current ListNode object in the summed linkedlist. As the values are added, 'resultP' points to the most recently summed digit in the resultant linked list. 'result' is used just to keep track of the beginning of the linked list.  The if-else statement is there to create the first node of the result linked list.  Also another error with my code:  'result' should be assigned to 'resultP' in the if block. 'result' always points to the 1st node of the LL that is returned."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What if the numbers to be added are 851 and 74. As I understand, the linked list would be represented as follows:  8 -> 5 -> 1 -> 7 -> 4  Is there any additional info provided, like where the second number begins etc? I'm afraid I don't quite understand the Q."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package com.java.linkedlist; \n \npublic class Node { \n int data; \n Node next; \n public Node(int d) \n { \n  this.data=d; \n     this.next=null; \n } \n void appendToTail(int d) \n { \n  Node end=new Node(d); \n  Node n=this; \n  while(n.next!=null) \n  { \n   n=n.next; \n  } \n  n.next=end; \n   \n } \n Node reverse() \n { \n  if (this == null || this.next == null) \n   return this;  //empty or just one node in list \n \n   Node Second = this.next; \n \n   //store third node before we change  \n   Node Third = Second.next;   \n \n   //Second's next pointer \n   Second.next = this;  //second now points to head \n   this.next = null;  //change head pointer to NULL \n \n   //only two nodes, which we already reversed \n   if (Third == null) \n   return Second;   \n    \n   while (Third != null) \n   {  \n   Node NextNode = Third.next; \n \n   Third.next = Second; \n \n   /*  repeat the process, but have to reset \n        the Second and Third \n   */ \n \n   Second =Third; \n   Third = NextNode;   \n   } \n \n   Node r = Second; //reset the head node \n   return r; \n } \npublic Node add(Node num2) \n{ \n Node result; \n if(this==null&&num2==null) \n  return null; \n if(this==null) \n  return num2; \n if(num2==null) \n  return this; \n Node num1=this; \n int sum=0; \n int r=0; \n sum=(sum+num1.data+num2.data)%10; \n result=new Node(sum); \n r=(num1.data+num2.data)/10; \n num1=num1.next; \n num2=num2.next; \n while(num1!=null&& num2!=null) \n  { \n  sum=(num1.data+num2.data+r)%10; \n  result.appendToTail(sum); \n  r=(num1.data+num2.data+r)/10; \n  num1=num1.next; \n  num2=num2.next; \n  } \n while(num1!=null) \n { \n  sum=(r+num1.data)%10; \n  result.appendToTail(sum); \n  r=(r+num1.data)/10; \n  num1=num1.next; \n } \n while(num2!=null) \n  { \n  sum=(r+num2.data)%10; \n  result.appendToTail(sum); \n  r=(r+num2.data)/10; \n  num2=num2.next; \n  } \n return result; \n} \n public static void main(String args[]) \n { \n  /*Numbers to add are 549 and 65*/ \n  Node num1=new Node(5); \n  num1.appendToTail(4); \n  num1.appendToTail(9); \n  Node rev1=num1.reverse(); \n  Node num2=new Node(6); \n  num2.appendToTail(5); \n  Node rev2=num2.reverse(); \n  Node sum=rev1.add(rev2); \n  Node resultRev=sum.reverse(); \n  while(resultRev!=null) \n  { \n   System.out.print(resultRev.data); \n   resultRev=resultRev.next; \n  } \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Those are not good solutions indeed, too complicated anyways. Here is my code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Nice, working fine. We can do one small change here to avoid string manipulation. take res as int variable with 0 as default value and then we can use multipkication to create actual number in place like :  private int transferListToInt( Node node ){   if ( node == null ) return 0;   curNode = node;   int res = 0;   while ( node != null ){    res = (res * 10) +  curNode->data;     curNode = curNode -> next;   }   return res;  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5692185471090688","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"8","title":"Implement stack with findMiddle and deleteMiddle() in constant time. Can you please explain and write code for it","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Implement it using doubly linklist... and use an int variable to store the address of current number of elements in stack and a pointer variable to store the address of middle element."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; \n \npublic class Stack  \n{ \n private ArrayList stack; \n  \n public Stack() \n { \n  stack = new ArrayList(); \n } \n  \n public int push (int value) \n { \n  stack.add(value); \n  return stack.size() - 1; \n } \n  \n public int pop () \n { \n  int value = stack.get(stack.size() - 1); \n  stack.remove(stack.size() - 1); \n  return value; \n } \n  \n public int getMiddle () \n { \n  return stack.get(stack.size()/2); \n } \n  \n public int deleteMiddle () \n { \n  int value = stack.get(stack.size()/2); \n  stack.remove(stack.size()/2); \n  return value; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can have a doubly linked list as stack having pointers to start, end, middle and integer top, mid  update middle and mid in case top/2 != mid whenever push or pop takes place."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use flag to check if the length of the stack is even or odd and then accordingly update the mid element"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"AFAIK,  ArrayList(java) or vector(c++) can be used to implement the stack(push and pop on the last element). Indexing the middle element of either would be a constant time operation."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5185048617680896","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"//Online Coding Assignment  As a member of the cab finder app team, you are tasked with implementing a CabFinder class that has the following minimal public interface:","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is it the same id=5717814883123200?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"yeah, the same. Although that solution is a little vague."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"last i checked careercup is not for homework assignments"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5894737940709376","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"12","title":"You are given a 3 * 3 Matrix -   3  -5  10 6  2   -1 2  6  1  Q: Find the sum of the elements of each rows, and each column, and then display row number \\ column number having  the maximum sum and the minimum sum.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"var matrix =[[ 3,-5,10] \n            ,[ 6,-2,-1] \n            ,[ 2, 6, 1]]; \n \nvar maxRow=0 \nvar maxRowSum=Number.MIN_VALUE \nvar minRow=0 \nvar minRowSum=Number.MAX_VALUE \n \nvar maxColumn=0 \nvar maxColumnSum=Number.MIN_VALUE \nvar minColumn=0 \nvar minColumnSum=Number.MAX_VALUE \n \nfor(var i=0; i<3; i++) { \n    var rowSum=0; \n    var columnSum=0; \n     \n    for(var j=0; j<3; j++) { \n        rowSum+=matrix[i][j];             \n        columnSum+=matrix[j][i] \n    } \n     \n    if(rowSum>maxRowSum) { \n        maxRowSum=rowSum; \n        maxRow=i \n    } \n     \n    if(rowSummaxColumnSum) { \n        maxColumnSum=columnSum; \n        maxcolumn=i \n    } \n     \n    if(rowSum"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Concept : In this example, calculate the 6 entities, 3 row sums, and 3 column sums. Store this in a dictionary with key as \"sum value\" and value as \"index of row/col\" . Now pick up all the keys and find min/max of these - and then just display then corresponding values along with the keys. When I say dictionary I am *thinking* python - you could do the same with associative arrays/hash-maps"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package vrts.common.test.deepak; \n \nimport java.util.ArrayList; \nimport java.util.Collections; \nimport java.util.List; \n \npublic class Matrix { \n  \n private int matrix[][] = { \n   {1,22,2,34,4}, \n   {1,2,342,34,4}, \n   {11,2,2,34,4}, \n   {1,2,2,34,34}, \n   {1,221,2,34,4}, \n   {11,2,12,34,24} \n }; \n  \n private List rowSum = new ArrayList(); \n private List colSum = new ArrayList(); \n  \n class IndexSumPair implements Comparable { \n  private int index; \n  private int sum; \n \n  public IndexSumPair(int index, int sum) { \n   this.index = index; \n   this.sum = sum; \n  } \n \n  /** \n   * @return the sum \n   */ \n  public int getSum() { \n   return sum; \n  } \n \n  /** \n   * @param sum \n   *            the sum to set \n   */ \n  public void setSum(int sum) { \n   this.sum = sum; \n  } \n \n  /** \n   * @return the index \n   */ \n  public int getIndex() { \n   return index; \n  } \n \n  @Override \n  public int compareTo(IndexSumPair object) { \n   if (object != null) { \n    return object.sum > sum ? -1 : 1; \n   } \n   return 0; \n  } \n } \n  \n void updateColSum(int row,int col){ \n  if(col>=colSum.size()){ \n   colSum.add(new IndexSumPair(col,matrix[row][col])); \n   return; \n  }   \n  IndexSumPair colValue = colSum.get(col); \n  colValue.setSum(colValue.getSum()+  matrix[row][col]);   \n } \n  \n void updateRowSum(int row,int col){ \n  if(row>=rowSum.size()){ \n   rowSum.add(new IndexSumPair(row,matrix[row][col])); \n   return; \n  } \n  IndexSumPair rowValue = rowSum.get(row); \n  rowValue.setSum(rowValue.getSum()+  matrix[row][col]); \n } \n  \n void printValues(){ \n  Collections.sort(rowSum); \n  System.out.println(\"Max row:\"+rowSum.get(rowSum.size()-1).getIndex() + \" Sum  \"+rowSum.get(rowSum.size()-1).getSum()); \n  System.out.println(\"Min row:\"+rowSum.get(0).getIndex() + \" Sum  \"+rowSum.get(0).getSum()); \n  System.out.println(\"Max Col:\"+colSum.get(colSum.size()-1).getIndex() + \" Sum  \"+colSum.get(colSum.size()-1).getSum()); \n  System.out.println(\"Min Col:\"+colSum.get(0).getIndex() + \" Sum  \"+colSum.get(0).getSum()); \n } \n  \n void processMatrix(){ \n  for(int row=0; row"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void getIndex(int number){   \n  int numberLength = (int)(Math.log10(number)+1); \n  int index = 0; \n  for(int i=numberLength;i>0;i--){ \n   index = (int) (index + ((number - Math.pow(10,i-1)) * (i))); \n   number = (int) Math.pow(10,i-1); \n  }  \n  System.out.println(\"Index :\"+index); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void getIndex(int number){   \n  int numberLength = (int)(Math.log10(number)+1); \n  int index = 0; \n  for(int i=numberLength;i>0;i--){ \n   index = (int) (index + ((number - Math.pow(10,i-1)) * (i))); \n   number = (int) Math.pow(10,i-1); \n  }  \n  System.out.println(\"Index :\"+index); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorry mistakenly added code here..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) { \n   \n  int[][] data = new int [3][3]; \n     \n  data[0][0] = 3; \n  data[0][1] = -5; \n  data[0][2] = 10; \n   \n  data[1][0] = 6; \n  data[1][1] = 2; \n  data[1][2] = -1; \n   \n  data[2][0] = 2; \n  data[2][1] = 6; \n  data[2][2] = 1; \n      \n  Map rows = new TreeMap(); \n  Map cols = new TreeMap(); \n \n  for (int i = 0; i < data.length; i++) { \n   for (int j = 0; j < data[i].length; j++) { \n    if (!rows.containsKey(i)) { \n     rows.put(i, data[i][j]); \n    } else { \n     int val = data[i][j] + rows.get(i); \n     rows.put(i, val); \n    } \n    if (!cols.containsKey(i)) { \n     cols.put(i, data[j][i]); \n    } else { \n     int val = data[j][i] + cols.get(i); \n     cols.put(i, val); \n    } \n   } \n  } \n      \n  sortMap(rows); \n  sortMap(cols); \n   \n  System.out.println(String.format(\"Min Row sum %d and Max row sum %d\", rows.get(0), rows.get(rows.size() -1))); \n  System.out.println(String.format(\"Min Column sum %d and Max Column sum %d\", cols.get(0), cols.get(cols.size() -1))); \n   \n } \n \n private static void sortMap(Map map) { \n  for (int i = 0; i < map.size(); i++) { \n   for (int j = i + 1; j < map.size(); j++) { \n    int temp = map.get(i); \n    if (map.get(j) < temp) { \n     map.put(i, map.get(j)); \n     map.put(j, temp); \n    } \n   } \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) { \n   \n  int[][] data = new int [3][3]; \n     \n  data[0][0] = 3; \n  data[0][1] = -5; \n  data[0][2] = 10; \n   \n  data[1][0] = 6; \n  data[1][1] = 2; \n  data[1][2] = -1; \n   \n  data[2][0] = 2; \n  data[2][1] = 6; \n  data[2][2] = 1; \n      \n  Map rows = new HashMap(); \n  Map cols = new HashMap(); \n \n  for (int i = 0; i < data.length; i++) { \n   for (int j = 0; j < data[i].length; j++) { \n    if (!rows.containsKey(i)) { \n     rows.put(i, data[i][j]); \n    } else { \n     int val = data[i][j] + rows.get(i); \n     rows.put(i, val); \n    } \n    if (!cols.containsKey(i)) { \n     cols.put(i, data[j][i]); \n    } else { \n     int val = data[j][i] + cols.get(i); \n     cols.put(i, val); \n    } \n   } \n  } \n   \n  System.out.println(String.format(\"The Row: %d has the Min Sum %d\", getMinIndex(rows), rows.get(getMinIndex(rows)))); \n  System.out.println(String.format(\"The Col: %d has the Min Sum %d\", getMinIndex(cols), cols.get(getMinIndex(cols)))); \n  System.out.println(String.format(\"The Row: %d has the Max Sum %d\", getMaxIndex(rows), rows.get(getMaxIndex(rows)))); \n  System.out.println(String.format(\"The Col: %d has the Max Sum %d\", getMaxIndex(cols), cols.get(getMaxIndex(cols)))); \n   \n   \n } \n \n private static int getMaxIndex(Map map) { \n  Set> entrySet = map.entrySet(); \n  int max = entrySet.iterator().next().getValue(); \n  int index = entrySet.iterator().next().getKey(); \n  for (Entry entry : entrySet) { \n   if (entry.getValue() > max) { \n    max = entry.getValue(); \n    index = entry.getKey(); \n   } \n  } \n  return index; \n } \n  \n private static int getMinIndex(Map map) { \n  Set> entrySet = map.entrySet(); \n  int min = entrySet.iterator().next().getValue(); \n  int index = entrySet.iterator().next().getKey(); \n  for (Entry entry : entrySet) { \n   if (entry.getValue() < min) { \n    min = entry.getValue(); \n    index = entry.getKey(); \n   } \n  } \n  return index; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Displays row number OR column number having the maximum sum and the minimum sum."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Keep it simple and this should work with any size matrix"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In Python: \n \ndef sumRowCol(matrixlist): \n    sumRowList = [sum(x) for x in matrixlist] \n    sumColList = [sum(x) for x in zip(*matrixlist)] \n    return sumRowList, sumColList \n     \nlistSumRow, listSumCol = sumRowCol([[3,-5,10],[6,2,-1],[2,6,1]]) \nprint 'Row num:{} has maximum value {}\\nRow num:{} has minimum value {}'.format(listSumRow.index(max(listSumRow)),max(listSumRow),listSumRow.index(min(listSumRow)),min(listSumRow)) \nprint 'Col num:{} has maximum value {}\\nCol num:{} has minimum value {}\\n'.format(listSumCol.index(max(listSumCol)),max(listSumCol),listSumCol.index(min(listSumCol)),min(listSumCol))"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5195825227497472","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"8","title":"How to find the adjacent elements of an single dimensional array whose difference is 1; What is the Time Complexity & Auxiliary Space you use ? What type of efficiency can be achieved?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Since you have to traverse the entire array atleast once, Time Complexity : O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int a[LENGTH];  for(i=0; i {  if( 1== abs(a[i]-a[i+1]))   printf(\"%d %d\",a[i],a[i+1]);  else   continue;  }  Time Copmplexity = O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"People have got the question wrong, I think.  The array could be {4,7,6,9,3}  4 and 3 are adjacent with difference 1.  For this version, use a hashtable, and given a[i], check if a[i] -1 and a[i]+1 are already there."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nmain() \n{ \n int temp=0; \n int arr[]={-13,-12,18,17,19,20,23}; \n int length=sizeof(arr)/sizeof(arr[0]); \n for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include main() {       int i , j, a[20], n;         printf(\"entr the size of array \");     scanf(\"%d\", &n);   printf(\"enter the element\");      for(i=0;i  {                    scanf(\"%d\",&a[i]);                                        }                             for(i=0;i        {              j=i+1;                                     if((a[i]-a[j]==1)||(a[j]-a[i]==1))                         {                                                           printf(\"%d%d\",a[i],a[j]) ;                                                           }                                                           else                                                           printf(\" there are such pairs of elements whose difference is equal to1  \");                                                           }                                                           getch();                                                           }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5081948464611328","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"8","title":"How to sort an single dimensional array whose elements are {4,5,6,4,5,6}; What is the Time Complexity & Auxiliary Space you use ? What type of efficiency can be achieved?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"dutch national flag algorithm? , in place sorting, O(n) complexity."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"In this case we can use count sort as all the numbers are less than number 7 which can act as a key in count sort and the range of the numbers is also small so count sort is best suited in these cases with complexity O(k+N) = O(N) in a linear time"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// int[] input = {4,5,6,6,6,6,5,4,4,6}  public static void sortArray(int[] input)  {   int start=0;   int end = input.length-1;   int counter_4 = 0;   int counter_6 = input.length-1;   while(input[counter_4]==4)   {   counter_4++;   start++;   }   while(input[counter_6]==6)   {    counter_6--;    end --;   }   while(start    if(input[start]==4 && start > counter_4)    {     int tmp = input[counter_4];     input[counter_4] = input[start];     input[start] = tmp;     counter_4++;     if(tmp!=4 && tmp!=6)      start++;    }    else if(input[start] == 6 && start   {     int tmp = input[counter_6];     input[counter_6] = input[start];     input[start] = tmp;     counter_6--;     if(tmp!=4 && tmp!=6)      start++;    }    else     start++;    }   System.out.println(\"Printing sorted array \");   for (int i = 0; i < input.length; i++) {    System.out.print(input[i]+\" \");    }   System.out.println();  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Quicksort in this case won't be a good option as data is almost sorted and this is the worst case for quick sort (n square).  An merge sort (require additional space) and a insert sort (no additional space) could be a nice option."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just use merge procedure of merge sort?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Divide the array into two parts and use merge sort. Best case time complexity is O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void Partition(int data[], int size1, int low, int high)  {     int p = -1;     int q = size1;     for (int i = 0; i < q;)     {         if (data[i] < low)         {             swap(data[i], data[++p]);             ++i;         }         else if (data[i] > high)             swap(data[i], data[--q]);         else ++i;     } } //low=5 and high=5"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Actually none of the above ! waste of time guys, all same answers but no out of box thinking.  If you see input, the numbers are out of order at most by 4 numbers.  so what to do : build heap of 4 numbers, remove min and keep advancing after 5th number and adding new number. At the end when all numbers exhaust, add all remaining numbers on heap one by one by deleting min.  This is what the interviewer is expecting."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4837540129406976","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"Threads synchronization methods, how do they use CPU time slice and compare their efficiency?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Filter Lock, Peterson lock etc?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5932349506191360","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"16","title":"Given a set of names, sort them in the following manner the next word should start with the last letter of the previous word. Java ?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Interesting question.   Someone suggested reducing the problem to finding a Hamiltonian Path in a graph. I might be wrong but I think finding a Hamiltonian Path in a general graph is an NP-Complete problem. However, finding an Euler path in a graph is not, so instead of reducing the problem to find a Hamiltonian path we might try reducing it to finding an Euler path.  Instead of looking at the names as vertices, we'll look at them as edges between two characters (the starting character and the ending character). Thus, our graph G will be defined as follows: The vertices are all the starting and ending characters from the strings (no repetitions). For every two vertices c1 and c2, there is an edge (c1,c2) for every name which begins with c1 and ends with c2 (with parallel edges as well, meaning that if there are two names starting with c1 and ending with c2 then there would be two edges from c1 to c2 in the graph as well).  For example: Input = {\"luis\",\"hector\",\"selena\",\"emmanuel\",\"amish\",\"anna\",\"andrea\",\"rawle\"}  The graph G would be as follows: Vertices = {'l','s','h','r','a','e'} Edges (the format is (from,to,name)) = {('l','s',\"luis\"), ('h','r',\"hector\"),('s','a',\"Selena\"),('e','l',\"emmanuel\"),('a','h',\"amish\"),('a','a',\"anna\"),('a','a',\"andrea\"),('r','e',\"rawle\")}  Notice that there are two edges from 'a' to 'a' (one for \"anna\" and another for \"andrea\").   Now, notice that each path (with more than one vertex) in the graph we just defined corresponds  to some names in the right order. For instance: Path: 's' --(\"selena\")---> 'a' --(\"andrea\") ---> 'a' --(\"amish\")---> 'h'  Thus, in order to sort all the names we must find a path in G which goes through all the edges exactly once, in other words we must find an Euler path in the graph G.  Algorithm: 1. Build the graph G from the set of strings as described above. 2. Find an Euler path in the graph G (for instance: using Hierholzer's algorithm). 3. If an Euler path was found in (2) then Output the strings in the order induced by the path found in (2). 4. else, output \"Sorting not possible\".  Complexity:  1. Building the graph can be done in linear time. 2. Hierholzer's algorithm can be implemented in linear complexity as well. 3. Printing the path is also done in linear time (the path contains at most n edges). Overall complexity: O(n) where n is the number of names.  Here is my attempt at a non-optimized (O(n^2)) implementation of this idea: snipt.org/BKic4  With some additional data structures - path merging and next character selection can be reduced to O(1) instead of O(n) which would make this solution linear. It worked well for the tests I ran but I haven't tested it thoroughly."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First pass : - Create an ordered trie for the set of words as the look up  Second pass :- starting with the first word look up the tie for last char available on the current word. If present concatenate to the result else go through with the next word in the source."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Construct a graph (connect two words accoding to the condition) and run a topological sort"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{let s be the no. of words; let n=1; let l=0; while(n0) {  take nth word; look the last letter; loop: search for the word starting with that letter in the remaining s-n words; if found { interchange (n+1)th and the newly found word; n=n+1; } else { interchange the nth and (l+1)th last word; l++;          }  //this else condition is to place the words for which there won't exist any words start with its last letter  }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Make a graph with a vertex for each name, and have a directed edge connecting them if the last letter of name1 is the first letter of name2.  Find a Hamiltonian path in this graph."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using the charAt() and str.length should work in a simple for loop condition"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"One thing to note is that it may not always be possible to sort the numbers as asked in the question.  Suppose you have the strings: abc cba bbb  Where will you place the string 'bbb' w.r.t the other strings?  Supposing that the input strings can be arranged as required in the question, first sort the array 'strings[]' using the natural order of the strings. Then we can maintain an auxiliary array that holds the locations of strings starting with a particular character. For ex: Lets have the array index_manager[] such that:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.*; \n/** \n* Given a array of names, this program would sort all names such that last character of preceding string is equivalent to first character of current name \n**/ \nclass NameSort{ \n \n    /** \n    * @return String[] array of sorted names as per requirement. \n    * If not possible to sort as per given conditions than return null; \n    */ \n    String[] sortNames(String[] names) { \n        Arrays.sort(names);    //Alphabetical order \n        String[] orderedNames = null; \n        for(int index = 0; index < names.length; index++) { \n            Set orderedNamesSet = new LinkedHashSet(); \n            if(visitNames(orderedNamesSet, names[index], names)) { \n                orderedNames = orderedNamesSet.toArray(new String[orderedNamesSet.size()]); \n                break; \n            } \n        } \n        return orderedNames; \n    } \n     \n    private boolean visitNames(Set orderedNames, String candidateString, String[] names) { \n        orderedNames.add(candidateString); \n        for(String nextCandidate : findNamesStartingWithChar(names, candidateString.charAt(candidateString.length()-1))) { \n            if(!orderedNames.contains(nextCandidate)) { \n                Set cloneSet = new LinkedHashSet(orderedNames);  \n                if(visitNames(cloneSet, nextCandidate, names)) { \n                    orderedNames.clear(); \n                    orderedNames.addAll(cloneSet); \n                    break; //I found my candidate \n                } \n            } \n        } \n        return orderedNames.size() == names.length; \n    } \n     \n    /** \n    * Iterate through each name, and do a binary search in endCharSortNames string \n    * Else i will have to try with all possible String sequence \n    */ \n    private List findNamesStartingWithChar(String[] alphabetSortNames, char startChar) { \n        List names = new ArrayList(); \n        int low = 0; \n        int high = alphabetSortNames.length - 1; \n        while(low <= high) { \n            int middle = (low + high) >>> 1; \n            if(getFirstChar(alphabetSortNames[middle]) == startChar) { \n                for(int index = middle; index >=0 && getFirstChar(alphabetSortNames[index]) == startChar; index--) { \n                    names.add(alphabetSortNames[index]); \n                } \n                for(int index = middle+1; index"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"solution takes O(N^2) but very straight foreword -"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class OrderWordsNextStartsWithLastLetterOfPrevious { \n  \n  \n public static void orderWords(List words) { \n   \n  TreeSet[] starts = (TreeSet[]) new TreeSet[26]; \n  TreeSet[] ends =  (TreeSet[]) new TreeSet[26]; \n   \n  for(String word:words) { \n   int startIndex = word.charAt(0) - 'a'; \n   int endIndex = word.charAt(word.length()-1) - 'a'; \n    \n   if(starts[startIndex] == null) { \n    starts[startIndex] = new TreeSet(); \n   } \n   if(ends[endIndex] == null) { \n    ends[endIndex] = new TreeSet(); \n   } \n    \n   starts[startIndex].add(word); \n   ends[endIndex].add(word); \n  } \n   \n  //find first and last \n   \n  int startIndex = -1; \n  int endIndex = -1; \n   \n  for(int i = 0; i < starts.length; i++) { \n    \n   if(starts[i]==null && ends[i]==null) continue; \n   else if(starts[i]!=null && ends[i]==null) {startIndex=i; continue;} \n   else if(starts[i]==null && ends[i]!=null) {endIndex=i; continue;} \n   else { \n     \n    if(startIndex<0) startIndex = i; \n    if(endIndex<0) endIndex = i; \n     \n    if(starts[i].size() > ends[i].size()) startIndex = i; \n    else if(ends[i].size() > starts[i].size()) endIndex = i;  \n   } \n  } \n   \n  String word = starts[startIndex].pollFirst(); \n   \n  while(word!=null) { \n   System.out.println(word); \n   int end = word.charAt(word.length()-1)-'a'; \n   ends[end].remove(word); \n    \n    \n   if(starts[end]==null) {word=null;continue;}  \n    \n   word = starts[end].pollFirst(); \n    \n   int endOfNewWord = word.charAt(word.length()-1) - 'a'; \n   if((starts[endOfNewWord]==null || starts[endOfNewWord].size()==0) && starts[end].size()>0) {String tmp = word; word=starts[end].pollFirst(); starts[end].add(tmp);} \n    \n    \n  } \n   \n } \n  \n public static void main(String[] args) { \n  String[] words = { \n  \"luis\", \n  \"hector\",  \n  \"selena\", \n  \"emmanuel\",  \n  \"amish\", \n  \"heoj\", \n  \"jeoh\" \n  }; \n   \n  orderWords(Arrays.asList(words)); \n   \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why not a simple Hash with values as Linklist. the key for the hash will be the first character of the word"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6323309054525440","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"Write all test cases and Test data to test BODMAS rule in Maths.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Evaluate a set of expressions which involve multiple operands (or variables) Ensure the bodmas rule is followed in each expression  Example expression which would ensure rule working fine:  a * b-c * 4 / 5-3  Test with braces single and multiple levels and ensure BODMAS gets applied correctly abiding to paranthesis operations"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Its amazing, looking at the time and effort you put into your blog and detailed information you provide. I'll bookmark your blog and visit it weekly for your new posts."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6482154242441216","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"8","title":"Given a binary search tree whose nodes are integers, find the frequency of occurrence of each digit in the tree.tr","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"public class frequency { \n public static int[] digitFreq = int[10]; \n \n public static void treeFreq (BTNode tree) { \n  /* Base Case */ \n  if (tree == null) { \n   return; \n  } \n \n  /* Visit Node, check digit frequency */ \n  int number = tree.data; \n  do { \n   digitFreq[number % 10]++; \n   number /= 10; \n  } (while number != 0); \n \n  treeFreq(tree.left); /* Check left sub-tree */ \n  treeFreq(tree.right); /* Check right sub-tree */ \n } \n} \n \npublic class BTNode { \n int data; \n BTNode left; \n BTNode right; \n \n public BTNode { \n  data = null; \n  left = null; \n  right = null; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hrmm... My first thought was just using a hashtable or make your own data structure. Do an ___-order traversal and every time you get to a node, look at the digit, see if your data structure has it: a. Has it? K, increment the count of it. b. Doesn't have it? First time it's come up so start it at zero.  For each digit we use our modified version of put/add. O(n)?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.HashMap; \nimport java.util.Map; \nimport java.util.Map.Entry; \n \npublic class BTreePreOrder { \n \n private Node root; \n private Map frequencyCounter = null; \n \n private void treeTravelAndeFindFrequency(Node root) { \n  if (root == null) \n   return; \n  findFrequency(root.getNodeValue()); \n  treeTravelAndeFindFrequency(root.getLeftNode()); \n  treeTravelAndeFindFrequency(root.getRightNode()); \n } \n \n private void findFrequency(int value) { \n  String valueString = \"\" + value; \n  for (char ch : valueString.toCharArray()) { \n   Integer intValue = frequencyCounter.get(\"\"+ch); \n   if (intValue != null) \n    frequencyCounter.put(\"\"+ch, ++intValue); \n   else \n    frequencyCounter.put(\"\"+ch, 1); \n  } \n } \n  \n public void add(int array[]){ \n  for (int value : array) { \n   add(new Node(value)); \n  } \n } \n \n public void add(Node node) { \n  Node x, y; \n  // Assume root is initialized to null \n  x = y = root; \n \n  while (x != null) { \n   if (x.getNodeValue() > node.getNodeValue()) { \n    y = x; \n    x = x.getLeftNode(); \n   } else { \n    y = x; \n    x = x.getRightNode(); \n   } \n    \n  } \n \n  // y will be the parent of node \n  if (y == null) { \n   root = node; \n   return; \n  } \n \n  if (y.getNodeValue() > node.getNodeValue()) \n   y.setLeftNode(node); \n  else \n   y.setRightNode(node); \n \n  node.setParent(y); \n } \n \n public void getFrequencyOfEachDigit() { \n  frequencyCounter = new HashMap(); \n  treeTravelAndeFindFrequency(root); \n  for (Entry entrySet : frequencyCounter.entrySet()) { \n   System.out.println(entrySet.getKey() + \" \" + entrySet.getValue()); \n  } \n } \n  \n class Node { \n  private Node rightNode; \n  private Node leftNode; \n  private Node parent; \n  private int nodeValue; \n   \n  public Node(int nodeValue){ \n   this.nodeValue = nodeValue; \n  } \n   \n   \n  /** \n   * @return the parent \n   */ \n  public Node getParent() { \n   return parent; \n  } \n \n \n  /** \n   * @param parent the parent to set \n   */ \n  public void setParent(Node parent) { \n   this.parent = parent; \n  } \n   \n   \n  /** \n   * @return the rightNode \n   */ \n  public Node getRightNode() { \n   return rightNode; \n  } \n \n \n  /** \n   * @param rightNode the rightNode to set \n   */ \n  public void setRightNode(Node rightNode) { \n   this.rightNode = rightNode; \n  } \n \n \n  /** \n   * @return the leftNode \n   */ \n  public Node getLeftNode() { \n   return leftNode; \n  } \n \n \n  /** \n   * @param leftNode the leftNode to set \n   */ \n  public void setLeftNode(Node leftNode) { \n   this.leftNode = leftNode; \n  } \n \n \n  /** \n   * @param nodeValue the nodeValue to set \n   */ \n  public void setNodeValue(int nodeValue) { \n   this.nodeValue = nodeValue; \n  } \n \n \n  /** \n   * @return nodeValue \n   */ \n  public int getNodeValue() { \n   return nodeValue; \n  } \n } \n \n public static void main(String[] args) { \n  int[] array = { 1, 2, 9, 12, 123, 123, 4 }; \n  BTreePreOrder btree = new BTreePreOrder(); \n  btree.add(array); \n  btree.getFrequencyOfEachDigit(); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A binary Search tree is an ordered binary tree with *NO* duplicates. So, every digit will occur only once in the tree. So, frequency is 1/(total nodes in the tree). So, the problem, to me, boils down to counting the total number of nodes in the tree.   Am I missing anything people? Lemme know please. Thanks."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"call this method in any ***order traversal :  Map hash = new HashMap(); public void findFrequency(int data){   if(hash.containsKey(data)){    Integer temp = (Integer) hash.get(data);    temp++;    hash.put((Integer)data,temp);   }   else{    hash.put((Integer)data, 1);   }  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5133782344531968","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"25","title":"You have a single string which contains all the positive numbers upto N concatenated together. If you are given an input number then how would you find the index position of the number in the string.  Eg:","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Just calculate index performing arithmetic operations. Range is limited from 1 to 10000 so in my opinion arithmetic operations are best way. Code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"To try to avoid the if statements and make it work for all N"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"You can use some basic string operations to get the index. Here i have used a string till 30 integers but it will work for N number of Integers too."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"By the example, it seems the index begin with ZERO. (That is just a 1 value shift. :p) There is just a simple formula to get the index. 0-9, just 1 char 10-99, 2 chars 100-999, 3 chars...etc.. So, for input number, you can calculate how many chars before it based on the range.  And BTW, it is more interesting if trying to find the first substring which present the number. For example, input 202 should return 29 because \"2021...\" matching to 202."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Slightly cleaner ( 1 fewer else statements )  public static int findIndex(int n) {                if (n <= 10) {      return n - 1;  } else if (n <= 100) {      return (n - 10) * 2 + 9;  } else if (n <= 1000) {      return (n - 100) * 3 + 90 * 2 + 9;  } else {      return (n - 1000) * 4 + 900 * 3 + 90 * 2 + 9;               } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int indexOf(String str, int val) {    char[] a1 = str.toCharArray();   char[] a2 = String.valueOf(val).toCharArray();    int i = a2[0];   int j = (a1.length - a2.length);    for (int k = 0; k <= j; k++) {    if (a1[k] != i) {     do {      k++;     } while ((k <= j) && (a1[k] != i));    }     if (k <= j) {     int m = k + 1;     int n = m + a2.length - 1;     for (int idx = 1; (m < n) && (a1[m] == a2[idx]);) {      m++;      idx++;     }     if (m == n) {      return k;     }    }   }   return -1;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can get number of digits of a number without converting it to string but I will do it that way because JavaScript.  If you have number of digits then your index can be calculated like this:  For example for index of 102 you have:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void getIndex(int number){   \n  int numberLength = (int)(Math.log10(number)+1); \n  int index = 0; \n  for(int i=numberLength;i>;0;i--){ \n   index = (int) (index + ((number - Math.pow(10,i-1)) * (i))); \n   number = (int) Math.pow(10,i-1); \n  }  \n  System.out.println(\"Index :\"+index); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be solve using following formula  ??(9x10pow(i) ) + ((n-10.pow(d-1) ) x d)  where i = 0 to i < d and d = no. of digits in n"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Correction to earlier formula -   (??((9x10pow(i)).(i+1) ))  + ((n-10.pow(d-1) ) x d) where i = 0 to i < d-1 and d = no. of digits in n"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//d = No Of digits In Given number //n = given number; sum = 0; while(d >0) { x = pow(10, d-1); sum = sum + (n - x) * d; n = x; d--; }  //sum gives the index position for given number in the string.  eg: n = 1234 d = 4  sum = (1234 - 1000) * 4 + (1000 - 100) * 3 + (100 - 10) * 2 + (10 - 1) * 1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this will work -"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi,    What about if we have repetitive occurrences of the number, say 123 or 23, the I guess the first occurrence should be given as result."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"just add the difference of the number N-10 and add to N to get the index value ex: for number 20, 20-10 = 10,add 20+10=30, so index is 29 and 30 for 20..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"dim s:s=\"12345678910111213141516171819202122232425\"  a=inputbox(\"enter a char:\")  set oreg=new regexp oreg.pattern=a oreg.global=true  set omatch=oreg.execute(s) For Each Match in omatch   ' Iterate Matches collection.       if omatch.count<>0 then exit for end if    Next  msgbox \"count is : \"& omatch.count & \"index is : \" &match.firstindex set oreg=nothing"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"rurururu"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If we need to find the index of 20. Then find the first occurrence of the string \"202122\" /\"2021\" (the number || next number) which will be always unique."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5142389660319744","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"How would you represent a graph with million nodes ?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What kind of graph? Here are some approches: stackoverflow.com/questions/12188887/using-a-map-for-a-graph"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Before beginning the first question is how do we want the representation to be..is it one time use or used multiple times. Is it to be constructed at real time or stored and retrieved at run time.  Assuming it needs to be persisted and flexible for updates, here is one approach. Identity clusters in the points based on some distance function (which might not be linear). All the points in a cluster can be represented using an adjacency matrix approach and those edges between the clusters can be represented using a hashmap. Clearly this approach depends on the type of data objects and the type of clustering method adopted."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5977715047923712","download_status":"DOWNLOAD_DONE","votes":"-2","answersCount":"5","title":"What kind of Environment and Work you are expecting from Amazon?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"o I want my own office. o I want a secretary. o I want to be able to come in at 11 and leave at 3. o I want work that challenges me. o I want co-workers who don't ask idiotic questions like these."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Huge pay, no mundane work, freedom to do WHATEVER i want including dancing, singing etc. @ work"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Cool and neat definitely give some space for me to expose myself there should be a recognition for my work"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Want to be part of great product at the same time people should recognize my work.  Also expecting cool environment with work life balance."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6487304377991168","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"5","title":"What fields are contained in a defect report and brief description about each field?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Got nothing better to ask?   Typically -  Case ID Associated bug ID Summary of problem Description of Problem Error logs (Core dumps + any other debug information collected from site uploaded to a particular FTP site) Scenario to reproduce problem Current progress status Customer PoC  Version number, build number, patch numbers if any."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"--Expected results --Severity/Priority"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"category, assigned to, severity, priority, reproducibility, summary, description, Steps,  product, customer, Images, type of test"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Bug Id Bug Description  Severity Priority Steps to Reproduce files for reference to developers like error log,screenshot"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Defect ID (DI_01) Assigned By (Kaushal) Assigned Date (03/10/2014) Defect Raised in module (Module name) Defect Type (UI, Functional, DB) Defect Description Steps to reproduce Priority Severity(High, Medium, Critical, Low) Fixed date Status Remarks Screenshot"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6748271959605248","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"5","title":"A PDF file is not getting opened how will you debug this issue before reporting it to development team?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Non-Functional 1. Check file size 2. Check file type 3. acrobat reader is installed? Functional- 1. Check if other pdf is opening 2. Check mime type of pdf 3. Check what error showing while opening the file"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Check the file extension, it needs to be .pdf for it be read in any pdf reader software Check the file permissions Check the file is not 0B size To drill down whether its a file problem or software problem  Try to open the file with a different software, or just  Open a different pdf file using the same software and see if it works Act on the error returned when you opened the file and it failed"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Initially i will confirm whether it have some content with it, or not by its size. Make sure of the error by open it in nitro pdf and adobe  If same prob occurs means then try to convert it to word file or rich text format or even a image file. Else go with OCR converter, there you can definitely get the solution."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4914048260898816","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"12","title":"There are two questions that I want to ask. Q1) divide two numbers without ??/??? Q2) judge if there are two numbers in an array add to a given number For both the questions please consider minimum space and time complexity","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public static int divideWithoutOperator(int num, int divisor) { \n   \n  // handle case in which divisor is 0 \n  if (divisor == 0) { \n   return 0; \n  } \n   \n   \n  int quotient = 0; \n   \n  int iterator = 1;  \n   \n  // to handle -ve numbers \n  if (num < 0) { \n   num = num * -1; \n   iterator = -1; \n  } \n   \n  while (num > divisor) { \n   num = num - divisor; \n   quotient = quotient + iterator; \n  } \n   \n  return quotient; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int divideWithoutOperator(int num, int divisor) { \n   \n  // handle case in which divisor is 0 \n  if (divisor == 0) { \n   return 0; \n  } \n   \n   \n  int quotient = 0; \n   \n  int iterator = 1;  \n   \n  // to handle -ve numbers \n  if (num < 0) { \n   num = num * -1; \n   iterator = -1; \n  } \n   \n  while (num > divisor) { \n   num = num - divisor; \n   quotient = quotient + iterator; \n  } \n   \n  return quotient; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Q1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Q2. after sorting the array, we can run the following code to make it O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int divide(int number, int divisor){ \n      int custom= 0; \n      while(number >=divisor){ \n            custom++; \n            number= number-divisor; \n          \n      } \n      return custom; \n   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"question 1 can be solved with a right bitwise shift."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"1.As for dividing two numbers, if we can not use \"/\", why not use \"*\" instead?  Take \"a / b\" as an example. We can do following steps: (1)figure out the sign of the result: sign (2)define a rough range of the result: [L, R] (3)use binary search to find the result in the range, every time we only need to figure out the b * M, where M = (L+R)/2, and compare it with a to narrow the range. Time complexity: O(log(a)) Space complexity: O(1) following is C++ code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Q1: Use logarithms."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6037902303690752","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"Given a collection of 3-set sequences, where a 3-set sequence is defined as a list of 3 different pages (for example: mouse-keyboard-printer is a 3-set sequence, while printer-mouse-keyboard is another) accessed sequentially on amazon.com, find the most common 3-set sequence with minimum space and time complexity","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Assuming there can be more than 1 three set sequences:  have a hash table with key as a string (based on sequence of pages, say strcat  of the 3) and value as count(integer value).  have a struct having 2 elements-integer value for max count and vector of strings for the 3 page sequence.   if key exists in hashmap increase count, else add to map with value as 1  if (hashmap_count>struct_count)   {  //first call vector.erase          //update struct_count value   // then  push back the new sequence string  } else if (hashmap_count==struct_count)  //push back this string also to the vector. no need to worry about  duplicate as it will never happen"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hash Table"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can use a trie data structure storing the count of the sequence followed to reach the node. The element nodes store a pointer to a linked list. Whenever we get a sequence we move through the trie and increment the count at the specific node in the linked list using the pointer.  We can traverse the linked list in O(n) to find the most repeated sequence."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6210203154382848","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"16","title":"Given a list of test results (each with a test date, Student ID, and the student??s Score), return the Final Score for each student. A student??s Final Score is calculated as the average of his/her 5 highest test scores. You can assume each student has at least 5 test scores.  You may use the JDK or the standard template library. The solution will be evaluated on correctness, runtime complexity (big-O), and adherence to coding best practices. A complete answer will include the following:      Document your assumptions     Explain your approach and how you intend to solve the problem     Provide code comments where applicable     Explain the big-O run time complexity of your solution. Justify your answer.     Identify any additional data structures you used and justify why you used them.  class TestResult{    int studentId;    Date testDate;    int testScore; }  public Map getFinalScores(List resultList){    return null; }","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"import java.util.ArrayList; \nimport java.util.Date; \nimport java.util.List; \nimport java.util.Map; \nimport java.util.PriorityQueue; \nimport java.util.TreeMap; \n \npublic class StudentScore { \n \n public static Map getFinalScores( \n   List resultList) { \n \n  Map> topFives = new TreeMap<>(); \n \n  for (TestResult res : resultList) { \n   PriorityQueue topFive = topFives.get(res.studentId); \n   if (topFive == null) { \n    topFive = new PriorityQueue(); \n    topFives.put(res.studentId, topFive); \n   } \n   topFive.add(res.testScore); \n   if (topFive.size() > 5) { \n    topFive.poll(); \n   } \n  } \n \n  Map finalScores = new TreeMap<>(); \n  for (int id : topFives.keySet()) { \n   double total = 0.0; \n   for (int score : topFives.get(id)) { \n    total += score; \n   } \n   finalScores.put(id, total / 5.0); \n  } \n \n  return finalScores; \n } \n \n public static void main(String[] args) { \n  int[][] scores = { { 2, 78 }, { 2, 89 }, { 2, 97 }, { 2, 92 }, \n    { 2, 99 }, { 2, 66 }, { 2, 23 }, { 3, 78 }, { 3, 89 }, \n    { 3, 87 }, { 3, 92 }, { 3, 98 }, { 3, 66 }, { 3, 23 } }; \n \n  List resultList = new ArrayList<>(); \n  for (int[] score : scores) { \n   resultList.add(new TestResult(score[0], score[1])); \n  } \n \n  System.out.println(getFinalScores(resultList)); \n \n } \n} \n \nclass TestResult { \n int studentId; \n Date testDate; \n int testScore; \n \n TestResult(int id, int score) { \n  studentId = id; \n  testScore = score; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Use a map containing for each user a min heap with a size of 5. after that calculate for each user. Complexity n * log(5) == O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Use Map + MaxHeap  Link: github.com/techpanja/interviewproblems/tree/master/src/heaps/heap"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Assumptions: 1) The student id are in the range (0-max role number for students) with out any gaps.  2) To achieve constant insertion time to the map we use studentId as the key. So we assume that we have a hashmap with initial capacity = max role number for students 3) test scores are in the range of [0-100]  Approach: Lets say there is an object called TestResult which encapusulates testdate, studentId, testscore. These test results are stored in a hashmap with student id as the key      Map perStudentResults = new HashMap  Before we declare the score per student, heapify the results per student as a max heap. Once made as a max heap, get the max element 5 times and perform the average of the score and display it as the score.  Complexity: If there are n students p results for each students,  * Insertion to the hashmap for n student records -> O(n*p) * Heapify operation for p elements can be done in O(p). The heapify operation for n student is again n* O(p) = O(n*p) * For each student        for i = 1 to 5            * retrieve the max element and rearrange the heap = O(logp)            * Compute the average so far        end   end   Complexity here will be O(n*5logp) = O(nlogp)    * finally the complexity is O(n*p)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public Map getFinalScores(List resultList) { \n \n Map finalScores = new HashMap(); \n for (TestResult result : resultList) { \n     if (finalScores.containsKey(result.studentId)) { \n  finalScores.put(result.studentId, finalScores.get(result.studentId) + result.testScore); \n     } else { \n  finalScores.put(result.studentId, Double.valueOf(result.testScore)); \n     } \n \n } \n  \n return finalScores; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.*; \n \npublic class TestResult implements Comparable { \n \n    int studentId; \n    Date testDate; \n    int testScore; \n \n    TestResult(int id, Date dt, int score) { \n        studentId = id; \n        testDate = dt; \n        testScore = score; \n    } \n \n    @Override \n    public int compareTo(TestResult o) { \n        if (studentId > o.studentId) \n            return 1; \n        else if (studentId < o.studentId) \n            return -1; \n        else \n            return 0; \n    } \n \n    public Map getFinalScores(List resultList) { \n        Map result = new HashMap(); \n        Collections.sort(resultList); \n \n        int prevId = resultList.get(0).studentId; \n        ArrayList scores = new ArrayList(); \n \n \n        System.out.println(\"Result\"); \n        int len = 0; \n        for (TestResult t : resultList) { \n            len++; \n            if (prevId != t.studentId || resultList.size() == len){ \n                result.put(prevId, getAverageTopFiveScore(scores)); \n                System.out.println(prevId + \" \" + getAverageTopFiveScore(scores)); \n                prevId = t.studentId; \n                scores = new ArrayList(); \n                scores.add(t.testScore); \n            } \n            else { \n                scores.add(t.testScore); \n            } \n        } \n \n        return result; \n    } \n \n    public double getAverageTopFiveScore(ArrayList topFiveScores) { \n        Collections.sort(topFiveScores, Collections.reverseOrder()); \n        int sum = 0; \n        for (int i = 0; i < 5; i++) { \n            sum += topFiveScores.get(i++); \n        } \n        return sum / 5; \n    } \n \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class TestResult{  \nint studentId;  \nDate testDate;  \nint testScore;  \n}  \n \npublic Map getFinalScores(List resultList){  \n // test if input list if null or empty \nif(resultList != null || resultList.isEmpty()) { \n  // Sort using an O(nlogn) runtime sorting algo \nArrays.sort(resultList, new TestResultComparator()); \n  Map averages = new HashMap(); \n  int count = 0; \n  for(int i = 0 ; i 5) { \n     continue; \n    } \nelse if(count == 5) { \n     int avg = (averages.get(resultList.get(i).studentId) +resultList.get(i).testScore) /5 ; \n     averages.put(resultList.get(i).studentId, avg); \n     count++; \n    } else { \n     int acum = averages.get(resultList.get(i).studentId) +resultList.get(i).testScore; \n     averages.put(resultList.get(i).studentId, acum); \n     count++; \n    } \n   } \n  } \n } \n  \n return null; \n} \n \npublic class TestResultComparator implements Comparator { \n @Override \n public int compareTo(TestResult o1, TestResult o2) { \n  if(o1 == o2) \n   return 0; \n  if(o1.studentId = o2.studentId) { \n   return o1.testScore == o2.testScore ? 0 : o1.testScore > o2.testScore? 1 : -1; \n  } \n  return o1.studentId > o2.studentId ? 1 : -1; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The idea is to store information about every student in Map, where key is Student ID. Value of this Map is a special structure where the best 5 results are in PriorityQueue, but other are in some simple collection (like list).  So when we need to add new item we check if PriorityQueue has 5 items. If it has less - just add new item, otherwise we peek top item which is the worse among best 5 and compare it with given. After that we put new item to list or to priority queue (and put in list top heap item)  So add operation takes O(log 5) == O(1) constant time"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5700464825860096","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"4","title":"Write a function to remove all redundant characters in a given string with minimum space and time complexity","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"public static String removeRedundantChars(char[] input){ \n        //assume ASCII characters only  \n        boolean[] charTable = new boolean[128]; \n        int i = 0; \n        for(int j = 0; j < input.length; j++){ \n            if (!charTable[input[j]]) \n            { \n                charTable[input[j]] = true; \n                input[i] = input[j]; \n                i++; \n            } \n        } \n        return new String(input, 0, i); \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"This solution takes O(1) space - BitSet and result StringBuilder:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5339357867147264","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"17","title":"You are given an array A with elements 0 to n-1, numbers can be repeated in the array. Create n sets where  S[i]={a[i],a[a[i]],a[a[a[i]]]??}. Set has all elements unique. Find the size of the largest set.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"import java.util.LinkedHashSet; \nimport java.util.Set; \n \n \npublic class IterativeSubset { \n \n public static void main(String[] args) { \n   \n  int array[]=new int[]{5,6,3,1,4,7,8,9,2,11,12,2,4,6,9,4,1}; \n   \n  int arrayLngth=array.length; \n  int i=0; \n  Set sets=new LinkedHashSet(); \n   \n  for(int j=0;j"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can you provide an example?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static Set[] createSetOfElements(int a[]) { \n  Set[] allSets = new Set[a.length]; \n  int largestSetSize = 0; \n  for (int i = 0; i < a.length; i++) { \n   allSets[i] = new HashSet(); \n   int element = a[i]; \n   while (!allSets[i].contains(element)) { \n    allSets[i].add(element); \n    if (element < a.length) { \n     element = a[element]; \n    } \n   } \n   if (allSets[i].size() > largestSetSize) { \n    largestSetSize = allSets[i].size(); \n \n   } \n  } \n  System.out.println(\"Size of Largest set is \" + largestSetSize); \n  System.out.println(\"Printing elements in all sets\"); \n  int i = 1; \n  for (Set set : allSets) { \n   System.out.print(\"Set# \" + i++ + \" =>  \"); \n   for (Integer integer : set) { \n    System.out.print(integer + \" \"); \n   } \n   System.out.println(); \n  } \n  return allSets; \n } \n \n public static void main(String[] args) { \n  int a[] = { 1, 2, 3, 4, 4, 5 }; \n  createSetOfElements(a); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static Set[] createSetOfElements(int a[]) { \n  Set[] allSets = new Set[a.length]; \n  int largestSetSize = 0; \n  for (int i = 0; i < a.length; i++) { \n   allSets[i] = new HashSet(); \n   int element = a[i]; \n   while (!allSets[i].contains(element)) { \n    allSets[i].add(element); \n    if (element < a.length) { \n     element = a[element]; \n    } \n   } \n   if (allSets[i].size() > largestSetSize) { \n    largestSetSize = allSets[i].size(); \n \n   } \n  } \n  System.out.println(\"Size of Largest set is \" + largestSetSize); \n  System.out.println(\"Printing elements in all sets\"); \n  int i = 1; \n  for (Set set : allSets) { \n   System.out.print(\"Set# \" + i++ + \" =>  \"); \n   for (Integer integer : set) { \n    System.out.print(integer + \" \"); \n   } \n   System.out.println(); \n  } \n  return allSets; \n } \n \n public static void main(String[] args) { \n  int a[] = { 1, 2, 3, 4, 4, 5 }; \n  createSetOfElements(a); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class maxSet {     public static void main(String[] args) {    int a[] = {5,6,3,1,4,7,8,9,2,11,12,2,4,6,9,4,1};     int b[][] = new int[a.length][a.length];          for(int i=0;i     int j=i,n=0;          do{       boolean flag = false;       for(int k=0;k      if(b[i][k] == a[j])            flag = true;        }       if(!flag)            b[i][n]=a[j];            j=a[j];           n++;        }while(j       }        System.out.println(\"\\n\\nSets generated: \");     int count[] = new int[a.length];     int max=0;     for(int i = 0; i         for(int j=0 ; j       if(b[i][j] != 0){           System.out.print(b[i][j]+ \" \");         count[i]++;       }        if(count[i]>max)       max = count[i];       System.out.println();         }         System.out.println(\"\\nSize of largest Set is :\"+max);  } }  Input:  5 6 3 1 4 7 8 9 2 11 12 2 4 6 9 4 1   Sets generated:  5 7 9 11 2 3 1 6 8  6 8 2 3 1  3 1 6 8 2  1 6 8 2 3  4  7 9 11 2 3 1 6 8  8 2 3 1 6  9 11 2 3 1 6 8  2 3 1 6 8  11 2 3 1 6 8  12 4  2 3 1 6 8  4  6 8 2 3 1  9 11 2 3 1 6 8  4  1 6 8 2 3   Size of largest Set is :9"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Does the interviewer wants us to modify the given array so that we can find the longest such sequence? Or just print sequences (sets) to the given array?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"an interesting variation of the question is, what is the maximum possible size of any set S[i]. the answer is n. all n elements have to be unique  from 0 to n-1. another followup - if the n elements can be shuffled around ,create a set of sets of all possible maximum sets .  for example for number 0 1 2 3, {1,2,3,0},{1,3,0,2} are 2 orderings for S[0] to be of maximum size."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) { \n  int[] input = new int[] { 1, 2, 3, 4, 4, 5}; \n  int[] setSize = new int[input.length]; \n \n  int max = -1; \n  for (int index = 0; index < input.length; index++) { \n   Set set = new HashSet<>(); \n   int curr = input[index]; \n   boolean alreadySet = false; \n   while (!set.contains(curr)) { \n    set.add(curr); \n    curr = input[curr]; \n    if (setSize[curr] > 0) { \n     // -1 because a[curr] will already be there \n     setSize[index] = set.size() + setSize[curr] - 1; \n     alreadySet = true; \n    } \n   } \n   if (!alreadySet) { \n    setSize[index] = set.size(); \n   } \n \n   if (max < setSize[index]) { \n    max = setSize[index]; \n   } \n \n   System.out.println(\"for index \" + index + \" set size \" + setSize[index]); \n  } \n \n  System.out.println(max); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String args[]){ \n    \n   int arr[]=new int[]{5,6,3,1,4,7,8,9,2,11,12,2,4,6,9,4,1}; \n   int len = arr.length; \n   int maxcount = 0; \n   int count = 0; \n   Set finalSet=null; \n    \n   for(int i=0;i set = new LinkedHashSet(); \n    int num = arr[i]; \n    count = 0; \n    while(!set.contains(num)){ \n     set.add(num); \n     num = arr[num]; \n     count++; \n    } \n     \n    if(count>maxcount){ \n     maxcount = count; \n     finalSet = set; \n    } \n   } \n  System.out.println(finalSet);  \n  System.out.println(\"Maxsize is :: \"+maxcount); \n    \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String args[]){ \n    \n   int arr[]=new int[]{5,6,3,1,4,7,8,9,2,11,12,2,4,6,9,4,1}; \n   int len = arr.length; \n   int maxcount = 0; \n   int count = 0; \n   Set finalSet=null; \n    \n   for(int i=0;i set = new LinkedHashSet(); \n    int num = arr[i]; \n    count = 0; \n    while(!set.contains(num)){ \n     set.add(num); \n     num = arr[num]; \n     count++; \n    } \n     \n    if(count>maxcount){ \n     maxcount = count; \n     finalSet = set; \n    } \n   } \n  System.out.println(finalSet);  \n  System.out.println(\"Maxsize is :: \"+maxcount); \n    \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":",hlkjhkj"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4750615091609600","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"40","title":"int sum = 0;          for (int i = 0; i < m; i++)              for (int j = i + 1; j < n; j++)                  for (int k = j + 1; k < l; k++)                      sum++;  what will be the value of sum?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"We will have to solve this equation:    m-1     n-1       l-1    ??         ??           ??   1 i=0     j=i+1    k=j+1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"we will have to solve this equation  m-1   n-1       l-1 ??       ??           ??     1   i=0   j=i+1    k=j+1  =   m-1   n-1        ??       ??     ( l - j -2)   i=0   j=i+1         m-1     ??    (l-2)*(n-i-2) - (n^2/2 - n/2 - i^2/2 + i/2)    i=0       Solve the last equation and you will get the actual answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"summation over(n-1)(l-2)+(n-2)(l-3)+(n-3)(l-4)...(n-Z)(l-Z-1).... m times or till n-Z or l-Z-1 becomes negative  this has close form solution summation (n-z)(l-z-1) = nl + z^2 +z - lz-nz-n  = nl + z^2 - (l+n-1)z -n  this summation can be calculated over 1-> Z where Z = min(m,n,l-1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sum will be incremented by (m-1)*(n-i-1)*(l-j-1) times."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The answer is 1!+2!+---+ (l-2)!. I too could not find it directly. I had to debug and understand how the loop runs. It was completely dependent on the 'L' and not dependent on M and N. and by the way, since l-2 will be positive only when l>=3, the answer for l<=2 is 0.. for eg: if l = 6, then value is 1!+2!+3!+4! = 20..and for l=7 it will be 35.. and so on..   You can check it out.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sum=m*(l-2)*(n-1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"mrange = min(m, l-2) ??[(l-i-2)(l-i-1)/2] from 1 to mrange  sum = mrange*(mrange+1)*(2*mrange+1)/12 + mrange*(mrange+1)*(1-2*l)/4 + mrange*l*(l-1)/2; The closed form can be further reduced."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For (l >= n >= m):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"L * (L - 1) * (L - 2) / 6"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int sum=0; now the answer will be independent of n and m.  for(k=2;ksum+=??(lower bound 1 and upper bound l-k) a; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Look closely: sum = 0  => 0++ => always 0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In C++"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sum = Z*n*(l-1) + Z*(Z+1)*( 2*Z - 3*l -3*n +4)/6   Z=MIN( m, MIN(n,l-1) )"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I tried to solve the equation. And sum=m*m*m/6.0-(l-1)*m*m/2.0-(n*n/2.0-(l-1/2.0)*n+l/2.0-1/3.0)*m;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. First of all the condition should be:  {n > 1 and l > n}  2. After solving the summation: (sum from i=0 to m-1 (sum from j = i+1 to n-1 (sum from k = j+1 to l-1 {1} ))), the result would be:  sol = sol1 - sol2 + sol3/12 - sol4, where  sol1 = (((l*n)-l)-n+1)*m; sol2 = l*m*(m-1)/2; sol3 = (9*m*(m-1)) + (m-1)*m*(2*m-1); sol4 = n*(n-1)*m/2;  This could be further simplified..  If the answer is negative, then the sum would be 0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"l"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"should be 0 since for (int k = j + 1; k < l; k++)  is never to execute that k always not ( k < 1 )"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"sum = (l-2) * (n-1) * m, provided 0else sum = 0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"if (m <= 0 || n <= 1 || l <= 2) sum = 0; else sum = (l-2) * (n-1) * m;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"l"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"SUM =  m * n * l"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"Sum[ (n-i) * (l - i+1)]; i varies from 1 to m"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5827147503501312","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"List Functional and Non-Functional Test cases for Zip/Unzip tool?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"1. Zip the file then unzip the same zip file it should show the same files 2. Zip the folder containing multiple files it should be zipped successfully and on unzipping the file same folder and file should get extracted.  3. Check files should be intact after zipping and unzipping. 4. Zip a file at one machine then unzip the file of different machine containing same kind of os family also on different os and machine configurations. 5. Zip a zipped file, it should get zipped successfully. 6. Check the size after zipping, it should be less or equals to the size of file got zipped  Non functional test:  1. Compatibility testing: Zip a file at one machine then unzip the file of different machine containing same kind of os family also on different os and machine configurations. 2. check the behavior of zipping and unzipping while system is too much. Means multiple processes is running 3. Try to zip large file more than 1 gb or more, check the performance of zipping and unzipping 4. While an zipping or unzipping is going on, suddenly restart the computer, and afterwards check the validness of the data integrity. 5. if a zip if password protected then it should open with only the same password"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Non-Functional :- How easy is the process of zipping and unzipping, it should not be a lengthy process"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5968086721101824","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"13","title":"Given a linked list of integers, write a function to determine whether the given list has a loop or cycle anywhere in the list. The integer values may not be relied upon to be distinct.  You may use the JDK or the standard template library. The solution will be evaluated on correctness, runtime complexity (big-O), and adherence to coding best practices. A complete answer will include the following:      Document your assumptions     Explain your approach and how you intend to solve the problem     Provide code comments where applicable     Explain the big-O run time complexity of your solution. Justify your answer.     Identify any additional data structures you used and justify why you used them.     Only provide your best answer to each part of the question.  Use one of the following skeletons for your solutions. Java:  public class ListLoopQuestion {    public static class ListNode {       public int value;       public ListNode next;   }     public static boolean hasLoops( ListNode myList ) {    }  }     C++:  struct ListNode {    int value;    ListNode * next;  }  bool hasLoops( ListNode * myList ) {  }","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"There is well known solution for finding loops in the list. Maintain two pointers fast and slow. fast change as follows fast = fast.next.next slow change as follows slow= slow.next If they meet at some point then there is a loop. If fast reach the end of the list then there is no loop."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"An implementation of the \"fast and slow pointers\" solution. The fast pointer moves two steps every time and the slow pointer only moves one step. If they meet at some point then there is a loop."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In C++:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java code for the same algo - thanks to @thelineofcode"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class ListLoopQuestion {  \n \npublic static class ListNode {  \n \npublic int value;  \n \npublic ListNode next;  \n}  \n \npublic static boolean hasLoops( ListNode myList ) {  \n if(myList == null || myList.next == null) { \n  return false; \n } \n \nListNode slow = myList; \n ListNode fast = myList.next; // this pointer is going to travel twice as fast as the first \n \n // If we find a null value as a next element then we don??t have loops \nwhile(fast != slow) { \n  slow = slow.next; \n  if(fast.next != null && fast.next.next != null) \n   fast = fast.next.next; \n  else \n   return false; \n } \n  \n // if the pointers meet at some point there is a loop in the list \n return true; \n  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What is the algo to Find the starting point of the loop?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static boolean hasLoops( ListNode myList ) {  \n    for (ListNode hare = myList, tortoise = myList; true; ) { \n        if (hare.next == null || hare.next.next == null) { \n            return false; \n } \n        if (hare.next == tortoise || hare.next.next == tortoise) { \n            return true; \n } \n        hare = hair.next.next; \n        tortoise = tortoise.next; \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"github.com/techpanja/interviewproblems/blob/master/src/collections/customlinkedlist/LinkedListImpl.java  #hasLoop()"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"careercup. com/question?id=5968086721101824"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static boolean hasLoops(listNode mylist){     listNode slow=mylist;     listNode fast =mylist;     while(fast!=null && fast.next!=null){     slow=slow.next;     fast = fast.next.next;     if(slow==fast){         break;     }     if(fast == null || fast.next ==null){     return null;     }     slow=mylist;     while(slow!=fast){     slow=slow.next;     fast=fast.next;     }     return fast; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Finding a loop in linked list single iteration:  we can use HashSet implementation of java. Below is code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what if the loop is bigger? I mean if the loop is not between the adjacent nodes. I am thinking if we put the addresses of each node in an array or hashmap as we traverse the linked list...and search if the address is already in the array before putting a new one..would cover the above scenario.  Thoughts?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6284997057052672","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"12","title":"Given two sorted singly linked lists, implement a function to merge the two lists into a single sorted list and return its head. You may destroy the original lists if you want.  You may use the JDK or the standard template library. The solution will be evaluated on correctness, runtime complexity (big-O), and adherence to coding best practices. A complete answer will include the following:      Document your assumptions     Explain your approach and how you intend to solve the problem     Provide code comments where applicable     Explain the big-O run time complexity of your solution. Justify your answer.     Identify any additional data structures you used and justify why you used them.     Only provide your best answer to each part of the question.  Example:  Input:  List 1: 1->2->3->4  List 2: 1->3->5->7  Output:  1->1->2->3->3->4->5->7  Use one of the following skeletons for your solutions. Java:  public class Node {  public int value;  public Node next;  public Node() {   value = 0;   next = null;  }  public Node(int value, Node next) {   this.value = value;   this.next = next;  } }  public class MergeListProblem {                  public static Node mergeLists(Node head1, Node head2) {   // your code goes here  } }  C++:  class Node {                                                        public:  int value;                                                                Node* next;                                                                                                                                       Node() {                                                                    value = 0;                                                              next = NULL;                                                          }                                                                         Node(int v, Node* n) {                                                      value = v;                                                              next = n;                                                             }                                                                        };   Node* mergeLists(Node* head1, Node* head2) {  // your code goes here }","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"public static Node mergeLists(Node head1, Node head2) { \n \n Node newHead = new Node(); \n if (head1.value <= head2.value) { \n     newHead.value = head1.value; \n     head1 = head1.next; \n } else { \n     newHead.value = head2.value; \n     head2 = head2.next; \n } \n Node prev = newHead; \n while (head1 != null && head2 != null) { \n     Node n = new Node(); \n     if (head1.value <= head2.value) { \n  n.value = head1.value; \n  head1 = head1.next; \n     } else { \n  n.value = head2.value; \n  head2 = head2.next; \n     } \n     prev.next = n; \n     prev = n; \n } \n while (head1 != null) { \n     Node n = new Node(); \n     n.value = head1.value; \n     head1 = head1.next; \n     prev.next = n; \n     prev = n; \n } \n while (head2 != null) { \n     Node n = new Node(); \n     n.value = head2.value; \n     head2 = head2.next; \n     prev.next = n; \n     prev = n; \n } \n  \n return newHead; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"#include  \n \ntemplate  \nstruct node { \n node(T value) : value{value}, next{nullptr} {} \n ~node() { if(next != nullptr) delete(next); } \n \n T value; \n node* next; \n}; \n \ntemplate  \nnode * merge_list(node * head1, node * head2) {  \n node* ptr1 = head1; \n node* ptr2 = head2; \n \n node* merged_list = nullptr; \n node* out; \n \n while(ptr1 != nullptr && ptr2 != nullptr) { \n  if(ptr1->value > ptr2->value) { \n   //std::cout << ptr2->value << std::endl; \n \n   if(merged_list == nullptr) { \n    merged_list = new node(ptr2->value); \n    out = merged_list; \n   } else { \n    out->next = new node(ptr2->value); \n    out = out->next; \n   } \n \n   ptr2 = ptr2->next; \n  } else { \n   //std::cout << ptr1->value << std::endl; \n    \n   if(merged_list == nullptr) { \n    merged_list = new node(ptr1->value); \n    out = merged_list; \n   } else { \n    out->next = new node(ptr1->value); \n    out = out->next; \n   } \n \n   ptr1 = ptr1->next; \n  } \n } \n \n while(ptr1 != nullptr) { \n  //std::cout << ptr1->value << std::endl; \n  out->next = new node(ptr1->value); \n  out = out->next; \n \n  ptr1 = ptr1->next; \n } \n \n while(ptr2 != nullptr) { \n  //std::cout << ptr2->value << std::endl; \n  out->next = new node(ptr2->value); \n  out = out->next; \n \n  ptr2 = ptr2->next; \n } \n \n return merged_list; \n} \n \nint main() { \n node* head1 = new node(2); \n head1->next = new node(2); \n head1->next->next = new node(4); \n head1->next->next->next = new node(6); \n \n node* head2 = new node(1); \n head2->next = new node(3); \n head2->next->next = new node(5); \n \n node* merged_list = merge_list(head1, head2); \n \n delete head1; \n delete head2; \n  \n node* ptr = merged_list; \n while(ptr != nullptr) { \n  std::cout << ptr->value << std::endl; \n  ptr = ptr->next; \n } \n \n delete merged_list; \n \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// this is C like code should be easy to adapt to Java. \n \nSingleNode *linkedListMerge(SingleNode *list1, SingleNode *list2) \n{ \n    SingleNode *head = nil; \n    SingleNode *current = nil; \n     \n    while (list1 != nil || list2 != nil) \n    { \n        int value1 = list1 ? list1.value : INT_MAX; \n        int value2 = list2 ? list2.value : INT_MAX; \n         \n        if (value1 < value2) \n        { \n            if (current != nil) \n            { \n                current.next = list1; \n                current = list1; \n            } \n            else \n                head = current = list1; \n             \n            list1 = list1.next; \n        } \n        else \n        { \n            if (current != nil) \n            { \n                current.next = list2; \n                current = list2; \n            } \n            else \n                head = current = list2; \n             \n            list2 = list2.next; \n        } \n    } \n     \n    return head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"C code to merge two sorted linked list. The original list is destroyed and pointers are modified  so as to obtain a sorted list. Hence space complexity is O(1) and time complexity is O(n+m) when n+m are total number of nodes in both the list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"By adjusting each node's pointer to next, we can have  (1)O(len1+len2) time complexity in worst case, and O(min(len1,len2)) in best (2)O(1) space complexity"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n \nclass Node{ \n \npublic:  \n \n int value;  \n Node* next;  \n  \n Node(){ \n  value = 0; \n  next = NULL; \n } \n Node(int v, Node* n) {  \n  value = v;  \n  next = n;  \n }  \n \n void PrintList(); \n}; \n \nvoid printList(Node* node){ \n \n  \n while(1){ \n   \n  std::cout << node->value; \n \n  if (node->next == NULL){ \n   std::cout << std::endl; \n   break; \n  } \n \n  std::cout << \" -> \"; \n  node = node->next; \n } \n} \n \nNode* mergeList(Node* head1, Node* head2){ \n Node* newNode; \n  \n if(head1 == NULL && head2 == NULL) \n { \n  newNode = NULL; \n \n }else if(head1 == NULL){ \n  newNode = new Node(head2->value, mergeList(head1, head2->next)); \n }else if(head2 == NULL){ \n  newNode = new Node(head1->value, mergeList(head1->next, head2)); \n }else if(head1->value < head2->value){ \n  newNode = new Node(head1->value, mergeList(head1->next, head2)); \n }else{ \n  newNode = new Node(head2->value, mergeList(head1, head2->next)); \n } \n   \n return newNode; \n} \n \nint main(){ \n \n Node* node1 = new Node(1, new Node(2, new Node(3, new Node(4, NULL)))); \n Node* node2 = new Node(1, new Node(3, new Node(5, new Node(7, NULL)))); \n \n  \n printList(mergeList(node1, node2)); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node* mergeSortedLists(node* head, node* head2) \n{ \n node* temp1= head; \n node* temp2=head2; \n node* temp3; \n node* temp4; \n int i=0; \n \n while( temp1 != NULL && temp2 !=NULL) \n { \n  if( temp1->data < temp2->data) \n  { \n   if( i==0) \n   { \n    head=temp1; \n   } \n   temp3=temp1->next; \n   temp1->next=temp2; \n   temp1=temp3; \n   //temp2=temp1; \n \n  } \n  else \n  { \n   if( i==0) \n   { \n    head=temp2; \n   } \n   temp4=temp2->next; \n   temp2->next=temp1; \n   temp2=temp4; \n   //temp1=temp2; \n  } \n  i++; \n \n } \n  \n  \n return head; \n \n \n \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5173708981272576","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"15","title":"Amazon has many visitors to its site. And it tracks what pages the customers visited, etc and other stuff. Make an efficient data structure for storing 3 days of information of all those customers who have visited site exactly two different days and searched more than 3 unique pages of the site in those 2 days.  So whoever visited site exactly two days out of these three days and visited more then 3 unique pages should be in the contact list.  What's the efficient approach to solve these kinds of problems??","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"I would go with a hashtable approach. create a hashtableH1 for storing username(key of H1) , hashtable H2 of pagestrings(key of H2), day(value of H2) which will be the value of H1.  For day 1 store info for all usernames in H1 and H2.  For day 2 for each username check if entry exists in H1. If so check if the pagestring is same . If so this means the same user visited the page twice in 2 different days. so increase the day count by 1. For day 3 for each username check if entry exists in H1. If so check if the pagestring is same . If so this means the same user visited the page twice in 2 different days. so increase the day count by 1. Now check the hash H1. For each username check the pagestring and day count. if the days is 1 or 2 for more than 3 pages this means he has visited more than 3 unique pages in 2 different days. hence output that username."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"We can use HashMap to store the user information. Here the key will be username and value will be another hashmap like: Map> userInfo = new HashMap>();  the userInfo will map user with their activity. the innermap will store user activity for a particular day. inner map will map particular date with the unique page visit for the particular day. at the end of the 3rd day iterate through the map for each user and check for the unique visit on a particular day. I think this satisfies the requirement."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I will use a map something like Map>> userInfo = new HashMap>>(); where I will add the date of the users visit as key and the list of page id of the pages visited by the user as the value in the inner Map. In the outer Map I will put this inner map as the value against the UserId as the key. So its up to you how do you want to process the criteria. If you wants to search for 5 days out of 12 days as mentioned by \"rmn\" you are free to do that. I think this is more generalized solution for this problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Question - About the 2 visits in 3 days  suppose user visits on 1st, 2nd and 3rd, so he is not to be tracked. But on 4th he doesn't visit the site, so as per 2 visits in 3 days he should be tracked i.e. visited on 2nd, 3rd and not on 4th  Is this assumption correct? also can you clarify around 3 days, are those need to be consecutive?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First of all, you should not come up with a solution that is specifically designed for this particular problem, i.e. 2 out of 3 days. Your solution should also work for, let's say 5 out of 12 days case.  Second, I think here the interviewer wants to hear something about distributed computing, rather than conventional data structures. We're talking about a huge amount of data, so my answer would be using a distributed database to store all this information and use database operators to find which customer visited how many pages for how many days."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I get what the other answers are doing but in the real world, this information is going to be in a database somewhere. Is it wrong to say we have something like the following -"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"its ia binary index tree problem where frequency is also added."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can use  hashmap HashMap dayCountMap where key is userid and value is no of days visited and hashmap of set HashMap> pageVisited where key is userid and value is set of pages visited by the user.  For day 1, we put  in dayCountMap if entry for key  does not exist in it. Also, if entry of key  does not exist in pageVisited, we create a new set with the page string and put it in pageVisited as . If the entry of the key  exists, we just add the page to the set (it'll be discarded if it is duplicate).  For day 2, we increment the value integer in dayCountMap by one if key for  exists or put an entry  in it if it does not exist. We follow same process as in previous day for adding entries in page visited. For day 3, we repeat the process as for day 2. Finally, for all users we check if the integer value in dayCountMap ie. dayCountMap.get() == 2 (ie, user visited exactly for 2 days) and pageVisited.get().size() > 3 (ie more than 3 unique pages visited) and add the user to contact list if it satisfies both conditions"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5937940479868928","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"6","title":"WAP to check if a binary tree is balanced","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"/* \n    balanced: check if a binary tree is balanced. \n */ \n \n#include  \n#include  \n#include  \n \n/* standard tree node */ \nstruct treenode { \n        struct treenode *left; \n        struct treenode *right; \n}; \n \n \n/* max of two integers */ \nint \nmax(int a, int b) \n{ \n        return (a > b) ? a : b; \n} \n \n \n/* start by assuming tree rooted at node is balanced.  Recurse \n   to find left and right subtree heights.  Set balanced to false \n   if tree rooted at node is not balanced.  Leaf height is 0 \n   and leaf is balanced. \n \n   Note that balanced is untouched or set to false. \n */ \nint \nheight(struct treenode *node, int *balanced) \n{ \n        if (!node) \n                return 0; \n        int leftheight = height(node->left, balanced); \n        int rightheight = height(node->right, balanced); \n        if (abs(leftheight - rightheight) > 1) \n                *balanced = 0; \n        return max(leftheight, rightheight) + 1; \n} \n \n \nint \nmain(void) \n{ \n        struct treenode rightrightleaf = { \n                .left = NULL, \n                .right = NULL \n        }; \n        struct treenode right = { \n                .left = NULL, \n                .right = &rightrightleaf \n        }; \n        struct treenode root = { \n                .left = NULL, \n                .right = &right \n        }; \n        int balanced = 1; \n        height(&root, &balanced); \n        printf(\"Tree is %s\\n\", balanced ? \"balanced\" : \"not balanced\"); \n        return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just curious and pardon my ignorance. I have seen \"WAP\" in other questions. Why is it called WAP?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"github.com/techpanja/interviewproblems/blob/master/src/trees/treeproblems/CheckBalancedTree.java"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Balanced Tree: for each node, the difference between left subtree and right subtree should be less than or equal to 1 and left and right subtree should be balanced.  int height(Node root) {  if(root==null)   return 0;  else   return (max(height(root.left),height(root.right)) +1);  }  boolean balanced(Node root) {    int diff = Math.abs(height(root.left) - height(root.right));  if(root == null)     return true;  else {     if (root.left ==null && root.right == null)   return true;     else if (diff <=1 && balanced(root.left) && balanced(root.right))   return true;     else    return false;  } }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5115660266897408","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"3","title":"write a method to check if a binary tree is balanced","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static int height(BSTNode n) {  if (n==null)   return 0;  else return max(height(n.lChild),height(n.rChild))+1; } private static int max(int a , int b) { return (a>=b?a:b);  } public boolean balanced() { int diff = Math.abs(height(root.left)-height(root.right)); if (diff >1) return false; else return true; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"only need to check max_depth-min_depth<=1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Balanced Tree: for each node, the difference between left subtree and right subtree should be less than or equal to 1 and left and right subtree should be balanced. \n \nint height(Node root) { \n if(root==null) \n  return 0; \n else \n  return (max(height(root.left),height(root.right)) +1); \n } \n \nboolean balanced(Node root) { \n  \n int diff = Math.abs(height(root.left) - height(root.right)); \n if(root == null) \n    return true; \n else { \n    if (root.left ==null && root.right == null) \n  return true; \n    else if (diff <=1 && balanced(root.left) && balanced(root.right)) \n  return true; \n    else  \n  return false; \n } \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5110725081038848","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"3","title":"which is the bestway to implement  stack/queue  (would you go for arrays/linkedlist/arraylist etc) explain pros and cons","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I came across the following on stack Exchange, its about linked List vs Dynamic Arrays  In short:  The linked-list approach has worst-case O(1) guarantees on each operation; the dynamic array has amortized O(1) guarantees. The locality of the linked list is not as good as the locality of the dynamic array. The total overhead of the dynamic array is likely to be smaller than the total overhead of the linked list, assuming both store pointers to their elements. The total overhead of the dynamic array is likely to be greater than that of the linked list if the elements are stored directly. Neither of these structures is clearly \"better\" than the other. It really depends on your use case. The best way to figure out which is faster would be to time both and see which performs better.  Hope this helps!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Actually ArrayList based on arrays, so it is almost the same. Pros of arrays - fast random access, because you dont need to iterate over links. But in stack/queue it is doesnt matter. Pros of this approach - your queue or stack can become quite big, so it can cause promotion failure in from young ot tenured. Also when your array will become fullilled youl'll have long operation of memory allocation and replacing your data. in case of big arrays - big risk of OutOfMemoryError.  LinkedList pros - very fast append both to head and tail, low risj of outof memory error and there is no need to allocate big amounts of memory. Pros memory defragmentation and long garbage collecting. GC have to raverse all references(there are a lot of them in list) to be sure that all nodes are reachable."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Stack (LIFO) - Dynamic array would be suffice. You add items to the end of the array and you pop them from the end of the array which results in O(1) for add and removal.  Queue (FIFO) - Linked List as the element at the front of the list can be easily be popped with O(1). Arrays on the other hand would require a reshuffle of the elements which is O(n) for the pop operation."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6221763662839808","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"2","title":"Implement classes for a website that can be used for building your own computer in object-oriented design manner. Eg: If a user selects a motherboard, it should filter out all the incompatible CPUs etc. You have to implement various classes that can be used for implementing this functionality. Java preferred.  Thanks a lot.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I guess Observer design pattern will be helpful. CPU depends on mother board, Operating system depends on CPU architecture chosen, memory requirements depends on OS chosen and so on."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Primarily would go ahead with Abstract Factory Pattern on a broad sense. Also, other patterns may pitch in as complexity grows."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6110581555724288","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"4","title":"Design a object oriented class for a vending machine. My idea is that it should have the ability to take in money, item selection, serving item. But I am not sure how to put everything together using good object-oriented principles.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"class VendingMachine \n - boolean takeMoney(Money money); \n //Here item will contain type & quantity, no smart search required  \n //say user need half litere Coke. \n - Item pickItem(Item item);  \n - boolean isAvilable(Item item) \n - Double askForAmount(Input input); \n - Double valiDateAndReturnBalance(Money money); \nclass Money \n -CurrencyType type; \n -Double amount  \nclass MoneyValidator \n    - boolean validate(Money amount); \nclass Item \n -ItemType type; \n -Double quantity \n -String barcode; // May be anything else to identify it \nclass Input \n    - CommandType type; \n    - Double quantity \n - ItemType type; \nclass display \n    - void updateDisplay(String instructions) \nclass KeyPad \n    - Input readUserInput(Key key); \nclass Key \n    -KeyType type \n    -Double value \n  \nenum CurrencyType \nenum ItemType \nenum KeyType \nenum CommandType"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; \n \npublic class VendingMachine { \n private ArrayList itemlList; \n private ArrayList selectedItems; \n private Coin receivedCoin;  \n public VendingMachine(ArrayList itemlList) { \n  this.itemlList = itemlList; \n } \n public ArrayList getItemlList() { \n  return itemlList; \n } \n public ArrayList giveCoins(Coin coin){ \n  this.receivedCoin = coin; \n  return showUserChoiceList(); \n } \n private ArrayList showUserChoiceList() { \n  ArrayList userChoiceList = new ArrayList(); \n  for(Item item: itemlList){    \n   if(item.getPrice()<=receivedCoin.getValue()){ \n    userChoiceList.add(item); \n   } \n  }     \n  return userChoiceList; \n } \n public Coin getSelectedItem(ArrayList selectedItems){ \n  this.selectedItems = selectedItems; \n  return giveSelectedItem(); \n } \n private Coin giveSelectedItem() { \n  Coin returnCoin=null; \n  double value = receivedCoin.getValue(); \n  for(Item item: selectedItems){ \n   System.out.println(item.getName()+\" | \"+item.getPrice()); \n   value=value-item.getPrice(); \n  }   \n  return new Coin(value, receivedCoin.getCurrency()); \n } \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6235383104798720","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"Design \"YOU TUBE\".  Like how do you upload/where to do you upload/how do you fetch/ how millions of incoming requests will be addressed. Also take care of things like how do you provide services.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Create a User Class  2. Create a Upload class, containing methods related to file uploads  3. Create a Download class, containing methods related to file downloads  4. Create a Status class, having methods of number of Users online etc......."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Video class - Contains Video attributes like time, author, type, and other stuff; Media functionns like start, stop, pause, resume, previous,next; Youtube class - Upload, Download, archieve Playlist class SocialMedia class for shareit, like Comments class to contains comments/user data  User class - to contain user information UserStatus class UserPlaylist class extending playlist class Search/filter class (search video, related video, etc)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5664748918013952","download_status":"DOWNLOAD_DONE","votes":"-2","answersCount":"11","title":"Design question to find the most frequent sequence of web page views from a log file of all the web pages viewed. Say the sequence is 4.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"The way I see it, a sequence could be of a length=1 which means any individual page in the log file makes a sequence. Now the algorithm will be just to construct a HashTable and populate it with the pages and the number of occurrences for that page. Then we generalize it and \"design\" the question - \"What is the most frequent sequence of length N\" Say the sequence is 4 would mean that we ask for the most frequent sequence P1->P2->P3->P4. Then the algorithm should be just tuned to take not one page but N and store those as concatenated string as the key in the HashTable. Like P1#P2#P3#P4. The iterating over the log would be with a window of N elements instead of one at a time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What is the structure of the log file? Is it just a sequence of the page names e.g. 'page1, page2, page3' or there are some additional attributes like user name -> page?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"assume each page takes 1 sequence, and first we get all sequences of length 4. It is like (p1, p2, p3, p4), (p2,p3, p4, p5) etc, so it takes O(n) time. then we encode this sequence to a hashmap as the keys, and the frequency is value. We increase the value if the key has exited. it takes O(n) then just find the key with highest value. O(n)  Overall O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We could use Trie Data Strucutre to store the sequence of size k"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A Max-Heap data structure could be a nice solution to this problem. Each node represents a page and the key is its views count. Building a heap from n entries requires O(n log n) and insertion/heapify is ofcourse O(log n) .. Finding the most k frequent pages is O(k)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"assume pages are represented by page id??s. now keep looking for that sum, and use that sum as key for hashtable and value is count of how many time that sum was found"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5718616397840384","download_status":"DOWNLOAD_DONE","votes":"-2","answersCount":"8","title":"Arranging file system in the form of a binary tree. I think the interviewer meant B-Tree. She had a huge accent.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think, File system can be implemented using binary trees (or btrees etc). For example, in linux root directory can take the place of a root of the tree, with other files and directories underneath it.  eg:                      /            bin...         etc ....     For adding a new directory we need to identify its parent directory in the tree and insert into it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If it should be binary tree, I believe it`s fine. You can decide that node to the left is a file/folder inside the same folder as this one (it`ll be null for /). And right is a link to first file/folder inside this one.  So actually you`ll have linked list for file inside this foder (if nothing inside it or not a folder then null) and pointer to the next file/folder for parent folder (if last file/folder inside parent folder, then null) Let`s try with pseudographics"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"huge what?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Try to perform list files (LS -l  in linux ) and do BFS for the list of files"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4685835307843584","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"7","title":"Implement a method that flattens an iterator of iterators. I believe we will need a class to do it? Java preferred. Thanks.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Too easy"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package com.anand.learn.iter; \n \n/** \n * @author akeshri \n * \n */ \npublic interface MyIterable { \n  \n public MyIterator iterate(); \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What do you mean by \"flattens\"? Can you explain the question more specifically"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package testing; \n \nimport java.util.Iterator; \nimport java.util.List; \n \npublic class AddedIteratots { \n \n private List > iteratots; \n private Iterator currentit; \n private int currentItIndex = 0; \n public AddedIteratots(List > iteratots){ \n  this.iteratots = iteratots; \n  currentit = iteratots.get(0); \n } \n  \n public boolean hasNext(){ \n  boolean ret = false; \n  if(currentit.hasNext()) \n   ret=currentit.hasNext(); \n  else{ \n   currentit = iteratots.get(++currentItIndex); \n   if(currentit != null) \n    return hasNext(); \n  } \n  return ret; \n } \n  \n public Object next(){ \n  Object ret = null; \n  if(currentit.hasNext()) \n   ret = currentit.next(); \n  else { \n   currentit = iteratots.get(++currentItIndex); \n   if(currentit != null) \n    return next(); \n  } \n  return ret; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; \nimport java.util.Iterator; \nimport java.util.List; \n \npublic class FlattenedIterator implements Iterator { \n private List> itrs; \n private volatile Iterator currentItr; \n private volatile int currentItrIndex; \n \n public FlattenedIterator(List> itrs) { \n  if(itrs != null) { \n   this.itrs = itrs; \n   this.currentItr = itrs.get(0); \n  } else { \n   this.itrs = new ArrayList>(0); \n   this.currentItr = null; \n  } \n  this.currentItrIndex = 0; \n } \n  \n @Override \n public boolean hasNext() { \n  if(this.currentItr == null) { \n   return false; \n  } \n  do { \n   if(this.currentItr.hasNext()) { \n    break; \n   } else { \n    if(currentItrIndex + 1 < itrs.size()) { \n     this.currentItr = itrs.get(++currentItrIndex); \n    } \n   } \n  }while(currentItrIndex + 1 < itrs.size()); \n  return this.currentItr.hasNext(); \n } \n \n @Override \n public K next() { \n  if(this.currentItr == null) { \n   return null; \n  } \n  do { \n   if(this.currentItr.hasNext()) { \n    return this.currentItr.next(); \n   } else { \n    if(currentItrIndex + 1 < itrs.size()) { \n     this.currentItr = itrs.get(++currentItrIndex); \n    } \n   } \n  } while(currentItrIndex + 1 < itrs.size()); \n  return this.currentItr.next(); \n } \n \n @Override \n public void remove() { \n  if(this.currentItr != null) { \n   do { \n    if(this.currentItr.hasNext()) { \n     this.currentItr.remove(); \n     return; \n    } else { \n     if(currentItrIndex > 0) { \n      this.currentItr = itrs.get(--currentItrIndex); \n     } \n    } \n   } while(currentItrIndex > 0); \n   this.currentItr.remove(); \n  } \n } \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5705699820568576","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"24","title":"Write a method which takes an array input and returns true if the sum of any two elements is equal to the sum of the corresponding indices. Like if for an array the sum of values at any two indices i and j is equal to the sum of i and j.  I can't think of any other way to do it except brute force.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"Since we know we are looking for pairs where x+y = A[x] + A[y], by simple algebra, you can also look for x-A[x] = A[y]-y"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"walk the input array (say A) and create another array of structures (B). such that b[i].index = i b[i].diff = a[i] - i;  Now our problem is reduced to finding two elements in B such that the sum of diff is zero! To do that sort the new array on the key = abs(b[i].diff)  now walk the array b, and see if any adjusant elements sum is zero. If yes, then we got our target, if not we didnt!  This will be O(n + nlogn + n) == O(n log(n)) solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"O(n) solution,   Basically keep a track of (Value - Index) of all the  element you walked thru, if you happen to see one that the result of (index - value) is logged previously you got the pair ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* \nAssume int i and j are index positions. \n2 Possible Cases: \n1) arr[i] = i, arr[j] = j \nthus, arr[i] + arr[j] = i + j \n2) arr[i] = j, arr[j] = i; \nthus, j + i = i + j \n*/ \n \npublic static boolean isSumEqualToIndices(int[] arr) \n{ \n    if (arr == null || arr.length < 2) \n        return false; \n     \n    HashMap ht = new HashMap<>(); \n     \n    for (int i = 0; i < arr.length; i++) \n    { \n        if (arr[i] == i) \n        { \n            if (ht.containsKey(null) == false) \n                ht.put(null, i); \n            else \n                return true; \n        } \n         \n        if (arr[i] != i) \n        { \n            if (ht.containsKey(arr[i]) \n            { \n                if (ht.get(arr[i]) == i) \n                    return true; \n            } \n        } \n         \n        ht.put(i, arr[i]); \n    } \n     \n    return false; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It can be done in O(n). 1) Create a temp array such that temp[i] = i-arr[i] 2) Find any two indexes i, j in temp arrray such that their sum is 0. This can be done in O(n) using hashing. ( Same approach as to find a target sum using any two elements of array )"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for(int i=0;i if( a[i] == a[ a[i] ] ) return true; return false"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Let's say i'th and j'th element in the array are p and q, respectively . What we want is"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This question is ambigous and can be understood in two different ways:  1. return true if at least a pair of numbers satisfies the requirement.   2. return true if all pairs of numbers satisfy the requirement.  Both are O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This question is ambigous and can be understood in two different ways:  1. return true if at least a pair of numbers satisfies the requirement.   2. return true if all pairs of numbers satisfy the requirement.  Both are O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Sum { \n \n \n    //a[i]+a[j]=i+j \n    //a[i]-i =j-a[j] \n \n    public static void main(String[] args) { \n        int[] array = {6, 1, 3, 2, 10, 14, 50}; \n        Map hashmap = new HashMap(); \n \n        for (int i = 0; i < array.length; i++) { \n \n \n            hashmap.put(array[i] - i, i); \n        } \n \n        for (int i = 0; i < array.length; i++) { \n \n            if (hashmap.containsKey(i-array[i]) && hashmap.get(i-array[i])!=i) \n            { \n \n               System.out.print(\"the condition is true   \" +\"index1: \"+ i +\", value1: \"+array[i]+\", index2: \"+hashmap.get(i-array[i])+\", value2: \"+array[hashmap.get(i-array[i])]); \n                break; \n \n            } \n \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Check if it is {0,1,2,3..} (Ai==i), if yes, return true, otherwise false."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public boolean hasSuchPair(int[] arr) {  \n    HashSet set = new HashSet<>(); \n    for (int i = 0, temp = 0; i < arr.length; ++i) { \n        temp = arr[i] - i; \n        if (set.contains(temp)) { \n            return true; \n        } \n    } \n    return false;  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"actually I found the array is just 0, 1, 2, 3, 4..... proof:  consider the first three elements, namely x, y, z so x has index 0, y->1, z->2 we have the following equations: x+y = 0+1=1 y+z = 1+2 = 3 x+z = 0+2 =2 so we get x = 0, y = 1, z =3 it is a fixed solution now we prove that the array is 0, 1, 2, 3..... as follows:  suppose we have any two distinct elements a1, a2(suppose a2 is not the last element) in that array, and a3 is the element right next to a2, so the index[a3]=index[a2]+1 we have a1+a3 = index[a1]+index[a3] = index[a1]+index[a2]+1=a1+a2+1 so we have a3 = a2+1 which means we have an unique array 0, 1, 2, 3, 4,...... END"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6101286072090624","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"You are responsible for maintaining a web service that sits behind a load balancer. If the web service starts failing, how will you go about fixing it?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"If a specific web server starts failing you could remove this one from load balancer connection pool until problem be fixed. Using a cloud infrastructure, could be easy start a new server to replace that one with problem...   If you have a software problem happening in all servers. It could be a capacity problem and the solution could be adding new servers to the pool to reduce the load."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is to be handled using the concept called fault tolerance. A bit of it is explained below.  When a server crashes or a hard disk runs out of room in an on-premises datacenter environment, administrators are  notified immediately, because these are noteworthy events that require at least their attention ?? if not their  intervention as well. The ideal state in a traditional, on-premises datacenter environment tends to be one where failure  notifications are delivered reliably to a staff of administrators who are ready to spring into action in order to solve the  problem. Many organizations are able to reach this state of IT nirvana ??C however, doing so typically requires extensive  experience, up-front financial investment, and significant human resources."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5749828462051328","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"8","title":"You are given two version numbers of a software, like Version 10.3.4 and Version 10.3.41. Write a program in Java to find out which of the version numbers are the latest. If version 1 is latest output -1, if version number 2 is latest output +1 else output 0 if same version. Both the version numbers are taken as string.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"public static int cmpVersion(String ver1,String ver2){ \n        String [] sarr1=ver1.split(\"\\\\.\"); \n        String [] sarr2=ver2.split(\"\\\\.\"); \n        for(int i=0;ii){ \n                val2=Integer.parseInt(sarr2[i]); \n            } \n            if(val1!=val2 ){ \n                return ((val1-val2)>0) ? -1 : 1; \n            } \n        } \n        return 0; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int compareVersions(String v1, String v2){ \n  String[] sp1 = v1.split(\"\\\\.\"); \n  String[] sp2 = v2.split(\"\\\\.\"); \n     int min = sp1.length>sp2.length?sp2.length:sp2.length; \n     for(int i=0; i0?-1:1; \n      } \n     } \n     if(sp1.length!=sp2.length) \n      return sp1.length>sp2.length?-1:1; \n     else \n      return 0; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int compareVersion(String v1, String v2){ \nString v1_ = v1.replaceAll(\"\\\\D\", \"\"); \nString v2_ = v2.replaceAll(\"\\\\D\", \"\"); \nif (v1_.isEmpty() && !v2_.isEmpty()) return 1; \nelse if ( !v1_.isEmpty() && v2_.isEmpty()) return -1; \nelse if ( v1_.isEmpty() && v2_.isEmpty()) return 0; // invalid inputs \nreturn Integer.parseInt(v1_)>Integer.parseInt(v2_) ? -1 : 1; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static int compareVersion(String ver1, String ver2) { \n  String[] str1 = ver1.split(\"\\\\.\"); \n  String[] str2 = ver2.split(\"\\\\.\"); \n  int loopCount = str1.length > str2.length ? str1.length : str2.length; \n  if (!str1[0].isEmpty() && !str2[0].isEmpty()) { \n   for (int i = 0; i < loopCount; i++) { \n    int v1 = Integer.parseInt(str1[i]); \n    int v2 = Integer.parseInt(str2[i]); \n    if (v1 == v2) \n     continue; \n    else if (v1 > v2) { \n     int v11 = Integer.parseInt(str1[i].substring(0, 1)); \n     int v21 = Integer.parseInt(str2[i].substring(0, 1)); \n     if (v11 >= v21) \n      return -1; \n     else \n      return 1; \n    } else if (v2 > v1) { \n     int v11 = Integer.parseInt(str1[i].substring(0, 1)); \n     int v21 = Integer.parseInt(str2[i].substring(0, 1)); \n     if (v21 >= v11) \n      return 1; \n     else \n      return -1; \n    } \n   } \n  } else if (str1[0].isEmpty() && str2[0].isEmpty()) { \n   return 0; \n  } else if (str1[0].isEmpty()) \n   return 1; \n  else if (str2[0].isEmpty()) \n   return -1; \n  else \n   return 0; \n  return 0; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can remove all the dots except the first dot. This will result in a floating point number. We can directly do the fp comparison."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5071420023373824","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"6","title":"write a program to convert  a number in indian rupees form such that we input 11200234 then output come 1,12,00,234 in c language pls help","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include void print(int n,int flag) {     if(n<100)     {         printf(\"%d\",n);         return;     }     int a=100;     int b=0;     if(flag==1)     {         a=a*10;         flag = 0;         b=1;      }     print(n/a,flag);      if(n%a==0)      {       printf(\",%d%d\",0,0);      }     else if(n%a<10)        {             printf(\",%d%d\",0,n%a);        }     else       {           printf(\",%d\",n%a);       }     if(b==1)     {         if(n%a==0)             printf(\",%d%d%d\",0,0,0);        else if(n%a<10)             printf(\",%d%d%d\",0,0,n%a);        else if(n%a<100)             printf(\",%d%d\",0,n%a);        else             printf(\",%d\",n%a);      }   } main() { int a; scanf(\"%d\",&a); print(a,1); return 0;   } if any thing wrong please comment here"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include void divide(int); main() { long int n;   printf(\"Enter the number:\");     scanf(\"%ld\",&n);   divide(n); } void divide(int n) {    char digit[30];   int d,i=0,count=0,j;   while(n!=0)   {      d=n%10;     n=n/10;     digit[i++]=d;      count++;      if(count==3 && i==3)       {          digit[i++]=',';          count=0;       }      else if(count==2 && n!=0 && i>3)       {          count=0;         digit[i++]=',';       }   }    i--;     j=i;   while(j>=0)   {        if(digit[j]==',')       printf(\"%c\",digit[j]);      else       printf(\"%d\",digit[j]);       j--;   } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"similar implementation in Java"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just try the below one once.  //"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"here's the code for you man, cheers!!!"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4859951939846144","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"10","title":"Find the pair of numbers that sums to an integer k from an linked list.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"As mentioned by Ayush, if there are no space constraints, a \"map/hashtable\" can do the job in O(n) where \"n\" is the length of the list (in fact the number of distinct numbers on the list). I added a simple java function for that."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"public static void findPair(int [] array , int k){ \n  HashMap map = new HashMap(); \n   \n  for (int i =0 ; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"use a hashtable  time complexity O(n) space complexity O(MAX(list)-MIN(list)+1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//suppose that integer is 5 \n  LinkedListtest=new LinkedList(); \n  //adding some elements \n  test.add(1); \n  test.add(2); \n  test.add(4); \n  test.add(3); \n  test.add(6); \n  test.add(5); \n  for (Integer no1 : test) { \n   if(test.contains(5-no1)) \n    System.out.println(\"OUTPUT:\"+no1+\" \"+(5-no1)); \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Previous answer is O(n^2). This one is O(n*logn), assuming that find a number in a set takes logN."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about converting the array to a BST and then for a node(say root node) in the bst search for some other node(say target node) whose value when added with the reference node will give the desired sum. Now delete the reference node and target node . Continue this process untill last 2 nodes are present. Every search will happen in O(log m) where m is number of elements in BST. With each iteration value of m will decrease by a factor of 2 as we will delete the reference node. If space is not a constraint then we can improve the results further by using DP."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In Python:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5071646582898688","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"15","title":"You have given a number, rearrange the digits of given number and find the next large number.  For example given number is 2576 the next large number is 2657  code is not required approach or algo is enough.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Algo:  1) Starting from the end of the number keep checking each digit and store max value till the following condition is met:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static void next(int[] number) {         PriorityQueue queue = new PriorityQueue();          LinkedList list = new LinkedList();          int index = -1;         for (int i = number.length - 1; i >= 1; i--) {             queue.add(number[i]);             if (number[i] > number[i - 1]) {                 queue.add(number[i - 1]);                 boolean done = false;                 index = i;                 while (!queue.isEmpty()) {                     int v = queue.poll();                      if (v > number[i - 1] && !done) {                         number[i - 1] = v;                         done = true;                     } else {                         list.add(v);                     }                 }                 break;             }         }          if (index != -1) {              for (Integer v : list) {                 number[index] = v;                 index++;             }              System.out.println(Arrays.toString(number));         }     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Assuming number is loaded into an array of characters with size num_digits. The same algo can be modified to not use additional array and extract the digits at a given position. \n cur_max = num[num_digits-1]; \n cur_max_pos = num_digits-1; \n for(i=num_digits-2; i>=0; i--) { \n  if (num[i] < cur_max) { \n   swap(num, i, cur_max_pos); \n   break; \n  } \n  if(num[i] > cur_max) \n   cur_max_pos = i; \n } \n \n        if(i<0) { \n  //Digits sorted in decreasing order from beginning \n  printf(\"Sorry, no number greater than this possible\"); \n } \n \n sort_asending(num, i+1, num_digits);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Find the first digit starting from least significant digit that has a greater digit and with the smallest difference when compared with the other digits on the right. Swap these two. Then sort the remaining digits to its right in decreasing order."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Let the digits be stored in an array of size n."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Traverse the whole number and store each digit in array 2. Start from last position to first position"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Traverse the whole number and store each digit in array 2. Start from last position to first position"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Starting from tenth place move to left.  1. Replace the current position digit with the digit greater then this in right. 2. Arrange the all right digits in ascending order."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Find a digit smaller than digits behind,  swap two digits,and sort the digits from that position"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5207705241255936","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"6","title":"Suppose you are given a set of small boxes, numbered 1 to n, identical in every aspect except that each of the first i contains a pearl whereas the remaining n-i are empty. You can have two magic wands that can each test if a box is empty or not in a single touch, except that a wand disappears if you test it on a box that is empty. Show that, without knowing the value of i, you can use the two wands to determine all the boxes containing pearls using at most o(n) wand touches. Express as a function of n, the asymptotic number of wand touches needed.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Reference - webdocs.cs.ualberta.ca/~mreza/courses/204-F07/tut-notes/tut2.txt We will fix number k later. The idea is first use one wand on boxes 1, k, 2k, 3k, ... The smallest i for which the wand burns on box i*k indicates that the first empty box is among (i-1)*k+1....i*k Now we use the second wand sequentially from (i-1)*k+1 to i*k-1 to find it. The total number of toches will be at most: n/k + k n/k is the number of boxes for the first wand and k for the second one  If we now choose k to be (about) \\sqrt{n} then we have n/\\sqrt{n}+\\sqrt{n} which is in O(\\sqrt{n}) touches."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This might sound foolish, but shouldn't you just:  (1) Go over each box in sequence (2) If your wand disappears for box k, the rest of the boxes (n - k) are empty  You don't even need to use the second wand. A perfectly valid O(n) algorithm unless I am missing something."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Follow this sequence, test 1,2, 4, 8,16,...... if 2pwd k is empty 2pwd k-1 to x Using second wand Ologn"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"grt question"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5774500532584448","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"10","title":"Write a function which verifies  a binary tree where all leaf nodes are at the same level.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algorithm:  1. Traverse the tree in level order fashion. 2. Set a flag to 0 initially. Flag is used to check if any leaf node is encountered. 3. Mark end of each level with NULL node. 4. When leaf node is encountered for the first time, set the flag to 1. 5. Traverse tree, and if any non leaf node is occured and flag is already set to 1, then it failes the conditoin 6. If NULL node is encountered indicating the end of a level and If the flag is set indicating leaf node is already occured then verify if queue is empty or not. If not then tree fails the condition."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Make preorder traversal and for each leaf count its depth. In a separate variable keep the level of the previously found leaf. When you reach next leaf compare its depth with the previous one. Code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public boolean check(Node root, int curLevel, int preLevel){ \n   \n  if (root.left==null &&root.right==null){ \n   // bottom of the tree \n   if (preLevel==0||preLevel==curLevel){ \n    preLevel = curLevel; \n    return true; \n   } \n   return false; \n  }else{ \n    \n   //go to left sub tree \n   boolean bLeft= false; \n   if (root.left!=null){ \n    bLeft = check(root.left, curLevel+1, preLevel);  \n   } \n   boolean bRight = false; \n   if (root.right!=null){ \n    bRight = check(root.right, curLevel+1, preLevel); \n   } \n    \n   return bLeft&&bRight;    \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Does it means that checking if the max_depth = min_depth?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can check the height of the immediate leftchid rightchild and save these values in 2 integers. Then check if the 2 ints are the same. If yes, then the leaves are at the same level otherwise not"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class BT \n { \n  public bool areAllLeavesAtSameLevel(Node root) \n  { \n   int levelOfLastLeaf = -1; \n   Queue q = new Queue(); \n   q.enqueue(new NodeLevel(root, 0)); \n   while(!q.isEmpty()) \n   { \n    NodeLevel nl  = q.dequeue(); \n \n    if(nl.node.getLeft() == null && nl.node.getRight() == null) \n    { \n     if(levelOfLast < 0) \n     { \n      levelOfLastLeaf = nl.level; \n     } \n      \n     if(nl.level != levelOfLastLeaf) \n     { \n      return false; \n     } \n    }     \n \n    if(nl.node.getLeft() != null) \n    { \n     q.enqueue(new NodeLevel(nl.node.getLeft(), nl.level + 1)); \n    } \n \n    if(nl.node.getRight() != null) \n    { \n     q.enqueue(new NodeLevel(nl.node.getRight(), nl.level + 1)); \n    } \n   } \n   return true; \n  } \n } \n \n class NodeLevel \n { \n  public Node node; \n  public int level; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Found the interesting answer for the same. geeksforgeeks.org/check-leaves-level/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algo Post order traversal"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"BFS version without recursion 1. Go through the tree level by level 2. Find level of the first leaf 3. For each next leafs check level, if levels are different, return false 4. At the end of BFS return true,"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6249266351702016","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"14","title":"Online assessment: There are N points on a 2D plane, find the k closest points.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"For small \"k\" this can be done in O(k N log(N)) using divide and conquer. Start by sorting the list of points with respect to \"x\" and \"y\". Let's form two sorted arrays this way, namely Ax and Ay.  1- Take Ax and divide it into lower and upper halves (roughly N / 2 length). That is, divide the array around its median (say Mx). 2- Run the algorithm for the first half and then second half, independently (divide and conquer: this is a recursive call). 3- Lets assume by solving it over the two subarrays, \"delta\" is the minimum length found. NOW We want to see if the two closest points are in different subarrays. 4- Now choose all points where \"|x - Mx| < delta\". 5- Go through all such points, (at most N). For a given point (x, y), look for the next \"7\" points on the array sorted with respect to \"y\". This will take O(N) time. At the end, if you find a pair with distance less than \"delta\", return it as solution, otherwise, return \"delta\".  I saw this algorithms in some course notes from Algorithm I in Stanford."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Clarification Required:  K closest point among each other? OR  K closest point from origin? OR K closest point from some given point?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can use k means algorithm. For example  n = 12 and k = 3. So we have to create 4 clusters (call it 'nc' - number of clusters) which contain 3 points. 1) Choose randomly 'nc' - 4 points as an initial cluster's centers. 2) Assign remaining points to the centers (closest points to the center's center are assigned to it). in this way we have just created clusters. 3) Recompute a center of each cluster. New cluster's center is the average of coordinates of all points in the cluster. 4) Repeat 2,3 till there is no changes in the clusters. In other words we found nc clusters which contain k closest points. 5) Check the total distance between points in each cluster and choose the one for which the total distance is minimum."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just a random thought:  If the problem were on 1D, the solution would be to sort the points in ascending order, then you would take the first k items and consider that your k-set of closest points with a cost equal to the difference of the k point minus the first one, then you'd visit k + 1 point and see if the distance between the k + 1 point and second one is smaller than the current minimum cost, if so, shift the k-item one point to the right, otherwise start a new k window with its first index located at the current point and repeat the procedure until you cannot create a k window anymore. By that time you'd have the k-set with the closest items, though, of course, you have to consider the edge case where you have less than k items in your original set.  That algorithm takes O(nlgn + n)  If we take close notice, the invariant we need to hold for the algorithm to work is that for all 1 <= i <= n - 1 point it is true that the euclidean distance d(i - 1, i) <= d(i - 1, i + 1), so can we still hold this property on a 2D scenario? I think so.  If you sort the items by its euclidean distance to the origin (in the scenario where all points are positive), then by triangulation the property holds. In the edge case where you have negative values for x or y axis, the property may break, so to fix that you'd have to locate the new origin with its x-axis equal to the smallest x value from the list of points and similarly, with the y-axis equal to the smallest y value from the collection.  This algorithm takes O(n) to find the smallest x and y values, O(lgn) to sort them in ascending order by its distance to the new origin and finally O(n) to get the k-set of closest points (using the euclidean distance as a way to calculate the cost of the current k-window)."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5639709426450432","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"37","title":"Two container of 5 L and 3 L are given. Then are is 9.5L water given you need to make 4L water with minimum attempts and water wastage.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"A(5L) B(3L) C(Big) --------------------------- 0         0          9.5 0         3          6.5 3         3          3.5 5         1          3.5 0         1          3.5  (5L waste) 1         3          0.5 4         0          0.5"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"From the problem statement, wastage can only happen if the user is allowed to use two jars only.  According to that assumption, I could think of following solution; Fill the --- 5L 0 2L 3L  2L 0 (3L wastage) 0 2L 5L 2L 4L 3L => (6 attempts)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"In SIX Steps with No Water Wastage.. Initially.. 0,0,9.5 step1:  5,0,4.5 step2:  2,3,4.5 step3:  2,0,7.5 step4:  0,2,7.5 step5:  5,2,2.5 step6:  4,3,2.5"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"But you cannot use 3 jars"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Let the water be distributed in the 3 jars(separated by commas) as below.  Initially: 0L,0L,9.5L, Distribute them into 5L and 3L jars as below: 5L,3L,1.5L  Now throw away the 1.5 (wastage = 1.5L) so the distribution becomes  5,3,0. From here... 5,0,3 2,3,3 2,0,6 0,2,6 5,2,1 4,3,1 (Four is captured inside the 5L can in a total of 8 steps.)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"4 steps : 1.First fill 3L and pour it into 5L and now 5L container has 3L and 2L empty 2.another 3L into 5L, so  1L will be left in 3L container 3.clear the 5L and fill it with 1L  that was left in 3L 4.fill 3L into the 5L , hence 4L."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"See the water which has been thrown out is only 3L which is in step 4th that is 2, 0, 3"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It can be done in following way but I don't know its minimal wastage or not... I am assuming we can only use two jar not 3 5,3,9.5 ------------------- 0,3,6.5 3,0,6.5 3,3,3.5 5,1,3.5 1,0,3.5 1,3,0.5 4,0,0.5 done I understand wastage is 9L..., but this the only way I could think of using two jars"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"5 steps, no waste. 0,0,9.5 1) 3,0,6.5 2)0,3,6.5 3)3,3,3.5 4)1,5,3.5 5)4,2,3.5"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"0 Ltrs, 0 Ltrs, 9.5 Ltrs (Given)  5 Ltrs, 2 Ltrs, 2.5 Ltrs (Now given changes to)  4 Ltrs, 3 Ltrs, 2.5 Ltrs (Given remains the same)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"5L 3L 9.5L  0  0  9.5   0  3  6.5   3  0  6.5 3  3  3.5 5  1  3.5   0  1  3.5  (-5L)   1  0  3.5 1  3  0.5   4  0  0.5"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Everyone is over thinking the problem.  Assuming you have  5L and 3L beaker, and 9.5L of water....  1)  Put the 3L beaker inside the 5L beaker, fill the remaining space inside the 5L beaker to the rim with water. You should now have 2L of water in the 5L beaker, transfer that water into the 3L beaker.  2)  Repeat the same motion, you should now have 2L of water inside the 3L beaker, and another 2L of water inside the 5L beaker, which equals a total of 4L!!!  two steps, no water wasted.  Don't over think life."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Pour half to 5 ltr i,e 2.5 ltr and full to 3 ltr , remaining water is   9.5-2.5-3 =  4ltr"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"9.5L   5L    3L 9.5 0 0 1.5 5 3 0 5 3 3 2 3 6 0 2 1 5 2 1 4 3"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Fill 5L can , pour 3L to 3L can. 2. put  remaining 2L in 5L can to 3L can. 3. Fill 5L can and pour 1L of the 5L to 3L can. Now you have 4L in the 5L can"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"0 0 9.5 5 0 4.5 2 3 4.5 2 0 7.5 0 2 7.5 5 2 2.5 4 3 2.5"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#include #include return(); int; char[ ] [ ]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"5                             3 --------------------------- 5   0 2   3 2   0 0   2 4.5   2 4   2.5"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"vol(A) - 5, vol(B) - 3, water thrown/wasted 0, 0, 0 5, 0, 0 2, 3, 0 2, 0, 3 0, 2, 3 5, 2, 3 4, 3, 3 in A I get 4L with wastage of 3L"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Fill the 5.  Pour slowly into the 3 until the bottom of the 5 container is almost exposed.  That is 2.5. Using the water already in it, do the same with the 3, that is 1.5. Pout that into the big container 2.5+1.5 = 4 total wastage 2.5-1.5 = 1 litre. 4 steps      /   /           /  /           /             /"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5152384183435264","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"9","title":"You are given an array of integers, sorted, but rotated. Find an better than O(n) algorithm to find an element in an array. Write code for this.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Modification of binary search. I assume there is no duplicates in array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public class Practice6 { \n \n public static void main(String args[])throws IOException{ \n  int arr[] = {4,5,6,7,8,1,2,3}; \n   \n  int num = 7; \n  int last = arr.length-1; \n  int first = 0; \n  performSearch(arr,first,last,num); \n   \n   \n } \n  \n public static void performSearch(int arr[],int first,int last,int num){ \n  int mid = (first + last)/2; \n   \n  if(arr[mid] == num){ \n   System.out.println(\"Index is :: \"+mid); \n   return; \n  } \n  else if(arr[first]= arr[first] && numarr[mid] && num <= arr[last]){ \n    binarySearch(arr,mid+1,last,num); \n   }else{  \n    performSearch(arr,mid+1,last,num); \n   } \n  } \n} \n  \n public static void binarySearch(int arr[],int first,int last,int num){ \n  if(first"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"do binary search. I think there is one same problem in leetcode."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There shouldn't be any duplicates in the array. The below java code would work fine  public static  int findElement(int[] a, int low, int high, int x) {  while(low<=high)  {      int mid=(low+high)/2;   if(a[mid]==x)    return mid;      else if(a[mid]<=a[high]){    if(x>a[mid]&&x    low=mid+1;    else     high=mid-1;   }   else   {    if(xa[low])     high=mid-1;    else     low=mid+1;   }  }  return -1;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There shouldn't be any duplicates in the array. The below java code would work fine  public static  int findElement(int[] a, int low, int high, int x) {  while(low<=high)  {      int mid=(low+high)/2;   if(a[mid]==x)    return mid;      else if(a[mid]<=a[high]){    if(x>a[mid]&&x    low=mid+1;    else     high=mid-1;   }   else   {    if(xa[low])     high=mid-1;    else     low=mid+1;   }  }  return -1;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int search(int arr[],int first,int last,int key) {  while((last>0)&&(first<=last))  {   int mid=(first+last)/2;     if(arr[mid]==key)   {    return mid;   }  else if(arr[mid]>key)  {   last=mid-1;   return(search(arr,first,last,key);  }  else    {    return(search(arr,mid+1,last,key);   } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \nusing namespace std; \n \nint testarray[20]={26,27,28,29,30,32,36,40,45,50,4,5,7,9,10,15,18,20,22,25}; \n \nint binary_search(int x, int start, int last) \n{ \n if(testarray[start]==x)return start; \n  \n else if(testarray[last]==x)return last; \n  \n  \n  \n else \n { \n  int middle =(start+last)/2; \n  if(start==middle) return -1; \n   \n  if(x>testarray[middle]) \n  return binary_search(x,middle,last); \n  else \n  return binary_search(x,start,middle); \n } \n} \n \nint find(int x,int start, int last) \n{ \n if(testarray[start]!=x && testarray[last]!=x) \n { \n  int middle=(start+last)/2; \n   \n  if(testarray[middle]==x) \n  return middle; \n   \n  if(testarray[middle]testarray[start] && testarray[start]x) \n  return find(x,start,middle); \n   \n  else if(testarray[middle]>testarray[start]) \n  return find(x,middle,last); \n   \n  else \n  cout<<\"not found\"; \n  return -1; \n   \n } \n  \n else  \n { \n  if(testarray[start]==x)return start; \n  else return last; \n } \n   \n   \n} \n \n \n \n \nint main() { \n // your code goes here \n int x,start=0,last=19; \n cout<<\"enter element you wanna search \\n \"; \n cin>>x; \n int pos=find(x,start,last); \n cout<>x; \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use custom Binary Search Find the mid element and then compare  a. if the search value is less that left_start & current_pos then proceed with left subtree. b. Else go for right sub tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Modification of binary search"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5139982465368064","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"15","title":"BST - find next immediate higher value  Ex . BST  2,3,6,9,7,4,13,24,19  find immediate highest value for 9 should be 13","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public bool Search(Node Root, int T, ref Node P) {    if(Root==null) return;     Node C = Root;    while(C!=null);    {     if(C!=null)     {       if(C.left==null)       {         if(C.Val>T && P==null)         {           P=C; return true;         }          C=C.Right;       }       else       {         Node R = C.Left;         while(R.Right!=null && R.Val!=C.Val)         {           R=R.Right;                      }         if(R.Right==null)         {            R.Right=C;            C=C.Left;         }         else         {           R.Right=null;           if(C.Val>T && P==null)           {             P=C; return true;           }            C=C.Right;         }       }     }   } return false; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"only need to find its successor."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do inorder traversal till you find first higher value then n - 9."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void findNext(Node *root,int target){ \n    public static Node * prev = NULL; \n    if(root == NULL) \n        return; \n    else{ \n        findNext(root->left,target); \n        if(prev != NULL){ \n            if(prev -> value == target && prev->value < root->value){ \n                printf(\"%d\",root->value); \n        prev = root;     \n        findNext(root->right,target); \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"tree* searchLeftmostnodeInRightSubtree (tree* root) \n{ \n        while (root->left) \n        { \n                root = root->left; \n        } \n        return root; \n} \n \ntree* inorderSuccessor (tree *root, int key) \n{ \n        if (root) \n        { \n                if (root->key == key) \n                { \n                        /*inorder successor will be in right subtree of node if right subtree exist*/ \n                        if (root->right) \n                        { \n                                tree *subtree = searchLeftmostnodeInRightSubtree(root->right); \n                                return subtree; \n                        } \n                        /*If right subtree of this node doesnot exist, then parent node for which leftsubtree consist this node*/ \n                        else \n                        { \n                                return root; \n                        } \n                } \n                tree *left = inorderSuccessor (root->left, key); \n                if (left) \n                { \n                        /*if immediate child is key*/ \n                        if (left->key == key) \n                        { \n                                return root; \n                        } \n                        /*tree is returning correct value*/ \n                        return left; \n                } \n                tree *right = inorderSuccessor (root->right, key); \n                return right; \n        } \n        return NULL; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int floor(int val, node x) \n{ \n if(x==null) \n  return null \n if(val>=x.val) \n { \n  a = floor(val, x.right) \n  if(a==null) \n   return x.val \n } \n else \n { \n  return floor(val, x.left) \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Logic: There can be three possibilities: 1. There is only one element in the tree 2. The key element is the left node of it's parent node 3. The key element is the right node of it's parent node  Approach: For case one there can be no result possible For case two parent of key node is the next larger element For case three parent of parent is the next larger element  Sol: Perform binary search on the tree to search key element just make sure you are keeping parent and parent's parent in temp var for current node while traversing tree  Time Complexity: nlog(n) Space Complexity: (2 * logn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ask how the BST is provided to you 1. If provided as 2 arrays (inorder and preorder) then binary search for element in inorder array and return next element. check for appropriate boundary conditions 2. If provided as object and pointers, assume a node also saves its parent in addition to left and right for convenience:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static boolean flag=false;   public static void inOrder(TreeNode root,int judge){    if(root!=null){     inOrder(root.left,judge);     if(flag) {      System.out.println(root.data);      flag=false;     }     if(root.data==judge) flag=true;          inOrder(root.right,judge);    }   }  t4.left=t3;t4.right=t5;       t3.left=t1;t3.right=t2;       t5.right=t7;t7.right=t6;       Integer judge=10;       inOrder(t4, judge);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this is equivalent to the problem of returning the left-most node in the sub-tree with elements greater than the value provided. Here's my attempt to solve it:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The leftmost node of right subtree"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Do an inorder traversal of the tree. The values will be in ascending order. Then do a binary search on resulting array to find the index of given number, and then find the next highest number in constant time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"a"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5169896912584704","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"3","title":"BST - find next immediate higher value  Ex . BST  2,3,6,9,13,24,19  find immediate highest value for 9 should be 13","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Do inorder traversal till you find first higher value then n - 9."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The following should work (code has comments):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What is the given input type ?      1) Is it preorder of the binary tree and the node value of which we need to find its successor?                       or      2) root of the BST and the node value of which we need to find its successor"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6224689877745664","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"13","title":"Given String ss = \"(a(b))(c(d(f))g)(y(h))  Find the max depth of parentheses.  Result should be numeric like here result should be 3 as \"f\" is surrounded by 3 parentheses.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"easy make a stack. push everytime you see a ( pop everytime you see a ) store a max value of the stack size."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Store the string in an array. Store two additional variables - max_count and current_count. Loop over the string, and whenever you see an open parenthesis push it onto a stack and increment the current count. When you encounter a closing parenthesis, pop the corresponding open parenthesis front the stack. Check is stack is empty; if yes, check if current count is greater than max. If yes, swap current and max. Repeat until the end of the string. Worst case complexity is O(N)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use a running_counter and another variable to store the max_depth. On seeing a left parenthesis, increment the running_counter by one and on seeing a right parenthesis, decrement the running_counter.  Each time the running_counter is incremented, check it against max_depth and update it if needed. In the end, max_depth will hold the maximum depth of the parentheses."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int count(String s) { \n char[] c = s.toCharArray(); \n int max = 0; \n int count = 0; \n int leftCount = 0; \n int rightCount = 0; \n for (int i = 0; i < c.length; i++) { \n     if (rightCount > leftCount) { \n   return -1; \n     } \n     if (c[i] == '(') { \n   leftCount++; \n   count++; \n   if (count > max) { \n    max = count; \n   } \n     } else if (c[i] == ')') { \n   rightCount++; \n   count--; \n     } \n } \n if (leftCount != rightCount) { \n     return -1; \n } \n return max; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String args[]){ \n  String ss = \"(a(b))(c(d(f))g)(y(h))\"; \n  int maxcount=0,count=0; \n  for(int i=0;i maxcount) \n    maxcount = count; \n  } \n  System.out.println(\"Max depth is :: \"+maxcount); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int findDepth(String input){      Stack stack=new Stack();      int max=Integer.MIN_VALUE;      for (int i = 0; i < input.length(); i++) {    if(input.charAt(i)=='('){     stack.push(input.charAt(i));    }    if(input.charAt(i)==')'){     max=Math.max(max, stack.size());     stack.pop();    }   }      return max;     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Stack; \n \npublic class MaxDepthParanthesis { \n \n    private int returnMaximumParanthesisDepth(String expression) { \n        Stack brackets = new Stack(); \n        int maxDepth = 0; \n        for (char c : expression.toCharArray()) { \n            if (c == '(') { \n                brackets.push(c); \n            } else if (c == ')') { \n                maxDepth = brackets.size() > maxDepth ? brackets.size() : maxDepth; \n                brackets.pop(); \n            } else { \n                continue; \n            } \n        } \n        return maxDepth; \n    } \n \n    public static void main(String[] args) { \n        MaxDepthParanthesis maxDepthParans = new MaxDepthParanthesis(); \n        System.out.println(maxDepthParans.returnMaximumParanthesisDepth(\"(a(b))(c(d(f))g)(y(h))\")); \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Incorrect qus: Given String ss = \"(a(b))(c(d(f))g)(y(h))    It should be  Given String ss = \"(a(b))(c(d(f))g)(y(h))\";  In case there was typo in qus as mentioned above:  Approach:  -Have two var counter,max=0 and and start traversing the string one char by next char -For each '(' occurrence perform counter++ and compare incremented counter value with max in case max-For each ')' occurrence perform counter--  At last  -If counter is null that means there were no '(' or ')' occurrence -If counter <> 0 that means few brackets are missing -If counter == 0 then just print all the string after max upto next ')' occurrence in case we want to print deepest string or else MAX is your ans"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int max_depth_of_parentheses(char [] exp){ \n  Stack stack =new Stack(); \n  int max = Integer.MIN_VALUE; \n  int current = 0; \n  for (int i = 0 ;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void ParenthesisDepth(string ip)         {                          char[] iparray = ip.ToCharArray();             int buffcount = 0;             int max = 0;             for (int i = 0; i < iparray.Length; i++)             {                 if (iparray[i] == '(')                 {                     buffcount = buffcount + 1;                     if (max < buffcount)                     {                         max = buffcount;                     }                 }                 if (iparray[i] == ')')                 {                     if (buffcount > 0)                     {                         buffcount=buffcount-1;                     }                     else { throw new Exception(\"Incorrect bracket formation\"); }                 }             }              Console.WriteLine(max);         }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5631708976119808","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"7","title":"You are given a long list of integers, so long that you can not fit the entire list into memory, implement an algorithm to get the max 100 elements in the list.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"11","title":"Use a min heap of size 100. Insert the first 100 elements of the list into the heap. From the 101st element, check if the current element in the list is greater than the min element in the heap. If yes, delete the min element and insert the current element into the min heap. Repeat this until the list is exhausted and in the end, the top 100 elements will be present in the heap."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about using external sorting instead of heap sort?    External Sort: en.wikipedia.org/wiki/External_sorting  Time complexity: stackoverflow.com/questions/10359661/time-complexity-cost-of-external-merge-sort"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"insert first k element in BST   klog k  now for n-k elements   element is smaller than smallest element in bst then delete it and insert curr element  logk finding smallest element + log k insert newly element in bst = 2 log k(worst case)  so overall its takes  klogk + (n-k)logk (find smallest) + (n-k)logk = klogk +2*nlogk -2*klogk = 2*nlogk + klogk = nlogk"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why not just use a hash table? Always insert each number into the table, no matter what. If it's already in there, it doesn't matter, since you are replacing a number with itself. Then return the 100 highest entries in the table as your new hash table, so you don't run out of memory.  We don't need to sort it, since the hash does that. We don't care if we have a duplicate, since each bucket only holds one item. Finally, we don't care where it falls in relation to anything else, since we always return the top 100 entries."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution with heap implemented in C++"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5685648396648448","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"Debugging testcases if a video file is VLC is not opening along with another scenario where only voice is playing not video.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question is not clear.  Dubugging testcases ? Is it for creating test cases to validate the above scenarios ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Verify that Video is enabled in VLC player. 2. Wrong overlay setting 3. Setting file is corrupted."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5648183396925440","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"Debugging testcases if a web site is opening in US but not in India","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"IP restriction testing. u can go with fly vpn for testing those scenarios"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a) Ping the Website Url from the local machine in india, to see if that website is up and running, by checking packets returned. b) Check if the correct website URL is typed in the browser address bar. c) Check if the port at which the website is hit, is supported by the host website. e.g. if user is trying to hit on https mode, and the website is actually hosted on http mode only. d) Check for browser compatibility. Check if the browser or the version of the browser in which the website url is hit, is supported by the application. e) Check for OS compatibility. Check for the OS on which the website url is hit, is supported by the application. for e.g we are trying to hit the url on a Windows XP (32-bit machine), but application is supported on a 64 bit machine. f) Check if the application is not restricted on the www domain, and is registered on the US country dns only. g) Check if the application has sensitive content which is not supposed to be shared with other countries, hence meant to be used in US only. h) Check if the application is registered on US country domain like -  Dot us, and thus not being accessible from India. i) Check if the website is blocked on the India Country DNS to be used in India, and hence not accessible. j) Check if the system from where user is trying to access the website, has firewall activated, which is restricting the site to be opened. k) Check, if the time, when User is trying to access the system, is peak business hours \\ usage hours, and the application is not hosted on a high performance server, thus it takes too much time to be loaded and user thinks its not working.  l) Probably there is some module in the application, which when accessed by some user in US, consumes too much system memory on server, or might be several threads which are consuming too much server memory, and thus slowing down the performance of the server. And Users from India trying to access that machine at that time faces performance issues, and application not opening. m) User trying to use the application on some device like ipad, mobile on which it is not supported."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5636887632936960","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"7","title":"Imagine a binary tree lying on the floor with nodes as balls and edges as threads, you are given a pointer to a node. When you pick the tree from that node up what will be the structure of the tree. You have gravity changing the structure of the tree","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Case 1: If the original root itself is choosen as the root and picked up, then the tree remains binary Case 2: Otherwise, the original root will have one child. Internal nodes with k children become nodes with k+1 children, where 1<=k<=2. Leaf nodes will have zero or one(in case a leaf is picked as the root) children."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"it would be a splay tree its like we are accessing a node that will become root and remaining tree will be adjusted as a binary tree by single or double rotation"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In my perspective it ll become a unbalanced tree with left subtree containing more nodes than right or vice verse. Any suggestions ??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"one more case: if it will choose internal node which has 2 child than this won't be Binary tree.... than root will have 3 child..."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5114168101306368","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"5","title":"Second question is Implement a boolean method for returning whether an appointment with a doctor is possible or not. Given that we have a set of start and end time frames already scheduled with the doctor.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"time complexity : O(nlogn)  typedef struct node  {  int start;  int finish; }node;  solution : { 1. Use the Priority_Queue  data structure by setting the priority of increasing finish time...    // means the one having less end_time will have greater priority;  2. Then  pop first node from priority_queue;     and set last_finish=node.finish;        Then pop nodes from priority_queue until Priority_queue is empty...                 if(node.start>last_finish)    return NOT_BUSY;                                   else BUSY in that appointment;  }// end   ----question based on activity selection"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simple solution: Go though each interval and check for conflict. O(n). Another solution use a 2D interval tree to make the queries. O (log n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why not maintain a schedule as a binary tree, where key is the starting point and data is the finish time:  for every new appointment 1. search for the node at which this appointment (node) can be inserted, by start times ... O(log n) 2. get the successor of the pre node ... O(log n) 3. check for conflicts: pre.finish < new.start && new.finish < successor(pre).start ... O(1) return true if no conflicts, and otherwise"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"input needed :  1. what is the length of the appointment to be scheduled? 2. What is the last time until which an appointment can be scheduled?  once we have these details, follow these steps: 1. arrange already scheduled appointments in increasing order of start time. O(nlogn) 2. traverse through the list and compute difference between end time and start of successive intervals. 3. an appointment can be scheduled if oneo f the following is satisifed: a) if the gap between any two successive appointments is greater than or equal to the length of the required appointment b) if there is enough time left in the day after last appointment to accomodate the new appointment"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5698980512006144","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"6","title":"Find the longest common substring between 2 string in O(n) complexity","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Here good description of the algo:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is it really expected for one to know Ukonnen and how it can be solved using suffix tree or suffix array? Wouldn't a simple dynamic n*m approach be enough for an interview?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The only solution possible for LC substring between two strings is : Manacher??s Algorithm"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(N) looks impossible to me unless some constraints have not been specified here."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Yep, suffix trees are your best bet. Though I wonder if they expect you to actually CODE it during the interview. Name dropping Ukkonen's algorithm is one thing, implementing it is another??"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5723432834564096","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"6","title":"There is a matrix which contains white cells , black cells and only one gray cell, need to go from (0,0) to (N-1, N-1) if Arra[N][N]  constraints:  a. The path should cover only white cells and should go via grey cell.  b. The node once visited cannot be visited again.   White cells are represented by 0, black cells by 1 and grey cell by 2.  Java preferred. I know there is another thread on the same problem, but apparently nobody has the correct solution there. Most of the suggested solution won't cover all cases.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This can be done in two phases. 1. In phase 1, find out the location of the grey cell by scanning the 2D array and let it's location be (i,j). 2. In phase 2, find out the paths from (0,0) to (i,j) and then from (i,j) to (N-1,N-1) using DP. The black cells can be treated as 'blocked' sites/paths and we have known DP solutions to traverse from a cell (i1, j1) to (i2,j2) with some paths blocked in between them."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"We can use a modified version of A*, having the heuristic to take into account the manhattan distance to the grey cell if the cell has not gone there yet. in addition we need to know for each candidate the path, so that we do not pass on the same cell twice. Thr main problem here is the space complexity. How do we store the path for each candidate. It could generate a huge amount of data."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the matrix were instead a graph, and we start at one vertex, must to through a gray vertex, and then finish at another vertex such that no edge is traveled twice, then we want to find two edge-disjoint paths from the gray vertex, one ending at the start location and the other ending at the end location. This can be solved with a network flow, where each edge has capacity 1, a flow of 2 starts at the gray vertex, and two flows of 1 are directed from the start and end to the sink. So a path is found iff the maximum flow is 2.  So it remains to transform the matrix into a graph. To do this, for each cell c, make two vertices c_in and c_out; direct an edge from c_in to c_out. Then, for each neighbor n, direct edges from c_out to n_in. This way, each path of the matrix must go through c_in and c_out for each cell in the path.  Time complexity with Ford-Fulkerson is O(N*M), since BFS is O(N*M) and max flow is only 2."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5747845428674560","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"9","title":"Print a 2D array in spiral order.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assume the matrix has dimention m*n, firstly print the surrounding number, reduce the dimension to (m-1)*(n-1), repeat the first step recursively until one dimension of the matrix reaches zero."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include #include using namespace std;  void printSpiral(int**,int,int,int,int); int main() {     int **arr;     int r=5,c=5;     int count=1;     int i,j;                  arr = (int**)malloc(r * sizeof(int*));       for (i=0; i      {         arr[i] = (int*)malloc(c * sizeof(int));       }          for(i=0; i        for(j=0; j            arr[i][j] = count++;         }     }     printSpiral(arr,0,r-1,0,c-1);      }  void printSpiral(int** arr, int startRow, int endRow, int startColumn, int endColumn){     int r;     int c;     for( r = startRow, c = startColumn; c <= endColumn; c++){         printf(\" %d \", arr[r][c]);     }     printf(\"\\n\");     for(r=startRow+1, c=endColumn; r<=endRow; r++){         printf(\" %d \", arr[r][c]);     }     printf(\"\\n\");     for(r=endRow, c=endColumn-1; c>=startColumn;c--){         printf(\" %d \", arr[r][c]);     }     printf(\"\\n\");     for(r=endRow-1, c=startColumn; r>=startRow+1; r--){         printf(\" %d \", arr[r][c]);     }     printf(\"\\n\");     if(startRow+1    {         printSpiral(arr, startRow+1,endRow-1, startColumn+1,endColumn-1);     }      }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Spiral {   /**   * @param args   */  public static void main(String[] args) {   int arr[][]={{1,2,3,4},{10,11,12,5},{9,8,7,6}};   int T=0,B=2,L=0,R=3;   int dir=0;   while(T<=B && L<=R){    if(dir==0){     for(int i=L;i<=R;i++)      System.out.print(arr[T][i]);     T++;         System.out.println(\" \");    }    if(dir==1){     for(int i=T;i<=B;i++)      System.out.print(arr[i][R]);     R--;         System.out.println(\" \");    }    if(dir==2){     for(int i=R;i>=L;i--)      System.out.print(arr[B][i]);     B--;     dir++;     System.out.println(\" \");    }    if(dir==3){     for(int i=B;i>=T;i--)      System.out.print(arr[i][L]);     L++;          System.out.println(\" \");    }    dir=(dir+1)%4;   }      }    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This was my attempt in java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void spinalPrint(int[][] arr) { \n if (arr == null) { \n  return; \n } \n \n // l, t, r, and b stand for left, top, right, and bottom respectively \n for (int l = 0, t = 0, r = arr[0].length, b = arr.length; l < r && t < b;) { \n  for (int col = l; col < r; ++col) { \n   System.out.print(arr[t][col] + \" \"); \n  } \n  ++t; \n  --r; \n  for (int row = t; row < b; ++row) { \n   System.out.print(arr[row][r] + \" \"); \n  } \n  if (t < b) { \n   --b; \n   for (int col = r - 1; col >= l; --col) { \n    System.out.print(arr[b][col] + \" \"); \n   } \n  } \n  if (l < r) { \n   for (int row = b - 1; row >= t; --row) { \n    System.out.print(arr[row][l] + \" \"); \n   } \n   ++l; \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java version: Working for all kinds of test cases:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Isn't this similar to matrix rotation? Gayle covered it in one of her interview videos."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void Dspiral()         {             int[,] ipmatrix = new int[4, 4] { { 1, 5, 3, 2 }, { 2, 8, 4, 0 }, { 3, 7, 1, 9 }, { 5, 2, 8, 6 } };             int rowlength = ipmatrix.GetLength(0);             int columnlength = ipmatrix.GetLength(1);             int chk = 0;              for (int i = 0; i < rowlength; i++)             {                 for (int j = 0; j < columnlength; j++)                 {                     Console.Write(ipmatrix[i, j] + \" \");                 }                 Console.WriteLine();             }             Console.WriteLine(\"Spiralled matrix\");              for (int i = 0; i < rowlength; i++)             {                 if ((chk % 2) == 0)                 {                     for (int j = 0; j < columnlength; j++)                     {                         Console.Write(ipmatrix[i, j]);                     }                     chk++;                 }                 else                  {                     for (int j = columnlength - 1; j >= 0; j--)                     {                         Console.Write(ipmatrix[i, j]);                     }                     chk++;                 }                 Console.WriteLine();             }          }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5834736509386752","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"6","title":"You are standing at 0 0 and you have to get to i, j. Find the number of ways. Did that with recursion then with DP. Then he extended the question saying some edges are not traversible. Then edges have weights, find min weight path.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In a grid?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"recursive solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Grid can be viewed as strongly connected graph, so u can use djiktra Algorithm"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"dp solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use wave algorithm"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about doing an A* search? The nodes (grid points in this case) are expanded based on the function f(x) = g(x) + h(x), where g(x) = path code till now to arrive at node (a,b), where 0<=a<=b \n   \n    \n   -  \n     copyconstructor \n     on January 11, 2014 Edit | Flag  \n    \n    \n   Reply"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6256948974452736","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"0","title":"You are standing at 0 0 and you have to get to i, j. Find the number of ways.. Then he extended the question saying some edges are not traversible. Then edges have weights, find min weight path."}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5710908374384640","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"7","title":"Write a program to check if a binary tree is balanced","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"function balanced(Node *root){ \n if (root == NULL) \n  return 0; \n \n int left = balanced (root->left); \n int right = balanced (root->right); \n \n if (left == -1 || right == -1) // if any subtree is unbalanced \n  return -1; \n else if (abs (left-right) <= 1) // this subtree is balanced \n  return left+right+1; // return number of nodes \n else { \n  return -1; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Define balanced.  Red-black trees are considered balanced, for instance..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Balanced tree is  (1)an empty tree (2)left subtree is a balanced tree && right subtree is a balanced tree &&     abs(height difference of the two subtrees) <= 1 Following is C++ code??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int isBalanced(Node *root){ \n int hl,hr; \n if(root == NULL) \n  return 1; \n \n hl = height(root->left); \n hr = height(root->right); \n \n if(abs(hl-hr) <=1 && isBalanced(root>left) && isBalanced(root->right)) \n  return 1; \n \n return 0; \n} \n \nint height(Node* root){ \n if(root == NULL){ \n  return 0; \n } \n return 1 + max(height(root->left),height(root->right)); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A balanced tree is one in which height of left subtree - height of right subtree is atmost 1.  A naive approch would be: 1. start from root 2. while an unvisited node exists, check if the subtree rooted at that node is balanced or not 3. if all such subtrees are balanced then return true else return false"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4789906861719552","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"3","title":"What is the best way to implement Stack/queue... (EX will you use array/linkedlist etc ) explain pros and cons.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The best way to implement stack and queue is using linked list as it can grow dynamically. Also, since the operation are performed at the top of stack and Front and Rear of a Queue, they can be easily implemented in linked list using pointers to the head and tail.  Arrays are useful for quick random access. Since a stack or queue requires insertion/deletion operation at the extreme ends of list, linked list will give similar performance like arrays. Plus, it can grow dynamically as compared to Arrays."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Simple array implementation - operations will be O(1), but maximum size of the stack must be defined in advance and can not be changed. 2. Dynamic array implementation - Here you increment the array size as you push the element to the stack. It is too expensive to implement. For an example to push second element, you create a new array of size 2, copy old element from old array (of size 1) to new array and at index 1 (n-1 in general) you add second element. Similarly for adding third element you create a new array of size 3, copy old elements from old array and at index 2 add new element. After n push the number of copy operations will be ~O(n squared). The complexity can be bettered by repeated doubling i.e. creating a new array of double the size instead of increasing the size by one. 3. Linked list implementation -  This is the best approach as stack size here increases and decreases gracefully. Operations are O(1). Only that it uses extra spaces for references."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5131792298278912","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"15","title":"We have a fictitious multi-level marketing scheme where a member can recruit one or more other members. At the end of the month, member??s payout is calculated at 10% of his direct sales (items the members sells themselves) and 4% of sales generated by his recruits and their recruits. Write a function that calculates the monthly compensation for all members given the original member. You can assume a member can only be recruited by a single existing member.  Given the following interface, please implement the MemberPayoutUtil.calculatePayout function.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"This should work:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static double calculatePayout(Member member)  \n{ \n    double payout = member.getMonthlySales() * .1; \n    double recruitSales = 0; \n    Collection allRecruits = new Collection(); \n    while( !allRecruits.isEmpty() ) \n    { \n         Member recruit = allRecruits.First(); \n         recruitSales += recruit.getMonthlySales(); \n         allRecruits.remove(recruit); \n         allRecruits.AddRange(recruit.getRecruitedMembers()); \n    } \n    return payout + (recruitSales * .04); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Define a variable to keep track of what recruit level you are at. 0 for the member you are calculating the commission for.  public static int level = 0;  public static double calculatePayout(Member member) {      ArrayList members = (ArrayList) member.getRecruitedMembers();   level = level + 1;   if(members!=null){    for(int i=0; i< members.size();){     calculatePayout(members.get(i++));    }   }   level = level - 1;   if(level==0){    return payout + (member.getMonthlySales() * 0.1);   }else{    return payout + (member.getMonthlySales() * 0.04);   }     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static double calculatePayout(Member member) { \n     ArrayList members = (ArrayList) member.getRecruitedMembers(); \n  level = level + 1; \n  if(members!=null){ \n   for(int i=0; i< members.size();){ \n    calculatePayout(members.get(i++)); \n   } \n  } \n  level = level - 1; \n  if(level==0){ \n   return payout + (member.getMonthlySales() * 0.1); \n  }else{ \n   return payout + (member.getMonthlySales() * 0.04); \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"PS :  that is my code above. dint realize I was logged off when posting."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how about this recursive logic?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"One more recursive:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Trying to use recursive logic to get the total sales of one member's recruits"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public double calculatePayout(Member member)  {   double directPayout = member.getMonthlySales()*0.1;   List recruits = member.getRecruitedMembers();   Stack recruitStack = new Stack();   double payOut=0,total=0;   if(recruits.size()>0)   {    for(Member m : recruits)    {     recruitStack.push(m);     payOut = payOut + 0.04 * m.getMonthlySales();     while(!recruitStack.isEmpty())     {      Member m1 = recruitStack.pop();      payOut = payOut + 0.04 * m1.getMonthlySales();      if(!m1.getRecruitedMembers().isEmpty())      {       recruitStack.addAll(m1.getRecruitedMembers());      }     }     }   }    return payOut+directPayout;   }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6602280065302528","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"13","title":"reverse a single linked link - recursive and iterative.  tell the O(n) for each.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"// Recursive code \nNode Reverse(Node current, Node pre) \n{ \n Node next=current.next; \n current.next=pre; \n  \n if(next==null) \n             return current; \n \n return Reverse(next,current); \n} \n \nNode Reverse(Node head) \n{ \n        if(head==null) \n               return null; \n \n return Reverse(head,null); \n} \n \n//Iterative code \nNode ReverseIterative(Node head) \n{ \n if(head==null) \n  return null; \n   \n Node pre=null; \n Node current=head; \n  \n while(current!=null) \n { \n  Node next=current.next; \n  current.next=pre; \n   \n  pre=current; \n  current=next; \n } \n  \n return pre;  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"void RecursiveReverse(struct node** root ) { \n if (*root == NULL)  \n   return; \n  \n struct node* cur; \n struct node* rest; \n  \n cur = *root; \n  \n rest = cur->next; \n  \n if (rest == NULL)  \n   return; \n  \n RecursiveReverse(&rest); \n   \n // put the cur elem on the end of the list  \n cur->next->next = cur;  \n cur->next = NULL; \n   \n // fix the root poniter \n *root = rest;  \n} \n \n \nvoid Reverse(struct node** root) { \n struct node* result = NULL; \n struct node* cur = *root; \n  \n while (cur != NULL) { \n  struct node* next = cur->next;   \n   \n  cur->next = result; \n  result = cur; \n   \n  cur = next; \n } \n *root = result; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"// Recursion  Node Reverse(Node current, Node pre) {  Node next=current.next;  current.next=pre;    if(next==null)              return current;   return Reverse(next,current); }  // iterative  public void Reverse(Node head) { Node NextNodeOfCurrent, Prev,Current;  Current = head; Prev = null;  while(Current !=null) { NextNodeOfCurrent = Current.next;  Current.next=Prev; Prev = Current; Current=NextNode; } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"recursive:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Reverse the list and return the new head's pointer:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Recursive:  1) Divide the list in two parts - first node and rest of the linked list. 2) Call reverse for the rest of the linked list. 3) Link rest to first. 4) Fix head pointer  void recursiveReverselinkedlist(struct node** head) {     struct node* first_node;     struct node* rest_nodes;            /* empty list */     if (*head == NULL)        return;         first_node = *head;      rest_nodes  = first_node->next;       /* List has only one node */     if (rest_nodes == NULL)        return;         /* reverse the rest list and put the first element at the end */     recursiveReverse(&rest_nodes);    first_node->next->next  = first_node;     first_node->next  = NULL;              *head = rest_nodes;              }  Time Complexity: O(n) Space Complexity: O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node reverse(Node head){ \n Node temp = null; \n Node next = null; \n while(head != null){ \n  next = head.getNext(); \n  head.setNext(temp); \n  temp = head; \n  head = next; \n } \nreturn temp; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"in a recursive program time complexity=O(n) and space also O(n) , as for every node we creating a stack (implicit stack) , while in iterative time=O(n) and space =O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Iterative solution in java:- class node{  private int val;  node next;  public node(int val){   this.val=val;   next=null;  }  public int getval(){   return this.val;  }   } class linklist{  node start;  node last;  public linklist(){   start=null;   last=null;  }  public boolean isempty(){   return start==null;  }  public void insert(int val){    node newnode=new node(val);   if(start==null){    start=newnode;   last=newnode;       }   else{    last.next=newnode;    last=newnode;   }  }  public node listreverse(){   node middle=null;   node tail;   if(isempty()){    System.out.println(\"list empty\");    return this.start;   }   else{    while(start!=null){     tail=middle;     middle=start;     start=start.next;     middle.next=tail;    }    return middle;   }     }   } public class List_reverse {   public static void main(String[] args) {   // TODO Auto-generated method stub   linklist l=new linklist();   l.insert(10);   l.insert(20);   l.insert(30);   l.insert(40);   node a;   a=l.listreverse();   while(a!=null){    System.out.println(a.getval());    a=a.next;   }   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node * reverse(node *h) \n{ \n  node *prev=h,*future; \n  if(h->next==NULL) \n    return h; \n \n  h=h->next; \n  prev->next=NULL; \n  while(h!=NULL) \n    { \n      future=h->next; \n      h->next=prev; \n      prev=h; \n      h=future; \n    } \n  return prev; \n \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"recursive: time = O(n), space = O(n) iterative: time = O(n), space = O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class node{  int value;  node next=null;  node(int v){   this.value=v;  }  void appendToTail(int n){   node end=new node(n);   node current=this;   while(current.next!=null){    current=current.next;   }   current.next=end;  } } public class reverse {  public static void main(String[] args) {   // generate a single list   node head=new node(Integer.parseInt(args[0]));   for(int i=1;i   head.appendToTail(Integer.parseInt(args[i]));    head=reverseLinkedList(head);   System.out.println(\"The result is:\");   while(head!=null){    System.out.print(head.value);    head=head.next;   }  }  static node reverseLinkedList(node head){   node newHead=head;   if(head==null||head.next==null)    return head;   else{    newHead = reverseLinkedList(head.next);    head.next.next=head;    head.next=null;    return newHead;   }  } }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5146036959969280","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"Q: Pretend I'm a Dog breeder and you are an SDE. Design a solution for tracking my dog's pedigrees.  Followup - pedigree may also be hybrid. need a data structure which can lookup by pedigree to see if dog exists. also should be able to search by pedigree and some characters of dog.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Public class Dog \n{ \n   boolean gender; \n   List childrens = new ArrayList(); \n   Dog sprouce; \n   Pedigree pedigree = Pedigree.Unknown; \n   int age; \n   List characteristics = new ArrayList(); \n} \n \nPublic enum Breed \n{ \n   PAMERIAN(\"white\", \"short\", \"sweet\"), \n   ALSESIAN(\"dark\", \"huge\", \"dangerous\"),  \n   DOVERMAN(\"huge\", \"faithful\"),  \n   UNKNOWN(); \n    \n   public Breed(String... breedCharacterstics) \n   { \n      m_breedCharacterstics = Arrays.asList(breedCharacterstics); \n   } \n    \n   List m_breedCharacterstics = new ArrayList(); \n} \n \nPublic enum PedigreeType \n{ \n   PURE, MIXED, UNKNOWN; \n} \n \nPublic interface Pedigree \n{ \n    PedigreeType pedigreeType = PedigreeType.UNKNOWN; \n} \n \nPublic interface PurePedigree extends Pedigree \n{ \n   Breed breed = Breed.UNKNOWN; \n   pedigreeType = PedigreeType.PURE; \n} \n \nPublic interface MixedPedigree extends Pedigree \n{ \n   pedigreeType = PedigreeType.MIXED; \n   Pedigree motherPedigree; \n   Pedigree fatherPedigree; \n} \n \nPublic class DogsInBreederCamp \n{ \n   Lst admittedDogs = new ArrayList(); \n    \n   public List search(SearchCriteria criteria) \n   { \n   } \n} \n \nPublic class SearchCriteria \n{ \n  List characterstics; \n  Breed breed; \n  PedegreeType; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please ignore earlier one.. check this one"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can anyone please explain me the solution to this question. I am finding it difficult  thanks"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can anyone help with the design solution for this question"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4751976126480384","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"13","title":"Find the K closest points to the origin in 2D plane, given an array containing N points. You can assume K is much smaller than N and N is very large.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Using heap as implementation of priority queue to store the fist k points. So the complexity is O(n log k) with O(k) memory."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Another approach (instead of Minimum Heaps) is to use the median of medians select to find the k-th closest point to the origin and then iterate through the entire array and print k points which are closer/as close as the k-th closest point (to avoid missing some points in case there are several points as close as the k-th point, we might need two passes on the points array).  If we are allowed to change the original points array then this solution is O(n) run-time complexity and O(1) space complexity. If not then the space complexity is O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Another Approach,  NxN bit Matrix Representation of the points, Traverse the matrix from the given point.  O(n) Time Complexity and O(Max(x) *Max(y)/8)  => Bit matrix representation"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think building the heap directly from the array (without traversing the whole array) can save a lot of time. The complexity won't change (will continue O (n log n)), but in practice, only half of the array will be traversed (n/2 log n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hi, here my c++ solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. compute all the distance between points and origin, no need to calculate sort here. store them into an array. 2. create max heap with the first k elements in an array. 3. for every elements(a[k+1]??a[n]) in the remaining set of the distance array, compare heap root with a[i], it heap root > a[i], replace heap root with a[i]. 4. when loop finished, the heap are all k nearest neighbors."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First, find the distance of each point from the origin and store it in an array 'dist'. Time = O(n).  Secondly, find kth smallest element in 'dist' using select algorithm and store it a new variable say 'num'. Time= O(n).  Then traverse the array dist and print out all the corresponding points which have distance less than or equal to num. Time= O(n).  overall time complexity= O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First, find the distance of each point from the origin and store it in an array 'dist'. Time = O(n).  Secondly, find kth smallest element in 'dist' using select algorithm and store it a new variable say 'num'. Time= O(n).  Then traverse the array dist and print out all the corresponding points which have distance less than or equal to num. Time= O(n).  overall time complexity= O(n)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6264294643597312","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"15","title":"given a N x N matrix find the no. of times a word is present in that matrix. constraints you can move in 3 directions from one cell 1. forward  (x+1,y), 2. down (x, y+1) 3. diagonal(x+1,y+1) . Find all the occurance of all the word  solution approach --> BFS or DFS eg:- forward means right (x+1,y) down mean (x,y+1)  diagonal means (x+1,y+1)  it can be done with BFS. {search the no. of occurance of a given  word example \"sachin\" in the whole NxN matrix}  w | s | r  | t | g | g| a | a | c | h | i | n | k | c  | h | u | j | j  | o | h | i | n | y | q |  in this sachin can be found out 3 times.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Actually, there are 4 matches for \"sachin\" and not 3 as the question says."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"FindWordCount(char *word, char **matrix, int curRow, int curCol, int rows, int cols) \n{ \n    if (curRow >= rows) return 0; \n    if (curCol >= cols) return 0; \n    if (*word != matrix[curRow][curCol]) return 0; \n \n    // goto next letter in the word. \n    word++; \n \n    // no more letters left. we got a match. \n    if (*word == NULL)  \n return 1;  \n \n    int WordCount = 0; \n \n    // go right \n    WordCount += FindWordCount(word, matrix, curRow+1, curCol, rows, cols);     \n    // go down \n    WordCount += FindWordCount(word, matrix, curRow, curCol+1, rows, cols);     \n    // go diag \n    WordCount += FindWordCount(word, matrix, curRow+1, curCol+1, rows, cols);     \n \n    return WordCount; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I'm more familiar with C. Following is my C code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//There are 4 answers for the above question #include #include int dfs(char **mat, int R,int C, char *search,int r,int c, int index) {     //printf(\"%d %d %d\\n\",r,c,index);     int answer=0;     if(index==strlen(search)-1)         return 1;     if(r>=R || c>=C)         return 0;     if(mat[r+1][c]==search[index+1])         answer+=dfs(mat,R,C,search,r+1,c,index+1);     if(mat[r][c+1]==search[index+1])         answer+=dfs(mat,R,C,search,r,c+1,index+1);     if(mat[r+1][c+1]==search[index+1])         answer+=dfs(mat,R,C,search,r+1,c+1,index+1);     return answer; } int find_1stLetter(char **mat,int R,int C,char *search) {     int i,j, answer=0;     for(i=0;i    {         for(j=0;j        {             if(mat[i][j]==search[0])             {                 //printf(\"%c %c--\",mat[0][0],search[0]);                 //printf(\".%d %d.\\n\",i,j);                 answer+=dfs(mat,R,C,search,i,j,0);             }         }     }     return answer; }  int main() {     int i,j;     char *mat[]={\"wsrtgg\",\"aachin\",\"kchujj\",\"ohinyq\"};     char search[15]={'s','a','c','h','i','n','\\0'};     int answer=find_1stLetter(mat,4,6,search);     printf(\"\\nanswer=%d\\n\",answer);     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class Count{  static int num=0; } public class BFSsearch {  static String find=\"sachin\";  static char [][] matrix={    {'w','s','r','t','g','g'},    {'a','a','c','h','i','n'},    {'k','c','h','u','j','j'},    {'o','h','i','n','y','q'},  };  public static void main(String []args){   boolean flag=false;   int i=0,j = 0;   for(i=0;i   for(j=0;j    if(matrix[i][j]==find.charAt(0)){       flag=true;       break;     }    }    if(flag)     break;   }   findSubString(j,i,0);   System.out.println(Count.num);  }  static void findSubString(int curX,int curY,int position){   if(position==find.length()-1){    Count.num++;    return;   }   if(matrix.length+matrix[0].length-1-1-curX-curY>=find.length()-position-1){    if(curX+1<=matrix[0].length-1&&matrix[curY][curX+1]==find.charAt(position+1))     findSubString(curX+1,curY,position+1);    if(curY+1<=matrix.length-1&&matrix[curY+1][curX]==find.charAt(position+1))     findSubString(curX,curY+1,position+1);    if(curX+1<=matrix[0].length-1&&curY+1<=matrix.length-1&&matrix[curY+1][curX+1]==find.charAt(position+1)                                                                     )     findSubString(curX+1,curY+1,position+1);   }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this can be solved using dynamic programming easily in O(n*m) if the characters of the string to be found are different and in O(n*m*k) if the same character can appear more than once (k = strlen(string to be found)). Using dfs it is exponential"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class MatrixWord { \n  \n public static void main(String[] args) { \n  char[][] x = {{'w','s','r','t','g','g'},  \n           {'a','a','c','h','i','n'},  \n           {'k','c','h','u','j','j'}, \n           {'o','h','i','n','y','q'} \n     }; \n  String word = \"sachin\"; \n   \n  int found = 0; \n  int wi=0; \n   \n  System.out.println(x.length+\" \"+x[0].length); \n   \n  for(int i =0;i= limitfori || j >= limitforj) return 0; \n   \n  if(word.charAt(wi)==x[i][j]){ \n   if(wi==word.length()-1 ){ \n    System.out.println(\"Found=\"+found); \n    return 1; \n   } \n   else{ \n    found += checkword(word,wi+1,x, i+1, j, limitfori, limitforj); \n    found += checkword(word,wi+1,x, i, j+1, limitfori, limitforj); \n    found += checkword(word,wi+1,x, i+1, j+1, limitfori, limitforj); \n   } \n  } \n  return found; \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n#include \n \n \nusing namespace std; \n \n \nclass Occurence{ \n  \n vector< vector > matrix; \n \n public: \n Occurence(); \n int find_instances(string ); \n int bfs_find(string,int ,int ,int); \n \n}; \n \n \nOccurence::Occurence() \n:matrix{{'w','s','r','t','g','g'} ,{'a','a','c','h','i','n'} ,{'k','c','h','u','j','j'} , {'o','h','i','n','y','q'}}{} \n \n \nint Occurence::find_instances(string name) \n{ \n int c = 0; \n for(int i = 0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n#include \n \nusing namespace std; \n \nclass Occurence{ \n  \n vector< vector > matrix; \n \n public: \n Occurence(); \n int find_instances(string ); \n int bfs_find(string,int ,int ,int); \n \n}; \n \nOccurence::Occurence():matrix{{'w','s','r','t','g','g'} , \n                              {'a','a','c','h','i','n'} , \n                              {'k','c','h','u','j','j'} ,  \n                              {'o','h','i','n','y','q'}}{} \n \nint Occurence::find_instances(string name) \n{ \n int c = 0; \n for(int i = 0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I tried to solve the problem by a DFS.  public class findWord {   static int n=4;  static int m=6;  static String[] matrix=new String[n];  static String word;  static int len;  static int ans=0;  static Step[] sa=new Step[100];  static Step step;    static void init(){   matrix[0]=new String(\"wsrtgg\");   matrix[1]=new String(\"aachin\");   matrix[2]=new String(\"kchujj\");   matrix[3]=new String(\"ohinyq\");   word=new String(\"sachin\");   len=word.length();   System.out.println(\"The matrix is: \");   for(int i=0;i  System.out.println(\"The word is: \"+word);  }    static void dfs(int u,int v,int k){   if(matrix[u].charAt(v)!=word.charAt(k)) return;   step.add(v, u);   if(k==len-1){    sa[ans]=new Step(step);ans++;    step.remove();    return;   }   if(u+1  if(v+1  if(u+1  step.remove();  }    public static void main(String args[]){   init();   for(int i=0;i   for(int j=0;j    step=new Step();     dfs(i,j,0);    }   System.out.println(\"The number of same words is: \"+ans);   for(int i=0;i } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"DP is best approach for this because there are many overlapping sub-problems.  Approach should be.  1) At each cell find the index of that character in the string to match.    a) If found, look in three direction from where you can come to this cell. i) one before cell, ii)  above cell , iii) diagonally before. Now if the index equals previous value +1 update the matrix with index otherwise zero.    b) If not found just move to next matrix.  Once whole of the matrix is filled, look for all the path which can be backtrack from the full length of the string."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5640130266136576","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"11","title":"Calculate number of DISTINCT palindromic substrings in a string with help of suffix array or a trie. Like if aba is string the their are 3 distinct palindromic subsrings:{a,aba,b}","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"you can do this using suffix Tree and Suffix arrays. O(nlgn) solution  1. For constant sized alphabet we can build suffix trees using Ukkonen's Algorithm in O(n). 2. Traverse the tree lexicographically and populate the suffix array.  3. Pass over suffix array once to get total number of palindromic substrings in the input string.  More Specifically:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"without help of suffix array or a trie, i can think of a solution with O(n*n),where n is string len.  1) for palindromic str len %2 == 1, we can iterate through each index i of str, and check how many substring is palindromic if str[i] is the centre of the substr. the check process is as follow: if str[i-1]==str[i+1],then str[i-1,i,i+1] is a palindromic substr, we can continue to check if str[i-2]==str[i+2], if it is not, quit this iterator. 2) for palindromic str len%2 == 0, the process is similar except that str[i-1]=str[i],then check how many substr is palindromic."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is reasonable approach without suffix array and trie though."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.HashSet; \nimport java.util.Set; \n \npublic class UniqueSubstringsInAStringThatArePalindromes { \n \n    public static void main( \n            String[] args) { \n        String str = args[0]; \n        Set set = new HashSet(); \n        for (int i = 0; i < str.length(); i++) \n            for (int j = i+1; j <= str.length(); j++) \n                if (isPalindrome(str.substring(i, j))) \n                    set.add(str.substring(i, j)); \n        System.out.println(set); \n    } \n \n    public static boolean isPalindrome( \n            String str) { \n        if (str.length() > 0) { \n            for (int i = 0, j = str.length() - 1; i <= j; i++, j--) { \n                if (str.charAt(i) == str.charAt(j)) \n                    continue; \n                else \n                    return false; \n            } \n            return true; \n        } else \n            return false; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. construct two suffix trees, one for original string and the other for reversed string. O(n) 2. for each letter in the string, get LCA of both trees. if string length is odd, get LCA(a[i], a' [n-i+1]), if even, LCA(a[i], a' [n-i+1]) and LCA(a[i+1], a' [n-i+1]).  O(n)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6114699053629440","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"5","title":"given a N x N matrix find the no. of times  a word is present in that matrix. constraints you can move in 3 directions from one cell 1. forward , 2. down 3. diagonal . Find all teh occurance of all the word","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"The question isn't exactly clear, what is forward, which diagonal and whether we need to find the number of occurrences of a given word(s) or the occurrences of all possible words.  Anyway, I'll assume the following: 1. We're counting the number of occurrences of a given word. 2. Forward means right. 3. Diagonally means right and down.  My approach is to use dynamic programming and basically count the number of occurrences of every suffix beginning from every array element. This solution (and there probably are better ones) has O(k*n^2) run-time and space complexity (k is the length of the input string)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I don't understand your restrictions on directions.   What's \"forward\"?  Do you mean you can go to the right column? And which \"diagonal\" are you talking about?  All four?   Anyways, I would imagine you could do a modified DFS."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if the word is given, a brute force solution is check each point(i,j) in the matrix, and if m[i][j]=word[0],then check three directions with length equals word.length(). this is a O(mnk) complexity, where m,n is matrix size, k is word size.  if the word finding process will execute multi times,then maybe generate all prefix of rows,cols,dialogues of the matrix, and use trie is a better idea."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5161466495762432","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"Given an array, divide it into two parts for monte carlo simulations, with 80% of them as training and the rest as testing.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In python  {{  from random import random, randint, sample  #Given an array, divide it into two parts for monte carlo simulations #with 80% of them as training and the rest as testing.   #without with repeated elements def monte_carlo_split_without(array):   train = sample(array,int(0.8*len(array)))   test = list(set(array)-set(train))   return train,test  #with with repeated elements def monte_carlo_split_with(array):   train = []   test = []   for ar in array:     if random() > 0.8:       test.append(ar)     else:       train.append(ar)   return train,test  #testing if __name__ == '__main__':   a = sample(range(1,1000),300)   b = [randint(1,1000) for i in range(0,300)]   train, test = monte_carlo_split_with(b)   print len(train)+len(test)   print float(len(train))/len(b)    train, test = monte_carlo_split_without(a)   print len(train)+len(test)   print float(len(train))/len(b) }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is there any other limitations?  In PHP:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4821862626361344","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"8","title":"You are given two arrays, how to you find the common elements in them?  My answer: Make a hashmap for one array with the entries as keys and their presence (0 or 1) as values. Then run through the elements of the other array to see which elements match.   Complexity: O(m+n) where m and n are the lengths of each array.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"This solution is O(n + m) complexity and O(n) memory. You get only one occurrence of distinguishable item in result collection. If you need to find all items - change answer HashSet to List.  Does anybody know the linear solution without additional memory (or O(log n) memory)?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"the problem is a little abstract, you should confirm with the inteviewer further,maybe he/she is waiting for you. :) 1. is the array sorted? then we can solve it in O(M+N) complexity and O(1) space. 2. is the array number in certain arrange? for example, between 1-100, then we can use counting sort, with O(M+N) complexity and O(1) space. 3. if we count the same common element only once or actually occurence. 4. if all of these are not guaranteed, then maybe hashmap is possibly the best one."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution seems reasonable and I don't know if you can do any better other than using a HashSet instead of HashMap. It gets slightly more complicated if there are duplicate elements and we want to count them too. I think it all depends on how they want to twist this question further."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.HashSet; public class Duplicatesin2Arrays {     public static void main(String[] args) {         int[] array1 ={1,2,3,4,5};         int[] array2 ={3,4,5,6,7};         HashSet hs = new HashSet();         int i;         for(i=0;i        {             hs.add(array1[i]);         }         int j=0;         for(i=0;i        {             if(!hs.add(array2[i]))             {                j++;                System.out.println(array2[i]);             }                     }         System.out.println(\"The number of duplicates present is \"+j);     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"one more solution could be possible sort one array and binary search into it each element of other array. time : (n)log(m), no space"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4880578318958592","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"16","title":"Print an n-ary tree with level. For e.g.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Breadth first search works for n-ary trees too."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class PrintNaryTreeWithLevels { \n    private static Queue queue = new LinkedList(); \n \n    public static void bfs(Graph graph) { \n        Vertex vertex = graph.getVertexesAsArray()[0]; \n        vertex.setVisited(true); \n        int counter = 0; \n        System.out.println(vertex + \"level \" + counter); \n        counter++; \n        queue.add(vertex); \n        //null acts as a pointer/marker when new level should begin. \n        queue.add(null); \n        while (!queue.isEmpty()) { \n            Vertex currentVertex = queue.remove(); \n            if (currentVertex == null) { \n                counter++; \n                if (queue.isEmpty()) { \n                    break; \n                } \n                currentVertex = queue.remove(); \n                queue.add(null); \n            } \n            Vertex unvisitedVertex; \n            while ((unvisitedVertex = getUnvisitedVertex(currentVertex)) != null) { \n                unvisitedVertex.setVisited(true); \n                queue.add(unvisitedVertex); \n                System.out.println(unvisitedVertex + \"level \" + counter); \n            } \n        } \n \n    } \n \n    public static Vertex getUnvisitedVertex(Vertex vertex) { \n        for (Vertex temp : vertex.getDependsOn()) { \n            if (!temp.isVisited()) { \n                return temp; \n            } \n        } \n        return null; \n    } \n \n    public static void main(String[] args) { \n        Graph graph = new UnDirectedGraph(11); \n        graph.addEdge(\"V1\", \"V2\"); \n        graph.addEdge(\"V1\", \"V3\"); \n        graph.addEdge(\"V1\", \"V6\"); \n        graph.addEdge(\"V2\", \"V4\"); \n        graph.addEdge(\"V3\", \"V5\"); \n        graph.addEdge(\"V3\", \"V10\"); \n        graph.addEdge(\"V4\", \"V7\"); \n        graph.addEdge(\"V4\", \"V8\"); \n        graph.addEdge(\"V6\", \"V9\"); \n        graph.addEdge(\"V9\", \"V11\"); \n        graph.displayVertexList(); \n        graph.displayGraphDependency(); \n        bfs(graph); \n    } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{ \n// sudo code \nvoid printLevels(TreeNode root) \n{ \n Queue queue; \n    queue.push(root); \n    queue.push(\"LEVEL_DELIM\"); \n    int level = 0; \n    while (!queue.front != \"LEVEL_DELIM\") \n    { \n        print \"Level-\" + level; \n        while(queue.front != \"LEVEL_DELIM\") \n        { \n           TreeNode node = queue.front; \n           print node \n           TreeNode[] childNodes= getChildren(node); \n           queue.push_all(childNodes); \n           queue.pop(); \n        } \n        queue.pop(); \n        queue.push(\"LEVEL_DELIM\"); \n        level++; \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"var values = []; \nvar solution = function(num, node) { \n    values[num] = (values[num]||\"\") + node.value + \" \" \n    if(node.left) solution(num+1, node.left) \n    if(node.right) solution(num+1, node.right) \n} \n \nvar printValues = function() { \n    for(var i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You could store the level with each node in your traversal."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java implementation: 1. TreeLevelPrint class package com.sateesh;  import java.util.ArrayList; import java.util.List;  /**  * Created with IntelliJ IDEA.  * User: sateesh  * Date: 12/11/13  * Time: 11:45 AM  */ public class TreeLevelPrint {    public static void main(String[] args) {     printNodeElements(buildTree());   }    private static TreeNode buildTree() {     TreeNode node2 = new TreeNode(\"bar\");     TreeNode node4 = new TreeNode(\"foobar\");     node2.addChild(node4);     TreeNode node3 = new TreeNode(\"baz\");     TreeNode node5 = new TreeNode(\"barfoo\");     node3.addChild(node5);     TreeNode node1 = new TreeNode(\"foo\");     node1.addChild(node2);     node1.addChild(node3);     return node1;   }     private static void printNodeElements(TreeNode tree) {     if (tree == null)       System.out.println(\" tree is null \");      System.out.println(\"Level 0: \" + tree.getName());     printNodeElements(tree.getChildren(), 1);   }    private static void printNodeElements(List nodes, int level) {     if (nodes == null || nodes.size()==0)       return;     StringBuilder builder = new StringBuilder();     List nextLevelNodes = new ArrayList();     for(TreeNode node : nodes) {       builder.append(node.getName()).append(\" \");       if (node.getChildren()  != null)         nextLevelNodes.addAll(node.getChildren());     }     System.out.println(\"Level \" + level + \": \" + builder.toString());     printNodeElements(nextLevelNodes, level+1);   }  }    2. TreeNode class  package com.sateesh;  import java.util.ArrayList; import java.util.List;  /**  * Created with IntelliJ IDEA.  * User: sateesh  * Date: 12/11/13  * Time: 11:44 AM  */ public class TreeNode {   private String name;   private List children;    public TreeNode(String name) {     this.name = name;   }    public String getName() {     return name;   }    public void setName(String name) {     this.name = name;   }    public List getChildren() {     return children;   }    public void setChildren(List children) {     this.children = children;   }    public void addChild(TreeNode child) {     if (children == null) {       children = new ArrayList();     }     children.add(child);   } }   3. Output   Level 0: foo Level 1: bar baz  Level 2: foobar barfoo"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Uses one queue"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void printLevels(TreeNode root) \n { \n  // -- CODE-- \n \n   \n  int level = 0; \n \n  List currentLevelNodes = new LinkedList(); \n  List nextLevelNodes = new LinkedList(); \n \n  currentLevelNodes.add(root); \n \n  while(currentLevelNodes.size() > 0) { \n \n  System.out.print(\"Level \" + level + \" \" ); \n \n  for(TreeNode node : currentLevelNodes) { \n \n   System.out.print( node.name + \" \" ); \n    \n   nextLevelNodes.addAll(node.getChildren()); \n \n  } \n \n  System.out.println(); \n \n  currentLevelNodes.clear(); \n  currentLevelNodes.addAll(nextLevelNodes); \n  nextLevelNodes.clear(); \n  level++; \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n) queue implementation:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void printLevelOrder(TreeNode* root) \n{ \n if(!root) \n  return; \n int level = 0; \n int c1 = 0; \n int c2 = 0; \n TreeNode *node; \n List nodes = new List(); \n Queue *q = new Queue(); \n q.EnQueue(root); \n while(! q.isEmpty()) \n { \n  nodes.clear(); \n  System.out.println(\"level \"+level); \n  node = q.DeQueue(); \n  System.out.println(\"node->name\"); \n   \n  nodes.addAll(node->getChildren()); \n  for( TreeNode n: nodes) \n  { \n   q.EnQueue(n); \n  }    \n  c2 = q.length(); \n  if(--c1 == 0) \n  { \n   ++level; \n   c1 = c2; \n  }else \n   --c1; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void printLevels(TreeNode root){ \n  List la=new ArrayList(); \n  List lb=new ArrayList(); \n  int level=0; \n  la.add(root); \n  while(true){ \n   if(la.isEmpty()) break; \n   System.out.print(\"Level \"+level+\": \");level++; \n   for(TreeNode node:la){ \n    System.out.print(node.getName()+\"  \"); \n    lb.addAll(node.getChildren()); \n   } \n   System.out.println(); \n   la.clear();la.addAll(lb); \n   lb.clear(); \n  } \n }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4861659206123520","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"21","title":"/* Question 2 / 36 (FizzBuzz) Write a program which prints the numbers from 1 to N, each on a new line. But for multiples of three print ??Fizz??? instead of the number 3 and for the multiples of five print ??Buzz???.  For numbers which are multiples of both three and five print ??FizzBuzz???. Read in the input number from STDIN.  Sample Input #00:  15  Sample Output #00 :  1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz     Explanation:  Position 3,6,9,12 have the word \"Fizz\" because they are multiples of 3.  Positions 5 and 10 have the word \"Buzz\" because they are multiples of 5.    Position 15 has the word FizzBuzz because it is a multiple of both 3 and 5.       */   import java.io.*; class Solution {     public static void main(String args[] ) throws Exception {         BufferedReader br=new BufferedReader(new InputStreamReader(System.in));         System.out.println(\"Enter the value of N\");         int N=Integer.parseInt(br.readLine());         Solution objSolution=new Solution();         objSolution.fizzBuzz(N);     }     public static void fizzBuzz(int N) throws IOException     {                for(int i=0;i<=N;i++)         {             if((i%5==0)&&(i%3==0))             {                 System.out.println(\"fizzBuzz\");             }             else             {                 if((i%3)==0)                 {                      System.out.println(\"Fizz\");                 }                 if((i%5)==0)                 {                     System.out.println(\"Buzz\");                    }                 if((i%3!=0)&&(i%5!=0))                    {                        System.out.println(i);                    }                              }         }                                } }    ---------------------------------------- What is the complexity of this algorithm ? Is there any solution with better efficiency ?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static IEnumerable FizzBuzzCovertor(int inputNo) \n        { \n            var result = new List(); \n            for (int i = 1; i < inputNo + 1; i++) \n            { \n \n                if (i % 3 == 0 && i % 5 == 0) \n                { \n                    result.Add(\"FizzBuzz\"); \n                    yield return result; \n                } \n                else \n                { \n                    if (i % 3 == 0) \n                    { \n                        result.Add(\"Fizz\"); \n                        i++; \n                        yield return result; \n                    } \n                    if (i % 5 == 0) \n                    { \n                        result.Add(\"Buzz\"); \n                        i++; \n                        yield return result; \n                    } \n                } \n                result.Add(i); \n \n            } \n            yield return result; \n        } \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Scanner; \n \npublic class NumSequenceTest { \n \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n  // TODO Auto-generated method stub \n  Scanner in = new Scanner(System.in); \n   \n  int number = in.nextInt(); \n   \n   \n  for(int i = 1; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#!/usr/local/bin/python \nimport fileinput \n \nfor line in fileinput.input(): \n    num = int(line) \n    if num%3 == 0: \n        print \"fizz\", \n    if num%5 == 0: \n        print \"buzz\", \n    if num%3 != 0 and num%5 != 0: \n        print num, \n    print"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Complexity: One for loop means O(n) time complexity and no array needed means O(1) space complexity. But, Warning: Try initiate a class where you only need static methods can give a very bad impression on your java proficiency."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Personally I would avoid any solution using a mod operation (2 in the case). Also, when analyzing N one should try to use and relevant info from the previous iterations. Instead of using mod I would have 2 counters:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for (int i=1; i<=N; i++) \n    { \n        if (i % 15 == 0) \n        { \n            printf(\"FizzBuzz\\n\"); \n        } \n        else if (i % 3 == 0) \n        { \n            printf(\"Fizz\\n\"); \n        } \n        else if (i % 5 == 0) \n        { \n            printf(\"Buzz\\n\"); \n        } \n        else \n        { \n            printf(\"%d\\n\", i); \n        } \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static void method1() \n        { \n            Console.Write(\"Enter the no. : \"); \n            Int16 num = Convert.ToInt16(Console.ReadLine()); \n            if (num >= 3) \n            { \n                for (Int16 i = 1; i < num + 1; i++) \n                { \n                    if (i % 3 == 0 && i % 5 == 0) Console.WriteLine(\"FizzBuzz\"); \n                    else if (i % 3 == 0) Console.WriteLine(\"Fizz\"); \n                    else if (i % 5 == 0) Console.WriteLine(\"Buzz\"); \n                    else Console.WriteLine(i); \n                } \n            } \n            else Console.WriteLine(\"enter a valid no..\");"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \nusing namespace std; \n \n \nint main() \n{ \n int number = 25; \n int index = 0; \n bool enter = false; \n \n do \n { \n  if (index % 3 == 0 && index>0) \n  { \n   cout << \"Fizz\"; \n   enter = true; \n  } \n  if (index % 5 == 0 && index>0) \n  { \n   cout << \"Buzz\"; \n   enter = true; \n  } \n  if (!enter) \n  { \n   cout << index; \n  } \n  cout << \"\\n\"; \n  enter = false; \n } while (++index <= number); \n \n system(\"pause\"); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include void main() {     int a,n;     clrscr(); printf(\"enter n\"); scanf(\"%d\",&n); for(a{     for(a    {         if(a*3=0&&a*5=0)         printf(\"FIZZBUZZ\");         else         printf(\"a\");     }     printf(\"BUZz\"); } printf(\"FUZZ\"); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for (int i = 1; i <= n; i++)             {                 bool flag = false;                 if (i % 3 == 0)                 {                     Console.Write(\"Fizz\");                     flag = true;                 }                 if (i % 5 == 0)                 {                     Console.Write(\"Buzz\");                     flag = true;                 }                 else if(!flag)                 {                     Console.Write(i);                 }                 Console.WriteLine();             }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for (int i = 1; i <= n; i++)             {                 bool flag = false;                 if (i % 3 == 0)                 {                     Console.Write(\"Fizz\");                     flag = true;                 }                 if (i % 5 == 0)                 {                     Console.Write(\"Buzz\");                     flag = true;                 }                 else if(!flag)                 {                     Console.Write(i);                 }                 Console.WriteLine();             }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//javascript \n \nfunction print(x) { \n    document.body.innerHTML += \""},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simple Solution: public  void printNumbers(int num){    for (int i =1;i<=num;i++){    int flag = 0;    if ( i % 3 == 0 ){     System.out.print(\"Fizz\");      flag = 1;    }     if (i % 5 == 0){     System.out.print(\"Buzz\");     flag =1;    }    if (flag == 0){     System.out.print(i);    }    System.out.print(\"\\n\");     }  }//End printNumbers"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{{ import java.util.HashMap; import java.util.Map; import java.util.Map.Entry;  public class FizzBuzz {   /**   * @param args   */  void print(Map m, int n){   StringBuilder b = new StringBuilder();   boolean flag ;   for(int i=1;i<=n;i++){    flag = false;    for(Entry s : m.entrySet()){     if(i%s.getKey()==0){      b.append(s.getValue());      flag = true;     }    }    if(!flag)     b.append(i);    b.append(\" \");   }      System.out.println(b);  }  public static void main(String[] args) {   Map m = new HashMap();   m.put(3, \"Fizz\");   m.put(5, \"Buzz\");   m.put(7, \"kabootar\");   new FizzBuzz().print(m,105);   }  }  }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.HashMap; \nimport java.util.Map; \nimport java.util.Map.Entry; \n \npublic class FizzBuzz { \n \n /** \n  * @param args \n  */ \n void print(Map m, int n){ \n  StringBuilder b = new StringBuilder(); \n  boolean flag ; \n  for(int i=1;i<=n;i++){ \n   flag = false; \n   for(Entry s : m.entrySet()){ \n    if(i%s.getKey()==0){ \n     b.append(s.getValue()); \n     flag = true; \n    } \n   } \n   if(!flag) \n    b.append(i); \n   b.append(\" \"); \n  } \n   \n  System.out.println(b); \n } \n public static void main(String[] args) { \n  Map m = new HashMap(); \n  m.put(3, \"Fizz\"); \n  m.put(5, \"Buzz\"); \n  m.put(7, \"kabootar\"); \n  new FizzBuzz().print(m,105); \n \n } \n \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5728785773101056","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"22","title":"Given a binary tree. Modify it in such a way that after modification you can have a preorder traversal of it using only right pointers. During modification you can use right as well as left pointers. Write complete code and dry run it for some test cases","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"reverse preorder.. right left root  prev=NULL   everytime acces the node set its right to prev  and prev=current  in the end we will have a sort of linked list whose 1 st element is root then left child then right,.,,  code is simple..  any thoughts???"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static Node transform(Node root) { \n  Node right = root.right; \n  Node rightMost = root; \n \n  if (root.left != null) { \n   rightMost = transform(root.left); \n   root.right = root.left; \n   root.left = null; \n  } \n \n  if (right == null) { \n   return rightMost; \n  } \n \n  rightMost.right = right; \n  rightMost = transform(right); \n  return rightMost; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here my iterative solution in C++:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"simplified version in C++:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's another recursive implementation in Java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi, i had a small bug in my code, all left pointers should be set to NULL...to make sure the tree is deleted correctly when calling the destructor of the tree..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void PreorderTraverse(queue& myQueue, Node* head) {  if (NULL == head)  {   return;  }   myQueue.push(head);  PreorderTraverse(myQueue, head->left);  PreorderTraverse(myQueue, head->right); }  void Transform(Node*& head) {  if (NULL == head)  {   return;  }  std::queue myQueue;  PreorderTraverse(myQueue, head);   Node* pre = myQueue.front();  myQueue.pop();   head = pre;   while (!myQueue.empty())  {   Node* cur = myQueue.front();   myQueue.pop();    pre->right = cur;   pre->left = NULL;   pre = cur;  }  pre->right = NULL; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node *modifyPreorder(node *root) { \n  node *temp = root, *ret = root; \n  if(root->left) { \n    temp = modifyPreorder(root->left); \n  } \n  if(root->right) { \n    ret = modifyPreorder(root->right); \n    temp->right = root->right; \n  } else { \n    ret = temp; \n  } \n  if(root->left) { \n    root->right = root->left; \n  } \n  return ret; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Recursive call to transform everything to a ??Right??? node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public: \n void flatten(Node *root) { \n  flatten(root, nullptr); \n }; \nprivate: \n void flatten(Node *root, Node *tail) { \n  if (root == nullptr) \n   return tail; \n  root->right = flatten(root->left, flatten(root->right, tail)); \n  root->left = nullptr; \n  return root; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void modify_subtree (tree *root, tree **new_ptr_addr) \n{ \n        tree *right = root->r_child; \n        root->r_child = root->l_child; \n        *new_ptr_addr = right; \n} \n \ntree **convert_to_preorder(tree *root) \n{ \n        if (root) \n        { \n                tree **left = convert_to_preorder(root->l_child); \n                tree **right = convert_to_preorder(root->r_child); \n \n                if (!left && !right) \n                { \n                        return &(root->r_child); \n                } \n \n                if (left) \n                { \n                        modify_subtree (root, left); \n                } \n \n                if (right) \n                { \n                        return right; \n                } \n \n                else \n                { \n                        return &(root->r_child); \n                } \n        } \n        return NULL; \n} \n \nidea is like: \nfor leaf node, address of right child is returned \nfor non-leaf node, if left subtree exist then it has returned a address that address should not point to right of this node & node's right should point to node's left. \nif for non-leaf node, left subtree doesnot exist, do nothing/ \nfor non-leaf node, if right subtree exist then this right subtree must have returned a address that address should be returned  \nfor non-leaf node, if right subtree does not exist, then address of right child should be returned"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can anyone verify this for me"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My function logic below might seem a little complicated at first but upon going through some test cases, you should be able to get it.  eg-   initial tree:             1           /  \\         2    6        /        \\      3          7     /  \\   4    5  final tree:   1    \\      2        \\          3            \\              4                \\                 5                   \\                     6                       \\                        7"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6229237509914624","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"24","title":"Given N numbers , [N<=10^5] we need to count the total pairs of numbers which have a difference of K. [K>0 and K<10^9]. The solution should have as low of a computational time complexity as possible.  Input Format:  1st line contains N & K (integers). 2nd line contains N numbers of the set. All the N numbers are assured to be distinct.   Output Format:  One integer saying the no of pairs of numbers that have a diff K.  Sample Input #00: 5 2 1 5 3 4 2  Sample Output #00: 3  Explanation: The possible pairs are (5,3), (4,2) and (3,1).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"O(n) time and O(n) space solution: 1. Keep a hashtable(HashSet would suffice) to keep the elements already seen while passing through array once.  2. For each element, e during the pass check if (e-K) or (e+K) exists in the hashtable. If exists then increment a count.  3. Add the scanned element in the hashtable."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"If we don't have enough space  1. sort given array in an ascending order 2. initialize start = end = 0 and compute diff = a[end] - a[start] 3. if diff == K, count++; end++;     else if diff < K, end++;     else if diff > K, start++; 4. termination condition: if end == N,"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is there any efficient solution than n-sqaure  ??? ?? I've this code here which works for me :  import java.io.*; import java.lang.*; import java.util.ArrayList;  class Solution {     public static void main(String args[] ) throws Exception {         /* Enter your code here. Read input from STDIN. Print output to STDOUT */          Solution objSolution=new Solution();          int N,K;          BufferedReader br=new BufferedReader(new InputStreamReader(System.in));          System.out.println(\"Enter the value of n -number of inputs\");          N=Integer.parseInt(br.readLine());          int arrayOfNumbers[]=new int[N];          System.out.println(\"Enter the value of k- the difference\");          K=Integer.parseInt(br.readLine());                    objSolution.inputNumbers(arrayOfNumbers);          System.out.println(\"The size of array is \"+N);          for(int i=0;i         {             System.out.println(arrayOfNumbers[i]);          }            objSolution.calculateDifference(arrayOfNumbers,N,K);               }          public static void inputNumbers(int arrayOfNumbers[])throws IOException     {            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));         int lengthOfArray=arrayOfNumbers.length;   System.out.println(\"The length of the array is \"+lengthOfArray);         for(int i=0;i        {             System.out.println(\"Enter another integers for the list\");             arrayOfNumbers[i]=Integer.parseInt(br.readLine());         }     }          public static void calculateDifference(int arrayOfNumbers[],int N,int K) throws IOException     {         int count=0;          for(int i=0;i        {             for(int j=i+1;j                if((arrayOfNumbers[i]-arrayOfNumbers[j]==K)||(arrayOfNumbers[j]-arrayOfNumbers[i]==K))             {                 count++;             }         }         System.out.println(\"The number of such pairs found is \"+count);     }           }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use hashtable!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"first step:sort the array second step:start=0;end=1;  while( end  {   if (a[end]-a[start] == diff)   {    num++;    printf(\"%lld  %lld\\t\",a[start],a[end]);    start++;   }   else if (a[end]-a[start] > diff)    start++;   else     end++;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about using this (Space Complexity is O(size of input)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for(int i = 0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n) complexity with O(n) additional memory"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int FindedgeCount( int *A, int k) { While (start < end ) { if ( A[end] - A[start] == k) { count++; end -- ; start =0; } else if (A[end] - A[start] > k) { start++; } } return count; }  The space is O(n) time is O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int FindedgeCount( int *A, int k)  {  int start = 0; end = sizeof(A)/sizeof(int);  While (start < end ) {  if ( A[end] - A[start] == k) { count++; end -- ; start =0; }  else if (A[end] - A[start] > k) { start++; }  }  return count;  }   The space is O(n) time is O(n - k)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Radix sort O(n) and then with two pointers with a single pass O(n) will do it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sort by ascending. Then,"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int main() \n{ \n int i[10] = {1, 5, 3, 4, 2, 6, 9, 8, 7, 0}; \n int k = 2; \n int m; \n \n mergesort_s(i, 10); \n \n int *s, *f; \n s=f=i; \n \n while( *s < (*f + k ) ) \n { \n  s++; \n } \n \n int count = 0; \n \n while(s < (i + 10)) \n { \n  if((*s - *f) == k) \n  { \n   count++; \n  } \n  f++; \n  while( *s < (*f + k ) ) \n  { \n   s++; \n  } \n } \n \n printf(\"%d\\n\", count); \n \n return 0; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5148778843602944","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"13","title":"Find cousins of a given node in a Binary tree and  BST.  My Approach:","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Will u mind posting any example??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ex:    a   / \\        b   c       / \\   / \\             d e f g   Then node(d) if input, output should be f and g. since parent of node(d) is sibling for node(c) whose children are f and g."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can do this in O(n) time (technically O(log n + n) time which reduces to O(n). You first check which level of the tree the node is. Store that in a temporary variable.  Then , you do a BST iteration keeping a \"count\" variable that will be 0 after you have a whole tree level in your queue. You decrement the variable \"level\" at that ime.  At the begining of the iteration, you check to see if level = 0. If so, you have reached the same level where the node was and you can empty the queue to the list that will be returned as the solution. You just need to make sure you aren't pushing the target node or it's brother to the list (by checking if the parent of that node is the same as the desired node)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Forgot to add my name on the answer above <,<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Guys ,everyone is using queue..No need to use it...just do a preorder traversal and get the level of the node..that is when we are at 1 level we will check whether 2nd level has req. node. and if yes then we check is the req. is left child of current or right and save the opposite child..land then leavinf these two child print the level... say if root is not the req. child. int preorder(int child,int *brother,struct node *root,int level) { if(root) { if(root->left) { if(root->left->data)=child { if(root->right ) root->right=root->right->data; } return level+1; }  same for right    }   //code to print nodes at k level if value of node=child or value of node is brother then skip it else  print   } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Find grandparent node and get grandparent's children; 2. Remove parent node from grandparent's children; 3. Traverse grandparent's children list and add all children (the cousins we want) of each parent."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void findCousin(TreeNode *node) \n{ \n int c1 = 0; \n int c2 = 0; \n boolean flag = False; \n TreeNode *tmp; \n Queue *q = new Queue(); \n q.EnQueue(node); \n while(!q.isEmpty() && Flag==False) \n { \n  tmp = q.DeQueue(); \n  if(tmp->left->data == node->data || tmp->right->data == node-->data) \n   flag = True; \n  else \n  { \n   q.EnQueue(tmp->left); \n   q.EnQueue(tmp->right); \n  } \n  c2 = q.size(); \n  if(--c1 == 0) \n   c1 = c2; \n  else \n   -- c1; \n } \n while(!q.isEmpty()) \n { \n  tmp = q.DeQueue(); \n  if(c1 > 0) \n   -- c1; \n   q.EnQueue(tmp->left); \n   q.EnQueue(tmp->right); \n  else \n   System.out.print(tmp->data); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My attempt: using modified BFS and linkedList like a queue.  keep tracking the level number. always return all nodes in certain level(excluding the target node) if target node is found.  public List findCousins(Node root,Node src){         if(root==null) return null;         List q = new LinkedList();         q.add(root);         int curLevl=0,nodesNoOnCurLevel=1,nodesNoOnNextLevel=0;         boolean isFound=false;         List cousinsQueue = new LinkedList();         while(q.size()!=0){             Node curNode = q.remove(0);// acts like dequeue             nodesNoOnCurLevel--;        // decrement number of nodes on current level             if(curNode==src){                 isFound=true;             }             else                 cousinsQueue.add(curNode);             if(curNode.left!=null){                 q.add(curNode.left);                 nodesNoOnNextLevel++;      // increment number of nodes on next level             }              if(curNode.right!=null){                 q.add(curNode.right);                 nodesNoOnNextLevel++; // increment number of nodes on next level             }             if(nodesNoOnCurLevel==0){                 if(isFound==true)                     return cousinsQueue;                 else{                     nodesNoOnCurLevel=nodesNoOnNextLevel;                     nodesNoOnNextLevel=0;                     curLevl++;                 }             }                      }         return null;              }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think a more simple solution is just to go for a DFS and keep a reference on 2 last level ancestors to retrieve cousins as soon as we reach the target node :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be answered by a very simple modification to BFS  Create a Q struct as"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5931075461185536","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"34","title":"Given a list of ranges as input ((1,2),(3,4),(3,6),(8,10)),the output would be those ranges that don't overlap.For example, the output could be merging the ranges 1) (1,2),(3,4)  2) (1,2) (3,6) etc  The output cannot contain (3,4),(3,6) as 3 is common to both","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"It is 1d interval search problem. Algorithm: Create BST where each node stores an interval (lo,hi). Use left endpoint as BST key. (here lo is BST key) Store max endpoint in subtree rooted at node. (consider hi of all nodes) Now: To search for any one interval that intersects query interval (lo,hi): If interval in node intersects query interval, return it. Else if left subtree is null, go right. Else if max endpoint in left subtree is less than lo, go right. Else go left."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sort the ranges and remove one of the ranges that are overlapping. Time complexity O(nlogn), written in C++.  Output:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Sort pairs by lower range (nlogn) 2) Go through list of pairs checking overlap (merge node) and duplicate (remove node)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here my version:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Brut force:  the function:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"DO we have to ouput always in pairs? For example can answer in example be  {(1,2) (3,6) 8,10)}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have a hard time understanding this question. Are we supposed to print all pairs of ranges that don't overlap? Can someone elaborate and provide more examples? Thanks."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@Sunny:  yes, check if a number within the range overlaps with any other range.  examples:  input: {{1,2}, {3,4}, {3,6}, {8,10}} output: {{1,2}, {8,10}}  explanation: {3,4}, {3,6} ...overlap and will be removed  input: {{1,2}, {3,5}, {4,6}, {8,10}} output: {{1,2}, {8,10}} explanation: {3,5}, {4,6} ...overlap and will be removed  input: {{1,6}, {3,4}, {5,7}, {8,10}} output: {{8,10}} explanation: {1,6}, {3,4}, {5,7} ...overlap and will be removed"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void doItNew(int[][] x) { \n        int[] checker = new int[x.length]; \n        for (int i = 0; i < x.length - 1; i++) { \n            for (int j = i + 1; j < x.length; j++) { \n                if (checkOverLap(x[i], x[j])) { \n                    checker[i] = -1; \n                    checker[j] = -1; \n                } \n            } \n        } \n        for (int i = 0; i < x.length ; i++) { \n            if (checker[i] != -1) { \n                for (int a1 : x[i]) { \n                    System.out.print(a1 + \"\\t\"); \n                } \n            } \n        } \n    } \n \n    public boolean checkOverLap(int[] a, int[] b) { \n        return a[0] - b[1] <= 0 && a[1] - b[0] >= 0; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Its a  very easy question of \"Activity selection problem\", an application of greedy algorithm."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If we assume that the input array comes already sorted (in the problem statement it comes sorted), just traverse this array and eliminate  the overlapping pairs, then it has an O(n) for both time and space complexities."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Jumping directly to code without understanding the problem is just stupid. What to return if the array contains (1,2) (3,4) (1,2,3,4,5)?  (1,2) + (3,4) or (1,2,3,4,5)? Is it asking for the largest coverage?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Create 2 separate sets of tuples, in one set sort the intervals by the first number, in the second set sort the intervals by the second number.  For each tuple in the first set, use binary search to find all tuples in the second set for which the second number in the tuple from the second set is less than equal to the first number in the tuple from the first set.  Sorting takes O(nlogn) time. Forming the set of intervals for each of n tuple takes O(logn) time (binary search). Thus O(nlogn) time complexity and O(n) space complexity."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This problem is like interval scheduling problem in which we have to schedule jobs which are compatible.  We are given here (start,finish) time pair of each job.  Two approach:  Greedy: 1) Sort them based on the range end of each (start,end) pair. 2) Now take first pair which end first and add it to solution. 3) Iterate on sorted job to find  jobs which are compatible with the result. This will be one scan to the input. Note: We are adding job greedily to the solution set.  DP: Sort the based on the end range. Create Array which account for last job compatible with jth jon. Let it be p(j). Now Use this recurrence solution. M[i] = max(1+p(i),M[i-1]).  M[n] will give you number of max set compatible. For printing solution you can iterate over M array one scan."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class MergingRang { \n public static void main(String[] args) { \n  List pointList = new ArrayList(); \n  Point point;   \n  point = new Point(3,4); \n  pointList.add(point); \n  point = new Point(1,2); \n  pointList.add(point); \n  point = new Point(3,6); \n  pointList.add(point); \n  point = new Point(8,10); \n  pointList.add(point); \n  Collections.sort(pointList); \n  for(int i=0;ii;j--){         \n    if((pointList.get(i).y>=pointList.get(j).x) || (pointList.get(i).y>=pointList.get(j).y)) \n     break; \n    else \n     System.out.println(\"(\"+pointList.get(i).x+\",\"+pointList.get(i).y+\")\"+ \n       \"(\"+pointList.get(j).x+\",\"+pointList.get(j).y+\")\"); \n   } \n  } \n   \n } \n \n} \nclass Point implements Comparable{ \n int x; \n int y; \n public Point(int x, int y) { \n  this.x = x; \n  this.y = y; \n } \n @Override \n public int compareTo(Point o) { \n  // TODO Auto-generated method stub \n  return x-o.x; \n } \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6047481959809024","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"19","title":"For a given string of some sentence, reverse words in that sentence. Ex: I am Don..return Don am I.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Reverse complete string and then reverse each words from starting. Eg: I am Don  Step 1: noD ma I Step 2: Don am I  Please suggest me better solution if exist."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"If additional buffer is allowed - stack can help."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A little python code the works. Complexity is O(n).  def f(x): return x+\" \" def f(x): return x+\" \"  def reverse(toReverse):     answer=toReverse.split()     answer.reverse()     answer=\"\".join(map(f,answer))     return answer  if __name__ == '__main__':     print (reverse(\"I am trying to learn python\"))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a straight forward Java Solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n#include \n \nusing namespace std; \n \nint main() \n{ \n \nstring inpStr,inpWrd; \nint age; \n \ncout << \"Enter the string :\"; \n \ngetline(cin,inpStr); \n \ncout<<\"Input String is : \"<<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Input: I am Don Output: Don am I  Algorithm:  - Start on the input string from the reverse side.  - If encounter any character other than space, put that in a stack.  - If encountered a space, take all the characters out of the stack one by one and add them to the output string, append the space, and continue.  - As you are traversing in reverse, you'll encounter the word letters in reverse. Pushing them in stack and popping them out will switch them to make a forward word."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Recursively"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java code using a Stack:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Recursively (assuming I can use some helper methods like indexOf and that space is the only tokenizer and there aren't contiguous space)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def func(string):  s=string.split(\" \")  s=\" \".join(s[::-1])  return s"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why don't you just store the splitted words into a simple array and then iterate through this array until its middle part swapping 'i' element by 'i + length - i' ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here it is"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"A no additional buffer solution:  Use two parsers, p1, p2;"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5096672887570432","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"14","title":"For given set of natural number, suppose we can negate some number. Find what all number we should negate such that sum of all number (after negating some number) is zero. For ex: {1,2,3} return {-1, -2}, {1,2,3,4} return {-1,-4} or {-2,-3}. 1st check if such number in given set exist or not. If not return empty array else return numbers.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"It seems to be subset-sum problem.  Find a subset with sum of elements half of total sum of array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"If you sum all the numbers in the set, then you just have to find the numbers which total half of that sum (i.e if you have 1,2,3,4 sum is 10. 2 + 3 total 5, 1 + 4 totals 5).  Say you get that the sum of your set divided by two is S. At this point, you just gotta use the 0/1 knapsack algorithm (can't repeat elements) to find a combination of numbers that sums up to that S. This would be O(nS) complexity which is exponential (since usually any N numbers will sum up higher than 2N)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Should you find only one set of numbers or sets of all numbers? i mean for {1,2,3} the answer would be {-1-2},{-3}. Assuming we need to return all sets of negative numbers,  1. find permutations of the array. 2. for each element in permutation; negate 1st element and take the sum. if sum is 0, return the 1st element, else negate 1st and 2nd elements... and so on...  java POC:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Complexity is exponential but I dont think there is a way to avoid it in this case. It boils down to subset problem which is an exponential problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We have to find all sublists of the the list whose sum is half the sum of the list. (I use List instead of Set as the elements may not be all distinct.) There 2^N such sublists and it is exponential in N. Here is a solution in Scala:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"first find the sum S of array, now find a list whose sum is S/2; that can be done is O(nlongn), by first sort the array ,1,2,... ,N now if we include N in our list,the remaining list should be, S/2-N, and so on recursively. so overall complexity is 0(nlogn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) { \n  int[] iarr = { 1, 4, 5, 8, 6}; \n  ArrayList  al = new ArrayList(); \n  for( Integer i  : iarr) \n   sum += i; \n  System.out.println(scan(sum/2, 0, 0, al, iarr)); \n } \n public static ArrayList  scan(int half, int sum, int i, ArrayList al, int arr[]){ \n      if (half == sum) \n        return al; \n      if (half < sum ) \n          return null; \n      for ( int j = i; j < arr.length; j++ ){ \n          ArrayList altmp = new ArrayList(); \n          for( Integer in : al) \n              altmp.add(in); \n          altmp.add(arr[j]); \n          ArrayList t =  scan( half, sum + arr[j], j+1, altmp, arr); \n          if ( t != null) \n            return t; \n      } \n      return null; \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include int main() { int i,j,a[100],temp; static int n=0,sum=0,sum1=0,count=0,count1=0; printf(\"\\nEnter the number of terms:\"); scanf(\"%d\",&n); printf(\"\\nEnter the %d numbers:\",n); for(i=0;i{ scanf(\"%d\",&a[i]); } for(i=0;i{ sum=sum+a[i]; } printf(\"\\n%d\",sum); if(sum==0) { printf(\"\\nThe sum is zero already\"); } if(sum%2==0) { for(i=0;i{ for(j=i;j{ if(a[i]>a[j]) { temp=a[i]; a[i]=a[j]; a[j]=temp; } } } for(i=0;i<(n/2);i=i+2) count=count+(a[i]+a[n-i-1]); for(i=1;i<(n/2);i=i+2) count1=count1+(a[i]+a[n-(i+1)]); if(count==count1) { for(i=0;i<(n/2);i=i+2) { a[i]=-a[i]; a[n-i-1]=-a[n-i-1]; } printf(\"\\n\"); for(i=0;i{ printf(\" %d \",a[i]); } for(i=0;i{ sum1=sum1+a[i]; } printf(\"\\n%d\",sum1); printf(\"\\nThe numbers to be negated are: \"); printf(\"\\n{\"); for(i=0;i<(n/2);i=i+2) {printf(\"%d,\",a[i]); printf(\"%d,\",a[n-i-1]); } printf(\"}\"); }} else { printf(\"\\nThe is no such combination in the following set:\"); printf(\"\\n{\"); for(i=0;iprintf(\" %d,\",a[i]); printf(\"}\"); } return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think it is possible to use greedy aproach here"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static List findAllComb(int arr[],int index,int sum)  {   if(index==(arr.length-1))   {     if(sum+arr[index]==0)     {    System.out.println(\"me\");      return new ArrayList();     }     else if(sum-arr[index]==0)     {      List list=new ArrayList();      Integer negate=-1*arr[index];      list.add(negate.toString());      return list;     }     else      return null;           }   else   {    int negatedSum=sum-arr[index];    int normalSum=sum+arr[index];         List negatedSumList=findAllComb(arr,index+1,negatedSum);    List normalList=findAllComb(arr,index+1,normalSum);    if(sum==-5 && index==2)     System.out.println(\"a\");    if(negatedSumList !=null)    {     String negate=Integer.toString(-1*arr[index]);     List newNegaedList= new ArrayList();     if(negatedSumList.size()==0)      newNegaedList.add(negate);     else     {     for(String s: negatedSumList)     {            s=negate+\"|\"+s;      newNegaedList.add(s);           }     }     negatedSumList=newNegaedList;    }    if(negatedSumList!=null&& normalList!=null)    negatedSumList.addAll(normalList);    else if(normalList!=null)     return normalList;        return negatedSumList;       }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"javascript:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"javascript without sorting:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5205047260479488","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"9","title":"public static LinkedList reverse(LinkedList current)  {   LinkedList result=null;   if(current==null) return null;   if(current.next==null) return current;      //LinkedList current=head;   LinkedList prev=null;   LinkedList next=current.next;   while(current!=null)   {    next=current.next;    current.next=prev;    prev=current;    current=next;   }   result=prev;      return result;  }","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Find the issue with the above code and fix it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"pnode ReversLinklist(Linklist s) {  pnode p=s;  pnode q,r;  if(p==NULL) return NULL;  if(p->next==NULL ) return p;  q=p->next;  while (q!=NULL)  {   if(q->next!=NULL)     {   r=q->next;   q->next=p;   if (p==s)   {         p->next=NULL;   }     p=q;     q=r;     }  else    {    q->next=p;          return q;    }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I can't find any issue from original code if the linked list does not contains any loop."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Problems are : 1. As mentioned by Dinesh, 2. No iterator used to iterate through linkedlist"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the code is always loosing the head element in the iteration  Suppose we have following list   a -> b -> c -> d   So the reverse would be like this  d-> c-> b"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void reverse() \n        { \n            Node temp=head; \n            head=tail; // //swap head and tail \n            tail=temp; //tail points to head \n            //traverse the list swapping prev and next fields of each node \n            Node p=head; //create a node and point to head \n \n            while(p!=null) //while p does not equal null \n            { //swap prev and next of current node \n \n                temp=p.next; \n                p.next=p.prev; //point next pointer to previous \n                p.prev=temp;     //previous point to what next used to point to \n                p=p.next;//advance current node \n            } \n \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Code is wrong..  Suppose we have following list  a -> b -> c -> d  After first while loop it will be  b-> null -> c-> d  Third time loop will not execute.."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5729537878917120","download_status":"DOWNLOAD_DONE","votes":"3","answersCount":"21","title":"Given two unsorted integer arrays A & B of unequal length. Find an element from A(say 'X') and another element from B(say 'Y') such that |X-Y| is minimum.  Note: A & B can contain positive/negative numbers.  How can you find this without sorting both arrays? How can you find this by sorting both arrays?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"java solution by sorting"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"After both arrays are sorted, we can go through the same logic as the merge sort (the  actually sorted array output is not necessary). While we going though both arrays during the merge processes, if the previous pick and current pick are from different source array (A,B) we calculate & Keep track of the Min ABS(A-B) value (if the value from A and B are the same we can stop the program and and return \"0\"  ).  Once one of the array is done processing just make sure do the last check with the other array for the Min."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"assuming size of arrays are j, k and n = j + k  without sorting: compare all possible sets in O(n^2)  with sorting: combine both arrays into a combined array with extra data flag identifying with set it is from.  Now sort the combined array according to value.  Iterate over the combined array and compare  adjacent(opposite flagged) elements.  Note that if the elements are not adjacent and opposite then cannot be best pair(can prove if needed).  Find best pair in O(n log n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can we view this question as putting several points on a x-axis and finding the closest two points? Here's a thought, probably will have time tomorrow to try it out: 1. put A and B in HashSet setA and setB while keeping track of max and min value of all data.Check duplicate while adding data to maps. If there is overlap between A and B, simply return the overlapping element. ( |X-Y|==0 ) O(n) 2. boolean[] buffer = new boolean[max-min]; 3. mark all data from setA and setB in the boolean array. buffer[data-min] = true; O(n) 4. the above process automatically sorted all the data. now we just need to count the distance between every two adjacent elements which are from different HashSets in the buffer. keep track of the minimum count and the indexes correspond to the minimum count. O(n) 5. return the indexes + min.  Overall, it should be O(3n) time and O(2n) space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the arrays are sorted we can apply merging step of merge sort and if not sorted theb we can do it by comparing one element with every other.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using namespace std; \n \nint FindPairWithMinDiff(vector a, vectorb, pair &minDiffPair) \n{ \n if(a.size() < 1 || b.size() < 1) \n  return -1; \n \n int min = abs(a[0] - b[0]); \n int aPtr = 0, bPtr = 0, aIter = 0, bIter = 0; \n \n while(min > 0 && aIter < a.size() && bIter < b.size()) \n { \n  int curDiff = abs(a[aIter] - b[bIter]); \n  if(min > curDiff) \n  { \n   min = curDiff; \n   aPtr = aIter; \n   bPtr = bIter; \n        } \n \n        if(a[aIter] < b[bIter]) \n        { \n         ++aIter; \n        } \n        else \n        { \n         ++bIter; \n        } \n    } \n \n    while(min > 0 && aIter < a.size()) \n    { \n     int curDiff = abs(a[aIter] - b[bIter - 1]); \n     if(min > curDiff) \n     { \n      min = curDiff; \n      aPtr = aIter; \n      bPtr = bIter - 1; \n        } \n        ++aIter; \n    } \n \n    while(min > 0 && bIter < b.size()) \n    {   \n        int curDiff = abs(a[aIter - 1] - b[bIter]); \n     if(min > curDiff) \n     { \n      min = curDiff; \n      aPtr = aIter - 1; \n      bPtr = bIter; \n        } \n        ++bIter; \n    } \n    minDiffPair = make_pair(a[aPtr], b[bPtr]); \n     \n    return 0; \n} \n \nint main() \n{ \n   vector a = {0, 12, 44}; \n   vector b = {5, 10, 11, 12}; \n    \n   pair pr; \n    \n   if(0 == FindPairWithMinDiff(a, b, pr)) \n      cout << pr.first << \", \" << pr.second << endl; \n    \n   return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If both arrays are sorted, This can be done in O(log m log n). Here is how 1. Find middle element of both arrays say a=A[mid1] and b=B[mid2]. 2. If a==b return 0, we have found the min 3. If(a>b) min is Min(|a-b|, minimum in  A(0.. mid1) and B(mid2... end)) 4. if(a \n   \n    \n   -  \n     loveCoding \n     on December 05, 2013 Edit | Flag  \n    \n    \n   Reply"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Approach 1: w/o sorting it??ll be O(n^2) as we need to iterate the 2nd list for each element of 1st list Approach 2: sort the arrays with O(nlgn), n is the size of larger array. Then for each element in first array find the last element of a decreasing diff sequence in the 2nd array. The sequence starts from the next element of the previous sequence??s last element in the 2nd array. So, we are scanning both the array at most once and hence the complexity is O(m+n) = O(n). Total complexity: O(nlgn)+O(n) = O(nlgn)  O(nlgn) solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a simple python solution:  from numpy import * def axbkron(a, b):     x = array(zip(kron(a, ones(len(b))),kron(ones(len(a)), b)))     return max(abs((x[:, 0]-x[:,1])))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This O(nlogn) solution.  First sort both the arrays A and B. Now for each element in A search for the nearest element of A in B using binary search.  The complexity is O(nlogn+mlogm+nlogm) = O(nlogn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.merge Sort the arrays . 2.put the elements in a single array with an extra flag indicating which array 3.find the most adjacent numbers form the single array we have(assume like number line). 4.in case we hit an element with both flags enabled thts it, we can return (implies present in both arrays) 5.other wise maintain a variable tht has the min value we are looking for.  ::calulate the min value based on the flags (whether present in both arrays or array1 or array2)   -1 2 4 -3 -4 5  -4(0,1) -3(0,1) -1(1,0) 2(1,0) 4(1,0) 5(0,1)  //(0,1)====> (not present in first array, present in second array)  //only compare the adjacent values, only if its from different array take the diff and stor it"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For Sorted arrays:  |A[i+1] - B[j]| < |A[i] - B[j+1]| then increment i, otherwise increment j"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Create a BST using the Array A:  1. If it is sorted create the root node with n/2th element and create the tree recursively inserting not n/4th and 3n/4th node in the 2nd iteration etc. 2. If it is not sorted then just create a BST going from 1st to nth element.  Now keep a variable MIN, retX, retY. From Array B try to insert the element y, one by one. You will find a place (z) to insert the element. Find the m = min(z, parent(z)), and then update MIN, retX, retY.  Return the retX and retY."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  using namespace std;  int main (int argc, char * argv []) {  void closest (int a1[], int size1, int a2[], int size2);   int n, m;  cout<<\"Please enter the size of the first array:\"< cin>>n;  int * array1 = new int [n];  cout<<\"Please enter each element of the first array:\"< int i;  for (i = 0; i < n; ++i)  {   cin>>array1[i];  }  cout<<\"Please enter the size of the second array:\"< cin>>m;  int * array2 = new int [m];  cout<<\"Please enter each element of the second array:\"< for (i = 0; i < m; ++i)  {   cin>>array2[i];  }   closest (array1, n, array2, m);   return 0; }   void closest (int a1[], int size1, int a2[], int size2) {  int i;  int j;  int Min_Distance;  int a1_number;  int a2_number;   if (a1[0] > a2[0])  {   Min_Distance = a1[0] - a2[0];  }  else  {   Min_Distance = a2[0] - a1[0];  }   for (i = 0; i < size1; ++i)  {   for (j = 0; j < size2; ++j)   {    if (a1[i] < a2[j])    {     if (a2[j] - a1[i] < Min_Distance)     {      Min_Distance = a2[j] - a1[i];      a1_number = i;      a2_number = j;     }    }     else    {     if (a1[i] - a2[j] < Min_Distance)     {      Min_Distance = a1[i] - a2[j];      a1_number = i;      a2_number = j;     }    }   }  }   cout<<\"The Minimum Distance is:\"< cout<< cout<<\"The two index are:\"<<<\" \"<< }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"# include # include # include void bubble(int a,int n); int main() {  int a[80],b[80];  int sizea,sizeb;  int i,j,mindif,dif,indexa,indexb;     printf(\"Enter size of a:\");  scanf(\"%d\",&sizea);  printf(\"Enter %d integers:\",sizea);   for(i=0;i   scanf(\"%d\",&a[i]);  printf(\"Enter size of b:\");  scanf(\"%d\",&sizeb);  printf(\"Enter %d integers:\",sizeb);      for(i=0;i   scanf(\"%d\",&b[i]);  mindif=abs(a[0]-b[0]);  for(i=0;i  for(j=0;j  {               if(abs(a[i]-b[j])     {       mindif=abs(a[i]-b[j]);          indexa=i;indexb=j;      }   }      printf(\"The min difference of a and b is abs(a[%d]-b[%d])=%d\\n\",indexa,indexb,mindif);  return 0; }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5308479619203072","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"15","title":"How to represent a number in base -2? (negative -2 base) eg 6 can be 11010 i.e. 16 -8 +0 -2 +0 = 6.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Decimal can convert into base by divide and collecting the remainders,    For example:            Binary value of decimal 12               12 / 2 = 6 with remainder 0               6 / 2  = 3 with remainder 0               3/ 2  = 1 with remainder 1                1 / 2  = 0 with remainder 1   So the Binary value is 1100    Same formula can be applied to find Negative Base, but remember remainders have to be positive.   Like the sample found in wiki     Note, here  -5/-3 = 2 with remainder 1 ,    If a/b = c with remainder d then bc + d = a  , thus the c can be found like c = (a-d) / b    Let??s try to write Java method to calculate this."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"private static void convertBase(int decimalVal,int base){ \n  if(base > 0 && decimalVal < 0){ \n   System.out.println(\"not possible\"); \n   return; \n  }  \n        StringBuffer buffer = new StringBuffer(); \n        while (decimalVal != 0){ \n       \n          int result = decimalVal / base; \n          int remainder = decimalVal % base; \n          if(remainder < 0){ \n           result++; \n           remainder = decimalVal - base * result; \n          } \n          decimalVal = result; \n             buffer.insert(0, remainder); \n        } \n        System.out.println(buffer); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If we simulate 2-3 digits we can see the pattern of generated numbers. The code follows from observing how the range of positive/negative numbers changes. Time O( log n )."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"See Negative_base on wikipedia  Algorithm is same as positive-base conversion(e.g. base 2) but if you get remainder as -ve, you need to add the mod of base(e.g. | -2 | = 2) to remainder to get it to become non-negative and also add 1 to the remaining value after division by base."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public String convert(int number){   StringBuffer str = new StringBuffer();   while(number!=0){    int remainder = number/(-2);    int mod = number%(-2);    if(mod==-1){     remainder+=1;     mod=1;    }    str.insert(0, mod);    number=remainder;   }   return str.toString();  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Compilable and running code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int base_convert(int num, int base) \n{ \n    int rem =   0; \n    int idx = 0; \n    int baseX   =   0; \n \n    while( num ) \n    { \n        rem =   num%10; \n        baseX   +=   rem * pow(base,idx); \n        idx++; \n        num   /=  10; \n    } \n \n    return baseX; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Suppose you have a binary number 1101110.  If we consider this as base -2, the difference is that the odd digits now represent a negative value.  We simply need to convert the odd digits into base -2.  Examples:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"String neg2base(int x){ \n String ret = \"\"; \n int remains = 0; \n while(Math.abs(x) != 0){ \n  remains = x%2 == 0?0:1; \n  x -= remains; \n  x /= -2; \n  ret = remains + ret; \n } \n return remains + ret; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What a headache, but I managed it. It returns an integer where it's bits correspond to the base -2 encoding, it does it in O(log(n)) where n is the position of the highes bit:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"don't you just take the two's complement of the base2 representation? i.e. 00101 (6 in base 2) --> 11010 (6 in base -2)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6296068761321472","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"8","title":"Find the longest path in a binary tree  with one bend. One bend means like SAY I HAVE                 1            2         44        3  With one bend means all the nodes means if we start connecting nodes then connect as much as possible in a single line and u can take maximun one bend.Say left left left than right right right.That is maximum one turn..It is not same as diameter say ia have          1      /    2        \\          3 Diameter of above is 3 but if we take all the nodes then we will have 2 bends..   So we will two nodes to get nodes with one bend..hope m clear","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Approach:  max path with a bend  = max of { max path with a bend of right subtree, max path with a bend of left subtree, max path with a bend including the root }  In the above, max path with a bend including the root is the max of { max of {length of left only path of right subtree, max length of right path of right subtree with one bend} + 1, max of {length of right only path of left subtree, max length of left path of left subtree with one bend} + 1 }  Following code should work:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"There it is: ------------->  WTF are you talking about? Define your terms."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int longestPath(node *root) \n{ \n if(! root) \n  return 0; \n \n node *r1 = root->left; \n int pathLen = 2; \n  \n \n for(int len=0; r1; r1 = r1->left, len++) \n { \n  int tempcount = len + 1; \n  while(r1) \n  { \n   r1 = r1->right; \n   tempcount++; \n  } \n \n  if(tempcount > pathLen) \n   pathLen = tempcount; \n } \n \n r1 = root->right; \n \n for(int len=0; r1; r1 = r1->right, len++) \n { \n  int tempcount = len + 1; \n  while(r1) \n  { \n   r1 = r1->left; \n   tempcount++; \n  } \n \n  if(tempcount > pathLen) \n   pathLen = tempcount; \n } \n \n if(pathLen > 2) \n  return pathLen; \n else \n  return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If I understand correctly it means to find the diameter of binary tree. Please confirm."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int maxPath(TreeNode* root, int *height) \n{ \n if(!root)  \n { \n  *height = 0; \n  return 0; \n } \n  \n int lh=0, rh=0; \n  \n int ld = diameter(root->left, &lh); \n int rd = diameter(root->right, &rh); \n \n *height = 1+max(lh, rh); \n \n return max(max(ld, rd), 1+lh+rh); \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4881711603122176","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"19","title":"Given a list of unsorted numbers, can you find the numbers that have the smallest absolute difference between them? If there are multiple pairs, find them all.   Sample Input   12 -20 -3916237 -357920 -3620601 7374819 -7330761 30 6246457 -6461594 266854 -520 -470  Sample Output #2  -520 -470 -20 30 Explanation (-470)-(-520) = 30- (-20) = 50, which is the smallest difference.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"1)first sorting the list 2)traversing the list and return the min absolute pair.  the time complexity is O(nlogn). I do not know if there is any solution in O(n) steps."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ambiguous question.  If array is all 1. Do we print n(n-1)/2 pairs? or just 1?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using this method we can find the absolute minimum difference:  Assume numbers are array a[ ]."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I agree with Jason.  First sort the list, then compute the min of"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1> Convert all numbers as positive integers. 2> Sort them. complexity O(n log n) Average/best time 3> Traverse once to find the closest two adjacent numbers. O(n) Overall complexity O(n log n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorry, above won't work for -20,30"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution written in C++. Time complexity O(nlogn).  Output:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In c#, maybe not the most elegant, but this should work:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here my solution in O(n log n) time. @Diego: i think this might be faster than your algo...since i dont call vector.erase...which allocates the vector new?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(nlgn) with O(1) space solution 1. Sort the array. 2. Scan the sorted array from left to right. keep minDiff to contain the min difference between two elements during the scan. 3. If diff between two consecutive is less than minDiff so far then create a list and add the pair.  4. if diff between two consecutive is equal to minDiff that means there is already a list. Add the pair to the list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #define MAX 100 int main() { int arr[12]={-20,-3916237,-357920,-3620601,7374819,-7330761,30,6246457,-6461594,266854,-520,-470}; int i,j,temp,c[11],min; /* Sort the array*/  for (i= 0;i<11;i++)   {     for (j=0;j<(12-i-1);j++)     {       if (arr[j]>arr[j+1])       {         temp =arr[j];         arr[j]=arr[j+1];         arr[j+1]=temp;       }}}   for(i=0;i<11;i++)  {      c[i]=abs(arr[i]-arr[i+1]);       }      min=c[i];   for(i=0;i<11;i++)      {          if(min>c[i])          min=c[i];       }     for(i=0;i<11;i++)     {         if(min==c[i])         printf(\"%d %d\",arr[i],arr[i+1]);         }     return 0;   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.) Sort the list; 2.) Traverse the list twice: first to find the min difference and second to find all pairs with the min difference found"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5656914679562240","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"22","title":"List of parent and child of a binary tree are given in the format (parent, child) ??C> (p1,c1) (p2,c2) etc [ie, binary tree represented by adjacency list]  How to check \"loop\" exists in this binary tree or not  efficiently.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"we can do it more efficiently ..........in case of binary tree.... number of edges in n nodes binary tree is equals to (n - 1) count number of nodes in binary tree lets say n and also count number of edges(numbers of parents child pairs given) lets say e"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"suppose given pairs  (G,H),(B, E),(B,F),(A,B),(A,C),(C,G)......and if we construct tree froms these pairs..then binary tree looks like as following"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"In binary tree, no child can have more than one parent. create a map while populating this structure, if there is any attempt to assign parent of a node, which already have one, you got cycle."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Since the tree is already given in a graph representation, apply either BFS or DFS. Return true  if you encounter a node with 'isVisited' flag is true."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Care to give an example? Thanks."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) If we are given pairs in (parent, child) notation, then lets create a set S. 2 ) For each pair (parent, child) add parent to the set without checking if it is there 3) If child exists in the set then return false (it is a loop, meaning that we previously inserted this node either a parent or someone's child. A child can have only one parent in Binary tree). 4) Else add the child to the set 5) If no loops found - return true"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can do it in O(n) by using hashes. 1. Traverse the tree in any form (preorder, inorder or postorder). 2. For each element in the tree, create an entry in the hash. 3. While inserting, check if the entry already exists or not. If so, you found a loop. 4. If no duplicates found in the complete traversal, loop does not exist"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In the tree each node should be a \"child\" of  0 (root) or 1 \"parent\". In this case if some \"child\" presented in the list  of pairs (parent, child) twice or more - than the tree have cycles.   Searching the duplicates in the list is known algorithm that could be solved by O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A binary tree has a loop, if a child has more than one parent. So sort the given list with child as the key. Then travese the list to find if there are two adjacent node pair with same child . One more way I could think is to go through the list and create a hash table with child as key to figure out the number of parent the child has."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Tree is a directed acyclic graph. So, there should have only one path from root to any node in the tree. If this property is violated then the graph is not a tree and might have the potential chance for having a loop. We can easily check this by checking number of incoming edges to a node.   1) If a non-root node has more than one incoming edge then loop exists only if the edge is from a child to an ancestor.  2) If the root contains an incoming edge then loop surely exists.   If we have a tree like  a  / \\  b c  / \\  d  e   Now assume there is an edge from d to b (d, a). This edge will create a loop according to (2). Now assume an edge from d to b: (d, b). Then there will be a loop according to (1). But if e have an edge from e to c : (e,c) then there exist no loop although the tree is not tree anymore as there are more than one path from root to c."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If child has multiple parents, then there is loop, store a hashmap, with child as keys and parents has values, the moment i see a keys has more that one values, then there is a loop in the Tree"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5715360594526208","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"List of parent and child of a binary tree are given in the format (parent, child) ??C> (p1,c1) (p2,c2) etc [ie, binary tree represented by adjacency list]  How to check \"loop\" exists in this binary tree or not in efficiently.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Tree is a directed acyclic graph. So, there should have only one path from root to any node in the tree. If this property is violated then the graph is not a tree and might have the potential chance for having a loop. We can easily check this by checking number of incoming edges to a node.   1) If a non-root node has more than one incoming edge then loop exists only if the edge is from a child to an ancestor.  2) If the root contains an incoming edge then loop surely exists.  If we have a tree like                                            a        / \\           b c        /    \\         d  e  Now assume there is an edge from d to b (d, a). This edge will create a loop according to (2). Now assume an edge from d to b: (d, b). Then there will be a loop according to (1). But if e have an edge from e to c : (e,c) then there exist no loop although the tree is not tree anymore as there are more than one path from root to c."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In this particular type of binary tree representation, a node can appear only thrice. As a child of parent and parent of two of its children. If the three appearance is violated, then binary tree has a loop. Consider the following binary tree. 8 appears 4 times and hence btree has loop.  10,8  8,9  12,11  12,20  10,12  20,15  20,25  8,5  5,3  5,7  3,8"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If given list is:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5068766153015296","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"14","title":"You are given pairs of numbers. In a pair the first number is smaller with respect to the second number. Suppose you have two sets (a, b) and (c, d), the second set can follow the first set if b","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"dynamic programming?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Same as Longest Common Subsequence problem (just consider the second element in each pair) - can be solved in O(n^2) using dynamic programming."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Same as the \"Scheduling Problem\" in CLRS, which has a greedy algorithm solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Let's say input is a set of (x1,x2) points. Sort input by x2, then traverse the list and add elements to the chain which satisfy the required condition with regards to the tail of chain."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Collections; \nimport java.util.LinkedList; \nimport java.util.List; \n \n \npublic class Chain { \n \n class Segment implements Comparable { \n \n  private final int start; \n  private final int end; \n  private final String name; \n   \n  public int getStart() { \n   return start; \n  } \n \n  public int getEnd() { \n   return end; \n  } \n \n  public String getName() { \n   return name; \n  } \n \n  Segment(int start, int end, String name) { \n   this.start = start; \n   this.end = end; \n   this.name = name; \n  } \n   \n  @Override \n  public int compareTo(Segment s) { \n    \n   if (this.end > s.end) { \n    return 1; \n   } else if (this.end == s.end){ \n    return 0;     \n   } else { \n    return -1; \n   } \n     \n  } \n   \n } \n  \n  \n private final Segment[] segments = { \n    \n   new Segment( 8, 10, \"A\" ), \n   new Segment( 0, 7, \"B\" ), \n   new Segment( 11, 12, \"C\" ), \n   new Segment( 13, 16, \"D\" ), \n   new Segment( 0, 1, \"E\" ), \n   new Segment( 2, 15, \"F\" ), \n   new Segment( 4, 11, \"G\" ), \n   new Segment( 5, 6, \"H\") \n }; \n  \n  \n public int findChainLength() { \n   \n  List tempSegments = new LinkedList(); \n  int result = 0; \n   \n   \n  for (Segment s : segments) { \n   tempSegments.add(s); \n  } \n   \n  // O(nlogn) - sort segments by their end points: \n  Collections.sort(tempSegments); \n  Segment[] sortedSegments = (Segment[])tempSegments.toArray(new Segment[tempSegments.size()]); \n   \n  int currentSegmentIndex; \n   \n  currentSegmentIndex = 0; \n  System.out.print(sortedSegments[currentSegmentIndex].getName()); \n  result++; \n   \n  // O(n) worst case - scan and augment chain by adding the next \n  // shortest segment: \n  for (int index = 1; index < tempSegments.size(); index++) { \n    \n   if (sortedSegments[index].getStart() > sortedSegments[currentSegmentIndex].getEnd()) { \n    currentSegmentIndex = index; \n    result++; \n     \n    System.out.print(sortedSegments[currentSegmentIndex].getName()); \n   } \n  } \n   \n  return  result; \n } \n  \n  \n public static void main(String[] args) { \n   \n  Chain myChain = new Chain(); \n   \n  myChain.findChainLength(); \n   \n  return; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Sort the sets on the basis of second number. Set (a,b) should be sorted on 'b' 2) Then, take the series satisfying second condition, that is, out of sets (a,b) & (c,d) b should be less than c.  For example, (4,5) (7,9) (1,2) (11,15) (3,18) After sorting it becomes: (1,2) (4,5) (7,9) (11,15) (3,18) It is being assured that in (a,b) a is always less than b. Now, we can choose elements with respect to second condition as out of two sets, (a,b) & (c,d) b should be less than c."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(nlgn) using Activity Selection Problem:  1) Sort the pairs according to their second element --> O(nlgn)  2) Select the first pair from the sorted array and print it. --> O(1)  3) Do following for remaining pairs in the sorted array. --> O(n)  ---------------> If the first element of this pair is greater than the 2nd element of previously selected pair then select this pair and print it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"This guy must be interviewing with several companies everyday."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5913424689102848","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"14","title":"Write a function that converts an int into its alpha-numeric equivalent represented as a null terminated string. The function should accept an int as input and return a string as output. For instance, calling the function with an int value of 324 would return a null terminated string containing \"324\". Ensure that your function checks for appropriate boundary conditions and edge cases. Assume you cannot use any standard libraries (for example, no itoa or sprintf).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"C++ version."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"loop { \nrem = value % 10 \nvalue /= 10 \nmystr[i++] = rem - '0' //sizeof(mystr) == sizeof(int) + 1 and mystr[i] = '\\0' for 0 < i < sizeof(mystr)  \n} until value > 0  \n \nrev(mystr) // reverse by swapping ith and (n-1-i)th for 0 < i < sizeof(mystr)/2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Null terminated string? Should the function's return type be char* ? If so, the caller will need to worry about the memory problem then, which I don't think is a very good way. If the function returns a string as an object, then the null terminated request will be redundant. Here is my C++ solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class numToStr { \npublic static void numToStrVal(int a,String s){  \n if(a>0){ \n  s=a%10+s; \n  numToStrVal(a/10,s); \n } \n else \n System.out.println(s);; \n  \n} \npublic static void main(String[] args) { \n numToStrVal(324,\"\\0\"); \n} \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"string itoa(int num){ \n  \n if (num == 0) return \"0\"; \n string ret_string; \n  \n if (num < 0){   \n  ret_string.push_back('-');  \n  num = -num; \n } \n  \n while (num !=0){ \n  ret_string.push_back(num%10 + '0'); \n  num = num/10; \n } \n \n ret_string.push_back('\\0'); \n \n //swap \n for(int i = ret_string[0] == '-', j = ret_string.size()-2; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"C++ version:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6650855742767104","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"32","title":"Print words of given string in reverse: \"This is test\"  -> \"test is This\"","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"1.Make a function to reverse the string passed:: String Reverse(String s){} 2.Reverse whole string.:: s=Reverse(s); 3.Split The String by space. a[] = s.Split(\" \"); 3.For each word in a, Reverse and print i.e:: a[i] = Reverse(a[i])  then print a[i]."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"1. Split the string by space String arr[] = str.split(\" \"); \n2. for (i=arr.length - 1; i>=0; i--)   System.out.print(arr[i] + \" \");"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"My solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi. Here is O(n) time complexity and O(1) memory solution that is readable and small, using C++."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public String  reverse(String ss){  if(ss.length()==0)return null;  else if(ss.length()==1)return ss;  else return ss.substring(ss.length()-1)+reverse(ss.substring(0, ss.length()-1));   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why can't this be a s simple as   split with space  push all in stack pop all"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"String str = \"This is test\"; \n  String[] strArray = str.split(\" \"); \n  String newStr= \"\"; \n  for(String s:strArray){ \n   newStr = s + (\"\".equals(newStr)?newStr:\" \") + newStr ; \n  } \n  System.out.println(newStr);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static String revereseWords(String inputString,char spaceChar){ \n  char[] charArray = inputString.toCharArray(); \n  int totalLength = charArray.length; \n  char[] destArray = new char[totalLength]; \n  int spaceCount = 0; \n  for (int i = totalLength , length = 0; i > 0; i--,length++) { \n   if (charArray[i-1] != spaceChar){ \n    spaceCount ++; \n   }else{ \n    System.arraycopy(charArray, i, destArray, length-spaceCount, spaceCount); \n    destArray[length] = ' '; \n    spaceCount = 0; \n   } \n  } \n  if (spaceCount > 0){ \n   System.arraycopy(charArray, 0, destArray, totalLength-spaceCount, spaceCount); \n  } \n  return String.valueOf(destArray); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Without use of any array split...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ruby Code without using built in function-"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"-----Ruby Code------ str=String.new n=String.new str='This is a new year' l=str.length puts l len=l-1  for i in 0...l  n[i]=str[len]  len=len-1   end print n"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Heres the solution in C without using stack"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here my C++ version:  string get_words_reverse(string &s) {  int j = s.size() - 1;    for(int i = 0; i < s.size()/2.0; i++) {   swap(s[i], s[j]);   j--;  }    for(int i = 0; i <= s.size(); i++) {   if(s[i] == ' ' || i == s.size()) {    int end = i - 1;    int len = end - start;     for(int j = 0; j <= len/2.0; j++) {     swap(s[start], s[end]);     start++;     end--;    }        start = i + 1;   }  }    return s; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":">>> a = \"This is a test\" >>> a[-1::-1] 'tset a si sihT'"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void check()  {   index=0;   for(int i=0;i  {    if(i<(input.length()-1))    {     index=input.indexOf(\" \");     if(index!=-1)     {      output= input.substring(0,index)+\" \"+output;      input=input.substring(index+1);      i=0;     }         }        else    {     output= input.substring(0)+\" \"+output;         }   }      System.out.println(output);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public String reverseString(String s) { \n        if (s == null || s.length() <= 1) { \n            return s; \n        } else { \n            return reverseString(s.substring(1)) + s.charAt(0); \n        } \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Stack; \n \npublic class PrintLineInReverse { \n \n public static String reverseString(String str){ \n  Stack sk = new Stack(); \n  StringBuilder sb = new StringBuilder(); \n  int lasti=0; boolean flag=false; \n  String st; \n  for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Scanner;  public class reversewrdstring  {  public static void main(String[] args)  {   Scanner obj= new Scanner(System.in);   String str;   String str1=\" \";   int len,i,j;   System.out.println(\"Enter String\");   str=obj.nextLine();   len=str.length();   for(i=(len-1);i>=0;i--)   {    if(str.charAt(i)==' ')    {     for(j=(i+1);j<=(len-1);j++)     {      str1=str1+str.charAt(j);     }     str1=str1+' ';     len=i;    }    else if(i==0)    {     for (j=i;j<=(len-1);j++)     {      str1=str1+str.charAt(j);     }    }   }   System.out.println(\"The modified String is \"+str1);  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"String sentence = \"This is test\"; \n  String[] words = sentence.split(\" \"); \n  for(int i = words.length-1 ; i >=0 ; i-- ) \n  { \n   System.out.print(words[i]); \n   if(i > 0) \n    System.out.print(\" \"); \n  } \n \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the C++ code: \nint main() { \n \n string cszStr = \"I am tester trying for new opportunities\"; \n \n int len = cszStr.length(); \n \n for (int i=0,x=0; i<= len; i++, x++) \n { \n  if (32 == (int)cszStr[len-i] || i == len) \n  { \n   for (int y = len-i; y <= ((len-i)+x); y++) \n    cout << cszStr[y]; \n   x = 0; \n  } \n } \n \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This is my C++ version, O(n) complexity and O(1) space (in-place). First reverses the entire string. Then reverse each word separated by one or more spaces."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"line = 'This is test' \nprint line.split()[::-1]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"this is my CPP code working fine with few test."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"reverse(char *p,stack &s) \n{ \n   if(*(p + 1) != '\\0') \n   { \n     reverse(++p); \n   } \n    \n   if(*p != ' ') \n   { \n     s.push(p); \n   } \n   else \n   { \n     s.print(); // This pops and prints all the chars pushed so far \n   }    \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4915877933744128","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"19","title":"Write code for finding first duplicate element in given array: [4,3,1,2,5,9,5,4] output : 5  (not 4)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Time: O(n) Space: O(n) Use hashMap to mark every element encountered so far. The first element that is already in map is the output, print that number and return."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"import java.util.HashMap; \n \n \npublic class FirstDupicate { \n \n public  static void main(String []args) \n { \n  int []arr= {4,3,5,6,5,7,8,4}; \n  int duplicate=-1; \n  HashMap hm=new HashMap(); \n   \n  for(int i:arr){ \n   System.out.print(i+\",\"); \n  if(null==hm.get(i)) \n  { \n   hm.put(i,i); \n  } \n  else{ \n   duplicate=i; \n  break; \n  } \n  } \n  System.out.println(duplicate); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is my C++ version with O(n) time, O(n) space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Time O(n) Space(n). Finding a number which have Closest duplicate. Below method will return 5 as answer not 4 since 5 has closest duplicate then 4."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"srinivas , sorting will change the index , so how will you know that which element is first repeated/duplicate .. best way is using hashing .. if there is any other way other than using hashing  with o(n), i would like to know ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class FindingFirstDuplicateElement { \n \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n \n  int[] data = { 4, 3, 1, 2, 5, 9, 5, 4 }; \n  Map lookup = new HashMap(); \n  for (int temp : data) { \n   if (lookup.containsKey(temp)) { \n    System.out.println(temp); \n   } else { \n    lookup.put(temp, 1); \n   } \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I agree that hashset should be used since it also has a method that returns false if the element being added is duplicate.Moreover for Performance both hashmap and hashset are same,but this code makes it much simpler."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For simplicity, assume that the values of the array A are all positive integers and A has length N (In the general case, hash the values of A into the positive integers).  Now, count sort the values A[i] of A, starting from i=0, noting that the first bin to obtain two elements will be the first duplicate."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.*; public class Firstduplicate { public static void main(String[] args) {         // TODO code application logic here         HashSet hs = new HashSet();         int[] array = {4,3,1,2,5,9,5,4};         int i=0;         while(hs.add(array[i]))         {             i++;         }         System.out.println(array[i]);     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n) time and O(n) space"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Recursive version"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the C++ code: \n //!!!Finding first duplicate element in the array \n \n string strArr = \"43125954\"; \n int cPntr = 0; \n int lPntr = 0; \n \n for (int i = 0; i < strArr.length(); i++) \n { \n  for (int j = (i+1); j < strArr.length(); j++) \n  { \n   if (strArr[i] == strArr[j]) \n   { \n    cPntr = j; \n   } \n  } \n \n  if ( cPntr < lPntr) \n   lPntr = cPntr; \n  else \n   lPntr = cPntr; \n \n } \n cout << strArr[lPntr] << \" is the first duplicate elements in the string\"; \n cout << endl;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"d = [] for i in a:  if i in d:   print i   break  else:   d.append(i)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"we sort elements and compare with side element....."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"int firstDup(int[] str) { \n  int len = str.length; \n  Map map = new HashMap(); \n  int loc = len; \n  int lastValue = 0; \n  for (int i = 0; i < len; i++) { \n   for (int j = i + 1; j < len; j++) { \n    if (str[i] == str[j]) { \n     if (loc > j) { \n      loc = j; \n \n     } \n    } \n   } \n  } \n  return str[loc]; \n }"}]}}]