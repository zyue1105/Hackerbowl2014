[{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=7578666","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"80","title":"1. How to find whether two link-lists intersect each other or not? If yes find intersection point.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"Consider two linked lists L1 and L2 1) Go through L1 and get its length l1 2) Go through L2 and get its length l2 3) Now find the difference d = l1-l2 4) So d is the number of nodes that are extra in longer list. 5) Traverse longer list till 'd' ..keep a pointer at this point 6) Now the length of longer list( That pointer) is equal to length of smaller list from front. 7) Now just traverse the the two list sequentially and compare every Node   Complexity O(n).."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"These are the following steps:- 1)traverse the first list and reach at the end 2)link the end of first list to the head of second list 3) retain the pointers at the head of both list,also at the end of 1st list 4) problem becomes a->b->c->d->e->f->g->h->e loop in a linked list and now we have to find the start of loop 5)take two pointers move 1st by one node,second by  two  6) when they meet after that take back the 1st to head 7)now move both pointers 1st and second also by one node(from the meeting point) 8)where they meet is the intersection of both list 9)break the link from last of 1st list to head of second"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"int check( struct node * list1,struct node * list2) {  int count1 = countLL(list1);  int count2 = countLL(list2);   while(count1> count2)  {   list1 = list1->next;   count1--;   }  while(count2>count1)  {   list2 = list2->next;   count2--;  }   while(list1 ! = list2)  {   list1 = list1->next;   list2 = list2->next;  }  if(list1== null)  {   return 0;/ do not intersect  }  else   return 1; //it intersects   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Another approach : 1. point the last of 1st list to begining of second list. 2. Check if cycle is present (using fast and slow pointer). 3. If cycle is present then these two list merge at some point. 4. to Find the merging point, take two pointers one at the start of 1st list and another at the node where fast and slow pointers meet. 5. increment these two pointers by one each. 6. the node where they meet will be the merging point of two list.  Thanks"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Algo: - Find lengths of lists with two given heads.  Let us say they are m, n. - Have two pointers each pointing to given head pointers - Find abs(m - n), and skip abs(m - n) nodes in the long list - Compare both pointers. If they match, return. Otherwise, move both pointers by one step.  Repeat this step till the lists end  Logic: - Maximum length of common list < minimum of lengths of linked lists -- Case - 1: One is a sub-list of the other -- Case - 2: Both lists are same - That means big list length - small list length nodes can safely be skipped for comparison  Space Complexity : O(1) Time Complexity: O(m + n)  Thanks, Laxmi"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if the address of tail nodes in both linked lists are equal then the linked lists intersect.  to find the intersection..increment a pointer from head of the longer list by L1-L2...where L1 and L2 are lengths of longer and shorter lists. The pointer on L2 starts from its head. Now keep incrementing the pointers of both L1 and L2 till they intersect."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Nope intersection in de shape of X is not possible coz if it has to occur de middle node should have 2 next pointers n v's sol is rite"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Nope intersection in de shape of X is not possible coz if it has to occur de middle node should have 2 next pointers n v's sol is rite"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"intersection of two single link-list always be in Y shape, X shape is not possible in any case."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Cudos to M.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void check(struct node *list1, struct node *list2) {  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void check(struct node *list1, struct node *list2) {  struct node *temp1, *temp2;  temp1=list1->start;  while(temp1!=NULL  {  }  ) }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void check(struct node *list1, struct node *list2) {  struct node *temp1, *temp2;  temp1=list1->start;  while(temp1!=NULL  {    temp2=list2->start;    while(temp2!=NULL)    {      if(temp1==temp2)      {       printf(\"Intersection found!\");    //at temp1 or temp2       break;      }      temp2=temp2->next;    }      temp1=temp1->next;  } ) }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If two linked lists meet then they should end at the same NULL node (or last node). Traverse both lists and if they both end at the same NULL node (or if the last node is same for both), they meet"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Y list problem. 1. Traverse both the list and count nodes. 2. Traverse the bigger one as many nodes as the difference between two. 3. Now traverse both the list simultaneously and keep on checking if both the pointers are pointing to same node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If we have authority to change the linklist  node structure,i'll makrk each visited node of 1st list.  now i'll start traversing on 2nd list & when i'll get marked node then i'll get merging point."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"while(list1 != null && list2 != null ) {   if(list1 == list2)     return true;   else    {      list1=list1->next;      if(list1==list2)       return true;      else        list2=list2->next;    } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Thanks Paras for your reply But I have one question  if the two linked lists meet, the meeting node will have two next pointers pointing to both the linked lists, so while travering in the cycle, how the next pointer will be progressed? I mean towards which linked list?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Assume list 2 to be shorter list, list 1 to be longer one  2)  loop x from head:list1 to NULL     loop y from head:list2 to NULL       if ( x == y )          intersection = x;          return;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Finding out if they merge is easy, start with 2 pointers and keep iterating until next pointer is null. If the 2 poiters are now equal, then lists merge. Basically if the last elemet of the 2 lists is the same node, they converge, otherwise not.  now finding out where they merge - can we use a hash and add nodes from first list, then from second list. First node where we hit exception is the one where lists merge, since that will be the first common node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use hashmap then store element addresses, if key is exists then it is merge point."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using a hashmap to store the addresses of the list elements is working but if the lists are huge this table will be huge.  If memory is the bottleneck and you are willing to pay for time you could do this: Get the address of the first list item in list-A and search for it in list-B. If found -> bingo. If not get the next item in list-A and repeat. If you cannot find any of the addresses of the items in list-A -> they never merge. (And it does not matter which list you use as list-A and -B)  Actually they always merge in NULL aka the empty list :) but I am not sure all interviewers will love this answer although an empty list is a very nice list and he/she might not like if you ignore this special case on another problem ;)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just compare tails of each list. If they become equal then they merge.  To find out where do they actually meet we can do the reverse traverse till the node is in both list. Thus we get the node where the lists meet."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Consider two linked lists L1 and L2 1) Go through L1 and get its length l1 2) Go through L2 and get its length l2 3) Now find the difference d = l1-l2 4) So d is the number of nodes that are extra in longer list. 5) Traverse longer list till 'd' ..keep a pointer at this point 6) Now the length of longer list( That pointer) is equal to length of smaller list from front. 7) Now just traverse the the two list sequentially and compare every Node"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"given these two lists: 1->2->3->4->5->6->7 and a->b->6->c->d, then the intersection point would be 6 right? If that's the case, then you can find that point with a hash table and the complexity would be O(n+m) (the number of nodes in both lists)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// junk.cpp : Defines the entry point for the console application. //  #include \"stdafx.h\" #include  #include    struct node  {  int data;  struct node *next; };  struct node * insert(struct node *, int ); void  insertintersection(struct node *,struct node *, int ); void display(struct node *); int intersection(struct node *,struct node *);   void main() {  struct node *head1,*head2,*top;     int x=0,p=0;  head1=NULL;  head2=NULL;  //1st list    head1=insert(head1,10);  head1=insert(head1,20);  head1=insert(head1,30);  head1=insert(head1,40);  head1=insert(head1,50);  head1=insert(head1,60);  head1=insert(head1,70);  head1=insert(head1,80);  head1=insert(head1,90);  head1=insert(head1,100);  printf(\"1st list is :=>\\n\");  display(head1);  // 2nd list    head2=insert(head2,1000);  head2=insert(head2,2000);  head2=insert(head2,4000);  head2=insert(head2,5000);  head2=insert(head2,200);  head2=insert(head2,300);  head2=insert(head2,800);  insertintersection(head1,head2,700);      printf(\"\\n2nd list is :=>\\n\");  display(head2);   p=intersection(head1,head2);  printf(\"\\nintersection point is ==>%d\",p); }  int intersection(struct node *t,struct node *r) {    struct node *temp1,*temp2;    int count1=0,count2=0,diff=0;         temp1=t;     temp2=r;    while(temp1)    {     temp1=temp1->next;     count1++;    }     while(temp2)    {     temp2=temp2->next;     count2++;    }     diff=count2-count1;        for(;diff>0;diff--)     r=r->next;      while(t->data!=r->data)    {     t=t->next;        r=r->next;    }    return (t->data); }     struct node * insert(struct node *t,int m) {  struct node *temp,*r;    temp=(struct node *)malloc(sizeof(struct node));  temp->data=m;  temp->next=NULL;   if(t==NULL)  {         t=temp;  }  else  {   r=t;   while(r->next!=NULL)   {    r=r->next;   }   r->next=temp;  }  return t; }  void insertintersection(struct node *t,struct node*s,int m) {     struct node *temp,*r;    temp=(struct node *)malloc(sizeof(struct node));  temp->data=m;  temp->next=NULL;    while(t->data!=40)    t=t->next;   while(s->next !=NULL)    s=s->next;   s->next=temp;   temp->next=t;    return;  }   void display(struct node *t) {  struct node *p;  p=t;  while(p)  {   printf(\"%d->\",p->data);   p=p->next;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// junk.cpp : Defines the entry point for the console application. //  #include \"stdafx.h\" #include  #include    struct node  {  int data;  struct node *next; };  struct node * insert(struct node *, int ); void  insertintersection(struct node *,struct node *, int ); void display(struct node *); int intersection(struct node *,struct node *);   void main() {  struct node *head1,*head2,*top;     int x=0,p=0;  head1=NULL;  head2=NULL;  //1st list    head1=insert(head1,10);  head1=insert(head1,20);  head1=insert(head1,30);  head1=insert(head1,40);  head1=insert(head1,50);  head1=insert(head1,60);  head1=insert(head1,70);  head1=insert(head1,80);  head1=insert(head1,90);  head1=insert(head1,100);  printf(\"1st list is :=>\\n\");  display(head1);  // 2nd list    head2=insert(head2,1000);  head2=insert(head2,2000);  head2=insert(head2,4000);  head2=insert(head2,5000);  head2=insert(head2,200);  head2=insert(head2,300);  head2=insert(head2,800);  insertintersection(head1,head2,700);      printf(\"\\n2nd list is :=>\\n\");  display(head2);   p=intersection(head1,head2);  printf(\"\\nintersection point is ==>%d\",p); }  int intersection(struct node *t,struct node *r) {    struct node *temp1,*temp2;    int count1=0,count2=0,diff=0;         temp1=t;     temp2=r;    while(temp1)    {     temp1=temp1->next;     count1++;    }     while(temp2)    {     temp2=temp2->next;     count2++;    }     diff=count2-count1;        for(;diff>0;diff--)     r=r->next;      while(t->data!=r->data)    {     t=t->next;        r=r->next;    }    return (t->data); }     struct node * insert(struct node *t,int m) {  struct node *temp,*r;    temp=(struct node *)malloc(sizeof(struct node));  temp->data=m;  temp->next=NULL;   if(t==NULL)  {         t=temp;  }  else  {   r=t;   while(r->next!=NULL)   {    r=r->next;   }   r->next=temp;  }  return t; }  void insertintersection(struct node *t,struct node*s,int m) {     struct node *temp,*r;    temp=(struct node *)malloc(sizeof(struct node));  temp->data=m;  temp->next=NULL;    while(t->data!=40)    t=t->next;   while(s->next !=NULL)    s=s->next;   s->next=temp;   temp->next=t;    return;  }   void display(struct node *t) {  struct node *p;  p=t;  while(p)  {   printf(\"%d->\",p->data);   p=p->next;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"(Using difference of node counts) 1) Get count of the nodes in first list, let count be c1. 2) Get count of the nodes in second list, let count be c2. 3) Get the difference of counts d = abs(c1 ??C c2) 4) Now traverse the bigger list from the first node till d nodes so that from here onwards both the lists have equal no of nodes. 5) Then we can traverse both the lists in parallel till we come across a common node. (Note that getting a common node is done by comparing the address of the nodes)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"One solution.. 1. Go to the end node of common list. 2. Make it point to the head of longer list.Loop will be created 3 Calculate the length of the loop 'x'. 4. Now take two iterator itr1 and itr2. Give head start of x to itr1. 5. Now move both the itrs toward head with same speed.whereever they meet that will be the intersection node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use 2 stacks to store nodes while traversing 2 linkedlists. Then keep popping until you find 2 nodes that are different."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sort the linklists and then it would be easy to find intersection."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"may be a crude/immature or an  engineering method  1) L1 = length( list1); 2) L2 = length( list2);  now reverse any of the list [ assume List-1 is reversed ] 3) now starting from head of List-2 find the length  = L3  intersection point Ie ( From the end )  =  ( L1+L2 - L3 )/2;  intersection point from the begining  of list 1 is (  L1- Ie)th node"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a Small correction in the above method  intersection point Ie ( From the end ) = ( L1+L2 - L3-1 )/2;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about Reverse(L1), Reverse(L2) and then check for a diverging node! Bad Idea??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"traverse linked list 1 traverse link list 2 simultaneously  until temp1->link==temp2->link; gives point of intersection"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"(1)take  2pointers initialize to head of the list (2)increment both pointer till they reach end of the list and calculate list length l1,l2 (3) calculate absolute difference between l1-l2 ie n=|l1-l2| (4) calculate nth element from end of the list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I could only think of using a hashtable"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"a binary search may be useful."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13575664","download_status":"DOWNLOAD_DONE","votes":"3","answersCount":"82","title":"Q1.- Written exam (Amazon, Bangalore)  Given a singly link list and a number 'K', swap the Kth node from the start with the Kth node from the last. Check all the edge cases.  Sample Input: 1->2->3->4->5->6->7->8 and K = 3 Sample Output : 1->2->6->4->5->3->7->8  Sample Input: 1->2->3->4->5->6->7->8 and K = 10 Sample Output: print error \"LIST IS OF LESSER SIZE\".","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"18","title":"This can be done in line without first completely traversing the list to check the size. This can be done with 3 pointers.   One pointer is for the first element which is k from the start the second pointer is for the element which is k from the end the last pointer is to find the end.  Then you traverse the list save the pointers and do the swap at the end, you don't even have to mess with the links when swapping, just swap the values from the pointers you have saved from above."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"We need to handle a few test cases. 1. Both nodes are end nodes. 2. Both nodes are adjacent. 3. Both nodes are somewhere else. 4. Both node are same. 5. kth node doesn't exist.  I prefer swapping the nodes rather than values. It is always advisable to swap the nodes as in general, nodes may contain several data. So, it will be overhead to swap the values.  Steps: Find the kth node[p] from the beginning. If no kth node, return. Take another pointer[q] & move it at head. Move it & the kth node one step at a time until kth node is null.   q is the kth node from the last.  We need to swap p & q.  The part of linked list found is: t1->p->t2   and t3->q->t4 Just swap the nodes based on links & handle the corner cases mentioned above. Here is the code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Take 3 pointers to the starting point of the list - P1, P2 & P3.  Start moving P1 & P3 till you have moved 'K'  nodes. If the list ends before P1 reaches the End, give the error message \"LIST IS OF LESSER SIZE\". Once you have reached the Kth node, move P1 and P2 pointers to the next node one by one till P1 reaches the end.  At this point P2 points to the Kth element from the last. Now simply swap the values of P2 & P3.  Job done."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public static void swap(LinkedList ll,int k){ \n  int size = ll.size(); \n  if(1<=k&&k<=size){ \n   int firstK = ll.get(k-1); \n   int lastK=ll.get(size-k); \n   ll.set(k-1, lastK); \n   ll.set(size-k, firstK); \n   System.out.println(ll); \n  }else{ \n   System.out.println(\"ERROR\"); \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algorithm: 1.Get the linked list lenghth. If it is less than 'K' print the error message. O(N) 2.Traverse to the 'K' the element from the beginning. O(N) 3.Traverse to the N-Kth element from the beginning. O(N) 4. Swap them.O(1) 5.End of Algorithm  Complexity: O(N)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Find Kth Element from Beginning. Store the pointer. 2. Using Kth Element, find kth element from last(two pointers) 3. Swap these pointers. 4. At every step, check for length traversed till is < n, otherwise raise error"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node* SwapList(Node* head, int k) \n{ \n if (head == NULL || head->next == NULL) \n { \n  return head; \n } \n  \n Node* current = head->next; \n Node* prev = head; \n int currentCount = 2; \n  \n Node* kth = NULL; \n Node* kthPrev = NULL; \n Node* kthLast = NULL; \n Node* kthLastPrev = NULL; \n  \n while (current != NULL) \n { \n  if (currentCount == k) \n  { \n   kth = current; \n   kthPrev = prev; \n  } \n   \n  if (kthLast != NULL) \n  { \n   kthLastPrev = kthLast; \n   kthLast = kthLast->next; \n  } \n  else if (kth != NULL) \n  { \n   kthLast = head; \n  } \n   \n  prev = current; \n  current = current -> next; \n } \n  \n if (kth == NULL) return head; // kth node does not exist in list \n if (kth == head) // k == 1 \n { \n  kthLast->next = kth->next \n  kth->next = NULL; \n  kthLastPrev->next = kth; \n  return kthLast; // this becomes new head \n } \n  \n  \n if (kthLast == head) \n { \n  kth->next = kthLast->next; \n  kthprev->next = kthLast; \n  kthLast->next = NULL; \n  return kth; \n } \n  \n Node* temp = kth->next; \n kth->next = kthLast->next; \n kthLast->next = temp; \n kthLastPrev->next = kth; \n kthPrev->next = kthLast; \n return head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node* SwapList(Node* head, int k) \n{ \n if (head == NULL || head->next == NULL) \n { \n  return head; \n } \n  \n Node* current = head->next; \n Node* prev = head; \n int currentCount = 2; \n  \n Node* kth = NULL; \n Node* kthPrev = NULL; \n Node* kthLast = NULL; \n Node* kthLastPrev = NULL; \n  \n while (current != NULL) \n { \n  if (currentCount == k) \n  { \n   kth = current; \n   kthPrev = prev; \n  } \n   \n  if (kthLast != NULL) \n  { \n   kthLastPrev = kthLast; \n   kthLast = kthLast->next; \n  } \n  else if (kth != NULL) \n  { \n   kthLast = head; \n  } \n   \n  prev = current; \n  current = current -> next; \n } \n  \n if (kth == NULL) return head; // kth node does not exist in list \n if (kth == head) // k == 1 \n { \n  kthLast->next = kth->next \n  kth->next = NULL; \n  kthLastPrev->next = kth; \n  return kthLast; // this becomes new head \n } \n  \n  \n if (kthLast == head) \n { \n  kth->next = kthLast->next; \n  kthprev->next = kthLast; \n  kthLast->next = NULL; \n  return kth; \n } \n  \n Node* temp = kth->next; \n kth->next = kthLast->next; \n kthLast->next = temp; \n kthLastPrev->next = kth; \n kthPrev->next = kthLast; \n return head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node* SwapList(Node* head, int k) \n{ \n if (head == NULL || head->next == NULL) \n { \n  return head; \n } \n  \n Node* current = head->next; \n Node* prev = head; \n int currentCount = 2; \n  \n Node* kth = NULL; \n Node* kthPrev = NULL; \n Node* kthLast = NULL; \n Node* kthLastPrev = NULL; \n  \n while (current != NULL) \n { \n  if (currentCount == k) \n  { \n   kth = current; \n   kthPrev = prev; \n  } \n   \n  if (kthLast != NULL) \n  { \n   kthLastPrev = kthLast; \n   kthLast = kthLast->next; \n  } \n  else if (kth != NULL) \n  { \n   kthLast = head; \n  } \n   \n  prev = current; \n  current = current -> next; \n } \n  \n if (kth == NULL) return head; // kth node does not exist in list \n if (kth == head) // k == 1 \n { \n  kthLast->next = kth->next \n  kth->next = NULL; \n  kthLastPrev->next = kth; \n  return kthLast; // this becomes new head \n } \n  \n  \n if (kthLast == head) \n { \n  kth->next = kthLast->next; \n  kthprev->next = kthLast; \n  kthLast->next = NULL; \n  return kth; \n } \n  \n Node* temp = kth->next; \n kth->next = kthLast->next; \n kthLast->next = temp; \n kthLastPrev->next = kth; \n kthPrev->next = kthLast; \n return head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node* SwapList(Node* head, int k) \n{ \n if (head == NULL || head->next == NULL) \n { \n  return head; \n } \n  \n Node* current = head->next; \n Node* prev = head; \n int currentCount = 2; \n  \n Node* kth = NULL; \n Node* kthPrev = NULL; \n Node* kthLast = NULL; \n Node* kthLastPrev = NULL; \n  \n while (current != NULL) \n { \n  if (currentCount == k) \n  { \n   kth = current; \n   kthPrev = prev; \n  } \n   \n  if (kthLast != NULL) \n  { \n   kthLastPrev = kthLast; \n   kthLast = kthLast->next; \n  } \n  else if (kth != NULL) \n  { \n   kthLast = head; \n  } \n   \n  prev = current; \n  current = current -> next; \n } \n  \n if (kth == NULL) return head; // kth node does not exist in list \n if (kth == head) // k == 1 \n { \n  kthLast->next = kth->next \n  kth->next = NULL; \n  kthLastPrev->next = kth; \n  return kthLast; // this becomes new head \n } \n  \n  \n if (kthLast == head) \n { \n  kth->next = kthLast->next; \n  kthprev->next = kthLast; \n  kthLast->next = NULL; \n  return kth; \n } \n  \n Node* temp = kth->next; \n kth->next = kthLast->next; \n kthLast->next = temp; \n kthLastPrev->next = kth; \n kthPrev->next = kthLast; \n return head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void swapElementsInLinkedList(int k){   if(k<0 || k> getSize() ){    throw new InvalifIndexException(\"LIST IS OF LESSER SIZE/LIST SIZE CANT BE NEGATIVE\");   }   temp = head ;   LinkedListNode KthnodeFromRear = null;   int newValueForK = (getSize()-k)+1;   int counter = 1;   int firstStop = 0;   int lastStop = 0;   if(k   firstStop = k;    lastStop = newValueForK;   }   else{    firstStop = newValueForK;    lastStop = k;   }     while(counter != firstStop){         counter ++;         temp=temp.getNext();          }       KthnodeFromRear = temp;     while(counter!=lastStop){         counter ++ ;         KthnodeFromRear = KthnodeFromRear.getNext();         }         swap(temp,KthnodeFromRear);          }      private void swap(LinkedListNode first, LinkedListNode last) {   Integer data = first.getData();   first.setData(last.getData());   last.setData(data);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void replace_node(struct node **head,int pos) \n{ \n        int count = 1; \n        int tmp =0; \n        myNode *curr = *head; \n        myNode *one = curr; \n        myNode *two = curr; \n        while(two != NULL && two->next !=NULL && count next; \n                count++; \n        } \n        curr = two; \n        while(one!=NULL &&one->next!=NULL&& two->next!=NULL) \n        { \n                one = one->next; \n                two = two->next; \n        } \n        tmp = curr->value; \n        curr->value = one->value; \n        curr = one; \n        curr->value = tmp; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void replace_node(struct node **head,int pos) \n{ \n        int count = 1; \n        int tmp =0; \n        myNode *curr = *head; \n        myNode *one = curr; \n        myNode *two = curr; \n        while(two != NULL && two->next !=NULL && count next; \n                count++; \n        } \n        curr = two; \n        while(one!=NULL &&one->next!=NULL&& two->next!=NULL) \n        { \n                one = one->next; \n                two = two->next; \n        } \n        tmp = curr->value; \n        curr->value = one->value; \n        curr = one; \n        curr->value = tmp; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int kthnodeswap (node*& head, int k) \n{ \n \n    if (k<=0) //invalid node given \n        return -1; \n    else \n    { \n        if (k==1) //swap head node and last when index = 1 \n        { \n            node *trav = head; \n \n            //move till the end of the list \n            while (trav->next!=NULL) \n                trav = trav->next; \n \n            //swap head and last node \n            int temp = head->data; \n            head->data = trav->data; \n            trav->data = temp; \n            return 1; \n        } \n        else \n        { \n            node *trav = head; //pointer to traverse the list \n            node *swap1 = trav; //pointer which will point to the kth node from beginning \n            node *swap2 = trav; //pointer which will point to the kth node from end \n \n            //advance both traverse pointer and the beginning pointer till kth node \n            for (int i = 2; i <= k ; i++) //index starts at 2 since 1st node is head \n            { \n                trav = trav->next; \n                if (trav == NULL) return 0; //list is of lesser size \n                swap1 = trav; //advance two pointers to the same location \n            } \n \n            //after reaching the kth node from beginning advance the traverse pointer and end pointer \n            while (trav->next != NULL) \n            { \n                trav = trav->next; \n                swap2 = swap2->next; \n            } \n \n            //swap the data pointed by beginning pointer and end pointer \n            int temp = swap1->data; \n            swap1->data = swap2->data; \n            swap2->data = temp; \n            return 1; \n \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int list_swap(snode *head,int pos) \n{ \n    snode *tmp; \n    int ll=0; \n    int cnt=1; \n    snode *curr    =    NULL; \n \n    for(tmp = head;tmp;tmp=tmp->next)  \n            ll++; \n     \n    for(tmp = head;cnt < pos;cnt++)  \n            tmp=tmp->next; \n \n    /*Found from head node*/ \n     \n    curr    =    tmp; \n    while((ll-cnt) != pos-1) \n    { \n        tmp    =    tmp->next; \n        cnt++; \n    } \n    /*Now swapping the data part*/ \n    cnt    =    tmp->data; \n    tmp->data    =    curr->data; \n    curr->data    =    cnt; \n    return(0);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void swaplist(Node** list,int K) \n{ \n if (K<1)  \n  return; \n int count=1; \n Node* first=*list; \n while (count++next; \n if (first==0) { \n  cout << \"not available\\n\"; \n  return; \n } \n Node* tmp=first; \n first=first->next; \n Node* second=*list; \n while (first) { \n  first=first->next; \n  second=second->next; \n } \n swap(tmp1,second);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is working code and covers almost all the cases and boundries:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Fellas.. this ain't a Big Complex Code.. Its tricky question...  Algo. 1> Get kth Node from last and kth node from beginning. 2> Hold one pointer each to these nodes. 3> Swap their values.. :D   Code               struct Node* Swapkth(struct Node * node,int k)               {                 struct Node *temp1,*temp2,*temp3;                 temp1=node;                   while(k!=0) {                                           node=node->next;                        }                     temp2=node;// this is kth node from first                                         while(node->next!=NULL) {                                node=node->next;                                temp1=temp1->next;                           }                    //Finally when loop exits temp1 will be  pointing to the kth node from the last.                  temp3=temp1;                  temp1->data=temp2->data;                  temp2->data=temp3->data;               free(temp1);               free(temp2);               free(temp3);              }   This is all U need... No Swapping No Complex Code.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Fellas.. this ain't a Big Complex Code.. Its tricky question...  Algo. 1> Get kth Node from last and kth node from beginning. 2> Hold one pointer each to these nodes. 3> Swap their values.. :D   Code               struct Node* Swapkth(struct Node * node,int k)               {                 struct Node *temp1,*temp2,*temp3;                 temp1=node;                   while(k!=0) {                                           node=node->next;                        }                     temp2=node;// this is kth node from first                                         while(node->next!=NULL) {                                node=node->next;                                temp1=temp1->next;                           }                    //Finally when loop exits temp1 will be  pointing to the kth node from the last.                  temp3=temp1;                  temp1->data=temp2->data;                  temp2->data=temp3->data;               free(temp1);               free(temp2);               free(temp3);              }   This is all U need... No Swapping No Complex Code.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/*Q1.- Written exam (Amazon, Bangalore)  Given a singly link list and a number 'K', swap the Kth node from the start with the Kth node from the last. Check all the edge cases.  Sample Input: 1->2->3->4->5->6->7->8 and K = 3 Sample Output : 1->2->6->4->5->3->7->8  Sample Input: 1->2->3->4->5->6->7->8 and K = 10 Sample Output: print error \"LIST IS OF LESSER SIZE\"*/ #include #include struct node *recursion(struct node *,int ); /* void append(struct node **,int ); void display(struct node *);  here is problem is that void  you will get warning warning: ??struct node?? declared inside parameter list [enabled by default] amazon1.c:12:20: warning: its scope is only this definition or declaration, which is probably not what you want [enabled by default] amazon1.c:13:21: warning: ??struct node?? declared inside parameter list [enabled by default] */ struct node  {   int data;   struct node *link; }; int main() {   struct node *start;   start=NULL;   int n,i=0,item,k;   printf(\"Enter the no of node\\n\");   scanf(\"%d\",&n);   while(i++  {    printf(\"Enter node value\\n\");    scanf(\"%d\",&item);    append(&start,item);      }   display(start);   printf(\"Enter the number k for swaping kth from the fast and kth from last\\n\");   scanf(\"%d\",&k);   swap(start,k,n);   printf(\"\\n\");   display(start); }  append(struct node **t,int b) {   struct node *r,*temp;   r=*t;     if(r==NULL)     {         r=(struct node*)malloc(sizeof(struct node));         *t=r;     }   else     {          while(r!=NULL)         {           temp=r;           r=r->link;         }         temp->link=(struct node *)malloc(sizeof(struct node));         r=temp->link;         /*            If you write like this r=(struct node *)malloc(sizeof(struct node)); then you are creating indepent node which are not connected            to it's previous node.r=NULL then r(struct node *)malloc(sizeof(struct node)); it will not link to the previous node .          */     }      r->data=b;     r->link=NULL;      }  display(struct node *q) {     while(q!=NULL)     {      printf(\"%d-> \",q->data);      q=q->link;     } } swap(struct node *fast,int k,int n) {     struct node *Kth_fast,*Kth_last;     int temp;     if(k>n)        printf(\"Swaping is not possible you enter the number greater than number of element of linklist\\n\");     else     {        Kth_fast=recursion(fast,k);        Kth_last=recursion(fast,n-k+1);     }     temp=Kth_last->data;     Kth_last->data=Kth_fast->data;     Kth_fast->data=temp;   } struct node *recursion(struct node *p,int K) {     int i=1;     while(i++    {       p=p->link;     }      return p; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Complexity: O(n) Space: O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Complexity: O(n) Space: O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapKth(Node *head,int k) \n{ \n  int counter=0; \n  Node *kth=head,*kth_end=head; \n  while(kth && counter++next; \n  if(!kth) return false; \n  counter=0; \n  while(counter ++next; \n  while(head) {head=head->next;kth_end=kth_end->next;} \n  swap(kth->data,kth_end->data); \n  return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapKth(Node *head,int k) \n{ \n  int counter=0; \n  Node *kth=head,*kth_end=head; \n  while(kth && counter++next; \n  if(!kth) return false; \n  counter=0; \n  while(counter ++next; \n  while(head) {head=head->next;kth_end=kth_end->next;} \n  swap(kth->data,kth_end->data); \n  return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapKth(Node *head,int k) \n{ \n  int counter=0; \n  Node *kth=head,*kth_end=head; \n  while(kth && counter++next; \n  if(!kth) return false; \n  counter=0; \n  while(counter ++next; \n  while(head) {head=head->next;kth_end=kth_end->next;} \n  swap(kth->data,kth_end->data); \n  return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapKth(Node *head,int k) \n{ \n  int counter=0; \n  Node *kth=head,*kth_end=head; \n  while(kth && counter++next; \n  if(!kth) return false; \n  counter=0; \n  while(counter ++next; \n  while(head) {head=head->next;kth_end=kth_end->next;} \n  swap(kth->data,kth_end->data); \n  return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapKth(Node *head,int k) \n{ \n  int counter=0; \n  Node *kth=head,*kth_end=head; \n  while(kth && counter++next; \n  if(!kth) return false; \n  counter=0; \n  while(counter ++next; \n  while(head) {head=head->next;kth_end=kth_end->next;} \n  swap(kth->data,kth_end->data); \n  return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapKth(Node *head,int k) \n{ \n  int counter=0; \n  Node *kth=head,*kth_end=head; \n  while(kth && counter++next; \n  if(!kth) return false; \n  counter=0; \n  while(counter ++next; \n  while(head) {head=head->next;kth_end=kth_end->next;} \n  swap(kth->data,kth_end->data); \n  return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"you can just reverse the value."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if (indexToBeSwapped < 0 || indexToBeSwapped > inputList.Count - 1)                 return;             int indexFromLast = inputList.Count - indexToBeSwapped;             int temp = inputList[indexToBeSwapped];             inputList[indexToBeSwapped] = inputList[indexFromLast];             inputList[indexFromLast] = temp;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There is no need to swap the node. Just swap the value. That's it,"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapList(Node* head, int k) {     int count = 0;     Node *p1, *p2, *end;     p1 = p2 = end = head;      while (count < k-1)     {         if (0 != end->next)         {             end = end->next;             count++;         }         else         {             return false;         }     }      p1 = end; // fix the first pointer      while (0 != end->next)     {         end = end->next;         p2 = p2->next;     }// fix the position of second pointer      // swap the data values in the two pointer p1 and p2     p1->data = p1->data + p2->data;     p2->data = p1->data - p2->data;     p1->data = p1->data - p2->data;      p1 = p2 = end = 0;     return true; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapList(Node* head, int k) \n{ \n    int count = 0; \n    Node *p1, *p2, *end; \n    p1 = p2 = end = head; \n \n    while (count < k-1) \n    { \n        if (0 != end->next) \n        { \n            end = end->next; \n            count++; \n        } \n        else \n        { \n            return false; \n        } \n    } \n \n    p1 = end; // fix the first pointer \n \n    while (0 != end->next) \n    { \n        end = end->next; \n        p2 = p2->next; \n    }// fix the position of second pointer \n \n    // swap the data values in the two pointer p1 and p2 \n    p1->data = p1->data + p2->data; \n    p2->data = p1->data - p2->data; \n    p1->data = p1->data - p2->data; \n \n    p1 = p2 = end = 0; \n    return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have written and tested the following code ... its working"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hi guys , below is the code with 2 pointers..difference between pointers is k... slow  pointer is behind k positions of fast pointers.  There is a check before getting the k(th) element from the first and k(th) element from the last..which you can see in the following loop:           for( i = 1; i< k; i++){    fast = fast.getNext();    if(fast == null){     System.out.println(\"List is of size:: \" + i + \"  which is lesser then::\" + k);     return;    }   }     Please find the code below , this is a method in a linked list class, which access the head of the list using this.getHead() method.  and swaps the values in the last..  public void replaceKthCharacter(int k){      Node  kthElementFromStart,slow , fast;   slow =  fast = this.getHEAD();      if(slow == null || fast == null){    System.out.println(\"List is empty..\");    return;   }      int i;      for( i = 1; i< k; i++){    fast = fast.getNext();    if(fast == null){     System.out.println(\"List is of size:: \" + i + \"  which is lesser then::\" + k);     return;    }   }       kthElementFromStart = fast ;      while(fast != null && fast.getNext() != null){    fast = fast.getNext();    slow = slow.getNext();   }      String tmpKey = kthElementFromStart.getKey();   kthElementFromStart.setKey(slow.getKey());   slow.setKey(tmpKey);        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Its Easy, please do as explained below.  1.take 2 pinters say ptr1 and ptr2 and assign the root node address. 2.Move the ptr2 for the k times,this the pointer you have to swap keep the address with you. 3.Now move the both the pointer ptr1 and ptr2 both at time, the moment ptr2 reach to null, note down the ptr1. 4.swap the ptr1 and once node which you have restored before.  complexity is O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nstruct node \n{ \n    int info; \n    struct node *link; \n}; \nstruct node *create(struct node *start, int data); \nvoid exchange(struct node *start, int k); \nvoid display(struct node *start); \n \nint main() \n{ \n  int data,ans,k; \n  struct node *start=NULL; \n  do \n  { \n       cout<<\"Enter the value\"<>data; \n         start=create(start,data); \n         cout<<\"do you want to add another node?\"<>ans; \n    }while(ans==1); \n    display(start); \n    cout<<\"enter the position\"; \n    cin>>k; \n    exchange(start,k); \n    display(start); \n  getch(); \n  return 0; \n} \n \nvoid exchange(struct node *start, int k) \n{ \n   int count=0,s,i; \n   struct node *p,*q,*p1,*q1,*temp; \n   p=start; \n   q=p; \n   while(p!=NULL) \n   { \n          count++; \n          p=p->link; \n     } \n     try \n     { \n       if(k>count) \n         throw k; \n     //cout<<<<\" is the count\"<link; \n     } \n     s=count-k; \n     for(i=0;ilink; \n     } \n     if(p==q1) \n     { \n     int swap; \n     swap=p->info; \n     p->info=q->info; \n     q->info=swap; \n     return; \n     } \n     temp=q->link; \n     p1->link=q; \n     q->link=p->link; \n     q1->link=p; \n     p->link=temp; \n      \n     } \n     catch(int) \n     { \n     cout<<\"out of bounds\"<info=data; \n          start->link=NULL; \n          return start; \n  } \n  while(p->link!=NULL) \n  { \n          p=p->link; \n     } \n     temp=new node; \n     temp->info=data; \n     temp->link=NULL; \n     p->link=temp; \n     return start; \n} \n \nvoid display(struct node *start) \n{ \n   struct node *p=start; \n   while(p!=NULL) \n   { \n   cout<info; \n   if(p->link!=NULL) \n     cout<<\"->\"; \n   p=p->link; \n     } \n     cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"swapKthNode(node *head){ \n    temp=head \n    while(k!=1){ \n        if (head == NULL) return \"ERROR\"; \n        head = head->next; \n        k--; \n    } \n    first_node=head; \n    while(head->next!=NULL){ \n        head = head->next; \n        temp = temp->next; \n    } \n    second_node = temp; \n    swap(first_node->data, second_node->data) \n \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// (assuming k=0 means swap root and tail) \nNode* swapK (Node* head, int k) { \n \n Node* p1, p2, temp; \n int n = 1; \n  \n // no list, nothing to swap..  \n if (head == null || head->next = null) \n  return head; \n  \n // count length of list \n // optimized here to save time for k=0 below \n p1 = head; \n while(p1->next != null) { \n  p1 = p1->next; \n  n++; \n } \n  \n // negative values of k and k greater \n // then length of list are not valid \n if (k < 0 || k > n) \n  return NULL; // should actually throw error here \n \n // normalize k \n if (k > n/2) \n  k = n-k; \n   \n // special case if k=0 or k=n \n if (k == 0) { \n  // set p1 = 2nd to last node \n  p1 = head; \n  for (int i = 1; i < n-1; i++) \n   p1 = p1->next; \n  // set p2 = last node \n  p2 = p1->next; \n   \n  // set last node to point to 2nd node \n  p2->next = head->next; \n  // set 2nd to last node to point to head \n  p1->next = head; \n  // set head to point to nothing (it is now the last node) \n  head->next = null; \n   \n  // return the new head (p2) \n  return p2; \n } \n   \n // set p1 to (k-1)th node \n p1 = head; \n for (int i = 1; i < k; i++) { \n  p1 = p1->next; \n } \n // set p2 to (n-k-1)th node \n p2 = p1->next; \n for (int i = k; i < n-2k; i++) { \n  p2 = p2->next; \n } \n  \n // swap p1's next and p2's next \n temp = p1->next; \n p1->next = p2->next; \n p2->next = p1->next; \n // swap p1 next's next and p2 next's next \n temp = p1->next->next; \n p1->next->next = p2->next->next; \n p2->next->next = p1->next->next; \n  \n return head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void fn(node * start) \n  { \n     if(K>N)// if n given else traverse inO(n) to find the length \n       printf(\"ARRAY IS OF LESSER  SIZE\") \n    else \n   { \n        int traverse=0,count=0; \n        if(K>N-K) \n          traverse=N-K; \n       else traverse=K; \n      node * one ,*two; \n      one=start; \n      while(count++!=traverse) \n         one=one->next; \n      two=one; \n     traverse=abs(2*K-N) \n     count=0 \n     while(count++!=traverse)two=two->next \n     swap(one->data,two->data); \n     } \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void move_the_node(struct link_list **node, int mov) {         struct link_list *start_ptr, *end_ptr, *length_ptr;         int i=0,j;         if((*node)->next == NULL)         printf(\"No swapping..since list is empty\\n\");         else         {                 length_ptr = (*node);                 while(length_ptr)                 {                         i++;                         length_ptr = length_ptr->next;                 }                 if(i <= mov)                 printf(\"Cant swap..since no enough nodes\\n\");                 else{                 end_ptr = start_ptr = (*node);                 for(j=0; j                start_ptr = start_ptr->next;                 for(j=0; j<(i-mov-1); j++)                 end_ptr = end_ptr->next;                 i = end_ptr->data;                 end_ptr->data = start_ptr->data;                 start_ptr->data = i;                 }         } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"don't u think the question is too easy.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void swapListNodes(int swapPosition)             {                 Node advPointer = first;                 Node normalPointer = first;                 Node tempNode = first;                 Node iterator = first;                 int tempdata = 0;                 int loop = 1;                  if (swapPosition > count) return;                                while (loop < swapPosition)                 {                     if (iterator.next != null)                     {                         advPointer = iterator.next;                         iterator = iterator.next;                         loop++;                     }                 }                  tempNode = advPointer;  // at 3rd position from start                  while (advPointer.next != null)                 {                     advPointer = advPointer.next;                     normalPointer = normalPointer.next;                 }                                   tempdata = normalPointer.data;                 normalPointer.data = tempNode.data;                 tempNode.data = tempdata;             }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void swapkelement(struct list **l,int k) { struct list *x = *l; struct list *y; struct list *z = *l; int i; for(i=0 ; i < k  ; i++) { if(x == NULL) {  printf(\"LIST IS OF LESSER SIZE\");  return; } if(i == k-1) y = x; x = x->next; }  while(NULL != x) { z = z->next; x = x->next; }  i = y->data; y->data = z->data; z->data = i; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hey guys pls let me know if this is correct solution.....  void swap(nd *start,int val) { nd *temp; int count=0,j,i=0;  temp=start; while(temp->next!=NULL) { temp=temp->next; count++; } if(count>val) { j=0; temp=start; i=count-val; while(j++<=i) { temp=temp->next; } //p(\"from last %d\\n\",temp->data); count=0; while(count++{ start=start->next; } //p(\"from beg %d\\n\",start->data); //if(start->next==temp)                    //if both elements are adjacent to each other.... //{ int var; var=start->data; start->data=temp->data; temp->data=var; //p(\"list changed...\\n\");  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nint k,t1,t2; \nint x; \nvoid insert1(); \nvoid swap1(); \nvoid swap(); \nstruct Node1 \n{ \n int info1; \n Node1 *next1; \n}; \nNode1 *ptr1,*start1=NULL,*rear1,*save1; \nmain() \n{ \n cout<<\"How many nodes in list\\n\"; \n  \n cin>>x; \n for(int i=0;i>k; \n swap1(); \n //swap(); \n} \nvoid insert1() \n{ \n ptr1=new Node1; \n  \n if(start1==NULL) \n { \n  cout<<\"Enter info\\n\"; \n        cin>>ptr1->info1; \n  start1=ptr1; \n  ptr1->next1=NULL; \n  rear1=ptr1; \n } \n else \n { \n  cout<<\"Enter info\\n\"; \n        cin>>ptr1->info1; \n  rear1->next1=ptr1; \n  ptr1->next1=NULL; \n  rear1=ptr1; \n } \n} \nvoid swap1() \n{ \n int cnt=0; \n save1=start1; \n while(save1) \n { \n  cnt=cnt+1; \n  cout<<\"\\n\"<<\"COUNT HERE\\n\"; \n  cout<<\"\\n\"<info1; \n   \n  } \n   //save1=save1->next1; \n  if(cnt==(x-k) ) \n  { \n   t2=save1->info1; \n    \n  } \n  save1=save1->next1; \n   \n } \n int temp; \n temp=t1; \n t1=t2; \n t2=temp; \n cout<<\"VALUES INTERCHANGED\\n\\n\\n\"<<<\"\\t\"<info1; \n while(save1) \n { \n  save1=save1->next1; \n  cout<<\"\\n\"<info1; \n } \n} \nvoid swap() \n{ \n  \n}*/ \n      \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void swapindex(list L,int index){ List lst=new LinkedList(L); swap(lst,lst.get(index),lst.get(lst.size()-index)); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The running time is O(N) and hardly any space complexity .. the only trick here is to maintain the height of the node in the node object and the length of the linked list in the linkedlist instance   Here is the python implementation"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I simply did this by getting the two nodes from the get node function and then swapped the two. i got the answer correctly.   public LinkedListNode getNode(int index){   String str;   LinkedListNode prevnode = first.getNext();   for(int i=0;i   prevnode = prevnode.getNext();  // reaching the index node.   }   return prevnode;  }    // Swapping the Kth node from first and last alike.  public void specialSwap(int index){   LinkedListNode frontnode = first.getNext();   LinkedListNode lastnode = first.getNext();   frontnode = getNode(index);    // obtain the first node   lastnode = getNode(size()-index+1);  // obtain the last node      // Swap the Nodes values. no need  of breaking the nodes.   String temp = frontnode.getName();   frontnode.setName(lastnode.getName());   lastnode.setName(temp);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nusing namespace std; \n \nstruct node{ \n int data; \n node *next; \n}; \n \nint main() \n{ \n  \n node *list,*nptr,*tptr; \n int item,n,i; \n list=NULL; \n  \n cout<<\"PLEASE.......Type how many nodes that you want    \"; \n cin>>n; \n for(i=1;i<=n;i++) \n { \n  cout<<\"Type your \"<<<\" node item  \"; \n  cin>>item; \n  nptr=new(node); \n  nptr->data=item; \n  nptr->next=NULL; \n  if(list==NULL) \n  { \n   list=nptr; \n   tptr=nptr; \n  } \n  else \n  { \n   tptr->next=nptr; \n   tptr=nptr; \n  } \n } \n tptr=list; \n for(i=1;i<=n;i++) \n { \n   \n  cout<data<<\"    \"; \n  tptr=tptr->next; \n   \n } \n cout<<>k; \n tptr=list; \n first=k-1; \n last=(n-k); \n int mid=(n-k+2); \n node *pptr,*sptr,*wptr=NULL,*temp2=NULL,*temp1=NULL; \n int count=1; \n tptr=list; \n for(i=1;i<=n;i++) \n { \n   \n  if(count==first) \n  { \n   pptr=tptr; \n   temp2=pptr->next; \n  } \n  else if(count==last) \n  { \n   sptr=tptr; \n   temp1=sptr->next; \n    \n  } \n  else if(count==mid) \n  { \n   wptr=tptr; \n    \n  } \n  tptr=tptr->next; \n  count++; \n   \n   \n } \n int d; \n d=(n/2); \n if(d!=k) \n { \n   \n  temp1->next=pptr->next->next; \n   \n   \n  pptr->next=temp1; \n   \n   \n   \n  sptr->next=temp2; \n   \n   \n  temp2->next=wptr; \n } \n  \n else  \n { \n  pptr->next=temp1; \n  temp1->next=sptr; \n  sptr->next=wptr; \n } \n  \n  \n int g; \n  \n for(g=1;g<=n;g++) \n { \n  cout<data<<\"   \"; \n  tptr=tptr->next; \n   \n } \n  \n    cout<<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void mainwork() \n { \n//initialise to start. \n//count is the length of link list \n//n is the position at which swap needs to be made. \n temp=p; \n int count=0; \n while(temp!=NULL) \n { \n count++; \n temp=temp->link; \n } \n int n=4; \n prev=p; \n curr=prev->link; \n next=curr->link; \n for(int i=0;ilink; \n  curr=curr->link; \n  next=next->link; \n } \n prev1=p; \n curr1=prev1->link; \n next1=curr1->link; \n for(i=0;ilink; \n  curr1=curr1->link; \n  next1=next1->link; \n } \n //cout<<\"\\n\"<data<<\",\"<data; \n \n if(nlink=curr1; \n curr1->link=next; \n prev1->link=curr; \n curr->link=next1; \n } \nelse \n{ \n \ncout<<\"Cant perform this operation\"; \n \n} \n \n \n \n \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n \nstruct node { \n int data; \n struct node *link; \n}; \n \nint append(struct node **q,int num) { \n struct node *temp, *r; \n temp = *q; \n if(temp == NULL) { \n  temp = (struct node *) malloc(sizeof(struct node)); \n  temp->data = num; \n  temp->link = NULL; \n  *q = temp; \n  return 0; \n } \n while(temp->link != NULL) \n  temp = temp->link; \n r = (struct node *) malloc(sizeof(struct node)); \n r->data = num; \n temp->link = r; \n return 0; \n} \n \nint display(struct node *q) { \n struct node *temp = q; \n while(temp != NULL) { \n  printf(\"data = %d\\n\",temp->data); \n  temp = temp->link; \n } \n return 0; \n} \n \nint sizeofl(struct node *temp) { \n int count = 0; \n struct node *temp1 = temp; \n while(temp1 != NULL) { \n  count++; \n  temp1 = temp1->link; \n } \n return count; \n} \n \nint swap_list(struct node **q,int position) { \n struct node *temp = *q, *ptr1 = *q,*ptr2 = *q; \n int size_list,i,temp_data = 0; \n size_list = sizeofl(temp); \n printf(\"count = %d\\n\",size_list); \n for(i=1; ilink; \n printf(\"ptr1 data = %d\\n\",ptr1->data); \n for(i=0;ilink; \n printf(\"ptr1 data = %d\\n\",ptr2->data); \n temp_data = ptr1->data; \n ptr1->data = ptr2->data; \n ptr2->data = temp_data; \n return 0; \n} \n \nint main() \n{ \n struct node *k = NULL; \n append(&k,1); \n append(&k,2); \n append(&k,3); \n append(&k,4); \n append(&k,5); \n append(&k,6); \n append(&k,7); \n append(&k,8); \n append(&k,9); \n display(k); \n swap_list(&k,3); \n display(k); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void swap(struct node *node1,struct node *node2) {     if(node1 == NULL || node2 == NULL)     {       cout<<\"LIST IS OF LESSER SIZE\"<      return;     }     int temp_data = 0;     temp_data = node1->data;     node1->data = node2->data;     node2->data = temp_data;     struct node *temp = start;     while(temp->next != NULL)     {        cout<data<<\"->\";        temp = temp->next;     }     cout<data<}  void trav_swap(int K) {     int curr = 1;      struct node *temp = start;     struct node * node1 = NULL, *node2 = NULL;     if(K == 0)     {       cout<<\"INVALID INPUT\"<      return;     }     while(temp != NULL && curr != K)     {                temp = temp->next;                curr++;     }     if(curr == K)     {         node1 = temp;         node2 = start;         while(temp->next != NULL)         {            temp = temp->next;            node2 = node2->next;         }     }     swap(node1,node2);      }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void swap(struct node *node1,struct node *node2) \n{ \n    if(node1 == NULL || node2 == NULL) \n    { \n      cout<<\"LIST IS OF LESSER SIZE\"<data; \n    node1->data = node2->data; \n    node2->data = temp_data; \n    struct node *temp = start; \n    while(temp->next != NULL) \n    { \n       cout<data<<\"->\"; \n       temp = temp->next; \n    } \n    cout<data<next; \n               curr++; \n    } \n    if(curr == K) \n    { \n        node1 = temp; \n        node2 = start; \n        while(temp->next != NULL) \n        { \n           temp = temp->next; \n           node2 = node2->next; \n        } \n    } \n    swap(node1,node2); \n     \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use double linked list & two pointers,one from first till our k value and another from last till our k value then exchange the values"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"check skillgun.com for free online tests with java interview questions"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Algorithm: 1.Get the linked list lenghth. If it is less than 'K' print the error message. O(N) 2.Traverse to the 'K' the element from the beginning. O(N) 3.Traverse to the N-Kth element from the beginning. O(N) 4. Swap them.O(1) 5.End of Algorithm  Complexity: O(N)."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=1814","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"54","title":"Coding: How would you find the nth to last element in a linked list?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Use two pointers. Initalize both pointers to the front of the list then use a loop to traverse one pointer Nth times. Then moves both pointers until one reaches the end of the list. The second pointer is Nth to last element"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here n is the distance from the last element. Is there a better solution out there ??node *getNthToLast(node *head, int *pos, int n) {        if(head==NULL) {                *pos=0;                return NULL;        }        node *nElemNode = getNthToLast(head->next, pos, n);        if((*pos)++==n)                return head;        else                return nElemNode;}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Iteration solutions are generally better than recursive solutions.  Can you do it iteratively?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Well its obvious to do it iteratively if its a doubly linked list... simply traverse till the last node... now traverse back n nodes.On the other hand if its singly linked I dont see how it can be done in an \"efficient\" manner (without doing something stupid like using extra memory!). You really have to first find the length of the list somehow.... a quick way could be to traverse the list 2 nodes in each iteration of the while/for loop (something I would do to find the middle element of a linked list). Dunno if this makes sense ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using extra memory isn't much worse than a recursive solution.  Every time you add a level to your recursion, you increase the stack.  Memory usage for your recursive solution is O(n) anyway."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@KHOA   U may be right... i also think that 2 pointers make sense and simplifies the solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the size of the list is M(compute this) and you want N, then traverse a  pointer M-N-1 times."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Taking Khoa's idea further...something like this....int findNthPos(int pos){ LLIST ptr1,ptr2; ptr1=ptr2=head; int current=pos; while(ptr1->next) {  current = pos;  ptr2= ptr2->next;  ptr1 = ptr2;  while(current-- >0)  {   if(ptr1!=NULL)   ptr1=ptr1->next;  }   } return ptr2->data;}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Khoa's solution would work fine. To put it into codeint findNthPos( LinkedList* listHead, int pos ){    if ( pos < 0 || listHead == NULL )         return FAILURE;    LinkedList *ptr1, *ptr2;    ptr1 = ptr2 = head;    while( pos > 0 )    {      if( ptr1 == NULL )        return FAILURE; // could return some other error value      ptr1 = ptr1->next;      pos--;    }    while( ptr1 != NULL )    {         ptr1 = ptr1->next;         ptr2 = ptr2->next;    }    return ptr2->data;}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Trying to see if i can put spaces in here ... being a Virgo, i tend to be fussy about small things sometimes :-)int findNthPos( LinkedList* listHead, int pos){    if( pos < 0 || listHead == NULL )        return FAILURE;// look up the previous answer for complete code}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node* findNthPos( node* head, int pos ) {node *nth, *current;int n = 0;nth = listHead;current = listHead->next;while(current){current = current->next;if(n == pos){nth = nth->next;}else{n++;}}}if(n == pos)  return nth;else  return NULL;  /* no such node */}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node findNode(LinkedList list, int pos){   int size=0;   iter=list.head;   while(iter != null)   {     size++;     iter = iter -> next;   }   foundNode=list.head;   for(int i=2;i<=size-pos;i++)   {      foundNode=foundNode->next;   }   return foundNode;}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Although the above solutions may work, such complex solutions can potentially introduce bugs that are cumbersome to detect."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just for fun...to find the nth to last element.If you know how many elements are in the linked list, and you have a pointer to the first element and the last element.  Also, assuming that its a double-linked list.Determine if the Nth element is closer to the front of the list, or the back of the list, ie (length/2).  If its closer to the front of the list, travse from the front of the list.  If its closer to the back of the list, traverse from the back."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Khoa's solution would work fine. To put it into code node* findNthLast(node* head, int n){ if(n<0){ //check for negative inputcout<<\"Error\";return NULL;}node *nBehind;     //n-behind pointernode *curr = head;for(int i=0; iif(curr->next){curr = curr->next}else{return NULL;}nBehind = head; while(curr->next){curr = curr->next;nBehind = nBehind->next;}return nBehind;}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Khoa's solution would work fine. To put it into code node* findNthLast(node* head, int n){ if(n<0){ //check for negative input cout<<\"Error\"; return NULL; } node *nBehind; //n-behind pointer node *curr = head; for(int i=0; iif(curr->next){ curr = curr->next } else{ return NULL; } }nBehind = head; while(curr->next){ curr = curr->next; nBehind = nBehind->next; } return nBehind; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What is the difference between 2 pointers solution and Jack's solution? i.e.1. Count the number of elements. O(M) time, say M nodes totally.2. From begining travel M-N+1 steps.The numbers of steps are the same for both."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The 2 pointer approach will take only M steps."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think 2 pointer approach also takes 2M-N+1 moves."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why don you take Saloni's code and spend some time to analyze the number of steps."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming that Node represents a node in the linked list.struct ptrpos{Node *ptr;int pos;}With array of n structures ptrpos_array, walk through the list and fill in the array with pointer to the nodeand its position till you reach the end. Now we knowthe number of nodes lets say it is m. The pointer tothe nth node is at ptrpos_array[m-n+1].This approach also takes o(m)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Forget to mention, just round robin the arrayfilling once you reach the end of the array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ListNode* nthFromBack(LinkedList* list, int n){  int i = 1;  ListNode* node = list->first;  ListNode* to_return = NULL;  while (node)  {    if (i == n)      to_return = node;        node = node->next;    i++;  }  return to_return;}I'd test this with a few test cases... the edge cases (list size 0, 1), maybe a five-element list, and a case where n is greater than the list size."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ListNode* nthFromBack(LinkedList* list, int n){ int i = 1; ListNode* node = list->first; ListNode* to_return = NULL; while (node) {   if (i == n)   {     to_return = list->first;   }   if (i>n)   {     to_return = to_return->next ;   }      node = node->next;   i++; } return to_return;} Hi Corrected code is above.. Please check the difference"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"take 2 pointers...move one N steps and then start moving the second also..when the first hits last the second is Nth from last :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node *find(int n, node *p) {    node *temp;    int num = 0;    if (p == NULL) return -1; /* checking error condition */    if (n == 0) return p; /* another error case */    temp = p;    while (p != NULL && num < (n-1)) {        p = p->next; num++;    }    if (p == NULL) return -1; /* list is not big enough */    while (p != NULL) {        p=p->next; temp=temp->next;    }    return temp;}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Amazing solution and smart too.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi guysI think instead of using two pointers and then traversing the list we could use some extra space and do it with one pointer.We can use a circular queue of size n+1 and then start traversing the list till end and keep inserting the elements in the queue.When we reach the end of the list the front element in the queueis the required node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Take 2 pointers A and B2) Point both to starting of list A=0 b=03) Move one pointer to nth node A=n-14) Move both the pointers and stop when A hits the last Node .Now B will point to the Nth Node from last"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Khoa's solution is right and it is also mentioned in the book PIE with the same solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void show_n_elment(link *ln, int N){ link *nelement = ln, *node = ln; int i = 0 ; while(i < N && node != NULL) {  i++;  node = node->next; } if(i != N) {  printf(\"\\n No. of element in link list is less than %d \\n \",N);  return ; } else {  while(node != NULL)  {   node = node->next;   nelement = nelement->next;  } } printf(\"\\n %dth element of link list from end is : %d \" ,N,nelement->info);}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simple approach on khoa's solutionstruct list { int data; struct list *next;};typedef struct list myList;myList * find5thNode(myList *head){ myList *fast = NULL; myList *slow = NULL; int count = 1; fast = slow = head; while(NULL != fast) {  if ( (count >1) && ((count % 5) == 1)) /* 5 times slower then fast pointer*/   slow = slow->next;  fast = fast->next;  count++; } /* in case list contains lesser than 5 nodes, this returns NULL, which is ok as there is no 5th node in the list */ if(count <5)  return NULL; else  return slow;} }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For any number n, just replace 5 with n. (count%n) does the trick, it moved slow pointer n times slower than the first one."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i dont exactly understand this...Does this find nth from the tail?like if we have to find rd from the tail with 10 nodes, does the code find the 7th node?The problem is more of complexity.One solution is to count the nodes and return the 7th (after you know that there are 10 elements), or maintain a counter as u add nodes.The simpler solution is to run two pointers, ptr0 and ptr1, and start using ptr1 after ptr0 has reached the nth element (checking that it is not out of bounds)Thus, when ptr1 reaches the end of the list, ptr1 points exactly to the nth from tail element.The above solution gives n from front.The point to note is nth from tail is difficult in a singly linked list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am of a different opinion. Better use a stack. Assuming worst case where this linked list is single linked list . We do not know number of nodes we do not know the size. Just keep pushing addresses of nodes on a stack still you get end of list. When end of list is achieved just pop n-1 nodes addresses from the stack and peek top of stack. You will get nth node from last. Any suggestions on this approach??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I thin that stack approaching is not good in terms of memory management and we also need additional work for sorting either. as you mentioned, we do not know how big the size of liked list. but no matter what it's O(m) iteration would be better, I mean it's simple and clear enough I think."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Reverse the list (which can be done in O(n) ) and find the nth position and again reverse the list"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include#includeusing namespace std;struct node  {       int data;     node *nxt;// Pointer to next node  };node *start_ptr = NULL;node *current;   // Used to move along the listvoid add_node_at_end()  {  node *temp, *temp2;   // Temporary pointers     // Reserve space for new node and fill it with data     temp = new node;     cout << \"Please enter the data value: \";     cin >> temp->data;     temp->nxt = NULL;     // Set up link to this node     if (start_ptr == NULL)       { start_ptr = temp;  current = start_ptr;       }     else       { temp2 = start_ptr;         // We know this is not NULL - list not empty!         while (temp2->nxt != NULL)           {  temp2 = temp2->nxt;              // Move to next link in chain           }         temp2->nxt = temp;       }  }void display_list()  {  node *temp;     temp = start_ptr;     cout << endl;     if (temp == NULL)       cout << \"The list is empty!\" << endl;     else       { while (temp != NULL)    {  // Display details for what temp points to              cout << \"Data : \" << temp->data;       if (temp == current)  cout << \" <-- Current node\";              cout << endl;       temp = temp->nxt;    }  cout << \"End of list!\" << endl;       }  }void findNthLast(){    node *nBehind;     //n-behind pointer    node *curr = start_ptr;    int n=3;    for(int i=0; i    {         if(curr->nxt)       {                     curr = curr->nxt;       }    }    nBehind = start_ptr;    while(curr->nxt)    {                    curr = curr->nxt;                    nBehind = nBehind->nxt;    }    cout<<\"The third last element is :\"<data;}int main(){    start_ptr = NULL;    char option;    do {   display_list();   cout << endl;   add_node_at_end();   cout<<\"Enter another value (y/n):\";   cin>>option; }while (option == 'y'); display_list(); cout<<\"Here is the third node from the end in the list\\n\"; findNthLast(); getch();}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If we don't have to maintain the list in its original form, then reverse the list as we iterate the first time. So from L, we now have L' (reversed list). Now iterate N steps in L' to reach Nth last element in original list L. This would require M+N-1 steps. However, it keeps the list in reversed state. If N is very close to M, then this approach is worse than iterating twice on L. Worst case performance of both approaches are the same. If you are going to hit the 'back' of the list, then the approach stated above would work better."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ok"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node* nth_last(node* head, int n) \n{ \n node* nth; \n int i; \n nth=head; \n for(i=0;inext; \n if(!nth) return 0; \n while(nth) \n { \n  nth=nth->next; \n  head=head->next; \n } \n return head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"2-pointer approach is the best solution for this question.   All other solutions need extra time or space. Stack / Hash map approach needs extra O(n) space. Recursion (whoever suggested the reversing-approach) is equally bad. Recursion eats up a lotta stack. The function stack's size grows by twice with every recursive call.  So, stick to slow-fast pointer method which is O(n) max."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I want to solve this problem using recursion in JAVA. Can anyone please help me out?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//c# \n public Node nthToLast(int n) \n        { \n            Node runnerNode1 = firstNode; \n            Node runnerNode2 = firstNode; \n \n            for (int j = 0; j < n - 1; ++j) \n            { \n                runnerNode2 = runnerNode2.nextNode; \n            } \n            while (runnerNode2.nextNode != null) \n            { \n                runnerNode1 = runnerNode1.nextNode; \n                runnerNode2 = runnerNode2.nextNode; \n            } \n            return runnerNode1; \n        }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13730689","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"83","title":"With a linked list data structure, find if a given string is palindrome or not.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"1) Find the middle of the linked list using two pointers. 2) Reverse the linked list from the middle(second half). 3) Now two pointers, 1st one from start of list, 2nd one from middle of list.     Compare the list elements by moving pointers each time by one.     Check for palindrome property."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"1.find middle node(fast runner/slow runner method) 2.construct a stack of size n/2. 3.push elements till middle point is reached. 4.at n+1th element start popping and  compare with list. (handle suituation for even and odd number of elements)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Use two pointer strategy - advance one pointer twice as fast as the other pointer. Say you advance pointer 'i' at half the speed of pointer 'j'"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Method-1: Use Recursion  You need to compare the first and last node in the first loop and then compress the list    bool isPalindrome(Node* head) {    return isPalindromeRec(&head, head); }  bool isPalindromeRec(Node **l, Node *r) {    if (!r)      // terminating condition       return true;     // If the sublist is not palindrome then don't need to check further    if (! isPalindromeRec(l, r->link) )       return false;          bool flag = (r->data == (*l)->data);     *l = (*l)->link; // Move l forward     return flag; }     Method-2: Use reverse method      Move to the middle of the list.     Reverse the second half      compare the first and reversed second half one node at a time, if the are same return true else false.     Reverse the 2nd half again to get the original list.   Time Complexity: O(n) Extra Space used: O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"This can be optimized using a doubly linked list.  1. Traverse from head and tail at the same time from node to node and check if value is the same. (head ++ and tail --)  2. continue as long as head == tail or head > tail pointer.  3. If there was no change observed in the values as head and tail in each jump then its a palindrome, else its not."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Find the length of the list, and call the recursive function below."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"The below code uses two pointer strategy and checks for Palindrome Lists. It is also using C++ template mechanism to make it more general."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use stack (recursive function or explicitly)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* METHOD 1 (By reversing the list)     1.  Get the middle of the linked list.    2.  Reverse the second half of the linked list.    3.  Compare the first half and second half.    4.  Construct the original linked list by reversing the        second half again and attaching it back to the first half */   /* Program to check if a linked list is palindrome */ #include #include #define bool int   /* Link list node */ struct node {     char data;     struct node* next; };   void reverse(struct node**); bool compareLists(struct node*, struct node *);   /* Function to check if given linked list is   palindrome or not */ bool isPalindrome(struct node *head) {    struct node *slow_ptr = head;    struct node *fast_ptr = head;    struct node *second_half;    struct node *prev_of_slow_ptr = head;    char res;      if(head!=NULL)    {        /* Get the middle of the list. Move slow_ptr by 1          and fast_ptrr by 2, slow_ptr will have the |_n/2_|th          node */        while((fast_ptr->next)!=NULL &&                (fast_ptr->next->next)!=NULL)        {           fast_ptr = fast_ptr->next->next;              /*We need previous of the slow_ptr for            linked lists  with odd elements */           prev_of_slow_ptr = slow_ptr;           slow_ptr = slow_ptr->next;        }          /* Case where we have even no of elements */        if(fast_ptr->next != NULL)        {          second_half = slow_ptr->next;          reverse(&second_half);          slow_ptr->next = NULL;          res = compareLists(head, second_half);            /*construct the original list back*/          reverse(&second_half);          slow_ptr->next = second_half;        }          /* Case where we have odd no. of elements. Neither first           nor second list should have the middle element */        else        {           second_half = slow_ptr->next;           prev_of_slow_ptr->next = NULL;           reverse(&second_half);           res = compareLists(head, second_half);            /*construct the original list back*/          reverse(&second_half);          prev_of_slow_ptr->next = slow_ptr;          slow_ptr->next = second_half;        }          return res;    } }   /* Function to reverse the linked list  Note that this     function may change the head */ void reverse(struct node** head_ref) {     struct node* prev   = NULL;     struct node* current = *head_ref;     struct node* next;     while (current != NULL)     {         next  = current->next;         current->next = prev;         prev = current;         current = next;     }     *head_ref = prev; }   /* Function to check if two input lists have same data*/ int compareLists(struct node* head1, struct node *head2) {     struct node* temp1 = head1;     struct node* temp2 = head2;          while(temp1 && temp2)     {        if(temp1->data == temp2->data)        {           temp1 = temp1->next;           temp2 = temp2->next;        }        else return 0;     }       /* Both are empty reurn 1*/     if(temp1 == NULL && temp2 == NULL)        return 1;          /* Will reach here when one is NULL       and other is not */     return 0; }      /* Push a node to linked list. Note that this function   changes the head */ void push(struct node** head_ref, char new_data) {     /* allocate node */     struct node* new_node =             (struct node*) malloc(sizeof(struct node));       /* put in the data  */     new_node->data  = new_data;       /* link the old list off the new node */     new_node->next = (*head_ref);          /* move the head to pochar to the new node */     (*head_ref)    = new_node; }   /* Drier program to test above function*/ int main() {     /* Start with the empty list */     struct node* head = NULL;        push(&head, 'p');      push(&head, 'e');      push(&head, 'e');      push(&head, 'p');                      /* p->e->e->p */      if(isPalindrome(head) == 1)        printf(\"Linked list is Palindrome\");      else        printf(\"Linked list is not Palindrome\");               return 0; } //Time Complexity O(n) //Space Complexity: O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"reverse the linked list and compare with the original..O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use two pointers and a stack/array. One fast pointer moving two nodes a time and one slow pointer moving one node a time. Moving the two pointers at the same time. Before the faster pointer reaches the end, push the node pointed by the slow pointer to the stack. After the faster pointer reaches the end, pop the stack and compare it with the node pointed by the slow pointer. Only one time link list traversal is needed."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"while(1)     {          p=head;     q=head;                                           while(q!=NULL && q->next!=NULL )                {                r=q;                q=q->next;                }                         if(p==q || p== NULL || q==NULL)                {                       printf(\"palindrome\\n\");                            break;                                            }                                                if(p->value != q->value)                {                                                        printf(\"Not a palindrome\\n\");                            break;                }                                                    r->next=NULL;                           head=p->next;                     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"thanks Anonymous, liked the approach.. :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \nstruct lnode { \n    void *data; \n    struct lnode *next;   \n}; \n \nstruct lnode *newNode(void *data) { \n    struct lnode *node = (struct lnode *) malloc(sizeof(struct lnode)); \n    node->data = (char *) malloc(sizeof(strlen((char *)data)+1)); \n    node->next = NULL; \n    strcpy((char *)node->data, (char *)data); \n    return node; \n} \n \ntypedef struct { \n    struct lnode *top; \n} Stack; \n \nStack *newStack() { \n    Stack *s = (Stack *) malloc(sizeof(Stack)); \n    s->top = NULL; \n    return s; \n} \n \nvoid *pop(Stack *s) { \n    struct lnode *node; \n    void *data; \n     \n    if(s->top==NULL) \n        return NULL; \n     \n    node = s->top; \n    s->top = node->next; \n    data = node->data; \n    free(node); \n    return data; \n} \n \nvoid push(Stack *s, void *data) { \n    struct lnode *node = newNode(data); \n    node->next = s->top; \n    s->top = node; \n} \n \nint isPalindrome(struct lnode *ll) { \n    struct lnode *l2, *current; \n    Stack *s = newStack(); \n     \n    current = ll; \n    while(current) { \n        push(s, current); \n        current = current->next; \n    } \n     \n    current = l2 = pop(s); \n    while(current) { \n        current->next = pop(s); \n        current = current->next; \n    } \n     \n    while(ll!=NULL && l2!=NULL && strcmp((const char *)ll->data, (const char *)l2->data)==0) { \n        ll = ll->next; \n        l2 = l2->next; \n    } \n    return ll==NULL && l2==NULL; \n} \n \nint main() { \n    struct lnode *current, *ll = NULL; \n    char *words[] = {\"M\", \"A\", \"L\", \"A\", \"Y\", \"A\", \"L\", \"A\", \"M\"}; \n    int i; \n     \n    ll = current = newNode(words[0]); \n    for(i=1; i<9; i++) { \n        current->next = newNode(words[i]); \n        current = current->next; \n    } \n     \n    printf(\"String %s Palindrome\\n\", (isPalindrome(ll)) ? \"Is\" : \"Is not\"); \n     \n    return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@2 pointers' anonymous ..  gud approach !"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def test_symmetric (head): \n     helper(head, head) \n \ndef helper(curr, node): \n     if not curr: return node \n     if curr == helper(curr.next, node) \n     return node.next"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ptr1=head; ptr2=head; mark=0; while(ptr1!=NULL&&ptr2!=NULL) {  push(ptr1->data);//push to stack  ptr1=ptr1->next;//move the pointer to one step  ptr2=ptr2->next;//move ptr2 to 2 steps  if(ptr2!=NULL)  ptr2=ptr2->next  else mark=1;//if length of linked list is odd } if(mark==1)//means odd length pop(); ptr1=ptr1->next while(!stack_empty()&&ptr1!=NULL) {  compare(top_stack(),ptr1->data);  if(both r same)   pop(); else return GIVEN LL is NOT PALINDROME } if(stackis_empty())GIVEN LL is PALINDROME else GIVEN LL is NOT PALINDROME"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can't you just read the value of each linked list node into a string as you traverse? Then make a new string equal to the reverse of the original string (this is a string function) and compare. If a character is not the same, return false. This runs in O(n) + O(n) = O(n) time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we can do this by recursive call. fast pointer will be moving till the end of the list recursively and wen it reaches end thats when we start comparing the fast->data with the slow->data(where slow is in the beginning). we move slow pointer before recursive call is returned."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use 2 pointers fast and slow. when traversing slow should reverse the pointers. when fast reaches end slow reaches middle of list and all nodes before slow are reversed. now just compare reverse list with slow pointer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class LinkPalin { \n \n class MyBool { \n  public boolean val; \n \n  public MyBool() { \n  } \n } \n \n class Node { \n  public char ch; \n  public Node next; \n \n  public Node(char ch) { \n   this.ch = ch; \n  } \n \n  @Override \n  public String toString() { \n   return String.valueOf(ch); \n  } \n } \n \n Node head = null; \n int n = 0; \n \n public void add(char ch) { \n  Node newHead = new Node(ch); \n  newHead.next = head; \n  head = newHead; \n  n++; \n } \n \n public boolean isPalin() { \n  MyBool b = new MyBool(); \n  b.val = true; \n  palin(head, b, n / 2); \n  return b.val; \n } \n \n public Node palin(Node l, MyBool b, int depth) { \n  Node r = l.next; \n  if (depth > 1) \n   r = palin(r, b, depth - 1); \n  else if (depth == 1 && n % 2 == 1) \n   r = r.next; \n \n  b.val &= l.ch == r.ch; \n  return r.next; \n } \n \n public void print() { \n  System.out.print(n); \n  System.out.print(\": \"); \n \n  Node cur = head; \n  while (cur != null) { \n   System.out.print(cur.ch); \n   System.out.print(' '); \n   cur = cur.next; \n  } \n  System.out.println(); \n } \n \n public void test(MyBool b) { \n  b.val = false; \n } \n \n public static void main(String[] args) { \n  LinkPalin p = new LinkPalin(); \n  p.add('a'); \n  p.add('b'); \n  p.add('c'); \n  p.add('d'); \n  p.add('c'); \n  p.add('b'); \n  p.add('a'); \n \n  p.print(); \n  System.out.print(p.isPalin()); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have used Recursion to solve this prob: here back pointer will start from last node and temp will start fetching nodes from start.  Please go through the code, You can also exe it... its working...!  #include #include #include  struct nodetype {         int info;         struct nodetype *next;         }; typedef struct nodetype *node;  node createNode() {      node n;      n=(node)malloc(sizeof(struct nodetype));      return n;      }    void addNode(struct nodetype **head,int in) {      printf(\"1\");                 struct nodetype *temp,*add;      printf(\"2\");                                                                  if(*head==NULL)                  {                                      printf(\"3\");                  add=createNode();                           printf(\"4\");                        add->info=in;                       printf(\"5\");                  add->next=NULL;                        printf(\"6\");                  *head=add;                            printf(\"7\");                                              }                       else                  {                       temp=*head;                  while(temp->next!=NULL)                  {                  temp=temp->next;                  }                    add=createNode();                            add->info=in;                  add->next=NULL;                    temp->next=add;                                        } }  void showList(struct nodetype **head) {      node temp;      temp=*head;      if(*head==NULL)      {                     printf(\"List is empty\\n\");                    }      else      {                       while(temp!=NULL)                 {                                                   printf(\"\\nElement : %d\",temp->info);                    temp=temp->next;           }       } }  node checkPalindrome(struct nodetype **head,struct nodetype *back) { node temp;     if(back->next!=NULL)     {                         back=back->next;           temp=checkPalindrome(head,back);                       }          if(back->next==NULL)     {             temp=*head;                                    } if(back->info!=temp->info) {                      printf(\"\\n not \\n\");                            return temp; } temp=temp->next; return temp; }   int main() {   int ch,item;           struct nodetype *list=NULL;  do {                     printf(\"\\nPlease choose operation: \\n\");                        printf(\"1:ADD an item \\n\");                       printf(\"2:show the List \\n\");                       printf(\"3:check Palindrome \\n\");                       printf(\"0:Exit from Program \\n\");                       scanf(\"%d\",&ch);                     switch(ch)                                          {                               case 1:                                    {                                          printf(\"\\nEnter the item to add in List: \");                                          scanf(\"%d\",&item);                                          addNode(&list,item);                                          break;                                    }                               case 2:                                    {                                        printf(\"Element in List are :\\n\");                                           showList(&list);                                         break;                                                                              }                               case 3:                                    {                                         node res;                                         printf(\"\\n The List is\");                                          res=checkPalindrome(&list,list);                                         printf(\"Palindrome \\n\");                                          break;                                    }                               case 0:                                    {                                         printf(\"\\n Thanks for using this software\");                                            break;                                    }                     }   }while(ch!=0);    getch();  return 0; }  I have an Issue on this: how to stop and step out from recursion when required condition is met....?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Have a stack and a queue Traverse the linked list and add every node to stack and to queue Now, till the stack is empty, check pop()==dequeue() if there is a mismatch, say it is not a palindrome if stack gets empty, then it is a palindrome  Here is a sample code.. I have assumed this with a String. Just we have to traverse the linked list instead of String in this code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why not take this simple approach:  Step 1: Push the entire list in stack using a pointer ptr1. Step 2: Take another pointer ptr2 and start iterating this pointer 1 step at a time to front. Step 3: Start popping off the stack at the same time and compare the values (popped out value with the pointer's data) Step 4: If this Linked List is a palindrome then these values should always match."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int isPal(node *tmp) \n{ \n   static node *head = tmp; \n   static int result =2; \n \n   if(tmp->next) { \n        result = isPal(tmp->next); \n        if(!result) return 0; \n        if(result==1) return 1; \n   } \n \n   if(tmp->val == head->val) { \n      if( head == tmp || head->next == tmp) return 1; \n      head = head->next;  \n      return result; \n   } \n   else return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"just simply reverse the linked list ,it can be done in O(n) time. then compare each node which is also O(n) time. on the whole it takes O(2n),which is O(n) any way."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int checkpalindrome(struct node *root, struct node **left)    {       int ret;           if(root != NULL)       {          ret = checkpalindrome(root -> next, left);          if(root -> data != (*left) -> data)             return 0;          (*left) = (*left) -> next;          return ret;       }           return 1;    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int checkpalindrome(struct node *root, struct node **left)    {       int ret;           if(root != NULL)       {          ret = checkpalindrome(root -> next, left);          if(root -> data != (*left) -> data)             return 0;          (*left) = (*left) -> next;          return ret;       }           return 1;    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public boolean checkPalindrome(Node n) { char[] array = null; int index = 0 ;  while(n.next != null) { array[index] = n.val; index++; n = n.next; }  int i = 0 ; int j = array.length - 1;  int lengthofArray = 0 ;  while (i<=j)     {        if(array[i] ! = array[j])          return false;      else         {           if(arrayLength%2 != 0)             {                if(i == j-2)                     return true;                else                   {                   i++;                   j--;                   }     else {     if( i == j -1 )       {     return true;       }     else {       i++;       j--; } } return false; }          }  Here is how above code works 1. Build character array from linked list. 2. Start two pointers , one from the very first element of character array and other from end of the array. 3. Keep comparing corresponding elements. 4. return true if all the corresponding elements are equal , else return false."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Take two pointers, run second pointer twice as fast as first pointer. 2) when the fast pointer reaches the end of the list , the first pointer reaches the middle 3) calculate the sums of ascii values from start to mid and mid+ 1 to end 4) compare the two sums. if its same, that means its a palindrome.  Here is the code   int ispallindrome(LIST * node) { LIST *first,*second; first = node; second =node; while (second !=NULL){ first=first->next; second=second->next->next; }  //first pointer will point to the middle of the list LIST *trav; int sum=0,sum1=0; trav =node; while (trav!=first){ sum += trav->value; trav = trav->next; } //calculate the sum from mid+1 position till the end trav = first->next; while( trav!=NULL){ sum1 +=trav->value; trav=trav->next; }  if ( sum1 = sum) return 1; else return 0;  }  this algo takes O(n)time"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static boolean listPalindromeCheck(LinkedList list) \n    { \n        int sz = list.size()/2; \n        char[] arr1=new char[sz]; \n        ListIterator itr=list.listIterator(); \n        int i=0; \n        for (i=0;i0) \n            itr.next(); \n        for(--i;i>=0;--i) \n        { \n            if(arr1[i] != itr.next().charValue()) \n                return false; \n        } \n        return true; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.  Treat Linked List a Stack Data Type."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have used Recursion to solve this prob: here back pointer will start from last node and temp will start fetching nodes from start.  Please go through the code, You can also exe it... its working...!  #include #include #include  struct nodetype { int info; struct nodetype *next;  }; typedef struct nodetype *node;  node createNode() { node n; n=(node)malloc(sizeof(struct nodetype)); return n;  }  void addNode(struct nodetype **head,int in) { printf(\"1\");  struct nodetype *temp,*add; printf(\"2\");    if(*head==NULL) { printf(\"3\"); add=createNode();  printf(\"4\");  add->info=in; printf(\"5\"); add->next=NULL;  printf(\"6\"); *head=add;  printf(\"7\");  }  else { temp=*head; while(temp->next!=NULL) { temp=temp->next; }  add=createNode();  add->info=in; add->next=NULL;  temp->next=add;   } }  void showList(struct nodetype **head) { node temp; temp=*head; if(*head==NULL) { printf(\"List is empty\\n\");  } else {  while(temp!=NULL)  {  printf(\"\\nElement : %d\",temp->info);  temp=temp->next; } } }  node checkPalindrome(struct nodetype **head,struct nodetype *back) { node temp; if(back->next!=NULL) { back=back->next; temp=checkPalindrome(head,back);  }  if(back->next==NULL) { temp=*head;  } if(back->info!=temp->info) {  printf(\"\\n not \\n\");  return temp; } temp=temp->next; return temp; }  int main() { int ch,item;  struct nodetype *list=NULL;  do { printf(\"\\nPlease choose operation: \\n\");  printf(\"1:ADD an item \\n\");  printf(\"2:show the List \\n\");  printf(\"3:check Palindrome \\n\");  printf(\"0:Exit from Program \\n\");  scanf(\"%d\",&ch); switch(ch)  { case 1: { printf(\"\\nEnter the item to add in List: \"); scanf(\"%d\",&item); addNode(&list,item); break; } case 2: { printf(\"Element in List are :\\n\");  showList(&list); break;  } case 3: { node res; printf(\"\\n The List is\");  res=checkPalindrome(&list,list); printf(\"Palindrome \\n\");  break; } case 0: { printf(\"\\n Thanks for using this software\");  break; } }  }while(ch!=0);  getch(); return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Use the slow runner/fast runner technique. and use all the values slow runner is running through and add it to a stack. Also keep a counter to count the number of elements (Use the Fast runner to keep the count). 2)Follow this step only if the total count of the string is odd, else procedd to next step. Pop the first element in the stack. 3) Now use the slow runner and proceed one node to another. Compare the node's value with the last element popped. if they are same then proceed, else break."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int isPalindrome(struct node *head){ if(head->next == NULL){     return 1; } else {     int isp;     struct node *left=head->next;     struct node *right = head->next; isp = helperPalindrome(&left,right); return isp; } }  int helperPalindrome(struct node **left, struct node *right){ int hisp; if(right == NULL){ return 1; } else { hisp = helperPalindrome(left,right->next); if(hisp == 1){ if((*left)->data == right->data){ *left=(*left)->next; return 1; } else return 0; } return 0; } }  done in o(1) space and o(1) time"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What if we push the entire string into a stack and then pop it and see if the two strings are equal? What will be the time complexity of this approach?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. create a char pointer         char *ptr;  2. traver the linked list and keep adding element to ptr to form a string  eg. if our linked list is      c->a->t->a->c then do as *ptr = c; *(ptr+1) = a; *(ptr+2)=t; ... . . *(ptr+5)='\\0';  // ofcourse this would be a for loop                       //so *(ptr+i) till node!=NULL  3.   then again traverse linked list from starting and compare element from end of string .. eg.. compare 1st node with * (ptr+n-1) // (ptr+n) is '\\0'; .. compare 2nd node with * (ptr+n-2) .. compare 3rd node with * (ptr+n-3)  and so on...  time complexity O(n) space complexity o(1);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void pelindrome(node *h) {  node *p;  int *stack=NULL;  int n=0,i;  for(p=h;p!=NULL;p=p->next)  {   stack=(int *)realloc(stack,sizeof(int));   *(stack+n)=p->data;   n++;  }  i=n/2;  for(p=h;i>=0;p=p->next,i--)  {   if(p->data != *(stack+i))    break;  }   if(i  printf(\"it is not a pelindrome\");  else   printf(\"it is a pelindorme\");  for(i=0;i<25;i++)   printf(\"%d \",stack[i]); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* Interview questions  *   * Author : touzzie  * mailto:tousifmt87@gmail.com  */   #include  #include   #define TRUE  1 #define FALSE 0  typedef struct node {   char st;   struct node *link; }LIST_t;  typedef int BOOL;  LIST_t *head  = NULL,  *head2 = NULL; LIST_t *pCur  = NULL,  *pPrev = NULL;   /*   * This function accepts multiword string from user  * and maintain it in a linked list.  *   * Implements linked list as QUEUE  *   *  \\param  void  *  \\return void  *  */  void createString(void) {     char tmp;      printf(\"Enter the string(case sensitive) : \");     while((scanf(\"%c\",&tmp)) && (tmp != '\\n'))     {         pCur = (LIST_t *)malloc(sizeof(LIST_t));         pCur->st = tmp;           /* create first node */      if(NULL == head)      {            head = pCur;             pCur->link = NULL;             pPrev = pCur;         }         else         {             pPrev->link = pCur;             pPrev = pCur;             pCur->link = NULL;         }     }  }  #if 0 /*   * Display String  *   *  \\param  void  *  \\return void  *  */  void dispString(void) {     LIST_t *ptr = head;          printf(\"String  :  \");     while(ptr != NULL)     {         printf(\"%c\",ptr->st);         ptr = ptr->link;     }     printf(\"\\n\");  }  #endif   /*   * This funcion checks for palindrome  *   *  \\param  void  *  \\return BOOL indicates palindrome or NOT  *  */  BOOL checkPalindrome(void) {     LIST_t *slwptr = head, *fstptr = head;     LIST_t *ptr1 = NULL, *ptr2 = NULL;     BOOL bContinue = TRUE;      /*       * Find the middle of linked list by fast runner/slow runner method      * slwptr Points to (n/2) + 1 when loop exits      */      while((NULL != fstptr) && (FALSE != bContinue))     {        fstptr = fstptr->link;        if(fstptr != NULL)        {          fstptr = fstptr->link; /* Avoid chance of NULL pointer dereferencing */           slwptr = slwptr->link;                 }        else            bContinue = FALSE;          }      /*       * create another list of length (n/2) and copy items from       * the middle of existing one.       * Implements SECOND linked list as STACK      */        ptr2 = slwptr;      while(ptr2 != NULL)      {         pCur = (LIST_t *)malloc(sizeof(LIST_t));         pCur->st = ptr2->st;           /* create first node */      if(NULL == head2)             pCur->link = NULL;         else             pCur->link = pPrev;                 pPrev = pCur;            head2 = pCur;         ptr2 = ptr2->link;                }        ptr1 = head;       ptr2 = head2;       bContinue = TRUE; /* Reset flag here */        /* Check the two linked lists */       while((NULL != ptr1) && (NULL != ptr2))       {           if(ptr1->st != ptr2->st)           {               bContinue = FALSE;               break;           }           ptr1 = ptr1->link;           ptr2 = ptr2->link;       }        return bContinue;  }         int main(void) {     LIST_t *pCur = NULL, *pNext = NULL;     BOOL bCheck  = FALSE;      createString();    // dispString();     if(NULL != head)     {      bCheck = checkPalindrome();      if(bCheck)         printf(\"PALINDROME\\n\");      else            printf(\"NOT PALINDROME\\n\");             /* free allocated memory */      /* free LIST 1 */      pCur = head;      while(pCur != NULL)      {          pNext = pCur->link;          free(pCur);          pCur = pNext;           }       /* free LIST 2 */      pCur = head2;      while(pCur != NULL)      {           pNext = pCur->link;           free(pCur);           pCur = pNext;              }     }     else         printf(\"You entered NULL string\\n\");      return 0;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"->traverse input string from first to last element -> create two linked lists     1. one insert element at head     2. other insert element at tail  -> check whether both the list are same or not. -> if yes, palindrom else NOT!!!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"copy the contents of the original list in reverse order into another linked list using recursion...then match the node values of original list and the new reversed list by taking two pointers...first for original list and second pointer for second(reversed) list by moving both pointers simultaneously one- one step....if somewhere the node values doesn't match then return and display the msg not a pallindrome...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Palindrome { \n static LinkedList head=null; \n public static void main(String[] args) { \n   LinkedList list=LinkedListAddition.madelinkedList(); \n   head=list; \n   if(isPalindrome(list)) \n    System.out.println(\"It is Palindrome\"); \n   else \n    System.out.println(\"It is not a Palindrome\"); \n } \n \n private static boolean isPalindrome(LinkedList list){ \n       boolean ret=false; \n  if(list.link==null) \n  { \n   ret=list.data.equalsIgnoreCase(head.data); \n } \n  else{ \n   ret= isPalindrome(list.link) && list.data.equalsIgnoreCase(head.data); \n  } \n  head=head.link; \n  return ret; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Get the length of the link list. 2. Push the nodes of the list to stack from beginning till length/2. 3. Pop-up from stack & keep comparing till end of the list from length/2+1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  struct node {     char a;     struct node *link; }; void add(struct node**a,char ab) {     struct node *temp,*r;     temp=*a;      if(*a==NULL)     {         temp=malloc(sizeof(struct node));         temp->a=ab;         temp->link=NULL;         *a=temp;     }     else     {         temp=*a;         while(temp->link!=NULL)         {             temp=temp->link;         }         r=malloc(sizeof(struct node));         r->a=ab;         temp->link=r;         r->link=NULL;      } } void palindrome(struct node *a) {     struct node *temp,*mid;     int i,flag=0;     mid=a;     temp=a;     int count=0;     while(a!=NULL)     {         count++;         a=a->link;     }      int p=(count)/2;     for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.find the number of nodes in the node. 2.now design a function to get the kth element from end. 3.now compare kth element from start and kth element from end till middle is reached."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=12267020","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"85","title":"You are given two numbers in the form of linked list.Add them without reversing the linked lists. linked lists can be of any length. Ex:123 1->2->3 10234 1->0->2->3->4 ans: 10357  1->0->3->5->7","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"10","title":"Following code is tested. It handles the case where first list is longer than the second, or second is longer than the first as well as when they are of equal length."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"In interviews like that of Amazon, please don't expect the interviewer to give the expected complexity, etc. They want us to give an optimal solution. Gone are the days of merely solving problems. This is the time of scalability. So better make ur solutions how-much-ever optimal in the first go itself. My own experience with Amazon, I had high hopes, but they said, my problem solving skills are bad, though i gave all solutions. But not optimal ones."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"There could be multiple approaches. Two of them are listed below: Approach 1: Convert the linked lists to numbers. Add them. And then convert back the resultant number to a linked list. Approach 2: Take two stacks and push a linked list to a stack. After done pushing, simply start popping the stacks, add the numbers, get the carry over, generate another node with the result and add to front to a new linked list.  I prefer the second approach as this is less prone to errors while coding and faster when in-built library functions for stacks are used, although it takes memory with order of m+n where m and n are lengths of the linked lists."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"/*Solution Code to algorithm suggested by lanse.cse \n  1. reverse the lists.  \n  2. add them digit by digit and construct the result list.  \n  3. reverse the result list. \n NOTE: This code demonstrates the solution. The code will fail for invalid or no input and maybe other cases. Output for the following code : 9,1,3,1,3,8 \n*/ \n#include  \nusing namespace std; \n//! Node to store digits \nstruct Node{ \n short digit; //doesn't make a difference if I use short or int \n Node* next; \n}; \n//!Function reverses an input list \nvoid reverseList(Node*& head){ \n Node* curr = head; \n Node* nxt  = head->next; \n curr->next = NULL; \n while(true){ \n   head    = nxt; \n   if(head->next==NULL){ \n    head->next = curr; \n    break; \n   } \n   nxt    = nxt->next; \n   head->next = curr; \n   curr    = head; \n } \n} \n//! Function to compute the sum of two input lists. Complexity: O(m+n), sizes of lists m,n \nvoid sumOfLists(Node*& list1, Node*& list2, Node*& result){ \n // Reverse lists: Time: O( m + n). operating on input lists to save space complexity \n reverseList(list1); \n reverseList(list2); \n Node* ptr; \n ptr = new Node(); \n result = ptr; \n int n1=0,n2=0,sum=0,carry=0; \n bool n1flag=true,n2flag=true; \n while(n1flag || n2flag){ \n  n1= n1flag?list1->digit:0; \n  n2 = n2flag?list2->digit:0; \n  sum = n1+n2+carry; \n  carry = (sum>=10)?1:0; \n  ptr->digit = (sum-10*carry); \n  if(n1flag) \n   if(list1->next==NULL) \n    n1flag = false; \n   else \n    list1 = list1->next; \n   if(n2flag) \n   if(list2->next==NULL) \n     n2flag = false; \n   else \n    list2 = list2->next; \n  if(n1flag || n2flag){ \n   ptr->next = new Node(); \n   ptr = ptr->next; \n  }else \n   ptr->next = NULL; \n } \n reverseList(result); \n} \nvoid printListValues(Node*& list){ \n Node* ptr=list; \n do{ \n  cout<digit<<\",\"; \n  ptr = ptr->next; \n }while(ptr->next!=NULL); \n cout<digit<next = (i==sz-1)?NULL:(new Node); \n  newNd1->digit = myNum1[i]; \n  newNd1=newNd1->next; \n } \n newNd1 = new Node;num2 = newNd1; \n sz = sizeof(myNum2) / sizeof(int); \n for(int i=0;idigit = myNum2[i]; \n  newNd1->next = (i==sz-1)?NULL:(new Node); \n  newNd1=newNd1->next; \n } \n //Find sum \n sumOfLists(num1,num2,result); //. Result should be 913138 \n  printListValues(result); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"how abt this idea?  first we will fetch the lengths. then we will add 0's in the heads place of smaller linkedlist till the lingth of both becomes same..   lets assume linked list numbers are 999 and 999  the heads 99(this 9,9 are both the heads of two linked lists) will become 18. we will keep 18 . bein in the same place , we will calculate , the next's su, if there is carry , we will increment , the currnt  number.then we will move to next. will repeat the same while ->next != null."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hw abt using stack n push n pop n add"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have a feeling that the question is not complete. because here's a bruteforce O(n) solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"So can we just process the linked lists and get the number? I.e. multiply by 10 for each -> next. Or are we assuming the numbers are just too big to fit in a long?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I mentioned the pushing into stack answer. But interviewer was not happy.   How does reversing link list work?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"lets say the numbers are 1->2->3 and 1->2 \nAfter reversing the lists look like 3->2->1 and 2->1 \nNow add the two lists node by node and properly take care of the carry over of the addition of the nodes, if any. \nso, the resultant added list will look like 5->3->1 \nNow reverse the \"resultant added list\" to get the result of addition of two original lists. That is 1->3->5 is the actual answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Guys, there is some amount of repeated code. Any optimized version would be highly appreciated.. Please suggest any other better approach.. Time Complexity is O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about:   sum = atoi(list1) + atoi(list2) where atoi is modified version that operates on list of numbers. Then, itoa(sum), which ouputs as a list of numbers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is the following rephrase of th equestion correct (rephrased/introduced words in quotes):  You have two \"set\" of numbers represented by \"two\" linked lists, where each node contains a single digit. Write a function that adds the two numbers \"in the corresponding nodes\" and returns the sum as a \"third\" linked list"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"By reversing LinkList is very lengthy.  We have two Linklist A and B of length x and y(we can find length by simple traversing)  Now There may be three condition:(x=y,x>y,x_____________________________________________________________________________________          [1]:length of list A and length of List B are same (x=y):            In this case we can use simple recursion which will start from the end of list and proceed to front.recursive function will return carry digit(1 OR 0).  ********** +  ********** =  ********** NOTE: '*' can be any digit (0-9) ____________________________________________________________________________________          [2]:if length of List A is greater then length of list B(x>y):            In this case we will divide our bigger link list into two part (A1 and A2).First part(A1) will be of length (x-y) and second part(A2) will be of length (y). Now second part(A2) of List A and B are of same length (y).we can add it by simple recursion as we did in condition [1].After adding these two (A2 and B) we will append first part(A1) of list A if there is not carry digit in (A2+B).If there is any carry digit in (A2+B) we will apply recursion this time in first part(A1)of A and add one at the end of A1 and then appent the modified A'1 with (A2+B).We will get A'1(A2+B).The resultent sum.  *******************(x)             *******A1(x-y) ************A2(y) +                                +                 ************B(y)     **********(y)                                  =  *******A1(x-y) ************[A2+B](y) =  *****************(x)            =  *****************[A1][A2+B](x)  ___________________________________________________________________________________           [3]:if length of List A is lesser then length of list B(x             Same as condition [2] by replacing x with y.  Recursive Function:  int addTwoList(node *A,node *B) { int i=0;; if(A->link!=NULL) { A=A->link; B=B->link; i=addTwoList(node *A,node *B); } A->info=A->info+B->info+i;//assigning addition into A.(A=A+B). if(A->info>9) { i=1; } return i; }  __________________________________________________________________________________"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"*******A1(x-y) ************A2(y) + ---------------************B(y)  = *******A1(x-y) ************[A2+B](y) = *****************[A1][A2+B](x)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hello PKT  I feel a lil problem there!!! If u r adding the lists from end are u assuming them to be pointing to their prev. node?? Otherwise u need to use linked List reversal!!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simple solution. Complexity - O(n)  int carry = 0; while(nodenum1->next!=null or nodenum2->next!=null) {    addition = carry + nodenum1->data + nodenum2->data;    carry = (nodenum2->data)/ 10;    nodenum2->data = addition - (carry*10) }  reverse(nodenum2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"***Ignore the above solutions***  Simple solution. Complexity - O(n)  reverse(linkedlist_of_Num1) reverse(linkedlist_of_Num2)  int carry = 0; while(nodenum1->next!=null or nodenum2->next!=null) { addition = carry + nodenum1->data + nodenum2->data; carry = (nodenum2->data)/ 10; nodenum2->data = addition - (carry*10) }  //Copy the remaining elements of larger list in the nodenum2  //reverse the resultant reverse(nodenum2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why all you guys checking (nodenum1->next!=null or nodenum2->next!=null) only. What if both lists end but there is still carry to consider. Here is simple test case.  list1 contains single element 5 and list2 contains any element >5"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Guys Here is a solution without reversing the link lists  Time Complexity = O(n) Works for any length of linked lists"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Guys Here is a solution without reversing the link lists  Time Complexity = O(n) Works for any length of linked lists"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can perform this, by traversing the two lists and getting the two numbers. Then adding the two numbers through simple int addition and saving the result in another link list.   a. getting int while( a != NULL)   num = num*10 + a->value;  num_final = num1+num2  get digits of final and save it in another list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The following 'sum' method will return the requirement ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"let me try this... start parsing both the link list one node at a time.. to find out which is the largest one and what is the diff in the length.. suppose list1 1->2->3->4 and list2 5->3->4->6->9->2->1 given example L1=4 L2=7 and diff=3  create a function like below..   it can be passed to function  Node* add_node(Node *N1,Node *N2,size) { static int carry; int sum,remainder; Node *temp_node;  if(N1==NULL || N2==NULL) return NULL;  if(size<=diff) { size++; temp_node=(Node*)malloc(sideof(Node*)); temp_node->next=add_node(N1,N2->next,size); sum=N2->value+carry; } else  { size++; temp_node=(Node*)malloc(sideof(Node*)); temp_node->next=add_node(N1->next,N2->next,size); sum=N1->value+N2->value+carry; }  carry=sum/10; remainder=sum%10;  temp_node->value=remainder; return temp_node; }  tere might more exception handling and we need to take care.. but this is my over all idea.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"typedef struct list_t{  \n int x; \n struct list_t* next; \n } list_t; \n  \n     \n// add two lists and return a list \nlist_t* add(list_t* A, list_t *B){   \n int s; \n list_t* least=NULL; //pointer to the sum list least impotant digit \n list_t* most=NULL; //pointer to the sum list most impotant digit \n list_t* tmp=NULL;  \n                 \n // while there are 2 digits, add them \n while( A != NULL && B != NULL){ \n  s = A->x + B->x;            \n  // initialize sum list \n  tmp = malloc(sizeof(list_t)); \n  if(least == NULL){ \n   least = most = tmp; \n  } \n  // add either 1 or 2 digits \n  if(s<9){ \n   tmp->x = s; \n   tmp->next = NULL; \n   most->next=tmp; \n   most=tmp; \n     } \n  else{ \n   tmp->x = s -10; \n   tmp->next = malloc(sizeof(list_t)); \n   tmp->next->x = 1; \n   tmp->next->next=NULL; \n   most->next=tmp; \n   most=tmp->next;    \n  }          \n  A=A->next;      \n  B=B->next; \n }                \n while( A != NULL ){  \n  most->next=malloc(sizeof(list_t)); \n  most->next->x = A->x; \n  A = A->next;          \n  most = most->next;   \n } \n while( B != NULL ){  \n  most->next=malloc(sizeof(list_t)); \n  most->next->x = A->x; \n  B = B->next;          \n  most = most->next;   \n } \n return least; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"LinkedList ll = new LinkedList(); \nll.add(9); \nll.add(9); \nll.add(9); \nLinkedList ll1 = new LinkedList(); \nll1.add(9); \nll1.add(9); \nll1.add(9); \nll1.add(5); \nint num1 = 0; \nint num2 = 0; \nfor(int i =ll1.size()-1 ; i>=0;i-- ){ \n int temp = ll1.get(i); \n for(int j =0;j=0;i-- ){ \n  int temp = ll1.get(i); \n  for(int j =0;j"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int FormNumber( Node *n ) \n{ \n        if( n == NULL ) \n                return 0; \n        static int sum = 0 , i =0; \n        FormNumber( n->next ); \n        sum = sum + (n->data)* pow( 10 , i ); \n        i++; \n        return sum; \n} \n \n \n \nint Add( Node *h1 , Node *h2 ) \n{ \n \n        return FormNumber(h1) + FormNumber(h2 ); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int FormNumber( Node *n ) {         if( n == NULL )                 return 0;         static int sum = 0 , i =0;         FormNumber( n->next );         sum = sum + (n->data)* pow( 10 , i );         i++;         return sum; }    int Add( Node *h1 , Node *h2 ) {          return FormNumber(h1) + FormNumber(h2 ); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// Sum 2 lists \nstruct node* sum2LL(struct node* head1, struct node* head2) \n{ \n struct node* head = NULL; \n struct node* headcopy = head1; \n int carry = 0, sum = 0; \n  \n if(head1 == NULL && head2 == NULL) \n  return NULL; \n else if(head1 == NULL && head2 != NULL) \n  return head2; \n else if(head1 != NULL && head2 == NULL) \n  return head1; \n else \n { \n  // Both list have elements \n  while(head1 != NULL && head2 != NULL) \n  { \n   printf(\"head1->data : %d head2->data : %d Carry : %d\\n\", head1->data, head2->data, carry); \n   sum = head1->data + head2->data + carry; \n   if(sum > 9) \n   { \n    carry = (sum % 10) + 1 ; \n    printf(\"Sum : %d Carry : %d\\n\", sum, carry); \n    sum = sum - carry; \n   }else \n    carry = 0; \n   printf(\"Sum : %d Carry : %d\\n\", sum, carry); \n    \n   // First node \n   if(headcopy == head1) \n    head = createNode(sum); \n   else \n    addTail(&head, sum); \n    \n   head1 = head1->next; \n   head2 = head2->next; \n  } \n   \n  // Both of them are empty \n  if(head1 == NULL && head2 == NULL) \n  { \n   if(carry == 0) \n    return head; \n   else \n   { \n    addTail(&head, carry); \n    return head; \n   } \n  } \n  //Only Head1 is empty \n  else if(head1 == NULL && head2 != NULL) \n  { \n   if(carry == 0) \n   { \n    struct node* tail = findTail(head); \n    tail->next = head2; \n   } \n   else \n   { \n    while(head2 != NULL) \n    { \n     sum = head2->data + carry; \n     if(sum > 9) \n     { \n      carry = (sum % 10) + 1 ; \n      sum = sum - carry; \n     } \n     else  \n      carry = 0; \n      \n     addTail(&head, sum); \n      \n     head2 = head2->next; \n    } \n   } \n   return head; \n  } \n  // Only head2 is NULL \n  else if(head1 != NULL && head2 == NULL) \n  { \n   if(carry == 0) \n   { \n    struct node* tail = findTail(head); \n    tail->next = head1; \n   } \n   else \n   { \n    while(head1 != NULL) \n    { \n     sum = head1->data + carry; \n     if(sum > 9) \n     { \n      carry = (sum % 10) + 1 ; \n      sum = sum - carry; \n     } \n     else  \n      carry = 0; \n      \n     addTail(&head, sum); \n      \n     head1 = head1->next; \n    } \n   } \n   return head; \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hope this solution will also work. step 1: Calculate the length of both LinkList , say L1 and L2 step 2: Calculate the difference d, and find out which is longer. step 3: Traverse the longer List for 'd' number of nodes. step 4: Now start adding the nodes value of both LinkList and keep the Sum in longer List L1. step 5: This way longer List L1 will have the its own starting number and Sum of each digit. step 6: Finally create a function which have 'carry' as Static variable and traverse from end of a linklist using recursion. Use mod function to get the 'carry' part of each node starting from the end. And add this carry to previous node(in recursion). this way carry will propagate in backward direction. step 7: If the carry still have some value when we come to first node then create a new node and add to the starting of the Linklist.  What say Guys..?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"reverse both the list, soppose l1 = 1->2->9 and l2= 8->9 so l1 = 9->2->1 and l2 = 9-> 8 add the first elements of both list 9 + 9 = 18 put it in the stack add second element until all the elements are empty and put it in the queue so queue become 18, 10,1 then dequeue up element if greater than 10, then remove 10 and add 1 for the next element so it become 8, (10+1) = 11-10 =1 , 1+1 = 2 and then put it a new list become 8->1->2 now reverse the list = 2->1->8  hope this is clear"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"With the reversing->adding->reversing we need 5 iterations (i.e., revering two list, adding two list and reversing the resultant list).   Instead why not add the lists in the forward direction creating add-list and carry-list, then add the add-list and carry-list to get the final list. (Note: we need to iterate both the list to find the respective lengths first).  lets try this way Sum: 9999 + 9999 Add-list is 088888 and the carry list is 111110 and adding this list will give us 199998.  Complicity is 4 iterations (2 iterations to identify the length of the lists and 2 iterations for adding)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's my tail recursive version, which doesn't require first finding the lengths, first reversing, converting the lists to numbers, or using additional data structures such as Stack etc. It won't handle the case of overflow, so I might be solving an easier version of this problem.  The approach is to use 2 additional parameters (num & num2) to keep track of the current values we have seen for both lists. Code should be self-explanatory enough..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int addLists (node* list1, node* list2) { int add1=0, add2=0, final=0; while (list1->next != NULL && list2->next!= NULL) {      add1 = add1*10 + list1->value;    add2 = add2*10 + list2 -> value;    if(list1->next != NULL) list1 = list1->next;    else final += add1;    if(list2->next != NULL) list2 = list2->next;    else final += add2; }  return final; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This problem can be solved using stack. Step1: Insert all the elements in the list1 into a stack say s1 Step2: Insert all the elements in the list2 into a stack say s2 Step3:  int val1,val2,carry=0; while(!s1.empty() || !s2.empty()) { val1=0; val2=0; if(!s1.empty()) {  val1=s1.top(); s1.pop(); } if(!s2.empty()) {  val2=s2.top(); s2.pop(); } if(val1+val2+carry> 10) { carry=1;  insertintoll((val1+val2+carry)-10); } else { carry=0;  insertintoll((val1+val2+carry)); } }  Note: insertintoll() function inserts the value to the front of the new linked list"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My Generation"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This comment has been deleted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"// Find the difference between the given linked list  // assuming its d(suppose 1st linked list is  larger) Node * temp1 = first1;// For first Linked List Node *temp2 = first 2 ;//For second Linked List for (int i = 0; i< d; i++) temp1 = temp->next; // Now start adding  data and keep it in single Node from the left to right side  while( Temp1 != null) {temp1->data += temp2->data;  temp1= temp1->next; temp2 = temp2 -> next; } //Now start from first node of  first list  and check if any node data is  greater than 10 then just add 1 to the left node of  this node and subtract 10  from that.Repeat till  all  the  data  of  linked list is less than 10 //boundary condition if first data i s  greater than 10 we  need  to  create  a  separate node  and link  it  to first and  make  this  node  as  first  while (true) { int flag = false; if (first->data > 10)     {      // create new node         Node newnode  = malloc (sizeof(node))        newnode->data = 1;          first->data -= 10;         newnode->next = first;      first = newnode;  flag = true; }    temp1= first; temp2 = first->next; while(temp2 != null) { if(temp2->data >= 10) { temp2->data = temp2->data-10; temp->data = temp1->data+1; temp1= temp1->next; temp2=temp2->next; flag = true; } if(flag == false) break; }     }            {   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"How about starting at the head of the list and pushing the numbers in a stack as we read them. When end of list reached, pop out numbers from the stack and multiple them with increasing powers of 10 and keep adding them to the result."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Set old number as 0, new data from link list Now multiply old number with 10 and add link list number. while(linklist->next != null) Sum = old number* 10 + link list number old number = sum }  Answer is Sum  traver"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"if the question means it should be finished in one pass(no turning back), I think the point is how to take care of '9', if it's 1999, you should keep all the four digits and when the summation of next digit is 10, your current result should be be 20000.  In my opinion, after determine which list is longer and their length difference, we can keep add corresponding digits one by one from the front to rear. In the procedure, we can use a Queue to store the node pointer of all the previous nodes we need to keep tracking. If the current digit is not 9, we can give up all the previous tracked nodes in the Queue. The rule: If current->value==9: Queue.enqueue(9) if current->value>9: while(!Queue.isEmpty): Queue.dequeue()->value+1 //add more necessary code to take care of carry                                  Queue.enqueue(current->value%10) if current->value<9: while(!Queue.isEmpty): Queue.dequeue()                                  Queue.enqueue(current->value)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"List add (List l1,List l2){ List l3 =new List(); if(l1 == Null && l2 == Null){ l3=null; } while(l1.next != Null && l2.next!= null){ l3.data = l1.data+ l2.data; l3= l3.next; } if(l1.next){ l3.data = l1.data; l3.next = l1.next; } else{ l3.data = l2.data; l3.next = l2.next; }  return l3;  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14952616","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"66","title":"Given two singly linked list, find if they are intersecting. Do this in single iteration. Also find the intersecting node in O(n) time and O(1) space. By intersection I mean intersection by reference not by value","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"14","title":"here we have to parts ... 1)Given two singly linked list, find if they are intersecting. Do this in single iteration.      a) traverse list1 and find the last element      b) traverse list2 and find the last element      c) check if last element of list1 == last element of list2 , if equal intersecting else not    here we have parsed the list only once :-)  2) Also find the intersecting node in O(n) time and O(1) space      here they have asked to do it in O(1) space so we need to use only one variable :-)   a) create a variable(int) diff=0   b) parse list1 and increment diff for each node   c) parse list2 and decrement diff for each node   d)if diff is >  0 list1 is bigger so push the pointer of list1 by diff times      else list2 is bigger so push the pointer of list2 by mod(diff) times   e)Now check if both the pointers are equal till we reach end"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Count size of List A, B  If one list is larger than the other, move the root of the larger list until the remaining nodes are the same.  Now, while each list.next != null, compare RootA.Next with RootB.Next. If they are equal, return true, else move RootA = RootA.Next, RootB = RootB.Next"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"findIntersectoin(node *p, node *q) {  int d1=0,d2=0;  node* x=p;  while(x)  {   d1++;   x=x.next;  }  x=q;  while(x)  {   d2++;   x=x.next;  }  int d;  if(d1>d2)  {    d=d1-d2;   while(d>0)    p=p.next;     }  else  {   d=d2-d1;   while(d>0)    q=q.next;  }  while(p && q)  {   if(p.data==q.data)    return p;   p=p.next;   q=q.next;  }  return null; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hi,  I assume that it is a single linked list. Now If the two list is intersecting then they will have the single tail. so just go to boths tail and compare it.  How to find the point of interesection.  1) Find the length of both the list. let us say M and N. 2) now let us say M is bigger one. then find out the difference. d=M-N. 3) mow move d pointer on the bigger list.    now onward both this list has same length and they are going to merge also. So just move one node on both the list and compare nodes value. It will give u the node u are looking for.  thanks, DD>"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just to update, keep on moving one node at a time and keep on comparing it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hey can two linked lists intersect? Two nodes wont have the same memory rite??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"THANKX :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Destructive solution:  [1] Scan one list, say listA and point every node until end, listA(1..n)->next to a special node called nodeIntersect.  [2] Now scan listB and see if currentNode->next==nodeIntersect. If so, currentNode of listB is the intersection point  Much less destrcutive, requiring additional space:  [1] Scan listA and add the nodes (the pointer) to a hashtable [2] Scab listB and if any of the pointer is same in hashtable, that pointer (or the node) is the point of intersection  There must be a better solution though. I am not aware of one right now."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"just move till end on both the lists. compare the addresses of the last node. O(m+n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why is everyone assumming it's Y-shaped ? The question asks for intersection, not merging. And in that case, it could be X-shaped too."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"two link list A and B..if we can modify link list then it will become quite easy task add flag value to each node and when we traverse link list A then make flag =1 and second time when we traverse link list B if we already find flag =1 then that will be interaction point  correct me if wrong"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Lets call the  two lists a and b.Reverse the two lists.Continue iterating through list until a!=b.If the two lists are entirely different and they dont intersect then the return value would be false.  while(a==b){   commonNode = a;   a=a->next;   b=b->next;   count++; }  if(a!=b && count==0){ return false; }  else{   cout<<\"List intersects at \"<data;   return true; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node *temp, *prev; temp = list_a.head; while(temp != NULL) {  stack_a.push(temp);  temp = temp->next; } temp = list_b.head; while(temp != NULL) {  stack_b.push(temp)  temp = temp->next; } prev = NULL; temp = stack_a.pop(); while(temp == stack_b.pop()) {  prev = temp; } return(prev);  Pls correct me if I'm wrong."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"please factor in the presence of cycles too which could throw codes into infinite loops"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Say the input lists are A and B and 6 is the intersection node. Then the list looks like as below.  A==>  1->2->3->4->5->6->7->8->9->10->NULL B==> 15->13->12->11->6->7->8->9->10->NULL  Now if you will reverse the list B then the whole list architecture will looks like as below  A==>  1-->2-->3-->4-->5-->6<--7<--8<--9<--10 <==B         NULL<--15<--13<--12<--11<--6<--7<--8<--9<--10 <==B  Now if you will try to travers list A you will get something like below  A_New==> 1-->2-->3-->4-->5-->6-->11-->12-->13-->15-->NULL  So in this A_New list, if the last node will be the same of the first node of original B list (node value 15) then we can say that there is a intersection in between list A and list B.  ================================================================================  How to find the intersection node ?  say the length of list A is x, list B is y and list A_New is z. And say the length of common part of list A and B is k. (i.e k is the length from intersection node to last node).  Now we can say,  (x-k) + (y-k) = z or, k = (x+y-z)/2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Make two stacks, one while traversing each list. Then, compare the top two elements. If they're not the same, the lists do not intersect. If they are, keep popping off both stacks until they're no longer the same. The last node that was the same on both stacks is the intersecting node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* I m returning NULL for no common node and  next  node of *head1 or *head2  if common */ struct node  findcommon_node(struct node *head1,struct node *head2) {  if(*head1==NUL L&& *head2==NULL)  return NULL;  while(*head1!=NULL && *head2!=NULL)  {   if(*head1->next  != *head2->next)   {    Head1=head1->next;    Head2=head2->next; } elseif(*head1->next !=NULL  &&  *head2->next !=NULL) return *head1->next ; return NULL; } return NULL; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"disregard previous one"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If you want to do in a single scan you need to use stack. As you know 2 stack, you can use reccurssion [ correct me if I am worng ]. Following is the C++ version of the algo : Node* intersectionPoint( Node* L1, Node* L2) {      if( (L1 == NULL) || ( L2 == NULL))                return NULL;         Stack* stack1 = new Stack;      Stack* stack2 = new Stack;      while( (L1 != NULL) || (L2 != NULL) )   {   if( L1 != NULL )   {    stack1->push(L1);    L1 = L1->next;   }   if( L2 != NULL )   {       stack2->push(L2);    L2 = L2->next;   }      }   Node* node1, node2, prev = NULL;   while( !stack1->empty() && !stack2->empty())   {   node1 = stack1->pop();   node2 = stack2->pop();      if( node1 == node2 )   {    prev = node1; // you can keep node2 also   }   else    return prev;        }  return prev; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) To find if the lists intersects scan each one till last element. If last element of list1 equals last element of list2 then they intersect. Solution involves one scan of each list.  2) To find the intersection in O(n) and O(1) I would do the following: a) Count number of elements in each list. This can be done in O(n1+n2).  b) Traverse list#1 and while doing so - reverse it, i.e. each node now points to the previous node instead of next node. This can be done in O(n1). c) Traverse list #2. What will happen is that once it will reach the intersection it will not \"continue\" to the shared nodes but will \" go back\" to the beginning of list #1. This can be done in O(n1+n2). Count the number of elements encountered in this scan. Refer to it as n2*  Suppose list #1 has 100 independent nodes and 20 shared nodes. and suppose list #2 has 5 independent nodes and 20 shared nodes.  The values of n1, n2 and n2* in this case will be: n1 = 120 [ = 100 + 20] n2 = 25 [ = 5 + 20 ] n2' = 5 (the independent nodes) + 1 (the intersection) + 100 (the independent nodes of list 1)  What we're looking for is the number of shared nodes. We'll get this by calculating: (n1 + n2 - n2* -1) / 2 =  ((20 + 100) + (5 + 20) - (5 + 100 + 1) - 1) / 2 = (20 + 20) / 2 = 20  All we have to do now is to start again from the last node and go back 20 nodes. This will be the intersecting node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I hope you asked if the lists can be circular."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the question is not clear. Intersection does not mean inclusion. According to the question it does not have to be in \"Y\" shape it can be \">===<\" shape. E.g. list1 = [1,2,3,4] and list2 = [0,5,2,3,6,7] so [2,3] is the intersected part and neither they end with the same node nor they start with the diff. And in this case no one can solve the problem with O(n) time and O(1) space complexity. You need to give more constraints."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Count the number of elements in two lists. Take the difference of count. Traverse in longer list till the difference count. Start traversing both lists & check for common address"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int main() {      set < char >  set0;      cin >> s ;     cin >> t ;      cout << s << \" \" << t << endl;          for (int i=0; i        set0.insert(s[i]);     }     for (i=0; i        if (set0.find(t[i]) != set0.end())         {             cout << t[i] << endl;         }     }        return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if ( (t1->next == NULL ) || (t2->next == NULL ) )    return false;  while (t1->next != t2->next ) {    t1 = t1->next      t2 = t2->next } if ( (t1->next == NULL ) && (t2->next == NULL ) )    return false; else    return true"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If two singly linked lists are intersecting, the last nodes have to be the same. Just check the last nodes of both lists, you are done!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if(head1 == NULL || head2 == NULL) \n return NULL; \n \nwhile(true) \n{ \n if(head1 == head2) \n  return head1; \n  \n //reached end of both list \n if(head1->next == NULL && head2->next == NULL) \n  return NULL; \n   \n if(head1->next != NULL) \n  head1 = head1->next; \n  \n if(head2->next != NULL) \n  head2 = head2->next; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You could temporarily make one list a circular list and then do cycle detection on the other using either the tortoise and hare or Brent's algorithm. I don't see how it can be done in one iteration with constant space, unless each node already has e.g. a \"visited\" property but that is neither mentioned nor standard."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Make first list circular by connecting last->next = first, also remember first and last node and also remember total nodes in first list. \n2. Now iterate through second list and at iteration check whether last and first are matched. If at any point true then lists have an intersection point. Now this solves the problem in single iteration. \n3. Now problem is finding loop start point in second list. This is traditinal problem. \n4. After that remove loop from first list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"boolean intersect(Node head1 , Node head2){ \n Node current1 = head1; \n Node current2 = head2; \n while (current1.next != null) \n  current1 = current1.next; \n while (current2.next != null) \n  current2 = current2.next; \n return (current1 == current2); \n} \n \nNode intersect(Node head1 , Node head2){ \n Node current1 = head1; \n Node current2 = head2; \n int d1 , d2; \n while (current1 != null){ \n  current1 = current1.next; \n  d1++;  \n } \n while (current2 != null){ \n  current2 = current2.next; \n  d2++; \n } \n current2 = head2; \n current1 = head1; \n while (d2 > d1){ \n  current2 = current2.next; \n  d2--; \n } \n while (d1 > d2){ \n  current1 = current1.next; \n  d1--; \n } \n while (current1 != null && current2 != null && current1 != current2){ \n  current1 = current1.next; \n  current2 = current2.next; \n } \n return current1; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{{ bool check(node *head, node *head1) { if(head == NULL && head1==NULL) return false; else if(head == NULL || head1==NULL) return false; else {  while(head->next !=head1->next)     {     if(head->next ==NULL || head1->next==NULL) return false;         else { head=head->next;                     head1=head1->next;                 }     } return true; } }  }}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=8398850","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"48","title":"There is a doubly linked list with next pointer and arbitrary pointer( points to an arbitrary node in list). You have to make a copy of the linked list and return. In the end original list shouldn't be modified. Best time O(n).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"I am not quite understand the answer above but based on the same idea of using just a O(1) space the solution could be following: 1)[Merge listst]Create list B this way: for each NodeA in A create a NodeB in B , copy NEXT ptr to NodeB: NodeB{NEXT} = NodeA{NEXT} and change NEXT ptr in NodeA to this newly created node in B: NodeA{NEXT}=NodeB;  2) go through the list A (NB: you have to jump through the nodes of B!) and set NEXTRND ptr in next B nodes to the next ptrs after next_random nodes: NodeA{NEXT}{NEXTRND}=NodeA{NEXTRNF}{NEXT};  After that all NEXTRND nodes in list B will be pointing to correct nodes in B; 3) [Un-merge]. For each node in A and in NEXT node B set correct NEXT ptrs: node=headA;  while(node){tmp = node{NEXT}; node{NEXT}=tmp?tmp{NEXT}:NULL; node=tmp;} After this process all {NEXT} nodes in both lists A and B will be correct"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It seems that nobody replies. Just throw my idea on the table.   Assume the node has two pointers, one is called next, the other is called randomnext.  Go through the list by using \"next\", create a hashmap A with (Node -> serial number(1,2,3,...)). Go through the list again to create another hashmap(list) B with (serial number -> the randomnext's serial number) by the aid of A.  duplicate the list by using \"next\" and create the hasmap C with (serial number -> Node). Go through the newly created list again, use the current position (serial number) to check the hashmap(list) B to find out the position of the randomnext's serial number. Use the hashmap C to find out the node. Link the randomnext node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think only one hash map is enough. During first traversal on list, create a haspmap with oldpointer to new pointer. Now traverse the original list again and and link the newrandom pointer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the approach with single traversal and single hashtable:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"B: add a couple of lines explaining the flow of your algo/logic. :-)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Anonymous on October 08, 2009: B'coz we're not as retarded as you are. Your moron !  If your understand why d0nt you explain, you scruffy crappy idiot."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"are you sure we know which pointer points to next node and which points to random node? What if they're just two pointers and you cant tell who is pointing the next node and the random node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There is no need to create hashmap. let the two lists be A and B.  while copying a node nb in B from node na in A, change the random pointer of na to na->rand^nb. Also copy the original data and random pointer of na in node nb.  After copying all the nodes, again traverse two lists and this time,  nb->rand = nb->rand^na->rand = node in list b to which nb should point.  A third pass will be needed to restore the original random pointers in A. na->rand = na->rand^nb^nb = na->rand;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"typo: NodeA{NEXTRNF}{NEXT}; -> NodeA{NEXTRND}{NEXT}; NB: NodeA{NEXT} - is a node in B list!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"though looks complex initially its simple one....  A: Original List B: Copy List  First pass: make a copy of linked list using next ptr of A. With this..  B will have every next ptr perfectly placed.  While copying each node, make nodeA->next = nodeB; and NodeB->random=nodeA;  Second Pass:  Traverse B and make nodeB->random = nodeB->random->random->next;  Done; Correct me if something is wrong."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"you will need some kind of hash map to remember where ->random points. Also ->random in list A and B are different."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is an O(n) solution , but yeah it takes 2 hash map.   First, traverse through list A , while traversing store in hash map_A the  and copy this node to the new linked list.   when creating new linked list , store the index and the address_new in another hash map_B .    So at the end of the pass one, we have two hash maps and two list. New list does not have the random pointers.   In second pass, traverse through the first list for every random pointer address get the index of the pointer from map_A and get the corresponding new address for that index from map_B and point the random pointer of the list B to this address.  So totally in two pass we have the linked list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why not this:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Go over the original list following next links and create the new list. (new list will contain only the next pointers for now) Meanwhile put the new nodes in a hash map. (the key is the address of the old node and the value is the address of new node) 2. In the second scan, go over both lists in parallel. For each arbitrary pointer in the original list, fetch the address of corresponding node from hashmap."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it's a graph so, you can copy it DFS style marking the nodes with a 'visited' marker. Complexity O(|V|+|E|)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can you elaborate more on your graph method?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Following method should work with O(n) complexity and no extra space.  Original List a1->b1->c1->d1->e1  Let Random pointers of original list be a1->c1, b1->d1, c1->a1, d1->c1, e1->e1  Start traversing the original list, while traversing create new nodes as well.  When u do that, do one more thing, point the random pointer of the original node to the newly created node, and point the random pointer of this newly created node to the node which was pointed by random pointer of the original node.  After performing the above action   Original List a1->b1->c1->d1->e1  Random pointers of original list  a1->a2, b1->b2, c1->c2, d1->d2, e1->e1                 New list      a2->b2->c2->d2->e2  Random pointers of new list: a2->c1, b2->d1, c2->a1, d2->c1, e2->e1  Now traverse both the lists again simultaneously  since a1->a2, a2->c1 and c1->c2  (perform actions on random pointers)=> a1->c1, a2->c2 b1->b2, b2->d1 and d1->d2   (perform actions on random pointers)=> b1->d1, b2->d2  c1->c2, c2->a1 and a1->a1   (perform actions on random pointers)=> c1->a1, c2->a2   thus new similar list is formed"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"could anyone explain the question? how does it mean?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"tech-queries.blogspot.com/ 2011/04/copy-linked-list-with-next-and-random.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"create the copy of 1 and insert between 1 & 2, create the copy of 2 and insert between 2 & 3.. continue in this fashion add the copy of N to Nth node  Now copy the arbitrary link in this fashion Original->next->arbitrary = Original->arbitrary->next; TRAVERSE TWO NODES;  This works because original->next is nothing but copy of original and Original->arbitrary->next is nothing but copy of arbitrary.  now restore the Original and copy linked lists in this fashion in a single loop. Original->next = Original->next->next; copy->next = copy->next->next;  Make sure that last element of original->next is NULL."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct node *clone(struct node *head) {        HasMap  h=new HashMap();         for(current1=head;current1;current=current->next)        {              temp=malloc(sizeof(struct node));              h.put(current,temp);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct node *clone(struct node *head) {     HasMap h=new HashMap();     struct node *current1,current2,*prev=NULL,*head2;     for(current1=head;current1;current1=current1->next)     {        temp=malloc(sizeof(struct node));        temp->data=current->data;        if(prev==NULL)        {              head2=temp;        }        else        {            prev->next=temp;        }        h.put(current1,temp);        prev=temp;        h.put(current,temp);     }     for(current1=head,current2=head2;current1;current1=current1->next)     {             current.ptr=h.get(current.ptr);     }     return head2; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// arbitrary pointer linked list :) // code have the complexity equals O(n) struct node *createCopy(struct node *L) { struct node *temp,*temp1,*head; if(L==NULL) return NULL; temp=L; while(temp!=NULL) { if(!head) { head=(struct node*)malloc(sizeof(struct node)); temp1=head; temp1->next=temp->next; temp->next=temp1; temp=temp1->next; } temp1=(struct node*)malloc(sizeof(struct node)); temp1->next=temp->next; temp->next=temp1; temp=temp1->next; }  for(temp=L;temp!=NULL;temp=temp->next->next) { temp->next->arbit=temp; } temp=L; while(temp!=NULL) { temp->next->arbit=temp->arbit->next; temp1=temp->next; temp->next=temp->next->next; temp->next=temp->next->next; temp=temp->next; }  return head;    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Create the copy of node 1 and insert it between node 1 & node 2 in original Linked List, create the copy of 2 and insert it between 2 & 3.. Continue in this fashion, add the copy of N afte the Nth node 2) Now copy the arbitrary link in this fashion       original->next->arbitrary = original->arbitrary->next;  /*TRAVERSE TWO NODES*/  This works because original->next is nothing but copy of original and Original->arbitrary->next is nothing but copy of arbitrary. 3) Now restore the original and copy linked lists in this fashion in a single loop.       original->next = original->next->next;      copy->next = copy->next->next;  4) Make sure that last element of original->next is NULL.  Time Complexity: O(n) Auxiliary Space: O(1)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13556672","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"46","title":"Q3. Written Exam Amazon(Bangalore)  Given a singly linked list which may or may not contain loop and loop may or may not start from the head node. Count the number of elements in the linked list.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"EDIT: The previous algo failed for some input cases. Thanks to @ buckCherry for pointing it out. Below is the fresh algo.  Find the start of the cycle through Floyd cycle detection algorithm.  The total number of nodes is the count of nodes that form cycle and count of nodes that are not part of cycle. If the list doesn't contain cycle, count of nodes that are part of cycle is zero. 1. Maintain two pointers called hare & tortoise. 2. move hare two steps &  tortoise one step until either both become equal or hare reaches NULL. 3. Move tortoise to the start of the list. Move tortoise  and hare step by step until their next node don't point to the same node( in case there is no cycle , hare will point to NULL. Ignore step#4 in this case). This next node is the starting node of the cycle. Meanwhile count the number of nodes that are not part of the cycle.  e.g. A->B->C->D->E->D The number of nodes that don't form cycle is 3.  4. Count the number of nodes in the cycle. Start tortoise from the starting node of the cycle and keep on moving until it doesn't reach its initial position. In the example explained in step#3, the number of nodes in the cycle is 2.  5. The answer is count in step#3 + count in step#4."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Traverse through the linked list. while traversing the linked list insert address(key) of each node into a hashmap.If it already exists in the hashmap then the linked list contains the loop. Maintain a counter to know the number of elements of the list while traversing..  Timecomplexity-O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"you can first find if there is cycle in linklist or not(Using 2 pointer floyd theorm) in O(n) time     (i)If it is present then that node(ie. start node for cycle) will be your check point.    while counting you need to look at.   otherwise it is a normal link list"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"you can first find if there is cycle in linklist or not(Using 2 pointer floyd theorm) in O(n) time     (i)If it is present then that node(ie. start node for cycle) will be your check point.    while counting you need to look at.   otherwise it is a normal link list"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"first check if der is a loop wid o(n) complexity floyds theorem.. if loop is der,mark the starting node of loop wid pointr p.now tak a pointr k pointing to first node of lnkd list.traverse it until u rech p,increment countr til dat.after dis loop,point k to the next sequential node.. again run loop and increment counter untill p is rechd.. counter is the no. of nodes we wanted.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"such looping in list is solved using 2 pointers. one is ptr->next and the other is ptr->next->next. at 1 point they both meet and there your counting ends. when there is no looping you can just go to the end of the list incrementing the count."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"such looping in list is solved using 2 pointers. one is ptr->next and the other is ptr->next->next. at 1 point they both meet and there your counting ends. when there is no looping you can just go to the end of the list incrementing the count."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"such looping in list is solved using 2 pointers. one is ptr->next and the other is ptr->next->next. at 1 point they both meet and there your counting ends. when there is no looping you can just go till the end of the list incrementing the count."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"such looping in list is solved using 2 pointers. one is ptr->next and the other is ptr->next->next. at 1 point they both meet and there your counting ends. when there is no looping you can just go till the end of the list incrementing the count."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"in the question it is specified that we may be given a link list which may or may not have a loop , and it may not start from the head. Now consider that we were given a list which does not cointain loop (singly linked list) and we did not start form the head , then starting from the point or node given to us there might be a possibility that there were nodes behind then how can we count them when finding the no. of elements in the list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"in the question it is specified that we may be given a link list which may or may not have a loop , and it may not start from the head. Now consider that we were given a list which does not cointain loop (singly linked list) and we did not start form the head , then starting from the point or node given to us there might be a possibility that there were nodes behind then how can we count them when finding the no. of elements in the list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"LinkedListNode FindBeginning(LinkedListNode head) {   LinkedListNode n1 = head;   LinkedListNode n2 = head;       // Find meeting point   while (n2.next != null) {     n1 = n1.next;     n2 = n2.next.next;     if (n1 == n2) {      break;     }   }   // Error check - there is no meeting point, and therefore no loop   if (n2.next == null) {    return null;   }   /* Move n1 to Head. Keep n2 at Meeting Point.  Each are k steps   /* from the Loop Start. If they move at the same pace, they must    * meet at Loop Start. */   n1 = head;    while (n1 != n2) {     n1 = n1.next;     n2 = n2.next;    }   // Now n2 points to the start of the loop.   return n2; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is an idea --  maintain three pointers: a) head -- start of the given list b) first -- jumps one step in iteration c) second -- jumps two step in iteration  Start first and second pointers from the head and continue till both become equal (in case of loop) or second traverses the list completely and reaches  the end(in case of linear list).  If the list is linear, number of nodes can be counted by traversing the list starting from head.  If the list contains a loop, notice the node where first and second becomes equal, store this new pointer tempPointer.  At this point, break the loop between tempPointer and tempPointer->next  by using code below:  head2 = tempPointer->next; tempPointer->next = null   Suppose the original list with loop was like:   head - a - b- c- d- e - f - g - h                                  |              |                                 l -k  - j  - i  Suppose the loop is broken between f and g and null pointer is introduced:   then g becomes head2 and f->next is set to null:  head  - a - b- c- d- e - f --> null                                  |                                                 l - k  - j  - i - h - g (head2)  now we can traverse from head to null (first list) and head2 to null (second list)  These two lists are merged at node e.  Count the number of nodes in first list -- count1 Count the number of nodes in second list -- count2  suppose count1 is greater than count2 (take whichever is greater)  then traverse first list by (count1 - count2) starting from head. Then start traversing two lists together till you reach at merging point. Suppose you traverse M nodes together to reach merging point.  Then traverse the merged list.  The sum of nodes in both lists = number of nodes in first list + M"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how cycle is detected using hare & tortouse algo?? can u please explain??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Mark the nodes and then count"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Find the loop using floyd's algo, then clacualte thenumber of nodes in the loop by fixing one pointer inside the loop and shifting another pointer in the loop untill bth of them become equal again, lets the number be m now take a pointer pointing to the head and go to mth node now move the pinter to the head and the pointer pointing to the mth node step by step until the bcome equal and now you the node at which the loop starts"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using double pointers only, will not solve this problem. There two types elements in the list; first are say, X which are not in loop and other say, Y, which belongs to loop. let number of X are x. and number of Y are y. And we need to calculate the x + y.   I will go with this approach: First reverse the linked list and increment a counter, counter will be give you the value of 2x + y. Now, using floyd cycle detection algo to find any Y. Calculate the value of y by just traversing the loop once starting from Y. Calculate x + y, using prior equations.  Reverse again the linked list to give its original shape. Total complexity should be O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What exactly does \"may or may not start from the head mean\" ?? We certainly cannot backtrack in a singly linked list unless its circular. Maybe i am not clear with the question. Please explain."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"'shodnik' and 'Anonymous' have already provided solutions which I'm not fully convinced untill I receive some response against my asks to them. In the mean time here is my solution in O(n) time and with fixed additional memory. The only drawbacks of my algorithm is that it requires changing the structure of the list whereas both of the solutions from them does not. Note that the solution given by 'Anonymous' does a change of list structure but it can be avoided.  Anyway here is mine."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node slow = head; \n Node fast = head; \n while (slow != null && fast != null && slow != fast){ \n  slow = slow.next; \n  if (fast.next== null) \n   break; \n  fast = fast.next.next;  \n } \n int size = 0; \n if (slow == null ||fast == null || fast.next == null){ // there is no loop \n  Node temp = head; \n  \n  while (temp != null) \n   count++; \n  return count; \n } \n //now we want to find the head of the cycle \n slow = head; \n while (slow != fast){ \n  slow = slow.next; \n  fast = fast.next; \n } \n //now fast/slow is the head of the loop \n Node current1 = head; \n Node current2 = slow.next; \n while (current1 != slow){ \n  size++; \n  current1 = current1.next; \n } \n while (current2 != slow){ \n  size++; \n  current2 = current2.next; \n } \n return size + 1; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13275678","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"48","title":"input linked list is : 1->9->3->8->5->7->7  do you see any pattern in this input ? odd placed nodes are in increasing order and even placed nodes are in decreasing order. write a code that gives the the following linkedlist:  output linked list should be 1->3->5->7->7->8->9  ?? can it be done inplace ?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"9","title":"input linkedlist= 1->9->3->8->5->7->7 output linked list should be 1->3->5->7->7->8->9   main(){  //head represents the head of the input list as shown above;  list *l=head; list *evenNode; list *pre_evenNode; pre_evenNode=NULL;  while(l!=NULL){  evenNode=l->next;  l->next=l->next->next;  evenNode->next=pre_evenNode;  pre_evenNode=evenNode;         l=l->next; } l->next=pre_evenNode;   }  explaination: link all odd nodes one after other and reverse all even nodes while traversing for odd nodes. Finally link tha last odd node with the last even node;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Final list should be sorted , so better is to break list into two parts one containing all even nodes and one containing all odd nodes. then, reverse the list containing even nodes. Then merge the both sorted lists in O(n) inplace."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Sort in terms of three elements to get the result... 1->9->3->8->5->7->7 Step a: 1-3-9-8-5-7-7 Step b:1-3-8-9-5-7-7 Step c:1-3-5-8-9-7-7 Step d: 1-3-5-7-8-9-7 Step e: 1-3-5-7-7-8-9"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"looks like the solution is just applying a sorting algorithm over the linked list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi ashish, I am a little confused about the question, so the even number should be placed in decreasing order and should also placed in the right order with odd number? (just like 8 placed before 9), if we add the number 2 in the input, where should we put it? Thanks!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi ashish, I am a little confused about the question, so the even number should be placed in decreasing order and should also placed in the right order with odd number? (just like 8 placed before 9), if we add the number 2 in the input, where should we put it? Thanks!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it is just the sorting of link list so you can use any sorting technique and sort th elink list.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"garimaa.blogspot.in/2012/04/program-11th-in-c.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class Node \n{ \n \n int data; \n Node next; \n \n Node(int data) \n { \n  this.data=data; \n  this.next=null; \n } \n  \n Node(Node n) \n { \n  this.data=n.data; \n  this.next=null; \n } \n public int getData() \n { \n  return data; \n } \n  \n public Node getNext() \n { \n  return next; \n } \n  \n public void setNext(Node next) \n { \n  this.next=next; \n } \n  \n} \n \nclass LinkedList \n{ \n \n Node first; \n  \n LinkedList(Node first) \n { \n  this.first=first; \n } \n \n public void insertLast(Node n) \n { \n   \n  if(first==null) \n  { \n   first=n; \n    \n  } \n  else \n  { \n   Node temp=first; \n   while(temp.getNext()!=null) \n   { \n    temp=temp.getNext(); \n   } \n   temp.setNext(n); \n  } \n  \n } \n \n public void insertFirst(Node n) \n { \n \n  if(first==null) \n  { \n   first=n; \n  } \n  else \n  { \n   n.setNext(first); \n   first=n; \n  } \n } \n \n Node getFirst() \n { \n  return first; \n } \n \n public void mergeList(LinkedList l2) \n { \n  Node temp=this.first; \n  while(temp.getNext()!=null) \n  { \n   temp=temp.getNext(); \n  } \n  temp.setNext(l2.first); \n   \n } \n \n public void printList() \n { \n  Node temp=first; \n  while(temp.getNext()!=null) \n  { \n   System.out.println(temp.getData()); \n   temp=temp.getNext(); \n  } \n  System.out.println(temp.getData()); \n } \n} \n \nclass Arrange \n{ \n public static void main(String a[]) \n \n { \n  LinkedList l=new LinkedList(null); \n  for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If this is a doubly linked list, we can do the sorting in place in O(n) time. its just a merge starting from the tail of the linked list, where one array is starting at location 1, and other at n (for odd length) eg: 1->9->3->8->5->7->7 lst1: 1->3->5->7<=end pointer for increasing list lst2: 9->8->7         ^start pointer for decreasing list now merge from the end of the original list"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If this is a doubly linked list, we can do the sorting in place in O(n) time. its just a merge starting from the tail of the linked list, where one array is starting at location 1, and other at n (for odd length) eg: 1->9->3->8->5->7->7 lst1: 1->3->5->7;7<=end pointer for increasing list lst2: 9->8->7; 9<=start pointer for decreasing list now merge from the end of the original list"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It seems like the easiest way to do this would be to keep a stack of the even values. When you reach the end of the linked list, you just pop the stack and add the nodes to the end of the linked list.  Psuedo code  LinkedListNode sortLL (LinkedListNode head)  LinkedListNode curr = head; LinkedListNode tmp = null; Stack nums = new Stack();  while(curr != null)       if(curr.next != null && curr.next.next != null)            push curr.next onto your stack            assign curr.next to curr.next.next             increment to the next node, curr = curr.next      else           while(stack is not empty)                assign tmp to curr.next (should be null since curr is at the end of the list)                assign curr.next to stack.pop()                  assign curr.next.next to the end of the list (tmp)                increment to the next node, curr = curr.next           return head (which should still be pointing to the head of your linked list)             return null (if list was empty)  By the logic of this solution, the time complexity would be O(n+m) where n is the odd number nodes and m is the even. It seems counter intuitive, since there is a while loop within a while, which should be n^2. But if you look at how the list is looped through you see that the first while loop only goes through every other node (pushing the even nodes to the stack as it skips over them).   Then in the second while loop, in the else block, loops through only the values that were pushed into the stack (i.e. m which were the even placed nodes). So technically O(n+m) is O(n) where n is the total number of nodes, making this an in place solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* code */  linked *p; .... ....      while(p!=0)      {         printf(\"%d\\t\",p->data);         p=p->next->next;       }    p=p->pre;        while(p!=0)        {           printf(\"%d\\t\",p->data);           p=p->pre->pre;        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* code */  linked *p; .... ....      while(p!=0)      {         printf(\"%d\\t\",p->data);         p=p->next->next;       }    p=p->pre;        while(p!=0)        {           printf(\"%d\\t\",p->data);           p=p->pre->pre;        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node *change(node *head) { \n if (!head || !head->next) \n  return head; \n node *odd,*even,*temp1,*temp2; \n temp1 = odd = head; \n temp2 = even = head->next; \n bool flag1 = true,flag2 = true; \n while(flag1 || flag2) { \n  if (temp1 && temp1->next) { \n   temp1->next = temp1->next->next; \n   temp1 = temp1->next; \n  } \n  else \n   flag1 = false; \n  if (temp2 && temp2->next) { \n   temp2->next = temp2->next->next; \n   temp2 = temp2->next; \n  } \n  else \n   flag2 = false; \n } \n temp2 = reverse(even); \n temp1 = odd; \n while(temp1->next) \n  temp1 = temp1->next; \n temp1->next = temp2; \n return odd; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Create ListOdd using InsertAtTail and Create ListEven with InsertAtHead.  2. Append ListEven to ListOdd  Return ListOdd as sorted list.  Complexity: O(n) + O(1) = O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using 2 points.  The solution is posted here: thepragma.blogspot.com/2012/04/include-next-oddlist-oddlist-subroot.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using 2 pointers:  The solution is posted here: thepragma.blogspot.com/2012/04/include-next-oddlist-oddlist-subroot.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Posted the solution using 2 pointers here: thepragma_dot_blogspot_dot_com/2012/04/include-next-oddlist-oddlist-subroot.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.split the linked list into two separate lists  2.odd linked list in ascending order, even linked list in descending order 3. reverse the even linked list 4  now merge both sorted linked list in place"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have used a different set (1,2,3,4,5,6,7) and sorted the list as expected. You can change the value while trying yourself to the one given in question:  CODE:::  import java.awt.List; import java.util.Collections; import java.util.Iterator; import java.util.LinkedList;   public class LinkedListSample {  public static void main(String[] args) {   LinkedList LList = new LinkedList();   Iterator LList2;   LList.add(0, 1);   LList.add(1, 2);   LList.add(2, 3);   LList.add(3, 4);   LList.add(4, 5);   LList.add(5, 6);   LList.add(6, 7);   System.out.println(\"THe Linked List is:\"+LList);   System.out.println(\"THe Linked List is:\"+LList.size());   separateLinkList(LList);  }    public static void separateLinkList(LinkedList lList) {   int firstlement = (Integer) lList.element();   LinkedList even = new LinkedList();   LinkedList odd = new LinkedList();      for(int i=0; i   int count = 0;    int a = i%2;    if (a == 0) {    odd.add(count, lList.get(i));    count++;    }    else if (a == 1) {     even.add(count, lList.get(i));     count++;    }    }   Collections.sort(odd);   odd.addAll(even);   System.out.println(\"The Odd Linked List is:\"+odd);  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.awt.List; import java.util.Collections; import java.util.Iterator; import java.util.LinkedList;   public class LinkedListSample {  public static void main(String[] args) {   LinkedList LList = new LinkedList();   Iterator LList2;   LList.add(0, 1);   LList.add(1, 2);   LList.add(2, 3);   LList.add(3, 4);   LList.add(4, 5);   LList.add(5, 6);   LList.add(6, 7);   System.out.println(\"THe Linked List is:\"+LList);   System.out.println(\"THe Linked List is:\"+LList.size());   separateLinkList(LList);  }    public static void separateLinkList(LinkedList lList) {   int firstlement = (Integer) lList.element();   LinkedList even = new LinkedList();   LinkedList odd = new LinkedList();      for(int i=0; i   int count = 0;    int a = i%2;    if (a == 0) {    odd.add(count, lList.get(i));    count++;    }    else if (a == 1) {     even.add(count, lList.get(i));     count++;    }    }   Collections.sort(odd);   odd.addAll(even);   System.out.println(\"The Odd Linked List is:\"+odd);  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"82    int count = 1;      83    Node * tempList = header;      84    Node * oddList  = NULL;      85    Node * evenList = NULL;      86    Node * nextNode  = NULL;      87    if(header == NULL)      88       return ;      89    while(tempList != NULL)      90    {        91       nextNode = tempList->next;      92       if(count % 2 != 0)      93       {      94          if(oddList == NULL)      95             oddList = tempList;      96          else {oddList->next = tempList;oddList = oddList->next;}      97       }        98       else      99       {     100          if(evenList == NULL)     101          {     102             evenList = tempList;     103             evenList->next = NULL;     104          }       105          else { tempList->next = evenList; evenList = tempList;}     106       }       107       count++;     108       tempList = nextNode;     109    }     110    oddList->next  = evenList;     111    return ;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Keep connecting the even nodes and while at the same time remove odd nodes and connect in the reverse way. At the end of traversal you would have two linked list  : 1. Even nodes linked list 2. Reversed odd node linked list.    You would need 3 pointers and one temp node variable:  1. Pointer 1 : even -- which would traverse on even nodes only. 2. Pointer 2 :  odd -- which would traverse on odd nodes only. 3. Pointer 3 : revHead -- head of reversed odd linked list. 4. Temp variable -- temporarily hold the odd node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void transform() { \n \n    node *first = head; \n    node *middle = head->next; \n    node *second = middle; \n     \n    node *fwdFirst = second->next; \n    node *fwdSecond = fwdFirst->next; \n     \n    while (fwdFirst) { \n     \n        first->next = fwdFirst; \n        second->next = fwdSecond; \n \n        first = first->next; \n        second = second->next; \n \n        if (fwdSecond) \n            fwdFirst=fwdSecond->next; \n        else \n            fwdFirst = NULL; \n \n        if (fwdFirst) \n            fwdSecond = fwdFirst->next; \n        else \n            fwdSecond = NULL; \n    } \n     \n    first->next = middle; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node *pattern(node *head) \n{ \n if(head == NULL) \n  return NULL; \n \n node *h1,*h2,*p1,*p2; \n h1=head; \n h2=head->next; \n p1=head; \n p2=NULL; \n if(head->next != NULL) \n { \n  p2=head->next->next; \n  h2->next = NULL; \n } \n while(p2 != NULL) \n { \n  p1->next = p2; \n  p1 = p2; \n  if(p1->next != NULL) \n  { \n   p2 = p1->next->next; \n   p1->next->next = h2; \n   h2 = p1->next; \n  } \n  else \n   p2 = NULL; \n } \n p1->next = h2; \n  \n return head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void  arrageNodesImpl( LinkedListNode* node,LinkedListNode *oddnodes) \n { \n  if(node) \n  { \n    \n   if(node->next != NULL) \n   { \n    LinkedListNode *localoddnode=node->next; \n    node->next=node->next->next; \n                arrageNodesImpl(node->next,localoddnode); \n    LinkedListNode *iterator=node; \n    while(iterator->next) \n    { \n     iterator=iterator->next; \n    } \n    iterator->next=localoddnode; \n    localoddnode->next=NULL; \n   } \n  } \n  return; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Assuming its a singly linked list, here is a solution in O(n) time.   logic :   1. Construct two separate linked lists. One with values in odd  position & other with values in even position.  The second list would be constructed in reverse. i.e., first 9 will be added, then 8 will be added which would point to 9 as the \"next\", then 7 will be added to the list, which would be point to 8 as \"next\".  2. Point the last node of first list to the head of the second list.  here is the working java code :"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=164986","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"43","title":"Print a linked list recursively in a reverse manner without changing the actual list","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"Since space is not a restriction, a simple solution would be to use a stack...  Start from the first node of the linked list and enter every element to the stack as you move on... Once you reach the end of the LL, just print the stack contents...  Time complexity : O(n) Space Complexity : O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"void printRev(const node* node) { \n    if (node) { \n        printRev(node->next); \n        cout << node->value << endl; \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"What do you mean by linked list is dynamic?  I guess I'm missing something very crucial. I was thinking of using a stack to keep the pointers of the linked list. No recursion, and I'm not manipulating the pointers in the list itself. Can you elaborate on the \"dynamic\"?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"my idea, have an extra pointer and a count. in first iteration, loop through the end of linked list, and count the number of nodes in linked list. print the last element. decrement the count. then on loop through the linked list count number of times and print the last element. continue till count is 0. time complexity O(n^2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"private static void reverse(LinkedList lList) {   LinkedList temp = new LinkedList();   LinkedList lList2 = new LinkedList();   lList2 = lList;   int len = lList.size();   int t;   for (int i = 0; i < len; i++) {    t = lList2.getLast();    lList2.removeLast();    temp.add(t);   }   System.out.println(\"Linked List:\" + lList2);   System.out.println(\"reverse Linked List:\" + temp);   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"another simple method, hve 3 pointers , back , middle, front   reverse(list *header)  {   middle = header;    front = middle->next;    back = null ;    while(1)    {        // reverse the link for middle node        middle->next = back ;         // reached end of list break         if (front == NULL)  break;          // move ahead one node @ a time all the 3 pointers        back = middle;         middle = front;         front = front->next;     }    // middle now points to the last node in the original list.     header = middle ;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"my soln:  print(list *head) {    if( head)        print(head->link);    printf(\"%d\",head->data);    return; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the first solution is clear enough, avoiding the machine stack depth."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Stack solution however is of order Omega(2N), but doing things iteratively naturally leads to less memory usage (bar stack allocation) due to unstacked function calls."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct node  {   int a;   struct node*link;  };    struct node*head;    void rev_linklist()  {    struct node* prev_ptr , *temp , *for_ptr;     prev_ptr = head;    temp = for_ptr = head->link;     prev_ptr->link = NULL;     while(for_ptr->link != NULL)    {       temp = for_ptr;      for_ptr = for_ptr -> link;      temp ->link = prev_ptr;      prev_ptr = temp;   }     for_ptr->link = temp;    head = for_ptr;     traverse();   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"note sure abt the question but you could always create a list of objects in one iteration (as space complexity is not an issue), then print the list in reverse.... not sure if we understand the  question."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"one solution is, find the length of the linked list say n. then traverse the list through n/2, and push into stack from n/2 to n links... Now again start from beginning and swap first link with pop the stack element, and swap second link with pop the next element in stack, continue this till stack is empty"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using a stack is the obvious answer but this is pretty much equals to do-it-yourself-recursive."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Create another double linked list with tail pointer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using stack can do the reverse of linked list other than recursive or manipulating data/pointers"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Maybe I'm missing something, but it's possible to create reversed copy of the list like this:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"printReversedLinkedList(Node node){ \n \nString reversedValue =  new String(); \nwhile(node !=null){ \n \nreversedValue =node.value+reversedValue; \nnode=node.next; \n} \nSystem.out.println(s); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You could also just use StringBuffer if coding in java.  Similar to  Sidhavratha's solution, but perhaps slightly more simple.  Also O(n) time!  Public void printReverseLinkedList(Node node) {      StringBuffer sb = new StringBuffer();      while (node != null ) {                sb.append(node.value);                node = node.next;       }      System.out.println(sb.reverse().toString());"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"or"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we can take one more list and keep adding elemnts in the front, and then traverse the newly created linked list, and it will contain the objects in reverse order only"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public String printReverse(LinkedListNode head) \n { \n  int count = 0; \n  LinkedListNode current = head; \n  if(head == null) \n   return null; \n  while(current != null) \n  { \n   count++; \n   current = current.next; \n  } \n  String str = \"\"; \n  while(count > 0) \n  { \n   int currCount = 0; \n   current = head; \n   while(current != null) \n   { \n    currCount++; \n    if(currCount == count) \n    { \n     str += current.value; \n     count--; \n    } \n    current = current.next; \n   } \n  } \n  return str; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the questions says u can use an additional space , then the simplest ans is to store the contents of list in an array. Sort the array ( swap (a[0],a[n-1]), swap(a[1],a[n-2)...and so on). Once the array is sorted , put the value back in list. its  O(n) solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"declare a linked list Linkedlist l1 = new Linkedlist(); int lsize;  l1.add(\"1\"); l1.add(\"2\"); l1.add(\"3\"); l1.add(\"4\");  lsize=l1.size();  for (i= lsize;i>=0;i--) { System.out.println(\" the rev order\" +l1.get(i)); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just traverse the linked list and reverse the next links and once you get to the end of the list, traverse back and print."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just traverse the linked list and reverse the next links and once you get to the end of the list, traverse back and print."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think storing addresses of a list that is dynamic is not good. Its better to clone the data as well. Again if you use a fixed size stack you need to parse the list at least once to get the size, and a dynamic stack is just a list abstracted in a way that it looks like a stack."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; \n \npublic class PrintLLReverse { \n public static void print(ArrayList list) { \n  print_helper(list, 0); \n } \n \n private static void print_helper(ArrayList list, int position) { \n  if (position >= list.size() - 1) { \n   System.out.print(list.get(position) + \"\\t\"); \n   return; \n  } \n  print_helper(list, position + 1); \n  System.out.print(list.get(position) + \"\\t\"); \n } \n \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n  ArrayList list = new ArrayList(); \n  list.add(4); \n  list.add(5); \n  list.add(6); \n  list.add(7); \n  list.add(6); \n  list.add(2); \n  list.add(1); \n  list.add(9); \n  list.add(0); \n  print(list); \n } \n \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=11561969","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"41","title":"Given a doubly linked list containing only three integers 1,2,3. Sort the list without exchanging the values.  Eg- 1->3->2->1->2->3->2->1->1 output: 1->1->1->1->2->2->2->3->3","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"11","title":"take three pointers one, two and three. first of all search for a 1  and move( delete from current) it to head (if 1 is already at head then omit this step) now traverse the list starting from 2nd node  if found 1   delete it and move it to the head  (update the head also) if found 2    dont do anything just move to nect node. if found 3    move it to last ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"why so much...  take 3 int variables.. count the occrence of each digit in the first parse of link list.... in the second parse replace the node value as the number of occrance of 1 then 2 and then 3...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"instead of keeping 3 separate lists and merging it in last . Keep two check-points which marks end 1's, and 2's  .  now  you traverse the list , when ever you find a 1, detach it from current position and attach to 1's check point, same thing for 2's. after you traversed the list once , it will be sorted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"My solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"2 pointers original_head, original_tail  1. orignal_head = head; 2. Traverse DLL from tail to original_head. 2a. If nodeValue = value 1 ; move node to head (start).  # original_head is required because in step 2a we add the node to beginning (head), thereby changing value of head. Without original_head we would be stuck in an endless loop.   3. orignal_tail = tail; 4. Traverse DLL from original_head to original_tail. 4a. If nodeValue = value 3 ; move node to tail (end).  # Value 2 falls in place by itself.  Complexity: O(n) + O(n) = O (n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"take 3 pointers to store 3 link lists for 1,2,3, now start deleting all the nodes from the link list and instead of freeing the deleted node, append it to proper pointer above mentioned. Then finally merge the lists"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this?  Node sort(Node head) {  Node typeA = new Node (1);  Node headA = typeA;  Node typeB = new Node (2);  Node headB = typeB;  Node typeC = new Node (3);  Node headC = typeC;  Node current = head;    while(current! = null)  {   if(current.Value == typeA.value)   {    typeA.next = new Node(current.value);    typeA = typeA.next;   }   else if(current.Value == typeB.value)   {    typeB.next = new Node(current.value);    typeB = typeB.next;   }   else if(current.Value == typeC.value)   {    typeC.next = new Node(current.value);    typeC = typeC.next;   }     }  Node tmp = headA;  headA = headA.next;  Node tmp = headB;  headB = headB.next;  Node tmp = headC;  headC = headC.next;    //combining the 3 parts  typeA.next = headB;  typeB.next = headC;   return headA;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"oops! forgot to progress the current pointer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Must cosider the fact that the given link list is doubly. So, we can easily implement this in the same fashion as for grouping 1,2,3 together in an array.   Above stated methods are true for single link list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Must consider the fact that the given link list is doubly. So, we can easily implement this in the same fashion as for grouping 1,2,3 together in an array.   Above stated methods are true for single link list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What about having 3 variables reprenting the number of occurences for 1, 2 and 3 in the list. Then just traverse the list counting 1s and 2s and 3s. Once ended create a new list with as many nodes as the counters describe"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class SortLinkedList {  public Node sort123(Node head) {   Node[] starters = new Node[3];   Node firstNode = head;   do {    Node next = head.getNext();    head.setNext(head);    head.setPrev(head);    Node curNode = starters[head.getData() - 1];    if (curNode == null) {     starters[head.getData() - 1] = head;    } else {     Node lastNode = curNode.getPrev();     lastNode.setNext(head);     head.setPrev(lastNode);     head.setNext(curNode);     curNode.setPrev(head);    }    head = next;   } while (firstNode != head);    firstNode = null;   for (int i = 0; i < 3; ++i) {    Node curNode = starters[i];    if (curNode != null) {     if (firstNode == null) {      firstNode = curNode;     } else {      Node prevLast = firstNode.getPrev();      Node lastCur = curNode.getPrev();      prevLast.setNext(curNode);      curNode.setPrev(prevLast);      lastCur.setNext(firstNode);      firstNode.setPrev(lastCur);     }    }   }   return firstNode;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"American Flag, Link list version???"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Move 1's to head, Move 3 to tail"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Duplicate for qns 11561969"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"People Proposing so complex ,   1st dutch nation flag problem but it requires the swapping elements isn't it ?  what else we can do , take 3 counter , traverse linked list , count for each 1,2,3  then just put 1 , 2, 3 on basis of corresponding counter isn't it ?  correct me if anything ?  Shashank"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Recursive sort doubly link list  node* sortDoubly(node *head) {    node*ptr2=NULL,*ptr3=NULL, *ptr4=NULL, *headprev=NULL;  if (!head)  { return NULL;  }    else if(head->next==NULL)  {   return head;  }         //ptr2=ptr->next;  ptr2=sortDoubly(head->next);  if(head->a > ptr2->a)  {   headprev=head->back;   ptr2->back=headprev;   headprev->next=ptr2;   ptr3=ptr2;   while(ptr3->next && head->a > ptr3->a )   {       ptr3=ptr3->next;   }   if (ptr3->next)   {   ptr4=ptr3->back;   ptr4->next=head;   head->back=ptr4;   head->next=ptr3;   ptr3->back=head;    return ptr2;   }      else    {    ptr3->next=head;    head->next=NULL;    head->back=ptr3;    return ptr2;   }  }    return head;     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void sort(node p)  {   node r=null;   int i=0;   p=firstaddress;   boolean b=true;   while(b==true)   {    b=false;    p=firstaddress;        r=null;    i=0;    while(p!=null)    {     i++;     node q = p.next;     show(p);     System.out.println(\"\\n\");     if(q==null)      {       break;      }      else      {       if(p.val>q.val)       {        b=true;        r=p.prev;        if(r!=null)         r.next=q;        p.prev=q;        p.next=q.next;        if(q.next!=null)         q.next.prev=p;        q.prev=r;        q.next=p;             if(i==1)         firstaddress=q;            }       else       {        if(i==1)         firstaddress=p;        p=p.next;       }      }    }   }        } not bothering aout the time complexcity..o(n2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Check it, working correct:   #include #include  using namespace std; class Node{       public:              int n;              Node *next,*prev;              Node(int i){                     n=i;                     next=prev=NULL;                     } }; class dll{       public:       Node *head;       dll(){             head=NULL;             }       void insert(int i){            Node *n=new Node(i);            if(head==NULL) {head=n;return;}            Node *temp=head;            while(temp->next!=NULL) temp=temp->next;            temp->next=n;            n->prev=temp;            }       void display(){            Node *temp=head;            while(temp!=NULL){                              cout<n<<\" --> \";                              temp=temp->next;                              }            cout<           }       }; void correct(dll list,Node *temp){            Node *tmp=temp->next;      temp->next=tmp->next;      if(temp->next!=NULL) temp->next->prev=temp;      Node *tmp2=temp;      while(tmp2!=NULL&&tmp2->prev!=NULL){ if(tmp2->prev->n<=tmp->n){break;}tmp2=tmp2->prev;}      if(tmp2==NULL){tmp->next=list.head;                   list.head->prev=tmp;                  list.head=tmp;}      else{          tmp->prev=tmp2->prev;          tmp2->prev->next=tmp;           tmp->next=tmp2;           tmp2->prev=tmp;           }      } void sort(dll list){      list.display();      cout<     Node *temp=list.head;            temp=list.head->next;      while(temp!=NULL&&temp->next!=NULL){              if(temp->n>temp->next->n){                                        correct(list,temp);                                       continue;                                       }              temp=temp->next;              }      cout<<<\"Sorted: \"<     list.display();      }  int main(){     dll list;     int str[]={1,3,2,1,2,3,2,1,1};     int size=sizeof(str)/sizeof(int);     for(int i=0;i            list.insert(str[i]);             }     sort(list);     cout<    system(\"pause\");     return 0;     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can implement this Quicksort style - use 2 as pivot to shove all 1's to the left and 3's to the right."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"A Naive solution:  Take three copies of the list, one for each of the three numbers. Eg, First list for 1, Second for 2, and Third for 3.   Traverse each linked list deleting elements other than the one it represents.  Then append all three lists in sorted order.   This has O(kn) running time and O(kn) space complexity, where 'k' is the number of unique elements (in this case - 1,2 and 3)."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=1878","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"41","title":"How will you determine if a loop exists in a link list?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"O(n) time complexity  Simultaneously go through the list by ones (slow iterator) and by twos (fast iterator). If there is a loop the fast iterator will go around that loop twice as fast as the slow iterator. The fast iterator will lap the slow iterator within a single pass through the cycle. Detecting a loop is then just detecting that the slow iterator has been lapped by the fast iterator.  // Best solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Pointers moving at different rates:Pointer b moves 1 step ahead every time that pointer a moves 2 steps ahead. If there is a loop, eventually they will both enter it, and at some point because they are moving at different rates, they will be equal. If they are ever equal, you have a loop."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"yes using two pointers works well . other algo may be as follows:reverse the linked list from .while reversing if u start from first node.after starting reversing if u find first node again .there is loop in linked list.reverse it again to find original list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"try to travell to NULLif u reach start again,there is a loop."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Consider a linked list which has a head (reference to the first node) and a current pointer. Traverse the loop and if at any point of time current-> next == head, voilla! you got a loop.while( current.next != null ) {    if( current.next == head ) {        System.out.println(\"Loop detected!\");        break;    }    current = current.next;}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"typedef struct node Node;\nstruct node {\n Node * next;\n};\n\nbool is_cyclic(Node * list) \n{\n if(!list || !list->next) return false;\n if(list->next == list) return true; // one element list pointed to himself\n \n Node * first = list;\n Node * second = list->next->next;\n \n bool result = false;\n while(second) {\n  if(first == second) {\n   result = true;\n   break;\n  }\n  first = first->next;\n  if(second->next == 0) { break; }\n  second = second->next->next;\n }\n \n return result;\n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"add an extra flag field to each node.. while traversing the list set the flag bits, if an already set flag is encountered the list has a loop."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I don't think they would have let me add a flag, hence they wanted me to do the two pointers trick apparently ..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool DetectLoop(NODE First, NODE Second) { if(First == Second) return true;  if(second && second->next && second->next->next)     return DetectLoop(First->next,Second->next->next);  else return false; }  DetectLoop(head,head && head->next?head->next->next:NULL);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool DetectLoop(NODE First, NODE Second) { if(First == Second) return true;  if(second && second->next) return DetectLoop(First->next,Second->next->next);  else return false; }  DetectLoop(head,head && head->next?head->next->next:NULL);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hey was this a phone interview?? What position is it for?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use two pointers slow and fast,... every iteration slow travels 1 node and fast travels two nodes.. eventually fast will be behind slow if there is a loop .."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use fast and slow pointer....if fast==slow loop exist otherwise no loop.... but the real challange is how to remove the loop... I have found it in the folowing... goursahafreeodacom goursahafreeodacomDataStructureLoopDetectionInLLhtml"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am writing only the function, rest is pretty much decoration !!!  int detectloop(struct node *list) {   struct node  *slow_p = list, *fast_p = list;     while(slow_p && fast_p &&           slow_p->next &&           fast_p->next &&           fast_p->next->next )   {     slow_p = slow_p->next;     fast_p  = fast_p->next->next;     if (slow_p == fast_p)     {        printf(\"Found Loop\");        return 1;     }   }   return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// Here is the C# code.   public bool FindALoop()         {             if (Head == null)             {                 return false;             }             Node slow = Head;             Node fast = Head;              while (slow.Next != null && fast.Next.Next != null)             {                 slow = slow.Next;                 fast = fast.Next.Next;                 if (slow.Equals(fast))                 {                     //Found a loop                     return true;                 }             }             return false;         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use 2 pointers to begin with. Move one pointer at double the speed of the other. if there is a loop, then they would be equal at one some point."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Nice solution by Neo above.  One other approach. We can use hash set to keep the distinct nodes."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hiiiii"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Agree wid NEO... it will work in all cases..!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use two pointers:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Maintain two pointers to traverse through the linked list, pointer1 & pointer2 do pointer1 = pointer1->next; pointer2->pointer2->next->next;  while(pointer2 && pointer2->next) //check for null condition, which if hit means no loop  the slower pointer1 will eventually catch up with faster pointer2 if there exists a loop."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The code for this problem would be:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool FindInList(stList* pList,stList* pList2) {  bool bReturn = false;  stList* pList1 = pList;  if(pList1 == NULL || pList2 == NULL)   return bReturn;  while(pList1 != pList2)  {   if(pList1 == pList2)   {    bReturn = true;    break;   }   pList1 = pList1->pNList;  }  return bReturn; }  bool FindLoop(stList* pList) {  bool bReturn = false;  stList* pTemp = pList;   if(pTemp == NULL)   return bReturn;   while(pTemp != NULL)  {   if(FindInList(pList,pTemp))   {    bReturn = true;    break;   }   pTemp = pTemp->pNList;  }  return bReturn; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Am trying to use the length of list and incrementing the counter to check if its equal to list size is  this correct. thnx"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be done using 3 pointers 1. Take a slow runner(Increase with one ) and a first runner(increment twice) approach to find the linklist is circular or not. If slow runner == fast runner then loop is circular. 2. Once you find the list is circular then loop the  slow runner by one  and the third pointer(which is now pointed to head) . Where they collide you can reach to the start of loop."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I guess it is good know about other algorithms besides Floyd's:  //Algorithm invented by Richard P. Brent and runs in O(n) time. //Outline: initially rabbit and turtle starts //   off at same position however only rabbit moves by a step //   and checks if it meets the turtle. When it does //   not after a certain number of steps, the stationary //   turtle will be teleported to rabbit's position. //   The step counter as well as the limit of steps will //   will be reset. and rest of the actions just repeats.  //Algorithm starts here:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It's called the turtle and the rabbit algorithm. O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"you morons!  2 pointer solution is the standard way of solving this problem. i guess you guys had been rejected right after that interview. Oh Jesus! help these poor souls"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=188966","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"39","title":"Without using an additional linked list arrange elements such that all even numnbers are placed after odd numbers","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we can do bubble sort with arranging elements only when they are even"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"An approach for this problem would be each time check whether the data is even or odd, if it is even, link it with the tail node [keep 2 pointers, one pointing towards the head and the other always pointing towards the tail], thus all the even numbers would be towards the tail and we would have the odd numbers followed by the even numbers...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"try to keep any odd position fixed for odds and even for even....like when u find any odd/even at even/odd index swap it with next even/odd at odd/even index......don't know the complexity but I think this will do..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"comments are welcome...thanks..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"split the link list into two lists, one for even numbers, one for odd numbers. This should be doable by going through the original list. The head/tail pointers of these two lists are maintained. So, 4 more additional pointers.   When all nodes are handled, attach the even number list to the end of the odd number list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"split the link list into two lists, one for even numbers, one for odd numbers. This should be doable by going through the original list. The head/tail pointers of these two lists are maintained. So, 4 more additional pointers.   When all nodes are handled, attach the even number list to the end of the odd number list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is this a single linked list or double linked list? If it is a double linked list, start from both ends and keep swapping."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If it is a single linked list, we need at least some storage to improve time complexity."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"No  valid answer so far! Agreed with Erik though."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If it is a single linked list, we can do it as majun8cn said. Keep linking odd and even nodes and finally join both of these lists."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i misunderstood the problem as in we need to reform the linked list such that odd numbers occur prior to even alternatively something like odd-even-odd-even----...which I've already faced in an interview long back....this one looks different......"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for this 1 ...majun's solution seems fine..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Alternate thought... [This would work better for 'arrays' though] scan an element. if even, swap with the next element... and keep swapping till the element moves to the end. decrement 'end' by 1. repeat for all elements."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Nishit's solution has the issue that we might visit the numbers once again since they have been attached to the tail node. In order to prevent this we can have another pointer that maintains the reference to the tail node in the first run. Once the pointer used for traversal reaches the new pointer we stop because there is no need to traverse further."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The problem is not that hard. We need to traverse through the complete list with dividing it into the two list each having the head as the first odd and even element. Only the node-> next field needs to be changed to point to the next alternate node.  Test cases have to be checked for 0,1,odd and even number of nodes."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here it is i had not tested much but it seems to be correct    Arrange(List** Head)   {    List* Node=*Head; // we want all even at the start  while(Node) {    int Flag;   if(Node->data%2==0)  {        Node=Node->Next;   // move to the next element    continue;   // skip entire while then    }       // we will come till this line if the number is not even    List *temp=Node->next;  List* NextStart=Node->next;   while(temp)  {   int Flag=0;   if (temp%2==0)   {    int MyTemp=temp->data;    temp->data=Node->data;    Node->data=MyTemp;    Flag=1;   }               temp=temp->next;   }   // end of while   if (!Flag)  // If we reached the end of the link list then insert node at the end of link list  {   *Head=Node->next;         temp=*Head;      while(temp)   {    temp=temp->next;   }         Node->next=NULL;      temp->Next=Node;  }      Node=NextStart;   }// end of while   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Arrange(List** Head) \n \n \n{ \n  \n List* Node=*Head; \n// we want all even at the start \n \nwhile(Node) \n{ \n   int Flag; \n  if(Node->data%2==0) \n { \n       Node=Node->Next;   // move to the next element \n   continue;   // skip entire while then  \n \n }    \n   // we will come till this line if the number is not even  \n \n List *temp=Node->next; \n List* NextStart=Node->next; \n \n while(temp) \n { \n  int Flag=0; \n  if (temp%2==0) \n  { \n   int MyTemp=temp->data; \n   temp->data=Node->data; \n   Node->data=MyTemp; \n   Flag=1; \n  } \n \n \n }   // end of while \n \n if (!Flag)  // If we reached the end of the link list then insert node at the end of link list \n { \n  *Head=Node->next; \n        temp=*Head;    \n  while(temp) \n  { \n   temp=temp->next; \n  } \n        Node->next=NULL; \n     temp->Next=Node; \n } \n \n    Node=NextStart; \n \n \n}// end of while \n \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"cunomad can you please explain your code. just 2/3 lines explanation would be good enough to make sense."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First find out the total no of element in the list. -- O(n) complexity. Then take 2 pointer such that 1 pointing to the start and other pointing to the middle.[again O(n/2) complexity] Now check if the no is odd move it in the first half otherwise move it in the second half --- complexity O(nlogn) therefore the total complexity is O(nlogn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"previousNode := null node: = list.firstNode while node != null {  If(node.value % 2 == 0) {  Node1 := node.next  While(node1 != null)  {   If(node1.value % 2 != 0)   {    Found = true;    If(previousNode == null)    {     List.firstNode := node.next     previousNode := node.next     Node.next := node1.next     Node1.next := node     Break;    }    Else{     previousNode.next = node.next     node.next = node1.next     node1.next = node `    break    }   }   Node1 := node1.next  }  if(!found)  {   Break;  } } If (!found) {  If(null == previousNode) {  previousNode := node;  node:= node.next } Else {  Node:= previousNode.next.next  previousNode := previousNode.next             } } Found = false }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"take a pointer(ptr1) pointing to the header.. move it until the value of the node is odd and stop if you find and even number. now from here take another pointer(ptr2).. and keep moving it, until you find an odd number, swap there values not the node. I think this way we can put all odd numbers before the even numbers. Correct if I am wrong."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am thinking along the same lines of kk.  The question says to not create any additional list, just work with the list that's given.  It's been a while since I coded, so in pseudo-code:  take evenPtr and find the FIRST even numbered node. take oddPtr and find the FIRST odd numbered node occurring after an even numbered node. swap the values pointed to by evenPtr and oddPtr. advance evenPtr by 1.  evenPtr now points to the FIRST even number in the list, which will be replaced by the next odd number (if we find one). move oddPtr until we reach the next odd node.  repeat swap process above."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"yup this is the rght one"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my solution ..I have tested it works fine .. I am doing this in O(n) time and it requires some temp pointer ...so space complexity is much less .. I think time complexity can be improved to O(n/2)     Node* evenodd(Node *head) {  Node *odd,*even,*temp1,*temp2,*head1,*head2;  odd = head;  even = head->next;  head1 = even;  head2 = odd;   while(odd != NULL && even != NULL)  {   temp1 = odd->next->next;    if(even->next == NULL)    temp2 = NULL;   else   temp2 = even->next->next;    odd->next = temp1;   even->next = temp2;   odd = temp1;   even = temp2;  }    temp1 = head1;  while(temp1->next != NULL)   temp1 = temp1->next;   temp1->next = head2;    return head1; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ohh fish minor correction ..I did it such that even number come before odd ..but question is asking just opposite which is simple ..so only 2 lines need to be changed ..  temp1 = head2;  temp1->next = head1;  return head2;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Element *OddEven(Element **head) \n{ \n Element *cur = *head; \n Element *pre = null; \n Element *insertAfter = null; \n Element *newHead = *head; \n \n while(cur != null) \n { \n  if(cur->data%2 != 0) \n  { \n   if(insertAfter != null) \n   { \n    Element *tempCurNext = cur->next; \n    Element *tempInsertNext = insertAfter->next; \n    insertAfter->next = cur; \n    cur->next = tempInsertNext; \n    cur = tempCurNext; \n    insertAfter = insertAfter->next; \n   } \n   else if(pre == insertAfter) \n   { \n    insertAfter = cur; \n    pre = cur; \n    cur = cur->next; \n   } \n   else \n   { \n    Element *tempCurNext = cur->next; \n    pre->next = *tempCurNext; \n    cur->next = newHead; \n    newHead = cur; \n    cur = tempCurNext; \n    insertAfter = newHead; \n   }   \n  } \n  else \n  { \n   pre = cur; \n   cur = cur->next;  \n  } \n }  \n \n return *head; \n} \n \nHere I = insertAfter \nc = current \np = previous \nh = head \nStarting with Odd. \n \nI    p     c    \nnull null  1->2->4->5->7->null \n \nI  C \n1->2->4->5->7->null \nP \n \nI     C \n1->2->4->5->7->null \n   P \n \nI        C \n1->2->4->5->7->null \n      P \n \n   I        C \n1->5->2->4->7->null \n         P \n \n      I        C \n1->5->7->2->4->null \n         P \n \nStarting with event. \n \nI    p     c    \nnull null  2->4->5->7->null \n \nI    p  c    \nnull 2->4->5->7->null \n \nI       p  c    \nnull 2->4->5->7->null \n \nI     p  c    \n5->2->4->7->null \nH \n \nI        p  c    \n5->7->2->4->null \nH"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Traverse the linked list. If you find a odd number insert that number in front of the linked list and continue. At the end of the iteration all the odds will appear before even."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"C code:  Logic is simple. If the first element is even, then search for the first odd element (this is important). Then, adjust even and odd pointers so that they are one step behind the curr element being checked. Then check the value of curr->val % 2. If its zero, then add it to even list otherwise add to odd list. The main thing to observe is that at any given point in time, even and odd pointers should be one step behind the curr pointer. I ended up using a lot of temp variables, hope somebody can provide good suggestions."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what if: The head node, which may be odd-valued or even-valued, should remain unchanged.  For the general case where the given list has both odd-valued nodes and even-valued nodes, the processed list would take the form of odd1 -> even1 -> odd2 -> even2 -> ... if the head node is odd-valued, or  even1-> odd1-> even2-> odd2 -> ...if the head node is even-valued.  The order in which the odd-valued nodes appear in the given list should be preserved when the list is processed, AND similarly for the order of the even-valued nodes.  Any nodes (may be odd-valued or even-valued) in the given list that cannot be interleaved (because there are no more \"partners\" left) should appear as the tail portion of the processed list AND in the same order as they appear in the given list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it makes studying efficient"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this is similar kind of problem in which there is a link list having only 0 and 1. You have to arrange the no such that all 0 come before 1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void RearrangeListStable(listptr *head) \n{ \n listptr cur, prev, evenList, firstEven, lastEven; \n int i, len; \n i=0; len = findLength(*head); \n if(len <= 1) // nothing to rearrange \n  return; \n evenList = firstEven = lastEven = prev = NULL; \n cur = *head; \n while(idata %2 == 0) // if even \n  { \n   firstEven = lastEven = cur; \n   while(lastEven->link && lastEven->link->data %2 == 0) \n   { \n    lastEven = lastEven->link; \n    i++; \n   } \n \n   if (lastEven->link == NULL && prev == NULL) //the entire list contains even \n    break; \n \n   else if(prev) \n   { \n    prev->link = lastEven->link; \n    cur = prev; \n   } \n \n   else if (!prev) \n    *head = cur = lastEven->link; \n \n   lastEven->link = NULL; \n   if(!evenList) \n    evenList = firstEven; \n   else \n    appendList(&evenList, firstEven); \n  } \n  prev = cur;  \n  cur = cur->link; \n  i++; \n } \n \n appendList(head, evenList); \n displayList(*head); \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=1715697","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"33","title":"Given a singly linked list, swap every two elements (e.g. a->b->c->d->e->f->null should become b->a->d->c->f->e->null). Code it such that memory position is swapped and not the node value.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Dont think the solutions above will give right response  here's my recursive algo node* swap (node* root) {     if (root==NULL) return NULL;     if (root->link==NULL) return root;     node* first, second;     first = root;     second = root->link;     first->link= swap(second->link);     second->link=first; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"algopadawan(dot)blogspot(dot)com/2012/05/k-reverse-linked-list(dot)html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void swap()   {    int len=count();    node *start=p;    node *prev=NULL;    node *temp=NULL;    for(int i=0;i   {     if(start==p)     {      temp=start->next;      start->next=start->next->next;      temp->next=start;      prev=start;      start=start->next;      p=temp;     }     else     {      temp=start->next;      start->next=start->next->next;      temp->next=start;      prev->next=temp;      prev=start;      start=start->next;     }    }   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct node* exchange(struct node* node) { if(node==NULL || node->next==NULL) return node; struct node* p=node, *q=node->next; do { p->next = q->next; if(p==node) node=q; q->next=p; p=p->next; if(p != NULL) q=p->next; } while(p!=NULL || q!=NULL); return node; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int pairwise() \n                { \n                        struct node* t=p; \n                        struct node* s; \n                        while(t!=NULL && t->l!=NULL) \n                        { \n                                s=t->l; \n                                t->l=t->l->l; \n                                s->l=t; \n                                if(t==p) \n                                  p=s; \n                                t=t->l; \n                                if(t->l!=NULL) \n                                        s->l->l=t->l; \n \n                        } \n                }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void swap(int *a, int *b); {   int temp;   temp = *a;   *a = *b;   *b = temp; } /* Function to pairwise swap elements of a linked list */ void pairWiseSwap(struct node *head) {   struct node *temp = head;      /* Traverse further only if there are at-least two nodes left */   while(temp != NULL && temp->next != NULL)   {     /* Swap data of node with its next node's data */     swap(&temp->data, &temp->next->data);       /* Move temp by 2 for the next pair */     temp = temp->next->next;   } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"start = head j = 1; while(start != null) n = start; n = n->next; j++; if(j == jump) {   j = 1;   saveNext = n->next;   n->next = null;   node* last = Reverse(start);   last->next = saveNext;   start = saveNext; }  Node * Reverse(Node* n) {   prev = null;   cur = n;   next;   while(cur != null)    next = cur->next;    cur->next = prev;     prev = cur;    cur = next; }  return prev;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"> 1->2->3->4->5->1(this is circular one)  Is the 1 at the beginning and the end the same node?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"they always ask to write a running code on paper. so practice to write a code... anyone with the code !!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"there is nothing to test about the logic in this question, interviewer is trying to test the pointer manipulation. here we need to handle specially for head pointer. i.e for Head node and Head-> next nodes swap , swap using **Headref, i,e change the head node points to..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"assume temp1 is a typo for temp"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Will it be eassier to just swap data instead of pointer?? Also, we can use recursion to perform swapping for simple linked list...I am not sure if that can be done for circular linked list too."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//L is header  Node t1,t1,temp; if(L->next!=NULL) {    t1=L->next;    t2==t1->next;    temp=t2->next;    L->next=t2;    t2->next=t1;    t1->next=temp;    temp=t1; }     while(temp!=null) { t1=temp->next; t2=t1->next; t3=t2->next; temp->next=t2; t2->next=t1; t1->next=t3; temp=temp->next->next; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"boundary case : either you are at last node or you are not if you get circular list, two case might happen: a.)either your next node refers to first node(means you have one next node with which you can swap) - swap and quit b.) or next node refers to second node in list(means you are at the last node) - quit here"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the simplest I could get it:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the C++ Code for this problem"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There r two way to solve this prob : 1.Without Recursion. 2.With Recursion.  [1]Without Recursion:  node* swapList(node *firstNode) { node *head,*prev;  if(node==NULL) //if List is empty  {   printf(\"List is Empty\");  }  if(node->link==NULL)//if List is having Single node  {   printf(\"List is having single node\");   head=firstNode;  }  if(firstNode->link->ink!=NULL)//to set head of the new list.It will swap only starting two nodes.  {    head=firstNode->link;   firstNode->link=head->link;   head->link=firstNode;  }  while(firstNode->link->link!=NULL)//swap remaining nodes  {   prev=firstNode;   firstNode=firstNode->link;   prev->link=firstNode->link;   firstNode->link=firstNode->link->link;   prev->link->link=firstNode;  }  return head; }  [2]With recursion:  node* swapList(node *firstNode) { node *head,*prev;  if(node==NULL) //if List is empty  {   printf(\"List is Empty\");  }  if(node->link==NULL)//if List is having Single node  {   printf(\"List is having single node\");   head=firstNode;  }  if(firstNode->link->ink!=NULL)//to set head of the new list.It will swap only starting two nodes.  {    head=firstNode->link;   firstNode->link=head->link;   head->link=firstNode;  }  swap(firstNode);  return head; } //-------------------------------- swap(node *ptr) {  node *prev; if(ptr->link->link!=NULL)  {   ptr=ptr->link->link;   swap(ptr);  }   prev=ptr;   ptr=ptr->link;    prev->link=ptr->link;   ptr->link=ptr->link->link;   prev->link->link=ptr; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ptr=head; pptr=NULL; while(ptr->next!=NULL) {     temp=ptr->next->next;     ptr->next->next=ptr;     if(pptr!=NULL)     {       pptr->next=ptr->next;     }     pptr=ptr;     ptr->next=temp;          ptr=ptr->next; }  //looking forward to constructive suggestions"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"swap_pairs (list *p1) \n{ \n    list *temp = NULL, *prev = NULL; \n    while (p1 != NULL) { \n        if (p1->next) { \n            temp = p1->next; \n            p1->next = temp->next; \n            temp->next = p1; \n            if (prev) { \n                prev->next = temp; \n                prev = p1; \n            } \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct node *swapper2(struct node *l1) { struct node *head; struct node *p *q,*r; p=l1; q=l1->next; head=p; count=2; while(q && --count) { r=q->next; q->next=p; p=q; q=r; } head->next=swapper2(q); return p;   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Node* reverse(Node *Root) \n    { \n        Node* nRoot,temp ; \n        if(Root==null) return null; \n        nRoot = Root->next; \n        if(nRoot==null) return Root; \n         \n        while(root!=null) \n        { \n            temp = root->next; \n            root->next = temp->next; \n            temp->next = root; \n            root=root->next;  \n        }  \n      return nRoot; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"tum sab log mera loda chuso"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=3691807","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"29","title":"Linked List with following structure..","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"My guess is for min. space, mergesort should be applied, which is in-place and  O(N log N).  I am trying to come up with the code."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Best solution i think is... Considering a BST on given inputs  struct node {     int data;     struct node *next;     struct node *next_larger; }  So each node has link to next node = (left node if available else NULL) as well as its next highest node = (right node if available else its parent node).  Simple!..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"class Node { \n public T data; \n public Node next; \n public Node nextLarge; // To point the next large element in the list \n \n Node (T t) \n { \n  data = t;  \n } \n} \n \n public Node applicationOfMergeSort(Node head) \n { \n  if(head == null || head.next == null) return head; \n  else \n  { \n   Node slow = head; \n   Node fast = head; \n \n   //Split \n   while(fast.next != null) \n   { \n    fast = fast.next; \n    if(fast.next != null) \n     fast = fast.next; \n    else \n     break; \n \n    slow = slow.next; \n   } \n \n   Node List1 = head; \n   Node List2 = slow.next; \n   Node copyL2 = List2; \n \n   slow.next = null; \n   // Split complete \n    \n   // Recursively Split and then merge until we reach a list of sizes 1 \n   List1 = applicationOfMergeSort(List1); \n   List2 = applicationOfMergeSort(List2); \n \n   //Since List1 will ultimately hold the result of merging do lets reset the head to point to List1,  \n   //head will be returned as a result of this function \n   head = List1;  \n \n \n   //Merge \n   Node prev = null; \n \n   while(List1 != null && List2!= null) \n   { \n    if((Integer) List1.data < (Integer) List2.data) \n    { \n     prev = List1; \n     List1 = List1.nextLarge; \n    } \n    else \n    { \n     Node nextList2 = List2.nextLarge; \n     List2.nextLarge = List1; \n     if(prev == null) \n     { \n      head = List2; \n     } \n     else \n     { \n      prev.nextLarge = List2; \n     } \n \n     prev = List2; \n     List2 = nextList2; \n    } \n   } \n \n   if(List2 != null) \n    prev.nextLarge = List2; \n    \n   // Merging Complete \n \n   // Now make the connection of next pointers, broken earlier in the split step \n   slow.next = copyL2; \n   return head; \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"store the linked list value in an array. Sort that array. Now for each data value in linked list find the same data value  in array using binary search. After getting the index of data value in sorted array, get next value from array. complexity will be nlogn"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Sort the list ( keeping the original unaltered) : n log n 2) Hash the sorted list ( Key = value, Value = Next pointer in sorted list) 3) Walk through the original list, looking up the hash and setting the next->larger to point to the value in the hash.  Time Complexity: O(n log n) Space = 2n  Or you could do an n2 algorithm walking through the list and finding the next larger element for all the elements"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class Node { \n    int value; \n    Node next; \n    Node nextbigger; \n \npublic void listSort(){ \n \n    Node list, current, q, e, tail=null; \n    int insize, merges, psize, qsize, i; \n \n    current = this; \n    while(current != null){ \n        current.nextbigger = current.next; \n        current = current.next; \n    } \n    if(this == null) \n        return; \n \n    insize = 1; \n \n    list = this; \n    while(true){ \n        current = list; \n        list = null; \n        tail = null; \n        merges = 0; \n \n        while (current != null) { \n            merges++; \n            q = current; \n            psize = 0; \n            for (i = 0; i < insize; i++) { \n                psize++; \n            q = q.nextbigger; \n            if (q == null) \n                    break; \n            } \n \n            qsize = insize; \n \n             while (psize > 0 || (qsize > 0 && q!=null)) { \n \n                /* decide whether next element of merge comes from p or q */ \n                if (psize == 0) { \n      /* p is empty; e must come from q. */ \n      e = q; q = q.nextbigger; qsize--; \n \n  } else if (qsize == 0 || q == null) { \n      /* q is empty; e must come from p. */ \n      e = current; \n                    current = current.nextbigger; \n                    psize--; \n \n  } else if (current.value <= q.value ) { \n      /* First element of p is lower (or same); \n       * e must come from p. */ \n      e = current; current = current.nextbigger; psize--; \n \n  } else { \n      /* First element of q is lower; e must come from q. */ \n      e = q; q = q.nextbigger; qsize--; \n \n  } \n \n \n                if (tail != null) { \n      tail.nextbigger = e; \n  } else { \n      list = e; \n  } \n \n                tail = e; \n             } \n            current = q; \n        } \n \n        tail.nextbigger = null; \n \n        if (merges <= 1)   /* allow for merges==0, the empty list case */ \n            return ; \n \n        /* Otherwise repeat, merging lists twice the size */ \n        insize *= 2; \n \n    } \n \n} \n \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For each node let next_larger = next, and sort the linked list treating next_larger pointer as next pointer, I think this problem is just sorting a linked list, the interviewer was just being wise, which I think is pretty stupid.  It is exactly like following: I have following data structure, where initial_next pointer points to its next element while next pointer all points null, sort the list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The above understanding of the problem is correct.  Here's code to sort the list using merge sort in C. Simple merge sort routine has been modified to sort a linked list. Its a no brainer. The quality of the code isn't great."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"well i feel better idea would be to use max-heap as a priority queue Insert all the nodes into the list. Use an additional variable to store the popped node. Initially its null  for the given list 3-> 1-> 6-> 5-> 4  Pop the first one 6 and point it to the variable so 6-> null replace the variable with the current node  then pop next.. here 5 and point 5 to the variable so it is 5-> 6 and so on  overall complexity to add and remove from heap is log n and to traverse the list to push it into the tree is n  therefore it is n + logn = n"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think BST is a good solution.  If list is 3->1->6->5->4 then we ll make a BST out of it.         3 next  / \\nxt_bigger      1   6          /         5        /       4  After creating we'll traverse the tree using inorder then we ll get  1->3->4->5->6  This is the desired result."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The problem can solve in space with time complexity of nlogn.   list* merge(list* l1,list *l2){    if(!l1) return l2;    if(!l2) return l1;    if(l1->datadata){         l1->next_larger = merge(l1->next_larger, l2);         return l1;    }    else{         l2->next_larger = merge(l1, l2->next_larger);         return l2;      }  }  //use the above  merge code  list* sort(list* l){    //split l into 2 parts l1,l2     //merge and return the  list }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Does not it look like you have a infinite loop of nodes coming and you need to do insert sorted  1) traverse the list 2) update the Nexthigher pointer based on the insertsorted link list logic"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Copy the Next pointer value to Greater pointer  2) Sort using mergesort based upon greater pointer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use min Priority Queue (PQ) 1. Put all number in the PQ - store the node pointer and the data. Min on data 2. Take the min (top most element - say \"node\") 3. Set the \"node\"->nextbigger to the top element in the PQ (peek the next element in the PQ) 4. Repeat 2-4 till one element is left in PQ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node* merge(Node* first, Node* second) \n{ \n    Node* result = NULL; \n     \n    if (!first) \n        return second; \n     \n    if (!second) \n        return first; \n     \n    if (first->data() <  second->data()) { \n        result = first; \n        result->setNextLarger(merge(first->nextLarger(), second)); \n    } \n    else { \n        result = second; \n        result->setNextLarger(merge(first, second->nextLarger())); \n    } \n     \n    return result; \n} \n \nNode* sort(Node* root, int listLength) \n{ \n    if (!root || !root->next() || listLength <= 1) \n        return root; \n     \n    int middle = listLength / 2; \n    int index = 0; \n    Node* middleNode = root; \n     \n    while (index < middle) { \n        middleNode = middleNode->next(); \n        index += 1; \n    } \n     \n    return merge(sort(root, middle), sort(middleNode, listLength - middle)); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it is really easy but asked by smartness hats off to interviewr to ask such easy question with different way good one :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Traverse the link list & do next_large = next; //Means next_large points same next node. 2. Now assume its a single link list, which is having one pointer next_large. 3. Now sort this single link list in ascending order."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You could copy the value of next into next_larger, then sort the list using nlogn algo, then swap values of next and next_larger."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5724466092965888","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"31","title":"2.Given an integer linked list of which both first half and second half are sorted independently. Write a function to merge the two parts to create one single sorted linked list in place [do not use any extra space].   Sample test case:   Input: List 1:1->2->3->4->5->1->2; Output: 1->1->2->2->3->4->5   Input 2: 1->5->7->9->11->2->4->6; Output 2: 1->2->4->5->6->7->9->11   C/C++/Java/C#   struct node  {  int val;  node *next;  }   node* sortList(node* list1) {  }   Java   class Node  {  int val;  Node next;  }   Node sortList(Node list1) {  }","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Check if the list is null or it is sorted, if yes, return.  Otherwise, have a pointer starting from the beginning, iterate until find the beginning of the second half, call it p2. Have p1 pointing at the beginning of the array, merge them to a new linkedlist by manipulating the pointers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"struct node *sortlist(struct node *root) { \n \n struct node *middle = NULL, *later = NULL, *parent = NULL, *pwalk2 = NULL; \n if(NULL == root) { \n  return root; \n } \n  \n middle = root; \n while(middle->next) { \n   \n  if(middle->data <= middle->next->data) \n   middle = middle->next; \n  else  \n   break; \n } \n  \n if(middle->next) { \n    \n    \n   later = middle->next; \n   \n  /*special case when node goes on top*/ \n  if(later->data < root->data) { \n   if(later->next != NULL) \n    middle->next = later->next; \n   else { \n    middle->next = NULL; \n    later->next = middle; \n    return later; \n   } \n   later->next = root;  \n   root = later; \n    \n  } \n   \n  /*goes in somewhere middle*/ \n  parent = root; \n  while(middle->next) { \n   pwalk2 = parent->next; \n   while(pwalk2 != middle->next) { \n     \n     \n    later = middle->next; \n    if(later->data <= pwalk2->data) { \n    \n     if(later->next != NULL) \n      middle->next = later->next; \n     else  \n      middle->next = NULL;    \n    \n     parent->next = later; \n     later->next = pwalk2; \n     break; \n    } \n    parent = pwalk2; \n    pwalk2 = pwalk2->next; \n   } \n   \n  } \n  return root; \n  \n } else { \n  \n  return root; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public static Node merge(Node n1, Node n2) { \n    if (n1 == null) return n2; \n    if (n2 == null) return n1; \n \n    if (n1.value < n2.value) { \n        n1.next = merge(n1.next, n2); \n        return n1; \n    } else { \n        n2.next = merge(n2.next, n1); \n        return n2; \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"// Solution using  C# \n public void Merge2SortSingleList(Node startNode ) \n        { \n            Node head = startNode; \n            int count = 1; \n \n            while ( head.data < head.next.data )  \n            { \n                head = head.next; \n                count++; \n            } \n \n            if (head.next != null) \n            { \n                Node pervious = null; \n                Node split = head; \n                head = head.next; \n \n                while (count > 1 && head.next != null) \n                { \n                    if ( startNode.data < head.data) \n                    { \n                        pervious = startNode; \n                        startNode = startNode.next; \n                        count--; \n                    } \n                    else if ( startNode.data => head.data) \n                    { \n                        split.next = head.next; \n                        pervious.next = head; \n                        head.next = startNode; \n                        pervious = head; \n                        head = split.next; \n                    } \n                } \n                 \n                if (head.next == null) \n                { \n                    if  (startNode.data => head.data) \n                    { \n                        split.next = head.next; \n                        pervious.next = head; \n                        head.next = startNode; \n                    } \n                } \n            } \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"The solution is in Java ....  1. First split the list into two separate sorted lists (List1, List2) 2. Merge the lists to return single sorted list"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"So based on the example you give, they are not exactly first half and second half. Should be the first part and second part."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a variation of the merging two sorted linked lists problem. You would need to traverse the linked list till the point where the next node value is greater than the current node value. By doing this you can figure out the starting of two sorted linked list. Then merge the two sorted linked list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi, was this question in an online assessment test?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Writing my solution in Java"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"keep in mind the question says do not use any extra space, which means even an extra single bit is not allowed.  How can that be possible?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution proposal in C++:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Break the linked list when the value is less than the previous value. 2. Now you have two linked lists, one sorted and other sorted in reverse order. 3. Reverse the second linked list which is sorted in reverse order. 4. Merge the sorted linked lists"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #include struct node {  int val;  struct node* next;        };  struct node* create_node(int value) {        struct node *ptr;        ptr=(struct node*)malloc(sizeof(struct node));        ptr->val=value      ;        ptr->next=NULL; } void display(struct node* head) {          while(head!=NULL)                {                 printf(\"%d \",head->val);                 head=head->next;                                 }          printf(\"\\n\");             } struct node * merge(struct node *ptr1,struct node *ptr2) {  struct node* result=NULL;  if(ptr1==NULL)   return ptr2;  else if(ptr2==NULL)   return ptr1;  if(ptr1->val < ptr2->val)  {   result=ptr1;   result->next=merge(ptr1->next,ptr2);     }  else  {   result=ptr2;   result->next=merge(ptr1,ptr2->next);  }  return result; } sort(struct node **head) {  if(*head==NULL||(*head)->next==NULL)   return ;  struct node *ptr1=*head;  struct node*  prv=ptr1;  struct node* ptr2;  ptr1=ptr1->next;  while(prv->valval)  {   prv=ptr1;   if(ptr1->next==NULL)    return;   ptr1=ptr1->next;  }  ptr2=ptr1;  prv->next=NULL;    *head=merge(*head,ptr2); }   int main() {     struct node *head;     head=create_node(1);     head->next=create_node(2);     head->next->next=create_node(3);     head->next->next->next=create_node(4);     head->next->next->next->next=create_node(5);     head->next->next->next->next->next=create_node(1);     head->next->next->next->next->next->next=create_node(2);     //display(head);     sort(&head);     display(head);      }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nusing namespace std; \n \nstruct node \n{ \n        int val; \n        node* next; \n}; \n \nvoid add(struct node** p,int n) \n{ \n        struct node* temp= new node; \n        //struct node* temp = \n        //              (struct node*) malloc(sizeof(struct node)); \n        temp->val=n; \n        temp->next=NULL; \n        if(*p==NULL) \n        { \n                *p=temp; \n        } \n        else \n        { \n                struct node* mover=*p; \n                while(mover->next!=NULL) \n                        mover=mover->next; \n                mover->next=temp; \n        } \n} \nvoid display(struct node* p) \n{ \n        struct node*temp=p; \n        cout<next!=NULL) \n        { \n                cout<val<<\" --> \"; \n                temp=temp->next; \n        } \n        cout<val<<\" --> NULL\"<next->val > temp->val) \n                temp=temp->next; \n        struct node*ptr1,*ptr2,*ptr1_prev,*ptr2_prev; \n        ptr1=*p; \n        ptr1_prev=NULL; \n        ptr2=temp->next; \n        ptr2_prev=NULL; \n        temp->next=NULL; \n        while(ptr1!=NULL && ptr2!=NULL) \n        { \n                if(ptr1->val > ptr2->val) \n                { \n                        if(ptr1_prev==NULL && ptr2_prev ==NULL) \n                        { \n                                ptr2_prev=ptr2; \n                                ptr2=ptr2->next; \n                                ptr2_prev->next=*p; \n                                *p=ptr2_prev; \n                                ptr1_prev=*p; \n                                ptr2_prev=NULL; \n                        } \n                        else \n                        { \n                                ptr2_prev=ptr2; \n                                ptr2=ptr2->next; \n                                ptr1_prev->next=ptr2_prev; \n                                ptr2_prev->next=ptr1; \n                                ptr1_prev=ptr2_prev; \n                                ptr2_prev=NULL; \n                        } \n                } \n                else \n                { \n                        ptr1_prev=ptr1; \n                        ptr1=ptr1->next; \n                } \n \n        } \n        if(ptr1==NULL) \n        { \n                ptr1_prev->next=ptr2; \n        } \n \n} \n \n \nint main() \n{ \n        struct node *p=NULL; \n        int n; \n        cout<<\"\\nEnter space separated input(-1 at the end of input)\\n\\n\"; \n        while(cin>>n) \n        { \n                if(n==-1) \n                        break; \n                else \n                        add(&p,n); \n        } \n        cout<<\"\\nInput\\n\"; \n        display(p); \n        mergelist(&p); \n        cout<<\"\\nOutput\\n\"; \n        display(p); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include   struct node {  int val;  struct node * next; };  void create_linklist(struct node **, int); void display(struct node *); void sort_linklist(struct node **);  int main() {  struct node *p = NULL;  create_linklist(&p, 2);  create_linklist(&p, 1);  create_linklist(&p, 5);  create_linklist(&p, 4);  create_linklist(&p, 3);  create_linklist(&p, 2);  create_linklist(&p, 1);  //create_linklist(&p, 1);  display(p);  printf(\"\\n\");  sort_linklist(&p);  display(p);  return 0; }  void create_linklist(struct node **q, int num) {  struct node *temp = (struct node*) (malloc(sizeof(struct node)));  temp->val = num;  temp->next = *q;  *q = temp; }  void display(struct node *q) {  while (q) {   printf(\"%d\\t\", q->val);   q = q->next;  } }  void sort_linklist(struct node **q) {  if (!(*q))   return;  else {   struct node *temp1 = *q;   struct node *temp2 = *q;   struct node *temp3;   while ((temp1->next) && (temp1->val < temp1->next->val))    temp1 = temp1->next;    if (!(temp1->next))    return;   *q=temp2;   while (temp1->next)    {    if (temp1->next->val < temp2->val)     {     temp3 = temp1->next;     temp1->next = temp3->next;     temp3->next = temp2;     temp2 = temp3;     *q=temp3;     }    else     {     while (temp2->next->val < temp1->next->val)     temp2 = temp2->next;     temp3 = temp1->next;     temp1->next = temp3->next;     temp3->next = temp2->next;     temp2->next = temp3;     temp2 = temp3;    }   }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \nstruct node { \n int val; \n struct node * next; \n}; \n \nvoid create_linklist(struct node **, int); \nvoid display(struct node *); \nvoid sort_linklist(struct node **); \n \nint main() { \n struct node *p = NULL; \n create_linklist(&p, 2); \n create_linklist(&p, 1); \n create_linklist(&p, 5); \n create_linklist(&p, 4); \n create_linklist(&p, 3); \n create_linklist(&p, 2); \n create_linklist(&p, 1); \n //create_linklist(&p, 1); \n display(p); \n printf(\"\\n\"); \n sort_linklist(&p); \n display(p); \n return 0; \n} \n \nvoid create_linklist(struct node **q, int num) { \n struct node *temp = (struct node*) (malloc(sizeof(struct node))); \n temp->val = num; \n temp->next = *q; \n *q = temp; \n} \n \nvoid display(struct node *q) { \n while (q) { \n  printf(\"%d\\t\", q->val); \n  q = q->next; \n } \n} \n \nvoid sort_linklist(struct node **q) { \n if (!(*q)) \n  return; \n else { \n  struct node *temp1 = *q; \n  struct node *temp2 = *q; \n  struct node *temp3; \n  while ((temp1->next) && (temp1->val < temp1->next->val)) \n   temp1 = temp1->next; \n \n  if (!(temp1->next)) \n   return; \n  *q=temp2; \n  while (temp1->next) \n   { \n   if (temp1->next->val < temp2->val) \n    { \n    temp3 = temp1->next; \n    temp1->next = temp3->next; \n    temp3->next = temp2; \n    temp2 = temp3; \n    *q=temp3; \n    } \n   else \n    { \n    while (temp2->next->val < temp1->next->val) \n    temp2 = temp2->next; \n    temp3 = temp1->next; \n    temp1->next = temp3->next; \n    temp3->next = temp2->next; \n    temp2->next = temp3; \n    temp2 = temp3; \n   } \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void mergeLinklist(Linklist l1,Linklist l2) {  lnode current =l1.root;     lnode wait;  while (current.data < current.link.data)  {   current = current.link;  } lnode start=l1.root; current=current.link; wait=current;  while (start!=null && current!=null)  {       if (start.data < current.data)   {    l2.insert(start.data);    start= start.link;   }   else   {    l2.insert(current.data);    current = current.link;   }  }    while (start!=wait)  {   l2.insert(start.data);   start= start.link;  }    while (current!=null)  {   l2.insert(current.data);   current = current.link;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My implementation in C."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct node* sortList(struct node* head) \n{ \n        struct node* curr = head; \n        while(curr->next) \n        { \n                if (curr->next->data >= curr->data) \n                curr = curr->next; \n                else \n                break; \n        } \n \n        struct node* begin = curr->next;                // begin ->  first element of second list \n        struct node* state = head;                      // state ->  element which will be compared next from first list \n        struct node* prev = NULL;                       // prev  ->  element just before state in the linked list \n        while(state->next) \n                                        { \n                                                if ( state == begin ) \n                                                        { \n                                                                begin = begin->next; \n \n                                                        } \n                                                else{ \n                                                if (begin->data >= state->data) \n                                                        { \n                                                                prev = state; \n                                                                state=state->next; \n                                                        } \n                                                else    { \n                                                curr->next  = begin->next; \n                                                if (prev == NULL) \n                                                        head = begin; \n                                                else \n                                                        prev->next = begin; \n                                                begin->next = state; \n                                                prev = begin; \n                                                begin = curr->next; \n                                                        } \n                                                } \n                                                if (begin == NULL) \n                                                        break; \n                                        } \n \n        return head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct node* sortList(struct node* head) \n{ \n        struct node* curr = head; \n        while(curr->next) \n        { \n                if (curr->next->data >= curr->data) \n                curr = curr->next; \n                else \n                break; \n        } \n \n        struct node* begin = curr->next;                // begin ->  first element of second list \n        struct node* state = head;                      // state ->  element which will be compared next from first list \n        struct node* prev = NULL;                       // prev  ->  element just before state in the linked list \n        while(state->next) \n                                        { \n                                                if ( state == begin ) \n                                                        { \n                                                                begin = begin->next; \n \n                                                        } \n                                                else{ \n                                                if (begin->data >= state->data) \n                                                        { \n                                                                prev = state; \n                                                                state=state->next; \n                                                        } \n                                                else    { \n                                                curr->next  = begin->next; \n                                                if (prev == NULL) \n                                                        head = begin; \n                                                else \n                                                        prev->next = begin; \n                                                begin->next = state; \n                                                prev = begin; \n                                                begin = curr->next; \n                                                        } \n                                                } \n                                                if (begin == NULL) \n                                                        break; \n                                        } \n \n        return head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void sortList(node **head1){ \n \n    //1-->2-->3-->4-->5-->0-->2 \n    node *current=*head1; \n    while( current != NULL && current->next!=NULL && current->data < current->next->data ){ \n        current=current->next; \n    } \n \n    if (current == NULL){ \n        return; \n    } \n \n    node *head2=current; \n    if (head2->next != NULL && head2->next->data<(*head1)->data) \n    { \n        node *temp=head2->next; \n        current->next=head2->next->next; \n        temp->next=*head1; \n        *head1=temp; \n        head2=current; \n    } \n    node *prev=head2; \n    head2=head2->next; \n    node *head=*head1; \n    while(head2!=NULL){ \n        if(head2->data <= head->next->data){ \n            node *temp=head2; \n            prev->next=head2->next; \n            insert(head,temp); \n            head=head->next; \n            head2=prev->next; \n        } \n        else{ \n            head=head->next; \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void MergeHalfSortedList(stIntList* pHead) {  if(NULL == pHead)   return;   stIntList* pTemp = pHead;  stIntList* pHead2 = pHead;  stIntList* pList1Last = pHead;  while(pHead2 != NULL)  {   if(pHead2->pNList != NULL && pHead2->data > pHead2->pNList->data) //condition when second list head is found   {    pList1Last = pHead2;    pHead2 = pHead2->pNList;    break;   }    pList1Last = pHead2;   pHead2 = pHead2->pNList;  }   if(pHead2 == NULL)  {   std::cout<<\"\\nList is already Sorted\\n\";   return;  }   //Now Head 2 is found Merge them into single list  stIntList* pTemp2 = pTemp;  stIntList* pRoot = NULL;  stIntList* pCurr = NULL;  pList1Last->pNList = NULL;  while((pTemp2 != NULL) && (pHead2 != NULL))  {   if(pCurr == NULL)   {    if(pTemp2->data > pHead2->data)    {     pCurr = pHead2;     pHead2 = pHead2->pNList;    }    else    {     pCurr = pTemp2;     pTemp2 = pTemp2->pNList;    }    pRoot = pCurr;    continue;   }    if(pTemp2->data > pHead2->data)   {    pCurr->pNList = pHead2;    pCurr = pCurr->pNList;    pHead2 = pHead2->pNList;     }   else   {    pCurr->pNList = pTemp2;    pCurr = pCurr->pNList;    pTemp2 = pTemp2->pNList;   }   continue;     }  if(pHead2)  {   while(pHead2)   {    pCurr->pNList = pHead2;    pCurr = pCurr->pNList;    pHead2 = pHead2->pNList;   }  }  else if(pTemp2)  {   while(pTemp2)   {    pCurr->pNList = pTemp2;    pCurr = pCurr->pNList;    pTemp2 = pTemp2->pNList;   }  }   printIntList(pRoot); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void MergeHalfSortedList(stIntList* pHead) {  if(NULL == pHead)   return;   stIntList* pTemp = pHead;  stIntList* pHead2 = pHead;  stIntList* pList1Last = pHead;  while(pHead2 != NULL)  {   if(pHead2->pNList != NULL && pHead2->data > pHead2->pNList->data) //condition when second list head is found   {    pList1Last = pHead2;    pHead2 = pHead2->pNList;    break;   }    pList1Last = pHead2;   pHead2 = pHead2->pNList;  }   if(pHead2 == NULL)  {   std::cout<<\"\\nList is already Sorted\\n\";   return;  }   //Now Head 2 is found Merge them into single list  stIntList* pTemp2 = pTemp;  stIntList* pRoot = NULL;  stIntList* pCurr = NULL;  pList1Last->pNList = NULL;  while((pTemp2 != NULL) && (pHead2 != NULL))  {   if(pCurr == NULL)   {    if(pTemp2->data > pHead2->data)    {     pCurr = pHead2;     pHead2 = pHead2->pNList;    }    else    {     pCurr = pTemp2;     pTemp2 = pTemp2->pNList;    }    pRoot = pCurr;    continue;   }    if(pTemp2->data > pHead2->data)   {    pCurr->pNList = pHead2;    pCurr = pCurr->pNList;    pHead2 = pHead2->pNList;     }   else   {    pCurr->pNList = pTemp2;    pCurr = pCurr->pNList;    pTemp2 = pTemp2->pNList;   }   continue;     }  if(pHead2)  {   while(pHead2)   {    pCurr->pNList = pHead2;    pCurr = pCurr->pNList;    pHead2 = pHead2->pNList;   }  }  else if(pTemp2)  {   while(pTemp2)   {    pCurr->pNList = pTemp2;    pCurr = pCurr->pNList;    pTemp2 = pTemp2->pNList;   }  }   printIntList(pRoot); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#include  #include  struct node { int val; struct node *next; }; typedef struct node node; node *push(node *head,int value) { node *temp=(node *)malloc(sizeof(node)); temp->val=value; temp->next=head; return temp; } void print(node *head) { while(head) { printf(\"%d \",head->val); head=head->next; } printf(\"\\n\"); } node *find_middle(node *head) { node *fast_ptr=head, *slow_ptr=head; while(fast_ptr && fast_ptr->next) { fast_ptr=fast_ptr->next->next; slow_ptr=slow_ptr->next; } return slow_ptr; } node  *merge(node *a, node *b) { node *result; if(!a && !b) return NULL; if(!b) return a; if(!a) return b; if(a->val<=b->val) { result=a; result->next=merge(a->next,b); } else { result=b; result->next=merge(a,b->next); } return result; } int main() { node *start=NULL,*start2,*result; int value; char c; node *middle_node; printf(\"Enter value for list\\n\"); do { scanf(\"%d\",&value); start=push(start,value); printf(\"Do you want to continue ? (y/n)\"); getchar(); c=getchar(); }while(c=='y' || c=='Y'); print(start); middle_node=find_middle(start); start2=middle_node->next; middle_node->next=NULL; result=merge(start,start2); print(result); return 0; }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=10059669","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"28","title":"1- reverse a pair of elements in a linked list. abcd - badc 2 - find 3rd largest in an array in single pass 3 - check  if a tree is symmetrical","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"sorry the above code doesn't work in few cases This one works"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"algopadawan(dot)blogspot(dot)com/2012/05/k-reverse-linked-list(dot)html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// returns head of new list. \npublic Node reverseInPairs(Node head) { \n \n Node first = head; \n Node second = first.next; \n \n if (first == null || second == null) { \n  return head; // can't reverse a singleton/empty list. head remains the same \n } \n \n while (first != null && second != null) { \n  temp = first.next.next; \n  second.next = first; \n  first = temp; \n  second = first.next; \n } \n \n return head.next; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for the first one just recursively call the reversing procedure of linked list code for this  struct node *Group2Reverse(struct node *L) { struct node *p,*q,*r; struct node *head=L; int count=2; p=NULL: if(!L||L->next==NULL) return L; q=L; while(q && count--) { r=q->next; q->next=p; p=q; q=r; } if(q) head->next=Group2Reverse(q); else head->next=NULL  return p; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct node* alternate(struct node *head) {      if(head==NULL||head->next==NULL)         return head;       struct node* current=head->next;       struct node* next=current->next;       current->next=head;       head->next=alternate(next);       return current; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static boolean issym(Node root) {  if(root==null) return true;  return iss(root.left,root.right);  }  public static boolean iss(Node l, Node r) { if(l==null && r==null) return true;  if(l!=null && r!=null && l.data==r.data) return (iss(l.left,r.right) && iss(l.right,r.left));  return false;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static Node rev(Node s) { if(s==null or s.next==null) return ;  Node c=s; Node a=s; Node b=a.next; Node first; a.next=b.next; b.next=a; first=b;  c=a;   a=a.next; b=a.next;   while(a!=null && b!=null) { a.next=b.next; b.next=a; c.next=b; c=a; a=a.next; if(a==null ||a.next==null) b=null; else b=a.next;  } return first;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public Node reversePairsSLL(Node head){   Node first=head, second=first.next, third=second.next;   if(first==null || second==null) return head;   head=second;   while(first!=null && second!=null){   second.next=first;   if(third.next==null)first.next=third;else first.next=third.next;   first=third;   second=first.next;   if(second==null) return head;   third=second.next;   }   return head;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"guys if you will post your logic in pseudo code.. i think that will be much faster to understand the logic ...!! -Thanks"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For reversing the pair of elements, do it smart by changing just the values temp = node.value; node.value=node.next.value; node.next.value=temp node = node.next.next"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"check this for answer for symmetrical tree"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have a question- what's the definition of a symmetric binary tree?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"BR: Block reversal \nt : tail \ncn = current node \nk = size of block; 2 in this case \nr: Resultant linked list \nBR() \n r = NULL \n t = cn \n for each i from 0 to k-1 \n  if(cn) \n   tmp = cn->n \n   cn->n = r \n   cn = t     \n t->n = BR(cn) \n return r"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the code for reversing elements in linked list.I think it works fine.  lass Node { int x; Node next=null; Node() {   } Node(int r) {  x=r; } void insert(int xx) {   Node temp=this;  while(temp.next!=null)    temp=temp.next;  Node n=new Node(xx);  temp.next=n; } void display() {Node temp=this;  while(temp.next!=null)  {   System.out.println(\"num=\"+temp.x);   temp=temp.next;  }  System.out.println(\"num=\"+temp.x); } } public class job {  public static void main(String []args){ Node head=new Node(0); for (int i=1;i<10;i++)  head.insert(i); head.insert(10); //for (int i=10;i>0;i--)  //head.insert(i); //head.display(); Node xx;Node yy; xx=head;yy=xx.next; while(xx!=null&&yy!=null) {  int temp=xx.x;  xx.x=yy.x;  yy.x=temp;  if(xx.next.next!=null&&yy.next.next!=null)  {  xx=xx.next.next;  yy=yy.next.next;  }  else{  xx=null;yy=null;  }   } head.display(); } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct node* reverse(struct node *head, int k)    {       struct node *prev = NULL, *current = head, *next;       int count = 0;           while(current != NULL && count < k)       {          next = current -> next;          current -> next = prev;          prev = current;          current = next;       }           if(next != NULL)          head -> next = reverse(next, k);                 return prev;    } Put k = 2 for this case"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void swap(struct node **front) {         struct node *cur, *temp,*prev;         if(!(*front))         printf(\"no elemet in the list\\n\");         else         {                 cur=*front;                 if(!cur->next)                         ;                else                 {                         cur=cur->next;                         if(!cur->next)                         {                                 cur->next=*front;                                 (*front)->next=NULL;                                 *front=cur;                         }                         else                         {                                 prev=cur;                                 cur=cur->next;                                 prev->next=*front;                                 (*front)->next=cur;                                 temp=*front;                                 *front=prev;                                 prev=cur;                                 cur=cur->next;                                 while(prev && cur)                                 {                                         prev->next=cur->next;                                         cur->next=prev;                                         temp->next=cur;                                         temp=prev;                                         prev=prev->next;                                         if(prev)                                         cur=prev->next;                                 }                         }                 }         } return; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#include  \nint third_biggest(int *arr, int size) \n{ \n int first = INT_MIN, second = 0, third = 0; \n for(int i=0;i first) \n  { \n   third = second; \n   second = first; \n   first = arr[i]; \n  } \n } \n return third; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=219717","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"26","title":"Telephoic:  Given a linked list, findout wether it is a palindrome or not,  I have given a solution with extra space, after that he asked as .. No extra space is allowed,  expecting most efficient","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Copied from Geeksforgeeks  Here is the solution.  Algorithm:     1.  Get the middle of the linked list.    2.  Reverse the second half of the linked list.    3.  Compare the first half and second half.    4.  Construct the original linked list by reversing the        second half again and attaching it back to the first half  Implementation:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"bool helpFunction(Node **head , Node *tail) \n{ \n Node *t = tail; \n if(t==null) \n { \n  return true; \n } \n  \n if(helpFunction(head , t->next)) \n { \n  Node * h = *head; \n  if(h->Data == t->Data) \n  { \n   (*head) = (*head)->next;  \n   return true; \n  }  \n } \n \n return false; \n \n \n} \nbool IsPalidrome(Node * head) \n{ \n Node * head1 = head; \n Node * tail = head->next; \n  \n return helpFunction(&head,tail); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool find(node* node, int i) { \n   static node* head = node; \n   static int ispalindrome = true; \n \n   if (node) { \n      ispalindrome = find(node->next); \n \n      if (ispalindrome && (node->data != head->data)) { \n         ispalindrome = false; \n      } \n \n      head = head->next; \n   } \n \n   return ispalindrome; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here you make use of O(N) space in stack, due to activation record space coz of recursion. Space used wld be equivalent to have a local O(N) array or stack(not on heap)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"http://geeksforgeeks.org/?p=1072"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node IsPallin(Node current, Node head) \n{ \nif( head == null) return null; \n \nif(current->next != null) { \n head = IsPallin(current->next, head) \n} \nif(current->info != head->info) return null; \n \nreturn head->next ?? head; \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can be done in o(n)time. halve it; revert first half;compare;revert first half again."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n) approach: a bit messy though #1. Find the length of the list.  #2. Assuming the size is even, keep putting/pushing all the elements from the beginning till the mid to a stack[mimic a stack using an array]. Reverse the stack. If you are using array then you just have to traverse it in the reverse order, thats it.  #3. Now Pop out one element and compare that with NexttoMid element in the list. Keep doing this in a loop till,"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Reverse the first half of the list in O(n). Verify for palindrome. Reverse the first half again.  Got the same question in Yahoo!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algorithm:     1.  Get the middle of the linked list.    2.  Reverse the second half of the linked list.    3.  Compare the first half and second half.    4.  Construct the original linked list by reversing the        second half again and attaching it back to the first half"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@Topic starter: u should have said singly linked list. with dll its easy."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A simpler linear solution is as follows:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"singly linke list palindrome...no big deal..just use recursion first find the middle of the list..using one fast and slow iterators.. then traverse second half of the list in reverse order while first half in forward.. compare values use a global variable flag to save the value of comparison. but once the its no longer palindrome..we can't break the recursive calls.. so glabal variable flagchanged is used to keep track of the flag var.  int flag =0; int changedflag =0; node* reverse(node * n1,node* n2) {     if(n1==NULL)       return n2;     else      { node *temp = reverse(n1->next,n2);        if(temp->data == n1->data)        {          if(changedflag==0)             flag=1;        }           else        {           if(changedflag==0)             { flag=0;              changedflag=1;            }                      }        return n2->next;             } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sorry!! indentation went wrong due to copy pasting from editor   int flag =0; int changedflag =0; node* reverse(node * n1,node* n2) {   if(n1==NULL)     return n2;   else   { node *temp = reverse(n1->next,n2);     if(temp->data == n1->data)     {        if(changedflag==0)           flag=1;      }      else     {        if(changedflag==0)         { flag=0;          changedflag=1;         }       }     return n2->next;    } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this:  If extra O(n) space is allowed then. Use 1 stack and 1 queue.  put first half in queue. Second half in stack. Then pop from stack and dequeue from list and compare. If length if list is even both will be empty in the end. Else the middle element will remain, in the stack or queue (your choice)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"best wud be to take two pointers...fast and slow.....find the middle point. now take a third global pointer point it to head...use recursion(NO NEED TO REVERSE THE LIST)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why not this:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ptth://********************geeksforgeeks.org/?p=1072  Remove stars and reverse the \"ptth\" from the above written link,"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* Program to check if a linked list is palindrome */ #include #include #define bool int  /* Link list node */ struct node {     char data;     struct node* next; };  void reverse(struct node**); bool compareLists(struct node*, struct node *);  /* Function to check if given linked list is   palindrome or not */ bool isPalindrome(struct node *head) {    struct node *slow_ptr = head;    struct node *fast_ptr = head;    struct node *second_half;    struct node *prev_of_slow_ptr = head;    char res;     if(head!=NULL)    {        /* Get the middle of the list. Move slow_ptr by 1          and fast_ptrr by 2, slow_ptr will have the |_n/2_|th          node */        while((fast_ptr->next)!=NULL &&                (fast_ptr->next->next)!=NULL)        {           fast_ptr = fast_ptr->next->next;              /*We need previous of the slow_ptr for            linked lists  with odd elements */           prev_of_slow_ptr = slow_ptr;           slow_ptr = slow_ptr->next;        }         /* Case where we have even no of elements */        if(fast_ptr->next != NULL)        {          second_half = slow_ptr->next;          reverse(&second_half);          slow_ptr->next = NULL;          res = compareLists(head, second_half);           /*construct the original list back*/          reverse(&second_half);          slow_ptr->next = second_half;        }         /* Case where we have odd no. of elements. Neither first           nor second list should have the middle element */        else        {           second_half = slow_ptr->next;           prev_of_slow_ptr->next = NULL;           reverse(&second_half);           res = compareLists(head, second_half);           /*construct the original list back*/          reverse(&second_half);          prev_of_slow_ptr->next = slow_ptr;          slow_ptr->next = second_half;        }          return res;    } }  /* Function to reverse the linked list  Note that this     function may change the head */ void reverse(struct node** head_ref) {     struct node* prev   = NULL;     struct node* current = *head_ref;     struct node* next;     while (current != NULL)     {         next  = current->next;         current->next = prev;         prev = current;         current = next;     }     *head_ref = prev; }  /* Function to check if two input lists have same data*/ int compareLists(struct node* head1, struct node *head2) {     struct node* temp1 = head1;     struct node* temp2 = head2;          while(temp1 && temp2)     {        if(temp1->data == temp2->data)        {           temp1 = temp1->next;           temp2 = temp2->next;        }        else return 0;     }      /* Both are empty reurn 1*/     if(temp1 == NULL && temp2 == NULL)        return 1;          /* Will reach here when one is NULL       and other is not */     return 0; }      /* Push a node to linked list. Note that this function   changes the head */ void push(struct node** head_ref, char new_data) {     /* allocate node */     struct node* new_node =             (struct node*) malloc(sizeof(struct node));      /* put in the data  */     new_node->data  = new_data;      /* link the old list off the new node */     new_node->next = (*head_ref);          /* move the head to pochar to the new node */     (*head_ref)    = new_node; }  /* Drier program to test above function*/ int main() {     /* Start with the empty list */     struct node* head = NULL;       push(&head, 'p');      push(&head, 'e');      push(&head, 'e');      push(&head, 'p');                      /* p->e->e->p */      if(isPalindrome(head) == 1)        printf(\"Linked list is Palindrome\");      else        printf(\"Linked list is not Palindrome\");            getchar();      return 0; }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15026777","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"25","title":"Write a function that will return true if a circular singly linked list has duplicate values. For example, given a pointer to a node in the circular singly linked list, *slist, where the only values each node of this list contains int value, and *nxt_pointer.  How would you traverse it and what way will allow you to have the best case for time-complexity? How would we know when the circular singly linked list stops?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"save first node pointer create an empty set while next node is not the first node    check if the node value is already present in the set     if present, current value is a duplicate    else add node value to a set and go to next node  O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"boolean containsDups(Node slist){ \n   \n       Node curr = slist; \n       HashSet set = new HashSet(); \n       do{ \n           \n            if(set.contains(curr.value)) \n                return true; \n            else {  \n                 set.add(curr.value); \n              }  \n           curr = curr.next; \n         } while(curr != slist); \n \n      return false; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Use a slow and fast pointer to detect the loop. When loop is detected replace the fast pointer with the start and increment both until they meet, i.e., the start of the loop. Check for duplicates in using the value of slow pointer. Running time O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can calculate the length of the circular list in O(n) time. Then do a O(n^2) comparision to check for duplicates. Here's my code for it :  bool hasDuplicates(node* slist){     node* start = slist;     node* n = slist;     node* m;     int len = 0;  //Calculate the length      if(n != NULL)         count++;      //Calculate the length   while(n->next != start){         count++;         n = n->next;     }       n = slist;     m = slist;  // check if some dupliacte is present     for( int i = 0 ; i < count ; i++){         m = n;         for( int j = i + 1; j < count ; j++){             m = m->next;             if( m->val == n->val)                 return true;         }         n = n->next;     }  //Duplicate not found     return false; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"traverse the link list and keep the value in a hash table  while inserting the value in hash if it is found that the value is already in the list then it is the duplicate"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"traverse the link list and keep the value in a hash table  while inserting the value in hash if it is found that the value is already in the list then it is the duplicate"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"add linked list items into dictionary and then traverse and find duplicates. Here is c# code      class Program     {         static void Main(string[] args)         {             CircularList cl = new CircularList();             cl.insertToStart(0);             cl.insertToStart(1);             cl.insertToStart(2);             cl.insertToStart(3);             cl.insertToStart(4);             cl.insertToStart(4);             cl.insertToStart(4);             cl.insertToStart(5);             cl.traverse();             Console.WriteLine(cl.isDuplicate().ToString());          }     }      class CircularList     {         Dictionary d = new Dictionary();          private listNode head;         private listNode tail;         private int size = 0;          private class listNode         {             public int item;             public listNode next;         }          private listNode find(int index)         {             listNode cur = new listNode();             cur = head;             for (int i = 0; i < index; i++)             {                 cur = cur.next;             }             return cur;         }          public void insertToStart(int item)         {             listNode newNode = new listNode();             if (head == null)             {                 head = newNode;                 tail = head;                 head.next = tail;                 head.item = item;                 if (d.ContainsKey(item))                 {                     d[item] = true;                 }                 else                 {                     d.Add(item, false);                 }             }             else             {                 newNode.item = item;                 newNode.next = head;                 tail.next = newNode;                 head = newNode;                 if (d.ContainsKey(item))                 {                     d[item] = true;                 }                 else                 {                     d.Add(item, false);                 }             }             ++size;         }          public void insertToEnd(int item)         {             listNode newNode = new listNode();             if (head == null)             {                 head = newNode;                 tail = head;                 head.next = tail;                 head.item = item;                 if (d.ContainsKey(item))                 {                     d[item] = true;                 }                 else                 {                     d.Add(item, false);                 }             }             else             {                 tail.next = newNode;                 newNode.next = head;                 tail = newNode;                 newNode.item = item;                 if (d.ContainsKey(item))                 {                     d[item] = true;                 }                 else                 {                     d.Add(item, false);                 }             }             ++size;         }          public bool isDuplicate()         {             listNode tmp = head;             bool var = false;             while (tmp.next != head)             {                 if (d[tmp.item] == true)                 {                     var = true;                     break;                 }                 else                 {                     var = false;                 }                 tmp = tmp.next;             }             return var;         }          public void traverse()         {             listNode tmp = head;             while (tmp.next != head)              {                 Console.WriteLine(tmp.item.ToString());                 tmp = tmp.next;             }         }     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how about ! do merge sort on list (by fixing start and end pointer) then scan once , compare with neighbour node if equal return true no space required. time complexity nlog n+ 0(n) = 0 (nlog n)  any thought ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Possible solution: Time complexity: worst case: (n) Space complexity: worst case: (n)  Input Data structure: Singly linked list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* finding duplicate using hash table */    int  find_duplicate(node **head) {  node *result=*head;  int return_val=0;  int hashtable[50]={NULL};  /* table has to be modified based on the data range */  node *slow=*head;  node *fast=*head;  fast=fast->link->link;  while (fast != slow  ) /* assumed the given link list is circular */  {    fast=fast->link->link;    if(hashtable[slow->data]==0)     hashtable[slow->data]=true;    else if(hashtable[slow->data] >= 1)    {     return return_val=1;  /* found duplicate */    }                         /* objective was just to print true incase duplicate found */    slow=slow->link;               }  if(fast==slow)  /* its used to find the start of the circle */  {               /* when the slow reaches the circle, the fast would also           do a roatation so we can make sure that we check for duplicate */    slow=*head;    while (slow != fast)   {    slow=slow->link;    fast=fast->link;    if(hashtable[fast->data]==0)    hashtable[fast->data]=true;    else if(hashtable[fast->data] >= 1)    {     return return_val=1;  /* found duplicate */    }                }         return 0; /* no duplicate */  /* it also means that we traversed the entire link list now */  }  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=10014683","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"25","title":"Given a Doubly Linked List comprising of 1,2,3 nodes only. Write Code to Sort it.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Take 3 different pntrs, one, two, three. Traverse the list. If 1 is the value of the curent node, take the node out of the list and add it to the end of list represented by pntr \"one\", same for \"two\", \"three\". at the end u ll have 3 lists just point last ptr of \"one\" to \"two\" and of \"two\" to \"three\"."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Complexity is O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Traverse and Count each of the values. Next traversal assign count(1) values to start nodes and so on. (Counting Sort)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What about traverse the list twice? In first traverse, count how many 1's, 2's and 3's in the list, and in the second traverse, just sets nodes to 1 0r 2 or 3 in order according the their counts. It's O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It's Dutch national flag problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is similar to dutch flag problem.We can use that trick."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Definitely the dutch flag problem.  Something like this would sort the list inplace. O(n) complexity.   Where pEnd = End of list pIndex = pBeg = root"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"find the last index of 1 in the list from the beginning find the last index of 3 in the list from the end Then keep on traversing the list. if 1 found, swap with the node next to last index of 1, if 3 found, swap with node in front of last index of 3. so at the end we get, all 1's in the front, all 3's at the end and all 2's in between."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"no need to find any index of one or two or three. Simply head and tail solve the problem as follows: 0. save tail ptr  (T) in another variable V. traverse the list- 1. if node 1 then add to head dont increase head pointer until reach T 2. else if node 3 add to tail dont increase tail pointer to new node. final list is sorted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What do you mean by 1,2,3 nodes only. Do you mean the value is 1 2 and 3"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"AJ, I think there are only 3 nodes ( fixed ) in the linked list.  Always atleast 1 node will be at right place, and need to swap remaining 2.  Step 1: find the right nodes to be swapped. Step 2 - Swap: simple trick is swap the values ( check if it is ok ) else, ask interviewer if it is single linked list / double linked list  and set the links appropriately."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Only 1, 2 and 3 are allowed in that list. I don't think list comprises only 3 nodes with 1,2 and 3.  Algo using brute force method- Count the frequency of values 1,2 and 3. Make the list based on the counts.  Time O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"yes i also think so that the node value can be only 1 2 or 3 if that the case ur algo is fine"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think it can be anything..its like a problem where we are to sort the array containing only three elements.1,2,3.  we will take three pointer. start,mid and last pointer.  { int lo = 0;    int hi = arr_size - 1;    int mid = 0;      while(mid <= hi)    {       switch(a[mid])       {          case 0:            swap(&a[lo++], &a[mid++]);            break;          case 1:            mid++;            break;          case 2:            swap(&a[mid], &a[hi--]);            break;       }    } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1, 2 & 3 combination is another variant of dutch national flag problem where 0, 1 & 2 are given in unsorted order. We can achieve this in O(n) time complexity. No extra space is required.      void Sorting012sDutchFlagProblem(int A[], int n)         {             int i=0, pos0 =0, pos2=n-1;             while ( i < n  )             {                 if (A[i]==0)                 {                     A[i] = A[pos0];                     A[pos0] = 0;                     pos0++;                 }                 if (A[i]==2) && i < pos2)                 {                     A[i] = A[pos2];                     A[pos2] = 2;                     pos2--;                     i--;                 }                 i++;             }         }  Time Complexity: O(n)  Space Complexity: O(1)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"any 3 set number in a doubly linked list is already sorted... you just have to set the new head and the pre and next pointers..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it evaluates level of node while moving in BFS order. For even levels it enters the item in a Stack and empties it when size of stack =2^level. For odd levels it simply prints in normal level order.  import java.util.LinkedList;  import java.util.Queue;  import java.util.Stack;   public class LevelOrderPrint > {    //BFS method  public static void BFS(BTreeNode root){    Queue queue = new LinkedList();    Stack st =new Stack();    if(root!=null)     queue.add((BTreeNode) root); while(!queue.isEmpty()){  root=queue.remove();  if(root.mark==false)  {  root.mark=true;  if(root.level%2==0){   st.push(root.val);   if(st!=null&&st.size()==Math.pow(2,root.level)){       while(st.size()>0)    System.out.print(st.pop()+\" \");   }  }  else  {System.out.print(root.val+\" \");    }  }    if(root.left!=null)  {root.left.level=root.level+1;  queue.add(root.left);  }  if(root.right!=null)  {root.right.level=root.level+1;  queue.add(root.right);  }    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sry its d ans of another question"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void sortList(){   Element current  = root;   Element value3= new Element(0);      Element value1=new Element(0);;   Element value2= new Element(0);;   Element parent = null;   Element next = null;      while(current.next != null){    parent = current;    current = current.next;    next = current.next;        if(current.data == 3){      current.next=value3.next;      value3.next= current;      current.previous=value3;      if(current.next !=null){       current.next.previous=current;             }      if (value3.previous==null){       value3.previous=current;      }     parent.next=next;     if(next != null){      next.previous=parent;     }     current = parent;         }else                  if(current.data == 2){      current.next=value2.next;      value2.next= current;      current.previous=value2;      if(current.next !=null){       current.next.previous=current;      }      if (value2.previous==null){       value2.previous=current;      }     parent.next=next;     if(next != null){      next.previous=parent;     }     current = parent;         }else           if(current.data == 1){       current.next=value1.next;       value1.next= current;       current.previous=value1;       if(current.next !=null){        current.next.previous=current;       }       if (value1.previous==null){        value1.previous=current;       }      parent.next=next;      if(next != null){       next.previous=parent;      }      current = parent;           }   }     if(value3.next != null){   value2.previous.next=value3.next;   value3.next.previous=value2.previous;   value1.previous.next=value2.next;   value2.next.previous=value1.previous;   root.next=value1.next;   value1.next.previous=root;        }   displayList();  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=1422","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"25","title":"How would you detect a repeated element in an integer array. Discuss various solutions and the order of the algorithm.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since the question doesn't talk about any sorting, i think, [keeping the data along with a counter in a structure] linked list would be a good solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"method A: hashtable. detect collision. complexity O(n)method B: sorting, then compare adjacent elements.  detect elements which are equal. complexity O(nlogn)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I had a similar question from Expedia:How would you find the position of the duplicate element(1 duplicate at most) w/ O(1) space. This means you can use static memory but no dynamic allocation like Hash Tables. I didn't solve this problem but mentioned bit manipulation using XOR. Anyone have a clever idea on this?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think, if you don't want to use dynamic memory, then first sort the array. Then compare two adjacent elements, using xoring function. Means when two elements are equal, then xor result will be zero otherwise 1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"aXORa == 0.So aXORbXORa = b. XOR is commutative.So XOR all elements of the array in turn till it becomes zero will give u the repeated number. But i think this can fail sometimes. nybody has a better solution?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If you sort the array, you lose the position of the integer, so sorting isn't allowed."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The solution spontaneously came to me...1. Calculate the sum from 1 to N, using the series formula.2. Since there is at most 1 duplicate, you can find the position by searching in either direction, depending on which position you want to find.The running time is then O(n) and O(1) storage(only original array)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this solution only works if there is additional constraintsize of array = nall numbers lie with 1- n-1 range.Am i missing something"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Yes. The array is a set of 1 to N."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In Perl:my %h;$h{$_}++ for @A;@dups;for(keys %h){    push @dups, $_ if $h{$_}>1}return @dups;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use counting sort. It takes O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"From the above example 2,3,1,4,5,6,7,7 the sum is 35but the sum is 35 even for 2,3,1,4,5,6,6,8.. and the repeatednumber is 6! How does just getting the sum help in finding the repeated number?So, I think Hash which takes O(1) and extra space is the best solutionSecond best is to sort and scan the sorted array O(nlogn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Jack's Expedia question sol:first pass - xor everything to get duplicate number. second pass - iterate over array to find position of duplicate number.so each pass is O(n) and it did not use any extra space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"XOR would work only if ALL the elements in the array are repeated and there is just one number which appears once. XOR-ing would help us find that sole number."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A kind of bit vector like solution, in O(n).  Traverse the array, setting corresponding bit to 1. If the bit already one, then we found our duplicate, if not just keep traversing. Worst case would be if the last element is the repeated one.   But a CATCH is wasted space in creating the bitvector of that size. If range is known, then its great else, we have to make some guesses or give the range of Int.MAX_Value as the size of bit vector"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Bit vector sounds expensive since a bit vector supports sequential access, it takes O(n) time to scan.  Mergesort & comparing adjacent duplicates will be O(nlogn). This is expensive as well. O(nlogn) is expensive than O(n). But, this method doesn't need any extra space.  Hash table is the fastest with O(1) retrieval & access times. But a hash table takes extra O(n) space.  So, we need to decide if we want space(mergesort & comparing adjacent duplicates) or time(the lovely hash table)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Convert int array to an Integer array. Add contents of the new array to a TreeSet. when the .add method returns false we have encountered the duplicate."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"A simple solution is in O(1).The sum of first n natural numbers i.e., 1+2+3+...+n if the numbers are in sequence is given by: n*(n+1)/2. So u can apply the above formula i.e., For example:The below is the given sequence:2,3,1,4,5,6,7,7.Now as there are 8 numbers:8*(8+1)/2 = 36.Now the sum of the above elements is:35. So u can easily say that 7 is repeated as sum is 1 less than it should be."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=21162668","download_status":"DOWNLOAD_DONE","votes":"3","answersCount":"24","title":"Delete last node from the linked list. First node pointer is not given.  I told him its not possible in conventional linked list. He asked me what if we can add some more data in node.  Data should not be a pointer to previous node i.e., it should still be singly linked list.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"So to delete the last node from a singly linked list, you invoke a function from that node (this is the additional data I believe the interviewer was talking about) that:  1.  Checks if this node is the last node - if so set it to null 2.  Iterates through the list looking 2 nodes ahead (n.next.next) to find the end of the list 3.  Finally moves to the last node and sets it to null  Brief example:  Node n = myLinkedList.getRandomNode();  (this is any node that is part of a linked list)  n.deleteLast();"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I say, the extra data to keep in your node is a flag to indicate if the node is deleted.  When you have a chance, e.g., walking the list from the head, you can unlink a node if it is marked deleted, otherwise just respect the deleted flag when handling any node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the soln is possible if we have pointer to the pointer of last node,i/e double pointer.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Your statement of the problem is confusing.  I think you want to delete the previous node?  If all we need is to delete the last node or tail then it's fairly trivial.  You could easily add a head member to each node.  Then you have your list start off with a dummy head that never gets removed.  Still will take you iterating back to the given node from the head."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am sorry but...  I think question filler didn't get question properly..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The solution is possible if you can have a tail pointer and the linked list is made circular."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There is a type of single linked list where the pointer of a node contains the XOR of the previous and next nodes  In such type of a linked list, going back to the previous node is to XOR with the next node, in this case null.  Once we reach the previous node this way its just a matter of completing the formalities"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I guess in c or c++ you can do this,"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use a static variable in the linked list structure."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There is no way you can delete the last node when only pointer to a node is given.Generally the question is asked for middle node and the answer still remains NO. But there you can simulate this behavior by copying the contents to next node and deleting the given node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what is given to us?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@yolo  Can u please post answer this que?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-4","title":"to delete any node in list without access to head .Just copy the value of the next node to the current node and delete the next node. So, it would be something like :  node *tmp = NULL; tmp = ptr->next; ptr->value = tmp->value; ptr->next=tmp->next; delete tmp;"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14801886","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"23","title":"how to sort a single linked list with out using an additional node?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"swap Nodes values instead"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Merge sort is best suited for linked list.  Follow this link for explanations and implementation: geeksforgeeks.org/archives/7740"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Doesn't mergesort inherently uses extra nodes?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Yeah thanks.. realized that.. :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Quick sort is pretty efficient and doesn't use any other node, just swapping"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* \n Hint: Do not allow using additional node, but is it allowed to use additional node values? \n */ \n \n#include  \n#include  \n#include  \n#include  \n#include  \n#include  \n#include  \n#include  \n#include  \n#include  \n#include  \n#include  \n#include  \n#include  \n#include  \n#include  \n#include  \n#include  \n \nusing namespace std; \n \ntypedef struct NodeT { \n  int data; \n  NodeT *right; \n}Node; \n \n \nvoid swapNode(Node *l, Node *r) \n{ \n  int tmp = l->data; \n  l->data = r->data; \n  r->data = tmp; \n} \n \nNode * newNode(int num) \n{ \n  Node * node = new Node(); \n  node->data = num; \n  node->right = NULL; \n  return node; \n} \n \nNode * appendNode(Node *root, int data) \n{ \n  if (root == NULL) { \n    return newNode(data); \n  } \n   \n  Node *node = newNode(data); \n   \n  root->right = node; \n   \n  return node; \n} \n \nNode * sortList(Node *head, int n) \n{ \n  if (head == NULL || head->right == NULL || n <= 1) { \n    return head; \n  } \n \n  int randIndex = rand() % n; \n   \n  Node *target = head; \n   \n  for (int i = 0; i < randIndex; i ++) { \n    if (target) { \n      target = target->right; \n    } \n  } \n   \n  swapNode(head, target); \n   \n  int i = 1, count = 0; \n  Node *tail = head; \n  for (Node *iter = head->right; i < n && iter; i ++, iter = iter->right) { \n    if (iter->data < head->data) { \n      count ++; \n      tail = tail->right; \n      swapNode(tail, iter); \n    } \n  } \n   \n  swapNode(head, tail); \n   \n  head = sortList(head, count); \n  tail->right = sortList(tail->right, n - count - 1); \n   \n  return head; \n} \n \nvoid printList(Node *head, int n) \n{   \n  if (!head) { \n    return; \n  } \n   \n  for (int i = 0; i < n && head; i ++) { \n    cout << head->data << \" \"; \n    head = head->right; \n  } \n   \n  cout << endl; \n} \n \nvoid cleanList(Node *root) \n{ \n  if (root == NULL) { \n    return; \n  } \n   \n  cleanList(root->right); \n   \n  root->right = NULL; \n  root->data = 0; \n   \n  delete root; \n} \n \nint main() \n{ \n  int a[1000]; \n  int n = 100; \n  while (cin >> n && n != 0) { \n    if (n > 1000) { \n      break; \n    } \n     \n    for (int i = 0; i < n; i ++) { \n      a[i] = i; \n    } \n     \n    for (int i = 0; i < n; i ++) { \n      int r = rand() % n; \n      int tmp = a[i]; \n      a[i] = a[r]; \n      a[r] = tmp; \n    } \n     \n    Node *head = NULL; \n    head = appendNode(head, a[0]); \n    Node *last = head; \n     \n    for (int i = 1; i < n; i ++) { \n      last = appendNode(last, a[i]); \n    } \n   \n    head = sortList(head, n); \n    printList(head, n);     \n    cleanList(head); \n  } \n   \n  return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def sort_link_list(head_node): \n    while (True): \n        curr = head_node \n        changed = False \n        while (curr.next_node is not None): \n            if (curr.value < curr.next_node.value): \n                curr.value = curr.value ^ curr.next_node.value \n                curr.next_node.value = curr.value ^ curr.next_node.value \n                curr.value = curr.value ^ curr.next_node.value \n                changed = True \n            curr = curr.next_node \n        if (not changed): \n            break"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"mergesort for link lists does not use extra space... it is an in place algorithm... so O(nlogn)   //programme by shivi #include #include using namespace std; class LinkList {  private:  struct Node   {   int item;   Node* next;   Node(int k,Node* x)   {    item=k;    next=x;   }  };  Node* start;    public:  LinkList()  {   start=NULL;  }    void AddNode(int key)  {   Node *p=new Node(key,start);   start=p;  }    void Print()  {   pr(start);  }    void pr(Node *x)  {   if(x==NULL)return;   pr(x->next);   cout<item<<\" \";  }    void MergeSort()  {   mergesort(&start);  }    void mergesort(Node **start)  {   Node *x=*start,*lo,*mid;   if(x->next==NULL || x==NULL)    return;      splitlist(*start,&lo,&mid);   mergesort(&lo);   mergesort(&mid);   *start=mergelist(lo,mid);  }    void splitlist(Node *start,Node **lo,Node** mid)  {   if(start==NULL || start->next==NULL)    {     *lo=start;*mid=NULL;    }       else   {    Node *a=start,*b=start->next;        while(b!=NULL)    {     b=b->next;     while(b!=NULL)     {      a=a->next;      b=b->next;     }    }    *lo=start;    *mid=a->next;    a->next=NULL;   }         }    Node* mergelist(Node *lo,Node *mid)  {   Node *newstart=NULL;   if(lo==NULL)    return mid;   if(mid==NULL)     return lo;       if(lo->item>=mid->item)    {    newstart=lo;    newstart->next=mergelist(lo->next,mid);   }      else   {    newstart=mid;    newstart->next=mergelist(lo,mid->next);   }   return newstart;  }      bool CheckIdenticalLinkLists(Node * a,Node* b)  {   if(a==NULL && b==NULL)   return 1;   else if(a==NULL && b!=NULL)   return 0;   else if(a!=NULL && b==NULL)   return 0;   else if(a->item!=b->item)   return 0;      return CheckIdenticalLinkLists(a->next,b->next);  }    void alternate()  {   Node*a,*b;   AlternateSplit(start,&a,&b);   pr(a);   cout<  pr(b);  }    void AlternateSplit(Node *start,Node** a,Node** b)  {   Node *s1=start,*s2=start->next,*x=s1,*y=s2;   if(start==NULL || start->next==NULL)   {    *a=start;    *b=NULL;   }      else   {    while(b || a)    {     x->next=y->next;     x=x->next;     y->next=x->next;     y=y->next;    }       }      if(x->next!=NULL) x->next=NULL;   if(y->next!=NULL) y->next=NULL;   *a=s1;   *b=s2;  } }; int main() {  LinkList l;  LinkList k;  l.AddNode(2);  l.AddNode(1);  l.AddNode(4);  l.AddNode(6);  l.AddNode(3);  l.AddNode(9);  k.AddNode(2);  k.AddNode(5);  k.AddNode(19);  k.AddNode(6);  k.AddNode(8);  k.AddNode(1);  l.Print();  cout< // l.Print();cout< l.MergeSort();//k.MergeSort();  //cout< l.Print();cout< //l.alternate(); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I like the first answer to simply swap the value. Alternately, if we aren't even allowed to use a second variable, and assuming the singly linked list contains only numbers as data, we can use the typical math operations to swap the values. a=21, b=5 1. a=a+b (a becomes 26) 2. b=a-b (b becomes 21) 3. a=a-b (a becomes 5)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This post is in reference to my previous response above where I'm wondering why some links say that heapsort for linked list is nearly impossible. Here I provide an algortihm that runs in O(nlogn) time. Most of the algortihm is taken from cormen's book except the method 'heapsort'"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Find Max and swap with last node and so on is the simplest solution I guess."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/**  I am using pointers but no extra node for sorting link list */  void LinkList::sort() { Node*out_loop= head, *q=NULL, *p=head, *r=NULL;  while(out_loop!=NULL)    {     q=p;     while(q->next!=NULL) {       r=q->next;       //cout << q->data<      if(q->data > r->data) {         q->next=r->next;         r->next=q;         if(q==head) {           head = r;           p=r;         } else {           p->next=r;           p=r;         }       }else{       p=q;       q=q->next;       }     }     p=head;     out_loop=out_loop->next;   } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node mergeSort(Node head){ \n if (head == null || head.next == null) \n  return head; \n Node mid = getMidNode(head); \n Node secondHalf_head = mid.next; \n mid.next = null; \n return merge(mergeSort(head) , mergeSort(secondHalf_head)); \n} \n \nNode merge(Node head1 , Node head2){ \n Node current; \n Node head; \n Node temp1 = head1; \n Node temp2 = head2; \n if (head2.content < head1.content){ \n  current = head2; \n  head = head2; \n  temp2 = temp2.next; \n }else{ \n  current = head1; \n  head = head1; \n  temp1 = temp1.next; \n } \n while (temp1 != null & temp2 != null){ \n  if (temp1.content <= temp2.content){ \n   current.next = temp1; \n   temp1 = temp1.next; \n  }else{ \n   current.next= temp2; \n   temp2 = temp2.next; \n  } \n } \n if (temp2 != null) \n  current.next = temp2; \n else \n  current.next = temp1; \n return head; \n} \n \nNode getMidNode(Node head){ \n Node slow = head; \n Node fast = head; \n while (fast != null && fast.next != null){ \n  slow = slow.next; \n  fast = fast.next.next; \n } \n return slow; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=9304676","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"24","title":"There is a linked list whose node has 3 fields, val, next pointer & random pointer...next pointer points to next node in the list and random pointer can point to any node in the list.Write an efficient function which takes such list and returns the copy/clone of that list.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"10","title":"1) Create the copy of every node in the list and insert it in original list between current and next node. create the copy of A and insert it between A & B.. create the copy of B and insert it between B & C.. Continue in this fashion, add the copy of N to Nth node. 2) Now copy the arbitrary link in this fashion  original->next->random = original->random->next; /*Traverse two nodes in every iteration*/  3) Now restore the original and copy linked lists in this fashion in a single loop. original->next = original->next->next; copy->next = copy->next->next;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"saw the answer somewhere else few days back  1) create new link list and copy the data field and next pointer of the original link list. 2) not redirect the next pointer of each node  of the original list to the corresponding node in new list' 3)new_node->random_prt = old_node->random_prt->next"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The key is to keep one-to-one relationship between the old list and the new list, either through hash or simply build two arrays to keep track.  Then when building the new list, copy val and set next prt properly to new next added node make new_node->random_ptr = old_node->random_ptr, ie new node's random ptr points to the old list as the new list is not completed yet.  Finally, using the saved one-to-one relationship, modify the random_ptr of new_node to the correct new node in the list"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can't we just copy the nodes in two passes? In the first pass, copy the next pointers and in the second pass, copy the random pointers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"in reply to msd....in your approach are all the random pointers remain same as in the original list"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i didn't understand abc comments  i think msd solution was right. Can you please elaborate ..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"One more solution: 1. Create a copy of input by just following the next pointer 2. But when you are copying just keep on doing 2 things.  (i) Make sure that arbit pointer of the new node points to corresponding old node.      A' -> arbit = A (ii) And the next pointer of old node point to the corresponding new node      A->next = A'      where A is old node and A' is new node.  3. Now traverse the new list again and do the below steps :    A'->arbit = A'->arbit->arbit->next;    A->next = A' ->next->arbit."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=2653","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"23","title":"Write a function to find mid point of a linked list","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"how abt using 2 pointers, one travelling twice as fast as the other. (lets call them the 'hare' and the 'tortoise'). both start at node 0, wen tortoise moves to the 1st node, hare is at node 2, and wen tortoise is at the nth node , hare is at the 2nth node. While jumping to the 2nth node, if the hare sees the end of the list, then the tortoise is moved one step back. As per the moral,  \"slow and steady\" will give you the result !"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"that sounds about right."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node* midList(Node *head){ struct node *fast, *slow; slow=fast=head; while(fast->next && fast->next->next) {  fast=fast->next->next;  slow=slow->next; } return slow;}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for the function to find the mid of a linked list.Initialize 2 pointer both pointing to the head of the list initially.Now increment the first one by 2 places and keep the second one at rest. Keep moving the first pointer by 2 places and for each move of first pointer move the second pointer by one position. When the first pointer reaches to the end of linked list, second pointer will be pointing to the mid node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for the Function to remove extra spaces in a string:We can use the strtok function to get the tokens separated by spaces..(even if they are separated by multiple spaces). Store these tokens and once all the tokens are obtained, we can concatenate them with a single space between them. This way we are able to remove all the spaces and reconstruct the string with a single space between all the words."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the algo given by vel works absolutely fine."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have two points to make : - It didn't check for boundary cases. - It did not exploit the information given for Doubly linked list. This information might not be required.  Are both singly/doubly linked list have the same implementation for this program?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node* mid(node* h) \n{ \n node *n, *m; \n if(!h) return 0; \n if(h->next==0) return h; \n n=h; \n m=h->next; \n while(m && m->next) \n { \n  n=n->next; \n  m=m->next->next; \n } \n return n; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node* mid(node* h) \n{ \n node *n, *m; \n if(!h) return 0; \n if(h->next==0) return h; \n n=h; \n m=h->next; \n while(m && m->next) \n { \n  n=n->next; \n  m=m->next->next; \n } \n return n; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if anyone knows how to have middle of linked list in O(1)???????"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"mohit, there doesn't exits such solution that gives you the mid in one shot, without traversing the list once."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node * linklist_mid(node *head) {     node *s, *f;     s = f = head;      while(f && f->next) {         s = s->next;         f = f->next->next;     }      return s; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Create a double out of single and traverse half of it. O(1.5n) = O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct list *p,*q;      p=ptr;      q=p;      int flag=0;      while(q!=NULL)      {         if(flag==2)         {                    p=p->next;                    flag=0;         }        else        {                        q=q->next;                        flag++;                                 }                 }                                          printf(\"\\nValue at middle %d\\n\",p->value);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n)=O(1.5n). Fail."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=1460","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"23","title":"Why would you use an array vs linked-list","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"I think most people forget to think about the Hardware aspect of things, remember that Arrays give much better locality as in caching is so much better when data is in consecutive blocks with the prefetch stuff in processors etc... im sure an ECE guy would be able to better ellaborate on that point ( sorry im CS :) )"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"O(1) time to add an element to a linked list...also, linked list doesn't have a fixed size, so there will be no need to copy elements (like when you run out of space in a fixed-sized array), which is a very costly operation."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"save memory"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"So if that's the only reason to use an array over a linked list, why would you always use it?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"With linked lists, you need to do a linear search to find an element of the list with a specific index. With an array, you can just lookup the element in O(1) time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think saying arrays should be used always would be wrong. One should make a choice depending on the requirements:Both arrays and linked lists are for storing objects of the same type. Arrays:- you know the number of elements before hand. If size is dynamic choice, arrays are a wrong (or costly) choice.- element access time is importanta. It is O(1) for arrays and O(n) for linked listslinked lists:- when number of elements is unknown or dynamic- suitable for representing trees and so onUse arrayList in .net and have best of both. (Ok keeping in mind that capacity is well planned)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I really can't agree with you that an arraylist is the best of both worlds.    Sure, an arraylist beats an array (one that's dynamic anyway), but it doesn't necessarily beat a linked list.  A crucial difference is that element can be inserted in sorted order into a linked list quickly and efficiently.It's also somewhat misleading to say that linked lists are suitable for representing trees.  Although the data structures have some things in common, they are different data structures.  A linked list cannot represent a tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Agreed. linked list is not suitable for a tree (an adjacency list is more approp)...I was thinking in terms of a binary tree where each node maintains a list of parent/ child etc...same with inserting into an ArrayList. Usually I have a wrapper around arrayList which provides me sorted insert and so on. Thanks for your comments."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Linked List:? They allow a new element to be inserted or deleted at any position in a constant number of operations (changing some references) O(1).? Easy to delete a node (as it only has to rearrange the links to the different nodes).? To find the nth node, will need to recurse through the list till it finds [linked lists allow only sequential access to elements. ]Array? Insertion or deletion of element at any position require a linear (O(n)) number of operations. ? Poor at deleting nodes (or elements) as it cannot remove one node without individually shifting all the elements up the list by one.? Poor at inserting as an array will eventually either fill up or need to be resized, an expensive operation that may not even be possible if memory is fragmented. Similarly, an array from which many elements are removed may become wastefully empty or need to be made smaller? easy to find the nth element in the array by directly referencing them by their position in the array.[ arrays allow random access ]        Array        Linked list  Indexing O(1)      O(n)Inserting O(n)      O(1)Deleting O(n)      O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Apart from the above differences, one important use of linked lists is to store persistent data (be able to access old data after new data is added) easily. If there is an array, and some changes are made to this array but you still want to be able to see the old array, the only way you can do this is by copying the entire array into a new array and making changes to the copy.In a linked list, lets say you just want to change the front portion of a linked list, then you create a new front portion and at the end of this front portion, point to the old back portion (In effect, this lets you share the back portion).If the change is random, you can come up with operations, which will point to appropriate old portions."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Arrays: Use them when most of the data will be static i.e. they won't change once they are inserted - and where there will be intensive search operationsLinked list: use them whenever the data is dynamic - lots of insertions and deletions - not too much of search intensive operations"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi Gayle,Inserting elements in sorted order will take O(n) in both arrays and linked-list. This is so because in arrays you have to move O(N) elements elements while in linked-list you have travel through O(N) nodes. In fact, moving elements can be faster because of locality-of-reference of arrays. Please correct me where I a wrong."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hi all.. answers i found here are good. i wanna give my answer here itself  in my view:   Mainly there are 4 importent factors which are responsible to use any array.  1.accessing time. If your application needs faster speed, then elements insertion(if array is empty and if no need to insert in the middle of an array) or extraction data. This gives advantage over linked-list.2.if there are fixed number of elements you want to enter.3. if ur program is for small applications and needs some what acceptible memory.(as for larger application there may not be that much of memory available serially)4. Dealing with arrays are much easier logically than Liked-List.so if my application needs faster execution,limitted and known number of elementsfor easy logic,i prefer to use Array than linked list.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"When the size of the data is not known in advance, linked list is the choice."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Deleting/inserting a node in an array is not O(1) if the node is targeted at the front or in the middle. Deletion: the array contents would have to be shifted and the last node deallocated. Insertion: allocate a node and shift contents.This is for a vector. For a deque, insertion/deletion in the middle is not O(1), but O(1) at front/back.A linked list has O(1) deletion/insertion anywhere."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In case of link list while allocating nodes worst case possible scenario may be that memory gets allocated in various pages , which may result in significant page faults , degarding the performance . Whereas it may not be the same case with Array as is it a contigous allocation , provided array data elements are not of page size ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it depends on the situation. you can't say one is better than the other one in all cases !"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can build Windows Vista with linked lists to accommodate Blue screens"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This question makes me want to go to other sites for better questions :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Answer no any people used"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5313007689138176","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"22","title":"reverse the doubly linked list without using extra space","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"There can be various methods to reverse a linked list, but here we can take advantage of it being a doubly linked list:  1. loop from head to tail. For each node swap next and prev.   for(p = head;p!=NULL;p=r) {     r=p->next;     p->next=p->next^p->prev;     p->prev=p->next^p->prev;     p->next=p->next^p->prev; }  2.swap head and tail."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Reversing doubly linked list is easier than SLL. Just reverse head and tail of each node of DLL."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"reverseLinkedList(Node node) {  if(node.nxt==null) return; else {  reverseLinkedList(node.nxt) Node tmp=node.prev; node.prev=node.next; node.next=tmp } ---Ajeya"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static Node reverseLinkedListIteratively(Node head){ Node prev=null; Node temp=head; while(temp!=null){ Node temp1=temp.next; temp.next=prev; prev=temp; temp=temp1;  } return prev; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There are two ways to do the problem :   (1) to keep swapping  the data of first and last node - O(n/2) - extra space not required  (2) to swap the next n prev pointers for each node. - O(n) - extra space required for swapping (= size of node)  Please feel free to comment and point out any possible mistake on above approches."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ListNode *reverse(ListNode* head) \n { \n  if(head == NULL || head->next == NULL) \n   return head; \n  ListNode *p = head; \n  while(p->next != NULL) \n  { \n   ListNode *temp = p->next; \n   p->next = p->prev; \n   p->prev = temp; \n   p = temp; \n  } \n  p->next = p->prev; \n  p->prev = NULL; \n  return p; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the emphasis on the question is more on \"not use additional space\", so all the algos using Next or any other temporary variable is not accepted.   In c++, all these pointers are anyways long, so you can do this to swap 2 pointers without using a temporary variable:   n1= (Node *) ((long)n1+ (long)n2);  n2 = (Node *) ((long)n1- (long)n2);  n1= (Node *) ((long)n1- (long)n2);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Find and return the tail, the list is reversed because it is a double linked list.   Use two pointers, p1 and p2. p1 move 1 step forward, p2 move 2 stop forward, when p2 return back to head, p1 will be the tail."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void reverse(node ** headRef) \n{ \n        node* previousNode = NULL; \n        node* curr = *headRef; \n        while(curr) \n        { \n                curr->prev = curr->next; \n                curr->next = previousNode; \n                previousNode = curr; \n                curr=curr->prev; \n                if (curr == NULL) \n                        { \n                                *headRef = previousNode; \n                                break; \n                        } \n        } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Most of you are not checking error conditions.  Try it with a list of length 1. Some of the above solutions I've seen will actually return null for the new head."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why cant i swap just the data i the head and tail ??   do i really need to do all the pointer manipulations in a doubly linked list ??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why cant i just swap the data elements present in the first and the last node ??  I know that people might think that what if the no of variables in the Node of the list is O(n). in that case it might not be a viable option to swap data.. but if the node has constant no of data variables then its better we just swap the data.  suggestions welcomed."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"http://www.teamten.com/lawrence/writings/reverse_a_linked_list.html  C:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"its a double linked list..so just swap the head and tail."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=319703","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"21","title":"Given a singly linked-list, and a pointer to node, how to delete the node.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Copy the contents of next node to current node.. and delete next node.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Given a pointer to a node, it is not possible to go back from that node using this pointer. So it can be assumed that either the current node or one of the following node has to be deleted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Given a pointer to a node, it is not possible to go back from that node using this pointer. So it can be assumed that either the current node or one of the following node has to be deleted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"geeksforgeeks.org/?p=876"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We always need pointer to the previous node to delete. Solution: Swap the data between current and next node, and delete the next node. This solution doesnt work if the node to be deleted is last in the list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the simplest solution is to swap the given node with its successor and delete the successor. it wont be a problem if it is the last node in the list. if that is the case, then just make the given node null."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"temp is the given node then temp->data = temp->next->data; temp->next = temp->next->next; free(temp->next);  does this sound right???"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ptr - the pointer to the node to be deleted. head - the pointer to the header of the list.   if (head == null) return ; // list is empty if (ptr == head) //ptr points to the first node-delete first node. {        head=head->next;   } else // if the node to be deleted is not the first node {    while(head->next != ptr && head->next != null)      head = head->next;   // Traverse to the previous node of ptr.     if (head->next == null) return ;//reached the end of the list, didn't find ptr.        head->next = ptr->next; // actual delete statement. } free(ptr); //release ptr's memory. }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sarita dear, you are not provided the head node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void deletenode(NODE *p) { if(p->next->next==NULL)  {   free(p->next);   p->next=NULL;  } else  {  NODE *temp=p->next->next;  free(p->next);  p->next=temp;  } }  //p is the node which is pointing to the node to be deleted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Guys, if you are given a pointer to the last node and nothing else then you can't delete it. Don't try so hard. But that is a special case and I believe you must have the root node available."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=65210","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"21","title":"Write a code to reverse alternate nodes in a link list.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Cannot think of an optimal solution for this one. Here it goes, just describing the pseudo code. Think of this problem as if you are asked to reverse the alternate characters in a string (char array)  - Traverse the node in the list     + Add it to an Array of nodes - Get the Length of Array - If Length is odd, Length = Length - 1 //since we start with 0, the last node to be reversed will be even - for I = 0, J = Length; I <= ArrayLength/2 && J >= ArrayLength/2; I+=2, J-=2)    Swap (I&&J)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"3 variables: current, prev and temp current is initially pointing to head  while(cur!=null){ temp = cur->next; cur-next = cur-next-next; temp->next = cur; if(cur is not head of the list){ prev->next = temp; } prev = cur; cur = cur->next; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void revalt ( Node *head)  {    struct Node *p, *q, *prev = NULL;    if (head && head->next)      head = p; q= head->next;     head = q;   while (q)    {     struct node *temp = q->next;     q->next = p;     p->next = temp;     if (prev)      prev->next = q;    prev = p;     p= p->next;     if (p)       q= p->next;     else            q = null;     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If extra memory space is allowed to take then just store the reverse link list.Then go for the swapping of alternate positions."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can someone further explain this? What does reverse alternate nodes mean?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the length of linked list is odd, it is the same as reverse the whole linked list.  I use () to show alternative nodes e.g. a (b) c (d) e (f) g --reverse--> g f e d c b a, same as reverse the whole list.  If the length of linked list is even, take two elements as a unit, it is same as reverse the linked list units.  e.g. a (b) c (d) e (f) --reverse--> e f c d a b equivalent (ab)(cd)(ef) -- reverse -->(ef)(cd)(ab)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"while(curr && curr->next) {   tmp = curr->next;   next = tmp  ? tmp->next : NULL;      if (tmp) tmp->next = curr;   if (prev) prev->next = tmp;   else head = tmp;    prev = curr;   curr = next; } prev ? prev->next = NULL : NULL; return head;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"while(curr && curr->next) {   tmp = curr->next;   next = tmp  ? tmp->next : NULL;      if (tmp) tmp->next = curr;   if (prev) prev->next = tmp;   else head = tmp;    prev = curr;   curr = next; } prev ? prev->next = NULL : NULL; return head;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"http://www.ocf.berkeley.edu/~wwu/cgi-bin/yabb/YaBB.cgi?board=riddles_cs;action=display;num=1206564537"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node* SwapPairs(node* head) {     if(!head || !(head->next))        return head;      node* first = head;     node* second = head->next;     node* third = second->next;      second->next=first;     first->next = SwapPairs(third);      return second; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@Kiran: Your solution just swaps the nodes next to each other but the question is something else. To get a better idea go through the example of T."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My understanding is if list is: 1-2-3-4-5-6 after reversing it should be: 5-6-3-4-1-2 Is yes, then use 2 stacks, traverse list (s1, s2) and keep putting nodes in alternate stack (s1-> 5-3-1 and s2->6-4-2)and once list is over, build a list by popping nodes from both stack"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Erik has the perfect solution I think"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There are 3 basic steps as far as i can think 1. Split the main list into 2 lists - each list containing the alternate elements. Each time you add a node to the sublist, do a Push(node). This way the elements in the sublists will be in reverse order eg: 1-2-3-4-5-6 is split into 2 lists 5-3-1 and 6-4-2 This can be done in O(n) time.  2. Now shuffle merge the 2 sublists, starting from first sublist. This can be done in O(n) time again. 5-6-3-4-1-2  Therefore time complexity is O(n) + O(n) = O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i/p:  [a] -> b -> [c] -> d -> [e] -> f alternates nodes are one which are in [] brackets. o/p:   e ->  b ->  c ->  d ->  a ->  f  my solution: 1) split the list into two different list.    alternate sub list => a->c->e->NULL    and   normal sub list => b->d->f->NULL 2) reverse alternate sub list. now you have     e->c->a->NULL; and b->d->f->NULL; 3) merge above sub lists node by node to get.     e ->  b ->  c ->  d ->  a ->  f      all the above steps can be achieved in o(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I dont think 2 stacks work. We need 1 stack and 1 queue. The nodes to be reversed go in the stack.Others go in the queue. 1 -> 2-> 3-> 4 -> 5 -> null desired result: 5 -> 2 -> 3 -> 4 -> 1-> null push(1); enqueue(2); push(3); enqueue(4); push(5); then: pop(5); dequeue(2); pop(3); dequeue(4); pop(1);  running time - O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void swap(Node* parentQ, Node* Q, Node* parentR, Node* R) { \n  if(!parentQ) { \n   start = R; \n  } else { \n   parentQ->next = R; \n  } \n  if(!parentR) { \n   start = Q; \n  }else { \n   parentR->next = Q; \n  } \n  Node* temp = Q->next; \n  Q->next = R->next; \n  R->next = temp; \n } \n \n void alternateReverse() { \n  if(isEmpty()) { \n   cout<<\"\\nEMPTY LIST...\"; \n   return; \n  } \n  if(!start->next) { \n   cout<<\"\\nONLY ONE ELEMENT IN LIST...\"; \n   return; \n  } \n  Node *P = NULL, *Q = start, *R = start->next; \n  start = R; \n  while(R) { \n   swap(P,Q,Q,R); \n   P = Q; \n   Q = Q->next; \n   if(!Q) \n    return; \n   R = Q->next; \n  } \n }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=161687","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"20","title":"Sort a linked list using bubble sort.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Look like that we can map the linklist to an arrary, then use bubble sort for array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The point of the question seems to be to judge how well you write linked list manipulation code.  If we are dumping to an array, we might as well QuickSort or something better than bubble sort."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// preprocessor directives  # include   # include    using namespace std;   // class nodeType  class nodeType  {  // class members   public:           char fName[ 15 ];           char lName[ 15 ];              nodeType *next;         };   int main() { // all your declaration goes here nodeType *head, *first, *next, *newNode, *temp1, *temp2; char fn[ 15 ]; char ln[ 15 ]; char anyMore;   head = first = next = newNode = temp1 = temp2 = NULL;   do { system ( \"cls\" ); // prompt and input first name and last name  cout << \"\\nEnter first name: \"; cin >> fn;  cout << \"Enter last name: \"; cin >> ln;  newNode = new nodeType;  strcpy( newNode -> fName, fn ); strcpy( newNode -> lName, ln );  newNode -> next = NULL;  if ( head == NULL ) // list is empty { head = first = newNode; }  else if ( strcmp( newNode -> lName, head -> lName ) < 0 ) // then insert before first one { newNode -> next = head; head = newNode; } else  {  temp1 = head;  //start a search for right place, by checking the next one's last name while (( strcmp( temp1 -> next -> lName, ln ) < 0 ) && ( temp1 -> next != NULL )) {  temp1 = temp1 -> next;  }  newNode -> next = temp1 -> next; temp1 -> next = newNode;  }    // now list the items temp1 = head;  while ( temp1 != NULL ) {  cout << temp1 -> fName << \" \" << temp1 -> lName << endl; temp1 = temp1 -> next;  }  // here prompt for an input to enter more (ie, anyMore Y/N)  cout << \"\\nEnter Y to input, or N to exit: \"; cin >> anyMore;  } while ( anyMore == 'Y' || anyMore == 'y' ); // end dowhile  system ( \"pause\" );  // all done; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// Sort list by swapping data around.  \nList *BubbleSort(List *head) \n{ \n    \n  if (head == null) return; \n   \n  List *A = head->next; \n   \n  if (A == null) return; \n  // Make head the minimum. \n  while( A != null) \n  { \n    if (head->Data > A->Data) \n    { \n      Data tmp = head->Data; \n      head->Data = A->Data; \n      A->Data = tmp;   \n    } \n  } \n  // Recurse on the rest of the list. \n  BubbleSort(head->next); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void BubbleSort(LL * head) \n{ \n if (!head) \n { \n  return; \n } \n     \n LL *end = NULL; \n while (end != head->next) \n { \n  LL *p = head; \n  LL *q = head->next; \n  LL *tmpend = NULL; \n     \n  while (q != end) \n  { \n   if (p->data > q->data) \n   { \n    int tmpData = p->data; \n    p->data = q->data; \n    q->data = tmpData; \n   } \n   tmpend = q; \n   p = p->next; \n   q = q->next; \n  } \n  end = tmpend; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You idiot Ganga Narayana .. go and drown yourself in Ganga.. Is this Bubble Sort Idiot!!  This is not Bubble sort. In bubble sort you compare consecutive elements. LOLer has made that clear in above posts. Why do you have to do it again and again. Felt like killing you !!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bubblesort(node) { if(node==null) return; bubble(node); bubblesort(node->next); }  bubble(node) { if(node==null) return; if(node->next == null) return; bubblecheck(node->next); if(node->data > node->next->data) { temp = node->data; node->data = node->next->data; node->next->data = temp; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please ignore the previous post as the recursive call in \"bubble\" is typed wrongly as \"bubblecheck\""},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorting a link list by swapping the data around isn't a good idea as there may be other pointers currently point to the nodes.  It's slightly more difficult to swap the actual nodes.  Here's a try:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Bubble Sort on linked list is O(n3)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bubble(Node ** head){      Node *prevPos,*curPos,*nextPos;      bool SWITCHED = true;      if(SWITCHED){           SWITCHED = false;           curPos=prevPos=*head;           while(cur->next != NULL){                 nextPos = curPos->next;                 if(curPos->data > nextPos->data){                       SWITCHED = true;                        curPos->next = nextPos->next;                       nextPos->next=curPos;                       prevPos = other;                       if(curPos==*head){                             *head = nextPos;                       }                 }                 else{                         curPos = curPos->next;                         prevPos = prevPos->next;                 }           }        } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* getLength() returns the length of list */ \n \nnode *BubbleSort(node *start) \n{ \n        node *prev, *orig = start, *temp; \n        int i,len = getLength(start), swaps; \n        while (len--) \n        { \n                swaps = 0; start = orig; prev = NULL; \n                for (i=0;idata > start->next->data) \n                        { \n                                temp = start->next; \n                                start->next = start->next->next; \n                                temp->next = start; \n                                if (prev) \n                                        prev->next = temp; \n                                else \n                                        orig = temp; \n                                start = temp; \n                                swaps++; \n                        } \n                        prev = start; \n                        start = start->next; \n                } \n                if (!swaps) \n                        break; \n        } \n        return orig; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// Its bubble sort.... where you compare two values at the time and every pass you will push large data to the end of the list. and small data keeps coming up.  void BubbleSort(node *head) {     bool swapped = true;     node *cur;      while(swapped) {           swapped = false;           cur = head;            while(cur->next != NULL) {               if(cur->next->value > cur->value )  {                      //swap values of cur and cur->next                      swapped = true;                }               cur = cur->next;           }     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Element *Bubblesort(Element **head) \n{ \n Element *curInner = *head; // current. \n Element *pre = null; // previous \n Element *end = null; //end of loop \n Element *newHead = *head; // new head to be returned. \n while(true) \n { \n  curInner = newHead; \n  if(curInner->next == end) //break when all outer loops are done. \n  { \n   break; \n  } \n  while(curInner->next != end) \n  { \n   if(curInner->data > curInner->next->data) \n   { \n    Element *temp1 = curInner->next; \n    Element *temp2 = curInner->next->next; \n    curInner->next = temp2; \n    temp1->next = curInner; \n    if(pre != null) \n    { \n     pre->next = temp1;  \n    } \n    if(curInner == newHead) \n    { \n     newHead = temp1; \n    } \n    pre = temp1; \n   } \n   else \n   { \n    pre = curInner; \n    curInner = curInner->next;    \n   } \n  } \n  end = curInner; \n } \n \n return newHead; \n} \n \nexample  \nround 1 \np,e  c   \nnull 3->1->4->null \n     h \n \ne    p  c   \nnull 1->3->4->null \n     n \n \n \n   p  c   \n1->3->4->null \nn     e \n \nround 2 \np     c   \nnull  1->3->4->null \n      n     e \n \np  c   \n1->3->4->null \nn     e"}]}}]