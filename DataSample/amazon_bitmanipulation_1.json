[{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=3179669","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"36","title":"There is very long array of ints, and you are given pointer to base addr of this array.. each int is 16bit representation... you need to return the pointer to tht \"bit\" inside array where longest sequence of \"1\"s start","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Do we need to take care of endianness ?  eg no=16704 can be represented as   01000001 01000001 MSB LSB 01000001 01000001 LSB MSB  depending upon endianess"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"int *largestseqone(int * p,int len) {  int *temp=p;  int count=0,maxcount=0;  int i=0,n=0;  for(i=0;i {   n=*(temp+i);   printf(\"\\n %d \\n\",n);   while(n!=0)   {    if(n%2==1)    {     count++;     printf(\"count increment: for %d is %d \",n,count);     if(count>maxcount)     {      maxcount=count;      p=temp+i;     }    }    else    {     if(count>maxcount)     {      maxcount=count;      p=temp+i;     }     count=0;    }    n=n/2;   }   count=0;  }  return p; }   int main() {  int arr[5]={1,13,12,8,7};  int *q=largestseqone(arr,5);  printf(\"\\n the answer is %d\",*q);  getch();   return 0; }  gives the answer as :7 which is correct"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Everybody has written something,but can somebody explain how can one return a pointer to a bit in C ?????????????? I think there should be a correction in the question"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Something take this simple example: Array = {15,7,2,1,0,23} 1111,0111,0010,0001,0000,10111 ^ Result: Pointer should point to 1st bit of number 15."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"anybody has the answer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Longest sequence of 1 implies the highest number in the collection. If we know the highest number in the collection, then we can return the pointer to it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Thought about a method..Let me know if sounds Ok.. 1.)keep incrementing the given integer pointer to access the elements of the array. 2.)for each integer element use the left shift operator to determine the longest sequence of 1's i.e.both \"start\" and \"end\" point..       2 a.)if the \"end\" point of previous element and starting bit of next element are continuous and greater increase the global count of \"Continous 1's\" and their starting position. 3.)For each element maintain the the number of continous 1 bits from the 16th bit.      3 a.)if the \"end\" point of previous element and starting bit of next element are continuous and greater increase the global count of \"Continous 1's\" and their starting position. 4.)finally we will have the global variable with maximum 1's with their start and endpoints.Probably return a type casted character pointer to the starting point..  I know I have written it in a confused manner. But I hope u get the Idea.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I don't think we need to consider endian problem, as long as we compare bit by bit."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I got a method: 1)Define a signature for each int. For example, an integer like 1111,0011,1111,0000 will have a signature in string as \"14021604\". The even char in the signature is either 0 or 1, while the odd char is the # of consecutive 0 or 1, which is represented in hex (since the consecutive # of 0 or 1 may be larger than 10, but we only want represent the # as one char). 2)therefore, we can convert the whole array into a string. 3)Go through the whole string, it is easy to get the longest consecutive sequence of 1 and its bit position. For example, we have an array like: 3, 4, 5, 7, if we represent each int as 4 bits, we will have 0011, 0100, 0101, 0111. Then we have the signature: \"0212\",\"011102\",\"01110111\",\"0113\". Then we go through the string, we can get the longest consecutive sequence is 3."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how about taking two character pointers pointing to beginning of array and move till its size. moving a pointer one by one as soon as u find 1 and simultaneously tracking the sequence count and initial pointer of sequence."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would suggest to have a 16 bit long bitmask with first bit set as 1 and rest set to zero. Do AND of that with a given integer. Check if output is 1 else do left shift of 1 bit on bitmask and check for 1 again. Once you got 1, store it and check for longest sequence in a similar way."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this is problem on bit array(search wiki) ,implement iterator over bitarray ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I don't think that it is important point to return pointer to bit. What is important that the algorithm implementation."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Tested this in VC++, but can't figure out how to return ptr to bit.  void printArrayBits (int *ptr, int arraySize) {   unsigned int i = 0, j = 0;   unsigned char *p = 0;    p = (unsigned char *) ptr;   for (i = 0; i < arraySize * sizeof(int); i++) {     printf (\"%08X: \", i+p);  for (j = 0; j < 8; j++) {   if (*(p+i) & (0x80 >> j))    printf (\"1\");   else    printf (\"0\");  }  printf (\"\\n\");   } }  unsigned char *findLongestContinuousOneBitsInArray (int *ptr, int arraySize) {   unsigned int i = 0, j = 0;   unsigned char *retPtr = 0;   unsigned char *p = 0;   unsigned char *q = 0;   int numOfOnes = 0;   int maxNumOfOnes = 0;      p = (unsigned char *) ptr;   for (i = 0; i < arraySize * sizeof(int); i++) {     for (j = 0; j < 8; j++) {    if (*(p+i) & (0x80 >> j)) {      if (numOfOnes == 0) {     // remember where we started     q = (p+i);   }      numOfOnes++;    } else {      if (numOfOnes > maxNumOfOnes) {     maxNumOfOnes = numOfOnes;     retPtr = q;   }   numOfOnes = 0;    }  }   }      // In case the array is all 1's   if (numOfOnes > 0 && q == 0) {     retPtr = q;   }        return retPtr; }  int main(int argc, char* argv[]) {  int arr[5]={1,13,12,8,7};   printArrayBits (arr, 5);  unsigned char *p = findLongestContinuousOneBitsInArray (arr, 5);   printf(\"\\n the answer is %p\",p);  getchar();   return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"unsigned int index=0; unsigned int max_bits=0; unsigned int temp_bits=0; unsigned int flag=1;  for(i=0;i< ARRAYSIZE;i++) {    flag = 01U; for(j=0;j{ if(a[i]& flag) temp_bits++ flag = flag << 1; } if(temp_bits > max_bits) index=i; } return i;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"unsigned int index=0; unsigned int max_bits=0; unsigned int temp_bits=0; unsigned int flag=1;  for(i=0;i< ARRAYSIZE;i++) {    flag = 01U; for(j=0;j{ if(a[i]& flag) temp_bits++; flag = flag << 1; } if(temp_bits > max_bits) index=i; } return i;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"unsigned int index=0; unsigned int max_bits=0; unsigned int temp_bits=0; unsigned int flag=1;  for(i=0;i< ARRAYSIZE;i++) {    flag = 01U; for(j=0;j{ if(a[i]& flag) temp_bits++; flag = flag << 1; } if(temp_bits > max_bits) index=i; } return i;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"unsigned int index=0; unsigned int max_bits=0; unsigned int temp_bits=0; unsigned int flag=1;  for(i=0;i< ARRAYSIZE;i++) { flag = 01U; for(j=0;j{ if(a[i]& flag) temp_bits++; else { if(temp_bits > no_bits) no_bits=temp_bits; temp_bits=0; } flag = flag << 1; } if(temp_bits > max_bits) index=i; } return i;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"unsigned int index=0; unsigned int max_bits=0; unsigned int temp_bits=0,no_bits=0; unsigned int mask=0;;  for(i=0;i < ARRAYSIZE;i++) {    mask = 1;    no_bits = 0;    for(j=0;j    {       if(a[i] & mask)       temp_bits++;       else       {         if(temp_bits > no_bits)          no_bits=temp_bits;          temp_bits=0;       }       mask = mask << 1;     } if(no_bits > max_bits) index=i; } return i;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void get_indexes(int *array_index,int * bit_index,int *array) {    unsigned int max_bits=0;   unsigned int temp_bits=0,no_bits=0;   unsigned int mask=0;   unsigned int temp_bit_index=0;    for(i=0;i < ARRAYSIZE;i++)   {    mask = 1;    no_bits = 0;    for(j=0;j   {      if(array[i] & mask)      temp_bits++;      else       {         if(temp_bits > no_bits)         {          no_bits=temp_bits;           temp_bit_index =j - temp_bits;          temp_bits=0;         }      mask = mask << 1;    }    if(no_bits > max_bits)    {     array_index=i;     bit_index = temp_bit_index;     }   }    return; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The following function will work  #define ARRAYSIZE some value #define INTSIZE 16  void get_indexes(int *array_index,int *bit_index,int *array) {   unsigned int max_bits=0;   unsigned int temp_bits=0,no_bits=0,temp_bits1=0;   unsigned int mask=0;   unsigned int temp_bit_index=0;    int i=0,j=0;    for(i=0;i < ARRAYSIZE ;i++)   {    mask = 1;    no_bits = 0;    temp_bits=0;    for(j=0;j   {      if(array[i] & mask)      temp_bits++;      else       {         if(temp_bits > no_bits)         {               no_bits=temp_bits;               temp_bit_index = j - no_bits;               temp_bits=0;         }       }      mask = mask << 1;          }    if((no_bits > max_bits) || (temp_bits > max_bits) )    {      max_bits=temp_bits > no_bits ? temp_bits : no_bits;     *array_index=i;     *bit_index = temp_bits > no_bits ? (j - temp_bits) : temp_bit_index;     }    }    return; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this should work, any advice ? ( make a little change, return max length of '1', no start position )"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13204662","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"20","title":"Calculate number of zeros in a given integer.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"15","title":"Is it to find the zeros in binary format? If yes then:  count = 0 while (n>0) { count = count + !(n&1) n=n>>1  //Right shift by 1 } return count  To find in decimal format the  count = 0 while (n>0) { count = count + (n%10>0 ? 0 : 1) n = n/10; } return count"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"while(num!=0) \n    { \n        k=num%10; \n \n        if(k==0) \n        count++; \n \n \n        num=num/10; \n \n    } \n    cout<<\"\\n\"<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It can be found by finding number of times 5 appears in the factors, since 5 *2 always gives one zero. So to proceed, try to find maximum value of n in 5^n in case where number is divisible. Ex: 100 => 5^2 , therefore n = 2 so maximum trailing zeros are 2."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int findZeroBit(int num)  {  int n=1,count=0;  while(n <= num)  {   if(!(n & num))    count++;   n<<=1;     }  return count;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int findZeroBit(int num)  {  int n=1,count=0;  while(n <= num)  {   if(!(n & num))    count++;   n<<=1;     }  return count;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would it by counting the number of ones and subtracting from sizeof(integer).   Assume input = v  for (int c =0; v; v>>1)  c+= (v&1)  At end 'c' will contain number of ones in number  So number of zeros is:   NoOfZeros = sizeof(int) *8 - c  (8= number of bits in byte. I guess this is an assumption so the code may not be fully portable)  So final code   int NoOfZeros(int v) {  for (int c = 0; v; v>>1)  c+= (v&1);    return sizeof(int)*8-c;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int FindZeros(uInt val) {     static uInt cnt = 0, loop = 0;     if(loop == 32)     {         return cnt;     }     loop++;     if(!(val & 1))         cnt += 1;     FindZeros(val >> 1); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int count_zero_bits(int n) \n{ \n   int x = ~o; \n   x=x^n;    // this will mask the bits that are set to 1,  \n   int count=0; \n  while(x!=0) \n   { \n      if(x&1==1) \n       { \n           count++; \n \n       } \n   x=x>>1; \n   \n   } \n \n return count; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int count_zero_bits(int n) \n{ \n   int x = ~o; \n   x=x^n;    // this will mask the bits that are set to 1,  \n   int count=0; \n  while(x!=0) \n   { \n      if(x&1==1) \n       { \n           count++; \n \n       } \n   x=x>>1; \n   \n   } \n \n return count; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"It can be done as follows. int num=1034000500;   int count =0;   while(num>0){   int modn=num%10;   num=num/10;   if(modn==0){    count++;   }    }  // count is the result."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"for(int i = 0; i < sizeOf(int) * 8 ; i++) {      x & x-1     count++; }  Answer = sizeOf(int)*8 - count  Basically number of 1's minus the total possible binary digits."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=9503107","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"31","title":"How do you determine if every digit in the binary representation of a number is a one?  I'll post the answer in a bit, think about it first!","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Adding 1 to all 1s will produce a perfect power of 2 => n & (n+1) == 0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"n & (n+1) == 0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Well, unsigned.  Like 7 for instance is 111.  If a number j is n bits in it's binary form, then do this: j & (first n bits of j+1) == 0.  If that's true, then the number was all ones."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"step1: negate the number (~q say number is q) step 2: find xor of the two number(Q xor ~Q) step 3: IF step2 result == Q all the every digit in binary is 1 else false"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if(~num == 0) {printf(\"the num contains all ones\\n\");}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Cant we just do an XOR with all 1's ???"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Allones {    public static void main(String args[]){      int no = Integer.parseInt(\"10\", 2);      System.out.println((no&(no+1))==0);   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if( (n& ~0)== ~0)          printf(\"\\nAll bits set to 1\\n\");    else        printf(\"\\nNot set to 1 all bits\\n\");"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorry it shud be     if((n&~0)==(unsigned)(~0))          printf(\"\\nAll bits set to 1\\n\");    else         printf(\"\\nNot all bits set to 1\\n\");  Forgot to Typecast with Unsigned ;-)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i asked why im here when reading all these answers. here actually is the valid numbers, 1, 11, 111, 1111, 11111, ..., 11111111"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"return ~x == 0;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i have 2 similar answers. the 1st one is"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"if (signednum == -1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I guess n^n == 0 will also work."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15030806","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"11","title":"A log file which has user details(user ID,timestamp) and pages visited in a particular day by that user.The next day -the same kind of log file gets generated.How do you find the probability of users who logged in consecutive days out of the second day - logged in users? The question is simple,but they look for the efficient data structure and time complexity.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Well this pretty much means finding repeating user ids in the second log file.  One must ask how big are these log files or even better how many unique UIDs will it have. If they are big enough to to be held in memory then just parse UIDs from first log file and add them to a HashSet, while parsing the second file check if each uid exists in the set. contains operation in hashset will take O(1) time and so does add operation. Summing up, this program will take O(n+m) time where n is number of users in first log file and m is number of users in second."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"If the data is tooo big that you cannot put it in memory at once, then follow this approach:  1. Apply a hash function h1(k) on the UserLog1 and UserLog2 files and partition the data into smaller chunks so that each of which can fit into memory. 2. Lets suppose that you get m files for UserLog1 and UserLog2 after step 1. 3. Now prepare a in memory hashSet for the first partition of UserLog1 file. 4. Now check for each element of UserLog2 file, if its already there in the hashSet prepared in step 3. If yes, then add it to a different list of duplicateUsers. Else, continue looking for next element until you are done with all the elements. 5. Repeat steps 3, 4 and 5 for second, third and all partitions of UserLog1 and UserLog2 files."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Step1:  awk -F ','  '{print $1}' file1.txt  > file2.txt                             // get ids only Step2:  awk '!x[$1]++' FS=\",\"  file2.txt   > userId.log                    //get distinct id"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"cat day2 | awk -F\",\" '{print$1;}' > UserId2 cat day1 | awk -F\",\" '{print$1;}' > UserId1 comm -13 UserId1 UserId2 >> ans"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"The probability cannot be determined by just looking at the second day log.  Even if a user  had 0 or a million log entries  on second day you must make assumptions about the probability distribution  from day to day to give an answer.  For example assume flipping a coin has a probability distribution or 50-50  heads  versus tails.  One day in N trials it could come up 50-50 heads and tails. The next day the trials  could  wind up being 100% heads.  So based on second day data you would then surmise that probability is 100% heads. And so you answer the first day that 100% heads was probability. But obvoiusly, this is a mistaken conclusion since you are making a faulty assumption about the probability distribution  based on one days data."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"As pointed out previously, this question is about the probability. Even if you assume a prior belief the question by itself does not have enough data to answer the question. I believe the interviewer wants us to ask questions about what is the relation between the users logging in the second day after the first day and so on. if you have enough information then you can do some bayesian inference on it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@bhargav : In that case you can use Arraylist"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think question has asked to find the probability. Can we take small chunk of file for different time stamps like [0-1], [8-9],[16-17] hours and do the hashing stuff."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=64254","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"19","title":"Write a method to check if a number is power of 2","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"f = !(v & (v - 1)) && v;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int power_of_two(int x) {    if (x % 2)       return null;        return power_of_two(x/2); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int powerOfTwo(int n) {     int count = 0;     while(n) {         n = n&(n-1);         count++;     }     if (count <= 1)        return 1;     else        return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int powerOfTwo(int n) { //If we have have more than 1 bit set return false if ( n&(n-1) )    return 0; return 1; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int powerOfTwo(int n) { //If we have have more than 1 bit set return false return !(n & (n-1) ); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"could somebody explain why only check n&(n-1)is OK? Thanks."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"coz when you do (n & (n-1)), the resulting binary number will have number of 1 bits exactly one less than original number. Try it your self by playing with some numbers. So, If  (n & (n-1)) is zero, it means that n has only one 1-bit. Any number that has exactly one 1-bit, is power of two."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Some more bit manipulation  int n; take input in n;  n <<= 31; n >>= 31;  if(n&1) print odd; else print even;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"n&(n-1) logic only works if n > 1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about checking the last bit? (!(n & 1)) ==> Even else Odd."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A number would be a power of two if there is exactly one bit that is equal to 1 in its bit pattern (even 1 is a power of 2. 2 raised to the power zero is 1). Now we could use the method that we used to count the number of bits that are 1 in a given number and check if it is equal to 1. However that approach needs many steps and hence won??t suffice here.  In a number which is an exact power of 2 only 1 bit is set and all others are zero. Let the position of this 1 bit be MSB. Mathematics rules for binary numbers tells us that if we subtract 1 from this number then the number that we would get would have all its bit starting from the bit position MSB+1 set to 1. For example if the given number num is 8(00001000) then num-1 would be 7 (00000111). Now we notice that these two bit patterns dont have a 1 in the same bit position. Further observation suggests that if we bitwise and (&) both these numbers we would get zero.  bool isPowerOf2(int num) {    return ((num>0) && (num & (num-1))==0); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For a number to be a power of 2, only one of the bits has to be set and others zero. In the below code, you test the last bit if zero, you rotate the bits till you find 1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{ if(!(num & (num - 1)) && num) { // Power of 2! } }  OR  { if(((~i+1)&i)==i) { //Power of 2! } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Method 1:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16012679","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"Design a Tic Tac Toe Game. Classes Segregation and Code Flow.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"The key thing on this type of question is not to freeze up.  Get something on the whiteboard:  1) You want to draw the board.  Have a DrawBoard class (or function). 2) You have players.  Have a Player class. 3) Players take turns.  Have a GamePlay class. 4) You need to keep track which moves have been made.  Have a Game class. 5) You need to decide if somebody won.  Have a GameEvaluate class.  Get something out there, then work with the interviewer to simplify things.  Do you really need a special GameEvaluate class?  Maybe a Game object can supply the method that says whether a game is over.  Seems like a reasonable responsibility for the game class.  But maybe the actual calculation drives out a simple Matrix class.  The key thing here is to be flexible and brainstorm.  Also, don't let the full complexity of the problem overwhelm you.  Before you figure out how to orchestrate players taking turns, simplify the problem.  Say that you just read the player's answers from a file, fill in the grid, and then say who won.  If you can figure out how to model that, you have a good foundation for the rest of the problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Main Class will be as follows:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Tic Toc game simulation.......... \n#include \n#include \n#include \nchar bord[3][3]={{'1','2','3'},{'4','5','6'},{'7','8','9'}}; \nchar win_status='\\0',turn='\\0'; \nchar win_check(char); \nvoid add_on_board(char); \nvoid print(void); \nvoid main() \n{ \n  \n printf(\"Welcome to Tic Toc Game\\n\"); \n printf(\"Rule-1: Two players, A and B.\\n\"); \n printf(\"Rule-2: A has 'X' and B has 'O' piece on board. \\n\"); \n printf(\"Initial status of board\\n\"); \n  \n print(); \n char e='\\0',f; \n int n=1; \n printf(\"ready to play?(y/n):\"); \n scanf(\"%c\",&f); \n f=getchar(); \n while(win_status=='\\0' && n<5) \n { \n  system(\"clear\"); \n  printf(\"For A ==> X\\nFor B ==> O\\n\\n\"); \n  print(); \n  if(win_status=='\\0') \n  { \n   turn='A'; \n   printf(\"A 's turn: press number:\"); \n   fflush(stdin); \n   //sleep(3); \n   scanf(\"%c\",&e); \n   f=getchar(); \n   //scanf(\"%c\",&f); \n   add_on_board(e); \n   win_status=win_check('X'); \n   print(); \n  } \n  if(win_status=='\\0') \n  { \n   turn='B'; \n   printf(\"B 's turn: press number:\"); \n   fflush(stdin); \n   scanf(\"%c\",&e); \n   f=getchar(); \n   add_on_board(e); \n   win_status=win_check('O'); \n   print(); \n  } \n  n++; \n } \n switch(win_status) \n { \n  case 'A': \n   printf(\"Winner is ---A---\\nCongrates\\n\"); \n   break; \n  case 'B': \n   printf(\"Winner is ---B---\\nCongrates\\n\"); \n   break; \n  default: \n   printf(\"Match draw!\\n\"); \n } \n  \n} \nchar win_check(char p) \n{ \n char temp[3]={'\\0'}; \n int i=0,j=0,k=0; \n for(i=0;i<3;i++) \n { \n  for(j=0;j<3;j++) temp[j]=bord[i][j]; \n   \n  for(k=0;k<3;k++) if(temp[k]!=p) break; \n   \n  if(k==3) return (p=='X'?'A':'B'); \n } \n for(i=0;i<3;i++) \n { \n  for(j=0;j<3;j++) temp[j]=bord[j][i]; \n   \n  for(k=0;k<3;k++) if(temp[k]!=p) break; \n   \n  if(k==3) return (p=='X'?'A':'B'); \n } \n for(i=0;i<3;i++) temp[i]=bord[i][i]; \n  \n for(k=0;k<3;k++) if(temp[k]!=p) break; \n  \n if(k==3) return (p=='X'?'A':'B'); \n  \n for(i=0;i<3;i++) temp[i]=bord[i][2-i]; \n  \n for(k=0;k<3;k++) if(temp[k]!=p) break; \n  \n if(k==3) return (p=='X'?'A':'B'); \n  \n return '\\0'; \n} \nvoid add_on_board(char c) \n{ \n int i=0,j=0; \n for(i=0;i<3;i++) \n { \n  for(j=0;j<3;j++) \n  { \n   if(bord[i][j]==c)  \n   { \n    bord[i][j]=(turn=='A'?'X':'O');  \n    return; \n   } \n  } \n } \n} \nvoid print(void) \n{ \n int i=0,j=0; \n printf(\"\\n\"); \n for(i=0;i<3;i++) \n { \n  for(j=0;j<3;j++) \n  { \n   printf(\"%-4c\",bord[i][j]); \n  } \n  printf(\"\\n\"); \n } \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13225741","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"26","title":"Given a function, take a number and the bit position and return true if that bit is set to 1 and false otherwise.  It took me a few minutes to think something like this, pasted code is after he corrected me on 2 silly mistakes.   bool ret_result(int number, int pos) {          int k=1;          for(int i=0;i         k=k<<1;          }        if(number&k==1) {                 return true;         }        else {                 return false;         } }","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"k = 1 << pos return ((number & k) > 0)  number & k may not be 1  number = 100 pos = 3 100 & 100 = 100 (4) not 1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"You want to check that \"number AND k\" preserves k"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"One way is :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Another way could be: bool is_set(int number, int pos){    return ((bool)(number>>pos)&0x1); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"(number & k) > 0 should read as (number & k) != 0 [or simple (number & k) if in C] in all the codes above.  If the shifting puts the bit to the topmost bit in k than the result will be negative, but still non-zero."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static boolean findbit(int no,int pos) \n { \n  int k=1<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"boolean bitset(int no,int pos) {   return (no & (1 << bit)) != 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You need to consider whether the bits are counted from 0 or 1. The above approaches wroks if the bits are counted from 0, but if counted from 1, below is the solution. bool bitset(int number, int pos) {    return (number & pow(2,(pos-1)) ; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what will happen when pos<0?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"probably you can just divide num by 2 for position number of times and then take num % 2. if the result is 1 then return true else return false."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"y u use the loop u jst shift the number by (pos -1) unit to right and and with 1.u get the result."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"return (n>>p & 1) ? true : false;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"return ((1<>pos;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"return ( num & pow( 2 , pos ) ) ? true : false"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"another method..."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=9607833","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"23","title":"The function signature looks like this:  boolean isPalindrome(int x) It should return true if the the bit pattern of x is the same as when you reverse it.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"@Anonymous: it doesn't matter. Here is my solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do we need to consider all bits in sizeof(int)?? Or only the number of digits required to represent that integer in binary notaion. e.g. lets say sizeof int is 4 byte=32 bits so 5 = 00000000000000000000000000000101 or we need to consider only 101"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Not a efficient program, but works below code:  int n=0, num = 9;  int val = num;  while(num)  {   n = n << 1;   n |= (1&num);   num = num >> 1;  }  if(n == val)   cout << \"Palindrome\" << endl;  else   cout << \"NOT Palindrome\" << endl;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int ispalindrome(int x) \n{ \n        int n=x,y=0; \n        while(n) \n        { \n                y=(y<<1) | (n&1); \n                n = n>>1; \n        } \n        return x==y; \n} \n  \nint main() \n{ \n        int a=3; \n        printf(ispalindrome(a)==1?\"Palindrome.\":\"Not a palindrome.\"); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"HI Guys You Can No One Has Given The Algorithm Here , so if anyone interested to analyze that ,i coded & explained it here  some time back , you can have a look , comment if anything wrong shashank7s dot blogspot dot com/2011/05/wap-to-check-that-binary-representation dot html  Shashank"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is an optimization for the case when the palindrome has an even number of bits."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int palindrome(int x){ \n     int i ; \n     for(i = 0; i < 32; i++){ \n         if( ( (x >> 31 - i) ^ ( x & (1 << i)) ) != 0) \n             return 0; \n     } \n     return 1; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#define TRUE 1 \n#define FALSE 0 \n \nint is_palindrome(int x) \n{ \n    int reverse = 0; \n    int result; \n    int y = abs(x); \n \n    while (y != 0) { \n        reverse = reverse << 1; \n        if ((y & 1)) \n            reverse = reverse | 1; \n \n        y = y >> 1; \n    } \n \n    result = reverse & abs(x); \n    if (x < 0) result = 0 - result; \n \n    return (x == result) ? TRUE : FALSE; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#Python { def palindrome(a):  b=a[::-1]  if (b==a): return True  else: return False } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#define isOne(num,pos)  (( num & ( 1 << pos ) ) ? TRUE : FALSE ) \nint isPalindrome( int num ) { \n   for( pos = 15 ; pos != -1 ; pos-- ) \n      res = res + ( ( isOne(num,pos) ) ? ( 1 << (15 - pos) ) : 0 ); \n   return ( num == res ); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is another version......"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this logic   boolean is_palindrome(int x) {     int comp=~x;    if( x&comp==0) return true ;    else false; }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=12651670","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"13","title":"Write a function to convert an IPv4 Address in string format to an unsigned integer","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"unsigned int ip_str_to_int(char *str) {      unsigned int ip=0;        while(*str) {             ip = (ip *10) + (*str -'0');             *str++;             if (*str && *str++ == '.')  //skip period                 *str++;        }    return ip; }  assuming passing valid four octet ip address string..u can add validation part before calling this function."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"I think this can be easily done using bitwise operators  perl:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public double IPAddressToNumber(string IPaddress) {     int i;     string [] arrDec;     double num = 0;     if (IPaddress == \"\")     {        return 0;     }     else     {        arrDec = IPaddress.Split('.');        for(i = arrDec.Length - 1; i >= 0 ; i --)        {           num += ((int.Parse(arrDec[i])%256) * Math.Pow(256 ,(3 - i )));        }        return num;     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In .NET"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In C, with no error handling, and using built-in functions for string searching and decimal conversion:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In c++:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"index = binarySearch(intArray, searchValue); \n  if (index != -1) { \n   System.out.println(\"Found at index: \" + index); \n  } else { \n   System.out.println(\"Not Found\");"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class ParseIPv4 { \n  \n public static void main(String[] args){ \n  String ip = \"192.168.0.1\"; \n  ip = ip.replace(\".\",\"\"); \n  int num = Integer.parseInt(ip); \n  System.out.println(num); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why not use sprintf?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #define STR1 \"192.168.72.46\" #define STR2 \".192.168.72.46\" #define STR3 \"192..72.46\" #define STR4 \"192.72.46\" #define STR5 \"192.168.\" #define STR6 \"192.168.72.46.23.44\" #define STR7 \".1923.168.72.46\" #define STR8 \"192.168.#72.46\"   unsigned long str_to_ip(char *str) {   unsigned long ip = 0;unsigned long tmp = 0;char dotcount = 0, numcount = 0;  //First character cannot be anything ohter than  // '0' to '9'  if(*str > '9' || *str < '0')   return 0;   while( *str )  {      //subsequent characters cannot be anything other than   // '0' to '9' and '.'   if((*str > '9' || *str < '0') && (*str != '.')        /*&& (*str != '\\0')*/){    //printf(\"returning from first if in while\\n\");    return 0;   }   else{     if(*str == '.'){     //following character cannot be anything other than     // '0' to '9'     if(*(str+1) > '9' || *(str+1) < '0')      return 0;     if(numcount > 3)      return 0;      dotcount++;numcount = 0;     str++;      ip |= tmp << ((4 - dotcount)*8);     //printf(\"tmp = %ld dot count = %d\\n\", tmp << 24, dotcount);     //printf(\"IP = %ld\\n\", ip);     tmp = 0;    }    else{     tmp = (tmp * 10) + (*str - '0');     //printf(\"tmp = %ld num count = %d\\n\", tmp, numcount);     str++;     numcount++;    }         }   if(dotcount > 3)    return 0;  }     if(dotcount < 3)    return 0;   ip |= tmp ;   //printf(\"tmp = %ld dot count = %d\\n\", tmp, dotcount);   //printf(\"IP = %ld\\n\", ip);  return ip; }   int main() {  int i;  unsigned long ip  = 0;  printf(\"Testing function to convert IPv4 addr in string form to integer\\n\");  printf(\"Input : %s    Output : %ld\\n\", STR1, ip = str_to_ip(STR1));  printf(\"Input : %s    Output : %ld\\n\", STR2, ip = str_to_ip(STR2));  printf(\"Input : %s    Output : %ld\\n\", STR3, ip = str_to_ip(STR3));  printf(\"Input : %s    Output : %ld\\n\", STR4, ip = str_to_ip(STR4));  printf(\"Input : %s    Output : %ld\\n\", STR5, ip = str_to_ip(STR5));  printf(\"Input : %s    Output : %ld\\n\", STR6, ip = str_to_ip(STR6));  printf(\"Input : %s    Output : %ld\\n\", STR7, ip = str_to_ip(STR7));  printf(\"Input : %s    Output : %ld\\n\", STR8, ip = str_to_ip(STR8)); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"char *str = \"192.168.100.2\""},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \nint main (int argc, char **argv) \n{ \n    unsigned int  octet = 0,ip_addr = 0; \n    char *str_ip, str[256]; \n \n    str_ip = str; \n    printf(\"Please provide IPV4 address in string format \\n\"); \n    scanf(\"%s\", str_ip); \n    printf(\"IP address: %s\\n\", str_ip); \n \n    while (*str_ip) { \n        octet = octet * 10 + (*str_ip - '0'); \n        printf(\"str %c octet 0x%x\\n\", *str_ip, octet); \n        str_ip++; \n        if ((*str_ip == '.') || (*str_ip == 0)) { \n            printf(\"ip_addr 0x%x\\n\", ip_addr); \n            ip_addr =  (ip_addr << 8) | octet; \n            printf(\"ip_addr 0x%x\\n\", ip_addr); \n            octet = 0x0; \n            if (*str_ip) \n                str_ip++; \n        } \n    } \n    printf(\"IP Address Hex: 0x%x, network order 0x%x\\n\", ip_addr, htonl(ip_addr)); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Removed debug statements..."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=9286520","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"12","title":"Given two unsigned integers, write an efficient function which returns the no. of bits needs to be flipped of one to generate the other.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"zhaoyangster that looks correct. I have one variation/minor improvement to suggest, use c=c&c-1 instead of c=c>>1 and you only loop once for each bit, instead of all the bit positions. {{ int bit_swaps_required( int a, int b ) {    unsigned int count = 0;    for( int c = a ^ b; c != 0; c = c & c-1 ) {       ++count;    }    return count; } }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"saw the solution before: Use XOR  int bit_swaps_required( int a, int b ) {     unsigned int count = 0;     for( int c = a ^ b; c != 0; c = c >> 1 ) {         count += c & 1;     }     return count; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Developer your code is working perfectly.Can u explain the logic behind c=c&c-1?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int num_bits(int x,int y) { int a,b; a=x^y; b=count_ones(a); return(b); } int count_ones(int x) { int count; while((n&(n-1))!=0) count++; return(count); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int bitswap(int a,int b) \n{ \n    int c = a^b; \n    int count = 0; \n    while(c!=0) \n    { \n       if(c&1 ==1) \n       count++; \n        \n       c = c>>1; \n    }  \n    return count; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int num_bits(int x, int y) {    int count = 0;    while(x != 0 || y != 0)    {     if((x&1)!=(y&1))     {       count++;     }     x = x>>1;    y = y>>1;    }  return count; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int bit_flip(int x, int y) {     int count=0;     z=x^y;     while(z)     {      z&=z-1;      count++;     }    return count; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int flipBits(int a, int b){ \n        int c = a ^ b; \n        int count =0; \n while(x!=0){ \n  if((x&1)==1){ \n   count++; \n  } \n  x= (x>>>1); \n } \n        return count; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here size of int is 2 bytes.... so i started pos from 15( left to right )"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=1741862","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"10","title":"given a number, 9th bit set or not?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool isSet = (num & (1<<8)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"((a>>8)>> 1) & 1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Doesnt sound like amazon question........2 easy"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"((a>>8)&1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a & 2^8"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"set(int x) {  int n=9;   n=1<<(9-1);  if((x&n))     printf(\"Bit not set:1\");  else    printf(\"Bit set:0\"); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int n; n=1<<8; if (x&n) then true"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"return num & 0x00000100"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=163679","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"Given an 8 bits, give the range of integers it can cover.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"idea's answer is correct for range containing +ve as well as -ve number equally distributed...Mike C's answer is correct too. I don't understand WTF amazon people ask such kinda of dumb questions...Oh Jesus!!!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Range will be from -128 to 127 general rule for n bits is--> from -2^(n-1) to (2^(n-1))-1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Range could also be 0 to 255 if you only choose unsigned integers In this case, from 0 to (2^n)-1"}]}}]