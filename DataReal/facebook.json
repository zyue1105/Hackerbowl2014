[{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15421954","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"9","title":"Design a realtime service that tells users which of their friends are currently online.  Your service must implement two functions:","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"We can not keep all the user online status in a hash map.. it will simply go out of memory for millions of users.   The idea is to implement a hashmap only, but distribute it across multiple servers just like Distributed Hash Tables (DHT). In DHT, we can setup multiple servers (nodes) and assign them the key space ( for eg. 1-100 user ids in node n1, 101-200 user ids in node n2 and so on) and then to set the online status of a user, you can simple send request any node, it will take care of routing the request to the actual node. Same with the getOnlineFriends status."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This is an implementation of the Push/Pull Model. The first time you go online you pull the data of your online friends, there after you push your name into the Active Maps of all the Users. When thier status changes they push their status to all the people in the Map. Read Observer/Observable design pattern for this."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"in setOnline, check if friend, if so add to hashmap, else ignore.  You can check if friend, by creating a friends hashmap.  Good thing to discuss after this would be scale of things (too many friends to hold in memory, frequent setonline, etc)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming   1. There are hundreds/thousands of servers on the production fabric, each of which handle a bunch of users.  2. Each host maintains a list of active users it is handling, say, in a simple enough data structure   *Broadcast_* 1. Each server when brought online or when a new user logs in, broadcasts a packet (with user data) for each of the active users it is handling. 2. And waits for at least N acknowledgements for each packet - N is to be configured 3. An acknowledgement is sent by a server as soon as it has received and stored the data (inside the packet) in it's online_users_hash_table.   *Search_* 1. When a user logs in on one of the servers, a lookup is made in the local hash table, when no data is found for a subset or all of users, sends a broadcast message for each of the user it is looking for.  2. And waits for a response from any of the servers.  3. Any server can respond..  3.1 If the packet is not older than T seconds - T is to be configured.  3.2 If it has the status of the user requested in the packet in its local hash table. 4. All users online (indicated by the response packets) are hashed locally.  5. If there is no response for a packet sent for user U even after T2 seconds, it means he is not online."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"They have a lot of users shared on a lof of servers. In realtime system you do not have time to scan either a single DB or a number of DB in a distributed cluster for checking status of the each member in a friendlist.   1. For each user store it's online friends list with the user's data. Do not store one online friend in one DB row. Try to keep list as an JSON array in NoSql DB near by or inside th user data. 2. List getOnlineFriends(user_id):  2.1 single access to the specified user data described above. 3. setOnline(user_id): 3.1 getFriendIds(user_id) to 'friends'. 3.2 for each 'fnext' in 'friends'  add task in queue to update online friends list of the 'fnext' with the user 'user_id'. 4. You have a distributed DB so it is not strognly consistent and eventual consistency is enough for a such data as online friends list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"maybe something like this?  public class CurrentlyOnline {   // global list of all the online users in the system  private List currentlyOnlineUsers;   // a singleton class  private static CurrentlyOnline instanceHolder;   private CurrentlyOnline() {   currentlyOnlineUsers = new ArrayList();  }   public static CurrentlyOnline getInstance() {   if (instanceHolder == null) {    instanceHolder = new CurrentlyOnline();   }    return instanceHolder;  }   public List getOnlineFriends(long user_id) {   List currentUserFriendsList = new ArrayList();   // get the user's friends list   currentUserFriendsList = getFriendIds(user_id);   Long currentFriendID;    List response = new ArrayList();    for (int i = 0; i < currentUserFriendsList.size(); i++) {    currentFriendID = currentUserFriendsList.get(i);    if (currentlyOnlineUsers.contains(currentFriendID)) {     response.add(currentFriendID);    }    }    return response;  }   public void setOnline(long user_id) {   currentlyOnlineUsers.add(user_id);  }  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15419952","download_status":"DOWNLOAD_DONE","votes":"4","answersCount":"29","title":"Given a hashmap M which is a mapping of characters to arrays of substitute characters, and an input string S, return an array of all possible mutations of S (where any character in S can be substituted with one of its substitutes in M, if it exists).  What is the time complexity?  What is the space complexity?  Can you optimize either?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"The question clearly states ' return an array of all possible mutations'. This means that both time AND space must be linear in the size of the output. The point is, what is the size of the output in terms of the input.  Lets just look at the worst-case complexity, since average case is hard to even define, let alone analyse. Say the input string is of size n. The worst case is that every character has a mapping. Lets also say that all mappings have arrays of the same size, m (that is, all arrays are the longest possible arrays for that mapping). Then the number of outputs we have is n^m, which is huge.  In simple terms I can't see any way to optimise this. However, you could return a data structure like this (for the given example):  [     [f, F, 4],    [a],    [b, B, 8] ]  ie an array of arrays, where every subarray is the corresponding character, together with its mapped mutations if there are any. You could then create an iterator that uses that data structure to produce the next mutated output string from each call to next()."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Treat is like an odometer: [3,1,3]. Start with [0,0,0] -> [1,0,0] -> [2,0,0] ->[0, 0, 1] -> [1,0,1] etc. (read from right to left instead left to right).  This little space (as compared to creating lists and appending).  Here is some python code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"(function(content, htReplaceCharacters) { \n    function mutate(content, index, htReplaceCharacters, result) { \n        for (var i = index; i < content.length; ++i) { \n            var character = content.charAt(i); \n \n            var replaceCharacters = htReplaceCharacters[character]; \n \n            if (replaceCharacters) { \n                for (var j = 0; j < replaceCharacters.length; ++j) { \n                    var replaceCharacter = replaceCharacters[j]; \n \n                    var tmp = content.substr(0, i) + replaceCharacter + content.substr(i + 1); \n \n                    result.push(tmp); \n \n                    mutate(tmp, i + 1, htReplaceCharacters, result); \n                } \n            } \n        } \n    } \n \n    var result = []; \n \n    mutate(content, 0, htReplaceCharacters, result); \n \n    result.push(content); \n \n    console.log(result);  // \"Fab\", \"FaB\", \"Fa8\", \"4ab\", \"4aB\", \"4a8\", \"faB\", \"fa8\", \"fab\" \n}( \n    'fab', \n    { \n        'f': ['F', 4], \n        'b': ['B', 8] \n    } \n));"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Does anybody know the time complexity of this problem if \"f\" and \"b\" had a different number of substitutes?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution in Java. The time complexity is O(n^m) where n is the number of variable positions (in this case 2, f and b) and m is the number of possible values (in this case 3 for each, the letter + its substitutes).  The complexity is exponential but I don't believe we can improve on it since we are required to generate n^m output strings."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"my two cents in python; i think time complexity would depend on both the size of the hashtable and the size of the input.  space complexity is the same?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void printMutation(Map map, String str, \n     char[] ret, int cursor) \n    { \n if (cursor == str.length()) \n { \n     System.out.println(ret); \n     return; \n } \n \n Character ch = str.charAt(cursor); \n ret[cursor] = ch; \n printMutation(map, str, ret, cursor + 1); \n \n String mapped = map.get(ch); \n if (map.containsKey(ch)) \n { \n     for (int j = 0; j < mapped.length(); j++) \n     { \n  ret[cursor] = mapped.charAt(j); \n  printMutation(map, str, ret, cursor + 1); \n     } \n } \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a variation of telephone words:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(ans.count) time and O(ans.size) space complexity:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There is also a tricky solution with very good time and space complexities. We do not have any restrictions about output format of resultant word set, so it will be absolutely legal to output them as a trie. The main idea of algorithm is following: Given a source string and map of substitutions, let's construct a trie with a single word - source string:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This code will be ok."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In the worst case it is O(N*M), where M=max_length{{ 'F', '4' }, { 'B', '8' }, ...} so it is better to say that time is O(N*M)."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15435963","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"20","title":"Given an array of real numbers A of length n, and some integer k such that 0 <= k < n, write a function that returns the kth largest number in A, where k=0 refers to the largest number.  What is the time complexity?  What is the space complexity?  Can you optimize either?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"the naive way to sort  the array in descending order, the best complexity would be O(n*log(n)), quick sort would be fine for that and then just return Kth element. The second thought is using the standard top-N algorithm to build the the min-heap of size K+1 from the input array, the heap will contain K+1 largest elements from the input. Then return the heap top which is Kth largest. The complexity is O(n*log(K) ), the space is O(K+1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"we can do using median of medians.time complexity O(kn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"wikipedia selection algorithm"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"standard selection algorithm is optimal, but impractical.  heap (implemented as array) can be O(n log K) time and O(K) space, which can be pretty fast for smallish K.  Interesting to discuss would be representation of reals..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import heapq \ntestk = 2 \narray = [3,6,5,8,7,9,1,10,20,18,50,40] \n \nk = testk + 1 \nheap = array[0:k] \nheapq.heapify(heap) \n \nfor i in array[k:]: \n    if i > heap[0]: \n        heapq.heapreplace(heap,i) \nprint heap[0]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For this problem, we could try to use quicksort multiple times. First choose a pivot A[i], then put the doubles that is less than A[i] on its left, the doubles bigger than A[i] on its right. Then check the number of  doubles are bigger than A[i], name it m, if m>K, we throw away the part that is less or equal to A[i], K is unchanged; if m==K, we return A[i] if m The time complexity is O(n)+O(n/2)+O(n/4)+.....=O(n) in the average case. Worst case senario would be O(n^2)though. Space complexity is O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it can be done in two way:- 1)either sort the array then take the kth element from last.space complexity 0(1) time complexity o(nlogn). 2)take first k element of array and make min heap from that,for the rest element check the value of root of heap with array value if array value > root value,replace the root value with array value.space complexity is o(k) which is constant time is o(klogk)+(n-k)log(k)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"No one mentioned quickselect ? Expected complexity O(n) Here's is a java solution :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use quick select algorithm O(n) time"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"This question is a good test for the underlying understanding of tradeoff.  1> For Memory Compromise, I can use a Hash of k buckets to hold k different values which has a time advantage of O(k) but memory O(k) 2> For Time Compromise, I will use any sorting perhaps the merge sort which can provide the best of all giving O(nlogn) . (I m talking about Merge function without using extra additional array )."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15420859","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"38","title":"Write a program to sum two binary numbers represented as strings.  Input: \"110\", \"01101\" Output: \"10011\"  Method signature: public String addBinaryNumbers(String num1, String num2);","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"My little try with JS:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"My solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"std::string addTwoBinaryStrings(std::string a, std::string b) \n{ \n    size_t i = a.length() - 1; \n    size_t j = b.length() - 1; \n     \n    int carry = 0; \n    int size = i > j? i+2: j+2; \n    int index = size - 1; \n    char * result = new char[size]; \n     \n    while(i >= 0 || j >= 0) \n    { \n        int m = i >= 0? a[i--] - '0' : 0; \n        int n = j >= 0? b[j--] - '0' : 0;  \n        result[index--] = m ^ n ^ carry + '0'; \n        carry = m & n || m & carry || n & carry; \n    } \n    result[index] = carry + '0'; \n    return string(result); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public String addBinaryNumbers(String num1, String num2) { \n        int carryflag = 0, i1 = num1.length() - 1, i2 = num2.length() - 1; \n \n        StringBuilder sum = new StringBuilder(); \n        while (i1 >= 0 || i2 >= 0) { \n            int c1 = i1 >= 0 ? Character.digit(num1.charAt(i1--), 2) : 0; \n            int c2 = i2 >= 0 ? Character.digit(num2.charAt(i2--), 2) : 0; \n \n            int next_bit = c1 ^ c2 ^ carryflag; \n            carryflag = (c1 & c2 & ~carryflag) | (~c1 & c2 & carryflag) | (c1 & ~c2 & carryflag) | (c1 & c2 & carryflag); \n \n            sum.append(next_bit == 1 ? '1' : '0');  \n        }  \n \n         if (carryflag == 1) { \n            sum.append('1'); \n         } \n \n         return sum.reverse().toString(); \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"/** \n * Write a program to sum two binary numbers represented as strings. \n * Input: \"110\", \"01101\" \n * Output: \"10011\" \n * Method signature: \n * public String addBinaryNumbers(String num1, String num2); \n * \n */ \npublic class BinarySum { \n \n private static final int[] binaryValues = { 1, 2, 4, 8, 16, 32, 64, 128 }; \n \n public static void main(String[] args) { \n \n  String num1 = \"110\"; \n  String num2 = \"01101\"; \n  System.out.println(\"Add \" + num1 + \" to \" + num2); \n \n  String answer = addBinaryNumbers(num1, num2); \n \n  System.out.println(\"Answer: \" + answer); \n } \n \n private static String addBinaryNumbers(String num1, String num2) { \n  char[] charNum1 = num1.toCharArray(); \n  char[] charNum2 = num2.toCharArray(); \n \n  int intAnswer = addBinaryNumbers(charNum1, charNum2); \n \n  String binaryAnswer = convertToBinaryString(intAnswer); \n \n  return binaryAnswer; \n } \n \n private static int addBinaryNumbers(char[] num1, char[] num2) { \n \n  int totalNum1 = toBinaryValue(num1); \n  int totalNum2 = toBinaryValue(num2); \n \n  System.out.println(\"Add \" + totalNum1 + \" to \" + totalNum2); \n  int total = totalNum1 + totalNum2; \n  System.out.println(\"Answer: \" + total); \n  return total; \n } \n \n private static int toBinaryValue(char[] num) { \n  int total = 0; \n  for (int i = 0; i < num.length; i++) { \n   if (num[(num.length - 1) - i] == '1') { \n    total += binaryValues[i]; \n   } \n  } \n  return total; \n } \n \n private static String convertToBinaryString(int value) { \n  StringBuilder binaryString = new StringBuilder(); \n  for (int i = binaryValues.length - 1; i >= 0; i--) { \n   int binaryValue = binaryValues[i]; \n \n   if ((value - binaryValue) >= 0) { \n    value -= binaryValue; \n    binaryString.append(\"1\"); \n   } else { \n    binaryString.append(\"0\"); \n   } \n  } \n  return binaryString.toString(); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Very Lucky Fellow to get this question @ FB... Here it goes  1> Reverse Each String . O(n) + O(m) 2> Pointer p1 and p2 to string 1 and 2 respectively. 3> Set Overflow = 0; 4> string *s; 5> Loop until each string finishes    {         s=*p1+*p2+overflow;  overflow=*p1+*p2;         if(overflow==2)             overflow =1;          else              overflow=0;       p1++;       p2++;       s++;    }  Total Time = O(n)+O(m)+O(m or n {which ever is higher})"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a simple python code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"(function(a, b) {   function convert(str) {     str = str.split('').reverse().join('');     var carry = 0;     for (var i = 0; i < str.length; i++) {       if (str[i] === '1') carry += 1 << i;     }     return carry;   }    console.log((convert(a) + convert(b)).toString(2)); })(\"110\", \"01101\");"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"std::string addTwoBinaryStrings(std::string a, std::string b) \n{ \n int len1=a.size(), len2=b.size(); \n reverse(a.begin(), a.end()); \n reverse(b.begin(), b.end()); \n int t=min(len1, len2); \n int carry=0; \n string res=\"\"; \n for (int i=0; it) { \n  for (int i=t; i1) { \n    res+=\"1\"; carry=1; \n   } \n   else { \n    itoa(m+carry, num, 10); \n    res+=num; \n    carry=0; \n   } \n  } \n } \n if (len2>t) { \n  for (int i=t; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"correct the code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static String addBinaryNumbers(String num1, String num2){ \n   \n  char [] chleft=num1.toCharArray(); \n  char [] chright=num2.toCharArray(); \n  StringBuilder sb=new StringBuilder(); \n  int p1=chleft.length-1; \n  int p2=chright.length-1; \n  int next=0; \n  int sum=0; \n   \n  while (p1>=0||p2>=0){ \n    sum=0; \n   if (p1>=0){ \n    sum+=getDec(chleft[p1]); \n    p1--; \n   } \n    \n   if (p2>=0){ \n    sum+=getDec(chright[p2]); \n    p2--; \n   } \n   sum+=next; \n       if (sum>=2){ \n        sum=sum-2; \n        next=1; \n       }else{ \n        next=0; \n       } \n       sb.append(sum); \n  } \n   \n  if (next>0){ \n    sb.append(next); \n  } \n  return sb.reverse().toString(); \n   \n   \n } \n  \n public static int getDec(char ch){ \n  return ch-'0'; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static String AddBinaryNumbers(String s1, String s2) {   if (s1 == null && s2 == null)    return null;    while (s1.length() != s2.length()) {    if (s1.length() > s2.length()) {     s2 = \"0\" + s2;    } else     s1 = \"0\" + s1;   }    int len = s1.length() - 1;   char c1[] = s1.toCharArray();   char c2[] = s2.toCharArray();   String result = \"\";   int carry = 0;   while (len != -1) {    int temp = (c1[len] - '1' + 1 ^ c2[len] - '1' + 1) ^ carry;    carry = (c1[len] - '1' + 1 & c2[len] - '1' + 1) ^ carry;    result = temp + result;    len = len - 1;   }   System.out.print(result);   return result;   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is super easy to implement in python:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static String add(String bin1, String bin2) { \n \n        String result = \"\"; \n \n        String longer = bin1.length() > bin2.length() ? bin1 : bin2; \n        String smaller = bin1.length() > bin2.length() ? bin2 : bin1; \n \n        int diff = longer.length() - smaller.length(); \n \n        result = result.concat(longer.substring(0, diff)); \n \n        longer = longer.substring(diff, longer.length()); \n \n        for (int i = 0; i < smaller.length(); i++) { \n            result = result.concat((Character.getNumericValue(longer.charAt(i))| Character.getNumericValue(smaller.charAt(i)))+\"\"); \n        } \n \n        return result; \n \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public String addBinaryNumbers(String num1, String num2) { \n         \n        String longestNumber = num1.length() > num2.length() ? num1 : num2; \n \n        int padCount = longestNumber == num1 ? num1.length() - num2.length() : num2.length() - num1.length(); \n \n        String pad = \"\"; \n         \n        for(int i = 0; i < padCount; i++) \n         pad += \"0\"; \n         \n        if(longestNumber == num1) \n        { \n         num2 = pad + num2; \n        } \n        else \n        { \n         num1 = pad + num1; \n        } \n \n        String result = \"\"; \n        int carry = 0; \n \n        for(int i = longestNumber.length() - 1; i >= 0; i--) \n        { \n            int num1Int = Integer.parseInt(num1.charAt(i)+\"\"); \n            int num2Int = Integer.parseInt(num2.charAt(i)+\"\"); \n \n            int currentSum = num1Int + num2Int + carry; \n            if(currentSum >= 2) \n            { \n                carry = 1; \n                if(currentSum == 2) \n                 result += \"0\"; \n                else \n                 result += \"1\"; \n            } \n            else \n            { \n                carry = 0; \n                result += currentSum; \n            }    \n        } \n \n        if(carry == 1) \n            result += carry; \n         \n        String finalResult = \"\"; \n        for(int i = result.length() - 1; i >= 0; i--) \n            finalResult += result.charAt(i); \n         \n        return finalResult; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"string decimal_to_binary_string(unsigned int n) {   string num = \"\";   while(n) {     num = ((n%2) ? \"1\":\"0\") + num;     n /= 2;   }   num += (!num.size() ? \"0\":\"\");   return num; }  string binary_sum(string num1, string num2) {   return decimal_to_binary_string(strtoul(num1.c_str(), NULL, 2) +                                   strtoul(num2.c_str(), NULL, 2)); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"/** \n  *  \n  * N = max(num1.length, num2.length) \n  *  \n  * time: O(N)) \n  * space: O(N) \n  *  \n  * @param num1 \n  * @param num2 \n  * @return \n  */ \n public static String addBinaryNumbers( String num1, String num2 ){ \n   \n  if( num1 == null || num2 == null ){ \n   throw new IllegalArgumentException(\"NULL string passed\"); \n  } \n   \n  if( \"\".equals(num1.trim()) || \"\".equals(num2.trim()) ){ \n   throw new IllegalArgumentException(\"EMPTY string passed\"); \n  } \n   \n  final int length1 = num1.length(); \n  final int length2 = num2.length(); \n   \n  final StringBuilder buf = new StringBuilder( Math.max(length1, length2) + 1 ); \n   \n  int carry = 0;   \n  int index = 0;   \n   \n  int digit1, digit2, res; \n   \n  while( index < length1 || index < length2 ){ \n    \n   digit1 = index < length1 ? (num1.charAt(index) - ZERO_CH_VALUE) : 0; \n    \n   if( digit1 != 0 && digit1 != 1 ){ \n    throw new IllegalArgumentException(\"Not a binary string: '\" + num1 + \"'\"); \n   } \n    \n   digit2 = index < length2 ? (num2.charAt(index) - ZERO_CH_VALUE) : 0; \n    \n   if( digit2 != 0 && digit2 != 1 ){ \n    throw new IllegalArgumentException(\"Not a binary string: '\" + num2 + \"'\"); \n   } \n    \n   res = digit1 + digit2 + carry; \n    \n   buf.append( res & 1 );    \n   carry = res >>> 1; \n    \n   ++index;    \n  } \n   \n  if( carry > 0 ){ \n   buf.append( carry ); \n  } \n   \n   \n  return buf.toString(); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public static String returnZero(int len){    String str=\"\";    for(int i=0;i    str+=\"0\";    }    return str;   }  public static String addBinaryNumbers(String s1,String s2){   String result = \"\";         int carry = 0;         if(s1.length()>s2.length()){    s2= CompairString.returnZero(s1.length()-s2.length())+s2;   }else{    s1= CompairString.returnZero(s2.length()-s1.length())+s1;   }     for(int i=s1.length()-1;i>=0;i--){    int num1Int = Integer.parseInt(s1.charAt(i)+\"\");             int num2Int = Integer.parseInt(s2.charAt(i)+\"\");              int currentSum = num1Int + num2Int + carry;             if(currentSum >= 2)             {                 carry = 1;                 if(currentSum == 2)                  result += \"0\";                 else                  result += \"1\";             }             else             {                 carry = 0;                 result += currentSum;             }      }   if(carry == 1)             result += carry;                  String finalResult = \"\";         for(int i = result.length() - 1; i >= 0; i--)             finalResult += result.charAt(i);   return finalResult;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"string AddBinaryNum(string s1, string s2) { \n    string s3 = \"\"; \n    int carry =0; \n     \n    int l1 = s1.length()-1; \n    int l2 = s2.length()-1; \n     \n    while(l1 >=0 || l2 >=0)  \n        { \n            int sum = carry + (l1>=0? s1[l1--]-'0': 0 )+ (l2>=0 ? s2[l2--]-'0': 0); \n            if(sum == 3 || sum ==1) { \n                s3.insert(s3.begin(), 1, '1'); \n            } \n            else s3.insert(s3.begin(), 1, '0'); \n            if(sum >= 2) carry = 1; \n            else carry = 0; \n             \n        } \n        if(carry) s3.insert(s3.begin(), 1, '1'); \n     \n    return s3; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"static void Main(string[] args)??????? {??????????? String a1 = \"00000000\";??????????? String a2 = \"00000\";??????????? String a3=null;??????????? char Res = '\\0';??????????? char carry = '0';??????????? int a1Len = a1.Length;??????????? int a2Len = a2.Length;??????????????????????? if (a2Len>a1Len)??????????? {??????????? ??? for (int i =0; i<(a2Len? - a1Len); i++)??????????? ??? {??????????? ??? ??? a1 = \"0\" + a1;??????????? ??? }??????????? }??????????? if (a1Len > a2Len)??????????? {??????????? ??? for (int i =0; i<(a1Len -a2Len); i++)??????????? ??? {??????????? ??? ??? a2 = \"0\" + a2;??????????? ??? }??????????? }??????????? for ( int i = a1.Length-1; i >=0 ; i--)? //a1/Length now contains original length???????????????????????????????????????????????????????? {??????????? ??? if (a1[i].Equals('0') && a2[i].Equals('0') && carry.Equals('0'))??????????? ??? {??????????? ??? ??? Res = '0';??????????? ??? ??? carry = '0';??????????? ??? }??????????????? else if (a1[i].Equals('0') && a2[i].Equals('1') && carry.Equals('0'))??????????? ??? {??????????? ??? ??? Res = '1';??????????? ??? ??? carry = '0';??????????? ??? }??????????????? else if (a1[i].Equals('1') && a2[i].Equals('0') && carry.Equals('0'))??????????? ??? {??????????? ??? ??? Res = '1';??????????? ??? ??? carry = '0';??????????? ??? }??????????? ??? else if (a1[i] == '1' && a2[i]=='1' && carry == '0')??????????? ??? {??????????? ??? ??? Res = '0';??????????? ??? ??? carry = '1';??????????? ??? }??????????? ??? else if (a1[i] == '0' && a2[i]=='0' && carry == '1')??????????? ??? {??????????? ??? ??? Res = '1';??????????? ??? ??? carry = '0';??????????? ??? }??????????? ??? else if (a1[i] == '0' && a2[i]=='1' && carry == '1')??????????? ??? {??????????? ??? ??? Res = '0';??????????? ??? ??? carry = '1';??????????? ??? }??????????? ??? else if (a1[i] == '1' && a2[i]=='0' && carry == '1')??????????? ??? {??????????? ??? ??? Res = '0';??????????? ??? ??? carry = '1';??????????? ??? }??????????? ??? else if (a1[i] == '1' && a2[i]=='1' && carry == '1')??????????? ??? {??????????? ??? ??? Res = '1';??????????? ??? ??? carry = '1';??????????? ??? }??????????????? a3 = Res + a3;??????????????? Res = '0';??????????????????????????? }??????????? if (carry == '1')??????????? ??? a3=carry+a3;??????????? Console.WriteLine(a3);??????????? Console.ReadLine();??????? }??? }}/*"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"std::string addTwoBinaryStrings(std::string a, std::string b) {     size_t i = a.length() - 1;     size_t j = b.length() - 1;          int carry = 0;     char * result = new char[i > j? i+2: j+2];          while(i >= 0 && j >= 0)     {         int m = a[i] - '0';         int n = b[j] - '0';          *result++ = m ^ n ^ carry + '0';         carry = m & n || m & carry || n & carry;         i--;         j--;     }          while(i >= 0)      {         int m = a[i] - '0';         *result++ = m ^ carry + '0';         carry = m & carry;         i--;     }          while(j >= 0)      {         int n = b[j] - '0';         *result++ = n ^ carry + '0';         carry = n & carry;         j--;     }          *result = carry + '0';          std::string str_to_return(result);     return str_to_return; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"std::string add(std::string a, std::string b) \n{ \n    size_t i = a.length(); \n    size_t j = b.length(); \n    int carry = 0; \n    int size = i > j? i+1: j+1; \n    int index = size; \n    char * result = new char[size]; \n    while(i > 0 || j > 0) \n    { \n      int m = i > 0? a[--i] - '0' : 0; \n      int n = j > 0? b[--j] - '0' : 0;  \n      result[--index] = m ^ n ^ carry + '0'; \n      carry = m & n || m & carry || n & carry; \n    } \n    result[--index] = carry + '0'; \n    std::string rstr(result); \n    return rstr; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"My try......... I learnt a lot while trying this code.......... string is not immuttable and about string buffer and string builder etc........... import java.io.*; import java.lang.*; class Binadd { public static void main(String a[]) {  String n1,n2;  StringBuffer n3;  char c='0';  int l1,l2,i,j,l;  DataInputStream dis=new DataInputStream(System.in);  try  {   System.out.println(\"Enter the 2 numbers\");    n1=dis.readLine();   n2=dis.readLine();   l1=n1.length();     l2=n2.length();   if(l1>=l2)   {    n3=new StringBuffer(n1);    l=l1-1;   }   else   {    n3=new StringBuffer(n2);    l=l2-1;      }   for(i=l1-1,j=l2-1;(i>=0)&&(j>=0);i--,j--)   {    if(c=='0')    {     if((n1.charAt(i)=='1')&&(n2.charAt(j)=='1'))     {      n3.setCharAt(l--,'0');      c='1';     }     else if((n1.charAt(i)=='0')&&(n2.charAt(j)=='0'))     {      n3.setCharAt(l--,'0');      c='0';     }     else     {      n3.setCharAt(l--,'1');      c='0';     }     }    else    {     if((n1.charAt(i)=='1')&&(n2.charAt(j)=='1'))     {      n3.setCharAt(l--,'1');      c='1';     }     else if((n1.charAt(i)=='0')&&(n2.charAt(j)=='0'))     {      n3.setCharAt(l--,'1');      c='0';     }     else     {      n3.setCharAt(l--,'0');      c='1';     }     }   }   for(;i>=0;i--)   if((n1.charAt(i)=='1')&&(c=='1'))   {    n3.setCharAt(l--,'0');    c='1';   }   else if((n1.charAt(i)=='0')&&(c=='0'))   {    n3.setCharAt(l--,'0');    c='0';   }   else   {    n3.setCharAt(l--,'1');    c='0';   }    for(;j>=0;j--)   if((c=='1')&&(n2.charAt(j)=='1'))   {    n3.setCharAt(l--,'0');    c='1';   }   else if((c=='0')&&(n2.charAt(j)=='0'))   {    n3.setCharAt(l--,'0');    c='0';   }   else   {    n3.setCharAt(l--,'1');    c='0';   }    if(c=='1')   {    n2='1'+n3.toString();    System.out.println(n2);   }   else   System.out.println(n3);   }   catch(IOException e)   {    System.out.println(e);   }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"What about this solution?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15443800","download_status":"DOWNLOAD_DONE","votes":"5","answersCount":"20","title":"As input, you are given two sets: 1) set R of n1 non-overlapping rectangles, whose sides are parallel to the x- and y-axes (ie: not rotated rectangles). Each rectangle denoted by bottom left & top right corner coordinates. 2) set P of n2 points - let n = n1 + n2  For each point 'p' in set P, find the rectangle 'r_p' in set R that contains 'p'. If 'p' is not enclosed by any rectangle, then 'r_p' is undefined. Otherwise, 'r_p' is unique because of the non-overlapping set.  Goal: come up with a divide-and-conquer pseudocode to solve the general problem in O(n(logn)^2) time.   Asked about points that are on the edge of the rectangle, and they said it was up to me whether to include those or not, just a matter of \"<\" vs \"<=\", etc. comparisons. Because it's just pseudocode they were looking for, they were not too concerned with the actual structure of the return value, just that the D&C algorithm showed the logic.  Struggled with it for awhile and they simplified the problem to a ~special case with the constraint where all rectangles of R intersected a horizontal line 'L', and instead give a O(nlogn) algorithm to solve the same problem. I suspect this would've been a subproblem/subroutine of the more general case, but again got a bit lost.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Build a balanced tree of the x-coordinates of the points(appearing only at leaf nodes) which will allow you to perform queries like getting the points in a given range [l, r].  Annotate each node of the tree with a balanced tree of the y-coordinates (called Y-trees) of the points in the leaf nodes of the subtree. Thus each range query [l,r] can be represented as a set of O(log n) Y-trees.  Building this structure takes O(n (log n)^2) time and O(n log n) space.  Now given a rectangle, you can query the S points that lie in the rectangle, in O( (log n)^2 + S) time. First run the range query of [l,r], the width of the rectangle to get O(log n) Y-Trees. Then run the range query of [bottom,top] (the height of the rectange) on each Y-Tree we got. This is O( (log n)^2 + S) total.  Since we do this for each rectangle, the total query time is O(n (log n)^2) (could potentially be faster is lot of points lie within a single rectangle...).  That said, this is too much for an interview, to come up with and write pseudo-code.  Perhaps there is an easier method.  (btw, if I recollect correctly, this is the idea behind a orthogonal-range search tree)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Does the following solve the problem in O(n log n)?  Sort the rectangles by the x-coordinate of the lower-left corner and remove those with this corner to the right of the point.  Sort the (remaining) rectangles by the x-coordinate of the upper-right corner and remove those with this corner to the left of the point.  Sort the (remaining) rectangles by the y-coordinate of the lower-left corner and remove those with this corner above the point.  Finally, sort the remaining rectangles by the y-coordinate of the upper-right corner and remove those with this corner below the point.  If there is nothing left, then no rectangle contains the point.  Otherwise, the one left is as desired."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I think, this problem can be solved by KD Tree because all the rectangles are non-overlapping. We can split the set of rectangles in half by x and y axis alternatively and construct the tree.   The lookup algorithm would also be same as KDTree. This way you can construct the tree in O(nlogn) and lookup in O(logn)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"PLEASE? A KD-tree? They will be more than happy to see you implement one in pseudocode... BTW a KD-Tree has O(n) worst-case complexity.  What they were probably looking for is this.  Sort all rectangles and points by their x and y coordinates into sorted sets Rx, Ry, Px and Py.  Then in each recursion level swap a bit which says whether to subdivide in X or Y direction. (This is just to make complexity analysis a whole heck of a lot easier)  You always use the middle element in the current subdivision of Rx, Ry, Px, Py as splitter to obtain the sets for the next subdivision.  The recursion terminates after log(n) steps when there is either none or one rectangle left. Then you check whether all points in the subdivided Px or Py are in there and add them to a result set.  The algorithm is at most O(n*log(n)^2) worst case... I have the proof on paper but it would be too tedious to carry it out here. Shouldn't be too hard ;)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"found a mistake in the algo"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how about a simpler approach of using divide of merge sort. keep sub dividing the set of rectangles till 1 rectangle remains. checking if a point is inside the rectangle is constant time operation. there is no need to combine as the result is unique rectangle. as a optimization , we can have global variable which says the search is complete. before we check for any inside condition for a rectangle we simply check if this variable is set. this will minimize the containment operation."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"To get O(n log n * log n) complexity it means that we have to solve the problem by doing a sorting and organizing an array as a tree , to be able to search next in log n time.  My idea is to sort and organize the array of rectangles creating  a structure for each node to be formed of : min x , max x, min y, max y. Next search in Log n time for each point if it fits in a rectangle.  O(nlogn log n) time and O (length of the rectangle array)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For the set of rectangles, create 4 sorted arrays, each storing the BottomLeft (BL) coordinate, the TopRight (TR) coordinate & an ID for the rectangle. The 4 arrays are sorted one each for the below (and named accordingly) 1. BL x value - BLX 2. TR x value - TRX 3. BL y value - BLY 4. TR y value - TRY (thus far takes O(nlogn))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) { \n        /* \n         * For each point 'p' in set P, find the rectangle 'r_p' in set R that contains 'p', 'r_p' \n         * is unique because of the non-overlapping set. \n         */ \n \n        // set R of n1 non-overlapping rectangles, whose sides are parallel to the x- and y-axes \n        Set rectangles = new HashSet(); \n        // fill rectangles here... \n \n        // set P of n2 points \n        Set points = new HashSet(); \n        // fill points here... \n \n        Rectangle[] rectanglesSortedByX = rectangles.toArray(new Rectangle[0]); \n        // O(NlgN), N = rectangles.size \n        Arrays.sort(rectanglesSortedByX, new Comparator() { \n            @Override \n            public int compare(Rectangle r1, Rectangle r2) { \n                return Integer.valueOf(r1.bottomLeft.x).compareTo(r2.bottomLeft.x); \n            } \n        }); \n \n        Rectangle[] rectanglesSortedByY = rectangles.toArray(new Rectangle[0]); \n        // O(NlgN), N = rectangles.size \n        Arrays.sort(rectanglesSortedByY, new Comparator() { \n            @Override \n            public int compare(Rectangle r1, Rectangle r2) { \n                return Integer.valueOf(r1.bottomLeft.y).compareTo(r2.bottomLeft.y); \n            } \n        }); \n \n        // O(N) \n        for (Point point : points) { \n            // O(lgN) \n            Rectangle rectangle = findRectagnleByX(rectanglesSortedByX, point, 0, rectanglesSortedByX.length); \n            if (rectangle == null) { \n                System.out.println(\"there is not a rectangle for point=\" + point); \n            } else { \n                // O(lgN) \n                rectangle = findRectagnleByY(rectanglesSortedByY, point, 0, rectanglesSortedByY.length); \n                if (rectangle == null) { \n                    System.out.println(\"there is not a rectangle for point=\" + point); \n                } else { \n                    System.out.println(\"point=\" + point + \" is covered by rectangle=\" + rectangle); \n                } \n            } \n        } \n    } \n \n    private static Rectangle findRectagnleByX(Rectangle[] sortedByX, Point point, int start, int end) { \n        if (start >= end) { \n            return null; \n        } \n \n        int middle = start + (end - start) / 2; \n \n        if (sortedByX[middle].bottomLeft.x <= point.x && point.x <= sortedByX[middle].topRight.x) { \n            return sortedByX[middle]; \n        } else if (sortedByX[middle].topRight.x < point.x) { \n            return findRectagnleByX(sortedByX, point, middle + 1, end); \n        } else { \n            return findRectagnleByX(sortedByX, point, start, middle - 1); \n        } \n    } \n \n    private static Rectangle findRectagnleByY(Rectangle[] sortedByY, Point point, int start, int end) { \n        if (start >= end) { \n            return null; \n        } \n \n        int middle = start + (end - start) / 2; \n \n        if (sortedByY[middle].bottomLeft.y <= point.y && point.y <= sortedByY[middle].topRight.y) { \n            return sortedByY[middle]; \n        } else if (sortedByY[middle].topRight.y < point.y) { \n            return findRectagnleByY(sortedByY, point, middle + 1, end); \n        } else { \n            return findRectagnleByY(sortedByY, point, start, middle - 1); \n        } \n    }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15317787","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"25","title":"Print all the permutaion of a given string.  1) explain time\\space complexity?  2) how can you improve time\\space complexity?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"standard solution :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Naive complexity would be n!  We could reduce the complexity via dynamic programming. Store the lesser components, so that you don't have to permute them again.  For example, if I have already permuted {abc} then I don't have to entirely permute {abcd}."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public class PermutationTest { \n \n /** \n  * @param args \n  */ \n public static void main(String[] args)  \n { \n  // TODO Auto-generated method stub \n  String permString = \"ABCDE\"; \n  Set se = permutations(permString); \n  Iterator itr = se.iterator(); \n  System.out.println(\"Total size of Permutations = \" + se.size()); \n  while(itr.hasNext()){ \n   System.out.println(\"--\" + itr.next()); \n  } \n } \n  \n public static Set permutations(String str) \n { \n  Set se = new HashSet(); \n  permute(str.toCharArray(),\"\",se); \n  return se; \n } \n  \n public static void permute(char[] rem, String str, Set se) \n { \n  if(rem.length == 1){ \n   String str2 = str + rem[0]; \n   se.add(str2); \n   return; \n  } \n  for(int i = 0 ; i < rem.length ; i++) \n  { \n   char[] rem2 = getRemainingArray(rem,i); \n   String s = \"\" + str + rem[i]; \n   permute(rem2, s, se); \n  } \n } \n \n private static char[] getRemainingArray(char[] rem, int i) \n { \n  char[] rem2 = new char[rem.length - 1]; \n  int k = 0; \n  for(int j = 0 ; j < rem.length ; j++) \n  { \n   if(i!=j){ \n    rem2[k] = rem[j];k++; \n   } \n  } \n  return rem2; \n } \n  \n  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public static ArrayList stringPermutation(String s){   if (s==null){    return null;   }   String first = s.substring(0,1);   String rest = null;   if(s.length() != 1){    rest = s.substring(1);   }   ArrayList list = stringPermutation(rest);   ArrayList permutation = new ArrayList();   if(list == null) permutation.add(first);   else{    for(String str : list){     for(int i=0; i     permutation.add(mutation(first,str,i));     }    }   }   return permutation;  }  public static String mutation(String ch, String s, int index){   if (index == 0) return ch + s;   else{    return s.substring(0,index) + ch + s.substring(index);   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How to calculate the complexity in such a solution?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static void allPermutationsOfGivenString_recursive() { \n  String s = \"vibhorras\"; \n  allPermutationsOfGivenString_recursive(s, \"\"); \n  System.out.println(\"\\n\"+count); \n } \n \n private static void allPermutationsOfGivenString_recursive(String s, String t) { \n  for (int i = 0; i < s.length(); i++) { \n   t = t + s.charAt(0); \n   if (s.length() > 1) { \n    allPermutationsOfGivenString_recursive(s.substring(1), t); \n    if (i + 1 < s.length()) { \n     s = rotate(s); \n     t = t.substring(0, t.length() - 1); \n    } \n    continue; \n   } \n   System.out.print(t+\" \"); \n   count++; \n   break; \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#!/usr/bin/python \n \ndef permute(s,cur,pos,n): \n  #prints all permutation of a given string O(n*n!) \n  #assuming unique characters present it prints the lexicographic-unique sequence \n  #but it fails to print unique sequence if there are repeating characters \n  global visited \n  if pos==n: \n    print ''.join(cur) \n    return \n  for i in range(n): \n    if not visited[i]: \n      cur[pos]=s[i] \n      visited[i]=True \n      permute(s,cur,pos+1,n) \n      visited[i]=False \n \ndef permutations(s): #solution to the above problem \n  #prints all unique permutation of a given string in lexicographic order TIME:O(n*n!) \n  n=len(s) \n  def next(): \n    k,l=-1,-1 \n    for i in range(n-1): \n      if s[i]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void getPermutations(String head,String tail) \n    { \n                 \n            if(tail.length()==0) System.out.println(head); \n            for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void permutation(String s) { \n  permutation(\"\", s); \n } \n \n private static void permutation(String prefix, String s) { \n  int n = s.length(); \n  if (n == 0) \n   System.out.println(prefix); \n  else { \n   for (int i = 0; i < n; i++) { \n    permutation(prefix + s.charAt(i), \n      s.substring(0, i) + s.substring(i + 1, n)); \n   } \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Generate all permutations in lexicographical order. That is going to take care of the duplicate characters in the string as well. Complexity  of generating the next permutation is going to be high as compared to normal permutation as u involve sorting as well here.  In normal algorithm complexity for generating the next permutation is going to be O(n) in worst case. In the case of lexicographical sorting it is going to be o(n + logk)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private void permuationInOrder(String prefix, String str) {   int len = str.length();   if (len <= 1)    System.out.println(prefix);   else {    for (int i = 0; i < len; i++) {     String newString = str.substring(0, i) + str.substring(i + 1);     permuationInOrder(prefix + str.charAt(i), newString);    }   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void printPermutations(char[] c) { \n  StringBuffer temp; \n \n  for (int i = 0; i < c.length; i++) { \n   temp = new StringBuffer(); \n   temp.append(c[i]); \n   for (int k = 0, j = (i + 1) % (c.length); k < c.length-1; k++, j = (j + 1) % c.length) { \n    //System.out.println(\"j=\" + j); \n    temp.append(c[j]); \n   } \n   System.out.println(temp); \n   System.out.println(temp.reverse()); \n  } \n \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What do you by the naive way would always be n!? In fact it is impossible to do better unless you managed to print a string in negative time lol. The question is rather how much worse does it get? And the solutions above seem to be a nightmare of memory allocation and copying. Mine is free of them all."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What do you by the naive way would always be n!? In fact it is impossible to do better unless you managed to print a string in negative time lol. The question is rather how much worse does it get? And the solutions above seem to be a nightmare of memory allocation and copying. Mine is free of them all."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"char* putCharAt(const char* str, char c, int index) \n{ \n int len = strlen(str); \n \n if(index < 0 || index > len ) \n  return NULL; \n char* res = new char[len + 2]; \n \n for(int i=0;i res; \n vector temp; \n \n int len = strlen(str); \n char* init_str = new char[2]; \n init_str[0] = str[0]; \n init_str[1] = '\\0'; \n \n res.push_back(init_str); \n \n for(int i=1;i::iterator it = res.begin(); it != res.end(); it++) \n  { \n   char* st = *it; \n   int l = strlen(st); \n   for(int j=0;j<=l;j++) \n   { \n    char* temp_str = putCharAt(st,str[i],j); \n    temp.push_back(temp_str); \n   } \n  } \n  res.clear(); \n  res = temp; \n  temp.clear(); \n } \n //print the permutations \n for(vector::iterator it = res.begin(); it != res.end(); it++) \n { \n  cout<<*it<<\", \"; \n } \n cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a python code. It is a recursive function. If we have \"abc\", it calls the recursive function three times.  1- prefix = a;  str = ''bc\" 2- prefix = b;  str = ''ac\" 3- prefix = c;  str = ''ab\""},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simple recursive C# solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Basically, think of the problem as a graph. For a string of length n, you have n sub-graphs. Each sub-graph then has n-1 sub-graphs. The total number of nodes in all of the sub-graphs is n!  So you start with a root and a remainder. You iteratively add each character from the remainder to the root, and then recurse down to the next level. When you have a remainder with only one character in it, you know you have hit a leaf, so you print the root plus the remainder.  In the case of no character repetitions, it's as simple as:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15290675","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"27","title":"Given an integer, return all sequences of numbers that sum to it. (Example: 3 -> (1, 2), (2, 1), (1, 1, 1)).  Interview was for a php position.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Recursive calls."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"i am not sure what is going on here, \"List tempList = getCombinations (val --);\". someone help me?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I am here giving only an idea... this to be done using dynamic programming...... 1 will have{1} 2 will have {1,1}.{2} as base conditions..... now T(n) will be temporaryset=null; for(i=1;itemporaryset=temoraryset union T(i) union T(n-i)(element wise union); //eg;T(3)=T(2) union T(1) union T(1) union T(2)                  so (2,1),(1,1,1)    (1,2);               then for T(4) and like that continue... I was asked the same question in Amazon.. I gave this solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"List   getCombinations (int num) { List > allCombinations = new ArrayList();  int val = num;  int i = 1;  while (val > 0)  {   List temp1 = new ArrayList();   temp1.add (i++);   List tempList = getCombinations (val --);   int j = 0;   for (List subList : tempList)   {      temp1.addAll(subList);   }   allCombinations.add(temp1); }      return allCombinations;     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Another recursive solution here: (but I am not sure if the running time is acceptable)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static HashSet> getSequences(int n) { \n        @SuppressWarnings(\"unchecked\") \n        HashSet>[] list = (HashSet>[]) new HashSet[n + 1]; \n \n        for (int i = 0; i < list.length; i++) { \n            list[i] = new HashSet>(); \n        } \n \n        ArrayList arr = new ArrayList(); \n        arr.add(0); \n        list[0].add(arr); \n \n        arr = new ArrayList(); \n        arr.add(1); \n        list[1].add(arr); \n \n        if (n > 1) { \n            arr = new ArrayList(); \n            arr.add(1); \n            arr.add(1); \n            list[2].add(arr); \n        } \n \n        if (n <= 2) \n            return list[n]; \n \n        for (int i = 3; i <= n; i++) { \n            for (int j = 1; j < i; j++) { \n                int t = i - j; \n                for (ArrayList s : list[j]) { \n                    ArrayList tmp = new ArrayList(s); \n                    tmp.add(t); \n                    list[i].add(tmp); \n                } \n                ArrayList tmp = new ArrayList(); \n                tmp.add(t); \n                tmp.add(j); \n                list[i].add(tmp); \n            } \n        } \n \n        return list[n]; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is an alogrithm An Array of n numbers starting from 1..n sorted  positive numbers only  Now we need to find the sum K clearly the sum will comprise of elements before K in array  here is a backtracking solution Target = K ; Int [k] Index =0; Index[0]=0; sum =0 Public void solve(Int target,int sum,int[]Index,int n, int []Array) {  if (Sum= target)  {    Print ( Array,Index,n);   }  for(int i= index[n];i  {     Index[n+1]=i;      solve(target,sum+Array[i],Index,n+1, Array);    } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//This program generates all combinations of set whose sum is equal to the a given number  import java.util.ArrayList;  public class AllSetOfNumberSumToN {  static ArrayList result=new ArrayList();  static String str=\"1111111\";  static int number=7;  public static void main(String [] args){   result.add(str);   generateNumber();   for(String s:result)   {    System.out.println(s);   }   System.out.println(\"The total number sets are :\"+result.size());  }  //function to generate all sets whose sum is equal to the a given number  private static void generateNumber(){   int count=0,i=1,sum=0;   while(count    i=1;sum=0;   String str= result.get(count);   StringBuilder s1=new StringBuilder();   Character c1=str.charAt(0);   Character c2=null;   if(Integer.parseInt(c1.toString())<=number/2&&str.length()>number/2)   c2=str.charAt(1);   else{    count++;    if(count   {    continue;    }    else     return;   }   sum =sum+Integer.parseInt(c1.toString());   if(c1!='1')   {   s1.append(c1);   }   else   {    result.remove(0);    sum=0;   }   while(c2!=null&& c2!='1'&&i  {    i++;    sum=sum+Integer.parseInt(c2.toString());    s1.append(c2);    if(i   c2=str.charAt(i);   }   String s2=s1.toString();   c1=str.charAt(i-1);   int partialSum=Integer.parseInt(c1.toString());   while(true)   {    s1=new StringBuilder(s2);    if(sum+partialSum<=number){     s1.append(partialSum);     int sum_total=sum+partialSum;     while(sum_total    {      s1.append(1);      sum_total++;     }     result.add(s1.toString());     partialSum++;    }    else     break;   }   count++;   }  }//end of function }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static HashSet> allSequences(int N, HashMap>> cache){ \n    if(N == 1){ \n      HashSet > h = new HashSet >(); \n      ArrayList list = new ArrayList(); \n      list.add(1); \n      h.add(list); \n      return h; \n } \n    HashSet > allSequence = new HashSet >(); \n    for(int i = 1;i < N; i++){ \n     HashSet> set = null; \n      if(cache.containsKey(i)){ \n        set = cache.get(i); \n      }else{ \n       set = allSequences(i, cache); \n       cache.put(i, set); \n      } \n       \n      for(ArrayList list : set){ \n       ArrayList l = new ArrayList(); \n       l.add(N - i); \n       l.addAll(list); \n       allSequence.add(l); \n      } \n      ArrayList list = new ArrayList(); \n      list.add(N); \n      allSequence.add(list); \n    } \n    return allSequence; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void GetAllSequences(int n) \n{ \n    int n1 = 0; \n    int n2 = 0; \n \n    if(n > 1) \n    { \n        for(int i=1;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#!/usr/bin/python \n \ndef partition(cur,pos,m,n): \n  #prints all unique partitions of a number (lexicographic order) \n  if n==0: \n    print cur[:pos] \n    return \n  for i in range(m,n+1): \n    cur[pos]=i \n    partition(cur,pos+1,i,n-i) \n \ndef apart(cur,pos,n):  #this solves the given question \n   #prints all paritions of a number (no order) \n   if n==0: \n     print cur[:pos] \n     return \n   for i in range(1,n+1): \n     cur[pos]=i \n     apart(cur,pos+1,n-i) \n \nif __name__=='__main__': \n  n=5 \n  #partition([0]*n,0,1,n) \n  apart([0]*n,0,n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"to make it simple:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void dfs(int arr[], int &cnt, int sum) \n{ \n if (sum<0) return; \n if (sum==0) { \n  for (size_t i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void PrintS(int n, string& s) \n{ \n  if (n == 1 ) { \n    cout << s << 1 << endl; \n    return; \n  } \n \n  for (int i=1; i < n; i++) { \n    char t[64]; \n    sprintf(t, \"%d\", i); \n    int len = s.size(); \n    s.append(t); \n    PrintS(n-i, s); \n    s.erase(len); \n  } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Recursive solution in C#."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void NumberSum(int number, string suffix) \n        { \n            for (int i = 0; i < number; i++) \n            { \n                if (i == 0) \n                { \n                    System.Console.WriteLine(number + \" \" + suffix); \n                } \n                else \n                { \n                    int temp = number - i; \n                    NumberSum(i, temp.ToString() + \" \" + suffix); \n                } \n            } \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why so complicated solutions ? Here is simplest solution I wrote"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"function sequence($num,$array,&$mainarray){ \n for($i=1;$i<$num;$i++){ \n  if(array_sum($array) + $i ==$num){ \n   $temparray = $array; \n   array_push($temparray,$i); \n   array_push($mainarray,$temparray); \n    \n   break; \n  }elseif(array_sum($array) + $i<$num){ \n   $temparray = $array; \n   array_push($temparray,$i); \n    \n   sequence($num,$temparray,$mainarray); \n  } \n } \n \n}  \n$mainarray = array(); \n$temp = array(); \nsequence($n,$temp,$mainarray);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class SequencesSum { \n \n public static void main(String args[]){ \n  Sequences(10); \n } \n  \n static void Sequences(int n){ \n  int j=1; \n  StringBuffer seq = new StringBuffer(); \n  seq.append(\"(\"); \n  for(int i=1;i"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14989686","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"3","title":"Design a system for showing quotes on the web.  For example, when the user is looking at page A, part of which is reproduced in page B, the system could highlight part of page A present the user with a link to page B.  This is an open-ended system design question.   What constitutes a quote?  How do you find quotes?  How do you make it scale to the web?  How do you handle updates?  How would you arrange the servers?  What data structures would you use?  How much storage would you need?  How would the user agent present information about quotes?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I was asked the same question in amazon , 1 yr back"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi, Steve, will you bother to reply more about what you were thinking and what the interviewer responded to your thought? Thanks a lot."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My approach: \n \n1) Data Model  \nI'll have 2 hash maps: \n \n  - Based on source page address as key  \n  - Destination page as key.  \n  - For both maps value will be position in a vector  which will contain pointer to struct. \n      \n    struct quote \n    { \n      string src;                  // Links \n      string dest;                 // Links \n      string src_element;          // We can have div, p etc \n      int src_id;                  // Id of element on source page i.e. to be quoted \n      string dest_element;         // We can have div, p etc \n      int dest_id;                 // Id of element on source page i.e. to be quoted \n    }; \n \n    unordered_map srcMap; \n    unordered_map destMap; \n \n2) Operations supported will be: \n     \n    - void insertQuote(string src, string dest ...)    // properties to be added to our struct \n    - string fetchQuotedString(string dest, string element, int id);  \n    - string fetchDestPage(string src, string element, int id); \n \n  Hash can be calculated on complete web address which might look like: \"http : / / w w w . b l a h . c o m & t y p e = i d \" \n \n3) Execution \n  \n   - Client sends insertquote request to server.  \n   - Insertion can be an asynchronous event, which returns with a success error code and lazily updates the data structures.       \n  \n4) Complexity  \n \n   - Since we're using hash maps and simply appending a new node to end of a STL list, our time complexity for each operation will be O(1).  \n \n5) Write to Disks \nWe can keep a threshold for time or for size of data in memory after which contents can be dumped to the disk. (These will basically be serial writes) \n \n6) Concurrency  \n \n  - Read operation  \n \n   - For displaying page A, whose text is quoted we'll have to invoke fetchDestPage(...) and for displaying page B, we'll invoke fetchQuotedString(...) \n   - For read, we can use reader-writer locking mechanism on the maps. If no writer is updating the corresponding entry, reader process can fetch node value based on the type of page being displayed (hashing source or destination web address).  \n  - Write operation  \n \n    - As mentioned earlier, insertion can be asynchronous in nature. Once a client invokes insertQuote(...), preforked server process can record the invocation and return a success code to the caller.  \n    - Each process update the List of nodes and receive an iterator. In order to insert entry to the maps, the process has to wait to acquire locks on the hashed positions and once received can insert a new entry to each map.   \n \n7) Scalability \nWe can distribute our hash maps to different nodes with a DHT based setup. (Caching most frequently used data). Therefore, when a server will receive request for fetching/ inserting an entry it'll: \n \n  - Return 2xx to client  \n  - Hash the \"web-address\" and accordingly find the destination host \n  - Route the message to the destination  \n  - Recipient node will have it's own segment of hash tables and list. \nWe basically import all the features of DHT to share resources between number of hosts and provide better performance to the user. \n \n9) Replication for availability  \n \nData can be replicated on many DHT nodes, with DHT based bootstrapping and division of labor. For every write operation once a node receives a request  it can be considered at the co-ordinator who'll take care of the successful commit to each replica using 2-phase commit protocol. In case of aborted transaction failure code can be returned to the client. Client is responsible for retrying.  \n \n10) Fault Tolerance \n \n- Again we're importing fault tolerance features from DHT. In case of faulty destination hosts, its replicas should be able to service the request.  \n- If none of the replica's is able to respond we'll assume it's a cache miss and fetch data from disk."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15011669","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"19","title":"Got FB interview questions is not difficult, basically, he is asking to count number of identical chars in a given string with with some special case handling, and return the number with highest count, question is pretty long leaving you to dig an algorithm.   Etc, given string \"coffee tuffee\", should return 4.  I was having my usual interview brain freeze, and start doing initializing with int, how silly  well after interview when I cool down, it doesn't take long to figure out as code below, little over weighted algorithm but the most concise I can wrote, someone please give more efficient code.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"//C# implmentation  \nstatic int MaxCharacterRepeatation(string _str) \n        { \n            int Max = 1; \n            Dictionary charset = new Dictionary(); \n            for (int i = 0; i <_str.Length; i++) \n            { \n                int val = _str[i]; \n                if (!charset.ContainsKey(val)) \n                { \n                    charset.Add(val, 1); \n                } \n                else \n                { \n                    charset[val] = charset[val]+1; \n                    if (charset[val] > Max) \n                    { \n                        Max = charset[val]; \n                    } \n                } \n            } \n            return (Max); \n \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Just use an auxiliary array of size equal to character set ( 130 would suffice ) => ch[130]   let given string is s."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Another possibility in python using a simple generator:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def get_iden(s)  ident=0   for i in 0..s.to_s().length-1   temp_iden=0   for j in i..s.to_s().length-1    if s[i]==s[j]     temp_iden=temp_iden+1    end   end    if (temp_iden>ident)    ident=temp_iden   end  end   return ident end    A=\"ddccaaaabcd\" puts get_iden(A)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just do as Cerbeuz showed, I cannot figure out any more effective algorithm either"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#JavaScript s = \"dfsdfsasd\" function getHighestCharCount(s){  var count = {};  for(c in s){   var key = s[c];   if( count[key] == undefined){    count[key] = 1;   }else{    count[key]++;   }  }  var highest = 0;  for(i in count){   highest = count[i] > highest ? count[i] : highest;  }  return highest; } getHighestCharCount(s); O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#JavaScript \ns = \"dfsdfsasd\" \nfunction getHighestCharCount(s){ \n var count = {}; \n for(c in s){ \n  var key = s[c]; \n  if( count[key] == undefined){ \n   count[key] = 1; \n  }else{ \n   count[key]++; \n  } \n } \n var highest = 0; \n for(i in count){ \n  highest = count[i] > highest ? count[i] : highest; \n } \n return highest; \n} \ngetHighestCharCount(s); \nO(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#JavaScript \ns = \"dfsdfsasd\" \nfunction getHighestCharCount(s){ \n var count = {}, highest = 0; \n for(c in s){ \n  var key = s[c]; \n  count[key] = count[key] ? count[key]+1 : 1; \n } \n for(i in count){ \n  highest = count[i] > highest ? count[i] : highest; \n } \n return highest; \n} \ngetHighestCharCount(s); \nO(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Something that might be a bit more effcient"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int PasswordCount(char * password) \n{ \n    int r[256] = {0}; //256 characters in ascii \n    int max = 0; \n    int l = strlen(password); \n \n    for(int i=0;i max) \n        { \n            max = count; \n        } \n    } \n    return max; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \n#include  \n#include  \n \n \nstd::pair countCharsAndReturnMax(std::string str, std::unordered_map& counts) \n{ \n    std::pair max; \n     \n    for(auto c : str)  \n    { \n        if(counts[c]++ > max.second) \n            max = std::make_pair(c, counts[c]); \n    } \n     \n    return max; \n} \n \nint main(int argc, char** argv) \n{ \n    std::unordered_map counts; \n    auto maxEntry = countCharsAndReturnMax(\"Facebook\", counts); \n \n    std::cout << \"Given strings has following char histogram:\" << std::endl << std::endl; \n     \n    for(auto e : counts) \n    { \n        if(e.first == maxEntry.first) \n            std::cout << \">>\"; \n        else \n            std::cout << \"  \"; \n             \n        std::cout << \" '\" << e.first << \"' : \" << e.second << \" times\" << std::endl; \n    } \n     \n    return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If you want a short Python code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def countmax ( word_): \n    charlist= list(word_) \n    maxim=0 \n     \n    for s in charlist: \n        charcount=charlist.count(s) \n        if charcount > maxim: \n            maxim=charcount \n    return maxim"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"maxstring = lambda s: max(map(s.count, iter(s))) \n \nTesting: \nmaxstring('coffee tuffee') \n4 \n \n \n# Handle Empty String: \nmaxstring = lambda s: 0 if len(s) == 0 else max(map(s.count, iter(s))) \n \nmaxstring('') \n0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def parseword(a_word): \n return max([a_word.count(c) for c in a_word.lower()])"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"from collections import Counter \ndef count_max(string): \n    return max(dict(Counter(string)).values())"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Python has some ways of doing this very elegantly, but typically interviewers want you to implement it at its base level, as can be seen here:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"from collections import Counter \ns = \"coffee tuffee\" \nc = Counter(s) \nc.most_common(n=1)[0]"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14974850","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"Implement second/minute/hour/day counters      Feb. 4, 2011 8:59pm Implement the API that counts the number of events in the last sec/min/hr/day:  SMHDCounter {    void Increment();    int LastSecCount(); // also functions for minute, hour    int LastDayCount();  }  Additional requirements  - you require that the data be quite fresh  - how much storage will they take up   - make sure this works for an active counter, getting 100s of events a second.   - keep the implementation fast. E.g. under 10 mS. Or even better motivate by saying we might have 50 of these SMHD counters on a single status page, and ask the candidate how fast their solution should be.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am assuming that the question doesn't talk about intermittent data ie like last 10 second data or last 3 hours data...How about a bounded queue of size 86400 each node having the count of events in each second of the last 1 day..In addition to this you keep a reference to 1st, 82800th (86400-3600) and 86340th (86400-60) node, and 3 counts (one for last day,d; one for last hour,h; one for last minute,m). Say you already have the entire queue filled: so here's what you'll do every second. a = deque; queue(s) d = d + s - a; m = m + s - node(86340).data h = m + s - node(82800).data also the three referenced node need to be updated. s is the number of events in the last second"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14965670","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"3","title":"consider a B2C website like Amazon, which will receive thousands requests from buyer per minutes. How will you design the \"shop cart \" component for it? where should the customs' shop cart data stored?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"There are many possible solutions here. Supposing that we're only given a small amount of time, I would narrow it down to three candidate ideas.  1) Cookies --------------- In other words, we store the data on the user's computer. This is the easiest solution and the cheapest for the website owner.   Some websites don't have logins and only track users through the fact that they use the same computer as they shop. Such websites use this solution by necessity. Even when you provide users with accounts that maintain cart information between sessions on different computers, you will probably want a cookie-based solution in addition to one of the other solutions below, because you wouldn't want people to be unable to add things to a cart until they log in. That's bad for business.  2) SQL Databases. --------------------------  The advantages of databases is that they are well-understood by developers, offer powerful data retrieval capabilities, and offer many strong guarantees pertaining to the data.  At this scale you probably need multiple database servers. You could have some sort of rule-based system to determine which users reside on which server. For example, you could hash the username to obtain a number i from 0 to N-1, where you have N servers, and store the data for that username on server i. There are of course several issues to think through here: when you need more servers, user data will need to be moved between servers so that the new servers can have users for which they're responsible. A typical hash approach will mean that the server number for almost every username will change when you change the total number of servers. This means you will need to move most of the data between servers, probably meaning substantial downtime for most users as you copy terabytes of data.  You could use ideas such as \"consistent hashing\" to be able to move only small amounts of data at a time, or you could design a rule system for determining the server that doesn't use a typical hash, but (as a dumb example) is based on last name, for example. A goes to 0, B goes to 1...Then if you need to, you can change \"A goes to 0\" to \"AA-AG goes to 0, AH-AZ goes to 232\", and move over the small amount of data you need for that change, and do the changes in small amounts incrementally. It's important to think about how you will maintain and further scale these types of large systems.  3) Distributed Hash Tables ------------------------------------ A general distributed key-value store (usernames will be the key, values will be all relevant user data). Look this topic up if you're interested in learning more about it. Issues here include the strategy for distributing data among nodes, whether there will be data replication to ensure smooth failover, the performance of this system, and more."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The above answer is totally irrelavant.  Can anyone provide an answer for design an amazon shopping cart?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14958681","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"generic HashMap implementation","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A generic Hashtable / Hashmap in C#. Note that I'm using the out-of-the-box Object.GetHashCode() method to generate hashes. You could substitute a custom hash method if so desired.. Also this is not a thread safe implementation."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14964682","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"Design a scalable server for the hangman game","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"1) TCP based session establishment (process based system where each request is handled by a forking/preforking a new process instance.) 2) Per user session created. Session class can look like:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14942012","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"5","title":"How do you search thrgough huge flat file?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Use \"grep\". This question is usually sandwiched between two programming questions. The interviewer is looking for your ability to switch contexts to a non-programmatic solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I can think of couple of approaches  1. Split the huge flat file into multiple chunks (or batches) and search those individual flat file.  2. If time is also a constraint, use Map-Reduce kind of distributed architecture. (en.wikipedia.org/wiki/MapReduce)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Regular expression"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-4","title":"How \"do\" you or how \"should\" you?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14942912","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"5","title":"Determining trending topics   How do you think Twitter determines trending topics?   If needed, explain that trending topics are N most common occurring substrings across all tweets in a given time window, which is constantly moving. Later you can expand the question by putting the scale constraint considering the rate at which tweets come in, etc.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"create an array pointers for frequecy max; lets say 10 million create a trie for all the substring. (or a suffix tree)  The leaf of a trie will contain two variables and two pointers. one variable contains the time stamp the other variable contains the frequency. one pointer contain the address of frequency pointer for k. the other contain the pointer to the next leaf of the same frequency. (you can even have double linked list). when a substring is found again, you increase the frequency and change the next leaf pointer to the leaf containing at the next frequency array pointer.  when you want the N most common substrings for a time frame T. go through the linked list pointed by the max frequency array pointer till time frame T. repeat the procedure to the next max frequency.  update substring= O(1)  adding new substring = O(1) N most freq = O(N) decrease substring = O(1) (dont update the time stamp while decreaseing freq).  ofcourse you have the time taken for searching string in the trie or suffix tree which would cost O(P +Sigma) P = length of pattern + max P. which can be obtained by having weighted balanced search tree at every node in the trie.  if frequency exceeds the max, then create a max frequency array pointer. :) or if you are worried about the size of frequency array pointer, then create a frequency bst/heap/wbst etc."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"create an array pointers for frequecy max; lets say 10 million create a trie for all the substring. (or a suffix tree)  The leaf of a trie will contain two variables and two pointers. one variable contains the time stamp the other variable contains the frequency. one pointer contain the address of frequency pointer for k. the other contain the pointer to the next leaf of the same frequency. (you can even have double linked list). when a substring is found again, you increase the frequency and change the next leaf pointer to the leaf containing at the next frequency array pointer.  when you want the N most common substrings for a time frame T. go through the linked list pointed by the max frequency array pointer till time frame T. repeat the procedure to the next max frequency.  update substring= O(1)  adding new substring = O(1) N most freq = O(N) decrease substring = O(1) (dont update the time stamp while decreaseing freq).  ofcourse you have the time taken for searching string in the trie or suffix tree which would cost O(P +Sigma) P = length of pattern + max P. which can be obtained by having weighted balanced search tree at every node in the trie.  if frequency exceeds the max, then create a max frequency array pointer. :) or if you are worried about the size of frequency array pointer, then create a frequency bst/heap/wbst etc."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How will you take care of previous timestamps of the same word??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"heap would work with a mechanism to 'retire' count based on timestamps."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14974673","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"74","title":"McDonald??s sells Chicken McNuggets in packages of 6, 9 or 20 McNuggets. Thus, it is possible, for example, to buy exactly 15 McNuggets (with one package of 6 and a second package of 9), but it is not possible to buy exactly 16 McNuggets, since no non- negative integer combination of 6's, 9's and 20's add up to 16. To determine if it is possible to buy exactly n McNuggets, one has to find non-negative integer values of a, b, and c such that 6a+9b+20c=n Write a function, called McNuggets that takes one argument, n, and returns True if it is possible to buy a combination of 6, 9 and 20 pack units such that the total number of McNuggets equals n, and otherwise returns False. Hint: use a guess and check approach.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"public class McNuggets { \n \n    public static boolean canBuyNMcNuggets(int n) { \n        return n >= 0 && (n == 0 || n % 6 == 0 || n % 9 == 0 || n % 20 == 0 || canBuyNMcNuggets(n - 6) || canBuyNMcNuggets(n - 9) || canBuyNMcNuggets(n - 20)); \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"The following is my O(1) time complexity, O(1) space complexity implementation in python 3:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Oneliner in C:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"boolean McNuggets(int n) {  boolean ret = false;   if (n < 1)   return false;   if ((n % 6 == 0) ||     (n % 9 == 0)  ||     (n % 20 == 0))   return true;   if (ret == false && n > 20)   ret = McNuggets(n - 20);   if (ret == false && n > 9)   ret = McNuggets(n - 9);   if (ret == false && n > 6)   ret = McNuggets(n - 6);   return ret; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I think this problem is similar to Minimum Coin Problem. Given set of coin values. Find minimum no of coins required for a sum. This can be solved easily by dynamic programming. Code goes like this."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"# Fast analytical solution using modular arithmetic \ndef McNuggets(n): \n        c = -n % 3 \n        n -= c*20 \n        b = n // 3 % 2 \n        n -= b*9 \n        a = n // 6 \n        return a >= 0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Simple DP problem,  Recurrence relation: Ways(x)=Ways(x-6)+Ways(x-9)+Ways(x-20)  If Ways(n)>0 return true else return false"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def McNuggets(n):     \"\"\"     n is an int      Returns True if some integer combination of 6, 9 and 20 equals n     Otherwise returns False.     \"\"\"     # Your Code Here     ret = False      if (n < 1):         return False;     if ((n % 6 == 0)or(n % 9 == 0)or(n % 20 == 0)):         return True     if (ret == False and n > 20):         ret = McNuggets(n - 20)     if (ret == False and n > 9):         ret = McNuggets(n - 9)     if (ret == False and n > 6):         ret = McNuggets(n - 6)     return ret"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"does this  code work for n=41 which is a combination of(6+6+9+20)...??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include using namespace std;  bool possible(int sum, int a1, int a2, int a3){     if(sum == 0){         cout<<<\" \"<<<\" \"<        return true;     }     if(sum <6) return false;     return possible(sum - 20, a1, a2, a3+1) || possible(sum - 9, a1, a2+1, a3) ||  possible(sum - 6, a1+1, a2, a3); }  int main(){     int sum;     cin>>sum;     possible(sum, 0, 0, 0);     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can anyone give me this same code in Python ??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool check(vector& s, int target) \n{ \n    if (target < 0) \n        return false; \n    if (target == 0) \n        return true; \n    bool ret = false; \n    for (int i = 0; i < s.size(); ++i) \n    { \n        ret = ret | check(s, target - s[i]); \n    } \n    return ret; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"## A solution for McNuggets problem on careercup (question?id=14974673) \n## \n##   \nvalidPacks = [20, 9, 6]  \nhowmany = [0, 0, 0] \n \ndef McNuggets(n) :  \n    \"\"\" Returns true or false, depending upon whether McNuggets for given  \n        amount are possible. Additionally also gives the combination \n    \"\"\"  \n    global howmany  \n    for i in range(len(validPacks)): \n        curpack = validPacks[i] \n        if (n - curpack) >= 0:  \n            retval = McNuggets(n-curpack) \n            howmany[i] += 1  \n            if retval is True: \n                return retval  \n            else:  \n                howmany[i] -= 1 \n \n        if n == 0: \n            return True \n \n    howmany = [0, 0, 0] \n    return False  \n \nfor i in range(6,100): \n    howmany = [0, 0, 0] \n    print i, \":\", McNuggets(i), howmany"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be solved by breaking down the problem to its sub problems. Given a number, take 6 out of it. Can the rest be be broken up between {9, 20}? (and recurse). If not possible, then take 2*6 out of the number. Can the rest be broken up between {9, 20}? and so on.  Here is the code."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Like someone mentioned below, its a coin change problem.   Code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a question from your midterm. Stop cheating!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nusing namespace std; \n \nint count(int *arr,int n,int number) \n{ \n \nif(number==0) return 1; \nif(number<0) return 0; \nif(n<=0 && number>=1) return 0; \nreturn count(arr,n,number-arr[n-1])+count(arr,n-1,number); \n \n} \n \nint main() \n{ \n \n    int arr[] = {6,9,20}; \n    int m = sizeof(arr)/sizeof(arr[0]); \n    cout<< count(arr, m, 40); \n \n    return 0; \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Not a good idea to use recursion. Evolve your solution to use DP,  Recurrence relation: Ways(x)=Ways(x-6)+Ways(x-9)+Ways(x-20)  If Ways(n)>0 return true else return false"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a*20 + b*9 + c*6 value of a b c can be decided as by linear probing - taking value of a b c in order of bits below:   000 001 010 011 101 110 111  if the number is greater, then re-place 1 with 2 3 and 4 ( so on).  We can also resort to binary search for getting the value of a b c."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Python based recursive solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Eh, a brute force solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"No one seems to have suggested the bottom-up approach of constructing a list of possible numbers until we either reach or exceed n. The list is {0} initially and gradually grows, such as {0, 6, 9, 12, 18, 20, 24, 27...}. In each iteration, we use 3 different indices to keep track of the numbers in the list to which we should add 6, 9 and 20 to. We then add their minimum to the list, and increment the relevant indices. We need to make sure we don't add numbers that are already in the list by checking that this minimum is actually greater than the maximum of the list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"boolean isTrue(int n){  if(n < 0)   return false;  if(n == 0)   return true;  return isTrue(n-6) || isTrue(n-9) || isTrue(n-20); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"6-packs + 9-packs only -> 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60,  etc. add a 20-pack -> 26, 29, 32, 35, 38, 41, 44, 47, 50, 53, 56, 59, etc... add two 20-packs -> 40, 46, 49, 52, 55, 58, etc.  Basically, if you want more than 60 nuggets, you can always get your exact nugget meal.  For values less than 60, just hard code a lookup table or use the recursive algorithm, which is efficient enough for small numbers despite exponential time.   The only unreachable numbers are 1,2,3,4,5,7,8,10,11,13,14,16,17,19, 22, 23, 25, 28, 31, 34, 37, and 43."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool \ncanCountmcNugget (int n) { \n    vector  dp [n + 1]; \n    fill (dp.begin (), dp.end (), false); \n    dp [0] = true; \n    for (int i = 1; i <= n; i++) { \n        if (i >= 6) dp [i] |= dp [i - 6]; \n if (i >= 9) dp [i] |= dp [i - 9]; \n if (i >= 15) dp [i] |= dp [i - 15]; \n    } \n    return dp [n]; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"function is_comb($n) { for ($i=0;$i<=(int)($n/20);$i++) { $x=$n-$i*20; if ($x%3==0 and $x>=6) return true;  } return false; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static boolean checkMcNuggets(int n){ \n if (n  >= 6 && n%3 == 0){ \n  return true; \n } \n if (n >= 20 && n%3 == 2 && n != 23){ \n  return true; \n } \n if (n > 40 && n%3 == 1 && n != 43){ \n  return true; \n } \n return false; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"well, anything divisible by 3 and greater than 5 can be represented by 6&9,so i have the following python code... does it work?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This problem is the same as the ol' \"minimum many quarters, dimes, nickels, and pennies do you need to make up x cents?\" only quite a bit easier, because you don't need to keep track of a, b, c: you just need to determine if a, b, and c can exist such that their combination satisfies the conditional statement (6a + 9b + 20c == n)  And here it is in Python"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(1) time complexity"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public boolean checkNuggets(int n) { \n    if (n == 6 || n == 9 || n == 20) return true; \n    if (n < 5) return false; \n     \n    return checkNuggests(n - 6) || checkNuggests(n - 9) || checkNuggests(n - 20); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def McNugget(x):     x=int(x)     a=x%20     if a != 0 :         b=a%9         if b != 0:             c=b%6             if c != 0 :                 print \"failed\"             else:                 print \"Number of 6 Nuggets : \",  b/6                  print \"Number of 9 Nuggets : \", a/9                 print \"Number of 20 Nuggets: \", x/20"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def McNuggets(n):     if n < 6:         return False     elif n%3 == 0 or n%20 == 0:         return True     i = 2     while 3*i < n:         if (n - 3*i)%20 == 0:             return True         i = i + 1     return False"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Two variations that run in O(1):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"McNuggets ( n ) { \n  if ( n % 6  == 0 ) return true; \n \n  if ( ( n % 9 ) % 6 == 0 ) return true; \n \n  if ( ( ( n % 20 ) % 9 ) % 6 == 0 ) return true; \n \n  return false; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"boolean McNuggets(int n) {   int packages[] = {20, 9, 6};   for (int i = 0; i < 3; i++) {   n %= packages[i];    if (0 == n)    return true;  }   return false; }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14942873","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"8","title":"Write a recursive procedure, called laceStringsRecur(s1, s2), which also laces together two strings. Your procedure should not use any explicit loop mechanism, such as a for or while loop. We have provided a template of the code; your job is to insert a single line of code in each of the indicated places.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"def laceStringsRecur(s1, s2): \n        \"\"\" \n        s1 and s2 are strings. \n \n        Returns a new str with elements of s1 and s2 interlaced, \n        beginning with s1. If strings are not of same length, \n        then the extra elements should appear at the end. \n        \"\"\" \n        def helpLaceStrings(s1, s2, out): \n                if s1 == '': \n                        return out + s2 \n                if s2 == '': \n                        return out + s1 \n                else: \n                        return helpLaceStrings(s1[1:], s2[1:], out + s1[0] + s2[0]) \n        return helpLaceStrings(s1, s2, '')"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"def laceStringsRecur(s1, s2): \n    \"\"\" \n    s1 and s2 are strings. \n \n \nReturns a new str with elements of s1 and s2 interlaced, \n    beginning with s1. If strings are not of same length,  \n    then the extra elements should appear at the end. \n    \"\"\" \n    def helpLaceStrings(s1, s2, out): \n        if s1 == '': \n            return out + s2 \n        if s2 == '': \n            return out + s1 \n        else: \n            return helpLaceStrings(s2, s1[1:], out + s1[0]) \n             \n    return helpLaceStrings(s1, s2, '') \n     \nprint laceStringsRecur('123456789', 'abcde') \n#1a2b3c4d5e6789"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"dummy code - { if s1 = ' '      - {copy s2 , from s2[(out.len/2 )] till end of s2,  to out } if s2 = ' '     - { copy s1 , from s1[(out.len/2)] till end of s1,  to out } else       {     - curr_pos = out.len / 2;      - copy char from  s1[curr_pos] to out[len] , s2[curr_pos] to out[len+1]      - if (s1.len == cur_pos +1 ) s1[0] = '\\0'      - if(s2.len == cur_pos +1 ) s2[0] = '\\0'      - helpLaceStrings(s1, s2, out) }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's one solution that aims for simplicity."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Similar to merging of two arrays, but we dont need compare."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Mis Nisha Kothari you are violating Honor Code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this'll work:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public class LaceString { \n \n public static void main(String[] args) { \n \n  String s2 = \"abcdjklmn\"; \n  String s1 = \"efghi\"; \n  System.out.println(\"Lace String = \" + laceString(s1, s2)); \n } \n \n private static String laceString(String s1, String s2) { \n  int l1 = s1.length(); \n  int l2 = s2.length(); \n  StringBuffer sResult = new StringBuffer(); \n  switch (checkBigger(l1, l2)) { \n  case 1: \n   sResult = appendString(s1, s2, l2); \n   sResult.append(s1.substring(l2)); \n   break; \n  case -1: \n   sResult = appendString(s1, s2, l1); \n   sResult.append(s2.substring(l1)); \n   break; \n  case 0: \n   sResult = appendString(s1, s2, l1); \n   break; \n  default: \n   break; \n  } \n  return sResult.toString(); \n } \n \n private static StringBuffer appendString(String s1, String s2, int length) { \n  StringBuffer sResult = new StringBuffer(); \n  for (int index = 0; index < length; index++) { \n   sResult.append(s1.charAt(index)); \n   sResult.append(s2.charAt(index)); \n  } \n  return sResult; \n } \n \n private static int checkBigger(int l1, int l2) { \n  if (l1 > l2) { \n   return 1; \n  } else if (l1 < l2) { \n   return -1; \n  } \n  return 0; \n } \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14967793","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"35","title":"You are given an input form such as the following (1, (2, 3), (4, (5, 6), 7)) Each element is either a number or a list (whose elements may also be numbers or other lists). Output the numbers as they appear, stripped down into a single list. E.G. (1, 2, 3, 4, 5, 6, 7)  (Complication - how does your code handle the case of ((((5)))) vs just ( 5 ) ? )","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"def parse_list(tlist, out): \n  for el in tlist: \n    if isinstance(el, int): \n      out.append(el) \n    else:  \n      out = parse_list(el, out) \n  return out \n \nprint parse_list(tlist, [])"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"#use recursive to flat all the way to element, and then append back to single tuple element, similar for list implementation  too."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"import re \n#LOL, this is the Power of Python \na_input=(1, (2, 3), (4, (5, 6), 7)) \nnum=re.compile('\\d') \nprint (tuple(map(int,num.findall(str(a_input)))))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Should the output for both ((((5)))) and ( 5 ) be ( 5 )?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the varying grouping of list in the input does not affect the output single list, then this should be fairly easy.  (1, (2, 3), (4, (5, 6), 7)) output (1, 2, 3, 4, 5, 6, 7) (1, (2, 3), (4, 5), (6, 7)) output (1, 2, 3, 4, 5, 6, 7) ......  1. Keep the leftest \"(\" and rightest \")\" 2. Remove any \"(\" and \")\" between 3. Detect delimiter \",\" and found the number.  Code wise is easy. Sometimes this kind of interview is quick tricky. Throw you piles of information. Sometimes need to peel off the distraction and simplify the problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why don't you simply scan the string from the second element to the second to last element, and just ignore anything in it besides numbers and commas. you can have a running string that has the elements so far. then you slap a left and right parenthesis at the end and voila. however, the solution seems too simple. maybe i'm missing something."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use a stack. 1. push all the elements in the original list into a stack in reversed order 2. get the top element in the stack,  2.a if the element is a list: push all the elements in this list into the stack in reversed order 2.b if the element is a number: append to the result list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have received similar question during one of my interviews:  Create an Iterator over collection  which may contains single objects or nested collections.  Like this:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class NestedListsIterator implements Iterator { \n \n  \n public NestedListsIterator(List list) { \n  super(); \n   \n  if( list == null ){ \n   throw new IllegalArgumentException(\"'list' parameter is NULL\"); \n  } \n   \n  this.curIt = list.iterator();  \n  this.element = getNextElement(); \n } \n \n @Override \n public boolean hasNext() { \n  return element != null; \n } \n \n @Override \n public T next() { \n   \n  if( ! hasNext() ){ \n   throw new NoSuchElementException(); \n  } \n   \n  T retValue = element;   \n  element = getNextElement(); \n   \n  return retValue; \n } \n \n @Override \n public void remove() { \n  throw new UnsupportedOperationException();   \n } \n  \n  \n /** \n  *  \n  * @return next available element or NULL if not exists \n  */ \n @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) \n private T getNextElement(){ \n   \n  Object obj = null; \n   \n  while( true ){  \n    \n   if( ! curIt.hasNext() && delayedData.isEmpty() ){ \n    return null; \n   } \n    \n   if( curIt.hasNext() ){  \n     \n    obj = curIt.next(); \n     \n    // list (maybe nested list)  \n    if( obj instanceof List ){         \n     delayedData.push( curIt ); \n     curIt = ((List) obj).iterator(); \n    } \n    // single element \n    else { \n     return (T)obj; \n    }        \n   } \n   else {   \n    curIt = delayedData.pop(); \n   } \n  } \n   \n } \n  \n  \n private T element; \n private Iterator curIt;  \n private final Deque> delayedData = new ArrayDeque>(); \n \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def f(L):    res = []    for i in L:        if IsList(L): res += f(i)        else: res += [i]     return res"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def flatten(input): \n        if isinstance(input, int): \n                yield input \n        else: \n                for elem in input: \n                        for nested in flatten(elem): \n                                yield nested"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hey, why not just remove all \"{\" and \"}\", that's it?  if it encountered \"{\" or \"}??, just remove it.    quite not sure what this question is about. defenitely u can write recurrsive function to remove it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Python generator is easy to use"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"scheme code  (define strip   (lambda(lst)     (cond       ((null? lst) lst)       ((atom? (car lst)) (cons (car lst) (strip (cdr lst))))       (else (append (strip (car lst)) (strip (cdr lst)))))))  > (strip '(1 (2 3) (4 (5 6) 7))) (1 2 3 4 5 6 7) > (strip '((((5))))) (5)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"C++ implementation:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class RemoveBrackets {  public String removeBrackets(String str) {   StringBuffer sb = new StringBuffer();   sb.append('(');   int count = 1;   for (int i = 0; i < str.length(); i++) {    char currentvalue = str.charAt(i);    if (currentvalue != '(' && currentvalue != ')'      && currentvalue != ',' && currentvalue != ' ') {     System.out.println(\"currentvalue is\" + currentvalue);     // System.out.println(\"count is\"+count);     // System.out.println(\"actual value is \"+String.valueOf(str.charAt(i)));     if (count > 1)      sb.append(\",\");     sb.append(str.charAt(i));      count++;    }   }   sb.append(')');    return sb.toString();  }   public static void main(String args[]) {   RemoveBrackets rmBrackets = new RemoveBrackets();   System.out.println(rmBrackets.removeBrackets(\"((((5))))\"));   System.out.println(rmBrackets     .removeBrackets(\"(1,(2, 3), (4, (5, 6), 7))\"));  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#cannot find any clean way to use split \nimport re \na_input=(1, (2, 3), (4, (5, 6), 7)) \nsep=re.compile('[(,) ]+') \nb_string=sep.split(str(a_input)) \n#always got empty string after splitting, anyone can brighten this up? \nwhile '' in b_string: b_string.remove('') \nprint (tuple(map(int,b_string)))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int main() {     int char1;     while((char1 = getchar())!=EOF)          if (char1 == '(' || char1 == ')') continue;         else printf(\"%c\", char1); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use the composite design pattern. It will work."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#!/usr/bin/python \n \ndef flatten(l): \n  res=list() \n  t=type(res) \n  for e in l: \n    if type(e)==t: \n      res.extend(flatten(e)) \n    else: \n      res.append(e) \n  return res \n \nif __name__=='__main__': \n  l=[1, [2, 3], [4, [5, 6], 7]] \n  l=[[[[[5]]]]] \n  print flatten(l)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"my java code is below to solve problem , however only one problem is, it puts comma at the and of the number as well :)))  public class Main  {    public static void main (String[] args)  {      String s1 = \"((((((555\";             char[] chars = s1.toCharArray();           System.out.print(\"(\");      int lastcomaremover = (s1.length()-1);         for(int i=0 ; i  {                  if ( ' ' == chars[i] || ',' == chars[i]  || '('== chars[i] || ')' == chars[i])    {     continue;         }    else     {            System.out.print(chars[i]);      System.out.print(',');                            }   }          System.out.println(\")\");        }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Looks to me like a trick question. Everyone who tries more than just skipping all non-digit characters won't get the job."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static string Parse(string s) \n        { \n            int index = 0; \n            return \"(\" + Parse(s, ref index).ToString() + \")\"; \n        } \n \n        private static StringBuilder Parse(string s, ref int index) \n        { \n            StringBuilder result = new StringBuilder(); \n \n            while (index < s.Length && s[index] != ')') \n            { \n                if (s[index] == '(') \n                { \n                    index++; \n                    result.Append(Parse(s, ref index)); \n                } \n                else result.Append(s[index]); \n \n                index++; \n            } \n \n            return result; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def dfs(s): \n \n for i in s: \n  if isinstance(i,int): \n   print i, \n  else: \n     dfs(i)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I see a lot of"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static String Parse(String s){ \n    int len = s.length(); \n    StringBuffer buf = new StringBuffer(); \n    for(int i = 0 ; i < len ; i++){ \n      if(s.charAt(i) != '(' !! s.charAt(i)!=')'){ \n        buf.add(s.charAt(i)); \n      } \n    } \n    return buf.toString(); \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def flatten(arr): \n    if isinstance(arr, int): \n        return [arr] \n \n    # Otherwise we're a list \n    flat_list = [] \n    for i in arr: \n        flat_list += flatten(i) \n    return flat_list"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14959819","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"13","title":"You are given a string that is in roman numeral format. Output the integer representation. E.G. You're given XIV Output 14.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Roman numerals: see the wikipedia"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Now that I've seen someone else's solution, I wish I had iterated over the string from right-to-left."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Borth the above solutions are wrong, because they don't handle the case XLIV.  Proper solution starts from end of string and proceeds towards first char. add if the prev elem is greater than cur. subtract if prev is less than cur.  prevValue = 0; curSum = 0; for ( i= str.lenght(0-1; i >=0; i--) {    curElem = str.at(i);    curValue = valueMap.find(curElem)->second;    if ( prevValue > 0 && prevValue < curValue) {        curSum = curSum - curValue;    else {       curSum +=curValue;    }    prevValue = curValue; }  return curSum;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sorry the condition should be if ( prevValue > 0 && prevValue > curValue) { curSum = curSum - curValue; else { curSum +=curValue; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"String str = \"MCMXLVII\"; \n         \n        HashMap roman = new HashMap(); \n        roman.put('M', 1000); \n        roman.put('C', 100); \n        roman.put('L', 50); \n        roman.put('X', 10); \n        roman.put('V', 5); \n        roman.put('I', 1); \n         \n        char[] chars = str.toCharArray(); \n \n        int lastValue = Integer.MAX_VALUE; \n        int total = 0; \n        for(int i = 0; i < chars.length; i++) \n        { \n            char c = chars[i]; \n            int value = roman.get(c); \n            if(value > lastValue) \n                total += (value-lastValue*2); \n            else \n                total += value; \n            lastValue = value; \n        } \n        System.out.println(total);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int romans(string& s) { \n int s = 0; \n int anchor = 0; \n for(string::reverse_iterator it = s.rbegin(); it != s.rend(); ++it) { \n  if (*it >= anchor) { s += *it; anchor = *it; } \n  else { s -= *it; } \n } \n return s; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def print_roman(s):     map ={'I': 1 ,'V': 5 ,'X': 10 ,'L': 50 ,'C': 100 ,'D': 500 ,'M': 1000 }     sum = 0     prev = None     for i in range(len(s)-1, -1, -1):         c = s[i]         val = map[c]         if not prev == None:             if prev > val:                 sum -= val             else:                 sum += val         else:             sum += val         prev = val     return sum"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What are the rules to convert?   This is a bad interview question. Some people might not even know roman numerals, and those more familiar have a distinct advantage. Hard to judge anything by this question."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int RomanToInteger(string s) \n{ \n int result = 0;  \n int d = 1; \n int prev = -1; \n \n for(int i = s.Length - 1; i >= 0; i--) \n { \n  int curr = 0; \n \n  switch(s[i]) \n  { \n   case 'I': \n    curr = 1; \n    break; \n   case 'V': \n    curr = 5; \n    break; \n   case 'X': \n    curr = 10; \n    break; \n   case 'L': \n    curr = 50; \n    break; \n   case 'C': \n    curr = 100; \n    break; \n   case 'D': \n    curr = 500; \n    break; \n   case 'M': \n    curr = 1000; \n    break; \n   default: \n    throw new Exception(\"Invalid roman numeral\"); \n  } \n \n  if (prev == -1 || curr > prev) d = 1; \n  else if (curr < prev) d= -1; \n \n  result += d * curr; \n \n  prev = curr; \n } \n \n return result; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Actually this would Work:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This code will be ok."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14921914","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"Your test randomly changes the comparison operators in your conditionals. This is which kind of testing?    Mutation test  Glass-box test  Black-box test  Fuzz test","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Mutation test. This might be my thesis topic."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Mutation test absolutely sure"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14946838","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"Which of the following guarantees that you have exhaustively unit-tested a piece of code?    100% C0 (statement) coverage  100% C1 (branch) coverage  100% C2 (path) coverage  None of the above","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"None of the above. Testing is hard.  You could have tried every path, but not with every set of input values."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14951800","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"5","title":"For a service like TMDb with an HTTP-based RESTful API, a Ruby wrapper library such as the ruby-tmdb gem is necessary in order to call the service from a Ruby app.    True  False","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"true"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"false"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"true"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Its False"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The answer is false (confirmed by the quiz question marking \"false\" as the right answer)."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14947723","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"12","title":"Estimate the # of unique strings with limited memory Given a large array of strings S = [s1, s2, ... sN], determine Uniq(S) = how many unique strings there are in S.  (b) How large can N be to solve on one machine using only memory?  (c*) What if N is too large to fully fit in memory?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"If it's only required to estimate the number with limited memory, I think it's possible to use a simplified hash table to do this. We can define a boolean array S[](If the memory is limited we can compress every 8 boolean values into one byte) For each iteration we calculate the hash function H of current string, and check if the S[H] is true which means that we have inserted the same string before current iteration, so we do not count the string. If the hash function have no collision, the algorithm can always get the accurate result. To minimize the collision, we can use a group of hash functions like a bloom filter ....(each time we check S1[H1] S2[H2] .. SN[HN], if all those variable have been set, we assert that the string is duplicated)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"A Bloom Filter might be a good way of checking how many unique elements there are in one pass through the array. As the question implies, it would only be an *estimate*, as the bloom filter is a probabilistic data structure and there might be false positives."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can think of maintaining a trie. So if two strings differ in only one character, we are not necessarily storing all characters of the strings separately as we would end up doing if use sets.  We can store the trie for words starting with each of the 26 characters separately. And only maintain few of them in memory (cache) as per the momory constraints allow. Else, we should dump them to disk (cache miss etc)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For N large enough to fit into memory, maintain a bucket based on sum of ascii values of alphabets in a string. Compare the strings in the common bucket. This optimizes the solutino to fit into memory. If there are large number of strings in common bucket, some other values can be used to maintain bukets, like first few characters of string so as to minimize max bucket size"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"We need to keep track of strings we already encountered, so we need a \"set\".  If we can do this in-memory, then we use our language's native set implementation, if it has one (e.g. Python has sets), or, if not, we use a hash where the strings are the keys and the values are some set value like True or 1.  The basic algorithm is this:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14955665","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"16","title":"Mastermind is a game of two players. In the beginning, first player decides a secret key, which is a sequence (s1,s2,...sk) where 0 < si <= n, Then second player makes guesses in rounds, where each guess is of form (g1,g2, ...gk), and after each guess first player calculates the score for the guess. Score for a guess is equal to number of i's for which we have gi = si.  For example if the secret key is (4,2,5,3,1) and the guess is (1,2,3,7,1),then the score is 2, because g2 = s2 and g5 = s5.   Given a sequence of guesses, and scores for each guess, your program must decide if there exists at least one secret key that generates those exact scores.  Input  First line of input contains a single integer C (1 <=C <= 100). C test-cases follow. First line of each test-case contains three integers n,k and q. (1 <=n,k <=11, 1<=q<=8). Next q lines contain the guesses.  Each guess consists of k integers gi,1, gi,2,....gi,k separated by a single space, followed by the score for the guess bi (1 <= gi,j<=n for all 1 <=i <=q, 1 <=j <=k; and 0 <= bi <=k )  Output  For each test-case, output \"Yes\" (without quotes), if there exists at least a secret key which generates those exact scores, otherwise output \"No\".  Sample Input 2  4 4 2 2 1 2 2 0 2 2 1 1 1 4 4 2 1 2 3 4 4 4 3 2 1 1  Sample Output  Yes  No","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"meet in the middle  1) simple brute force approach have 9^11 complexity. So we can place on each position of key number from some guess or number dont set in any guess. 2) on base brute force we can use meet in the middle approach. We can divide length of guess on two equal parts and iterate brute force for each parts independent. So we will get lacks for each guess from first part and we have to find them in second part. this approach have complexity 9^6 in worst case for iterate and 9^5 * log(9^5) for finding lacks. So time complexity of this solution is O(q^(k/2) * q * log(k / 2)) memory complexity is O(q ^ (k/2))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This dynamic computing solution took me an hour to write and 20 minutes with a compiler to debug, plus I had to check the documentation for next_permutation. That's a pretty hard question to encounter in an interview.  This solution would need lots of comments to really be useful. The idea is that it is going to check every possible combination of which guesses could be right and wrong. Suppose a key element is guessed to be \"1\" in the first round. If we hypothesize that guess is wrong, then that key element must be equal to one of { \"2\", \"3\", \"4\" }. On the other hand, if that guess is right, then the key element must be in { \"1\" }. We keep sets to show all the possibilities that any part of the key could be. Each round gives us more constraints for each part of the key. For example, based on our guess in the second round, we might believe that same key element to be in { \"1\", \"3\", \"4\" }. We can intersect one of our hypotheses from the first round { \"2\", \"3\", \"4\" } with the information from the second round { \"1\", \"3\", \"4\" } and derive a new constraint that the key must be in { \"3\", \"4\" }.  If it ever looks like the key must be in the empty set { }, then that means we should discard that possibility, because it is impossible. If we end up discarding all possibilities from a round, then there is no way the game was valid. The program prints \"Yes\" or \"No\" depending on whether a valid game could exist.  There are an exponential number of combinations that need to be tested, because every hypothesis from one round must be tried with every hypothesis of the other rounds. The algorithm does its best to discard false hypotheses as quickly as possible though. On my laptop, it computes most games instantly, although for the largest games, it can run for over a minute. I consider that to be pretty good for this size of problem though. It's much faster than the simple brute-force approach for most games, but comparable in speed for pathological games."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the time limit is 3 sec...i have figured out a brute force solution of doing it by generating all the possible permutations...but that wd definitely time out...how can we optimise it further...any suggestions..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i think n and k are preety small and max. no of operations performed will be (11^11)*8. So i think it will not time out."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for each pair of guesses, count the number of diff pair: 1 2 3 4 5 (score1) 1 2 3 5 6 (score2) dirr pairs: 4-5 5-6, then abs(score1 - score2) <= 2. err chck: 0 <= score <= k"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Seems like CSP(en.wikipedia.org/wiki/Constraint_satisfaction_problem):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Some context:  en.wikipedia.org/wiki/Mastermind_(board_game)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think we should find the number of matching columns,ie. if input is: 4 4 2 2 1 2 2 0 2 2 1 1 1  here number of matching columns , same=1. Then find largest and smalllest values of b, here largest=1,smallest=0 Then find diff=largest-smallest Find nonmatch=q-same  if(match >= lower  && nonmatch >=diff) { print \"yes\" } else print \"No\"  I dont know how valid is my approach,but I got all the test cases correct,but one hidden case went wrong. any further ideas ?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14921707","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"47","title":"You are given an array of N elements.arrange array in such a way that sum of any cunsucative k numbers are divisible  by NUM.if not possible print -1.(it may possible that there are many solution possible then return any one)  For example: N=6 k=3 NUM=63 array={80,17,90,82,27,19}  Answer:{19,17,27,82,80,90} any 3 cunsucative no. like (27+82+80)%63=0 another solution={27,19,17,90,82,80}  may be a hint :try to group all no.'s in mod NUM map and use vector and map.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"here is a property should be noticed: if ai + ... + ai+k mod num == ai+1 + ... + ai+k+1 mod num, (ai+k+1 - ai) mod num == 0 let a = N/k, b = N%k, if solution exist, there should be way to partition numbers in such a way: 1. totally k groups, N%k groups have N/k + 1 numbers each, and (k-N%k) groups have N/k numbers each. The numbers in each group are in the same mod set. (same remainder mod NUM) 2. The sum of k groups' remainder divisible by NUM.  Then algorithm is quite trivial, group numbers by remainder, with b groups of a + 1 numbers and k-b groups of a numbers, check the sum of remainder."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"array = {80,17,90,82,27,19}, k=3, NUM=63 1. after modulus all array elements with NUM     array = {17,17,27,19,27,19}, exclude all zeros if there 2. hash all data and keep the count of each element 3. there should be K unique elements 4. sum of all unique elements should be equal to NUM 5. difference between the counts of any two elements should be at most differ by 1. 17 19 27 17 is Correct 17 19 27 17 19 is Correct 17 19 27 17 17 is not NOT Correct as 17 are 3 but 19's 27's are 1   proof: lets 17+19+27 is equal to 63 with K elements next 19+27+x=63, so x should be 17 next 27+17+x=63, here again x should be 19  so the series would be like 17 19 27 17 19 27 (as per original array)  here series should start with element with max count and then next max count etc... if the count of all elements are same then the order can be anything. 17 19 27 17 19 27 19 17 27 19 17 27 both are correct   if number of unique elements are less than K then ex: arr={2 ,5, 0 ,9 ,1, 9 ,9 ,4} k=3, NUM=2, hash array={0,1,0,1,1,1,1,0}  0's - 3 1's - 5  actually expected number of unique elements are 3(K), but here only 2 are there, so there is one number duplicate(K-2 = 1) this duplicate should be 1, so for every set there should be 110... here number of zeros are more than number of 1's (11, 11, 1) so, series should start with element which is max occurrences  if number of 1 are 6 then 11 11 11 0 0 0, here number sets of 1's and 0's are same, in this case it works either order"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what if we have k is 3 sum is 3 1 1 1 1 1 1 2 2 2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int build_good_array(int *a, int n, int num, int k) \n{ \n int i; \n int ret = -1; \n int *next = (int *)malloc(sizeof(int) * n); \n int *result = (int *)malloc(sizeof(int) * n); \n int *counts = (int *)malloc(sizeof(int) * num); \n int *modulo_last = (int *)malloc(sizeof(int) * num); \n memset(counts, 0, sizeof(int) * num); \n memset(modulo_last, -1, sizeof(int) * num); \n  \n  \n for (i = 0; i < n; ++i) { \n  next[i] = modulo_last[a[i] % num]; \n  modulo_last[a[i] % num] = i; \n  ++counts[a[i] % num]; \n } \n \n int even_entries_count = 0; \n int even_sum = 0; \n int odd_sum = 0; \n int odd_entries_count = 0; \n int result_index = 0; \n for (i = 0; i < num; ++i) { \n  if (counts[i] == (n / k)) { \n   ++even_entries_count; \n   even_sum += i; \n  } else if (counts[i] == (n / k) + 1) { \n   odd_sum += i; \n   result[result_index++] = a[modulo_last[i]]; \n   modulo_last[i] = next[modulo_last[i]]; \n   ++odd_entries_count; \n  } else if (counts[i] != 0) { \n   goto out; //out of luck. \n   // btw. a * (n/k) + b (n/k + 1) is also valid. \n  } \n } \n \n if (odd_entries_count != (n%k)) { \n  goto out; \n } \n if (even_entries_count != (k - (n%k))) { \n  goto out; \n } \n if ((even_sum + odd_sum) % num != 0) { \n  goto out; \n } \n \n // We have filled n%k entries already. \n for (i = 0; i < num; ++i) { \n  if (counts[i] == (n / k)) { \n   result[result_index++] = a[modulo_last[i]]; \n   modulo_last[i] = next[modulo_last[i]]; \n  } \n } \n \n // Now we have k-length sequence sum divisible by NUM. \n for (;result_index < n; result_index) { \n  i = result[result_index - k] % num; \n  result[result_index++] = a[modulo_last[i]]; \n  modulo_last[i] = next[modulo_last[i]]; \n } \n \n memcpy(a, result, sizeof(int) *n); \n ret = 0; \n \nout: \n free(next); \n free(result); \n free(counts); \n free(modulo_last); \n return ret; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"WTF???  THAT ASK????? i all not understand. omg."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This problem can be solved based on this simple property  For 'k' numbers to add up such that (a1+a2+...+ak) % NUM = 0, means the sum of the individual numbers a1, a2...ak remainder with NUM, must be equal to NUM. (So that total remainder becomes 0)  Further, since it requires that they be in order and sequential, that is after first k numbers, when you remove a1, and include ak+1, this new set must also have the same property. This implies that the mod value of every element removed must be matched by the next element.  Based on these observances, the algo is pretty simple  Create 'Num' Buckets, For every element calculate its mod with Num, and add to buckets. If the number of filled buckets are not equal to k, return not possible. If the total number of elements in each of the 'k' buckets are not equal, return not possible. If the sum of the bucket values(Mod values) is not equal to 'k', not possible.  The answer is then just to pick one number from each bucket in a round robin fashion.  ------------------------ I think this is the simplest way to go about it"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"so basically, we have at most k distinct number(after mod). then we use DP or whatever to check whether we can get the sum with k numbers(must include all distinct number and may possibly include some repeated number, can be done in DP when k is very large!) if not obviously false. else we can check every possibility. say 1,2,3 and two 4s, can be an example of k=5 number=14. so we check the count of these numbers(1,2,3,4). it should be N/k 1s, N/k 2s, N/k 3s, 2N/k 4s and possibly  any combination of N%k elements from (1,2,3,4,4). Let me know whether I get it!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void printGroupedNumbers(int n, int k, int nUM, int[] list) { \n \n HashMap> modMap = new HashMap>(); \n int sum = 0; \n for (int index = 0; index < list.length; index++){ \n  sum += list[index]; \n  int key = list[index] % nUM; \n  List keyVals = modMap.get(key); \n  if (keyVals == null) \n   keyVals = new ArrayList(); \n  keyVals.add(list[index]); \n  modMap.put(key, keyVals); \n } \n  \n if (n%k != 0 || sum % nUM != 0 || modMap.keySet().size() != k) { \n  \n  System.out.println(\"-1\"); \n  return; \n } \n  \n int prev = -1; \n for (int keyV : modMap.keySet()){ \n  if (prev != -1){ \n   if (prev != modMap.get(keyV).size()) \n   { \n    System.out.println(\"-1\"); \n    return; \n   } \n  } \n   prev = modMap.get(keyV).size(); \n   \n } \n  \n for (int itr = 0; itr < prev; itr++){ \n  for (int keyV : modMap.keySet()){ \n   System.out.print(modMap.get(keyV).get(itr) + \" \"); \n    \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static class Solution{ \n  public static void main(String[] args){ \n   int[] array1 = {80,17,90,82}; \n   if(Rearrange(array1, 3, 63)==-1) \n    System.out.println(-1); \n   System.out.println(); \n    \n   int[] array2 = {2 ,5, 0 ,9 ,1, 9 ,9 ,4}; \n   if(Rearrange(array2, 3, 2)==-1) \n    System.out.println(-1); \n   System.out.println(); \n    \n   int[] array3 ={22,23,44,2,1,65,86,107,128,149,170}; \n   if(Rearrange(array3, 4, 21)==-1) \n    System.out.println(-1); \n  } \n   \n  public static int Rearrange(int[] array, int k, int num){ \n   int n = array.length; \n   HashMap modHash = new HashMap<>();   \n   for(int i=0;ik) \n    return -1; \n   if(n%k==0){ \n    for(int i: modHash.keySet()){ \n     if(modHash.get(i).length != n/k) \n      return -1; \n    } \n    for(int b=0;b modHashFirst = new HashMap<>(); \n    HashMap modHashSecond = new HashMap<>(); \n    int bnum = (int)Math.ceil((double)n/(double)k); \n    for(int i: modHash.keySet()){ \n     if(modHash.get(i).length%bnum != 0 &&  \n       modHash.get(i).length%bnum != Math.floor((double)n/(double)k)) \n      return -1; \n     if(modHash.get(i).length%bnum == 0) \n      modHashFirst.put(i, modHash.get(i)); \n     else \n      modHashSecond.put(i, modHash.get(i)); \n    } \n     \n    //Full Buckets: \n    for(int b=0;b"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think we should not dweal deep into the number theory and the solution could me much simpler -       public static void findCombination(Set num, Set candidate, Set outcome) {          if (outcome.size() == n) printcombination(outcome);          if (candiate.size() == 3) {               if (satisfyCondition(candidate))                   return true;               else                   return false;          }  else {                 for(each element in num) {                     num = num - item(num(0));                     candidate = candiate U item(num(0));                     outcome = outcome U item(num(0));                     if ( findCombination(num, candiate, outcome) ) {                           //extract two items and call recursively                           //candiate = candiate - two items                          // outcome = outcome - those two                          // num = num U those two - push them back                           findCombination(num, candiate, outcome) ;                           //Same thing for other two combination                           findCombination(num, candiate, outcome) ;                      }else {                        //take new item from num                        // remove last from candiate and outcome and push them back to num                        //add new item to candiate and outcome                        findCombination(num, candiate, outcome) ;                     }                 }          }      }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14874809","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"20","title":"You are given an array of integers. Find all the combinations of the numbers of the array, that sum to another number(might be different for different combination) from the array. One property of the array: The maximum number of the array will not be much greater than the others.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can you give a couple of examples? The question is not very clear."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Are all the numbers positive? Is the key always greater than the largest number/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct node \n{ \n struct node *global_next; \n struct node *hash_next; \n int sum; \n int first_index; \n}; \nstatic int \nint_hash(int a) \n{ \n return (int)(((long long)(a) * 11400714819323198485ULL) >> ((sizeof(long long) * 8) - 14)); \n} \nstatic void \nhash_table_add(int sum, int index, struct node **hash_table, struct node **global_list) \n{ \n struct node *curr; \n int hash = int_hash(sum); \n for (curr = hash_table[hash]; curr != NULL; curr = curr->hash_next) { \n  if (curr->sum = sum) { \n   break; \n  } \n } \n \n if (curr == NULL) { \n  curr = (struct node *)malloc(sizeof(node)); \n  curr->sum = sum; \n  curr->first_index = index; \n  curr->global_next = *global_list; \n  *global_list = curr; \n  curr->hash_next = hash_table[hash]; \n  hash_table[hash] = curr; \n } \n} \n \nvoid find_sums(int *a, int n, int *sums, int sum_count) \n{ \n struct node *global_list = NULL; \n struct node **hash_table = (struct node **)malloc (sizeof(node *) * (1 << 14)); \n struct node *curr; \n int i; \n int find_sum; \n int hash; \n \n for (i = n - 1; i >= 0; ++i) { \n  for (curr = global_list; curr != NULL; curr = curr->global_next) { \n   /* new entries will get added at the begining would not be issue. */ \n   hash_table_add(a[i] + curr->sum, i, hash_table, &global_list); \n  } \n  /* Add the number itself. */ \n  hash_table_add(a[i], i, hash_table, &global_list); \n } \n \n for (i = 0; i < sum_count; ++i) { \n  find_sum = sums[i]; \n  printf(\"%d :\", find_sum); \n  while(find_sums != 0) { \n   hash = int_hash(find_sum); \n   for (curr = hash_table[hash]; curr != NULL; curr = curr->hash_next) { \n    if (curr->sum = find_sum) { \n     break; \n    } \n   } \n \n   if (curr == NULL) { \n    printf(\"not found\"); \n    break; \n   } else { \n    printf(\"%d \", a[curr->first_index]); \n    find_sum -= a[curr->first_index]; \n   } \n  } \n  printf(\"\\n\"); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Python Code: not quite easy!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Recursive backtracking solution to this problem is really easy to code and formulate. But I am sure interviewer will ask for something better therefore the challenge is to find some polynomial solution to this problem. Just can't figure out any DP solution for this one !!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"naive recursive solution in Java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Will this function work. I am using DP here  SumSet(int sum, int *a, int n) {  if(a[n] > sum)  {   //no need to choose this number   SumSet(sum, a, n-1);  }  else  {   //explore both the path, taking the number and not taking the number   SumSet(sum-a[n], a, n-1);   SumSet(sum, a, n-1);  } }  Please let me know if I am doing something wrong here"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Will this function work. I am using DP here  SumSet(int sum, int *a, int n) {  if(a[n] > sum)  {   //no need to choose this number   SumSet(sum, a, n-1);  }  else  {   //explore both the path, taking the number and not taking the number   SumSet(sum-a[n], a, n-1);   SumSet(sum, a, n-1);  } }  Please let me know if I am doing something wrong here"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Combinations \n        { \n            public List Combs { get; set; } \n \n            public Combinations() \n            { \n                Combs = new List(); \n            } \n            public void Add(int[] item) \n            { \n                Combs.Add(item); \n            } \n \n            public void Add(Combinations left, Combinations right, int[] set) \n            { \n                List newComs = new List(); \n                foreach (int[] leftItem in left.Combs) \n                { \n                    foreach (int[] rightItem in right.Combs) \n                    { \n                        if ((leftItem.Length + rightItem.Length) <= set.Length) \n                        { \n                            int leftIndex = 0; \n                            int rightIndex = 0; \n                            List unionItem = new List(); \n                             \n                            while (leftIndex < leftItem.Length || rightIndex < rightItem.Length) \n                            { \n                                while (leftIndex < leftItem.Length && (rightIndex == rightItem.Length || leftItem[leftIndex] <= rightItem[rightIndex])) \n                                { \n                                    unionItem.Add(leftItem[leftIndex]); \n \n                                    leftIndex++; \n                                } \n                                while (rightIndex < rightItem.Length && (leftIndex == leftItem.Length || leftItem[leftIndex] >= rightItem[rightIndex])) \n                                { \n                                    unionItem.Add(rightItem[rightIndex]); \n                                    rightIndex++; \n                                } \n                            } \n \n                            if (AllItemsExist(unionItem, set)) \n                            { \n                                newComs.Add(unionItem.ToArray()); \n                            } \n                        } \n                    } \n                } \n  \n                foreach (int[] item in newComs) \n                { \n                    if (!Combs.Contains(item, this)) \n                    { \n                        Combs.Add(item); \n                    } \n                } \n            } \n \n            private bool AllItemsExist(List unionItem, int[] set) \n            { \n                int setIndex = 0; \n                foreach(int item in unionItem) \n                { \n                    while (setIndex < set.Length && set[setIndex] != item) \n                    { \n                        setIndex++; \n                    } \n \n                    if (setIndex < set.Length && set[setIndex] == item) \n                    { \n                        setIndex++; \n                    } \n                    else \n                    { \n                        return false; \n                    } \n                } \n \n                return true; \n            } \n ///assues set is sorted in ascending order \nCombinations FindCombinations(int min, int x, Combinations[] pastComb, int[] set) \n        { \n            if (x < min) throw new ArgumentException(x.ToString()); \n            if (pastComb[x - min] != null) return pastComb[x - min]; \n \n            Combinations comb = new Combinations(); \n            if (set.Contains(x)) comb.Add(new int[] { x } ); \n \n            if (x > min) \n            { \n                for (int i = min; i <= x / 2; i++) \n                { \n                    Combinations leftSet = FindCombinations(min, i, pastComb, set); \n                    Combinations rightSet = FindCombinations(min, x-i, pastComb, set); \n                    comb.Add(leftSet, rightSet, set); \n                } \n            } \n \n            pastComb[x-min] = comb; \n            return comb; \n        } \n \nFindCombinations(min, x, allComb, set); \nList result = allComb[x - min].Combs;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"well, if the array has n ones - [ 1, 1, 1, 1, ..., 1 ] and the number is n/2 (assuming n is even), then we have Binomial(n, n/2) = n!/((n/2)!)^2 options, which is exponential. So a polynomial solution is not possible."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can sort the array from smallest to largest, then for each element i, we are looking for a subset in the range [0, i) with sum equals to arr[i], which is the subset sum problem and it is NP-complete.   However, we can generate solutions with DP: Solution(sum, i) =  Solution(sum, i-1) || Solution(sum-arr[i], i-1)  The DP algorithm can be implemented bottom-up, and it's basically enumerating all possible combinations."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is the typical subset sum problem that has a pseudo-polynomial solution to determine if there is a solution or not via dynamic programming. I don't know if there is a viable solution to determine the actual solution. Or could I be mistaken? AFAICT, the solution is NP-Complete."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"We could use DP if all the numbers are positive  DP[0][0] = true for i from 1 to array.length,       for j from 1 to K              DP[i][j] = DP[i - 1][j - num[i - 1]]  then backtrack to print all the combinations"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14859694","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"33","title":"Given an array and a key, sum min subarray whose sum is no less than key.  O(n) Time needed","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Doesn't subarray normally refer to a contiguous subarray? Or are we talking about subsequences here, which may not be contiguous ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Assumption : All Numbers, Keys are +ve Sliding Window Method"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"So, here is the working version of the code that will print all sub arrays whose sum of the elements is more than the key.  Time complexity is O(n2) using recursion. Not sure, how to do with O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I believe there is an answer I solved this question in two attempts :  1) In first attempt I sort the array in decreasing order and then take the sum of each element starting from the largest till the sum is greater than key value.   complexity given I used merge sort is :  nlogn + r where r is the size of subset  2) Second attempt is a follows : Take each element of array and push it into a binary tree . An keep the total sum at top node. One the sum exceed given value. Now either this the is the solution or there are element with values greater than existing values... So for now on for each insert iteratively remove lowest from the tree till total sum is less than given value. .. (and that solves it in one iteration..)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Are there extra conditions like all numbers are positive. Otherwise, it is possible there is no answer. E.g. key is positive, and all numbers in the array are negative"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"is there a situation that a1 + a3 + a4 is smaller than a3 + a4 + a5??the alogrithm seems not calculate the value of a1+a3+a4?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int[] arr = {}; // read from the input \nint key = ; \nint sum = 0; \nint minArrayLength = Integer.maximum; \nfor (int i = 0; i < arr.length; i++) { \n    sum = 0; \n    for (int j = i; j < arr.length; j++) { \n        sum+= arr[j]; \n        if (sum >= key) break; \n    } \n \n    if (sum >= key) { \n        int subArrayLength = (j - i)  + 1; \n        if (minArrayLength > subArrayLength)  minArrayLength = subArrayLength; \n    } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int ARRAY, ARR_LEN, KEY; // passed in \nint subArrStartIndex = 0, subArrLen = 0, sum = 0; \n \nfor (int i = 0; i < ARR_LEN; ++ i){ \n    sum += ARRAY[i]; \n \n    if (sum < key){ \n        subArrLen ++; \n    } else { \n        sum -= ARRAY[subArrStartIndex]; \n        subArrStartIndex ++; \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Below is the code. I think this will work for O(n) because in this case every element will be traversed at the max 2 times. Please let me know if you find bug in this.  public class MinSubArrayWithK {  static int[] printSubArray(int[] a,int k){   int min_diff=a.length-1;   int sum = 0,i= 0,j=0;   for(i =0;i   sum += a[i];    if(sum >= k){     while(sum - a[j] >= k){      sum -= a[j];      j++;     }     int diff = i - j ;     if(diff < min_diff){      min_diff = diff;     }    }   }   int[] answer = new int[min_diff+1];   int index = 0;   for(i = j;i<=j+min_diff;i++){    answer[index++] = a[i];    System.out.println(a[i]);   }      return answer;  }    public static void main(String[] argv){   int[] a = {3,5,2,7,5,3,8,3,9,8,4,2};   printSubArray(a,12);  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Int sum = 0;  For ( I = 0; I < n ; ++I) { Sum+= a[i]; If (sum >= k){ prints found return;} If (sum < 0) sum = 0; // negative value will reduce the running sum and we want to grow it"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int sum = 0; int minSum = INT_MAX; int i = 0; j = 0; while(ture){  sum += A[i]  if(sum >= key){   //Go back   int tmpSum = 0;   for(int k = i; k > j; k--){    tmpSum += A[k];    if(tmpSum >= key){     if(minSum > tmpSum) minSum = tmpSum;     break;    }   }   j = i;      //Go forward   sum = 0;   continue;  }  i++; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Missed one line...  int sum = 0; int minSum = INT_MAX; int i = 0; j = 0; while(ture){  sum += A[i]  if(sum >= key){   minSum = MIN(sum, minSum);   //Go back   int tmpSum = 0;   for(int k = i; k > j; k--){    tmpSum += A[k];    if(tmpSum >= key){     if(minSum > tmpSum) minSum = tmpSum;     break;    }   }   j = i;      //Go forward   sum = 0;   continue;  }  i++; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1st. Go throught the whole string and find the biggest on  2ed. Build a bit array m which length eq to the biggest number  3rd. Match each number to m[number] =1. Others =0. Then this is a sorted array.  4th. Add from the biggest one and compare with the key."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Like binary search divide the array with elements greater than key on right and smaller than key on left. If there are elements on the right side output any of right side elements. otherwise do the same for key/2 and select 2 elements from right side elements (if there are any) and so on until you find the sub set. I think it would be O(nlogn)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Given an array and a key, sum min subarray whose sum is no less than key. O(n) Time needed  min subarray - array of length 1 sum not less than key, i.e. that element of array is > key  Traverse the array to find an element > key (smallest element > key can also be found)  Please suggest."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is subset sum problem (variation of knapsack). So it cannot be done in O(n). DP will result in O(nk).  where k is key."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solutions for both interpretations.  However, they are more than O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"$array = array(11,4,-23,6,-5,4,77,6,-1,3,-65,4,8,7,9); $number = 40; $l=0; $r=0; $fr=0; $fl=0; $count = count($array); $cursum=0; $diff = PHP_INT_MAX; for ($i=0;$i<$count;$i++) {     $cursum = $cursum + $array[$i];     if ($cursum >= $number && (($cursum-$number)<$diff))     {         $fl = $l;         $r = $i;         $fr = $r;         $diff = $cursum-$number;     }     if ($cursum < 0)     {         $cursum=0;         $l=$i+1;     } } echo (\"closet - \" . ($number+$diff) . \"\\n\"); echo (\"left - $fl \\n\"); echo (\"right - $fr \\n\");"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static class solution{ \n  public static void main(String[] args){ \n   int[] array = {1,2,5,5,2,3,5}; \n   int key = 5; \n   int min = 100; \n   int sum = 0; \n   int block=0; \n   for(int i=0;ikey){ \n     if(sum < min) \n      min = sum; \n     int sum2=0; \n     for(int j=i;j>block;j--){ \n      sum2+=array[j]; \n      if(sum2>key){ \n       break; \n      } \n     } \n     if(sum2>key && sum2 < min) \n      min = sum2; \n     block = i; \n    } \n   } \n   System.out.println(min); \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is code in Objective-C."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can't we just modify Kadane's algorithm to determine the end point for the max sum so far to have reached a value greater than or equal to the key?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14847691","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"6","title":"single machine,??given a dictionary(key->value),every entry takes 1KB??totally10 Million??entry??single mutex protecting the dictionary??mutex takes 512 Byte??What potential problems do you see and how would you address them?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"1. If dictionary is read only then no protection is needed.  It is adding starvation for no good.  2. If read write operation are happening then reader writer will perform better, but still can cause some starvation, but it is better than one mutex.  3. You can have multiple mutex, each protecting subset of hash buckets.  1 mutex protects n buckets.  Bucket%n is the mutex you need to grab.  1 mutex for each bucket would cost too much and would become unreasonable.  4. 1 reader writer lock for n buckets.  Seems like over engineering to me."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@steve: \"totally10 Million??entry\" ---> what do you mean by this? is the dictionary sorted in increasing order of keys?  As the data is huge(~ 10 GB),I guess,  the interviewer is looking for some reader-writer sort of solution(assuming he wants to edit the entries too...)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14852688","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"10","title":"Implement atof function. eg., +3.5e-2, .03e1, 1e1, 0.0","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"1. detect delimiter \"e\" and split to left and right parts 2. then two parts are parsed as    * detect the starting character with \"+\"/\"-\"    * call atoi() on the right part    * detect delimiter \".\" on the left part and split into two sections      * use atoi() on two sections      * the 2nd section times power(10, - 2ndSection.size()); * Then combine them together including the sign."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"regular expression + atoi()"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Doesn't seem like a very interesting thing to test a candidate on IMO."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use automata to simulate the process"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming I have no regular expression library to use:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14851686","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"12","title":"giving lots of intervals [ai, bi], find a point intersect with the most number of intervals","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"store each boundary value as a separate element in an array with the information whether it's the start boundary or end boundary. Sort this array by boundary value. initialize an integer overLapCount = 0; Traverse this array from start to finish whenever you cross a \"Start\" boundary, increment overlapCount whenever you cross an \"End\" boundary, decrement overlapCount store the maxOverLapCountSoFar at the end of the traversal you will have the information about what is the maximum possible overlap for a range. You can easily modify this to store the range information as well."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Using a Sweep Line algorithm approach I think is the way... can be done in N logN"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"sweep line should work. sort the endpoints. low1-low2-low3-high1-high2-high3-low4-high4. keep a counter.. increase it if you encounter low-type, reduce it if you encounter high-type. keep the maxcount."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I guess the intersections should meet ai-1 < bi-1 < ai < bi < ai+1 < bi+1.(i-1, i and i+1 are indices)  So here is an array a0, b0, a1, b1, ......, an-1, bn-1; For each number x, find the least number that is greater/equal to x. And found and the index (M) is an ODD number (in C/C++ index) then x is located in [a(M-1)/2, b(M-1)/2]. Record the occurrence and find the largest"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For those intersections having overlap they can be split into sub-sections.  For instance, two sections like [1, 5], [2, 4]. Then [1, 5] can be split into [1, 2 - delta), [2, 4], (4 + delta, 5] and apply the same method in my last comment. And the occurrence of [1, 5] is sum of 3 sub-sections."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"$bounds=array(); foreach($intervals as $intv) { //assume $intv[0]=low $intv[1]=high    $bounds[$intv[0]]=1;     $bounds[$intv[1]]=-1;  } ksort ($bounds); //sort by key, which are bound values  $max_intersect=0; $intersects=0; foreach($bounds as $bound =>$type){   if($type==1) $intersect++;   elseif($type==-1) $intersects--;   if($max_intersect <$intersects)       $max_intersect = $intersects; } return $max_intersect;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"$bounds=array(); \nforeach($intervals as $intv) { //assume $intv[0]=low $intv[1]=high \n   $bounds[$intv[0]]=1;  \n   $bounds[$intv[1]]=-1; \n } \nksort ($bounds); //sort by key, which are bound values  \n$max_intersect=0; $intersects=0; \nforeach($bounds as $bound =>$type){ \n  if($type==1) $intersect++; \n  elseif($type==-1) $intersects--; \n  if($max_intersect <$intersects) \n      $max_intersect = $intersects; \n} \nreturn $max_intersect;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for each boundary b { \n   sweep[b.start]++ \n   sweep[b.end]-- \n} \n \nint current = 0, max = 0 \nbool recording = false \nint start, end \nfor i = 0 to sweep.length { \n  current += sweep[i] \n  if (current > max) { \n    max = current \n    start = i \n    recording = true \n  } \n  if (sweep[i] < 0 && recording) { \n    end = i \n    recording = false \n  } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def find_point_intersect(ranges): \n    sorted_ranges = [] \n    index = 0 \n    for (low,high) in ranges: \n        sorted_ranges.append((low, index)) \n        sorted_ranges.append((high, index)) \n        index +=1 \n    sorted_ranges.sort() \n    max_range = 0 \n    max_range_so_far = 0 \n    encountered_indices = {} \n    low = -sys.maxint \n    high = -sys.maxint \n    for i in range(len(sorted_ranges)): \n        (num, index) = sorted_ranges[i] \n        if max_range_so_far == 0 : \n            high = -sys.maxint \n        if not encountered_indices.has_key(index): \n            encountered_indices[index] = 0 \n            max_range_so_far += 1 \n        else: \n            if high == - sys.maxint: \n                high = num \n            max_range_so_far -= 1 \n        if max_range_so_far > max_range: \n            low = num \n            max_range = max_range_so_far \n    print max_range \n    print low, high"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"I don't think the sweep-line algorithm will work. The question asks us to find a point which intersects with most number of intervals. Here is an example where the sweep-line algo is wrong..  If intervals are [1,5] [2,9] [12,16] [11,20] [14,21] the sweep line gives result as 0 when in fact you have [14,16] which intersects with 3 intervals.  Please correct me if I'm wrong."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5742219382226944","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"3","title":"Print all paths of a binary tree from root to leaf.  Later, extend the solution to work with graphs, careful attention to cycles which you should print as paths as well (without printing visited nodes twice).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Who interviewed you?  Why does it say \"Later...\" ?  I've seen this on a programming challenge website."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For binary tree:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5654773747417088","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"14","title":"Given two extremely large numbers - each number is stored in a Singly Linked list, with the MSB at the head. You are not allowed to reverse the Linked lists. Write a program to multiply them in optimum space and time.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use recursion  let the two numbers be a , b:   include 3 cases 1 length of a > length of b 2 length of a < length of b 3 length of a = length of b"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What I was thinking is: convert the linked lists to a stack. Here, it becomes a reversed linked list, and we can pop the top item of each list, multiply the two, write the result to a new node (or reuse) and free up the two input nodes. Remember to carry over using a temp variable. This should consume the least space, but more cpu to convert to stack. What do you guys think?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Save the result in a doubly linked list:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use an array of length (L1 + L2) to store the result, where L1 is the length of num1, while L2 is the length of num2."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"n^2 in time and n in space"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You could use Karatsuba's method to improve the usual O(n*m) to O(n^1.585) where n > m. However, you should also make sure that n ^ 1.585 >> n * m, because otherwise, the overhead of computing Karatsuba's method may not pay-off compared to doing it the traditional way (long multiplication).  When using Karatsuba's method, a few things I believe are worth considering:  - You need to traverse both lists once at the beginning to calculate their lengths. - For big enough numbers, are the lengths small enough to fit in an unsigned long number each? This goes outside the scope of the question, since by being able to store the whole number as a linked list in one machine that means its length should also fit in a long (or even int) number type. - The method doesn't generalize well (I think) for numbers of different lengths, so you need to pad with imaginary zeroes the number with smallest length in the implementation. - Instead of handling base case of 1*1 digit-length numbers, use a reasonable size in which is better to use the traditional approach (long multiplication) and use it instead of dividing and conquering. - Along with additions, Karatsuba's method require support for subtractions so when you're building a function that sums two lists, you may consider making it general enough to handle subtraction as well. - Previous point makes more evident the fact that you will support for negative numbers, so, how should you represent a negative number in a linked list? Probably by making the internal number in each node signed so that it generalizes better. - For big enough numbers, if instead of a singly linked list you use a circular doubly linked list, I think you could generalize the Karatsuba's method in a similar way as External Sorting and control the way you load nodes from disk into RAM. I mentioned a circular doubly linked list since you need to perform the addition (analogous to merge in External Sorting) backwards so that you can handle carryovers linearly without stack. - For big enough numbers, you could potentially generalize the Karatsuba's method to use Map-Reduce technology, since divide and conquer naturally accommodates for it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Another way to do this may be traverse the list and save the numbers in a long long type and multiply them and create a new result linked list. eg: Multiply 123456789 and 23454343"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using System; \nusing System.Collections.Generic; \nusing System.Linq; \nusing System.Text; \nusing System.Threading.Tasks; \n \nnamespace ConsoleApplication1 \n{ \n    class Node \n    { \n        public int val; \n        public Node next; \n        public Node(int val) \n        { \n            this.val = val; \n        } \n    } \n \n    class MultipleTwoLists \n    { \n        static int digitsPerNode = 2; \n        static Node result = null; \n        static Node resultp = result; \n        static Node resultp2 = result; \n \n        public static void mainFunc() \n        { \n            Node n1 = new Node(23); \n            Node n2 = new Node(65); \n            Node n3 = new Node(12); \n            n1.next = n2; \n            n2.next = n3; \n \n            Node n4 = new Node(34); \n            Node n5 = new Node(55); \n            n4.next = n5; \n \n            Multiply(n1, n4); \n \n            PrintResult(result); \n        } \n \n        static void Multiply(Node n1, Node n2) \n        { \n            if (n2.next != null) \n            { \n                Multiply(n1, n2.next); \n            } \n \n            Multiply2(n1, n2); \n            resultp2 = resultp = resultp.next; \n        } \n \n        static void Multiply2(Node n1, Node n2) \n        { \n            if (n1.next != null) \n            { \n                Multiply2(n1.next, n2); \n            } \n \n            if (resultp2 == null) \n            { \n                resultp2 = new Node(0); \n                result = resultp = resultp2; \n            } \n \n            int m = n1.val * n2.val + resultp2.val; \n             \n            int carryon = (int)(m / Math.Pow(10, digitsPerNode)); \n            resultp2.val = m % (int)Math.Pow(10, digitsPerNode); \n            if (carryon > 0) \n            { \n                if (resultp2.next == null) \n                { \n                    resultp2.next = new Node(carryon); \n                } \n                else \n                { \n                    resultp2.next.val += carryon; \n                } \n            } \n \n            resultp2 = resultp2.next; \n        } \n \n        static void PrintResult(Node p) \n        { \n            if (p == null) \n                return; \n \n            if (p.next != null) \n            { \n                PrintResult(p.next); \n            } \n \n            Console.Write(p.val); \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a complex solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"put it simple: v[i + j] += a[i] * b[j], for each digit in a and b;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Well, I think there might be a simpler solution. As an example, let's say you need to find 456*321 For first number  456, using trick of adding two linked list numbers on the fly without reversing it (you can find that online. Trick is to remember consecutive nodes with sum =9 and propagate carry 1 if it ended in a node whose sum was >=10 because at most you have 1 carry),  Find out all possible multiplication that is for 456*0, 456*1, 456*2, 456*3, ... 456*9 ( here 456*4 is simply adding 456 to itself 3 times). Cost is 9*N = O(N) where N is length of number. - Once you have this, the problem simply becomes iterating over second number and keep on adding (after multiplying by maintained sum by 10)   Algorithm:  1) First, find 456*1, 456*2, ... , 456*9 in O(N) and store it in int64 [] of 9 elements. e.g. Multplication[0] = 0, Multiplication[1] = 456, Multiplication[2] = 456*2 ...    2) Maintain int64 sum as answer, scan second number left to right, for the current digit in the second link list, find its multiplication value from first array, multiply sum by 10 and add it. This will give you a rolling multiplication e.g. while scanning second number 321, left to right sum = 0       for 3, sum = sum*10 + Multiplication[3] = 456*3 = 1368       for 2, sum = sum*10 + Multiplication[2] = 13680 + 912 = 14592       for 1, sum = sum*10 + Multiplication[1] = 145920+1368 = 146376  Step 1) cost is O(N) where N is length of first number step 2) cost is O(M) where M is length of second number. So total cost is O(N+M)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5110993575215104","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"4","title":"The beauty of a number X is the number of 1s in the binary representation of X.  Two players are plaing a game. There is number n written on a black board. The game is played as following:  Each time a player chooses an integer number (0 <= k) so that 2^k is less than n and (n-2^k) has as beautiful as n. Next he removes n from blackboard and writes n-2^k instead. The player that can not continue the game (there is no such k that satisfies the constrains) looses the game.  The First player starts the game and they play in turns alternatively. Knowing that both two players play optimally you have to specify the winner.  Input:  First line of the Input contains an integer T, the number of testcase. 0 <= T <= 5.  Then follow T lines, each containing an integer n.  n more than 0 and less than 10^9 +1.  Output          For each testcase print \"First Player\" if first player can win the game and \"Second Player\" otherwise.  Sample Input  7 1 2 8 16 42 1000 123  Sample Output  Second Player First Player First Player Second Player Second Player First Player Second Player  Explanation          In the first example n is 1 and first player can't change it so the winner is the second player.  In the second example n is 2, so the first player subtracts 1 (2^0) from n and the second player looses the game.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"question?id=5399897561890816"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I may misunderstanding the questions. For 16 as example, k | n-2^k | beauty(n) | beauty(n-2^k) 0   15        1                 4 1    14        1                3 2    12        1                2 3    8          1                1 stop  Only 3 is qualify for question, so I think first player will win. Why the second player wins?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a codechef question NOT a facebook interview question."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In the binary representation of the number, we count how many 0s there are on each 1's left side. If the sum is odd, the first player will be the winner, otherwise second player will win."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5179916190482432","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"27","title":"input [2,3,1,4] output [12,8,24,6]  Multiply all fields except it's own position.  Restrictions:  1. no use of division 2. complexity in O(n)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"13","title":"Maintain two arrays - front [ ] and rear [ ] front maintains the product before the current index rear  maintains the product after   the current index then the product of current index i = front[i]*rear[i]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I would like to explain it with example instead of code. Because code would be really easy:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Does division as repeated subtraction also doesn't count?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just use modular arithmetic with a large prime. Instead of divide, multiply by the inverse mod(p). 1. Calculate tp = the total product mod p 2. For each x: x = tp * x^(p - 2) mod p note: p must be picked larger than the largest result"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int GetQuotient(int a, int b) \n{ \n if (a < b) \n  return 0; \n if (a == b) \n  return 1; \n else  \n { \n  int q = (int) Math.Pow(e, (Math.Log(a) - Math.Log(b))); \n  return q; \n } \n} \n \npublic void ChangeArray(int[] arr, int n) \n{ \n int product = 1; \n for (int i = 0; i< n; i++) \n { \n  product *= arr[i]; \n } \n \n for(int i = 0; i< n; i++) \n { \n  arr[i] = GetQuotient(product, arr[i]); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  int main() {     int a[4],b[4],i,n;     for(i=0;i<4;i++)     {         scanf(\"%d\",&a[i]);     }     for(i=0;i<4;i++)     {         if(i==0)         {             b[i]=a[i+1]*a[i+2]*a[i+3];         }         else if(i==1)         {             b[i]=a[i-1]*a[i+1]*a[i+2];         }         else if(i==2)         {             b[i]=a[i-2]*a[i-1]*a[i+1];         }         else         {             b[i]=a[i-3]*a[i-2]*a[i-1];         }     }     for(i=0;i<4;i++)     {         printf(\"%d \",b[i]);     }     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void multiplyAllOthers(int arr[], int n) \n{ \n int* copy = new int[n]; \n memcpy(copy, arr, sizeof(int) * n); \n \n //multiply all others in the left \n for(int productSoFar = 1, i = 0; i < n; ++i){ \n  arr[i] *= productSoFar; \n  productSoFar = arr[i]; \n } \n //multiply all others in the right \n for(int productSoFar = 1, i = n-1; i >= 0; --i){ \n  arr[i] *= productSoFar; \n  productSoFar *= copy[i]; \n } \n \n        delete[] copy; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \n \nusing namespace std; \nint main() \n{ \n    vector A = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0}; \n    vector M(A.size());  \n \n    const int N = A.size(); \n    double m = 1.0; \n \n    for (int i = 0; i < N; i++) { \n        M[i] = m;       // m = A[0] * A[1] * .... * A[i - 1] \n        m *= A[i];      // update m \n    }     \n \n    m = 1; \n    for (int i = N - 1; i >=0; i--) { \n        M[i] *= m;      // m = A[i+1] * ... * A[N-1] \n        m *= A[i];      // update m \n    } \n    \n    for (double d : M) cout << d << \" \"; cout << endl; \n \n    return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Shouldn't it be so simple... 1. Multiple all element in first go 2. Divide the result by current element to get result at that position."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"multiply all the array elements and then divide the product with present element."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Multiplying anagram values"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Multiplying anagram values"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) { \n   \n  for (int i = 0; i < a.length; i++) { \n    \n   System.out.println(multiply(i, a.length, 1, a, 0)); \n   System.out.println(\"countAll : \"+countAll); \n  } \n } \npublic static int multiply(int i, int n, int r, int a[], int count) { \n    \n   int j = i + 1; \n    \n   if(j >= n) \n    r = r * a[j - n]; \n   else \n    r = r * a[j]; \n   \n   count++; \n    \n   \n   if(count+1 == n) \n    return r; \n    \n   return multiply(j, n, r, a, count); \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my code  1. Identify the current index and set the value of that element as 1 2. Multiple the elements in the array , that will be product of 3 numbers"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6299074475065344","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"12","title":"Given a matrix with 1's and 0's, a rectangle can be made with 1's. What is the maximum area of the rectangle.   00010 11100 11110 11000 11010 In this test case the result needs to be 8.   How:  00010     00010 11100      11  100 11110      11  110 11000      11  000 11010      11  010  If you see above the 11's are used from the first two columns and last four rows making the area or count of 1's to be 8.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"What 's wrong with you people? Stop posting these sheets of code. Write your idea first. Nobody wants to waste time reading tons of  your code."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class RectangleArea  {  public static void main(String[] args)   {   int [][] area = {{0,0,0,0,1,0,0},        {0,0,0,0,1,0,0},        {0,0,1,1,1,1,1},        {0,0,0,0,1,0,0},        {0,0,0,0,0,0,0}};          int maxarea = 0;        int startx =0;   int starty = 0;   int xlength = 0;   int ylength = 0;      for(int j=0;j y axis   {    for(int i=0;i x axis    {     int x = 0;//x de o turda ne kadar uzayabilir     int y = 0;//y de o turda ne kadar uzayabilir.      if(area[j][i] == 1)     {      int ii = 1;      int jj = 1;      int tempmaxarea = 1;           while(i+ii < area[j].length && area[j][i+ii] == 1)//detect x expansion      {       x++;       ii++;      }           while(j+jj < area.length && area[j+jj][i] == 1)//detect y expansion      {       y++;       jj++;      }       int breakxloopindex = x+1;// asagidaki aciklamanin x icin olani..defaultta max cerceve boyutunda tut.. 0 a rastladikca kucultursun      for(int l=0;l<=y;l++)      {       for(int k=0;k<=x;k++)       {        if(area[j+l][i+k] ==0)        {         if(breakxloopindex > k)         {          breakxloopindex = k;         }        }       }       tempmaxarea = (breakxloopindex)*(1+l);         if(maxarea < tempmaxarea)       {        maxarea = tempmaxarea;        startx = i;        starty = j;        xlength = breakxloopindex;        ylength = l+1;       }      }     }    }   }      System.out.println(\"Max area is:\" +  maxarea);   System.out.println(\"startx: \"+ startx + \" starty: \"+starty);   System.out.println(\"xlength:\"+ xlength + \" ylength:\"+ylength);  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"As Sam nicely suggested, previous code was wrong so I replaced it with this one. This one runs in O(WH) = O(N^2) for N = max(W, H).   The idea is we find something like cumulative sum over all columns. So when at row \"i\", w[j] is the sum of all the previous consecutive \"1\"s.   From \"w\" we can find the rectangles up to current row in O(N) time. For example, if w = [1 1 2 2 2 1], the largest rectangle has an area of 6.  Here is the python code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) \n {  \n  int [][] a =  \n    { \n     // 0 1 2 3 4 5 6 \n     /*0*/{1,0,0,0,1,0,0},  \n     /*1*/{0,0,0,0,1,0,0},  \n     /*2*/{0,0,1,1,1,1,1},  \n     /*3*/{0,0,1,1,1,1,0},  \n     /*4*/{0,0,1,1,1,1,0} \n    };  \n  int[] cur = {2,2}; \n  int[] opp = {4,3}; \n   \n  System.out.println(maxarea(a)); \n   \n } \n  \n  \n public static int maxarea(int[][] a) \n { \n  int max = 0; \n  for(int i = 0; i< a.length; i++) \n  { \n   for(int j = 0; j"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \nusing namespace std; \n \n/* find the largest rectangle in a histogram */ \nint largestRectangleInHistogram(const vector& H) \n{ \n    stack S; \n    int maxArea = 0; \n \n    for (int i = 0; i < H.size(); i++) { \n      while (!S.empty() && H[S.top()] >= H[i]) \n         S.pop(); \n \n      int span = S.empty() ? (i + 1) : (i - S.top()); \n      maxArea = max(maxArea, span * H[i]); \n \n      S.push(i); \n    } \n \n    return maxArea; \n} \n \nint largestRectangleInMatrix(const vector>& M) \n{ \n    int rows = M.size(); \n    int columns = M[0].size(); \n \n    vector H(columns); \n \n    for (int j = 0; j < columns; j++) \n        H[j] = M[0][j]; \n \n    int maxArea = largestRectangleInHistogram(H); \n \n    for (int i = 1; i < rows; i++) { \n        for (int j = 0; j < columns; j++) \n            H[j] = M[i][j] ? H[j] + 1 : 0; \n \n        maxArea = max(maxArea, largestRectangleInHistogram(H)); \n    } \n    return maxArea; \n} \nint main() \n{ \n    vector> M = { \n        {1,0,0,0,1,0,0}, \n        {0,0,0,0,1,0,0}, \n        {0,0,1,1,1,1,1}, \n        {0,0,1,1,1,1,0}, \n        {0,0,1,1,1,1,0} \n    }; \n \n    cout << \"max area = \" << largestRectangleInMatrix(M) << endl; \n} \n \n/* output: max area = 12 */"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Go through the matrix row by row; for each row, record the maximum height each column can reach. Then it becomes a skyline problem, which can be solved in O(n). Overall, the time complexity is O(n * n) and the space complexity is O(n);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In my opinion, we simply build a two dimensional array. Each element of the arrays is a struct (x,y)  X represents the number of consecutive ones in the row Y represents the number of consecutive ones in the column. F(i,j) =  if A(i,j) is 1 then F(i,j) = F(i-1) + 1 , F(j-1) + 1  Once you hit a zero, you initialize the cell to 0,0 Sample Array for the input:  0,0 0,0 0,0 1,0 0,0 1,1 2,1 3,1 0,0 0,0 1,2 2,2 3,2 4,1 0,0 1,3 2,3 0,0 0,0 0,0 1,4 2,4 0,0 1,1 0,0  And then simply doing another loop in the array, multiply the X*Y coordinates and the largest product is your largest triangle. O(n^2)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5762415492857856","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"24","title":"Imagine x is an operand and * is a binary operator. We say a string of x and * follows Reverse Polish notation if it is a postfix notation.  For example strings xx*, x, and xx*xx** follow Reverse Polish notation.  Given a string of x and *, how many insert, delete, and replace operations are needed to make the string follow the RPN.  For example, xx* need 0 operation to follow RPN since it already follows RPN. x*x needs two operations to become xx* which follows RPN. *xx* needs one operation to become xx* which follows RPN.  Your algorithm should work for a string of size up to 100.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"One of my friends helped me to solve this problem. The idea is dynamic programming!  Step A: for having RPN, it is enough to have (RPN)(RPN)*, so find the best K where (0,1,...K),(K+1,....,N-1)* is RPN (N is the length of the string).  If the last character is x, you can delete it and find the best answer for (0,....,N-1) or replace it with an asterisk and go to Step A,   or add an asterisk to the end and find the best K where (1,0,...K),(K+1,....N)* is RPN.  I have written the code for it and works perfectly even for the string size 200. Here is the code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am not very clear about the question.. especially with respect to the input , are we talking about levenshtein distance here? even then can you provide more clarity?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Exhaustive searching, this code chokes for length = 100 \nbool isValid(string str){ \n if( str.length() < 3 ) \n  return false; \n stack stk; \n int i = 0; \n while(i < str.length()){ \n  if( str[i] == 'x'){ \n   stk.push('x'); \n  } \n  else{ \n   if( stk.size() < 2) \n    return false; \n   char first = stk.top(); \n   stk.pop(); \n   char second = stk.top(); \n   stk.pop(); \n   if( first == 'x' && second == 'x'){ \n    stk.push( 'x' ); \n   } \n  } \n  i++; \n } \n return (stk.size() == 1 && stk.top() == 'x'); \n} \nstruct stringDepth{ \n int depth; \n string str; \n stringDepth(string s, int d):str(s),depth(d){} \n}; \nint minDistance(string str){ \n queue bfsQueue; \n unordered_set duplicateFinder; \n bfsQueue.push( stringDepth(str,0)); \n \n while( bfsQueue.size() > 0 ){ \n  stringDepth front = bfsQueue.front(); \n  bfsQueue.pop(); \n  if( duplicateFinder.find(front.str) == duplicateFinder.end()){ \n   int nextDepth = front.depth + 1; \n   const string currString = front.str; \n    \n   //Delete Each element \n   for( int i = 0 ; i < currString.length() ; i++){ \n    string newStr; \n    if( i == 0 ) \n     newStr = currString.substr( 1, currString.length() - 1 ); \n    else if( i == currString.length() - 1){ \n     newStr = currString.substr( 0, currString.length() - 1 ); \n    } \n    else{ \n     string first = currString.substr(0,i); \n      string second = currString.substr(i+1, currString.length()-(i+1)); \n     newStr = first + second; \n    } \n    if(isValid( newStr )) \n     return nextDepth; \n    bfsQueue.push(stringDepth(newStr,nextDepth));  \n   } \n \n   // Replace Each element \n   for( int i = 0 ; i < currString.length() ; i++){ \n    string newStr = currString; \n    newStr[i] = (newStr[i] == 'x' ? '*' : 'x'); \n    if(isValid( newStr )) \n     return nextDepth; \n    bfsQueue.push(stringDepth(newStr,nextDepth));  \n   } \n \n   //Append newChar \n   // Replace Each element \n   for( int i = 0 ; i < currString.length() ; i++){ \n    string newStr = currString.substr(0,i+1) + 'x' + currString.substr(i+1, currString.length() - (i+1)); \n    if(isValid( newStr )) \n     return nextDepth; \n    bfsQueue.push(stringDepth(newStr,nextDepth));  \n    newStr = currString.substr(0,i+1) + '*' + currString.substr(i+1, currString.length() - (i+1)); \n    if(isValid( newStr )) \n     return nextDepth; \n    bfsQueue.push(stringDepth(newStr,nextDepth)); \n \n   } \n \n   duplicateFinder.insert(currString); \n  } \n \n  bfsQueue.pop(); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is a stack question.  The correct question is when you have multiple operators and some have precedence, so you will need to include paranthesis. For this one, assuming only the \"*\" operator, a simple code will do it: A) Go through the sequence and push operands in one stack, and operators in another B) Pop an operator, pick a new operand and if we already have one from before, then attach them as the new operand. If we don't have an operand from before, just pop another one from operand stack  Python code running in O(N = number of operands + number of operators)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Umm, there's a quick O(n) solution.  Here's the idea: Anything you do to edit the string either adds an x (which is the same as removing a *) or adds a * (which is the same as removing an x). Also, we can assume that the x is added to the left and the * is added to the right. Going from right to left through the string, find the #x - #*'s at each point. Whatever the min is, (say m), then we need to put m-1 *'s on the right side. Then, we need total #x = total # star +1, so add the appropriate number of x's .   The reason this works is because this is very similar to catalan numbers with balanced parenthesis."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"0. Open algorithm book to pages explaining Shunting Yard and Edit Distance... then.. \n1. Use Dijkstra's Shunting Yard Algorithm to convert from infix to postfix \n2. Return Edit Distance (DP) {with costs 1, 1, 1 for three operations} between infix and posfix"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4909367207919616","download_status":"DOWNLOAD_DONE","votes":"4","answersCount":"51","title":"WAP to modify the array such that arr[I] = arr[arr[I]]. Do this in place i.e. with out using additional memory.  example : if a = {2,3,1,0} o/p = a = {1,0,3,2}  Note : The array contains 0 to n-1 integers.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"14","title":"void relocate(int *arr,int size) { \n for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"public static void modIndex(int[] array){         int pre = array[0];         int idx = 0;         array[0] = -array[pre];         while (true){             int i = 0;             for(; i < array.length;i++){                 if(array[i] == idx)                     break;             }             if(i == array.length) break;             int t = array[i];             array[i] = - pre;             pre = t;             idx = i;          }          for(int i = 0 ; i < array.length; i++)             array[i] *= -1;     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Deducing from the example, I think what we really want here is I = arr[arr[I]], which can be done in many ways while one of them is simply let arr[k] = k."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public class InPlaceRelocation { \n \n public static void relocate(int[] arr) { \n  if (arr == null || arr.length == 1) { \n   return; \n  } \n \n  int len = arr.length; \n  int shift = (int) Math.ceil(Math.log10(len) / Math.log10(2)); \n  int mask = (int) Math.pow(2.0, shift) - 1; \n  for (int i = 0; i < len; ++i) { \n   arr[i] += (arr[arr[i] & mask] & mask) << shift; \n  } \n  for (int i = 0; i < len; ++i) { \n   arr[i] >>= shift; \n  } \n } \n \n public static void main(String[] args) { \n  int[] arr = { 2, 3, 1, 0 }; \n  relocate(arr); \n  System.out.println(Arrays.toString(arr)); \n \n  int[] arr2 = { 5, 7, 2, 8, 3, 6, 4, 1, 0 }; \n  relocate(arr2); \n  System.out.println(Arrays.toString(arr2)); \n \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def f(a,n,i): \n if i < n:  \n  a_a_i = a[a[i]] \n  f(a,n,i+1) \n  a[i] = a_a_i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void wapMod(int[] array) { \n int first = array[0], i = 0; \n while(array[i] != 0) { \n  int tmp = array[i]; \n  array[i] = array[array[i]]; \n  i = tmp; \n } \n array[i] = first; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here we have a loop. a[0] becomes a[2] and a[2] becomes a[1]... a[0]->a[2]->a[1]->a[3]->a[0]. If we change any one value we will break the cycle. So, until we change all the values, we need to retain both the old and new values. Normally we could save them in a temporary vector b. But here we are not allowed to do that. But the hint is that the number are between 0...n-1. So, assuming n^2 < max(int) we can keep the old and the new values simultaneously with just a single number. Here is what we can do:  First change each of a[i] to n*(newval+1)+oldval. Given a[i], we can get its old value by a[i]%n and get the new value by (a[i]/n -1). Here is my code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int main() \n{ \n    int A[] = {2, 3, 1, 0, 5, 6, 4}; \n    const int N = sizeof (A) / sizeof (A[0]); \n \n    for (int i = 0; i < N; i++) { \n        if (A[i] < 0)   // already processed \n            continue; \n     \n        if (A[i] == i) { \n            A[i] = -A[i] - 1;   // reverse it to mark it processed \n            continue; \n        } \n     \n        int t = A[i]; \n        int j = i; \n     \n        do { \n            int k = A[j]; \n            A[j] = - A[k] - 1; // use negative value to to mark it processed \n            j = k; \n        } while (i != A[j]); \n        A[j] = -t - 1; \n    } \n \n    for(int i = 0; i< N; i++) { \n        A[i] = -A[i] - 1;       // restore the value \n        cout << A[i] << \" \"; \n    } \n    cout << endl; \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n) solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int *res_arr; \n  for(i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int[] IndexSwap(int[] values) { \n        int n = values.length; \n        if (n*n >= Integer.MAX_VALUE) \n            throw new IllegalArgumentException(\"Size of array is too large: \"+n); \n        for (int i=0; i < n; i++) { \n            if (values[values[i]] <= n) \n                values[i] = values[i]*n+values[values[i]]; \n            else { \n                int value = values[values[i]] / n; \n                values[i] = values[i]*n+value; \n            } \n        } \n        for (int i=0; i < n; i++) { \n            values[i] = values[i] % n; \n        } \n        return values; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void relocate(int[] arr,int size) \n{ \n int multiplier=Math.pow(10,Math.ceil(Math.log10(size))); \n for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class InPlaceRelocation { \n \n public static void relocate(int[] arr) { \n  for (int i = 0; i < arr.length; ++i) { \n   if (arr[i] >= 0) { \n    int headPos = i; \n    int headValue = arr[i]; \n    int currPos = headPos; \n    while (true) { \n     if (arr[currPos] == headPos) { \n      arr[currPos] = -(headValue + 1); // mark visited cell negative \n      break;  \n     } \n     int temp = arr[currPos]; \n     arr[currPos] = -(arr[arr[currPos]] + 1); \n     currPos = temp; \n    } \n   } \n  } \n \n  for (int i = 0; i < arr.length; i++) { \n   arr[i] = -arr[i] - 1; \n  } \n } \n \n public static void main(String[] args) { \n  int[] arr = { 2, 3, 1, 0 }; \n  relocate(arr); \n  System.out.println(Arrays.toString(arr)); \n \n  int[] arr2 = { 5, 7, 2, 8, 3, 6, 4, 1, 0 }; \n  relocate(arr2); \n  System.out.println(Arrays.toString(arr2)); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can even do number splitting based on bits, given all the integer, you can store arr[arr[i]] on other half (16 bits) and arr[i] on first 16 bits."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would like to correct my previously posted algorithm, here is the one that compiles, written in Java:  import java.util.Arrays;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Could we keep rotating the array say i times and check if the terminating condition for all elements in the array. a[i] == a[a[i]] . The rotating process could be done by log(n) and the worst case would be n log(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"solution inspired by cycle leader iteration algorithm"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For each element, trace it down until a loop is formed.  e.g. [2, 3, 1, 0]  1. all add one ==> [3, 4, 2, 1] 2. at position 0 arr[0] = arr[arr[0] - 1] = arr[3 - 1] = arr[2]  so, we swap position 0 and 2, and maintain a integer \"value\" to remember what arr[2] is originally Here we get: - new arr: [-2, 4, 3, 1] (-2 is to mark it's in right place) - value: 2 (what arr[2] is originally)  then we at the position 2, arr[2] = arr[arr[2] - 1] = arr[value - 1] = arr[1] then we swap position 2 and 1, and update \"value\" to arr[1] new arr: [-2, 3, -4, 1] value: 4  then we at position 1 as before, we get new arr: [-2, -1, -4, 3] value: 1  then we at position 3 arr[3] = arr[arr[3] - 1] = arr[value - 1] = arr[0] since arr[0] now is negative, we've finished this loop, set current position to its opposite and move to next position. Now arr = [-2, -1, -4, -3]  3. since all values are negative, they're in right places. Restore value, we get: [-2, -1, -4, -3] ==> [2, 1, 4, 3] ==> [1, 0, 3, 2]  4. done"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This can be accomplished the same way you would do it with memory allocation, but instead using pointers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Reverse function can be work in this use case: example : if a = {2,3,1,0}  ----> Reverse(0,4)--> 0,1,3,2----> reverse (0,1)---> 1 ,0 ,3,2"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5412018236424192","download_status":"DOWNLOAD_DONE","votes":"3","answersCount":"9","title":"Given a linked list where apart from the next pointer, every node also has a pointer named random which can point to any other node in the linked list. Make a copy of the linked list.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"L: a b c d ...  L': a A b B c C ...  A???random = a???random???next  Split L' into two list"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"We need to run three iterations over a linked list, which takes O(n) time.  input: a b c NULL output: a' b' c' NULL  1) Create nodes for an output and adjust \"next\" pointers for the input and the output in such a way to build a a' b b' c c' NULL  2) Adjust \"random\" pointers for the output by using the random and next pointers of the input list. For example, b'->random = b->random->next  3) Adjust next pointers for the input and output lists. For example, temp = (b'->next)?b'->next->next:NULL; b->next = b'->next; b'->next = temp;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"There are ways that involve trickery, which you want to avoid in interview settings. It might be fun to try these funky ways when you are home drinking coffee and chilling.  A good linear way is to use a map.  1) Go through your linked list, and for each node v, create a new node u, such that u->data = v->data.    Now store (v,u) in your map.  {Note, doesn't matter where you set the u->next, just leave the new nodes dangling in the air}  2) Now go through your original linked list again, and visit every v.  Now do 3 lookups in the map for every in your original linked list.... Look up v to get u. Look up v->next to get whatever, call it x Look up v->random to get whatever, call it y  Now set u->next = x, u->random=y."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can we use extra data structure, like map something, it makes big difference in terms of difficulty."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct list* copyll(struct *list) \n{ \n struct list *head, *fptr, *sptr, *ffptr, temp; \n  \n while(list) \n { \n  temp = (struct list *) malloc(struct list); \n  temp->random = NULL; \n  temp->next = NULL; \n  if(!head) \n  { \n    head = sptr = temp;  \n  }else \n  { \n   sptr->next = temp; \n   sptr = temp; \n  } \n  sptr->data = list->data; \n  list = list->next;  \n } \n  \n fptr = ffptr = head; /* new list */ \n temp = list; /* old list */ \n  \n while(temp) \n { \n  sptr = temp; \n  fptr = head; \n  while (sptr!= NULL && temp->random->data != sptr->data) \n  { \n   sptr = sptr->next; \n   fptr = fptr->next; \n  } \n  ffptr->random = fptr; \n  ffptr = ffptr->next; \n  temp = temp->next; \n } \n return head; \n} \n \n/* Complexity is high when setting random pointers */"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Clone linked list having random references between nodes Random references don't loop nodes. This solution is in JavaScript for Demo Purposes only. It is unacceptable JavaScript structure since it creates loops between objects in memory  and JavaScript is not capable to GC it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct Node { \n    Node* next; \n    Node* random; \n    int value; \n}; \n \nNode* copy(Node* head) { \n    if (!head) return NULL; \n \n    // copy the list \n    Node* cur = head; \n    while (cur) { \n        Node* node = new Node(); \n        node->value = cur->value; \n        node->random = NULL; \n        node->next = cur->next; \n        cur->next = node; \n        cur = node->next; \n    } \n \n    // update random correctly \n    cur = head; \n    while (cur) { \n        cur->next->random = cur->random ? cur->random->next : NULL; \n        cur = cur->next->next; \n    } \n \n    // split list     \n    Node* newhead = head->next; \n    Node* newcur = newhead; \n    cur = head; \n    while (cur) { \n        cur->next = newcur->next; \n        cur = cur->next; \n        newcur->next = cur ? cur->next : NULL; \n        newcur = newcur->next; \n    } \n     \n    return newhead; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6139456847347712","download_status":"DOWNLOAD_DONE","votes":"4","answersCount":"27","title":"Microsoft Excel numbers cells as 1...26 and after that AA, AB.... AAA, AAB...ZZZ and so on. Given a number, convert it to that format and vice versa.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"outputstr=\"\"; if(number<26)  print number else  while(number!=0)  {  x=number%26  //0 is A ,1 is B and so on   outputstr=outputstr+\"x\"      //string append  number=number/26  }  from string to number: example: xyz z*26^0+y*26^1+x*26^2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Basically converting base-10 input to base-26 on symbols {A, B, ..., Z}  C++:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"char* charToInt(unsigned int p) {  char output[1024];  memset(output,0, 1024);  int i = 0;   while(p) {   int x = p % 26;   char c = (char)((int('A') - 1  + x));   output[i] = c;   i++;   p = p / 26;   }  return strrev(output); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In Python:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \n#include  \n#include  \n \nusing namespace std; \ndouble convertletters(string cur) \n{ \n        vector letters; \n        for (unsigned int i = 0; i < 26; i++) \n        { \n                letters.push_back('A'+i); \n        } \n        map letmap; \n        for (int i =1; i < letters.size()+1; i++) \n        { \n                pair temp(letters[i-1],i); \n                letmap.insert(temp); \n        } \n \n        letters.clear(); \n \n        double Num = 0; \n        double sum = 0; \n        double power = 0; \n        for (int i = cur.size()-1; i > -1; i--) \n        { \n                Num = letmap[cur[i]] * pow(26,power); \n                sum+=Num; \n                power++; \n        } \n \n        cout<< retvals; \n       vector letters; \n        for (unsigned int i = 0; i < 26; i++) \n        { \n                letters.push_back('A'+i); \n        } \n        double power = 1; \n        double temp = 26; \n        while (temp < cur) \n        { \n                temp = temp*26; \n                power++; \n        } \n        power--; \n \n        double div_count=0; \n        double powholder = pow(26,power); \n        bool changed = false; \n        while (power > 0) \n        { \n                if (changed) \n                { \n                        powholder = pow(26,power); \n                        changed = false; \n                } \n                if (cur > powholder) \n                { \n                        cur = cur - powholder; \n                        div_count++; \n                } \n                else \n                { \n                        changed = true; \n                        retvals.push_back(letters[div_count-1]); \n                        div_count = 0; \n                        power--; \n                } \n        } \n        retvals.push_back(letters[cur-1]); \n        for (int i = 0; i < retvals.size() ; i++) \n        { \n                cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"and"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static String getColRowName(int num){ \n  String result = \"\"; \n  if ( num <= 26)return String.valueOf(num); \n  num = num-1; \n  while(num != 0){ \n   int a =  'A' + (num%26); \n   result = String.valueOf((char)a) + result; \n   num= num/26; \n  } \n  return result; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think of it this way: \n1-26 (26 of them) \nAA-ZZ (26*26 of them) \nAAA-ZZZ (26*26*26 of them) \n \nSo it's relatively easy once we figure out which \"level\" we are in. \nWe do that with several variables: \n(1) offset - it keeps getting multiplied by 26 in each iteration (eg. 26*26*26 for AAA-ZZZ) \n(2) numDigits - number of characters in the current \"level\" (eg. 3 for AAA-ZZZ) \nIn each iteration, we first decrement the number by the previous offset, then multiply offset by 26 and check if number-1 is now less than the new offset. \nFor example, when number is 702, we first decrement it by offset (26) and get 676. Now 676-1=675, which is less than the next offset 26*26=676. \nSo the task becomes converting 675 to a 2 digit string, which is base arithmetic and you should get ZZ. \n \nIt should be relatively simple to do the reverse of finding out the index given the string. \n \nclass ExcelColumn { \n \n public static String getColumnName(int num){ \n  if(num<=26) \n   return \"\" + num; \n  int offset = 26; \n  int numDigits = 1; \n  while(true) { \n   num -= offset; \n   numDigits++; \n   offset *= 26; \n   if(num - 1 < offset) { \n    return helper(num-1, numDigits); \n   } \n  } \n } \n \n public static String helper(int num, int numDigits) { \n  if(numDigits == 0) \n   return \"\"; \n  int digit = num%26; \n  return helper(num/26, numDigits-1) + (char)(digit + 'A'); \n } \n \n \n public static void main(String[] args) { \n  System.out.println(getColumnName(Integer.parseInt(args[0]))); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static String numToStr(int n) { \n    String str = (char) ('a' + n % 26) + \"\"; \n    n = n / 26; \n    while (n != 0) { \n        str = (char) ('a' + (n - 1) % 26) + str; \n        n = (n - 1) / 26; \n    } \n    return str; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"string getExcelCode(int n) \n{ \n //int n=708; \n //int n=691; \n string str; \n \n while(n!=0) \n { \n  int char1=n%26; \n \n  // to make sure it works for 'z' \n  if(char1==0) \n  { \n   char1=26; \n  } \n   \n  n-=char1; \n  str+=char1+'A'-1; \n  n=n/26; \n } \n int start=0, end=str.length()-1; \n //reverse the string to display in correct order \n while(start"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java Code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Practice93 {  public static void main(String[] args){   System.out.println(GetExcelColumnName(26*26+1));   System.out.println(getColumnNumber(\"ZA\"));  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"char []a=new char[26]{ 'Z', 'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y' }; \n \nstring  Result(int n) \n{ \n            if (n < 27 && n > 0) \n                return n.ToString(); \n            else if (n > 0) \n            { \n                if (n % 26 == 0) \n                    return myfun(n / 26 - 1) + a[n % 26]; \n                else \n                    return myfun(n / 26) + a[n % 26]; \n            } \n        } \n} \npublic string myfun(int n) \n{ \n if (n / 26 == 0) \n                return a[n % 26].ToString(); \n        else \n                return myfun(n / 26) + a[n % 26]; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please test the code and reply if there are any mistakes"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public String getExcelStr(int n) { return n==0?\"\":getExcelStr(n/26) + Character.toString((char)((int)'A'+n%26-1)); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int getNumber(String str) {  return str.length()==0?0:(int)((str.charAt(0)-'A'+1) * Math.pow(26,str.length()-1) + getNumber(str.substring(1))); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class ExcelLetters { \n  public static void main(String[] args) { \n    int i = Integer.parseInt(args[0]); \n    System.out.println(convert(i)); \n  } \n  public static String convert(int i) { \n    String s; \n \n    // Least significant character is different (0 -> A, 25 -> Z) \n    s = Character.toString((char)(i % 26 + (int)'A')); \n    i /= 26; \n    while (i > 0) { \n      s = (char)(i%26 + (int)'A' - 1) + s; \n      i = i / 26; \n    } \n    return s; \n  } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A = []   def convertDigit2Letter (d):  return chr(ord('A') + d)  def convertNumber2Letters (x):  x = x - 1  while x > 0:   r = x % 26   x = x / 26    A.append(r)  l = len(A)  s = \"\"  while (l > 0):   digit = A.pop()   print str(digit)   if (l == 1):    c = convertDigit2Letter(digit)    print str(c)    s += str(c)   else:    c = convertDigit2Letter(digit - 1)    print str(c)    s += str(c)   l = l - 1  return s  letters = convertNumber2Letters(27) print str (letters)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4922014007558144","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"2","title":"Design question: Say you have hacked in to a network and can deploy your bot thousands of machines, how would you design your bot so that all the machines work together to download a website, say wikipedia. There should be load balancing and a page should be queryable given its URL.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question states a bot, so it should not a vanilla spider.   1. We should be familiar with the target site to be downloaded. That would help in classifying/distributing the work amongst the bots. 2. There'd be a control bot in the network which distributes the payload to other bots. Any bot can become a control bot incase the current actor goes down. 3. The webpages downloaded with remain on the client. Only metadata on what is downloaded will be sent to the control bot. The subsequent querying can use this to route the request to the correct bot location. 4. The network activity should be covert. So worker bots will operate in small groups to avoid network detection. Also the payload should be to picked from different sections of the website to make it look more normal."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"I'll program my bots to access my server at random time of the day, so I'll distribute instructions about planned coordinated attack during a day to all my bots, so the next day at some scheduled time they all at once start to read Wikipedia, I would prefer to make donation to Wikipedia actually."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5890898499993600","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"9","title":"Given a matrix of letters and a word, check if the word is present in the matrix. E,g., suppose matrix is: a b c d e f z n a b c f f g f a b c and given word is fnz, it is present. However, gng is not since you would be repeating g twice. You can move in all the 8 directions around an element.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"(1) Create a Coord class that represents a (row, col) pair (2) Iterate through the matrix and store the occurrences of each character in a HashMap> (3) Define a recursive method find(String word, HashSet seen, int index, Coord prev). The HashSet seen represents the coordinates we have seen already (null initially). The index is the current index of the word we want to find (0 initially). The Coord prev is the previous Coord (null initially). In each recursive call, we want to look up all possible coordinates for the character at current index. If no coordinates is found then return false. Otherwise iterate through the coordinates from the map and perform recursive call.  More details in the code below, but I doubt this is the proper solution as it requires too much code."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just DFS from every starting position looking for a matching word along valid paths and as you visit nodes/letters, capitalize them ( c = c + 'A' - 'a') to mark them as visited, and decapitalize them when unwinding."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I guess there is need to DFS but we can start at all letters and see if there exist a valid suffix with that letter as the starting point if its true we can search a valid prefix attached to it.. we can mark all the suffix letters as visited but not the prefix searched ones.. this will not invalidate other possible cases"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. The entire alphabet set is of size 26 ( a-z) . Create a hash map of size 26 and parse through the matrix and store the frequency. Cost : O(row*col) 2. Iterate over the search string and subtract the freq. in the hash map as you iterate over each character. If at any point the frequency goes -ve, then the word doesn't exist.  Running time : O(row*col) Space: Constant"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For each node, store its 8 neighbor nodes, the rest is trivial"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here is my code ... hope it helps i have tested the given conditions"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5998719358992384","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"7","title":"Given a matrix consisting of 0's and 1's, find the largest connected component consisting of 1's.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Iterate through items of matrix: row * column If point is not part of any visited area then start searching for new area  Create margin collection having single starting point. Mark starting point as visited in matrix. Iterate through margin points. Populate new margin with points accessible from current margin points, in order to avoid duplicates, mark new margin points as visited in matrix immediately. Search for new margins till no accessible points exist.   JavaScript Implementation."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class LargestConnectedInMatrix { \n \n    public static void main(String... args) { \n        int[][]  k = new int[][] { \n                {0, 0, 1}, \n                {0, 1, 1}, \n                {0, 0, 1}}; \n        new LargestConnectedInMatrix().getLargestConnectedMatrix(k); \n    } \n \n    public int getLargestConnectedMatrix(int[][] arr) { \n        boolean [][] visited = new boolean [arr.length][arr[0].length]; \n \n        for (int l = 0; l < arr.length; ++l) \n            for (int m = 0; m < arr.length; ++m) \n                visited[l][m] = false; \n \n        Set>> s = new HashSet<>(); \n \n        for (int x = 0; x < arr.length; ++x) { \n            for (int y = 0; y < arr.length; ++y) { \n                if (visited[x][y]) continue; \n                List> current = new ArrayList<>(); \n                List> next = new ArrayList<>(); \n                int code = arr[x][y]; \n                next.add(new Pair(x, y)); \n                while (!next.isEmpty()) { \n                    Pair p = next.remove(0); \n                    current.add(p); \n                    int i = p.getFirst(); \n                    int j = p.getSecond(); \n                    visited[i][j] = true; \n \n                    if (i-1 >= 0 && arr[i-1][j] == code && !visited[i-1][j]) \n                        next.add(new Pair(i-1, j)); \n                    if (i+1 < arr.length && arr[i+1][j] == code && !visited[i+1][j]) \n                        next.add(new Pair(i+1, j)); \n                    if (j-1 >= 0 && arr[i][j-1] == code && !visited[i][j-1]) \n                        next.add(new Pair(i, j-1)); \n                    if (j+1 < arr.length && arr[i][j+1] == code && !visited[i][j+1]) \n                        next.add(new Pair(i, j+1)); \n \n                } \n \n                s.add(current); \n            } \n        } \n \n        for (List> l : s) { \n            System.out.println(l); \n        } \n        return -1; \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Union Find algorithm would be much better than brute force."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"way too much code guys way too much code do a simple if(a[i][j]==1) a[i][j] = max(a[i-1][j],a[i][j-1) + 1 if its 4 connected  if its 8 connect then you need Union find both will result in O(n^2) and will be better than brute force because checking viisted nodes repeatedly is complex"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"way too much code guys way too much code do a simple if(a[i][j]==1) a[i][j] = max(a[i-1][j],a[i][j-1) + 1 if its 4 connected  if its 8 connect then you need Union find both will result in O(n^2) and will be better than brute force because checking viisted nodes repeatedly is complex"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Define the terms/phrases used in the question please!"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4713484755402752","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"Given two arrays of sorted integers, merge them keeping in mind that there might be common elements in the arrays and that common elements must only appear once in the merged array.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"merge(int a[], int m,int b[], int n, int c[]) \n{ \n int *aptr=a, *bptr=b, *cptr=c; \n while(aptr <= (a+m) && bptr <= (b+n)) \n { \n  if(*aptr <= *bptr) \n  { \n   *cptr = *aptr++; \n   while((aptr <= a+m) && *cptr == *aptr) \n    aptr++; \n   while((bptr <= b+n) &&*cptr == *bptr) \n    bptr++; \n   cptr++; \n  }else \n  if (*aptr < *bptr) \n  { \n   *cptr = *aptr++; \n   while(aptr <= (a+m) && *captr == *(aptr)) \n    aptr++; \n   cptr++; \n  }else \n  if (*bptr < *aptr) \n  { \n   *cptr = *bptr++; \n   while(bptr <= (b+n) && *cptr == *(bptr)) \n    bptr++; \n   cptr++; \n    \n  } \n } \n  --cptr; \n  if( aptr > (a+m)) \n   while(bptr <= (bptr+n)) \n   { \n    if (*cptr != *bptr ) \n     ++*cptr = *bptr; \n    bptr++;  \n   } \n  if (bptr > (b+n)) \n   while (aptr <= (aptr+m)) \n   { \n    if (*cptr != *aptr ) \n     ++*cptr = *aptr; \n    aptr++; \n   } \n/* print the Array C till cptr */ \n} \n \nWorst case TC : (m+n) SC : O(m+n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use TreeSet"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5729456584916992","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"9","title":"Given a normal binary tree, write a function to serialize the tree into a string representation (returning the string), and also a function to deserialize a serialized string into the original binary tree.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"/** my implementation */ \n \n#include  \n#include  \n#include  \n \nstruct BinTreeNode { \n    int val; \n    BinTreeNode *left, *right; \n \n    BinTreeNode() {} \n \n    BinTreeNode(int v, BinTreeNode *l = NULL, BinTreeNode *r = NULL): \n        val(v), left(l), right(r) \n    {} \n}; \n \nvoid bin_tree_to_str(BinTreeNode *root, std::string& str) \n{ \n    if (root == NULL) return; \n \n    std::deque que; \n    BinTreeNode *p; \n \n    que.push_back(root); \n \n    str.append(std::to_string(root->val)); \n \n    while (!que.empty()) { \n        //undef NDEBUG \n        //std::cout << \"curr size: \" << que.size() << std::endl; \n \n        p = que.front(); \n        que.pop_front(); \n \n        //undef NDEBUG \n        //std::cout << \"size after pop_font: \" << que.size() << std::endl; \n \n        //undef NDEBUG \n        //std::cout << p->val << std::endl; \n \n        //leaves \n        if (p->left == NULL && p->right == NULL) continue; \n \n        str.append(\"L\"); \n \n        if (p->left) { \n            que.push_back(p->left); \n            str.append(std::to_string(p->left->val)); \n        } else { \n            str.append(\"#\"); \n        } \n \n        str.append(\"R\"); \n \n        if (p->right) { \n            que.push_back(p->right); \n            str.append(std::to_string(p->right->val)); \n        } else { \n            str.append(\"#\"); \n        } \n    } \n \n    std::cout << str << std::endl; \n} \n \nBinTreeNode *str_to_bin_tree(const std::string& str) \n{ \n    std::deque que; \n    size_t i, j, l; \n \n    for (i = 0, j = 0, l = str.size(); \n         i < l; \n         /* void */) { \n        while (str[i] != 'L' && i < l) i++; \n \n        std::string ss = str.substr(j, i - j); \n \n        que.push_back(ss); \n \n        if (i == l) break; \n \n        j = i + 1; \n        i++; \n \n        while (str[i] != 'R' && i < l) i++; \n \n        ss = str.substr(j, i - j); \n \n        que.push_back(ss); \n \n        j = i + 1; \n        i++; \n    } \n \n    std::deque que2; \n    std::string str_val; \n    BinTreeNode *root, *left, *right; \n    BinTreeNode *temp; \n \n    str_val = que.front(); \n    que.pop_front(); \n \n    root = temp = new BinTreeNode(std::stoi(str_val)); \n \n    que2.push_back(temp); \n \n    //while (!que2.empty()) { \n    while (!que.empty()) { \n    //for (i = 0, l = (que.size() - 1) / 2; i < l; i++) { \n        temp = que2.front(); \n        que2.pop_front(); \n \n        str_val = que.front(); \n        que.pop_front(); \n \n        if (str_val == \"#\") left = NULL; \n        else left = new BinTreeNode(std::stoi(str_val)); \n \n        str_val = que.front(); \n        que.pop_front(); \n \n        if (str_val == \"#\") right = NULL; \n        else right = new BinTreeNode(std::stoi(str_val)); \n \n        temp->left = left; \n        temp->right = right; \n \n        if (left) que2.push_back(left); \n        if (right) que2.push_back(right); \n    } \n \n    return root; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"two different ways: 1) write with parentheis : root(left subtree string)(right subtree string) 2) write in-order sequence and (post-order or pre-order) sequence"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"When serializing a binary tree, treat it as a complete binary tree (not a full binary tree), like adding NULL pointer to a single-child node (not really added).  When deserializing a string to a binary tree, first extract real contents (BinTreeNode.val) into a assistant double-ended queue, by removing L or R in between. And then constructing the binary tree, using another double-ended queue to maintain parents/children relationship."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Compared to the implementation by Preorder & Inorder traversal, the level-order implementation use more assistant storage. When the tree is sparse, possibilities are more memory are wasted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's the tested code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void serialize(node *head, string &serial) \n{ \n if(head == 0) \n { \n  serial += \"#,\"; \n  return; \n } \n serial += to_string(head->value)+\",\"; \n serialize(head->left,serial); \n serialize(head->right,serial); \n} \nvoid deserialize(node * &head, string &serial, int &index) \n{ \n  \n int fou = serial.find(\",\",index); \n string curr_val = serial.substr(index,fou - index); \n index = index + curr_val.length() + 1; \n \n if(curr_val == \"#\") \n { \n  head = 0; \n  return; \n } \n else \n { \n   \n  head = new node; \n  //assuming values here are integers \n  head->value = atoi(curr_val.c_str()); \n  deserialize(head->left,serial,index); \n  deserialize(head->right,serial,index); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can use BFS to serialize the tree. Then, you simply need to insert the values in order to get the same exact tree. The order is: \"Root R  L RR RL LR LL RRR RRL RLR RLL LRR LRL...\"  I implemented a simple BST with \"insert\" only."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void serialize(Node root, OutputStreamWriter out){ \n if(root==null){ \n  out.write(??|??); \n  return; \n } \n \n out.write(root.data+??????); \n serialize(root.left); \n serialize(root.right); \n} \n \npublic static Node deserialize(InputStreamReader reader) throw IOException{ \n char c = (char)reader.read(); \n if(c==??|??){ \n  return null; \n } \n Node n = new Node(c); \n n.left=deserialize(reader); \n n.right=deserialize(reader); \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5119108714594304","download_status":"DOWNLOAD_DONE","votes":"-2","answersCount":"3","title":"Given a normal binary tree, write a function to serialize it into a string representation (returning a string), and also a function to deserialize the string into the original binary tree","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Serialize:  Do BFS traversal  store the nodes (character) in the string buffer as they are explored  Deserialize:  In the given string buffer:   root -> first element   left child -> 2i   right child -> 2i+1   // i is the index as you travel through the buffer. So every index will have a left and a      right child as defined above."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Find the Inorder and pre order traversal of the tree and store it as a string. Use the same inorder and pre order traversal to create the binary tree."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6196366774632448","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"10","title":"A professor wants to see if two students have cheated when writing a paper. Design a function : hasCheated(String s1,String s2, int N) that evaluates to true if two strings have a common substring of length N. Additional question after implementation. Assume you don't have the possibility of using String.contains() and String.substring(). How would you implement this?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"It is important to distinguish between substring or subsequence. If it is substring and we can't use any of the std libraries then we can use any of the substring search algorithms: KMP, Rabin-Karp etc...   If it is subsequence search then we use the classic LCS algorithm as posted above."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would use (LCS) longest common subsequence which is a dynamic programming approach. Its running time is s1.size*s2.size.  The idea is like this: X = x_1 x_2 ... x_m Y = y_1 y_2 ... y_n if( x_m == y_n) then find LCS of x_(m-1) & y_(n-1) and concat x_m to it. if( x_m != y_n) then find max LCS of { (x_m & y_(n-1)) , (x_(m-1) &y_n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.HashSet; \nimport java.util.Set; \n \n \npublic class FindSUbStringOfSomeInputLength { \n \n  \n public static void main(String[] args) { \n  // TODO Auto-generated method stub \n  FindSUbStringOfSomeInputLength find=new FindSUbStringOfSomeInputLength(); \n  String s1=\"adsfgdsfjhgdsahjagjhds4234gjagsadsasdasdhj\"; \n  String s2=\"sdfsadfasqadcxzxdfa4234sdas\"; \n  int N=4; \n  find.hasCheated(s1,s2,N); \n } \n \n private boolean hasCheated(String s1, String s2, int n) { \n  Set set=new HashSet(); \n   \n  char stringFirst[]=s1.toCharArray(); \n  char stringSecond[]=s2.toCharArray(); \n  int arrayLength=stringFirst.length; \n  boolean flag=false; \n   \n  for(int i=0;i<=arrayLength-n;i++) \n  { \n   set.add(new String(stringFirst,i,n)); \n  } \n   \n  arrayLength=stringSecond.length; \n   \n  for(int i=0;i<=arrayLength-n;i++) \n  { \n   String s=new String(stringSecond,i,n); \n   if(set.contains(s)) \n   { \n    System.out.println(\"Cheated : \"+s); \n    flag=true; \n   } \n  } \n   \n  return flag; \n   \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think maybe suffix tree can be used here"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i1 represents index of str1 and i2 represents the index of str2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why cant you use any of the std libraries if its referred to substring?  how about this approach?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Take a sliding window of length N from string1 and stick it to a set, and take a sliding window of length N from string2 and check against it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Professor2 { \n \n public static void main(String[] args) { \n   \n  String s1=\"asdf\"; \n  String s2=\"basdasds\"; \n  int n=4; \n  Professor p=new Professor(); \n   \n  if(p.hasCheated(s1, s2, n)) \n  { \n   System.out.println(\"copy\"); \n   return; \n  } \n   \n  System.out.println(\"not copied\"); \n \n } \n \n public boolean hasCheated(String s1,String s2, int N) \n { \n   \n  ArrayList al=new ArrayList(); \n  ArrayList bl=new ArrayList(); \n   \n  al.addAll(getData(s1,N)); \n  bl.addAll(getData(s2,N)); \n   \n  return al.retainAll(bl); \n   \n } \n  \n public List getData(String s,int n) \n { \n  ArrayList temp=new ArrayList(); \n  temp.clear(); \n  String myStr=Arrays.toString(s.split(\"(?<=\\\\G.{4})\")); \n  //System.out.println(myStr); \n   \n  Scanner sc=new Scanner(myStr).useDelimiter(\",\"); \n  while(sc.hasNext()) \n  { \n   String my=sc.next(); \n  // my.replaceAll(\"\\\\w\", \"\"); \n   //System.out.println(my); \n   temp.add(my); \n  } \n     \n  return temp; \n } \n  \n} \n \nOut Put: \nStudent Cheated"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Prof { \n \n public static void main(String[] args) { \n  // TODO Auto-generated method stub \n \n  String s1=\"asdf\"; \n  String s2=\"basdasdsasdf\"; \n  int n=4; \n  Prof p=new Prof(); \n   \n  if(p.hasCheated(s1, s2, n)) \n  { \n   System.out.println(\"Student Cheated \"); \n   return; \n  } \n   \n  System.out.println(\"Not Cheated\"); \n   \n   \n \n } \n \n  \n  \n public boolean hasCheated(String s1,String s2, int N) \n { \n  boolean b=true; \n  ArrayList al=new ArrayList(); \n  ArrayList bl=new ArrayList(); \n   \n  al.addAll(getData(s1,N)); \n  bl.addAll(getData(s2,N)); \n  al.retainAll(bl); \n  if(al.size()==0) \n  { \n   b=false; \n  } \n  //System.out.println(b); \n  return b; \n   \n } \n  \n public List getData(String s,int n) \n { \n  ArrayList temp=new ArrayList(); \n  temp.clear(); \n  String myStr=Arrays.toString(s.split(\"(?<=\\\\G.{4})\")); \n  //System.out.println(myStr); \n   \n  Scanner sc=new Scanner(myStr).useDelimiter(\",\"); \n  while(sc.hasNext()) \n  { \n   String my=sc.next().replaceAll(\"\\\\W\", \"\"); \n     \n   //System.out.println(my); \n   temp.add(my); \n  } \n   \n   \n  return temp; \n } \n  \n \n} \n \nOut Put: \nStudent Cheated"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.io.InputStreamReader; import java.util.Scanner; public class Cheaters {      String s1,s2;     int n;     Scanner x;            public static void main(String[] args) throws Exception {        Cheaters c=new Cheaters();        System.out.println(\"Student\"+\" \"+c.find()+\" \"+\"in exam\");     }       String find() throws Exception     {             String result=\"\";         x=new Scanner(new InputStreamReader(System.in));         System.out.println(\"enter first string\");         s1=x.nextLine();         System.out.println(\"Enter size of n\");         n=Integer.parseInt(x.nextLine());         System.out.println(\"enter second  string\");         s2=x.nextLine();         int count=0,t=0;         for(int i=0;i        {             if(s1.charAt(i)==s2.charAt(i))             {                 count++;                 if(count==n)                 {                     t=1;                     break;                 }             }             else             {                 count=0;             }            }         if(t==1)         {             result=\"cheated\";         }         else         {             result=\"did not cheat\";         }         return result;               } }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5683255621713920","download_status":"DOWNLOAD_DONE","votes":"3","answersCount":"10","title":"Given a list of 4 billion integers, find an integer not in the list using 4MB of memory. (interview was in Java)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"how about the use of a bitset?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If you are only restricted to sort in memory then bit arrays would be the way to go (4MB = ~32 million bits), do multiple passes for range 0-32, 32-64 etc...   Otherwise, use external sort."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If there are no duplicates, then we can create array of buckets. The  array size is 1M, and each element is a 12-bit integer count. Then scan the numbers, for each number N, increase the count in the (N>>12)'th bucket. At the end if the count in the bucket is less than 2^12-1, then  the missing number is in this bucket.  The rest is easy - scan the numbers again, discard the numbers not in the bucket, for the number is this bucket, use bitmap to indicate if the number is visited."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You have to clarify if the integer is 32 bit or 64 bit. For 64 bit case, it is actually easier to generate an integer randomly. Since you have 4 billion = 2^32 integer, if you generate a random 64 bit integer, the chance that it is unique is (2^64 - 2^32) / 2^64 = 1.0 (with good precision)  So the question should be, having 4 billion 32 bit integers, how do you know if one of them is repeated?  This is what came to my mind.  Let's assume you have 4 MB = 2^20 integer words. Define an array of length 2^20 of integers. Each value (unsigned) can hold up to 2^32  Round A) Now read the stream of numbers (4 billion): For number X Let Y = X % 2^20. and array[Y] = array[Y] + 1  After reading all, go through the array and find a \"Y\"with array[Y] < 2^12  Round B) We know something about the missing number. The 20 LSB are same as Y. Clear memory except for \"Y\" and make another array of length 2^12. Read all X again. For each X, if X%2^20 == Y, increase the memory location at array[Z].  Round C) For through array Z and find the location where \"array[Z] = 0\". Report Z * 2^20 + Y as the missing number."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"so insert all elements into the bitset after that iterate through the bitset until you find a bit which is set to 0...that means the number was not int the list..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Its simple case of using bloom filter . And bloom filter are designed for this purpose only check wiki for details  Many url shorting websites such as bitly use this technique ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sort in place, iterate and find."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the constraints are that all the numbers are unique and because there is only 1 integer missing.  Step 1. Take an integer -> temp1=0. Step 2. Iterate through the array and then keep xor-ing each item with temp1. Step 3. Take another integer -> temp2=0; Step 4. Iterate till 4 billion / limit and keep xor-ing each item with temp2. Step 5 . Xor temp1 and temp2 to get the missing element.  If however, unique elements aren't guaranteed or there are more than 1 elements missing then, we can use a bit vector. In the absence of STLs ,we can use an array of integers as a bit stream and set the bit appropriately and scan through this array to find the missing elements."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"well i would just scan through to find the max and add 1 to it :)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4901629824335872","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"3","title":"Write atof in Java, which converts a string representation of a float (like \"342.18E-10\") to an actual float without using any built-in parsing functions.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Reads from arguments:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class AtoF { \n String str; \n float result; \n  \n public AtoF(String s) throws Exception{ \n  this.str = s.trim(); \n  result = solve(str); \n } \n  \n public float solve(String str) throws Exception{ \n  int indexOfE = str.indexOf('E'); \n  if(indexOfE == -1) \n   indexOfE= str.indexOf('e'); \n  if(indexOfE == -1){ \n   return withoutE(str); \n  }else{ \n   return (float) (withoutE(str.substring(0, indexOfE))* \n     Math.pow(10, withoutE(str.substring(indexOfE+1)))); \n  } \n } \n  \n \n private float withoutE(String s) throws Exception{ \n  if(s.charAt(0) == '-'){ \n   return -withoutE(s.substring(1)); \n  } \n  int indexOfPeriod = s.indexOf('.'); \n  if(indexOfPeriod == -1){ \n   return makeInt(s); \n  }else{ \n   float beforePeriod = makeInt(s.substring(0,indexOfPeriod)); \n   float afterPeriod = makeInt(s.substring(indexOfPeriod+1)); \n   float temp = afterPeriod; \n   int countDigit = 0; \n   while(temp > 10){ \n    countDigit ++; \n    temp /=10; \n   } \n   countDigit++; \n    \n   return (float)(beforePeriod + Math.pow(10, -countDigit)*afterPeriod); \n  } \n   \n } \n  \n \n private float makeInt(String s) throws Exception{ \n  if(s.length() == 0) \n   return 0; \n  float res = 0f; \n  for (int i = 0; i < s.length(); i++) { \n   // for example 234 = ((2*10)+3)*10+4; \n   res = res*10 + makeDigit(s.charAt(i)); \n  } \n  return res; \n } \n  \n  \n private float makeDigit(char charAt) throws Exception { \n  switch(charAt){ \n  case '0': \n   return 0; \n  case '1': \n   return 1; \n  case '2': \n   return 2; \n  case '3': \n   return 3; \n  case '4': \n   return 4; \n  case '5': \n   return 5; \n  case '6': \n   return 6; \n  case '7': \n   return 7; \n  case '8': \n   return 8; \n  case '9': \n   return 9; \n  default: \n   throw new Exception(); \n     \n  } \n } \n \n public static void main(String[] args) throws Exception { \n  AtoF a = new AtoF(\"3.2\"); \n  System.out.println(a.result); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hi, here a c++ solution...im not sure what you mean by built-in in function..."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6241652616200192","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"13","title":"Given a Binary Tree (balanced or not) write a method that transforms the tree in a degenerate tree (basically a data structure like a sorted linked list where each node has the left child null) and returns the new root. This must be made in place, no external memory usage is allowed.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"just a variant question of  converting it into singly linked list"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"recursive, degenerate left subtree,hook current root to it, root.'s right node is degenerated right subtree"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the given tree is a BST,right?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the given tree is a BST,right?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class node{ \npublic: \n int key; \n node* left; \n node* right; \n node(int key) { \n  this->key = key; \n  left = right = 0; \n } \n}; \n \nnode *degenerate(node *root) { \n if (!root) return 0; \n node *newroot = 0; \n for(newroot = root;newroot->left;newroot = newroot->left); \n convertToList(root); \n return newroot; \n} \n \nvoid convertToList(node *p) { \n node *leftHighest = 0; \n if (p->left) { \n  for(leftHighest = p->left;leftHighest->right;leftHighest = leftHighest->right); \n  convertToList(p->left); \n  leftHighest->right = p; \n  leftHighest->left = 0; \n } \n  \n node *rightLowest = 0; \n if (p->right) { \n  for(rightLowest = p->right;rightLowest->left;rightLowest = rightLowest->left); \n  convertToList(p->right); \n  p->right = rightLowest; \n  p->left = 0; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public Node convertToLinkList() { \n  convertToLinkList(mRoot); \n  Node head = mRoot; \n  while (head.mLeft != null) { \n   head = head.mLeft; \n  } \n  return head; \n } \n \n Node last = null; \n \n public void convertToLinkList(Node root) { \n  if (root == null) { \n   return; \n  } \n \n  convertToLinkList(root.mLeft); \n  root.mLeft = last; \n  if (last != null) { \n   last.mRight = root; \n  } \n  last = root; \n  convertToLinkList(root.mRight); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"some c# code. Suppose it works ok."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"static class Node { \n  int value; \n  Node left; \n  Node right; \n   \n  public Node() {} \n  public Node(int value, Node left, Node right) { \n   this.value = value; \n   this.left = left; \n   this.right = right; \n  } \n } \n  \n static class Result { \n  Node head; \n  Node tail; \n } \n \n static Result transform(Node root) { \n  if (root == null) return null; \n  Result result = new Result(); \n  result.head = root; \n  result.tail = root; \n  if (root.left != null) { \n   Result t = transform(root.left); \n   result.head = t.head; \n   t.tail.right = root; \n   root.left = null; \n  } \n  if (root.right != null) { \n   Result t = transform(root.right); \n   root.right = t.head; \n   result.tail = t.tail; \n  } \n  return result; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"/* BST to link List */ \n \nstruct node_t{ \n    int data; \n    struct node_t *left; \n    struct node_t *right; \n} \n \nnode_t *mergeLists(node_t *left, node_t *node, node_t *right) \n{ \n    assert(node != NULL); \n    node_t *head; \n     \n    /* merge left and node */ \n    if(left!=NULL){ \n        head = left; \n        while(left->next != NULL){ \n            left = left->right; \n            left->right = NULL; \n        } \n        left->next=node; \n    }else{ \n        head = node; \n    } \n     \n    /* merge node and right */ \n    node->next=right; \n    return head; \n} \n \nnode_t *convertToList(node_t *node) \n{ \n    if(NULL == node) \n        return NULL; \n         \n    node_t *left = convertToList(node->left); \n    node_t *right = convertToList(node->right); \n     \n    return mergeLists(left, node, right); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"/* BST to Double Link List */ \n \nstruct node_t{ \n    int data; \n    struct node_t *left; \n    struct node_t *right; \n} \n \nnode_t *mergeDLists(node_t *left, node_t *node, node_t *right) \n{ \n    assert(node != NULL); \n    node_t *head; \n     \n    /* merge left and node */ \n    if(left!=NULL){ \n        head = left; \n        while(left->right != NULL){ \n            left = left->right; \n        } \n        left->right = node; \n        node->left = left; \n    }else{ \n        head = node; \n    } \n     \n    /* merge node and right */ \n    node->right=right; \n    right->left = node; \n    return head; \n} \n \nnode_t *convertToDList(node_t *node) \n{ \n    if(NULL == node) \n        return NULL; \n         \n    node_t *left = convertToList(node->left); \n    node_t *right = convertToList(node->right); \n     \n    return mergeLists(left, node, right); \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5729940548878336","download_status":"DOWNLOAD_DONE","votes":"-6","answersCount":"0","title":"Idea student"}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6243918479884288","download_status":"DOWNLOAD_DONE","votes":"-5","answersCount":"0","title":"Facebook system editar"}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5138995193315328","download_status":"DOWNLOAD_DONE","votes":"-4","answersCount":"0","title":"I idea student for facebook."}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5699432859303936","download_status":"DOWNLOAD_DONE","votes":"-3","answersCount":"5","title":"What are the screen dimensions of various iPhone models?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What kind of stupid question is this?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"consider they are looking for an iOS Developers, it's not a bad question"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"iPhone 1 to iPhone 3gs: 320px width, 640px height iPhone 4 and iPhone 4s: 640px width, 960px height iPhone 5 and iPhone 5s: 640px width, 1136px height"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5726989369475072","download_status":"DOWNLOAD_DONE","votes":"-4","answersCount":"0","title":"What is the screen dimensions of various iPhone models?"}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5671785349513216","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"33","title":"// cat, actor -> T \n// car, actor -> F \n \nbool anaStrStr (string needle, string haystack)  \n{ \n}","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"The below solution is an O(n) time and O(n) space algorithm, although I assumed that the 2 strings can contain any character (that is, the primitive type char in Java - 16-bit Unicode characters). We could conclude that it is O(1) space also, because char can only have 65535 different values, therefore the Map's size is limited (has an upper bound).  1. We first build a map that contains the needle's characters and their number of occurences.  2. At this point we assume that the difference between the needle and the haystack is the length of the needle, since we haven't read yet anything from the haystack. 3. We also create a map for the haystack (similar to that of the needle's map, but we will fill it up along the way, it is empty first).  4. Then we iterate over the haystack and at every character we update the map of the haystack by looking at the last n characters of the haystack (where n is the length of the needle). We can actually do this in constant steps because we just remove an occurence of the character at the current-n position from the haystack's map and add an occurence at the newly read position. Meanwhile, we keep track of the difference between the needle and the current haystack \"window\". If at any point this difference is 0, then we return true (the current part of the haystack is an anagram with the needle). Otherwise, if we reach the end of the haystack without finding an anagram of the needle, then we return false.  It runs in O(n) time because we iterate over the haystack only once and at every step we do constant operations."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I can only come up with a brute force method for this. 1) create a historgram of characters of needle string  2) Starting at the beginning of haystack pick sets of k chars (where k is the length of needle string). If the historgram of this set matches the one for needle then return true  Running time O(kn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A solution in Java making two assumptions: 1) characters are [a-z], 2) no letter repetition. Extending from 1 is easy: just use larger freq and location arrays. Extending from 2 requires location to be an array of list since for each character there might be multiple possible location candidates. It then also requires modification to the algorithm to explore the different possible path, whereas with assumption 1 there is only a single path."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My idea to solve this: 1. either use a array of integer count[] to record the number of each character appears in string 1, or use a hashtable, character as key and count as value. 2. go through string2 from head to tail and lookup the current character in ur array or hashtable. each lookup takes O(1) in either case.  3. once you found a matching character, use it as starting point and check the characters following by. 4. if step 3 fail in middle, reset and start over the search from the next character in string2. This algorithm should take only O(n) time and O(n) space.   I will try come up with code later"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hash the first string, search for hash in second string (for example Rabin-Karp)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's an idea:  1. Define an array of 256 counters for the needle characters. Count the number of occurrences for each character in needle. 2. Define the same array as in (1) for the first needle.length() characters in haystack. 3. Compare between the arrays, if all the counters are equal return true. Otherwise: 4. Iterate from i=needle.length() to haystack.length() and in each iteration: 4.1. Increase the occurrence of haystack.charAt(i) by 1 in the array defined in (2). 4.2. Decrease the occurrence of haystack.charAt(i-needle.length()) by 1 in the array defined in (2). 4.3. Compare the two arrays just like in step (3), if they are equal return true, otherwise continue to the next iteration. 5. If we finished the loop without finding a match then we should return false because there is no needle anagram sub-string in haystack.  Basically, we just check whether for each consecutive needle.length() characters are an anagram of needle by comparing the number of appearances of every character.  Complexity: Assuming the number of characters is constant (256), the run-time complexity is O(n) where n=|haystack|. Space complexity is O(1) (fixed size arrays)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"An O(nk) solution where n=length of haystack and k= length of needle."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Could be done using the above idea O(n*k) but improved to O(n) using hashes."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Build a suffix tree given \"string haystack\" (takes O(N) time and O(N) space). Search is then O(M) time and in-place given \"string needle\" of length M.  This is especially efficient if the haystack is fixed and needle changes frequently."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about following solution. If we check every sub string of haystack to be anagram of needle?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Find substring of the smallest string length in the largest string. 2. Sort the substring and the smallest string and return true if they are equal."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is another O(N) solution with some assumptions:  - The needle string is relatively small compared to haystack string. By relatively small, I mean the difference might go into a few orders of magnitude.  - The needle string is small in size so that operations like toLowerCase and toCharArray are O(1). Also, Arrays.sort operation on the needle would be O(1) then.  The algorithm is, - Store the needle string sorted and lowercase in a hash table. This is O(1) by assumptions above. - Iterate over haystack string, picking a substring equal to needle's length at every iterated index. Sort this substring, convert it to lowercase and search in hashtable. Iterating and getting substrings will be O(N) iterations. Each iteration sorts a substring, makes it lowercase which are O(1) by assumption and lookups in hashtable, O(1). So, this is overall O(N)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Another solution  in javaScript 1. Build hash out of needle characters keeping total count of them 2. Count unique characters number 3. Function works only when needle length is greater than haystack length 4. Slide range equal to needle length along haystack and check for characters inside. If character goes out of range we decrement its count, if character comes into range we increment its count. If number of characters matches their number in needle we increment total number of matches, if number of characters does not match anymore we decrement number of matches. When number of matches equals number of unique characters in needle we exit with success."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool anaStrStr (string needle, string haystack)  \n{ \n    char *p1,p2,p1adv,p1start; \n    int bitmap[256],bitmap2[256]; \n     \n     \n     \n    p1 = haystack; \n    p1adv = haystack; \n    p2 = needle; \n    while(*p2) { \n       p1adv++; \n       p2++; \n    } \n    p2 = needle; \n     \n    for(i=0;i<256;i++) { \n      bitmap[i] = 0; \n    } \n     \n    while (*p2) { \n      bitmap[*p2]++; \n    } \n     \n    while(*p1adv) { \n        p2 = needle; \n        p1start = p1; \n        memcpy(bitmap2,bitmap,256); \n        while (*p2 && *p1) { \n            if (!bitmap2[*p1]) { \n                break; \n            } \n            bitmap[*p1]--; \n        } \n        if (!*p2) \n          return 1; \n        p1 =  p1start+1; \n        p1adv++; \n    } \n    return 0; \n     \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would go with a prime number  algorithm. No need to check order of letters, only matters the result of the matching prodcut of corresponding prime numbers: Each lettre in the needle has a unique prime number equivalent and since primes numbers product is unique ... equals product means anagram"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"One missing point is that the anagram has to be a word. So we should have a dictionary handy. Looking up a word of length \"n\" in the dictionary takes O(n).  I assumed all words are in dictionary. Python:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This solution seems clearer than the other ones. It has O(n) time complexity and O(k) extra space, where k is the size of the needle.  The idea is pretty simple you keep track of a count and a map of occurrences of the needle. In the event that you encounter a value that isn't in the needle, reset both of these to their original. When you reach count of zero, return true."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This solution seems clearer than the other ones. It has O(n) time complexity and O(k) extra space, where k is the size of the needle.  The idea is pretty simple you keep track of a count and a map of occurrences of the needle. In the event that you encounter a value that isn't in the needle, reset both of these to their original. When you reach count of zero, return true."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This solution seems clearer than the other ones. It has O(n) time complexity and O(k) extra space, where k is the size of the needle.  The idea is pretty simple you keep track of a count and a map of occurrences of the needle. In the event that you encounter a value that isn't in the needle, reset both of these to their original. When you reach count of zero, return true."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This solution seems clearer than the other ones. It has O(n) time complexity and O(k) extra space, where k is the size of the needle.  The idea is pretty simple you keep track of a count and a map of occurrences of the needle. In the event that you encounter a value that isn't in the needle, reset both of these to their original. When you reach count of zero, return true."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This solution seems clearer than the other ones. It has O(n) time complexity and O(k) extra space, where k is the size of the needle.  The idea is pretty simple you keep track of a count and a map of occurrences of the needle. In the event that you encounter a value that isn't in the needle, reset both of these to their original. When you reach count of zero, return true."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This solution seems clearer than the other ones. It has O(n) time complexity and O(k) extra space, where k is the size of the needle.  The idea is pretty simple you keep track of a count and a map of occurrences of the needle. In the event that you encounter a value that isn't in the needle, reset both of these to their original. When you reach count of zero, return true."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This solution seems clearer than the other ones. It has O(n) time complexity and O(k) extra space, where k is the size of the needle.  The idea is pretty simple you keep track of a count and a map of occurrences of the needle. In the event that you encounter a value that isn't in the needle, reset both of these to their original. When you reach count of zero, return true."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This solution seems clearer than the other ones. It has O(n) time complexity and O(k) extra space, where k is the size of the needle.  The idea is pretty simple you keep track of a count and a map of occurrences of the needle. In the event that you encounter a value that isn't in the needle, reset both of these to their original. When you reach count of zero, return true."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This solution seems clearer than the other ones. It has O(n) time complexity and O(k) extra space, where k is the size of the needle.  The idea is pretty simple you keep track of a count and a map of occurrences of the needle. In the event that you encounter a value that isn't in the needle, reset both of these to their original. When you reach count of zero, return true."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Any anagram? I assume you mean an anagram needle (the entire string), otherwise your example makes no sense.  Anyway, this is pretty straightforward. Reverse needle and then perform the KMP string matching algorithm. O(n) time and O(1) space."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6204973461274624","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"11","title":"I/P: N, k  O/P: all subset of N with exactly K elements.  eg: I/p: N = 5, K =3 O/p:  1 2 3 1 2 4 1 2 5 1 3 4 1 3 5 2 3 4 2 3 5 3 4 5","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Call with start = 1,  array aof size k, pos = 0."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public class Number {         public static String next(int start, int limit,int num,String str,int initialLimit)         {                 if(str == null)                 {                         str = Integer.toString(start);                 }                 else                 {                         str = str + ' '+Integer.toString(start);                 }                 limit--;                  if(limit == 0)                 {                         System.out.println(str);                 }                  for(int i=start+1;i<=num;i++)                 {                         if((num -i >= limit -1) && (limit >0))                         {                                 next(i,limit,num,str,initialLimit);                                 next(i,initialLimit,num,null,initialLimit);                         }                 }                 return str;          }         public static void main(String args[])         {                 int n=5;                 int k=3;                 String str =null;                 next(1,k,n,str,k);         } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool used[N]; \nchar output[K+1]; \n \nvoid rassclot(int fill, int prev) \n{ \n    if(fill == K) { print output; return; } \n \n    for(i=prev+1; i<=N; i++) \n    { \n        if(used[i]) continue; \n        output[fill]=i; \n        rassclot(fill+1, i); \n     } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Combinations { \n \n    public static List combinations(int n, int k) { \n        List list = new ArrayList(); \n        boolean flag = false; \n \n       List cur = new ArrayList(k); \n \n        for (int i = 0; i < k; i++) { \n            cur.add(i + 1); \n        } \n        list.add(cur.toString()); \n \n        for (int i = k - 1; i >= 0; i--) { \n            while (cur.get(i) < (n - (k - i) + 1)) { \n                cur.set(i, cur.get(i) + 1); \n \n                for (int j = i + 1; j < k; j++) { \n                    cur.set(j, cur.get(j - 1) + 1); \n                } \n \n                list.add(cur.toString()); \n            } \n        } \n \n        return list; \n    } \n \n    public static void main(String[] args) { \n        List list = combinations(5,3); \n \n        for(String s : list) { \n            System.out.println(s); \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static ArrayList> findCombinations(int n, int k){   if (k>n)     return null;   ArrayList> res = new ArrayList>();   ArrayList line = new ArrayList();   if (k==0){    res.add(line);    return res;   }   if (n==k){    for (int i=1; i<=n; i++)     line.add(i);    res.add(line);    return res;   }   res.addAll(findCombinations(n-1, k));   for (ArrayList e:findCombinations(n-1, k-1)){    e.add(n);    res.add(e);   }   return res;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"JavaScript implementation"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void print_subset(int *A, int K) \n{ \n  int i; \n  for(i=0; i=0 && k=0 && pos=0); \n \n  if(k==0){ \n    print_subset(B, K); \n    return; \n  } \n \n  if(start >= N) \n    return; \n \n  for(i=start; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A non-recursive solution in Python: It (theoretically) takes O(1) space since no stack is used. I am using a set \"sets\" to store all subsets rather than printing them."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A non-recursive solution in Python: It (theoretically) takes O(1) space since no stack is used. I am using a set \"sets\" to store all subsets rather than printing them."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using namespace std; \n \nvoid choose(const char *A, int n, int k, std::string prefix) \n{ \n if (A == NULL || n < 0 || k < 0) return; \n if (k == 0) { \n  cout << prefix << endl; \n  return; \n } \n std::string next_prefix(\"\"); \n for (int i = 0; i <= n - k; i++) { \n  next_prefix = prefix + A[i]; \n  choose(&A[i+1], n - i - 1, k - 1, next_prefix); \n } \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5293306254721024","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"26","title":"In Java: Write a function in language of your choice that takes in two strings, and returns true if they match. Constraints are as follows: String 1, the text to match to, will be alphabets and digits. String 2, the pattern, will be alphabets, digits, '.' and '*'. '.' means either alphabet or digit will be considered as a \"match\". \"*\" means the previous character is repeat 0 or more # of times. For example: Text: Facebook Pattern: F.cebo*k returns true.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Here is my working code in Java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public static boolean match(char text[], char pattern[]) { \n  if (text == null || text.length == 0) return false; \n  if (pattern == null || pattern.length == 0) return false; \n   \n  for (int i=0, j=0; i 0 && pattern[j] == '*') { \n    if (text[i] != pattern[j-1]) { \n     if (text[i] == pattern[j+1]) { \n      j++; \n     } \n     else { \n      return false; \n     } \n    } \n   } \n   else { \n    if (text[i] != pattern[j]) { \n     return false; \n    } \n    else { \n     j++; \n    } \n   } \n  } \n   \n   \n  return true; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a basic recursive solution. Few check like the first string should only have alphabets and digits can also be added"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static boolean compaire(String st, String pattern) { \n        boolean result = false; \n        if (st.length() == pattern.length()) { \n            char a1[] = st.toCharArray(); \n            char a2[] = pattern.toCharArray(); \n            for (int i = 0; i < a1.length; i++) { \n                System.out.println(\" First \"+a1[i]+\" Second \"+a2[i] ); \n                if (a1[i] == a2[i]) { \n                    result = true; \n                } else { \n                    if (a2[i] == '.') { \n                        if ((a1[i] >= 'a' && a1[i] <= 'z') || (a1[i] >= 'A' && a1[i] <= 'Z') || (a1[i] >= '0' && a1[i] <= '9')) { \n                            result = true; \n                        } else { \n                            return false; \n                        } \n                    } else if (a2[i] == '*') { \n                         \n                        if (i > 0 && (a2[(i-1)] == a1[i])) { \n                            result = true; \n                        } else { \n                            return false; \n                        } \n                    } else { \n                        return false; \n                    } \n                } \n            } \n        } else { \n            return false; \n        } \n        return result; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class MatchExp { \n    static boolean match(String input, String match){ \n        return matchExp(input.toLowerCase(),match.toLowerCase(),0,0); \n    } \n \n    static boolean  matchExp(String input, String match, int i, int j){ \n \n \n        if(i==input.length() && j==match.length()) return true; \n        if(i==input.length()) return false; \n        if(j==match.length()) return false; \n \n        if(match.charAt(j)=='*'){ \n            boolean matchVal = false; \n            for(int k  = i;k"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static boolean doesPatternMatch(String text, String patt)  {   //dp[i][j] = true if first \"i\" characters of pattern matches with first \"j\" characters of text   boolean[][] dp = new boolean[patt.length()][text.length()];          //base case      if(patt.charAt(0)=='.' || patt.charAt(0) == text.charAt(0))   {    dp[0][0]=true;   }else{    dp[0][0]=false;   }      for(int k=1;k  {    if(patt.charAt(0) == '*')     dp[0][k]=true;    else     dp[0][k]=false;   }      for(int k=1;k  {    if(patt.charAt(k) == '*')    {     dp[k][0] = dp[k-1][0];    }else    {     dp[k][0]=false;    }   }         for(int i=1;i  {    for(int j=1;j   {     if(patt.charAt(i) == '*')     {      dp[i][j] = dp[i-1][j-1] || dp[i-1][j];      }else if(patt.charAt(i) == '.')     {      dp[i][j] = dp[i-1][j-1];     }else if(patt.charAt(i) == text.charAt(j))     {      dp[i][j] = true;      }else{      dp[i][j] = false;     }    }   }       return dp[patt.length()-1][text.length()-1];  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the C code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def match2(s1, s2, prev=None): \n    if not len(s1): \n        return True \n    elif s1[0] == s2[0]: \n        return match2(s1[1:], s2[1:], s2[0]) \n    elif s2[0] == \".\" and (str.isdigit(s1[0]) or str.isalpha(s1[0])): \n        return match2(s1[1:], s2[1:], s2[0]) \n    elif s2[0] == \"*\" and s1[0] == prev: \n        return match2(s1[1:], s2, prev) \n    elif s2[0] == \"*\" and s1[0] != prev: \n        return match2(s1, s2[1:], s2[0]) \n    return False"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have question I saw comment that the code should return true for StringMatchWithWildCards.matchStrings(\"Facebook\", \"Facebo*ok\") but isn't pattern equivalent to Faceboook and it should rather fail?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"boolean isAMatch(int s_idx, int p_idx) {      if(s_idx == str.length() && p_idx == pat.length()) {    return true;   }      if(s_idx == str.length() || p_idx == pat.length()) {    return false;   }      if(str.charAt(s_idx) == pat.charAt(p_idx)) {    return isAMatch(s_idx+1, p_idx+1);   }      else if(pat.charAt(p_idx) == '.') {    return isAMatch(s_idx+1, p_idx+1);   }   else if(pat.charAt(p_idx) == '*') {        boolean case_A = false;    boolean case_C = false;    if(s_idx+1 < str.length() && str.charAt(s_idx+1) == str.charAt(s_idx)) {     case_A = isAMatch(s_idx+1, p_idx);    }    //0 characters    boolean case_B = isAMatch(s_idx, p_idx+1);    //both match    if(p_idx > 0 && str.charAt(s_idx) == pat.charAt(p_idx-1)) {        case_C = isAMatch(s_idx+1, p_idx+1);     }    return ( case_A || case_B ||case_C);   }   return false;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool ismatch(const char* s, const char* p) \n{ \n if(!s || !p) return false; \n if(*p == '\\0') return *s == '\\0'; \n if(*(p+1) == '*'){ \n  if(*s == *p || (*p == '.' && *s != '\\0')) return ismatch(s+1, p) || ismatch(s, p+2); \n  return ismatch(s, p+2); \n } \n else{ \n  if(*s == *p || (*p == '.' && *s != '\\0')) return ismatch(s+1, p+1); \n  return false; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ok , it was telephonic . I will explain logic  Assuming there can be more than one occurrence of * Taking example /temp/*my*jpeg   Calculate firstst occurrence of *   Calculate lastst occurrence of *   So know you know the prefix ans sufix string which need to be matched Figure out how many middleStrings can be there .( You know the first occurance of * , so add +1 to that position and find next occurance of * . this way do till you reach lastst *) Now simply use substring method for all the string which you have found ( i.e. prefix string,middle strings and sufix string)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"function func($pattern,$string) { \n if (strpos($pattern,\"**\") !== false || strpos($pattern,\"*\") === 0)  \n  return false; \n \n $pi = 0; \n $si = 0; \n do { \n  $p_chr = $pattern[$pi]; \n  $s_chr = $string[$si]; \n \n  if ($p_chr == $s_chr || $p_chr == '.') { \n   $pi++; \n   $si++; \n  } elseif ($p_chr == '*') {  \n   $masterChar = $string[$si-1]; \n   while ($string[$si] == $masterChar) $si++; \n   $pi++; \n  } elseif ($pattern[$pi+1] == '*') { \n   $pi+=2; \n  } else { \n   return false; \n  } \n \n }while($p_chr != null || $s_char != null); \n  \n return true; \n} \n \nvar_dump(func(\"aaa\",\"aaa\") == true); \nvar_dump(func(\"aaak\",\"aaa\") == false); \nvar_dump(func(\"aaa\",\"aaak\") == false); \nvar_dump(func(\"a.a\",\"ana\") == true); \nvar_dump(func(\".aa.\",\"jaan\") == true); \nvar_dump(func(\"aaa\",\"bbb\") == false); \nvar_dump(func(\".aa\",\"bbb\") == false); \nvar_dump(func(\"ab*g\",\"ag\") == true); \nvar_dump(func(\"ab*g\",\"abg\") == true); \nvar_dump(func(\"ab*g\",\"abbg\") == true); \nvar_dump(func(\"ab*\",\"abbb\") == true); \nvar_dump(func(\"b*\",\"\") == true); \nvar_dump(func(\".*.\",\"jjjjjm\") == true); \nvar_dump(func(\"*aaa\",\"a\") == false); \nvar_dump(func(\"aa***a\",\"a\") == false); \nvar_dump(func(\".\",\"j\") == true);"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4859932243394560","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"18","title":"Prints all unique subsets of the string. Given a string write a function which prints all the subsets of the string. Now make the function to return only unique solutions.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def print_substr (string):   strset = dict()   for cnt in range(0,len(string)):     for from in range(0,len(string)):       to=frm+cnt+1       if to <= len(string):         strset[string[frm:to]]=0.0    for substr,dummy in strset.iteritems():     print substr"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Remove dups from string and then user simple algo which based on binary representation on subset."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) first remove duplicates from the string 2) Use recursion and inside each call the same function, one using the character at that position and other without it. the total number of possible solution is 2^n"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for(int i= 0; i < s.length(); i++) \n  { \n   ArrayList tempList = new ArrayList(); \n   tempList.add(s.charAt(i)); \n   for(Character c : tempList) \n    System.out.println(c); \n   for(int j = i+1; j < s.length(); j++) \n   { \n    tempList.add(s.charAt(j)); \n    for(Character c : tempList) \n     System.out.print(c); \n    System.out.println(); \n   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This problem is from Glassdoor I believe. The interview candidate said they had to use recursion without extra memory.   \"Note: The interviewer gave me a big hint: \"What happens if you sort the array and simply generate all the subsets?\"  The best solution I've found so far is:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void solve(int index, string gen, set response, string input){ \n    response.add(gen); \n    for(int i=index;i>input; \n    set response; \n    for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"function getSubsets($string) { \n $result = array(); \n $chars = str_split($string); \n $strLength = strlen($string); \n $subsetAmount = 1 << $strLength;  \n for($mask=0; $mask < $subsetAmount; $mask++) { \n  $subset = \"\"; \n  for($j=0; $j<$strLength; $j++) { \n   if (($mask << $j >> ($strLength-1)) & 1) { \n    $subset .= $string[$j]; \n   } else { \n    $subset .= '_'; \n   } \n  } \n  $result []= $subset; \n } \n return $result; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I used a set to keep track of already printed subsets. I did not see any constraints on space so here is a solution in EXPSPACE/EXPTIME"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I used a dict to keep track of printed subsets. This one takes EXPSPACE in the length of input, also EXPTIME."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A set can be used to prevent printing duplicates. In any case, this is an EXPTIME problem and adding a set makes it EXPSPACE."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def stringSubset(abc):     if (len(abc) == 1):         return [\"\"]+[abc];     else:         result = []         a = abc[0]         bc = abc[1:len(abc)]         rest = stringSubset(bc)         if (bc[0] == a):             return [a+x for x in rest]     return [a+x for x in rest]+rest"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hash should limit selected items. The global hash of values can be used only for algorithm verification."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void print_subset(int *A, int K) \n{ \n  int i; \n  for(i=0; i= N) \n    return; \n \n  for(i=start; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"this should do the work(C++)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6685828805820416","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"5","title":"Given the following 3 by 3 grid where the (first row, first column) is represented by (0,0):  0,1     1,2     3,3 1,1      3,3   3,2 3,0     1,3     null  we need to find if we can get to each cell in the table by following the cell locations at the current cell we are at. We can only start at cell (0,0) and follow the cell locations from that cell, to the cell it indicates and keep on doing the same for every cell.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Just like a graph traversal using a same size matrix with initial value set to -1. Mark the position you visited and, if you see a cycle (not -1 value), you know you will not be able to visit all the cells.   time complexity nxn and space complexity nxn"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"$A = array( \n array( \n  array(0,1),array(1,2),array(3,3) \n ), \n array( \n  array(1,1),array(3,3),array(3,2) \n ), \n array( \n  array(3,0),array(1,3),null \n ), \n); \n \n$hasBeen = array(); \n$rootPosition = array(0,0); \n$total = 0; \nvar_dump(func($A,$rootPosition,$total,$hasBeen)); \n \n \nfunction func($A,$position,$total,$hasBeen) { \n $item = $A[$position[0]][$position[1]]; \n \n if ($item == null) { \n  return $total == count($A)*count($A); \n } \n  \n $hasBeen []= $position; \n  \n $nextPosition = array($item[0],$item[1]); \n \n if (!in_array($nextPosition,$hasBeen)) { \n  return func($A,$nextPosition,$total+1,$hasBeen); \n } \n  \n return false; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"by \"3,3\" you must mean \"0,0\". otherwise array index out of bound exception."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4804004722769920","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"21","title":"There are N objects kept in a row. The ith object is at position x_i. You want to partition them into K groups. You want to move all objects belonging to the same group to the same position. Objects in two different groups may be placed at the same position. What is the minimum total amount by which you need to move the objects to accomplish this?  Input: The first line contains the number of test cases T. T test cases follow. The first line contains N and K. The next line contains N space seperated integers, denoting the original positions x_i of the objects.  Output: Output T lines, containing the total minimum amount by which the objects should be moved.  Constraints: 1 <= T <= 1000 1 <= K <= N <= 200 0 <= x_i <= 1000  Sample Input: 3 3 3 1 1 3 3 2 1 2 4 4 2 1 2 5 7  Sample Output: 0 1 3  Explanation:  For the first case, there is no need to move any object. For the second case, group objects 1 and 2 together by moving the first object to position 2. For the third case, group objects 1 and 2 together by moving the first object to position 2 and group objects 3 and 4 together by moving object 3 to position 7. Thus the answer is 1 + 2 = 3.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Same DP approach as kkr.ashish above: F(n+1,k) = min(F(n,k-1), F(n-1,k-1)+dist(a(n),a(n+1)), F(n-2,k-1)+dist(a(n+1),a(n),a(n-1)  where dist(a(n),a(n+1)...) represents the minimum distance to group a(n),a(n+1)... into a partition.  Overall complexity is O(k*n^3) since each dist() takes O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"since this is one D array use DP F(n+1,k) = min(F(n,k-1), F(n-1,k-1)+dist(a(n),a(n+1)), F(n-2,k-1)+dist(a(n+1),a(n),a(n-1) ...................) also F(j,k) = 0 for j<=k  complexity.. O(k*n^2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sort the array so that x_1 <= x_2 <= ??. <= x_n. Now the problem is reduced to partitioning number N into K positive numbers a_1, a_2, ??., a_K. From the partition we can construct a grouping: First we pick up a_1 numbers from x_1 to x_a for the first group, next we pick another a_2 numbers from x_(a1+1) ??.x_(a2+a1), and this process continues. The problem can be reduced into a DP problem:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can't we use Kmeans algorithm for this purpose?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This algorithmic problem is called  Jenks natural Breaks for coloring, see following post \"Oren Gal GIS Blog: Calculating Jenks Natural Breaks\" And it has name of its creator :-)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"JavaScript implementation  1. sort array 2. find the best split of array into 2 intervals. Split second interval recursively in order to find the best split for K groups"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please explain me question...what x_i means?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"1) Iterate over the array (n - k) times. 2) In each iteration find the pair of elements for which abs(a[j] - a[i]) is minimal. 3) Merge a[i] and a[j] and add  total += abs(a[j] - a[i]); Code:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14847690","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"23","title":"FInd the maximum sum of a sub-sequence from an positive integer array where any two numbers of sub-sequence are not adjacent to each other in the original sequence. E.g 1 2 3 4 5 6 --> 2 4 6","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"This is a dynamic programming problem. Let original array = a[0 to n-1] Let solution array = s[0 to n-1] where s[I] = max sum of non-adjacent numbers from a[0 to I]; So, s[0] = a[0]; s[1] = Max(a[0],a[1]); Now recursively, s[I] = Max(s[I-1],a[I]+s[I-2]); you either take the ith element or you dont  s[n-1] will be final solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this can be implemented with Kadane's algorithm with a small change in it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Try  this-Basically it goes by the logic that if you do not want adjacent values, then the third or fourth value becomes a potential candidate to add."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"function findMax($a){ \n$l=count($a); \n$max=0; \n$cf=-1; \nfor($i=1; $i<$l-1; $i++){ \n   if($i-1==$cf) continue; \n  if($a[$i-1]+$a[$i+1] > $a[i]) \n     $cf=$i-1; \n   else \n     $cf=$cf[$i]; \n  $max+=$cf; \n} \n  if($i==1){ \n    if($a[0]+$a[1] > $a[2]){ \n      $cf=1; \n    } \n     $max = max($a[1]+$a[3], $a[2]); \n  } \n  return $max; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"assume A is original array and B is to point the indices of A starts from 0 to A.length then FIND_MAXSUM_SUBARRAY(A,B) {  for i=1 to A.length-1    for j=1 to B.length-1      if(a[j]>a[j+1])         swap(A[j],a[j+1])         swap(B[j],B[j+1])  for j=B.length to 1    if B[j]!=-1      C[i]=A[j]      i=i+1      for k=1 to j-1        if B[k]=B[j+1]+1           B[k]=-1      for k=1 to j-1        if B[k]=B[j]-1           B[k]=-1     B[j]=-1 }  This algorithm first sorts array A and changed positions of A will be stored in array B. starts from last value of A, as it is maximum put it under array C. Then make sure you won't consider a position immediate less or immediate above than that. You can do that by making indices values to -1. This algorithm takes Theta(n^2) at worst case. I traced it good and it works with different outputs. please let me know in case any improvements can be done."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n) solution, non-recursion... the idea is similar as the first post above: the (i+1)th element is not included in the result if the sum till (i+1)th elem is less than the sum till ith element:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n): Use Dynamic Programming, Take two additional array Including[n], excluding[n]..  Including gives the max sum including current position, and excluding keeps track of max sum excluding current position. For any position i, its including value = excluding[i-1] + Number at position i and its excluding value = including[i-1]  Thats it, in the end, check the last value of excluding and last of including array, whichever is maximum, just return it..  Ex. -> Given Array 1 - 2 - 3 - 4 - 5 - 6           Including        1   2   4    6  9    12           Excluding      0   1   2    4   6    9"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"$array = array(2,1,4,3,5,9); $size = count($array);   function maxs($arr, $size) {     $incl = $arr[0];     $excl = 0;     $excl_new = 0;     $incla = array($arr[0]);     $excla = array();     $excl_newa = array();     for ($i = 0; $i<$size;$i++)     {         unset($excl_newa);         if ($incl > $excl)         {             $excl_new = $incl;             $excl_newa = $incla;         }         else         {             $excl_new = $excl;             $excl_newa = $excla;         }                      $incl = $excl + $arr[$i];         $excl = $excl_new;         $incla = $excla;         $incla[] = $arr[$i];         $excla = $excl_newa;     }     if ($incl > $excl)     {         echo (\"total - \" . $incl);         print_r($incla);     }     else     {         echo (\"total - \" . $excl);         print_r($iexcla);     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we maintain an auxiliary array that holds the result upto a given value. rest is straight forward, very simple code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"function(array) { \n  if (array.length < 2) { \n   return -1; \n  } \n \n  var sum1 = array[0]; \n  var sum2 = array[1]; \n \n  var length = array.length; \n \n  for (var i = 0, j = 1; i < length && j < length; i += 2, j += 2) { \n   if (i + 2 < length) { \n    sum1 += array[i + 2]; \n   } \n \n   if (j + 2 < length) { \n    sum2 += array[j + 2]; \n   } \n  } \n \n  return Math.max(sum1, sum2); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A loop is more efficient here than memorization but it doesn't impact the complexity, so heck."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"No need for any DP approach.  Since the array is all POSITIVE integers, the only two possible maximum sum subsequences with no adjacent elements are: s_even=a[0]+a[2]+... s_odd=a[1]+a[3]+...  You just need to do one linear pass to compute the two values s_even and s_odd, and one pass to output the elements corresponding to the larger of the two values, e.g: 1 2 3 4 5 6 s_even=1+3+5=9 s_odd=2+4+6=12 Output: 2, 4, 6"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is dp:  f(n) = max(f(n-2) + c(n), f(n-1)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14848682","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"17","title":"You are given intervals of contiguous integers, like [1, 10), [15, 25), [40, 50), which are non-overlapping and of a fixed size. Design a data structure to store these intervals and have the operations of insert, delete, and find functions","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"basically using array of struct pointer. \n//pseudo code \nStruct Node { \n   int begin; //end can be inferrred due to fixed size and contiguous. \n} \nStruct*[] arr; //array of struct pointers. \nint size = 10; //fixed given size \n \nvoid insert(int begin) { \n  if(arr[begin] == null && arr[begin+size] == null) { \n   Struct s = new Struct(); \n   s.begin = begin; \n   for(int i = 0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"GO with Linked List.  Advantages: Inserting, Deleting simpler O(1) Disadvantages: Searching a particular interval O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"As they are not overlapped, so they are stored in the order. A structure having random access will boost the find() algorithm. Depending on how much operations of deleting and inserting a list may/may not used."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I dont see the need to create fancy data structures to handle such simple requirements. why not create an array of the size of the range of interest, and initialize the array members to say 1. Then, simply \"zero\" the members of an interval inserted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since we know none of the interval overlaps, we can simply store them in a sorted array with information about if this entry is start or end of an interval.  Modify binary search algorithm to return the low index in case of failed search. This will give us the index of key if found else low index. This low index gives us the position of new element to be inserted. For ex: intervals: [1, 10), [15, 25), [40, 50)  My array has, 1, 9, 15, 24, 40, 49  I want to insert new interval [30,32). Modified binary search will give position of 40. We need to verify that the 40 is start and 24 is end ..ie the two entries don't constitute an interval or else [30, 32) will overlap. if they don't constitute an interval insert [30,32) and push 40, 49. Therefore insertion is linear in worst case.  Search and delete would work similarly"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We need to design a data structure: Inserting an interval Find if a point P belong to any interval Delete an interval  Let's say we use balanced binary search tree: Inserting an interval O(logn) Find if a point P belong to any interval O(logn) Delete an interval O(logn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question is not really specified. So for a few interpretations:  1) Interval sizes are fixed means to me, that all intervals are of the same size, just as in the example. In that case just use either an unordered_set for space efficiency or a bitarray for more speed. The set only contains the left border of each interval while the array contains a 1 for each present number. Both have O(1) for all operations...  2) Interval can be of variable size. Order by left and right borders in two search trees. Insert/find/delete is log(n).  Or use bitarray for efficiency and wasting space..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"balanced binary search tree"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"We could use HashMaps as well."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"I think the answer is segment trees... a segment tree is a tree data structure for storing intervals, or segments. It allows querying which of the stored segments contain a given point. It is, in principle, a static structure; that is, its content cannot be modified once the structure is built"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"Red black trees should work fine too"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14848680","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"22","title":"You are going to take some numbers as an input from a file. You need to witer a program to find longest increasing sequence. You should process it as soon as you are taking an input. After finishing the last input immediately you should be able to tell the sequence. Input: 1 5 3 4 6 4 Output: 3 4 6","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"LIS in the question should be 1 3 4 6"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; \nimport java.util.Comparator; \nimport java.util.List; \nimport java.util.PriorityQueue; \n \n \nclass LSOfN { \n  \n private int arrIndex; \n private int length; \n  \n LSOfN(int arrIndex, int length) { \n  this.arrIndex = arrIndex; \n  this.length = length; \n } \n  \n public int getArrIndex() { \n  return arrIndex; \n } \n public int getLength() { \n  return length; \n } \n  \n public String toString() { \n  return \"LS(\"+arrIndex+\") = \"+length; \n } \n} \n \npublic class LongestIncrSubSeq { \n \n /** \n  * @param args \n  */ \n int size; \n List arrList; \n PriorityQueue pr; \n  \n LongestIncrSubSeq(List arrList, int size) { \n  this.arrList = arrList; \n  this.size = size; \n  this.pr = new PriorityQueue(size, maxSubSeqLengthComparator); \n } \n  \n private Comparator maxSubSeqLengthComparator = new Comparator() { \n \n        @Override \n        public int compare(LSOfN o1, LSOfN o2) { \n                int maxLengthLeft = o1.getLength(); \n                int maxLengthRight = o2.getLength(); \n                \n                if(maxLengthLeft > maxLengthRight) { \n                        return -1; \n                } else if (maxLengthLeft < maxLengthRight) { \n                        return 1; \n                } \n                return 0; \n        } \n }; \n  \n public void findLsOfi(int i) { \n  List tempHolder = new ArrayList(); \n  LSOfN lsofi = null; \n  while(!pr.isEmpty()) { \n   LSOfN lsOfN = pr.poll(); \n   tempHolder.add(lsOfN); \n   if(lsOfN.getArrIndex() < i && arrList.get(i) > arrList.get(lsOfN.getArrIndex())) { \n    lsofi = new LSOfN(i, lsOfN.getLength() + 1); \n    break; \n   } \n  } \n  if(lsofi == null) { \n   lsofi = new LSOfN(i, 1); \n  } \n  tempHolder.add(lsofi); \n  System.out.println(\"LsOf \"+i+\" = \"+lsofi); \n  pr.addAll(tempHolder); \n } \n  \n public static void main(String[] args) { \n  List arrList = new ArrayList(); \n  arrList.add(10); \n  arrList.add(22); \n  arrList.add(9); \n  arrList.add(33); \n  arrList.add(21); \n  arrList.add(50); \n  arrList.add(41); \n  arrList.add(60); \n  arrList.add(80); \n  LongestIncrSubSeq ls = new LongestIncrSubSeq(arrList, arrList.size()); \n  for(int index = 0; index < arrList.size(); index++) { \n   ls.findLsOfi(index); \n  } \n  System.out.println(\"Length of the longest subsequence is \"+ls.pr.peek().getLength()); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Online algorithm will probably have to remember ALL sequences so far... There should be no way to do better. Then you can keep them sorted by their last element and will have to manage O(n) sequences simultaneously in the worst-case. There is stuff you can do about optimizing memory though, but in principle this should be it.  So a more precise idea. Keep chunks of continous increases in a \"Node\" and has forward links (a list) which is empty. Further, keep all Nodes sorted by their highest element and you need to clone all Nodes, such that a sequence like \"1 2 3\" has three nodes, \"1\", \"1 2\" and \"1 2 3\". Now if you encounter a new Node, you scan in O(log(n)) time for the first Node that could continue in you new found sequence. You then add forward links to all folowing, already known Nodes. Then you clone and add these new Nodes... Also keep track of the maximum path found so far. I am not sure what you can do to improve if the future is totally unknown.  Wikipedia: Longest_increasing_subsequence  Offline:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"DP Algo"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"DP Algo"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"import java.util.ArrayList; \nimport java.util.Arrays; \nimport java.util.Iterator; \n \npublic class LongestSequence { \n \n static Seq current = new Seq(); \n static Seq lastLongSequence = new Seq(); \n \n public static void main(String[] args) { \n \n  int a[] = { 1, 5, 3, 4, 6, 4 }; \n  int[] expectedResult = { 3, 4, 6 }; \n \n  // coming from an input \n  for (int i = 0; i < a.length; i++) { \n   addSequence(a[i]); \n  } \n \n  Seq result = current.size() > lastLongSequence.size()?current:lastLongSequence; \n   \n  if (Arrays.equals(expectedResult, result.getAsArray())) { \n   System.out.println(\"Goal\"); \n  } else { \n   System.out.println(\"fail\"); \n  } \n \n } \n \n private static void addSequence(int i) { \n \n  if (i > current.getLastElement()) { \n   current.add(i); \n  } else { \n   if(lastLongSequence.size() < current.size()){ \n    lastLongSequence = current; \n   } \n   current = new Seq(); \n   current.add(i); \n  } \n \n } \n \n static class Seq { \n \n  int last = 0; \n   \n \n  // using a dynamic array \n  ArrayList s = new ArrayList(); \n \n  public int[] getAsArray() { \n \n   return convert(s); \n  } \n \n  public int size() { \n    \n   return s.size(); \n  } \n \n  public void add(int i) { \n   last = i; \n   s.add(i); \n \n  } \n \n  public int getLastElement() { \n   return last; \n  } \n \n  int[] convert(ArrayList integers) { \n   int[] r = new int[integers.size()]; \n   Iterator iterator = integers.iterator(); \n   for (int i = 0; i < r.length; i++) { \n    r[i] = iterator.next().intValue(); \n   } \n   return r; \n  } \n \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"int ARRAY, ARRAYLEN; // input \nint subArrStartInex = 0, subArrLen = 0; // ouput \nint tempStartIndex = 0; tempArrLen = 1; \n \nfor (int i = 0; i < ARRAYLEN - 1; ++i) { \n    if (ARRAY[i] < ARRAY[i + 1]){ \n        tempArrLen ++; \n    } \n    else { \n        // a descend detected \n        if (tempArrLen > subArrLen){ \n            subArrStartIndex = tempStartIndex; \n            subArrLen = tempArrLen; \n            tempStartIndex = i + 1; \n            tempArrLen = 1; \n        } \n    } \n} \nif (tempArrLen > subArrLen){ \n     subArrStartIndex = tempStartIndex; \n     subArrLen = tempArrLen; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I think this should work"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This can be done using two linked lists. One denoting the longest increasing sequence \"so far\" (currentSeq). And another denoting the \"next potential\" increasing sequence (nextSeq). In the beginning, currentSeq = firstElementOnly and nextSeq = firstElementOnly. The moment nextSeq becomes longer than currentSeq, we do currentSeq = nextSeq. If an input element is encountered that is less than nextSeq.Tail, we do nextSeq = null. When the input ends, currentSeq will denote the longest sequence, and we just need to print it starting from currentSeq.Head."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"int binarySearch(const vector& leastNumber, int key) {        int l = 0, r = leastNumber.size();        while (l < r) {            int mid = (l+r) / 2;            if (key < leastNumber[mid]) {                  r = mid; } else                   l = mid + 1; }           return r; } int LongestCommonSequence(const vector& data) {       vector f, leastNumber;       f.resize(data.size());       for (int i = 0; i < data.size(); ++i) {          int j = binarySearch(leastNumber, data[i]);                if (j == leastNumber.size()) {                leastNumber.push_back(data[i]);                f[i] = leastNumber.size(); } else {               leastNumber[j] = data[i];               f[i] = j; } return f[data.size()-1]; } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"We can take use of a stack.  1. Keep reading numbers from the file. 2. Put the next number into stack if the top element on Stack is less than the current number. 3. If current number is less than the top element, pop all the elements and keep track of length of all the popped elements. This way you will keep track of longest number sequence."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14858683","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"Design the Facebook Credit system which is a application where users can buy/trade virtual currency and can use the virtual currency to purchase Facebook services, like paid apps.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"- Earlier users had to buy credits per application but now with virtual currency, user can use the same credit in any Facebook affiliated application.  - Single user's credit balance is more of a user specific information now as compared to user's account info for a specific application. Therefore it can be combined with existing user info. - Our aim is to atomically and securely purchase and spend virtual currency thereby updating user's current balance. - @fb user info is cached with memcached which provides us with performance in fetching user data, replication for availability, atomic transactions using 2-phase commit, fault tolerance, cache coherency etc.  - For each expenditure we check user balance, if more or equal to be spent balance calculated accordingly and saved.   I'm really not sure, what exactly do they expect here. If they're ok with us leveraging their architecture then we don't have much to say here but if they want us to design everything from scratch then probably we need to explain memcached and DHT here."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14850690","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"7","title":"Design and implement an algorithm that would correct typos: for example, if an extra letter is added, what would you do?  design and implement algorithms that correct typos, offering guidance, encouragement, and confirmation along the way","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Firstly, consider the scenarios: 1) When user types a particular word      if(word == appropriate vocabulary word)         no suggestion;      else         suggestions with the closet matching words from the given dictionary  Assumptions: 1) There a should be a dictionary of correct vocabulary words, a) you can create you own b) several API's can be found online.  2) The dictionary should be stored as a form of sorted hashmap with no duplicate values.  Proceesing 1) When user enters the word, compare that word with the value of dictionary sorted hashmap,          if match is found then proceed          else compare the word with the closest matching word in the dictionary, pull out the closest matching            words for the user to display."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how about hashtable with link-list chaining.  For instance use first 1-3 characters as KEY. And in each entry link-list is used to chaining the words.  Christ, chrome, Christian, ...... use \"Chr\" as the hash key, and all the word in linked by a list. Typo checking: not entry found in list, then it's a typo auto typing: show some of words in this list. (depending on the rules)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"- The database here consists of frequently misspelled words and associated correct spellings . - The best in-memory DS to represent a large number of wrong strings and associated correct spellings is a trie / TST   - but such a structure would not scale well  in case there are a vast number of such words ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use a trie. For example if the user types seperate instead of separate then using trie traverse till there is a match i.e, till sep. Then get all the words starting with sep. use dynamic programming to get the cost to change seperate to each of the found words. Sort the words based on this cost and get the top 5 or 10 based on the application needs and display them to the user."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Have both prefix and suffix trie. When a user enters a word try to match using prefix trie till there is no mismatch. Get all the words starting from that. Then do the same for suffix. Now run the DP algo to get the closest set of words with minimum modification to transform the typed word to all of these words selected. Display the closest matching words.  2)You can also have a separate table for most common misspellings for the words and display from both this and the above.  In the trie mainatin the count for each word based on its usage."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"hashmap or trie"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14797777","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"13","title":"A period of time where users login and logout, given a sets of login and logout time pairs, write a function that can show the number of users online at any given time.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Sort all the login times in one list, sort all the logout times in another list. This is O(NlogN) preprocessing. Now when a query comes along, do a binary search on both lists to count the number of logins and the number of logouts prior to the specified time. Then the number of logged in users is logins minus logouts. This query answering process is O(logN). So for N elements and D queries, we achieve O((N+D) log N) when we count both preprocessing and query cost."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n) Consider every login/logout pair, count it if login happened prior to the given time, and logout happened after the given time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"segment tree"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) only query the number of users online once O(n): We can compare the each user's login time and logout time to the given time. If the login time is less than or equal to the given time and the logout time is greater than the given time, then then user is online.  2) Query m times the number of users online, where is m is large(O(mlogn + nlogn) instead of O(m*n)): we can precompute the number of users at certain times (times in the login and logout). Then we sort the times. Given a query time, we use binary search to find the largest time less than or equal to the given time and return the number of users online for this time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"segment tree is the best solution if there are huge number of users."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Interval tree is also fine"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14803796","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"2","title":"Implement a read/write lock, given a mutex that has lock() and trylock() interface","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My understanding...  lock(): Acquires the read lock. (shared lock) tryLock() : Acquires the read lock only if the write lock is not held by another thread at the time of invocation. So basically tryLock() is set by writers (exclusive lock)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14801686","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"11","title":"Generate a random 4 letter word from /usr/share/dict/words","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Since you specifically mention a unix file system, you will probably get bonus points for a one line terminal solution before designing a program.  grep -o -w '\\w\\{4\\}' /usr/share/dict/words | sort --random-sort | head -n 1  or   grep -o -w '\\w\\{4\\}' /usr/share/dict/words | shuf -n 1  would work"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Assuming the file is sorted with longer length words appearing after shorter one.  Do binary/interpolation search for aaaa and zzzz.  The positions between those two locations are in effect an array of the 4 letter words. (5 bytes each, assuming this is ascii file, with newline after each word)  The positions will tell you how many 4 letter words are there . Say that is W.  Now you can pick a random number in 1 to W. And pick the corresponding word.  This will issue very few reads (and seeks) on the file."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If you collect all the words in array, then you can generate random number and pick the word using array[randomnumber].  Looks need more details on this question."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"maximum number of 4letter words can be 26^4=456,976 ,working on a 32 bit or 64 bit domain we can simply produce a garbage value to cover this range and cm with the random word provided we have got a sub array of 4-letter words from the file"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sed -n '/^[a-zA-Z]\\{4\\}$/p' /usr/share/dict/words  They are probably testing your ability to use preexisting tools! If you are reinventing the wheel then you waste man hours, unproductive."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"str = \"/usr/share/dict/words\" \n  r_str = \"\" \n  while r_str.size < 4 do \n    c = str[rand(str.size)] \n    r_str += c if c != \"/\" \n  end"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class GenerateRandom {   public static void main(String args[]){   String s=\"/usr/share/dict/words:\";   String word=\"\";   int l=s.length();   List shuffledList= new ArrayList();     for(int i = 0; i < l; i++)      shuffledList.add(s.charAt(i));        Collections.shuffle(shuffledList);        List newList=shuffledList.subList(0, 4);        for(Object i:newList)         word+=i;        System.out.println(\"The new word is \"+word);  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"All these unix command line based ideas are great, but if we're asked not to use these but to think of an algorithm and print it out,  would reservoir sampling be a good fit?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14804692","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"39","title":"A file contains a billion integers, try to find any one integer that is not in the file.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Considering an unsigned 32 bit integer There are 2^32 possible values ( about 4 Billion ) Allocate a single bit for each value ( This would required 512 MB of memory ) Read the file, for each integer I, set ith bit to 1 Once reading file is complete find the first bit which is not 1 print the number corresponding to this bit."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"External sort then binary search on the file"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Read each number in the file. Keep track of the largest number you encounter. When you are at the end. Add 1 to it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Pick a random 64 bit integer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is not clear from the question, If the integers are between 1 to 1B only. We can solve it by divide and conquer.  We can divide all the integers based on their 1st bit i.e. make two buckets, 1st bucket with all integers whose first bit is 0 and second bucket with integers whose first bit is 1. then count the integers in both buckets, The bucket which has less integers pick that and again divide it into 2 buckets with 2nd bit and so on, do this until you end with a bucket no element and keep track of the bit for the each chosen bucket. You can form the missing integer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think using quicksort approach would definitely hit it. Suppose we are given a billion 64-bit integers we try to partition them around 2^63 and then we choose the part that has less (or equal) numbers. Suppose that left part has less numbers, then by comparing it to  2^62 we partition it (in place) again. until we reach a point that after partitioning there's one part that doesn't contain any number in it. Then you could choose any number in that range for an answer. That works for 32-bit integers, too."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Scan the file first and store the values in a BitMap. Using 1 bit per integer, we'd need 125MB.   Next scan the bitmap for a 0 bit."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Two we need to know to answer this question: 1. Are the numbers in the file unique? 2. What is the range of the numbers in the file?  If the numbers in the file are unique then we are dealing with a billion numbers in the range [n to n+1billion+1]. The plus one is for the missing number. If the numbers are not unique then the numbers will range from [n to n+c+1] where c is unknown, and there will be repetitions in the file (unless the file is 1billion instances of the same number).  If assume we are dealing with a file containing 1billion unique numbers in the range [0 to 1billion+1] then an way to determine the missing number would be to: 1. calculate the sum of [0 to 1billion+1] (sum of arithmetic series = n(a1+an)/2) 2. then subtract each number contained in the file.  The sum is big (approx. 1x10^18) This could be represented in 60bits, so a long will be fine."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's my Java solution for limited memory. Very minimal error checking."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Solution{ \n  public int findFirstNotIn(int[] arr){ \n    byte[] ret = new byte[(1<<30)+1]; \n    for(int a in arr){ \n      if(a>0) \n          ret[a>>2] = 1; \n    } \n    for(int i = 0 ; i < ret.length ; i++){ \n       if(ret[i] == 0) return i; \n    } \n    return 0; \n  } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"int input[] = { 0, 1, 2, 3, 4, 5, 6, 7, 12, 22, 23, 32, 54, 66, 88, 102, 12312, 1000000,  1012739, Integer.MAX_VALUE }; \n        long sum = 0; \n        int max = 0; \n        int res = 0; \n        int i; \n         \n        // Sum all the ints into a long variable, in this example ints come from int input[] \n        for (i = 0; i < input.length; i++) \n        { \n            sum += input[i]; \n            if (max < input[i]) \n            { \n                max = input[i]; \n            } \n        } \n         \n        // simple check \n        if (max != Integer.MAX_VALUE) \n        { \n            res = max + 1; \n        } \n        else \n        { \n            // if i cannot be subtracted from the sum it is the result, otherwise subtract \n            for (i = Integer.MAX_VALUE; i >= 1 ; i--) \n            { \n                if (sum >= i) \n                { \n                    while (sum >= i) \n                    { \n                        sum -= i; \n                    } \n                } \n                else \n                { \n                    res = i; \n                    break; \n                } \n            } \n        } \n         \n        System.out.println(\"Here is your new int: \" + String.valueOf(res));"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Cantor's diagnoalization"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Find the max number and max+1 is the number you are looking for."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Unbelievable the amount of bullshit we can read here. The best solution is, as someone mentioned, cantor's diagonalisation. You read the nth digit of the nth word, you add 1 to it modulo 10 (or even modulo 2 actually) (if the number doesn't have a nth digit, you just use 0+1 = 1) and this makes the nth digit of your new number. This new number is different from all other numbers from at least one digit (by construction). The complexity of this algorithm is O(number of lines). No other algorithm I have seen on this page runs as fast as this one."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14813666","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"How would you implement hash table on your own? Write the code for implementing your own hash table?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I think more information is needed for this question... 1)What dataset we are hashing?Without knowing this we cant decide on a good hashing function that minimizes collisions 2)Growth of Data?If data doesn't grow then static hashing will do,but if it does we need an extendable hashing solution. 3)How much resources do we have?Some hashing techniques have better performance but are less efficient in terms of space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-4","title":"It is true. Facebook engineers are crazy."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14804690","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"If you wanted to make a highly concurrent cache with a least recently used replacement policy, what data structures would you use? How would this scale per number of threads?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Hashtable + doubly linked list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Check this nice explanation from Google: code.google.com/p/concurrentlinkedhashmap/wiki/Design"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use heap (priority queue). For every block (aka cacheline for a processor cache), track \"least recently used\" by either a time stamp or a counter. When there is a need to find a victim block to make a room for some other block, find least recently used block."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This article explains how to build one really well.   openmymind.net/High-Concurrency-LRU-Caching/"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14762714","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"7","title":"Given a string and a pattern('.' Matches any single character.'*' Matches zero or more of the preceding element.),  find the first substring  matching this pattern.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"#include \n#include \n \nusing namespace std; \nint main() \n{ \n    string pat = \"\"; \n    bool match = false; \n    int j = 0; \n    cout<<\"Enter the pattern: \"; \n    cin >> pat; \n     \n    string str = \"\"; \n    cout<<\"Enter the string: \"; \n    cin >> str; \n     \n    for(int i=0;str[i] != '\\0';i++) \n    { \n        for(j=0;pat[j] !='\\0';j++) \n        { \n            if(str[i] == pat[j] || pat[j] == '.') \n            { \n                if(str[i+1] == '\\0') \n                { \n                    i++; \n                    j++; \n                    break; \n                } \n                i++;                 \n                continue; \n            } \n            else \n            { \n                if( pat[j] == '*') \n                { \n                    while(str[i] != pat[j+1] && str[i] != '\\0') \n                    { \n                        if(pat[j+1] == '*' || pat[j+1] == '.') \n                        { \n                            j++; \n                            if(pat[j+1] == '.') \n                            { \n                                i++; \n                            } \n                        } \n                        else \n                        { \n                            i++; \n                        } \n                    } \n                    if(str[i] == '\\0' && pat[j+1] != '\\0') \n                    { \n                        break; \n                    } \n                    else \n                    { \n                        //i++; \n                    }                      \n                } \n                else \n                {                    \n                    break; \n                } \n            } \n        } \n        if(pat[j] == '\\0') \n        { \n            cout<<\"Matched substring: \"<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"bool \ncharMatch(char s, char p) { \n  if (s == p || p == '.' || p == '*') return true; \n  return false; \n} \n \nbool \npatternMatchHelper(const string& s, int sPos, const string& pattern, int pPos) { \n  int sSz = s.size(), pSz = pattern.size(); \n  if (sPos == sSz - 1 && pPos == pSz - 1) return true; \n  if (sPos >= sSz || pPos >= pSz) return false; \n  char sCh = s[sPos + 1], pCh = pattern[pPos + 1]; \n  if (pCh == '*') { \n    // '*' representing 0 char \n    if (patternMatchHelper(s, sPos, pattern, pPos + 1)) return true; \n    // '*' representing > 1 char \n    if (patternMatchHelper(s, sPos + 1, pattern, pPos)) return true; \n  } \n  if (charMatch(sCh, pCh)) { // '*' representing 1 char \n    if (patternMatchHelper(s, sPos + 1, pattern, pPos + 1)) return true; \n  } \n  return false; \n} \n \nbool \npatternMatch(const string& s, const string& pattern) { \n  return patternMatchHelper(s, -1, pattern, -1); \n} \n \nint \nmain(int argc, char** argv) { \n  cout << \"string vs pattern test:\" << endl; \n  if (argc == 3) { \n    cout << argv[1] << \" vs \" << argv[2] << \" : \" \n        << patternMatch(argv[1], argv[2]) << endl; \n  } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simple iterative matcher, worst case O(m x n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using kmp algorithmn"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Questions is a bit underspecified. Assuming you can have arbitrarily many pattern special chars in there and then it gets complicated. All solutions except the downvoted one (LOL) would fail on that.  I could even write this in an ediotr and it COMPILED and worked out of the box. This is awesome :D."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static String matcher(String val, String pattern) \n    { \n StringBuffer sbuffer = new StringBuffer(val.length()); \n  \n int i = 0; \n int j = 0; \n \n while (i < val.length() && j < pattern.length()) \n { \n     char v = val.charAt(i); \n     char p = pattern.charAt(j); \n \n     if (v == p) \n     { \n  sbuffer.append(v); \n  i++; \n  j++; \n   \n  continue; \n     } \n      \n     if (p == '*') \n     { \n  j++; \n  if (j == pattern.length()) \n  { \n      sbuffer.append(val.substring(i)); \n      return sbuffer.toString(); \n  } \n \n  p = pattern.charAt(j); \n   \n  while (v != p) \n  { \n      sbuffer.append(v); \n      i++; \n      v = val.charAt(i); \n  } \n \n  continue; \n     }   \n \n     if (p == '.') \n     { \n  sbuffer.append(v); \n \n  j++; \n  i++; \n  continue; \n     } \n      \n     sbuffer = new StringBuffer(val.length()); \n     i++; \n     j=0; \n } \n return sbuffer.toString(); \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"int matcher_recurse(char text[], int i, char pattern[], int j) { \n  // If at end of pattern, we have found a match \n  if(pattern[j] == '\\0') return 1; \n  // If not at end of pattern but at end of text, \n  // we have not found a match. \n  if(text[i] == '\\0') return 0; \n  // Try to match any character \n  if(pattern[j] == '.') return matcher_recurse(text, i+1, pattern, j+1); \n  // Trying to match one or more characters \n  // Caveat: This isn't greedy. It tries to use minimum number \n  // of matching characters. \n  if(pattern[j] == '*') { \n    int k = 0; \n    int ret; \n    while(text[i+k] == pattern[j-1]) { \n      ret = matcher_recurse(text, i+k+1, pattern, j+1); \n      if(ret == 1) return 1; \n      k++; \n    } \n    return matcher_recurse(text, i, pattern, j+1); \n  } \n  // Finally, normal text match \n  if(text[i] == pattern[j]) { \n    return matcher_recurse(text, i+1, pattern, j+1); \n  } \n  return 0; \n} \n \nint matcher(char text[], char pattern[]) { \n  return matcher_recurse(text, 0, pattern, 0); \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14722670","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"? Design the recommendation system for search keywords","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"keywords->word analysis -> search data index -> merge & filter data -> ranking -> show back to user."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14712676","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"? Design a system to support Facebook status update","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"This is a good explanation, also is linked to a video where a facebook Engineer briefly explains how the newsfeed works in stack overflow: what-is-the-design-architecture-behind-facebooks-status-update-mechanism Observer Pattern is very heavy for facebook since they have so many users. According to the video they cache the latest status updates for every user in their memcache server, and everytime a user wants to look at their news feed it hits those servers and get the top stories (+ more details)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Use Observer pattern for notifications. All friends are subscribed to one user's activity event. Each user is subscribed to it's activity update event (comment or like on its own activity)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Cassandra would do it.  As a matter of fact, check out this implementation of twitter in Cassandra.  github.com/twissandra/twissandra"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"update all the child nodes in social graph....(using distributed computing )"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14680782","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"Design a system for showing quotes on the web?  For example, when the user is looking at page A, part of which is reproduced in page B, the system could highlight part of page A present the user with a link to page B.  What constitutes a quote?  How do you find quotes?  How do you make it scale to the web?  How do you handle updates?  How would you arrange the servers?  What data structures would you use?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would chunk each page in blocks of text (I can leverage the DOM of the page... the way you optimize this step deeply affect the final result). Then I would apply an hash function on each chunk and represent the page A as the set of that hash numbers A = [h_0, ... h_n].   Now, I can build a inverted index of the hashes so that h_i => {A,B} meaning that the h_i is present both in A and in B. At this point whenever I render the page A I will generate a link to the page B associated to the chunk of text having h_i as hash number.   I will keep updated the index by keep crowling the Web and updating internal representation of the pages and the index like a SE does."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What constitutes a quote? - A fragment of text in a page constitutes a quote. For now we will only consider a text dump rather than gathering any semantic meaning to it.  How do you find quotes?  If more than one page has common occurrences of fragments of text, then it constitutes a quote. As for which page is going to be quoted can be determined by some page rank or the timestamp of the page that was created.  How do you make it scale to the web? We crawl the web across to gather documents. These documents would then have to be compared amongst each other. The comparison can be limited to similar domains of the pages.   How do you handle updates?  The way the information would be laid out is, typically there would/could be a many(children) to one (parent) relationship of pages.  Lets call this a group.  When a new page comes in, there are three possibilities: 1. It is a page which will be added to an already existing grouping.   2. It is a page for which a grouping doesn't exist yet. And this will be the new parent referring to itself. 3. It is a page that will replace the parent of a group.  Even within a domain there would be many such groupings. To assign some priority, we can have the number of children quoting the parent treated as a rank. So the node with the highest rank gets checked against first.   #2 If there is no match against any of the highest rank nodes, then that means the children will not match as well. So we create a new parent with rank 1 and the page points to itself.  #1It matches one of the high rank document and gets added to the other nodes.   #3 Along side checking against the highest rank i.e. checkIfQuoteFrom(parent,new_page) , we should also do a checkIfQuoteFrom(new_page,parent). If it returns true for the second call, then either a) the pages are the same. b)  new_page is the parent of the current parent ( determined by timestamp amongst other metrics).   If it is a) then we can discard it.  If it is b) then we replace the parent with new_page and have the parent join the other set of nodes.  How would you arrange the servers? There would be a set of servers that would be responsible for crawling the web. Another set of servers who would be doing a comparison of pages to get the quotes. As soon as the the crawlers would return back with the set of results, it would be written to some cache and not the database. After massaging the data received is when they will be stored in the db with their state ( discussed above).  Even to fetch the results, we would cache the high frequency requests to ensure minimum db reads.   What data structures would you use?  A decreasing order of nodes ( based on rank ) for the pages to scan. Each of these nodes would be referred to by children. An object representing a domain pointing to these nodes.  A tree like ds that represents the reverse domain and each node there in would store the location to access the aforementioned list."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14688762","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"20","title":"FB has decided to award user who submits the billionth search query on a given day a car, by showing them a banner on their search result page. How would you implement such a system?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"The more pertinent issue is perhaps how you get a user to believe a banner that says \"You are the 1 billionth visitor to this page. Click here to claim your free car. \""},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I would use a separate database just for this purpose. Using a javascript include just for this purpose an ajax request will be sent to the server for every search made. I assume here the database server here is handling the concurrency of all incoming requests. Once the count reaches 1b, the same request for sent for each search will return and ajax create the banner.  The tricky part here is identifying the real winner. For example someone made the 1b search could not be the winner because of latency issues. For this part you cannot do much as there is no way to identify that the request was made as it can be forged from the client."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"fb copies everything from google. Including their interview questions."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"because each request may reach at different server. (for big web balance ^_^) echo server will log the request by timestamp. suppose one request reach at one server. and he want know what's her number. he can simlely count the requests before that timestamp on all servers. and then he will know it's number."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Let's say that there are N search servers, and let's assume that during any given day that N is constant. No servers fail, and no servers are added.  Let's assume that all servers are identical in performance, and that requests are load balancing evenly across the servers.  At midnight we send a message to each of the servers. The message includes the server's allocated server number S, which is in the range 0 to N-1. Each server begins counting search requests from S*(1b/N) to (S+1)*(1b/N).  If a server's counter reaches 1b, then we have a winner. The search results returned from that search server would include some flag that indicates this, which would be used by the front end page rendering servers to mark up the page with the special winner banner.  Although highly performant this solution is not very resilient to failures.But working through this approach is useful as it forms the basis of a better solution.   Let's introduce a new server, of which there is only one, called the counter server. The counter server has a request/response interface that the search servers can use to request a range of numbers. The range allocated could be between 1 and 1b/N... but we'd pick a number greater than 1 to reduce the contention for the counter server, and less than 1b/N so that we were more resilient to failures. Perhaps we'd measure the QPS of the search server and then multiply that by 10s, 30s, or 60s... Let's call the range extent R.  Now if a search server fails or a search server is added the change to N has little effect. We'll have to accept that this weakening of consistency has introduced some fuzziness. If a server fails having processed R/2 requests... the counter server sill thinks that R were counted. So the billionth query is now really the 1b-R/2 query.... which may, or may not, be acceptable...  But, having a single counter server introduces a single point of failure, so we would actually want M counter servers, and we would want them to co-ordinate with each other to ensure that any failure of an individual server has no effect. Co-ordination is expensive in terms of latency as to reach agreement a server has to talk with M-1 servers, twice. But by tuning R to take account of M, then we can build a system that is performant, reliable... and quite accurate."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Guys,  It's impossible to rely on a single centralised counter/machine given the scale of facebook.  The easiest think to do is perform the operation off-line. At runtime, the system should log each search request along with a timestamp and the id of the user the performed the query. This will lead to many different log files across the different servers that handle search. After some time, one can process these files using MapReduce/Hadoop and get the bilionth user.  Then good luck calling the lucky b*st*rd. ;-)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Guys,  It's impossible to rely on a single centralised counter/machine given the scale of facebook.  The easiest think to do is perform the operation off-line. At runtime, the system should log each search request along with a timestamp and the id of the user the performed the query. This will lead to many different log files across the different servers that handle search. After some time, one can process these files using MapReduce/Hadoop and get the bilionth user.  Then good luck calling the lucky b*st*rd. ;-)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would go for holding a counter in Memcached. It's distributed and scales very well. The only thing to consider is incrementing it properly:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"this question is quite easy... just to add a counter on their server... :P"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14681714","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"29","title":"Given a set {1,2,3,4,5...n} of n elements, write code that outputs all subsets of length k. For example, if n = 4 and k = 2, the output would be {1, 2}, {1, 3}, {1, 4}, {2, 3}, {2, 4}, {3, 4}","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"1 #include  \n  2  \n  3 using namespace std; \n  4  \n  5 void print(int *sets, int k) \n  6 { \n  7         for(int i=0; i= n || n-indexA < k-index) \n 21                 return; \n 22  \n 23         sets[index] = A[indexA]; \n 24         subsets(A, n, k, sets, index+1, indexA+1); \n 25         subsets(A, n, k, sets, index, indexA+1); \n 26 } \n 27  \n 28 int main() \n 29 { \n 30         int A[] = {1,2,3,4,5}; \n 31  \n 32         int n=5, k=3; \n 33  \n 34         int *sets = new int[k]; \n 35  \n 36         subsets(A, n, k, sets, 0 , 0); \n 37  \n 38         delete[] sets; \n 39  \n 40         return 0; \n 41 }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"void permutation(int arry[], int n, int k) {                  int total_num_comb = pow(n,k);                   for(i=0; i                 {                                                       for(j=0; j                          {                                   // elements of the set are arry[(i / pow(n,j))%5]                           }              } } if need to remove set with same value then remove the set if all its element index value is same... Complexcity of this code O(n*k) but its better than recursion i guess.... thank you......"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"#include  \n#include  \n \nint k_org; \nint* output; \nprint() \n{ \n        int temp=0; \n        for(temp=0;tempsize)return; \n        if(k==0){print(output);return;} \n        int temp=0; \n        for(temp=0;temp"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"non-recursive java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public static ArrayList> getAllSubSet(int num,int length){   if(length<1){    return null;   }   if(num<1){    return null;   }   if(length>num){    return null;   }   ArrayList> result= new ArrayList>();   for(int i=1;i!=num+1;i++){    ArrayList tmp=new ArrayList();    tmp.add(i);    compute_process(num,length,i+1,1,result,tmp);   }   return result;  }    public static void compute_process(int num,int len,             int curNum,int curLen,             ArrayList> result,             ArrayList current){   if(curNum>num){    if(current.size()==len){     result.add(current);    }    return;   }   if(curLen==len){    result.add(current);    return;   }   ArrayList next=copyList(current);   current.add(curNum);   compute_process(num,len,curNum+1,curLen+1,result,current);   compute_process(num,len,curNum+1,curLen,result,next);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use Narayan Pandita's algorithm on 0000...11111 where there are n-k zeroes and k ones. It is a bit vector representation of the set.  (C++ has std::next_permutation and std::next_combination for this, I believe).  We can also write a recursive version, which uses linear amount of space (and not Theta(n^k)).  Pseudo code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def subset(numbers, size): \n    if (size == 0): \n        raise Exception(\"size is 0\") \n \n    if size == 1: \n        return [[x] for x in numbers] \n \n    if len(numbers) < size: \n        raise Exception(\"Invalid: len(%s) < size(%d)\" % (str(numbers), size)) \n \n    if len(numbers) == size: \n        return [numbers] \n \n    first = numbers[0] \n    rest = numbers[1:] \n \n    ss = subset(rest, size-1) \n    [x.append(first) for x in ss] \n \n    ss2 = subset(rest, size) \n    ss.extend(ss2) \n \n    return ss"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) { \n  ArrayList> ss = subsets(5, 2); \n  for(ArrayList s : ss){ \n   for(Integer i : s) \n    System.out.print(i + \" \"); \n   System.out.println(); \n  } \n } \n  \n private static ArrayList> subsets(int n, int k){ \n  ArrayList> ss; \n  if(k == 1){ \n   ss = new ArrayList>(); \n   for(int i=1;i<=n;i++){ \n    ArrayList s = new ArrayList(); \n    s.add(i); \n    ss.add(s); \n   } \n   return ss;  \n  }else{ \n   ArrayList> newss = new ArrayList>(); \n   ss = subsets(n, k-1); \n   for(ArrayList s : ss){ \n    for(int i = s.get(s.size() - 1) + 1; i <= n; i++){ \n     ArrayList news = (ArrayList) s.clone(); \n     news.add(i); \n     newss.add(news); \n    } \n   } \n   return newss; \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void f(int* arr, int* buf, int k, int arr_cur, int buf_cur) \n{ \n   if(k==0) \n   { \n      printf(buf); \n      return; \n   } \n \n   for(int i=arr_cur;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \nusing namespace std; \nconst int MAX = 1000; \nint a[MAX]; \nbool b[MAX]; \nvoid f1(int n, int k, int indexn, int indexk){ \n int i, j; \n for(i = indexn; i <= n - k + indexk; i++){ \n  if(!b[i]) { \n   b[i] = true; \n   a[indexk] = i; \n   if(indexk == k) { \n    for(j = 1; j <= k; j++) { \n     printf(\"%d \", a[j]); \n    } \n    printf(\"\\n\"); \n   } else { \n    f1(n, k, indexn + 1, indexk + 1); \n   } \n   b[i] = false; \n  } \n } \n} \nvoid f(int n, int k) { \n int i;  \n for(i = 1; i <= n; ++i) { \n  a[i] = i; \n  b[i] = false; \n } \n f1(n, k, 1, 1); \n} \nint main() { \n f(4,2); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \nusing namespace std; \n \nvoid print_comb(string temp,int i,int j,int k) \n{ \n if(j-i+1> n; \n cout << \"Enter k : \"; \n cin >> k; \n print_comb(\"\",1,n,k); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def rec(arr, current_set, index, size) \n    return if (index >= arr.length) \n \n    if (current_set.length == size) \n        puts current_set.to_s \n        return \n    end \n     \n    current_set.push(arr[index]) \n    rec(arr, current_set, index+1, size) \n    current_set.pop \n     \n    rec(arr, current_set, index+1, size) \nend \n \nrec((1..n).to_a, [], 0, k)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  #include  #include   using namespace std;  vector > calcCombinations(vector ip){     vector > op;     if(ip.size() <= 2){                  op.push_back(ip);                  return op;     }                          vector res;     while(ip.size() > 0){                   int num = ip.back();                   ip.pop_back();                   for(int j = 0; j                          res.clear();                           res.push_back(num);                           res.push_back(ip[j]);                           op.push_back(res);                   }     }          return op; }  int main(){     int input[] = {16, 25, 30, 5, 7};     vector ip(input, input + sizeof(input)/sizeof(int));     vector > op = calcCombinations(ip);     int num1, num2;     vector res;     while(!op.empty()){                    res = op.back();                    op.pop_back();                    num1 = res.back();                    res.pop_back();                    num2 = res.back();                    res.pop_back();                    cout<<<\", \"<<    }     getch();     return EXIT_SUCCESS; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Rather than generating all subsets in 2^n time we can do an C(n, k) algorithm for k size subset generation"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def subsets(a, k): \n    def subsets(a, sol, k): \n        if k == 0: \n            print sol \n        for i in range(0, len(a)): \n            newsol = sol + [a[i]] \n            subsets(a[i + 1:], newsol, k - 1) \n    subsets(a, [], k)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my answer. For each element of the array, we have two options, use it or not use it. So we can use an additional array to store the options."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can be done with dynamic programming. Basically  Sol(n,k) = Sol(n-1,k) U \"Sol(n-1,k-1) concat {n}\" I am attaching a recursive solution here."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void subset(List list, int n, int k, int count, int cursor, int cursor2, int[] result) \n    { \n if (cursor >= k) \n { \n     if (count == k) \n     { \n  System.out.println(Arrays.toString(result)); \n     } \n   \n     return; \n } \n  \n for (int i = cursor2; i < n; i++) \n { \n     result[cursor] = list.get(i); \n     subset(list, n, k, count+1, cursor+1, i+1, result); \n } \n    }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14666725","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"8","title":"design the backend system(data structure) of facebook's \"like\" button","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"I would say that the Like button is a way to create an edge in the OpenGraph between the user and the liked entity. So in my opinion the question is more like: Design a way to represent such a huge graph with different type of edges (likes, friendships, etc...)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"OH MY GOOOD that the question?((   my Answer  1. module Core 2. widget Functions of material (like, comments, share, delete for item, all functions for item in one widget) 3. view File, like method 4. controller File, get like method from model subject 5. itemSubject(current material, example Photo User or Wall Action etc.) 6. in modelDbTablesLikes, getLikePaginator 7. in database in table \"core_likes\" like_id resource_type resource_id poster_type poster_id    I answered correctly? :("},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can you provide more details...Design a Button ??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do you mean, design an class for like button? or Designing like button in XAML?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class Button {    Button() { }        Click(){    cout << \"Press Like and your wish will come true!\" << endl;    }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i think it might be something like:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14633700","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"28","title":"Determine winner of 2/9 number game  Two players play the following game: they pick a random number N (less than 2 billion) then,  starting from 1, take turns multiplying the number from the previous turn with either 2 or 9 (their choice).  Whoever reaches N first wins.  The candidate should write a function that given N decides who wins (first or second player)?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Let us define a function is_first_player_winner() which returns 1 if the first player can control the game and force a win. This function returns 0 if the first player cannot do so, and consequently the second player wins.  Now, we can think of a recursive solution. If we want to find out if the first player can force a win for a given value if \"N\", we can consider all possible combinations of the first two moves.  We can divide N by the product of the first two moves and then apply the same function recursively to check if player 1 can force a win (Optimal substructure).  Based on the answer of these sub-problems, we can check if player 1 can force a win or not."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This comment has been deleted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is any player fixed for playing the first chance ? suppose we could assume that P-1 always gets the first chance.  Is this question is about getting closer to N than the other player to win the game ? please correct me if i am getting wrong interpretation of the question"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nusing namespace std; \nint playgame(int n,int turn,int x); \nint main() \n{ \n    int x=playgame(0,0,1); // first argument is n, second is player's turn(0 for first 1 for second) , third is starting no to each player(1) \n    cout<=n &&  x*9>=n) \n     return turn; \n      \n      \n     int l=playgame(n,(turn+1)%2,x*2); \n     int r=playgame(n,(turn+1)%2,x*9); \n     return (l || r); \n      \n     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if the n <= 9, the first player wins if the 9 < n <= 18, the second player wins if the 18 < n <= 36, the first player wins if the 36 < n <= 72, the second player wins  conclusion :  find the least number a, when n <= 9 * 2^a, if a is even, the first player wins, if a is odd, the second player wins"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"input number is N, if there are n steps to finish this game, the step n must multiply 9 to finish the game. the step n-1 must multiply 2 to avoid to reach N/9 (when N/9 > 9, if N/9<9, game over). the step n-2 must multiply 9 to reach the N/9/2  (when N/9/2 > 9, if N/9/2<9, game over). ... finally, the remain number <=9, get the winner.  here is the code (not test)  boolean game(int N, int value, boolean flag) {  if(N <= 9)  {   if(flag) return true;   return false;  }  else  {   int remain = (N%value == 0 ? N/value : N/value+1;   return game(remain, value == 9 ? 2 : 9, !flag);  } }  // true : first win, false : second win boolean game(int N) {  return game(N, 9, true); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution: If player 1 can make one successful combination of moves which is not broken by either choice by player 2 then he wins else player 2 wins. Dynamic programming might be useful although I am not sure how as in dynamic programming we are usually incrementing towards solution here it is other way around.  #include #include using namespace std; bool playgameplayer2(float n); bool playgameplayer1(float n) {      if(n<=9) {              return true;      }                  bool l=playgameplayer2(n/2);      bool r=playgameplayer2(n/9);      return (l || r);       } bool playgameplayer2(float n) {      if(n<=9) {              return false;      }            bool l=playgameplayer1(n/2);      bool r=playgameplayer1(n/9);      return (l && r);       } int main() {     float n;     cin>>n;     bool x=playgameplayer1(n); // first argument is n, second is player's turn(0 for first 1 for second) , third is starting no to each player(1)     cout<    getch();     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nusing namespace std; \nbool playgameplayer2(float n); \nbool playgameplayer1(float n) \n{ \n     if(n<=9) { \n             return true; \n     } \n      \n      \n     bool l=playgameplayer2(n/2); \n     bool r=playgameplayer2(n/9); \n     return (l || r); \n      \n} \nbool playgameplayer2(float n) \n{ \n     if(n<=9) { \n             return false; \n     } \n      \n     bool l=playgameplayer1(n/2); \n     bool r=playgameplayer1(n/9); \n     return (l && r); \n      \n} \nint main() \n{ \n    float n; \n    cin>>n; \n    bool x=playgameplayer1(n); // first argument is n, second is player's turn(0 for first 1 for second) , third is starting no to each player(1) \n    cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I've put some of my earlier comments into a complete solution:  Let F(i, j) be true if the winner of the game is the player whose turn it is next when we start at 2^i*9^j, false otherwise.  Then, since we start at 2^0*9^0 = 1 and with the first player's turn being next, we can write:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ok, so I'm assuming that the number has to be perfectly divisible by 2 or 9 or a combination of these for someone to win (so prime numbers are out for e.g.), in which case I think it's just a case of how many multiples of these are factors of the number in question, and if P1 goes first, then he can only win if there's an odd number of multiples:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// turn = 0 player 1 wins //turn = 1 player 2 wins int Win(int N, int turn, int dice) {  if(N == 0)   return turn  if(N < 0 )   return -1  else  {   Win(N - dice*2, !turn, dice+1);   Win(N - dice*9, !turn, dice+1);  } }  Do let me know If I am making any mistake here"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"classic game-theory question, recursion would give the most concise solution.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this number N can only be represented as 2^k1*9^k2  if ((k1+k2)%2 == 1) 1 win else  2 win"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"probably.... 0 for player 0, 1 for player 1, -1 for impossible cases like 13,17,19,..34,38.."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14607665","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"11","title":"design a distributed system to find the 1000th visitor of google.com","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"In a distributed system, generally a global clock is maintained for the purpose of sychronization. In absence of global clock, the distributed systems send a copy of their local clock (refer Chandy-Lamport algorithm or Vector clocks). A similar way of transmitting the count of the user access should be designed. Note: The above text is not a solution for this question. It is just a thought process that I have shared."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Though why not this be a trick maintain a  counter type variable when a particular system gets a visitor  he reads the count incr the count and then when the new user enters other system , inc the counter,when he gets new user , i guess before a traffic is split they come to a central point where we can keep this counter variable , when counter reaches 1000,i am done  , dont know if its correct"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I believe it is the same problem as to get the kth element from multilple array list, except arrays are far from each other. each array list is sorted by time. right?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O noo i dont know how answered for this question((   i try my answer  Answer  1. module User 2. next, api User  3. next getUser by id method  4. getUser(1000) 5. in model after database find user by id  or just view in database user id  How me correctly answered for this question??   SORRYY IS NOT 1000 USER is just visitor hmmm i think..   IF VISITOR THEN:  1. count visites 2. if COUNT vistes == 1000 then look ip user  Right??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"Go with Circular Queue of size 1000. \n \nif( !isFull(queue) )  \n    when a new user comes fill it into queue, \nelse \n    pop a user from queue and save it to 1000thUser(variable) \n    inQueue the new user  \n \n1000thUser will answer. (check the no of user should cross 1000 otherwise output no. of user visited is < 1000)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-6","title":"abe yaar solution to batao"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-7","title":"<br/>alert(\"sam\"); <br/>"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14601669","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"5","title":"Design the backend for a Gmail-like mail system","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"ALGO ------------- User table ========= 1. Each user has a unique ID which. (we have to generate a random ID) 2. Once user logs in that ID associates with user all time  Message Table ============= 1. Each message has a unique ID (we have to generate random no + UserID from User table)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"There are multiple steps in designing this. format for storing user info is the last thing. First we need to think about data storage. Think about Availability, concsistency, replication, tolerance. For gmail like system, it should be strongly consistent. It should be available and hence it needs to be replicated both within the datacenter as well as across datacenter. BigTable/HBASE like system will work for this. Next level is to support a webservice which can interact with webclient as well as mobile client. This should support any mail format like IMAP/POp3. A load balancer need to be installed at the front to receive connections. when a user sends  a mail, the webservice needs to call the appropriate storage service to store the mail contents to the sent users. It needs to call the notification service to notify the users. This requires that the webclient keep a persistent TCP connection. The server will push the notification on this connection. For mobile clients the notification  service should push the message to mobile push service. This mobile push service needs to handle the case of pushing the notification through carrier. This is the basics. Then we can talk about more features like seraching the older mails, filters, settings etc."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14610666","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"6","title":"design and implement a memcache","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"http://memcached.org/about"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"memcache is nothing but a distributed hash table. A simple enough implementation of a DHT can be found at http : //dks.sics.se/jdht/index.html#example"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Read more about how does memcached manages servers additions and removals:  en. wikipedia.org /wiki/Memcached en. wikipedia.org /wiki/Consistent_hashing www . tomkleinpeter . com /2008/03/17/programmers-toolbox-part-3-consistent-hashing/ offthelip.org /?p=149"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Facebook engineers are crazy."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14614667","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"3","title":"Design a DHT","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I'd think  Consistent Hashing scheme to distribute the (key, value) pair.  Too many details to write here..check out http : //basho.com/tag/ consistent-hashing/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Quite a demand there...I remember doing this as a major project for a course I took."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14578080","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"9","title":"Design a site similar to tinyurl.com","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Everytime when a url is to be shortened, url_id field is incremented, url_id is converted to base-36 ( 26 alphabets + 10 digits ) OR base-62 ( 26 small alphabets + 26 capital alphabets + 10 digits ) which serves as primary key for each tuple.  A string i.e. the actual url is added corresponding to this key in database. The primary key is appended to service providers domain name after '/' and returned to the user.  Usually its better to add a new url_id rather than searching for existence of a url in database. So same url can be shortened to multiple short url's.  But some sites do take care of not adding multiple short url's in database if same user try to reproduce it. They consider user location for this purpose."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"use hashmap,  break url in 2 portion, one is the domain name part and other is rest one,  now apply hashfunction on both separately and concatenate them,(this will reduce chance of collision).  if the given url is already used then return the previously used hash value."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I guess we can apply hashmap funda here............take the sitename as input to hasfunction ...the output of the hashfunction is your tinyURL and map it to the IP address in the hashtable..... :-/"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14594853","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"18","title":"given a stream of quotes for a stock from the last trading day. Assume its already time sorted. Find the maximum amount of money you could have made on this stock by making at most N transactions. A buy and a sell is counted as one transaction. For parts N = 1, N = 2 and N = Inf and the generic solution for N = some number (open ended)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This could be viewed as a weighted interval scheduling problem. The different pairs of buy and sell points are the intervals and the weight is the difference (profit). Getting all possible pairs would be O(n^2)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can make N transactions. Why wouldn't you just solve this problem for N=1 and then execute that transaction N times? If you've found the optimal transaction, you should do that transaction as many times as possible. Is there some sort of limitation where you may only buy or sell one share per unit of time?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assumptions: Generate N transactions (distinct, not duplicate) with buy-sell pairs such that pos of buy is before pos of sell in the quote stream. The following solution is naive O(N*n^2) but can be improved to O(N*nlogn) by sorting the stream array wrt stock values:  static int findMaxProfit(ArrayList stockQuoteStream, int n) {         int totalProfit = 0;         for (int i = 0; i < n; i++) {             int buy = stockQuoteStream.get(0);             int optBuy = 0;             int sell = stockQuoteStream.get(1);             int optSell = 1;             int maxProfit = sell - buy;             for (int j = 1; j < stockQuoteStream.size(); j++) {                 if (buy > stockQuoteStream.get(j)) {                     buy = stockQuoteStream.get(j);                     for (int k = j; k < stockQuoteStream.size(); k++) {                         sell = stockQuoteStream.get(k);                         int currProfit = sell - buy;                         if (currProfit > maxProfit) {                             maxProfit = currProfit;                             optSell = k;                             optBuy = j;                         }                     }                 }              }             totalProfit += maxProfit;             stockQuoteStream.remove(optSell);             stockQuoteStream.remove(optBuy);         }         return totalProfit;     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming no duplicate transactions, the key is to find, for each time t, the max price after t, so you can sell at that time.  O(nlog(n)). I think it could be improved by only sorting the first maxTrades trades, instead of all of them."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int optimal_trades(int *prices, int n_prices, int N) \n{ \n int i, j, n; \n int **arr; \n int max_profit; \n arr = (int **)malloc(n_prices * sizeof(int**)); \n for (i = 0; i < n_prices; ++i) { \n  arr[i] = (int *)malloc((N+1)*sizeof(int)); \n  memset(arr[i], 0, (N+1)*sizeof(int)); \n } \n arr[n_prices][N]; \n \n for (n = 1; n <= N; ++n) { \n  for (i = n_prices - 1; i >= 0; ++i) { \n   for (j = i + 1; j < n_prices; ++j) { \n    if (arr[i][n] < prices[j] - prices[i]) { \n     arr[i][n] = prices[j] - prices[i]; \n    } \n    if (arr[i][n] < prices[j] - prices[i] + arr[j][n-1]) { \n     arr[i][n] = prices[j] - prices[i] + arr[j][n-1]; \n    } \n   } \n  } \n } \n \n max_profit = arr[0][N]; \n for (i = 0; i < n_prices; ++i) { \n  free(arr[i]); \n } \n free(arr); \n return max_profit; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"OMG I ALL NOT UNDERSTAND("},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"there is a m*n*n solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using dynamic programming language."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"int MaxProfit(int dailyStockPrices[], int length) {     int min = dailyStockprice[0];     int maxProfit = 0;     int profit =0;     int buyDate = 0;     int minDate = 0;     int sellDate = 1;     for(int i=1, i < length; i++)     {         if(dailyStockPrice[i] < min)         {             min = dailyStockPrice[i];             minDate = i;         }         else         {              profit = dailyStockPrice[i] - min;                }         if(profit > maxProfit)         {             profit = maxProfit;             buyDate = minDate;             sellDate = i;         }     }      return maxProfit; }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14587009","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"? Write a function that finds all the different ways you can split up a word into a concatenation of two other words.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"for i in range (1, len(str)): \n    leftstring = str[:i] \n    rightstring = str[i:] \n    if isWord(leftstring) and isWord(rightString): \n        print leftstring + \" \" + rightstring + \"\\n\""},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* Write a funtion that finds all the different ways you can split up a word into a concatenation of two other words. */  #include  #include  void getleftstring(char *str,int index, char *leftstring); void getrightstring(char *str,int index, char *rightstring); int main() {         char str[64];         int index = 0;         int len = 0;         char leftstring[64], rightstring[64];         printf(\"Enter the word:\");         scanf(\"%s\",str);         len = strlen(str);         for(index = 0; index < len-1; ++ index)         {                 memset(leftstring,0, 64);                 memset(rightstring,0, 64);                 getleftstring(str,index,leftstring);                 getrightstring(str,index,rightstring);                 printf(\"%s : %s\\n\", leftstring, rightstring);         }         return 0; }  void getleftstring(char *str,int index, char *leftstring) {         char tempStr[64];         int i = 0;         memset(tempStr,0,64);         for(i = 0; i <= index; ++i)         tempStr[i] = str[i];         tempStr[i] = '\\0';         strcpy(leftstring,tempStr); } void getrightstring(char *str,int index, char *rightstring) {         char tempStr[64];         int i = 0;         int len = strlen(str);         memset(tempStr,0,64);         for(index = index+1; index < len; ++index)                 tempStr[i++] = str[index];         tempStr[i] = '\\0';         strcpy(rightstring,tempStr); }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14582042","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"11","title":"range sum query??array??given i,j. get sum array[i,j]:  requirement: n^1/2 space/time complexity","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"I'm assuming you have O(n) time and O(n^1/2) extra space to pre-process the input, and you're then allowed O(n^1/2) time to answer each of any number of queries that could then be sent your way.  Group the input by chunks of O(n^1/2), and store the sum of each (chunk 0: sum of arr[0] through arr[sqrt(n)-1]; chunk 1: sum of arr[sqrt(n)] through arr[2*sqrt(n)-1]; etc.). That's your preprocessing step.   Now, each query is the sum of some number (maybe 0) of complete chunks of size O(n^1/2) plus possibly parts of the two chunks on each end of the range. There are at most O(n^1/2) complete chunks to sum that are part of the range. Now consider the two chunks that are partially covered by the range. Each of these 2 chunks has at most O(n^1/2) numbers, so we can just add the individual numbers to the total and still keep the time within O(n^2).  This analysis assumes that adds are O(1)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"are you posting this because you are taking parallel computing course in U of M?  I am taking it too and this looks quite the same as the homework........so, i wish i could help, but i dont want to"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can be done using segment trees. See: community.topcoder.com/tc?module=Static&d1=tutorials&d2=lowestCommonAncestor O(preprocessing: n, query: n^1/2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"paulbutler.org/archives/data-structures-for-range-sum-queries-slides/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is RMQA problem. This can be done by dividing the array in to n^1/2 parts. i.e, if array has 9 elements {3, 9, 5, 2, -1, 4, 10, 0, 3} Then partition the array in to 3 parts and store min for each part in an array M. so M[0] will have 3 , M[1] will have -1 and M[2] will have 0. If the range is 2 to 6 then we need to get min of a[2], M[1], a[6]. so this is O(n^1/2) space and O(n^1/2) time complexity."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14585874","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"10","title":"Given: for every paper authored, there is a citation count vector. The h-index is a measure of researcher importance. h-index: The largest number i such that there are i papers each with at least i citations.  1. Suppose that the citation-vector is sorted, how to efficiently compute the h-index?  2. Suppose that the citation-vector is not sorted, how to efficiencly compute the h-index? time complexity? an algorithm with time complexity n?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"1. binary-search (O(log(n)). If citations[i] >= i then h >= i (if array's in descending order). 2. Here's a O(n) time & space solution in ruby. The trick is you can ignore citation-counts larger than n."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Binary search for the first part as mentioned by @gnahzy:  public static void main(String[ ] args) {         int [ ] sortedCitation = {21, 17, 12, 2, 2, 1};         System.out.println(\"The h-index value is: \" + getHindexFromSorted(sortedCitation));              }      private static int getHindexFromSorted(int[ ] citation) {         int low = 0; int high = citation.length - 1;         int idx = (low+high)/2;         while(low <= high) {             if(citation[idx] >= idx + 1) {                 low = idx + 1;             }             else {                 high = idx - 1;             }             idx = (low+high)/2;         }         return idx + 1;     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. we can solve this use binary search, which is O(logN).  2. implement @Cole 's idea in python, which is O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For 2, can we use an adapted quick selection algorithm? Instead of searching k-th element, search the largest element a satisfying citation(a) >= num of elements with larger of equal citation."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If there are 'n' papers in total, this problem can be solved in O(n) with space complexity of O(n). Note that, h-index can be between 0 to n. Say if the h-index is 10, this means, there has to be 10 papers with citation count >= 10. So if we can find out the number of papers with citations >=X for every X (and store it in an array C) where X ranges between 0 to n, then by scanning the count array C from the right to left, we can find the h-index at index i where i == C[i].  Pseudocode: input array A of length n.  - init array C[0] to C[n] with 0 - foreach p in A, if p >= n, c[n]++; else c[p] +=1 - for i=n-1 to 0, c[i]=c[i]+c[i+1] - for i=n to 0, if c[i] == i return i"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14584867","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"6","title":"Definition w-index: The largest number i such that there are i papers, with the lowest paper having at least one citation, the next one has at least two citations and so on, ith paper has i citations.    The citation vector is sorted. How efficiently can you compute the w index? Code this","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What operations?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int wIndex (int[] citation) { \n    if (citation == null) return -1; \n    int w = 0; \n    for (int i = 0; i < citation.length; i++) { \n        if (citation[i] > w) w++; \n    } \n    return w;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"do a binary search on by comparing (array[index]-index)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Try Fenwick tree"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14569808","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"24","title":"Write a function that takes 2 arguments: a binary tree and an integer N, it should return the N-th element in the inorder traversal of the binary tree. I asked the interviewer if I could use a 3rd argument to store the result; he said okay.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"code submitted: \npublic  class Result { \n        Node foundNode; \n        int iteration; \n    } \n \n    public  class Node { \n        int value; \n        Node left; \n        Node right; \n \n        public Node(int value) { \n            this.value = value; \n        } \n \n       \n    } \n \npublic  void findNth(final Node node, int N, final Result result) { \n        if (node.left != null && result.foundNode == null) { \n            findNth(node.left, N, result); \n        } \n \n        // handle root \n        result.iteration++; \n \n        if (result.iteration == N) { \n            result.foundNode = node; \n \n            return; \n        } \n \n        if (node.right != null && result.foundNode == null) { \n            findNth(node.right, N, result); \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this ?  inorder traversal of a binary tree prints elements in a sorted order .  So we can have a method that takes two arguments :the binary tree as an array and the integer n . Sort the the elements and output the Nth element in it?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node* findNthElementInorder(node *root,int n)  {  static int a;  static struct node *nthelement=NULL;    if(root==NULL)   return NULL;  if(nthelement==NULL)  {  nthelement=findNthElementInorder(root->left,n);  a++;  if(a==n)   return root;  nthelement=findNthElementInorder(root->right,n);  }  else  {   return nthelement;  }   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use morris inorder traversal to get the required answer   or just use recursion"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Untested recursive method"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void fun(tnode root,int n){   if(root!=NULL){   if(n==1){   printf(\"%d\",root->data);return;   }   else{     fun(root->left,n-1);    fun(root->right,n-1);   }   } else{   printf(\"error\"); return;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Tree is in ascending inorder traversal."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a solution in java. The hard part of this algorithm is communicating the count of visited nodes between recursive calls. It would be trivial if there was some out-of-scope variable, but that is ugly and not needed. Java is pass by value, so using the primitive java int does not retain its value between recursive calls, however an Integer object wrapper will, because all we are doing is passing a copy of the reference to the integer object, which any recursive call can mutate."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void findNthElementInorder(struct TNode* node,int N, int& count, struct TNode*& nthNode)  \n{ \n  assert(N>=0); \n if(node && count!=N) { \n  if(nthNode==NULL) { \n   findNthElementInorder(node->left, N, count, nthNode); \n    \n   // PROCESSED ONE ELEMENT INCREMENT THE COUNT \n   count++; \n      if(count==N) { nthNode = node; return; } \n    \n   findNthElementInorder(node->right, N, count, nthNode); \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node* f(Node* r, int *n) \n{ \n    if(*n<0 || r==null) \n      return null; \n \n    if(*n==0) \n      return r; \n  \n    Node* t = f(r->left, n); \n    if(t) \n      return t; \n    \n    if(*n==0) \n       return r; \n \n    *n = (*n)-1; \n    return f(r->right, n);            \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here I am assuming that the answer can be stored in an argument variable passed into the input."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int inorderN(node * x, int &N) {   if(N <=0)     error(??N must be positive!??);    if(x==Null)       return -1;   N = N - 1;   if (N == 0)     return x->key;   int s = inorderN(x->left,N);   if (N == 0)     return s;   s = inorderN(x-right,N);   if (N == 0??     return s;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is perfect for iterative inorder traversal which maintains the function signature and computes the function easily.  private static TreeNode findNthInOrderIterative(TreeNode root, int n) {         Stack s = new Stack();         TreeNode curr = root;         boolean done = false;         while (!done) {             if (curr != null) {                 s.push(curr);                 curr = curr.left;             }             else {                 if(!s.empty()) {                     curr = s.pop();                     n--;                     if(n == 0) {                         return curr;                     }                     curr = curr.right;                 }                 else {                     done = true;                 }             }         }         System.out.println(\"Couldn't find element...returning the tree root\");         return root;     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use modified recursive inorder \n \nmodified_inorder(node *pt,int n) \n{ \n if(pt!=NULL) \n { \n modified_inorder(pt->left,n); \n n--; \n if(n==0) \n  cout << pt->info<right,n); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void nthElement(Node *node, int &n, int &key) {  if (node == NULL)  {   return;  }   nthElement(node->left, n, key);  n--;  if (n == 0)  {   key = node->v;   return;  }  nthElement(node->right, n, key); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node * Findnth( node * root, int n) { Stack stack;  While (root != null){ Stack.push(root); Root  = root.left; }  While (!stack.empty() && n != 0)) {     Root  = stack.top();     Stack.pop();     N--;  // a node is getting visited.     If ( n == 0) return root;     // this node's left sub tree has been visited already, it itself has been visited as well. Now we need to concentrate on its right sub tree.    Root  = root->right;     While (root  != null) {          Stack.push(root);           Root  = root->left;      } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"memory O(n) and iterative.  computation complexity equivalent to in order traversal.  #include  #include   class BinaryTreeNode { private:  int data;  BinaryTreeNode *left;  BinaryTreeNode *right;  public:  BinaryTreeNode *FindNthInOrderNode(int n); }; BinaryTreeNode * BinaryTreeNode::FindNthInOrderNode(int n) {  BinaryTreeNode **stack = (BinaryTreeNode **)malloc(n* sizeof(BinaryTreeNode *));  BinaryTreeNode *curr;  int stack_items = 0;  int add_position = 0;  int remain = n;   curr = this;  while (curr != NULL) {   stack[add_position] = curr;   curr = curr->left;   if (stack_items < n) {    stack_items++;   }   add_position = (add_position + 1) % n;  }   curr = NULL;  while (remain != 0 && stack_items != 0) {   /* POP */   --add_position;   --stack_items;   if (add_position < 0) {    add_position += n;   }   curr = stack[add_position];   if (--remain == 0) { // visiting current.    break;   }   curr = curr->right;   while (curr != NULL) {    stack[add_position] = curr;    curr = curr->left;    if (stack_items < n) {     stack_items++;    }    add_position = (add_position + 1) % n;   }  }   free(stack);  return curr; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node *findElement(Node *root, int n, int &num) \n{ \n if (root == NULL) \n   return NULL; \n \n Node *left = findElement(root->left, n, num); \n if (left != NULL) \n  return left; \n \n num++; \n if (n == num) \n  return root; \n \n Node *right = findElement(root->right, n, num); \n \n return right; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def inorder_n( x, n ) \n return 0,nil if x.nil? \n \n left,node = inorder_n( x.left, n ) \n return left+1, node unless node.nil? \n n -= left \n \n return left+2,x if n == 0 \n n -= 1 \n \n right,node = inorder_n( x.right, n ) \n return right+1, node unless node.nil? \n n -= right \n \n return n,nil \nend \n \n \n \n_,node = inorder_n( root, n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"morris inorder traversal."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14548838","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"28","title":"Determine the 10 most frequent words given a terabyte of strings.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"1. Do External Sort (merge sort in file). 2. Collapse duplicates to \"num, word\", e.g. \"1025, the\". 3. While doing step 2, keep a max heap of word frequencies.  This way there is no extra storage needed, but the complexity is O(N*log(N)).  If extra storage is permitted, you can build a hash file, where line number corresponds to hash index. You'll probably end up with using twice the original storage though. Also, random access on disk will probably be less efficient than the sorting in External Sort, since lines will be read sequentially and written back sequentially."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Create a hash table, the key is word, and value is a counter. Trace all words, if is not existed in hash, add it with value 1, otherwise, increment the value.  In the same time using a list of pair key value, can hold the most ten frequent repeated words, and if a word after increment has a value of more than the minimum in this list, replace with that and remove the minimum in list.    Notice the total English words! The Second Edition of the 20-volume Oxford English Dictionary contains full entries for 171,476 words in current use, and 47,156 obsolete words. To this may be added around 9,500 derivative words included as subentries.  anyways, this is a simple code to handle this case:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Instead of using hashtables, we can use a different data strcuture to indicate the frequency of the occurances. I ve written a basic program for any number of words based upon input.   The structure has count of occurences of a word ending with that node. Based upon the next letter we create an array of 26 letters (assuming all the letters are small , doesnt matter if mixed as well) from the first node. And the process resumes till last letter."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what if we are allowed to use a distributed setup something like mapreduce and we use the hashmap solution on each  computer and then finally merge the each solution .  i think this can be solved by map reduce approach"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"create a min-heap of 10 nodes. Node structure would look like:  srtuct node{ int frequency; char *word; node * left; node *right; }  The min heap is created based on the frequency of the word. Also maintain a concurrent hashmap backing this. With every insert on the hashmap check if the frequency of the inserted element is greater than the min frequency currently on the min-heap then delete the min-heap element-> place it into the hashmap because later it could re-enter the min-heap. Insert the element from the hashmap back into the min-heap and heapify. The insertion into the min-heap has to be an atomic operation. I think this would have good throughput.  Alternatively map-reduce could also be the way to go.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use Hash-Map and Min Heap"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Well, there could be 2 different definition of word. 1. A word in English dictionary, the biggest I have seen so far has 400k words. 2. A sequence of character separated by separator like space, full stop, etc.  if we can say that they all from English dictionary or another languages dictionary.  Or even if we can be sure that all sequence of words in our terabyte of file belongs to word in any language.  Then total set of words is limited can easily loaded into hash table in memory."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"Partition the data into subsets(i.e. buckets of reasonable size in RAM), and do parallel processing on each node(bucket). Each node will return the 10 most-frequent strings and their counts, as a sorted array where the index is the rank. This is essentially mergesort, done in parallel."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14463150","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"37","title":"A string s is said to be unique if no two characters of s are same. A string s1 is producible from s2 by removing some of the characters from s2. A string s1 is said to be more beautiful than s2 if length of s1 is more than s2 or if both have same length and s1 is lexicographically greater than s2( ex: ba is more beautiful than ab) Input: is a string which can be of maximum 10^6 characters, you have to produce the most beautiful unique string out of the given string.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"#include  int main() {  char s[1000000];  int p[257],i,j,f,r,p1,p2,k,t;  scanf(\"%s\",s);  for(i=0;i<257;i++)   p[i]=-1;  for(i=0;s[i]!='\\0';i++)  {   r=1;   p1=-1;   p2=-1;   for(j=0;p[j]!=-1;j++)   {    if(p1==-1 && p[j]==s[i])    {     p1=j;     for(k=j+1;p[k]!=-1;k++)     {      if(p[k]>s[i])      {       p2=k;       break;      }     }     if(p2>-1)     {      for(k=p1+1;k     {       r=0;       for(t=i+1;s[t]!='\\0';t++)       {        if(s[t]==p[k])        {         r=1;         break;        }       }       if(r==0)        break;      }     }    }    if(p2>-1 && r==1)     p[j]=p[j+1];   }   if(p2>-1 && r==1)    p[j-1]=s[i];   else if(p1==-1)    p[j]=s[i];  }  printf(\"\\n\");  for(i=0;p[i]!=-1;i++)   printf(\"%c\",p[i]);  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I didn't understand the question correctly. If the given input string is str1, we have to 'produce' a new string str2 out of str1. So that means we might have to remove some characters from str1. So length of str2 might be less than str1. And according to the definition of beautifulness str2 can not be more beautiful than str1 because it's length might be smaller than str1 !! Can you please elaborate with an example ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This comment has been deleted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am thinking of the following approach, please correct me if I am wrong: Input = (0,10^6] length string Read characters one by one Keep a bitmap of the read characters, if the character has been read, then discard it and move to next Keep a max-heap of characters, put the incoming character in the max-heap Remove the characters from max-heap one-by-one and we will have the beautiful string"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I'm assuming the substring doesn't have to be contiguous. One observation is that every unique character in s2 will be in the solution s1, the question is which one, if there are duplicates. Which one to choose depends on the character that comes after, because we want to increase lexicographical order. For example, if we have \"aba\", we have a choice which 'a' to take. If we choose the first one, then we the decrease lexicographical order compared to choosing the second 'a'. I propose an algorithm that steps through s2 and greedily chooses every character it sees. When it runs into a character it has already seen, there is the choice whether to keep the one it already has, or go with the  newer one. That depends on which character that comes after the first occurrence. If it is 'smaller' then we keep it the first occurrence, otherwise we choose the second one."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about like this?  S: is the input string Cnt[]: array or hash where Cnt[i] is the number of occurences of character i in S.  - In one pass, we can calculate the number of occurences of each character in S by just using hash or array.   As scanning the string from left to right, Maintain the most beautiful string say P that could be produced from the substring 0..i for each index i."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Because longer strings are always more \"beautiful\", and because our output string must be \"unique\", we know that the most beautiful valid output string should be some permutation of the unique characters in the input string. We can easily find the set of unique input characters, sort them by lexicographical value, and add them to the output string in sorted order (resulting in the optimal output string in terms of \"beauty\"). However, this could lead to an output string which could not be created by simply removing input characters. To fix this, we need some way of ensuring that our output character ordering exists (not necessarily consecutively) somewhere in the input string.   Eg. Imagine we have the input string INPUT == \"addabacdb\". Then the optimal valid output is \"dbac\", because it is the most beautiful unique string whose character ordering exists in INPUT. We can see this by denoting removed characters with '-': \"-d--ba-c--\". The lexicographically sorted set of unique characters in this example is UNQ = {'d', 'c', 'b', 'a'}. We start at UNQ[0] == 'd', and attempt to add it to the (empty) output string OUTSTR without breaking the rules. This amounts to finding the first position of 'd' in INPUT and ensuring that all the rest of the characters in UNQ ('c', 'b', 'a') can be found somewhere after that position. In this case, the first occurance of 'd' is INPUT[1], so we must ensure that 'c', 'b', and 'a' can all be found after INPUT[1]. They can, so we can safely append 'd' to OUTSTR, remove it from UNQ, and move on to the next character in UNQ. We also set CURPOS, representing the last INPUT position we added to the output, to 1.   At this point, we have:  OUTSTR = \"d\" CURPOS == 1 UNQ = {'c', 'b', 'a'}  We again look at UNQ[0] == 'c'. We search INPUT, starting from CURPOS == 1, and find a 'c' at INPUT[6]. Unfortunately, one of the remaining characters in UNQ ('a') cannot be found after INPUT[6]. This means we cannot added 'c' to the output yet. So, we move on to UNQ[1] == 'b'. Searching again from CURPOS == 1, we find a 'b' at INPUT[4]. Both 'c' and 'a' can be found after INPUT[4], so we can go ahead and append 'b' to OUTSTR, remove it from UNQ, and set CURPOS = 4.   Now, we have: OUTSTR = \"db\" CURPOS == 4 UNQ = {'c', 'a'}  We start again at UNQ[0], which is still 'c', and try again to add it to the output. Starting from CURPOS == 4, we find a 'c' at INPUT[6]. However, we still cannot add 'c' to the output, because the remaining 'a' in UNQ cannot be found anywhere after INPUT[6]. We move on to UNQ[1] == 'a' and, starting from CURPOS == 4, we find it at INPUT[5]. The remaining 'c' in UNQ can be found after INPUT position 5, so we go ahead and add 'a' to OUTSTR, remove it from UNQ, and set CURPOS = 5.  Now, we have: OUTSTR = \"dba\" CURPOS == 5 UNQ = {'c'}  Because we are left with only one remaining character in UNQ, we can safely add it to OUTSTR and call it a day. OUTSTR now contains the most \"beautiful\" valid output string \"dbac\".  Here's my C++ code, with appropriate variables named to match the explanation above:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I guess we have to find the Longest (lexicographically decreasing) subsequence of the given string."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"O(n) iterative.  #include  #include  #include   static char * most_beautiful_unique_string(const char *str, int n) {  int a[256];  int i;  char *result = (char *)malloc(257);  char *writer = result;   while (n--) {   a[(int)*str++] = 1;  }   for (i = 255; i >= 0; --i) {   if (a[i] == 1) {    *writer++ = (char)i;   }  }   *writer = '\\0';  return result; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I am assuming it is not case sensitive.  int charMap[256];  for ( i = 0; i < 256; i++) {  charMap[i] = 0; }  for ( i = 0; i < str.length(); i++) {    charMap[str.at(i)] + =1; }  for ( i = 0; i < str.length(); i++) {    if ( charMap[str.at(i)]) == 1) {       cout<< str.at(i);       charMap[str.at(i)] -= 1;    } else {       bool foundGreater = false;      for ( j = str.at(i) + 1; j < 256; j++ ) {          if ( charMap[str.at(j)] > 0) {             greaterFound = true;        }    } if ( !foundGreater ) {      cout<< str.at(i)  } charMap[str.at(i)]  -= 1;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"static String mostBeautifulUniquProduction(String s1){ \n   \n  ArrayList selected = new ArrayList(); \n  HashMap charMap = new HashMap(); \n  for (int index = 0; index < s1.length(); index++){ \n   Integer count = 1; \n   if (charMap.containsKey(s1.charAt(index))){ \n    count += charMap.get(s1.charAt(index)); \n   } \n   charMap.put(s1.charAt(index), count); \n  } \n   \n  Comparator newComparator = new Comparator() { \n \n   @Override \n   public int compare(Character o1, Character o2) { \n    return -1 * (o1.compareTo(o2)); \n   } \n  }; \n  PriorityQueue pQueue = new PriorityQueue(charMap.keySet().size(), newComparator); \n  pQueue.addAll(charMap.keySet()); \n   \n   \n  for (int itr = 0 ; itr < s1.length(); itr++){ \n   if (pQueue.isEmpty()) break; \n   Character biggest = pQueue.peek(); \n   Character key = s1.charAt(itr); \n   Integer count = charMap.get(key); \n   if (count == 1){ \n    selected.add(key); \n    count -= 1; \n   } else if (key.equals(biggest)){ \n    selected.add(key); \n    count = 0; \n    pQueue.poll(); \n   } else { \n    count -= 1; \n   } \n   charMap.put(key, count); \n  } \n  return getStringRepresentation(selected); \n } \n  \n static String getStringRepresentation(ArrayList list) \n {     \n     StringBuilder builder = new StringBuilder(list.size()); \n     for(Character ch: list) \n     { \n         builder.append(ch); \n     } \n     return builder.toString(); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"// this function prints the most beautiful string using C#. \n// A hashtable is constructed to record the positions of each char. \n// The hashtable keys are examed from the greatest (e.g. 'z) to the  \n// smallest (e.g. 'a') one by one against the input string. If this char \n// is duplicated, keep the first one that is greater than its next neigbor and \n// delete all other occurrences by marking as spaces (do not shift chars so as \n// to reduce cost). At last, print the string by ignoring spaces. \n// \n// Assumption: the input string does not use spaces so that spaces can be used as marker. \n// If the input string does not have dup chars, the original string is printed as it is  \n// already the most beautiful one. \nvoid f(string s) \n{ \n   HashTable> h = new HashTable>(); \n    \n   // \n   // construct the hash table using s, recording the positions of each char. \n   // \n   for(int i=0;i list = new List(); \n         list.Add(i); \n         h.Add(s[i], list); \n      } \n      else \n      { \n         h[s[i]].Add(i); \n      } \n   } \n   \n   // sort keys so that we can remove the chars from 'z' to 'a'. \n   h.Keys.Sort(); \n \n   for(int i=h.Keys.Count-1; i>-1;i--) \n   { \n      char ch = h.Keys[i]; \n \n      // if this char has >1 occurrences \n      if(h[ch].Count>1) \n      { \n            bool OneKept = false; // is one such char kept from deleting? \n \n            for(int j=0;j= s.length || s[idxS] > s[nextNonSpace] || j == h[ch].Count-1)) \n               { \n                   OneKept=true; \n               } \n               else \n               { \n                   // delete other dup chars by marking as space. \n                   // don't shift chars to avoid heavy cost. \n                   s[idxS] = ' '; \n               } \n            }  \n      } \n   } \n       \n   for(int i=0;i"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14491904","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"6","title":"freinds can someone please xplain  N-Queen standard problem of DS It goea like..how would you place N Queens on a N*N chess board such that no one can attack rest.. Please xplain logic..I have the code  Thanxs in advance/.........","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Backtracking. You start column-wise. Place one queen on any of the rows in first column. Now start trying to place the queens in next columns such that so CLASH is encountered. If you are able to reach the end of loop - loop variable = 8 columns, a solution exists, and you can print it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the logic of 8-queen or in general n-queen is based on the backtracking fundamentals.  1)you start with row 1 at a time and put the queen at possible (j=1 to Col) position choosing only 1 at a time. checking if it is safe to place the queen at this position or not. 2) then you call the function recursively on the next row which again tries to choose a col which can be a potential candidate for valid position and so on  3) till you reach to the end of row with out violating the attacking condition.  This is like DFS and each step checking if it is safe or not if not then you try the next col position. If all the positions in a specific col are unsafe then you backtrack to previous row and unset the col and try next col in that row and so on."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"As some others mentioned it uses backtracking principle. Here's a rough pseudo code."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#include \n#include \n#include \nint a[30],count=0; \nint place(int pos) \n{ \n int i; \n for(i=1;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"you can understand the N Queens problem by watching this video tutorial on N Queens Problem youtu.be/p4_QnaTIxkQ"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#include  \n#include  \n \nint count = 0; \nvoid solve(int n, int col, int *hist) \n{ \n if (col == n) { \n  printf(\"\\nNo. %d\\n-----\\n\", ++count); \n  int i,j; \n  for ( i = 0; i < n; i++, putchar('\\n')) \n   for ( j = 0; j < n; j++) \n    putchar(j == hist[i] ? 'Q' : ((i + j) & 1) ? ' ' : '.'); \n \n  return; \n                } \n \n# define attack(i, j) (hist[j] == i || abs(hist[j] - i) == col - j) \n int i,j; \n for ( i = 0, j = 0; i < n; i++) { \n  for (j = 0; j < col && !attack(i, j); j++); \n  if (j < col) continue; \n \n  hist[col] = i; \n  solve(n, col + 1, hist); \n } \n} \n \nint main(int n, char **argv) \n{ \n if (n <= 1 || (n = atoi(argv[1])) <= 0) n = 8; \n int hist[n]; \n solve(n, 0, hist); \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14469817","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"22","title":"How will you implement your own rand() such that it returns an integer from 0 to n-1 with equal probability?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"The Random.next()[1] function is implemented using a linear congruential pseudo random number generator[2].  This is a simple algorithm where you take the seed value and generate random numbers using the following formula:  X(0) = seed >> 2^48. X(n+1) = (25214903917* X(n) + 11) (mod 2^48)   This gives us a random number generator with a uniform distribution between 0 and 1. If you need a guassian distribution, Random.nextGuassian() [3] implements it using the Marsaglia's polar method. [4]  Refer to Java doc for [1] and [3]. Refer to wikipedia for [2] and [4]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I suppose what facebook guys wanted to hear is to design a (almost)nondeterministic source of randomness that makes the best generic use of what the machine or the OS would provide indirectly.  #OS scheduling provides us with such a mechanism:  Pseudo code:  Function randomBinary returns boolean    yield OS scheduler;    Get system processor cycles count or maybe RTC based nano level counter    Check if the counter is even or odd;    If odd        Return 1;    Else        Return 0;   Function Rand(int n ) returns integer      Declare new random number R = 0;      While (R < n)          Call randomBinary and modify the LSB of R          Shift R by 1      Return residual and random part of R   I think this will pass most of the statistics test.  # other solution would be linear congruent approach"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int randomNumber(int no) {     return System.getCurrentTimeInMillis()%no; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int Rand_Num_Equal_Pro(const int n){ static int Flag[n]; int r, temp; time_t t; struct tm *t; t= localtime(&t); r= t->tm_sec+ t->tm_min*10+ t->tm_hour*100;  srand(r); r= rand(); r= r%n; temp= r+1;  if(Flag[r]){   while(Flag[temp]&& (temp%n)!= r) temp++;      if((temp%n)== r){    for(int i= 0; i    Flag[i]= 0;    return r;   }   else{   Flag[temp%n]= 1;   return temp%n;   }  }  else{  Flag[r]= 1;  return  r;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"check en.wikipedia.org/wiki/Mersenne_twister"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"check Mersenne twister on wikipedia"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"search Mersenne twister"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"1) Create a dyanamic memory of type char ie, size will be 1. 2) Store the value of the memory to a integer variable. 3) Take the mod of the interger variable for n we will get a random function in the range 0-n1  int rand(int num){  char * a=(char *)malloc(sizeof(1));  int b= a;  b=b%num;  return b; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This comment has been deleted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"the problem seems similar to shuffling a deck of cards. now what you would do is, generate a random number between 0 - n-1 and choose that index to mark the entry/value (i.e. arr[random_i] as dead by swapping it with the start index which also keeps moving with each new number being generated).  i.e. swap (arr[startIndex], arr[random_i]).  and you generate number between startIndex and n-1 and keep doing this n times. Then the array contains the numbers generated with equal probability."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14474750","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"16","title":"You have a stream of bytes from which you can read one byte at a time. You only have enough space to store one byte. After processing those bytes, you have to return a random byte. Note: The probability of picking any one of those bytes should be equal.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"public static int getRan(Node m) \n { \n  int range=1; \n  Random random=new Random(); \n  int ret=(Integer)m.getValue(); \n  while(m.next!=null) \n  { \n   m=m.next; \n   range++; \n   if(random.nextInt(range)==0) \n   { \n    ret=(Integer)m.getValue(); \n   } \n  } \n  return ret; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Reservoir Sampling."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"You need to be able to store how many elements you've seen so far (which presumably can't fit into a byte) for this problem to be possible."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I think, firstly, you should know how many bytes of this stream. For example, if there are 5 bytes in this stream. Then, for the first byte: You can use: if ( (int)(Math.Random()*5)==0 ){ Store this byte; return this byte; } for the second byte: if ( (int) (Math.Random()*4) ==0 ){ Store this byte; return this byte; } ......... for the kth byte of n byte: if ( (int) (Math.Random()*(n-k+1)) ==0 ){ Store this byte; return this byte; } ..... every byte have the same probability"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"tag"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14408731","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"12","title":"input a text and a pattern. The pattern can have *, say a*b, a**b, *ab...  find whether the pattern matches the whole input text.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use recursion. When a * is found and it is not the ending char in the pattern, find each occurrence of the next non-* char of the pattern in the text, call recursion for the substring in the text starting from each occurrence. Return true if any of the recursion is true."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here is the code. It checks if the second string is a pattern in a first string. for instance try: ./a.out \"This is the string \" \"is*is\" ./a.out \"This is the string d \" \"*is*is*dd\" ./a.out \"This is the string dd \" \"*is*is*dd\" ./a.out \"This is the string dd \" \"*is*is*dd**k\"  the code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use kmp as follows: 1. cut down the head and tail which is not '*' from the pattern, and match the head and tail with the text. If match, cut down the text head and tail and go on to 2; returns false otherwise. for example, text: abcdadabaccdba, pattern: ab*dad*ba*dba, then head = 'ab' and tail = 'dba', both match the text head and tail correspondingly. so the new text would be 'cdadabacc' and new pattern '*dad*ba*'. 2. split the remaining pattern by * and build the kmp for each part, then use them to match the text one by one. in the above case, '*dad' matches 'cdad', then '*ba' matches 'aba', the last '*' is for the tailing 'c'. done."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Kmp algorithm with some modification works fine  #include #include using namespace std; int array[100]; void precompute(string original,string matched) {  int k=0;  array[0]=0;  for(int q=1;q {   while(k>0&&(matched[k+1-1]!=matched[q])&&matched[k+1-1]!='*')   {    k=array[k-1];    //cout<<<\"hii\"<        }      if(matched[k+1-1]==matched[q]||matched[k+1-1]=='*')    k=k+1;   array[q]=k;  // cout< } } int main() {     //Kmp-algorithm     string original,matched;  cin>>original;  cin>>matched;  int q=0;  precompute(original,matched);  for(int i=0;i {   while(q>0&&(matched[q+1-1]!=original[i]&&matched[q+1-1]!='*'))    q=array[q-1];   if(matched[q+1-1]==original[i]||matched[q+1-1]=='*')    q=q+1;   if(q==matched.length())   {    cout<   q=array[q-1];   }     }     system(\"pause\");       return 0;       }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please correct me if I was wrong:  it is true that an input string matches the given pattern once satisfying: 1) pattern length equals with input string's length; 2) fixed characters in pattern match the ones in the same positions of input string"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Try it out at: ideone.com/eG3sQ"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include using namespace std;   struct node {  char a;  node *l;  int flag; }*start;  bool matchReg(node *q,int i);  string t,p; int n,m;  int main() {  start=NULL;  node *temp,*q;    cin>>t;  cin>>p;      n=t.length();  m=p.length();    int i;  i=0;    if(t[i]=='*')   i++;    while(i {   if(t[i+1]=='*' && t[i]!='*')   {    if(start==NULL)    {     start=new node;     start->a=t[i];     start->l=NULL;     start->flag=1;     temp=start;    }    else    {     q=new node;     q->a=t[i];     q->l=NULL;     q->flag=1;     temp->l=q;     temp=q;    }    }   else if(t[i]!='*')   {    if(start==NULL)    {     start=new node;     start->a=t[i];     start->l=NULL;     start->flag=0;     temp=start;    }    else    {     q=new node;     q->a=t[i];     q->l=NULL;     q->flag=0;     temp->l=q;     temp=q;    }    }   i++;   }    if(t[i]!='*')  {   if(start==NULL)   {    start=new node;    start->a=t[i];    start->l=NULL;    start->flag=0;    temp=start;   }   else   {    q=new node;    q->a=t[i];    q->l=NULL;    q->flag=0;    temp->l=q;    temp=q;   }   }      if(matchReg(start,0))   cout<<\"Accepted\";  else   cout<<\"Rejected\";      }  bool matchReg(node *q,int i) {  if(q==NULL && i==m)   return true;  else if(q==NULL && i!=m)   return false;  else if(q->l==NULL && q->flag==1 && i==m)   return true;  else if(q!=NULL && i==m)   return false;  else if(q->a!=p[i] && q->flag==0)   return false;  else if(q->a==p[i] && q->flag==0)   return matchReg(q->l,i+1);  else  {   bool b1=matchReg(q->l,i+1);   bool b2=matchReg(q,i+1);   bool b3=matchReg(q->l,i);      return (b1||b2||b3);  }     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Another recursion using different function signature."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"kmp pattern matching algorithm can be used"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14412669","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"32","title":"Input:  3 3 1 2 nny nnn ynn output: 2 1 3 n size of permutation P.First line of input is n.Second line is the permutation P.A Permutation X is said to be lexicographically smaller than Y if for all digits till i X[i]=Y[i] and for i+1 X[i]<=Y[i]so you can exchange the integers in the given permutation P if character j of line i+2 is 'y' then i th and j th integer in P can be exchanged . Output:Lexicographically smallest premutation of the given P using rule","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Make a graph where each vertex is a position in the array (0 to N-1). Let an edge connect two vertices whenever swapping the elements at those two positions is allowed. You need to get all the connected components of this graph, and then for each connected component, sort the elements available within that connected component so that the smallest positions have the lowest possible elements (smallest index within the connected component gets smallest element, second smallest index gets second smallest element, etc.). When this is done for all connected components, you will have the lowest possible permutation. This algorithm is about as efficient asymptotically as the sorting algorithm you use. Since all steps except sorting are O(N), it's asymptotically optimal."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"#include #include using namespace std; vector connected; void connectedComponent1(vector > v,vector &visited,int condition,int j1) {     visited[j1]=1;      for(int j=0;j            if(v[j1][j]==1&&visited[j]==0)             connectedComponent1(v,visited,1,j); }     void connectedComponent(vector > v,vector &visited,int condition,int j1) {     for(int i=0;i    {         if(visited[i]==0)         {                          vector visited2=visited;             visited[i]=1;             for(int j=0;j            if(v[i][j]==1&&visited[j]==0)             connectedComponent1(v,visited,1,j);                             for(int i1=0;i1                {                 if(visited2[i1]==0&&visited[i1]==1)                 connected.insert(connected.end(),i1);                 }                     connected.insert(connected.end(),-1);                             visited2.clear();                     }           }     }     int main() {     int n,condition=0;     cin>>n;     int array[n];     for(int i=0;i    cin>>array[i];     vector > v1(n,n);     vector > v(n,n);     vector visited(n);      for(int i=0;i    {         for(int j=0;j        cin>>v1[i][j];         visited[i]=0;     }         for(int i=0;i    {         for(int j=0;j        {             if(v1[i][j]=='y'||v1[j][i]=='y')             v[i][j]=1;             else             v[i][j]=0;         }         }         connectedComponent(v,visited,0,0);     vector v2;     for(int i=0;i    {         if(connected[i]==-1)         {             sort(v2.begin(),v2.end());             v2.clear();         }         v2.insert(v2.end(),array[connected[i]]);                  }              system(\"pause\");     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Question not clear. 3 3 2 1 nyn yny nyn What will be the output? {2 3 1} or {1 2 3}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can you apply any of the rules more then one?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I used some greedy approach and believe me It was right ,that's why i was selected for next round ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"warshall on yes no matrix and then starting from left in permutation bring up the least possible element available for swapping ahead of it.....hope it works well"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can i please get the full question? I'd help me understand the problem better. Thank you"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is facebook Online First Round question asked in NIT Warangal and IIT BHU"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nusing namespace std; \nint toint(int arr[],int); \nint main(){ \n int k,i,j,small,tm; \n cin>>k; \n int p[k],*r;  char q[k][k]; \n for(i=0;i>p[i];           \n    }  \n small=toint(p,k); \n for(i=0;i>q[i][j]; \n           } \n    } \nfor(i=0;i0;l--) \n       {  tmp=(int)floor(pow(10,(l-1))); \n          num+=arr[size-l]*tmp; \n       } \n     return num; \n   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can u clarify if the permutations have to be applied to the original sequence always or they can be applied to the sequence generated from the previous steps if yes, the permutations have to be applied in the same order or not ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Can anybody elaborate the question with more clear test cases...plsss"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"/*  * FB.cpp  *  *  Created on: 03-Sep-2012  *      Author: Pavan  */  /*  * Q2.cpp  *  *  Created on: 03-Sep-2012  *      Author: Pavan  */ #include #include using namespace std;  int main() {  int K;  cin>>K;  char *P = new char [K]();  for(int i=0;i {   cin>>P[i];  }  string *matrix = new string [K] ();  for(int i=0;i {    cin>>matrix[i];  }  for(int i=0;i {   for(int j=i;j  {    if(P[i]>P[j] && i   {     char temp;     temp = P[i];     P[i]=P[j];     P[j]=temp;    }    if(P[i]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"5 56321 nnyny nnnny ynnnn nnnnn yynnn output=??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"here is my friend's solution who cleared FB's 1st round.... codepad.org/BZFH0lae"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"void f() \n{ \n    //parse input, create table \n    int  n = 0; \n    int* a = null; \n    char** table = null; \n \n    scanf(\"%d\\n\", &n); \n     \n    a = new int[n]; \n    table = new (char*)[n]; \n    for(int i=0;ia[j] && table[i][j]=='y') \n            { \n                swap(a[i],a[j]); \n            } \n        } \n    } \n     \n    printf(\"%d %d %d\\n\", a[0], a[1], a[2]); \n \n    for(int i=0;i"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14260662","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"35","title":"Find the number of substrings of a string that are palindromes.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"10","title":"Here is O(N^2) solution. 1. Count all even length palindromes. 2. Count all odd length palindromes. 3.return count."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"My idea is to use DP.  s[i,j]= 1 if s[i+1,j-1]=1 && A[i]=A[j], where i+1<=j-1           if A[i]=A[i+1] if i=j-1          0 otherwise  sum=0; for(i=n; i>=0;i--) {    for(j>=n;j>=i;j--)    {       if(i==j)  S[i,j]=1;       else       {         if(j=i+1)         {            if(A[i]==A[j])               s[i,j]=1;            else              s[i,j]=0;         }         else         {            if(s[i+1,j-1]==1 && A[i]==A[j])              s[i,j]=1;            else              s[i,j]=0;         }       }       sum += s[i,j];    } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"int countPalindromes(const string& str) \n        { \n                  int N = str.size(); \n                  vector< vector > dp(N, vector(N, 0)); \n                  int cnt = 0; \n                  for (int i=0; i < N; i++)  { \n                             cnt += (dp[i][i] = 1); \n                   } \n                   for (int k=1; k < N; k++) \n                             for (int j=k, i=0; j < N; j++, i++) \n                                        cnt += (dp[i][j] = str[i] == str[j] & dp[i+1][j-1]; \n                   return cnt; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"codes-to-problem.blogspot.in/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Create a suffix tree of the word and also the word formed by reversing the word. Then simply count all the suffixes that occur in both tree that are palindromes."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have tried it with O(n^2) the best I could get.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Follow the below steps: 1. Reverse the string and add it to the original string. For eg if the string given is 'banana' take is as 'banana#ananab' 2. Make a suffix array of this string. 3. Put all the suffixes in a hashmap and sort the hashmap to avoid duplicate entries, you can even use arrays. 4. Now find the common prefix in the adjacent strings. Iterate through the hasmap or array created in last point. If you want youcan store this common prefix in a seperate array p. The array p contains all the palindrome string. You can count all the palindrome greater than any length or the longest palindrome."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include int checkpalindrom(char *s,char *s1) { while(sif(*s++!=*s1--) return 0; return 1; }  void main() { char string[30],c; int i=0,j=0,n=0;  printf(\"\\n Enter the Msg :- \"); gets(string);  printf(\"\\n Palindram substring are as follow \\n\\n\");  for(i=0,j=0;string[i];i++) {  if(string[i]==' ' || string[i]=='\\t')   {   c=*(string+i);       *(string+i)='\\0';    if(checkpalindrom(string+j,string+i-1))   printf(\"\\n %d) %s\",++n,string+j);       *(string+i)=c;       j=i+1;  }  }  if(checkpalindrom(string+j,string+i-1)) printf(\"\\n %d) %s\",++n,string+j);  }  input and output as follow ....    Enter the Msg :- hi madam and mom gud day   Palindram substring are as follow   1) madam  2) mom"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \"stdio.h\" \n#include \"string.h\" \n \nint main() { \n    char * str = \"abababbaa\"; \n    printf(\"hello world from panindrom!\\n\"); \n    printf(\"%s has %d panindrom\\n\",str, getNumberOfPanindrom(str)); \n} \n \nint getNumberOfPanindrom(char * str) { \n    return center_in_even_position(str) + center_in_odd_position(str); \n} \n \nint center_in_odd_position(char * str) { \n    int i,j = 0; \n    int count = 0; \n    int size = strlen(str); \n        for( i = 0; i < size; i++) \n        { \n            for( j = 1; j <= min(i, size - i - 1); j++) \n            { \n                if(str[i-j] == str[i+j]) \n                    count ++; \n                else \n                    break; \n            } \n        } \n    return count; \n} \n \nint center_in_even_position(char * str) { \n    int i, j = 0; \n    int count = 0; \n    int size = strlen(str); \n        for( i = 0; i < size; i ++) \n        { \n            for (j = 0; j < size - i - 1; j++) \n            { \n                if(str[i-j] == str[i+j+1]) \n                    count ++; \n                else \n                    break; \n            } \n        } \n    return count; \n} \n \nint min(int a, int b) { \n    return ((a > b) ? b : a); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/*     About Program: Finding all the possible substrings of a given string as well as finding the palindrome substrings in it.     Date: 19/07/2012     Author: Aditya Dhaniwala */ #include #include #include main() {       int i,j,k,flag=0,c=0,num=0,num2=0;       char str[200],strcopy[200]={\"\\0\"},stringconcat[200]={\"\\0\"},temp[2]={\"\\0\"},temp2[2]={\"\\0\"};       printf(\"Enter the string : \");       gets(str);       for(i=0;i      {           temp[0]=str[i];           strcat(stringconcat,temp);           for(j=i+1;j          {               temp2[0]=str[j];               strcat(stringconcat,temp2);               printf(\"%s\\n\",stringconcat);               num2++;                 strcpy(strcopy,stringconcat);               strrev(strcopy);               flag=strcmp(stringconcat,strcopy);               if(flag==0)               {                          printf(\"Palindrome string = %s\\n\",strcopy);                          c=1;                          num++;               }           }           for(k=0;k<200;k++)           {              stringconcat[k]='\\0';              strcopy[k]='\\0';           }       }       if(c==0)               printf(\"CANNOT FIND A PALINDROME SUBSTRING\");       printf(\"\\nTotal number of palindromes of the main string and its substring = %d\\nTotal number of substrings possible=%d\",num,num2);       getch(); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This solution works in O(n+p) where n is the length of string and p is the length of palindrom patterns. In worst case it would be O(n^2) check it:  /a.out \"baab check aa abc zxz it adda hhh \" ./a.out \" baab check aa abc zxz it adda hhh \" ./a.out"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"you can use a suffix array to get a O(nlogn) algorithm first construct a new string S+'#'+S' which # is not in char set of S and S' is the reversion of S. Then build a suffix array and calculate the longest common prefix. sum up each i < len(S) , LCP(Rank[i],Rank[2n-i]) you got the final answer.  if the LCP use a segment tree then each query take O(lgn) time. so the total complexity of the algorithm is O(nlogn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Calculate polinomial hash function for each prefix with O(n) complexity. Next we can calculate hash for some substring in O(1). Next fix center and parity of length and iterate length using binary search to find longest palindrome with fixed center. So we will get O(n log n) complexity."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think Manacher algo can solve this in O(n), I implement two algos: 1. longestPalindrome is O(n) using Manacher  2. partition is O(n^2) using 2-order DP"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using dynamic programming."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"O(n^2) algo:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"if(a[i][j]&&str[i-1]==str[j+1]) a[i-1][j+1]=1  does it work? but i think the time is O(n^2)..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"tag. O(n) solution is not intuitive."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Here is my O(n) solution. The code uses extra storage to track the number of characters matched at the current position based on the number of characters matched at the previous position. The matching logic simply compares the current position to the even & odd offsets based on the number of matches seen in each case previously. The insights I had were  1. It seemed very similar to the KMP substring problem  2. Each palindrome of length n had n/2 smaller palindromes 3. Once characters start matching, the palindrome will continue to expand until it stops at which point a new palindrome starts from that index  Please comment if you find bugs.   Thanks"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"int palidrome_count(const char *a, int n) {  int i;  int len;  int count = n;   int **p = (int **)malloc(sizeof(int *) * n);  for (i = 0; i < n; ++i) {   p[i] = (int *)malloc(sizeof(int) * (n+1));   memset(p[i], 0, sizeof(int) * (n+1));   p[i][0] = p[i][1] = 1;  }   for (len = 2; len <= n; ++len) {   for (i = 0; i + len < n; ++i) {    p[i][len] = ((a[i] == a[i + len - 1]) ? 1 : 0) & p[i+1][len-2];    count += p[i][len];   }  }   for (i = 0; i < n; ++i) {   free(p[i]);  }  free(p);   return count; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"This can be done in O(n) and i did this in O(n) in college. Now i cant remember this. If anyone knows please let me know."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Use a stack. Perform one linear pass through the string, compare current element to the one on top of the stack. If they're the same, pop the element and increment the counter. If not, clear the contents of the stack and push current element onto stack.   EDIT: sorry this is wrong."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-12","title":"# include  void main() {     string s1[10],s2[10];     strcpy(s1,s2);    s2= strrev(s2);    if(strcmp(s1=s2))  {    printf(\"it is plaindrome\"); else  printf(\"it is not a palindrome\"); }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14118790","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"35","title":"Let's say there is a file consists of billions of records data.  The file cannot fit into memory, and you need to reverse each word in that huge file and then save the reversed words to another file.  How would you implement this?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"hi guys, I've read every proposed answer, and beside pointer thing, I don't thing they'll work. I've written a pseudocode something line below answer.  \"Read the file in chunk, big enough to accommodate in memory. Process the chunk and reverser it and put into another file, Repeat this operation for the next chunk\"   I tried to get current available memory size, and read that bytes from original file, parse words by space, reverse and store them in the second file.  But the thing is when you read a chunk of byes from original file, it may be a part of only 1 word. So in this case, word cannot fir into memory, so that was a problem.  BTW, they didn't look for pseudocode or just explanations, they looked for a working solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Read the file in chunk, big enough to accommodate in memory. Process the chunk and reverser it and put into another file, Repeat this operation for the next chunk"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Let us take the extreme case that one word of the file is too big that it can't fit into the Memory, then we can take pointer(PTR1) to the first character of that word(stored in some block 'x' of hard disk ) and pointer(PTR2) to the last character of that word(stored in some block 'y' of hard disk ) and keep on swapping and incrementing PTR1 and decrementing PTR2 till the end of the blocks. Then again we will do this for the rest part of the word. Until and unless PTR1 becomes equal to the PTR2. If (PTR1==PTR2) Means the whole word is reversed.  Like this can be done to reverse all the words in the first file.  After that we can read the maximum part of the first file which  can fit into the memory and then copy it into the second file."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I don't quite get the point... You mean this file contains very huge string and *reverse* means reverse strings per line or entire file??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"file has billions of data. can be 1 line of string and it may have 1+ words. the requirement is reverse every word and write to another file"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@pawan We are asked to reverse individual word not the whole file. So I still still to my answer above  Read the file in chunk, big enough to accommodate in memory. Process the chunk and reverser it and put into another file, Repeat this operation for the next chunk"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am posting similar question asked to me for other company.  How do we sort a file that doesn't fit into Main Memory?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Isn't the question about be implementation of External merge sort?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use an LRU having a buffer size equal to the permissible memory size."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Seems like there is some confusion here. Is this to be done in place? If so then just reverse the file by reading  and swapping first n and last n bytes until you reach the middle. Then from the beginning read each word and reverse. (Lets assume that each word is small enough to fit in the buffer.)  If a new file is to be created from the existing file, a lay approach would be to read file backwards and reverse each word before writing to the new file."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"divide the file into n/k chunks. distribute n/k chunks to a set of computers, they reverse the words and give it back to the distributor. distributor on receiving prepares the output file. The distributor may receive some chunk first some second, so it either waits or writes the chunk to target position based on the worker's id to the desired destination"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do like this...  1. Break the huge data into some number of pieces so that each of the piece will fit into the memory. 2. Use multithreading to reverse each of the pieces one by one after bringing into the memory. Reverse using the technique such that on one piece of chunk 1st character is swaped with last, 2nd character is swaped with the second last. use one thread on one character. 3. After reversing all pieces of chunks use the same swaping technique using multithreading to reverse first piece of chunk with last piece of chunk for all.  You are done.....Best of Luck"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"(1) take *start and *end pointer at d beginning and end of 1st word respectively. (2) Let *tmp is another pointer at *end. (3) copy character at *tmp into another file and decrement tmp. Do this step untill *tmp reaches *start. This ll copy 1st word in reverse order. (4) Now put *start at *end+1  (i.e at d beginning of next word). again find next *end position for d next word and repeat above step. (5) do all above process untill *start reaches EOF  Complexity: O(2n) i.e O(n) (since every word is read twice)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"take a file of same size,divide the original into chunks,and start copying from the original file 'character by character' to the end of the new file decrementing towards the start of this new file, i.e, 1st char at last pos,2nd char at 2nd last pos......."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"File contains billions of instruction that cannot be fit into memory means we can't take complete file as input, we need to divide file into parts and only parts we need to read. we read every word one by one and reverse of that word then we store into another same file.and rejoin them into another file."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"How about.. reverse whole file first. We can swap two characters at a time. First with last and so on. So buff_size /2 characters from the beginning and buff_size/2 from the end and then read each word and reverse it.  For example abc de fg -> gf ed cba -> fg de abc.  We would need a buffer that can accommodate the longest word though."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Read one word at a time reverse it and then store it into the destination file, since the file is very big."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14182739","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"14","title":"Write a pseudo code. The question aims to test both your programming and analytical skills. Your implementation will be tested for both time and space efficiency.  The input format is strictly followed. Your program will be evaluated for correctness against multiple inputs. Some inputs will be very large (> 100,000 nodes).   Problem Statement  You are in-charge of the office jukebox. You are determined to do a very good job and make your colleagues happy. You ask them to email you a list of music bands they like. The number of bands each colleague likes is limited to 10,000.  Input  All input will be given on stdin. Your input will be of the form,  1. The first line will be an integer stating the number of lines of input. 2. The input will only contain alphanumeric characters, colon, comma, underscore and space [A-Z, a-z, 0-9, _,  , ], +. 3. The first word will be the name of your colleague, followed by a colon. 4. A comma separated list of that person??s favourite bands will follow the colon. 5. Every line will be terminated by a newline character (\\n).  An example input would look like:  6 Anne: Metallica, The_Doors, Black_Sabbath John: The_Beatles, The_Doors, Metallica, Pink_Floyd Kathy: U2, Guns_n_Roses, Led_Zeppelin Jamie: Radiohead Ashok: Guns_n_Roses, U2, Pink_Floyd, The_Doors Sara: Blink_182, Iron_Maiden, The_Doors   Problem  You decide to use your data to find the people most compatible with each other. Two people are compatible if they have at least 2 bands in common. The compatibility of two people is directly proportional to the number of bands they like in common.  For each person in the list, output the most compatible person(s). If there is more than one compatible person, separate the names with a comma. If a person has nobody compatible, output nothing. For our example input, the output will be,  Anne: John John: Anne, Ashok Kathy: Ashok Jamie: Ashok: John, Kathy Sara:","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"PersonRequest \n{ \nPersonName \nSongList \n} \n \nList is input \nDictionary> songDict = new Dictionary \nList PersonNameList \nPersonId = 0 \nForeach PersonRequest in input \n{ \n PersonNameList.Add(PersonRequest.PersonName) \n Foreach Song in PersonRequest.SongList \n { \n  if(!songDict.Contains(Song)) \n   songDict.Add(Song, new List()) \n  songDict[Song].PersonList.Add(PersonId)  \n } \n PersonId++ \n} \n \n// Probable candidate list \nDictionary> CandidateList; \nForeach Song in SongDict \n{ \n if(Song.PersonList.Count > 1) \n { \n  Foreach PersonId in Song.PersonLit \n  { \n   if(!CandidateList.Contains(PersonId) \n    CandidateList.Add(PersonId, new Dictionary()) \n   ForEach SecondLevelPersonId in Song.PersonList \n   { \n    If(PersonId <> SecondLevelPersonId) \n    { \n     If(!CandidateList[PersonId].Contains(SecondLevelPersonId) \n      CandidateList[PersonId].Add([SecondLevelPersonId], 0) \n     CandidateList[PersonId][SecondLevelPersonId].Count++ \n    } \n   }  \n  } \n } \n} \n \nForeach Candidate in CandidateList \n{ \n bool personHasCompatible = false \n strincg userToPrint = Candidate.name \n Foreach PersonCounts in Candidate \n { \n  if(PersonCounts.Count >=2) \n  {  \n   personHasCompatible = true \n   userToPrint.append(' ' + PersonCounts.Name) \n  } \n } \n if(personHasCompatible) \n  Print userToPrint \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"A simple way to do this is to maintain a hashMap of Map> where the key is the band name and the set of strings is basically the number of employees who have requested this band. This way we can easily invalidate those bands whose value count is lesser than 2 as nobody else likes this band.   Now with this reduced subset, we can convert it to a graph problem where the verticies are the music bands who have more than 1 recommendations and the edges are the employees. Now this is reduced to a spanning tree problem which can be efficiently solved  Space wise we have just a hashmap with the number of entries equal to the number of bands in this case the worst case scenario would be the case where all the 10000 bands requested by each employee will be different in which case we'd have n * 10000 entries where n is the number of employees. On the flip side there would be no processing required here as the reference count for each value would just be one.  There are many efficient ways to solve the graph problem when we need to process the data."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using Hashing method , store all the band(key) of each colleuges and initialize the value with 0. Whnever you are getting the given band name ,increment the value of the band name. That band name whihc is getting the more number of value,that bands will be selected ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"is thre any standard algorithm for this problem???"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct HashIntPair {  size_t operator()(const pair& intPair) const  {   std::hash hasher;   return hasher(intPair.first) + 13*hasher(intPair.second);  } };  int _tmain(int argc, _TCHAR* argv[]) {  ifstream  ifs (\"c:\\\\src\\\\example.txt\");  if (!ifs.is_open())  {   return -1;  }   vector UserNames;  unordered_map> AlbumToUsersMap;  unordered_map, int, HashIntPair> RelatedScoreMap;  unordered_map> RelatedUsers;   // process input   string temp;  getline(ifs, temp);   int numUsers = 0;  stringstream(temp)>> numUsers;  for (int i = 0; i < numUsers; ++i)  {    getline(ifs, temp);   stringstream liness(temp);   string name;   getline(liness, name, ':');   UserNames.push_back(name);   // read music   string album;   while(getline(liness, album, ','))   {    AlbumToUsersMap[album].push_back(i);      }    }  ifs.close();   // updated related scores  for (unordered_map>::iterator at = AlbumToUsersMap.begin(); at != AlbumToUsersMap.end(); ++at)  {   for (vector::iterator it= at->second.begin(); it != at->second.end(); ++it)   {    for (vector::iterator jt = it+1; jt != at->second.end(); ++jt)    {     pair related = *it < *jt ? make_pair(*it, *jt) : make_pair(*jt, *it);      unordered_map, int>::iterator rtscore = RelatedScoreMap.find(related);     if (rtscore == RelatedScoreMap.end())     {      RelatedScoreMap[related] = 1;     }     else     {      ++ (rtscore->second);      RelatedUsers[*it].push_back(*jt);      RelatedUsers[*jt].push_back(*it);     }    }   }  }    // output  ofstream  ofs (\"c:\\\\src\\\\exampleout.txt\");  for (size_t i = 0; i < UserNames.size(); ++i)  {   ofs << UserNames[i] << \" : \";   for (vector::iterator it = RelatedUsers[i].begin(); it != RelatedUsers[i].end(); ++it)   {    if (it != RelatedUsers[i].begin()) { ofs << \" , \" ; }    ofs << UserNames[*it];   }   ofs << endl;  }    ofs.close();  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this problem could be done in O(length of file) as follows: maintain a trie and put the name of the bands into it. when finished putting a band into the trie, add the corresponding college name into the last trie node's college list. each time you put a new band into the trie, you either found that this is a new band, or this band also belongs to some other college. so if you maintain a hash table for each college, you can find the required pairs in O(1)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Go through the input once, build a hash table with the keys being the band name, values being a list of colleagues  Now go through the input again, for each band mentioned by each colleague, create a new hash table with key being other colleagues, value being the number of times they appear in the bands that the current colleague likes.  Now for each colleague, we just need to go through the new hash table and find the entry with the maximum value  Code can be tested here: ideone.com/4bgU7 One caveat is that the order of the compatibility list is not preserved (although it wasn't mentioned in the problem statement, but I can see that if there's a tie, output in the order same as the input colleague list)."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13854665","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"implement dir *","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can you elaborate more !!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please elalaborate more!!!!  dir * just print contents (dir/files) in current directory... if it is the case then .... its too easy ... use this link:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  #include  #include  using namespace std;  int main(){   DIR *parentdir;   string dirname = \"/home/prajyoti/Documents/Placement/careercup/directi\";   struct dirent *fileentry ;   if((parentdir = opendir(dirname.c_str()))){     while((fileentry = readdir(parentdir)) != NULL){       if(strcmp(fileentry->d_name, \".\") != 0 && strcmp(fileentry->d_name, \"..\")!= 0){  cout << fileentry -> d_name << endl;       }     }    }   return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hmm, alot is missing from the above 'solutions': where's the volume name, serial number, dir name, dir or file, date / time created, num files / dir's and their byte sizes!?!?!?  I guess you need to discover exactly what dir * does / returns and not make assumptions about what you think it returns!"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13548681","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"28","title":"Question 1 / 1 There are K pegs. Each peg can hold discs in decreasing order of radius when looked from bottom to top of the peg. There are N discs which have radius 1 to N; Given the initial configuration of the pegs and the final configuration of the pegs, output the moves required to transform from the initial to final configuration. You are required to do the transformations in minimal number of moves.      A move consists of picking the topmost disc of any one of the pegs and placing it on top of anyother peg.     At anypoint of time, the decreasing radius property of all the pegs must be maintained.   Constraints: 1<= N<=8 3<= K<=5   Input Format: N K 2nd line contains N integers. Each integer in the second line is in the range 1 to K where the i-th integer denotes the peg to which disc of radius i is present in the initial configuration. 3rd line denotes the final configuration in a format similar to the initial configuration.   Output Format: The first line contains M - The minimal number of moves required to complete the transformation. The following M lines describe a move, by a peg number to pick from and a peg number to place on. If there are more than one solutions, it's sufficient to output any one of them. You can assume, there is always a solution with less than 7 moves and the initial confirguration will not be same as the final one.  Sample Input #00:    2 3 1 1 2 2  Sample Output #00:    3 1 3 1 2 3 2    Sample Input #01:  6 4 4 2 4 3 1 1 1 1 1 1 1 1  Sample Output #01:  5 3 1 4 3 4 1 2 1 3 1  NOTE: You need to write the full code taking all inputs are from stdin and outputs to stdout If you are using \"Java\", the classname is \"Solution\"","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"This looks like \"Tower of Hanoi\" algorithm. h t t p://en.wikipedia.org/wiki/Tower_of_Hanoi"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"i solved it using array of stacks and traversing the stacks with ID-DFS so give it a try guys i think it works ..  i passed all the test cases 2 + 4 hidden on interviewstreet"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I was able to write a program with a recursive \"move\" method which moves disks starting from the largest to the smallest to its corresponding target keg. But in that method, several other disks need to be moved as well. How can we tell which move will result in minimum moves? and how to not run into an infinite loop of moves?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Well here is the solution...plz explain this solution in the link given below : \" blog.csdn.net/maqingli20/article/details/7361057 \""},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This problem can be seen as a search problem -- searching for the optimal solution (minimal number of steps leading to the final state). We can search all possible states using either depth first search (recursion) or breadth first search. The problem with the dfs is that it will take a significant amount of time because it will first find the worst possible solution (the furthest from the initial state) and then go back to the optimal, so we pretty much have to find all possible solutions, using recursion, and return the one that is completed in the minimum number of steps. With the bfs approach, however, we can return the first solution we find, because we know that every other solution will involve at least one additional step, hence it is not the optimal solution. This approach is much faster."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the solution. I solved it using backtracking and a modification of breath first search."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"even I am stuck, especially with the test case like"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can anyone explain  blog.csdn.net/maqingli20/article/details/7361057"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"... I think it's just a BFS problem ..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This code in ruby is working fine..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.io.BufferedReader; \nimport java.io.InputStreamReader; \nimport java.util.ArrayList; \nimport java.util.Collections; \nimport java.util.LinkedList; \nimport java.util.Queue; \nimport java.util.Stack; \nimport java.util.Vector; \n \n/** \n * @author thiagogenez \n *  \n *         Facebook hiring sample test \n *  \n *         There are K pegs. Each peg can hold discs in decreasing order of \n *         radius when looked from bottom to top of the peg. There are N discs \n *         which have radius 1 to N; Given the initial configuration of the pegs \n *         and the final configuration of the pegs, output the moves required to \n *         transform from the initial to final configuration. You are required \n *         to do the transformations in minimal number of moves. \n *  \n *         A move consists of picking the topmost disc of any one of the pegs \n *         and placing it on top of anyother peg. At anypoint of time, the \n *         decreasing radius property of all the pegs must be maintained. \n *  \n *         Constraints: 1<= N<=8 3<= K<=5 \n *  \n *         Input Format: N K 2nd line contains N integers. Each integer in the \n *         second line is in the range 1 to K where the i-th integer denotes the \n *         peg to which disc of radius i is present in the initial \n *         configuration. 3rd line denotes the final configuration in a format \n *         similar to the initial configuration. \n *  \n *         Output Format: The first line contains M - The minimal number of \n *         moves required to complete the transformation. The following M lines \n *         describe a move, by a peg number to pick from and a peg number to \n *         place on. If there are more than one solutions, it's sufficient to \n *         output any one of them. You can assume, there is always a solution \n *         with less than 7 moves and the initial confirguration will not be \n *         same as the final one. \n *  \n *         Sample Input #00: \n *  \n *         2 3  \n *         1 1  \n *         2 2 \n *  \n *         Sample Output #00: \n *  \n *         3  \n *         1 3  \n *         1 2  \n *         3 2 \n *  \n *         Sample Input #01: \n *  \n *         6 4  \n *         4 2 4 3 1 1  \n *         1 1 1 1 1 1 \n *  \n *         Sample Output #01: \n *  \n *         5  \n *         3 1  \n *         4 3  \n *         4 1  \n *         2 1  \n *         3 1 \n *  \n *         NOTE: You need to write the full code taking all inputs are from \n *         stdin and outputs to stdout If you are using \"Java\", the classname is \n *         \"Solution\" \n * \n */ \npublic class Solution { \n \n public Solution() { \n  try { \n   BufferedReader br = new BufferedReader(new InputStreamReader( \n     System.in)); \n \n   String input[] = br.readLine().split(\" \"); \n   @SuppressWarnings(\"unused\") \n   int n = Integer.parseInt(input[0]); \n   int k = Integer.parseInt(input[1]); \n \n   String begin_config = br.readLine(); \n   String end_config = br.readLine(); \n \n   Vector moves = breadthFirstSearch(k, begin_config, \n     end_config); \n \n   System.out.println(moves.size()); \n   for (String move : moves) { \n    System.out.println(move); \n   } \n  } catch (Exception e) { \n   System.err.println(\"Error:\" + e.getMessage()); \n   e.printStackTrace(); \n  } \n } \n \n private Vector breadthFirstSearch(int k, String begin_config, \n   String end_config) { \n \n  Node node = new Node(null, null, begin_config); \n  Queue queue = new LinkedList(); \n  queue.add(node); \n \n  while (!queue.isEmpty()) { \n   node = queue.remove(); \n   if (!node.isVisited()) { \n    node.setVisited(true); \n    if (node.getConfig().equals(end_config)) \n     break; \n    ArrayList nextsNodes = node.getNexts(k); \n    queue.addAll(nextsNodes); \n   } \n  } \n \n  queue.clear(); \n  queue = null; \n \n  Vector moves = new Vector(); \n  while (node.getFather() != null) { \n   moves.add(node.getLast_move()); \n   node = node.getFather(); \n  } \n  Collections.reverse(moves); \n \n  return moves; \n } \n \n public static void main(String args[]) { \n  new Solution(); \n } \n \n private class Node { \n  private Node father; \n  private String last_move; \n  private String config; \n  private boolean visited = false; \n \n  public Node(Node father, String last_move, String config) { \n   super(); \n   this.father = father; \n   this.last_move = last_move; \n   this.config = config; \n  } \n \n  public ArrayList getNexts(int k) { \n   ArrayList nexts = new ArrayList(); \n   Vector> pegs = getPegs(k); \n \n   for (int from = 0; from < k; from++) { \n    for (int to = 0; to < k; to++) { \n     if (from != to) { \n      if (!pegs.get(from).isEmpty() \n        && (pegs.get(to).isEmpty() || pegs.get(from) \n          .peek() < pegs.get(to).peek())) { \n \n       String s[] = this.config.split(\" \"); \n       s[pegs.get(from).peek() - 1] = String \n         .valueOf(to + 1); \n       String config = \"\"; \n       for (int i = 0; i < s.length; i++) { \n        config += s[i] + \" \"; \n       } \n       config = config.trim(); \n       String last_move = String.valueOf(from + 1) + \" \" \n         + String.valueOf(to + 1); \n \n       nexts.add(new Node(this, last_move, config)); \n      } \n     } \n    } \n   } \n   return nexts; \n  } \n \n  private Vector> getPegs(int k) { \n   Vector> pegs = new Vector>(k); \n   for (int i = 0; i < k; i++) { \n    pegs.add(new Stack()); \n   } \n   String s[] = this.config.split(\" \"); \n   for (int i = s.length - 1; i >= 0; i--) { \n    pegs.get(Integer.parseInt(s[i]) - 1).add(i + 1); \n   } \n   return pegs; \n  } \n \n  @Override \n  public int hashCode() { \n   final int prime = 31; \n   int result = 1; \n   result = prime * result + getOuterType().hashCode(); \n   result = prime * result \n     + ((config == null) ? 0 : config.hashCode()); \n   result = prime * result \n     + ((father == null) ? 0 : father.hashCode()); \n   result = prime * result \n     + ((last_move == null) ? 0 : last_move.hashCode()); \n   result = prime * result + (visited ? 1231 : 1237); \n   return result; \n  } \n \n  @Override \n  public boolean equals(Object obj) { \n   if (this == obj) \n    return true; \n   if (obj == null) \n    return false; \n   if (getClass() != obj.getClass()) \n    return false; \n   Node other = (Node) obj; \n   if (!getOuterType().equals(other.getOuterType())) \n    return false; \n   if (config == null) { \n    if (other.config != null) \n     return false; \n   } else if (!config.equals(other.config)) \n    return false; \n   if (father == null) { \n    if (other.father != null) \n     return false; \n   } else if (!father.equals(other.father)) \n    return false; \n   if (last_move == null) { \n    if (other.last_move != null) \n     return false; \n   } else if (!last_move.equals(other.last_move)) \n    return false; \n   if (visited != other.visited) \n    return false; \n   return true; \n  } \n \n  public Node getFather() { \n   return father; \n  } \n \n  public String getLast_move() { \n   return last_move; \n  } \n \n  public String getConfig() { \n   return config; \n  } \n \n  public boolean isVisited() { \n   return visited; \n  } \n \n  public void setVisited(boolean visited) { \n   this.visited = visited; \n  } \n \n  private Solution getOuterType() { \n   return Solution.this; \n  } \n \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the Constraints:  1<= N<=8  3<= K<=5 , The number of pegs are <=5,no chance of infinite loop,the constraint N can also be N<=8,as N can disks can never be zero, and K lies in between 3 and 5...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a Java code which prepares the graph with neighboring configurations and solves it. I tried to use Object-Oriented way, but I still feel there might be better hack way to solve this faster. Hope it helps."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"just use a recursive function to do brute force search.. since we have: 1<= N<=8 3<= K<=5 and the problem statement guarantees that the answer will never be greater than 7. So."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Well, if M not mistaken.. this is last years Amazon question.. Unfortunately, it sounds like this is an NP problem and still the proper answer is under research !!!!!  Anyone can redirect to correct direction here ?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13383661","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"13","title":"print 2n+1 prime numbers if any one of them not prime then print factors for that number","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"That's a pretty ambiguous question. Could you please elaborate more? What is it meant by any of them not prime? I think you can find 2n+1 prime numbers for any value of n>0."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"public class PrimeFactors {   public PrimeFactors(int n) {   this.run(n);  }   private void run(int n) {   int m = 2 * n + 1;   for (int i = 2; i <= m; i++) {    if (this.isPrime(i))     System.out.println(i);    else     System.out.println(this.primeFactors(i));   }  }   private List primeFactors(int numbers) {   int n = numbers;   List factors = new ArrayList();   for (int i = 2; i <= n / i; i++) {    while (n % i == 0) {     factors.add(i);     n /= i;    }   }   if (n > 1) {    factors.add(n);   }   return factors;  }   private boolean isPrime(int n) {   for (int i = 2; i <= (int) Math.sqrt(n); i++)    if (n % i == 0)     return false;   return true;  }   public static void main(String[] args) {   new PrimeFactors(10);  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"He might be asking you to pick up the prime numbers from 1...2n+1 numbers. Which are not prime, just print out factors. Sieve's method might work well here.  // Let's print only the factors >1  void print(int n) {   vectornumbers [2*n+1];   int M = 1 + 2 * n;   for (int j=2;j<=M;j++) {     if (numbers[j].size() == 0) // it's prime and print it.     else // Traverse the list and print all the factors       for (int k=j+j;k<=M;k+=j) {       numbers[k].push_back(j);     }   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) { \n  // TODO Auto-generated method stub \n  int num = 10734; \n  PrimeCalc pc = new PrimeCalc(); \n  boolean res = pc.primeCalcMethod(num); \n  System.out.println(res); \n  // Factorize \n  if(!res){ \n   FactorCalc fc = new FactorCalc(); \n   fc.factorCalcMethod(num); \n  } \n  else \n  { \n   System.out.println(num); \n  } \n   \n } \npublic Boolean primeCalcMethod(int num){ \n  if(num%2 == 0){ \n   return false; \n  } \n  else \n  { \n   for(int i=3;i<13;i++){ \n    if(num % i == 0 && num != i){ \n     return false; \n    } \n   } \n  } \n  return true; \n } \npublic void factorCalcMethod(int num){ \n  while(num != 1){ \n   if(num % 2 == 0){ \n    System.out.println(2); \n    num = num / 2; \n   } \n   else{ \n    for(int i=3;i<=num;i=i+2){ \n     if(num % i == 0){ \n      System.out.println(i); \n      num = num / i; \n      break;  \n     } \n    } \n   } \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Thiago this section is not clear where n is divided by i.. for (int i = 2; i <= n / i; i++) { while (n % i == 0) { factors.add(i); n /= i;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This will do it in O(n^2) using a hashtable using so called Sieve  algorithm"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] a){ for(int i=1; i <= 2*(Integer.parseInt(a[0]))+1; i++){    primeFactor(i);   } } static void primeFactor(int n){   if(n==1){    System.out.println(\"Number 1 is prime\");    return;   }      List factors = new ArrayList();   for(int i = 2; i<= n/2; i++){    if(n%i == 0){     factors.add(i);    }   }   if(factors.isEmpty()){    System.out.println(\"\\nNumber \"+n+\" is prime\");    return;   }   factors.add(1);   factors.add(n);   System.out.print(n+\" is not prime factors are:\");   for(int factor : factors){    System.out.print(factor+\",\");   }     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I suppose I found a method work with better time approach(I think this comes from Eratosthenes sieve):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void two_n_1_primes(unsigned n) \n{ \n   unsigned m = (n << 1) + 1; \n   for (unsigned p = 2; p <= m; ++p) { \n    unsigned x = p; \n    printf (\"%d =\", p); \n    for (unsigned j = 2; j * j <= x; ++j) { \n     while (x % j == 0) { \n      printf (\" %d \", j); \n      x /= j; \n     } \n    } \n \n    if (x == p) { \n     printf(\" is prime\"); \n    } else if (x != 1){ \n     printf (\" %d\", x); \n    } \n    printf(\"\\n\"); \n   } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This is not the best one but a normal approach PrimeFactor(n) { int flag=0,i; for(i=2;i{   if((n%i)==0)    {       print i      flag=1    }  } if(flag==0) print n }  void main() {  for(int i=1;i<2*n+1;i++) PrimeFactor(i); }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13382661","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"21","title":"write a program to print the given string as alphabets in order next integres fallowed by sum  example: CAE2W3A is input and output should be  ACDEW5","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"Give the order of letters and sum integers up followed, right? But how come the 'D' is here?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Use an integer array of size 26 for 26 alphabets (whichever is required) Keep marking (or adding for repititions) the characters at the right position as you visit them. (Neglect non-alphabets) Print the characters in the array by iterating through its index while you also count for the number of set bits. Append with the counter."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Can you explain the problem clearly?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi,  I think this could be solved by taking a array of 27 elements. Put alphabets in according their ranks that will remove the duplicates. and any number add it with the 27th elements.  Print the whole array till 26th if element is not '0' and print the 27th element as a integer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can't we use the insertion sort with the alphabets and add the numbers if it comes anywhere in string.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class StringAsAlphabetFB {    void sortAndSum(String str) {   int[] array = new int[26];   int sum = 0;   for (int i=0; i<26;i++)    array[i] = 0;      for (int i=0; i   str = str.toLowerCase();    char c = str.charAt(i);    if (c>='a' && c<='z') {     array[c-'a']++;    }    else if (c>='0' && c<='9') {     sum += Integer.parseInt(c+\"\");    }   }      for (int i=0; i<26; i++) {    while(array[i]-- > 0)     System.out.print((char) ('a' + i));   }   System.out.println(sum);  }    public static void main(String[] args) {          StringAsAlphabetFB s = new StringAsAlphabetFB();   s.sortAndSum(\"zertyAB4ER69\");     }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Considering the input CAE2W3D, the following code gives the output as expected. This code works for any ASCII character other than alphabet."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Considering the input CAE2W3D, the following code gives the output as expected. This code works for any ASCII character other than alphabet."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{{ write a program to print the given string as alphabets in order next integres fallowed by sum  example: CAE2W3D is input and output should be  ACDEW5  void PrintStrAndNumSum(char *str) {     int n = A.Length;     int offset = (int)'A';     int map[27];          for(int i = 0 ; i<27 ;i++)     map[i] = 0;         while(*str != '/0')    {       if(*str >= 'A' && *str <= 'Z')        map[(int)(*str - 'A')]++;       else        if(*str >='0' && *str <= '9')            map[26] += (int) (*str - '0');         else       {           // Charset is out of range            return -1;              }       }         for(int i = 0 ; i<26 ;i++)     {         while(map[i] > 0)         {             print('%c' , i + 'A');             map[i]--;         }     }          print(\"%d\",map[26]);          }       } }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{{ write a program to print the given string as alphabets in order next integres fallowed by sum  example: CAE2W3D is input and output should be  ACDEW5  void PrintStrAndNumSum(char *str) {     int n = A.Length;     int offset = (int)'A';     int map[27];          for(int i = 0 ; i<27 ;i++)     map[i] = 0;         while(*str != '/0')    {       if(*str >= 'A' && *str <= 'Z')        map[(int)(*str - 'A')]++;       else        if(*str >='0' && *str <= '9')            map[26] += (int) (*str - '0');         else       {           // Charset is out of range            return -1;              }       }         for(int i = 0 ; i<26 ;i++)     {         while(map[i] > 0)         {             print('%c' , i + 'A');             map[i]--;         }     }          print(\"%d\",map[26]);          }       } }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void FacebookTest1() \n{ \n    const char const szInput[] = \"CAE2W3A\"; \n    char tmp[26] = {0x00}; \n    size_t sum = 0; \n \n    for( size_t i = 0; i < sizeof(szInput); i++ ) \n    { \n        char chr = szInput[i]; \n        size_t index = chr - 'A'; \n \n        if( '0' <= chr && chr <= '9' ) \n        { \n            sum += chr - '0'; \n        } \n        else \n        { \n            if( 0x00 == tmp[index] ) \n            { \n                tmp[index] = szInput[i]; \n            } \n        } \n    } \n    for( size_t i = 0; i < 26; i++ ) \n    { \n        if( tmp[ i ] ) \n        { \n            cout << tmp[ i ]; \n        } \n    } \n    cout << sum << endl; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First partition on 'A', based on ascii value of these characters.. that should return the index of 'A'. and then right side will be alphabet, left would be numerics.. quick_sort the alphabet part (index of 'A' ...end)...and add the numerics (0.. index of 'A') and move to the end."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it is better to use linked list to store characters in sorted form am i correct?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \"stdio.h\" \n#include \"string.h\" \n#include \"malloc.h\" \n#define NUMBER_OF_ALPHABET 27 \nchar * reorder(char * str) { \n    int i,j =0; \n    int * a =(int *) calloc(sizeof(int), NUMBER_OF_ALPHABET + 1); \n    char * s = (char *) calloc(sizeof(char), strlen(str)); \n    for(i = 0; i < strlen(str); i ++) { \n        if ((int)str[i] <= 'Z' & (int)str[i] >='A'){ \n            int index = (int) str[i] - 'A'; \n            if (index >=0 && index <= NUMBER_OF_ALPHABET) \n                a[index]++; \n        } \n        else if(str[i]>='0' && str[i]<='9') \n            a[NUMBER_OF_ALPHABET] += (int)str[i] - '0'; \n    } \n    for(i = 0; i< NUMBER_OF_ALPHABET; i++) { \n        while (a[i] > 0) { \n            s[j] = (char) (i + 'A'); \n            j++; \n            i++; \n        } \n    } \n    if(a[NUMBER_OF_ALPHABET] > 0) \n        s[j] = (char) (a[NUMBER_OF_ALPHABET] + '0'); \n    return s; \n} \nint main () { \n    char * test_string = \"RADOE3F2\"; \n    printf(\"The original string is %s.\\nThe ordered string is %s\\n\", \n            test_string,reorder(test_string)); \n    return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #include #include #include #include #include #include #include using namespace std;  bool palindrome(string s) {      return equal(s.begin(),s.end(),s.rbegin()); } int main() {    string kratos;    vector vec;    kratos=\"nare12sh\";    string::const_iterator iter;    for(iter=kratos.begin();iter!=kratos.end();iter++)       {    char p;    p=*iter;    char* g=&p;    int f=atoi(g);    if(f!=0)    vec.push_back(f);   }   int d=accumulate(vec.begin(),vec.end(),0);   cout<  getch();   return 0;                                                               }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \nusing namespace std; \n \nint main() \n{ \n string inputStr; \n string numericStr; \n string alphaStr; \n int numericStrLen = 0; \n int alphaStrLen = 0; \n \n cout << \"Enter your string \" << endl; \n cin >> inputStr; \n \n for (int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void sort_alpha_sum_int(const char *str) \n{ \n int ref_counts[256]; \n int sum; \n int i; \n \n memset(ref_counts, 0, sizeof(ref_counts)); \n while (*str != '\\0') { \n  if (*str >= '0' && *str <= '9') { \n   sum += (int)(*str - '0'); \n  } else { \n   ref_counts[(unsigned char)*str]++; \n  } \n } \n for (i = 0; i < 256; ++i) { \n  while(ref_counts[i]--) { \n   printf(\"%c\", (char)i); \n  } \n } \n printf(\"%d\\n\", sum); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"Just hack the cmp() in stl sort."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13364661","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"22","title":"Suppose you have a graph  G(V,E). You are supposed to find the shortest path from a vertex 's' to vertex 'e' for 'n' different cases.  In each case one of the edges  'Ei' (any one edge) of the graph will be blocked/deleted only for that case and we have to find the shortest path in the graph with that edge removed.  Guys finding the shortest path is easy. But how can I make the algo so fast that even if I remove one of the edges my algo should still be very fast. O(n log n) or  faster. Remember we are not deleting the edges permanently. We are just temporary removing one edge per case. In each case only one edge is removed. Suppose we blocked one edge E in one case. We have to find the shortest path for the graph. In next case, we will reconnect the last edge and we will block/remove a new edge. And again for this new case we have to find the shortest path.  Another way of understanding the problem is suppose there are cities connected to each other. And every day one of the roads gets blocked because of heavy rain. what is the shortest path every day from city s to e. Also one more important thing to note that each road can be used only once. But there could be more than 1 direct road from city a to city b.  FInd the shortest path distance from city s to e on a day when all direct roads from city f to city h are blocked. If there is no connecting path return -1","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"find all paths from source to destination, sort them and store.  remove one edge, go through the stored paths and find the first which doesn't contain the removed edge"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"There are many ambiguities in that definition of the problem. First of all is the graph weighted or unweighted? If graph is weighted all you need to do to avoid considering some edge is mark it somehow and then skip it during traversal. Dijkstra with binary heap would give you O(n lg n). Simple solution, something must be missing."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I saw this problem \"Going Office\" on Interviewstreet.  PS - This is not my solution. Credit goes to Richard Kempe  The main idea behind the problem is simple: given a weighted undirected graph G=(V,E) and two nodes s,t??V, we wish to answer Q queries of the following form:  What is the shortest path from s to t given that edge e??E is removed from the graph? (This type of problem is also known as the \"most vital arc\" problem ) Let N=|V| and M=|E| as usual. In this case, we are guaranteed that N,M,Q??200000.  Prerequisites You should definitely know Dijkstra's algorithm before attempting to solve this problem. Also, knowing about segment trees with lazy propagation would be good, but is not required to understand the solution.  Building Bridges First of all, it should be clear that naively running Dijkstra's isn't going to run in time, because it requires O(QNlogN) operations. In fact, the size of the input suggests that we should look for at worst an O(NlogN) solution. What can we do then? We may first try to solve an easier problem: can we determine whether an edge e, when removed, will increase the shortest path length between s and t?  Definitions: An edge is optimal if it is on a shortest path from s to t. An edge is a bridge* if it is on all shortest paths from s to t. (Here we refer only to shortest paths in G, without having removed any edges.) Let ds(u) (resp. dt(u)) be the shortest-path distance from s (resp. t) to u, and let OPT be the shortest-path distance from s to t. Then we can show the following properties:  Lemmata: e=(u,v) is optimal if and only ds(u)+length(e)+dt(v)=OPT. e=(u,v) is a bridge if and only if it is optimal and for all other optimal e??=(u??,v??), we have either ds(v??)??ds(u) or ds(v)??ds(u??). In other words, when we travel along an optimal path from s to t, then between lengths ds(u) and ds(v), we must be traveling along e. By convention we denote a bridge with the letter b. As a corollary of the above statement, e is a bridge if and only if, when removed from G, the shortest path distance from s to t increases. (Proofs are left to the reader.) These properties should give you some idea of how to find all the bridges in G. If you still need some hints, an algorithm for computing bridges is included at the end of this post. Islands Now we have a way of identifying which edges, when removed, affect the shortest path length. This still leaves one major question unanswered: given a bridge b, how exactly do we determine the shortest path length from s to t once b is removed? Running Dijkstra's repeatedly is too slow, since we can easily construct examples in which every edge is a bridge. (Consider a graph consisting of only a path from s to t.)  Let K denote the number of bridges. Note that Lemma 2 above implies that we can uniquely order the bridges b0,b1,??,bK?1 based on their relative distances from s. Could we use this to help us?  Definition: Let the i-th island be defined as the set of all vertices v, such that there exists a shortest path from s to v using no more than i bridges. (If v is not connected to either s or t, then we can ignore it -- it lies on some strange continent somewhere far away.) The intuition behind islands and bridges is this: bridges are the fastest way to \"travel\" between the islands when going from s to t. If we remove an edge that is not a bridge, our shortest path is not affected. However, when we take out a bridge, we are forced to travel along another (possibly much longer) path. Proposition: Consider the bridge bi, connecting the i-th and i+1-st islands. Let Ei be the set of all edges e connecting an island with index ??i to an island with index >i. Then the shortest path from s to t that bypasses bi must have length mine=(u,v)??Ei{ds(u)+length(e)+dt(v)} Proof: Any path P from s to t bypassing bi must include some edge in Ei. Now consider some edge e=(u,v)??Ei -- the shortest path from s to t that goes through e must have length ds(u)+length(e)+dt(v). Lastly, by the way we have constructed the islands, we know that bi is not on the shortest paths from s to u or from v to t. A Data Structure for Bypass Length Let bypass(i) denote the length of the shortest path that bypasses bi. The above observations suggest that we can run the following algorithm to compute bypass(i):  For each non-bridge edge e=(u,v) connecting islands i and j, where iFor each k??{i,i+1,??,j?1}: bypass(k)??min{bypass(k),ds(u)+length(e)+dt(v)} However, there is a slight problem with this algorithm: it's too slow. Through some tricky analysis, you can show that in the worst case, we can construct a graph that will cause the above subroutine to take O(M3/2) operations. What we need is a data structure that supports the following two operations efficiently:  update(i,j,val), which runs bypass(k)??min{bypass(k),val} for all k??{i,i+1,??,j?1} query(i), which returns bypass(i) One possible data structure that can support both operations in O(logK) time is called a segment tree with lazy propagation or a segment tree with range update. There are several tutorials online about this type of tree, and it's a good data structure to be familiar with. (The main problem right now is that the structure is rather complicated and the online tutorials are not very good. I may do an article on it some time, if there is sufficient demand.)   Putting It All Together The previous observations suggest the following algorithm for solving the problem:  Compute ds and dt using Dijkstra's algorithm. Find the bridges: First find all the optimal edges by iterating over all edges e=(u,v), and storing the edges such that ds(u)+length(e)+dt(v)=OPT. Sort all the optimal edges by ds(u) and ds(v). Use the criterion from above to find the bridges. Find the islands. One way (the hard way) is to run a modified version of Dijkstra. A smarter and shorter alternative is to just run multiple depth-first searches from s and from the far end of each bridge. It's up to the reader to figure out how to do so. Find the bypassing paths. Initialise your favourite range-update data structure. Iterate over all the non-bridge edges. If e=(u,v) is an edge crossing from island i to island j>i, then range-update bypass(i),bypass(i+1),??,bypass(j?1) such that they are no more than ds(u)+length(e)+dt(v). Process all the queries. If the edge in question is not a bridge, then we simply return the optimal length. Otherwise, we query the range-update data structure to find the best bypass length. All of the above steps run in require O(RlogR) operations where R=max{N,M,Q}, so the algorithm has complexity O(RlogR)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"One small update. There is only one path from one city to another."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"? Guys the graph is weighted .. and we cannot sort and store all pahts as the number of paths could be 10^22."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sounds like the edges are weighted (representing the distance), such as e1 = (v1,v2,d) and there exists at most 1 edge between any two nodes?   Then a weighted shortest path algorithm helps...but do we want to execute it fully n times, once for each round, for the entire graph?   Suppose on round 1, some edge e1 = (v1,v2,d) is missing and the shortest path is computed from the start to end node.  but we could also compute the shortest path from the start node to every node and save those paths (or at least the cost).  Then on round 2, e1 is placed back in and another edge, e2 = (v3,v4,d) is removed.   If e2 is on the shortest path in round 1, then the solution for round 1 no longer holds, otherwise the solution from round 1 -may- still hold.  By placing e1, is e1 now on the new shortest path...seems like we could focus on the cost of the path from (a) the start node to v1, (b) cost of e1, (c) the cost of v2 to the end node.  (a) and (b) are already known, so we compute (c), add them together to get the cost of the new path containing e1.  So maybe something along these lines, where shortest path is recomputed, not for the whole graph, but from the vertices of the two changed edges."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Suppose we have run the Dijkstra algorithm on original graph: g0; We have got the shortest distance array dist0[n].  Now, we have a new graph: g with the edge (w, v) removed;  dist0[n] and dist[n] are two global arrays, which store the shortest distance array from source of the original and removed edge graph.  Algorithm should be as followed;   void shortest(int s, int t)      // s source, t destination {       // 1. initialize       // copy dist0[n] to dist[n]// dist[n] is the array storing the new shortest distance;     for (int v = 0; v < n; v++)     {     dist[v] = dist0[v];     }      // 2. compare dist0[v] - dist0[w] and weight(w, v), if weight(w, v) == dist0[v] - dist0[w], we     need // to update dist[v];     if (dist0[v] - dist0[w] == weight(w, v))        {            dist[v] = 10000000;            for ( j in adjR[v] ) // adjR is the reversed graph adjacency list                 dist[v] = min(shortest, dist[j] + weight(j, v));         } // new dijkstra greedy score dist[v] is the minimum score of all other vertices scores + edge weights;  // recursively update the dijkstra greedy score vertices connected to vertices v;     update(s, t, v); }  // recursive program. void update(int s, int t, int v) {     int u;     for (u in adj[v])     {          if (dist0[u] - dist0[v] = weight(u, v))                {                       dist[u] = dist[v]  +  weight(u, v);                       update(s, t, v);                } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"my answer is, find the DAG with source 's' and destination 't' produced by dijkstra. if the removed edge is a cut in this DAG, then..I think you need to run dijkstra again... and if not, the shortest path is not changed.. I can't figure out better solutions.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Find a shortest path. Then recursively find shortest path where you remove one node each from your first shortest path. You will end up with a set of shortest paths and regardless which node is removed in the graph you now you always have an alternative shortest path."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13228699","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"16","title":"Given a character array. Find if there exists a path from O to X. Here is an example  . . . . . . .  . . . . . . . w . . . . . . w .w.w..  . . . . O . .  . . w. . . .  . . . X . . .  You have to just keep in mind that you cannot go through 'W'.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"This can be solved by Simple Depth First Search using Recursion.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"We can use  A* algorithm which takes euclidean distance as heuristic... very fast.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Why do you guys start writing code directly?  Please write your approach in the form of words and than write the code with comments to let the people understand clearly & quickly."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Can be solved by backtracking. call with   x,y indices of 'o' dest - 'x' err - 'w' visited - boolean array to track visited nodes."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"everyone... please explain your logic ..ther is no use of code..no one is gonna sit & read the big code... so try to mention the logic /important aspects of program.. so that everyone understands."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":". . . . . . . . . . . . . . w . . . . . . w .w.w.. . . . . O . . . . w. . . . . . . X . . .  it is a simple graph reachability problem. here the character matrix can be plotted as a graph where  .....  shows the nodes are connected.  while w shows disconnected. we can apply dfs/bfs  from the source  node and if we reach a node w, then return else recurse for each connected node,if we reach X,then true else false."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"isn't   Rat In Maze  problem.  And can be solved using backtracking."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can use A* algo solve this problem.  A* uses the heuristics with cost function. It applies the BFS and see the cost of every node and calculate the distance(i.e. heuristics function.)  complexity id O(n) for BFS or DFS complexity is O(m+n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can use A* algo solve this problem.  A* uses the heuristics with cost function. It applies the BFS and see the cost of every node and calculate the distance(i.e. heuristics function.)  complexity id O(n) for BFS or DFS complexity is O(m+n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bidirectional search will be better solution than others (A* or DFS) ...you can verify it using number of node visited by applying each search algorithm individually.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Here is the code using backtracking. I have not bothered for boundary cases, but they can be incorporated as well. Following give some idea."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"import java.io.*;  public class OtoX{ public static int rowfinal; public static int colfinal; public static int rowdir; public static int coldir; public static String[][] arr; public static int rows; public static int columns;  public static void main(String[] args){  try { BufferedReader reader=new BufferedReader(new InputStreamReader(System.in));  int row=0; int col=0; String input=reader.readLine(); String[] size=input.split(\",\"); rows=Integer.parseInt(size[0]); columns=Integer.parseInt(size[1]); arr=new String[rows][columns];  for(int i=0;i { System.out.print(\"Enter row -\"+i); for(int j=0;j  {   arr[i][j]=reader.readLine();   }  } System.out.println(\"--------\"); for(int i=0;i { for(int j=0;j  {   System.out.print(arr[i][j]);   if(arr[i][j].equals(\"O\"))    {    row=i;    col=j;    }   else if(arr[i][j].equals(\"X\"))    {    rowfinal=i;    colfinal=j;    }   } System.out.println(\"\");  }  if(rowfinal>row){ rowdir=1; } else{ rowdir=-1; }  if(colfinal>col){ coldir=1; } else{ coldir=-1; } boolean result;   System.out.println(move(row,col,row,col));  } catch(IOException e){ e.printStackTrace();  }  }  public static boolean move(int row,int col,int prevrow,int prevcol){ int nr; int nc; boolean result=false; if(row==rowfinal && col==colfinal)  {  return true;  } else  {   nr=row+rowdir;   nc=col;   //System.out.println(\"\"+nr+\"-\"+nc);   if((nr)>-1 && nr < rows  && (nr) !=prevrow && !arr[nr][nc].equals(\"W\"))   {   arr[nr][nc]=\"W\";   System.out.println(\"Trying to move to\"+(nr)+\",\"+nc);   result=move(nr,nc,row,col);   }   nr=row;   nc=col+coldir;    if((nc)>-1 && nc < columns && (nc) !=prevcol && !arr[nr][nc].equals(\"W\") )   {   arr[nr][nc]=\"W\";   System.out.println(\"Trying to move to\"+(nr)+\",\"+(nc));   result=move(nr,nc,row,col);   }   nr=row+rowdir*(-1);   nc=col;  // System.out.println(\"\"+nr+\"-\"+nc);   if((nr)>-1 && nr < rows && (nr) !=prevrow && !arr[nr][nc].equals(\"W\"))   {   arr[nr][nc]=\"W\";   System.out.println(\"Trying to move to\"+(nr)+\",\"+nc);   result=move(nr,nc,row,col);   }   nr=row;   nc=col+coldir*(-1);   if((nc)>-1 && nc < columns && (nc) !=prevcol && !arr[nr][nc].equals(\"W\") )   {   arr[nr][nc]=\"W\";   System.out.println(\"Trying to move to\"+(nr)+\",\"+(nc));   result=move(nr,nc,row,col);   }  return result;  }      }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"How does this look...too much memory?  import java.io.*; import java.util.*; import java.net.*; import java.util.LinkedList; import java.util.Queue;  public class Test {     class Point     {         public int x, y;  public Point (int _x, int _y) { x = _x; y = _y; }     }      public boolean run()      {         BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));         int      rows;         int      cols;         char[][] matrix;         Point    start = null, end = null, p;          Queue q = new LinkedList();   try {            // read input file             String  input = reader.readLine();             String[] size = input.split(\",\");              rows   = Integer.parseInt(size[0]);             cols   = Integer.parseInt(size[1]);             matrix = new char[rows][cols];              System.out.println(rows + \" , \" + cols);             for (int i = 0; i < rows; i++)      {                 input = reader.readLine();                 size = input.split(\" \");   for (int j = 0; j < cols; j++)   {       matrix[i][j] = size[j].charAt(0);       if (matrix[i][j] == 'O')  start = new Point(i,j);       if (matrix[i][j] == 'X')  end   = new Point(i,j);                     System.out.print(\" \" + matrix[i][j]);   }   System.out.println(\"\");      }       // search for path             q.add(start);      while ((p = q.poll()) != null)      {   matrix[p.x][p.y] = 'v';         // change from '.' to 'v' to indicate we visited this guy                 if (p.x - 1 > -1)   // north                  {       if (matrix[p.x-1][p.y] == 'X') return true;       if (matrix[p.x-1][p.y] == '.')           q.add(new Point(p.x-1,p.y));   }                 if (p.x + 1 < rows) // south   {        if (matrix[p.x+1][p.y] == 'X') return true;                     if (matrix[p.x+1][p.y] == '.')           q.add(new Point(p.x+1,p.y));   }                 if (p.y - 1 > -1)   // west   {        if (matrix[p.x][p.y-1] == 'X') return true;       if (matrix[p.x][p.y-1] == '.')                         q.add(new Point(p.x,p.y-1));   }                 if (p.y + 1 < cols) // east   {        if (matrix[p.x][p.y+1] == 'X')  return true;                     if (matrix[p.x][p.y+1] == '.')           q.add(new Point(p.x,p.y+1));   }      }         }         catch (Exception e) {             e.printStackTrace();         }  return false;     }      public static void main(String[] args)     {         Test t = new Test();         boolean rc = t.run();         System.out.println(\"Result of test is \" + rc);     } }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=12718665","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"86","title":"String Reduction  Given a string consisting of a,b and c's, we can perform the following operation: Take any two adjacent distinct characters and replace it with the third character. For example, if 'a' and 'c' are adjacent, they can replaced with 'b'. What is the smallest string which can result by applying this operation repeatedly?  Input: The first line contains the number of test cases T. T test cases follow. Each case contains the string you start with.  Output: Output T lines, one for each test case containing the smallest length of the resultant string after applying the operations optimally.  Constraints: 1 <= T <= 100 The string will have at most 100 characters.  Sample Input: 3 cab bcab ccccc  Sample Output: 2 1 5  Explanation: For the first case, you can either get cab -> cc or cab -> bb, resulting in a string of length 2. For the second case, one optimal solution is: bcab -> aab -> ac -> b. No more operations can be applied and the resultant string has length 1. For the third case, no operations can be performed and so the answer is 5.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"19","title":"Count the number of occurences of each letter in the input string [numA, numB, numC]  If two of these counts are 0, then return string.length  Else if (all counts are even) or (all counts are odd), then return 2  Else, then return 1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"i think you shouldn't post  those skill tests.. those are not interview questions."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"none of them working correctly.  try for this input abccaccba  solution should be \"b\"  but they are giving wrong solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"none of them working correctly.  try for this input \"abccaccba\" solution should be \"b\" but they are showing wrong output"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"But, abc only reduces to 2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"must depend on how many 'a', 'b' and 'c' the input has; seems with equal number of 'a', 'b' and 'c' the min is 2, otherwise 1. if you just look at the numbers (4,3,5) the way to the min must be through keeping the three counts as close as possible.  4,3,5->3,4,4->4,3,3->3,2,4->2,3,3->3,2,2->2,1,3->1,2,2->2,1,1->1,0,2->0,1,1->1,0,0  3,3,3->2,2,4->1,3,3->2,2,2->1,1,3->2,0,2->1,1,1->0,0,2  waiting for counter examples, thanks"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If i, j, k are the number of occurrences of a, b, c respectively where i, j, k >= 1 and if b,a,a,c is a possible combination then the answer is '1'. Eg. b,a,a,c can be converted to (b,a),(a,c) => c,b => a"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If either all characters are present odd no of times or all are present even number of times, in tht case the result will be 2 and in any other case the result will be 1. Please suggest a case where this does not hold true."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ishant , your answer is incomplete . if its not I have to give you so easy counter example"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ishant, you are correct (though there's still something missing ...). So let me list all possible cases:  (1) String contains only one kind of characters, or more precisely, the string contains k identical characters and nothing else. Clearly, no reduction is poosible and the minimum length is k.  (2) String contains 2 or 3 kinds of characters. Then if all the counts are even or all the counts are odd, the minimum string possible has length 2, otherwise we can reduce it to 1.  Proof (of 2): With every reduction, the count of 2 characters decreases by 1, and the count of the third character increases by 1. So if all counts are even before reduction, all counts will be odd after reduction, and if allcounts are odd before, they will all be even after. So, for such strings, the shortest possible string we can get is (0, 0, 2) or (cc) or (bb) or (aa). All even counts. This proves that we can't do any better than (0, 0, 2). Now, are we guaranteed that we can always get to (0,0,2) for the all-odd, all-even strings and to (0,0,1) for the other strings? YES! We just have to be smart about which pairs we reduce. For example, if our string is aaaaaaabc we can either reduce ab or bc. Reducing bc would mean no more reduction so we don't want to do that! So the algorithm to reach minimum string is this  -- always reduce a pair that contains a character with maximum count. It does not matter which pair, just that the max count character be reduced. This will eventually result in a string of length 1 or 2 depending on the initial counts."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"# of consecutive characters besides matters. E.G. aaaab, the # of a is even => absorbed to one b. aaab, the # of a is odd => absorbed to c, a different char other than a and b.  #include  #include  using namespace std;  int absorbstr(string str) {   if (str.empty()) return 0;   if (str.size()==1) return 1;   if (str.size()==2) return str[0]==str[1]?2:1;    int num = 0;   for (size_t ix = 0; ix!=str.size()-1; ++ix)     if(str[ix]!=str[ix+1]) num = ix;   int last_size = str.size()-1-num;    int count = 1;    for (size_t ix = 0; ix!=str.size()-1; ++ix)   {     if (str[ix]==str[ix+1]) ++count;     else {       if( ix==num ) {          if(!(count%2) && !(last_size%2))            return count         else return 1;       }       if( count%2 ) str[ix+1] = str[ix]^str[ix+1]^'a'^'b'^'c';       count = 1;     }   }   return count; }  int main(int argc, char* argv[]) {   cout << argv[1] << \"=>\" << absorbstr(argv[1]) << endl;   return 1; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"case 1: only 1 char: understood case 2: any 2 or 3 char if count of any char is odd then min possible length = 1, else if all chars count is even min possiblee length is 2. since in case of even eventually you will left with 2 similar chars which will not be able to generate 3rd char."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Well if you have string: abb then you can reduce it to cb and then to just a. The answer therefore is 1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"stackoverflow . com/ questions/ 8551519/ string-reduction-programming-contest-solution-needed/ 8997695#8997695"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//a really dumb solution using DP \npublic class Test { \n String needTest = \"cab\"; \n int sum = 'a' + 'b' + 'c'; \n Test() \n { \n  System.out.println(testString(needTest)); \n } \n int testString(String s) \n { \n  int min = s.length(); \n  if(min == 1) \n  { \n   return 1; \n  }else if(min == 2) \n  { \n   if(s.charAt(0) == s.charAt(1)) \n   { \n    return 2; \n   }else \n   { \n    return 1; \n   } \n  } \n   \n  StringBuffer sb = new StringBuffer(); \n  for(int i= 1; i temp) \n    { \n     min  = temp; \n    } \n   } \n  } \n  return min; \n } \n public static void main(String[] argv) \n { \n  Test t = new Test(); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Main {     public static char get(char a, char b) {         if (a == 'a') {             if (b == 'b') return 'c';             else return 'b';         } else if (a == 'b') {             if (b == 'a') return 'c';             else return 'a';         } else {             if (b == 'b') return 'a';             else return 'b';         }     }  public static void main(String[] args) {   String test = \"abbbbbbbbc\";   for (int times = 0; times < test.length(); times++) {       StringBuffer sb = new StringBuffer();       sb.append(test.charAt(0));       for (int i = 1; i < test.length(); i++) {           if (test.charAt(i) != sb.charAt(sb.length() - 1)) {               char rep = get(test.charAt(i), sb.charAt(sb.length() - 1));               sb.deleteCharAt(sb.length() - 1);               sb.append(rep);           } else {               sb.append(test.charAt(i));           }       }       test = sb.toString();   }   System.out.println(test);  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"take the array  with O(n)  Walk through original array and whenever two adjacent character diff replace it and keep the final result in  second array  apply the same with second array,   Repeat above procedure unless all elements are same or length equal to 1.  Time O(n^2)  Space O(n)  Space complexity can avoided  if be put the result back to original array ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We should look for optimum solutions here. It is not enough if we just parse the elements from left to right or right to left. we must find out proper combinations to achieve maximum compression. EG : cabb   Parsing from left to right yields -> cabb -> bbb -> String of lenght 3 Parsing from right to left yields -> cabb -> ccb -> ca-> b -> string of length 1.  Hence we must check when we combine two adjacent chars to produce the resultant char, if the resultant char is same as the next char. If so, skip this pair for that round and continue."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here is the idea: (1) allocate an array of vector size equal of length of the input array. (2) initialize this array by pushing sub-string(inputstring, 0 , i)  (3) for each item from the array, domerge from the last char to the first char(merge reversely)and push newly generated string to the vector. try combining the tail char with all strings in its previous array element (i-1) (4) loop (3) for all array elements (5) the length of the shortest string in the last array element will be the answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here is the idea: (1) allocate an array of vector size equal of length of the input array. (2) initialize this array by pushing sub-string(inputstring, 0 , i)  (3) for each item from the array, domerge from the last char to the first char(merge reversely)and push newly generated string to the vector. try combining the tail char with all strings in its previous array element (i-1) (4) loop (3) for all array elements (5) the length of the shortest string in the last array element will be the answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here is the idea: (1) allocate an array of vector size equal of length of the input array. (2) initialize this array by pushing sub-string(inputstring, 0 , i)  (3) for each item from the array, domerge from the last char to the first char(merge reversely)and push newly generated string to the vector. try combining the tail char with all strings in its previous array element (i-1) (4) loop (3) for all array elements (5) the length of the shortest string in the last array element will be the answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I also have an solution but in a recursive manner :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"find out the number of each characters NumA, NumB, NumB  If two of them 0 then return string.length else if (all of them are either Odd or Even) return 2;  else return 1;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can be solved using a stack..much the same way you would evaluate an expression(for eg infix)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \n#define A 'a' \n#define B 'b' \n#define C 'c' \n \nvoid compress(char c[], int l) { \n \n int i=0; \n int sum=0, rem=0, avg; \n \n for (i=0;i2) \n    i=0; \n  } \n \n  compress(c,l); \n } \n} \n \nint main(void) { \n int i, len; \n char c[40]; \n printf(\"Enter string {a,b,c}* : \"); \n scanf(\"%s\",c); \n len=strlen(c); \n printf(\"String is : %s\\n\",c); \n \n compress(c,len); \n printf(\"String is : %s\\n\",c); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include   #define A 'a' #define B 'b' #define C 'c'  void compress(char c[], int l) {   int i=0;  int sum=0, rem=0, avg;   for (i=0;i rem = sum % l;  avg = sum / l;   //check if all elements are same  if((avg==A && !rem) || (avg==B && !rem) || (avg==C && !rem)) return;   if(l==2) {   c[0]=A+B+C-c[0]-c[1];   c[1]='\\0';   return;  }else{   while((i+2)    if((c[i+0]+c[i+1]+c[i+2])==(A+B+C)) {     if(c[i+3]!=c[i+2])      c[i+0]=c[i+2];     else      c[i+0]=c[i+1];          memmove(&c[i+1], &c[i+2], l-i);     c[l]='\\0'; --l;     continue;    }    i++;   }     i=0;   while((i+1)   if(((c[i+0]+c[i+1])==(A+B))|| ((c[i+0]+c[i+1])==(B+C)) || ((c[i+0]+c[i+1])==(A+C))){     c[i+0]=A+B+C-c[i+0]-c[i+1];     memmove(&c[i+1], &c[i+2], l-i);     c[l]='\\0'; --l;     continue;    }    i++;    if(i==l && l>2)     i=0;   }    compress(c,l);  } }  int main(void) {  int i, len;  char c[40];  printf(\"Enter string {a,b,c}* : \");  scanf(\"%s\",c);  len=strlen(c);  printf(\"String is : %s\\n\",c);   compress(c,len);  printf(\"String is : %s\\n\",c);  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Check my solution here:  basicalgos.blogspot.com/2012/02/string-reduction-given-string.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #include #include #include using namespace std;  string s; mapmp; mapchange; int get(string s) {  int i,j;  int len=s.size();  int ans=len;  if(mp.count(s)!=0)   return mp[s];  for(i=0; i {   string now=s.substr(i,2);   if(change.count(now)!=0)   {    string tp=s.substr(0,i);    string tp1=s.substr(i+2,len-(i+2));    string tp2=change[now];    string next=tp1+tp+tp2;    ans=min(ans,get(next));   }  }  return mp[s]=ans; } int main() {  int i,j,k,t;  freopen(\"in.txt\",\"r\",stdin);  scanf(\"%d\",&t);  for(i=0; i {   mp.clear();   change[\"ab\"]=\"c\";   change[\"ba\"]=\"c\";   change[\"ac\"]=\"b\";   change[\"ca\"]=\"b\";   change[\"cb\"]=\"a\";   change[\"bc\"]=\"a\";      cin>>s;   int ans;   ans=get(s);   cout<< } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #include #include #include using namespace std;  string s; mapmp; mapchange; int get(string s) {  int i,j;  int len=s.size();  int ans=len;  if(mp.count(s)!=0)   return mp[s];  for(i=0; i {   string now=s.substr(i,2);   if(change.count(now)!=0)   {    string tp=s.substr(0,i);    string tp1=s.substr(i+2,len-(i+2));    string tp2=change[now];    string next=tp1+tp+tp2;    ans=min(ans,get(next));   }  }  return mp[s]=ans; } int main() {  int i,j,k,t;  freopen(\"in.txt\",\"r\",stdin);  scanf(\"%d\",&t);  for(i=0; i {   mp.clear();   change[\"ab\"]=\"c\";   change[\"ba\"]=\"c\";   change[\"ac\"]=\"b\";   change[\"ca\"]=\"b\";   change[\"cb\"]=\"a\";   change[\"bc\"]=\"a\";      cin>>s;   int ans;   ans=get(s);   cout<< } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #include #include #include using namespace std;  string s; mapmp; mapchange; int get(string s) {  int i,j;  int len=s.size();  int ans=len;  if(mp.count(s)!=0)   return mp[s];  for(i=0; i {   string now=s.substr(i,2);   if(change.count(now)!=0)   {    string tp=s.substr(0,i);    string tp1=s.substr(i+2,len-(i+2));    string tp2=change[now];    string next=tp1+tp+tp2;    ans=min(ans,get(next));   }  }  return mp[s]=ans; } int main() {  int i,j,k,t;  freopen(\"in.txt\",\"r\",stdin);  scanf(\"%d\",&t);  for(i=0; i {   mp.clear();   change[\"ab\"]=\"c\";   change[\"ba\"]=\"c\";   change[\"ac\"]=\"b\";   change[\"ca\"]=\"b\";   change[\"cb\"]=\"a\";   change[\"bc\"]=\"a\";      cin>>s;   int ans;   ans=get(s);   cout<< } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #include #include #include using namespace std;  string s; mapmp; mapchange; int get(string s) {  int i,j;  int len=s.size();  int ans=len;  if(mp.count(s)!=0)   return mp[s];  for(i=0; i {   string now=s.substr(i,2);   if(change.count(now)!=0)   {    string tp=s.substr(0,i);    string tp1=s.substr(i+2,len-(i+2));    string tp2=change[now];    string next=tp1+tp+tp2;    ans=min(ans,get(next));   }  }  return mp[s]=ans; } int main() {  int i,j,k,t;  freopen(\"in.txt\",\"r\",stdin);  scanf(\"%d\",&t);  for(i=0; i {   mp.clear();   change[\"ab\"]=\"c\";   change[\"ba\"]=\"c\";   change[\"ac\"]=\"b\";   change[\"ca\"]=\"b\";   change[\"cb\"]=\"a\";   change[\"bc\"]=\"a\";      cin>>s;   int ans;   ans=get(s);   cout<< } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #include #include #include using namespace std;  string s; mapmp; mapchange; int get(string s) {  int i,j;  int len=s.size();  int ans=len;  if(mp.count(s)!=0)   return mp[s];  for(i=0; i {   string now=s.substr(i,2);   if(change.count(now)!=0)   {    string tp=s.substr(0,i);    string tp1=s.substr(i+2,len-(i+2));    string tp2=change[now];    string next=tp1+tp+tp2;    ans=min(ans,get(next));   }  }  return mp[s]=ans; } int main() {  int i,j,k,t;  freopen(\"in.txt\",\"r\",stdin);  scanf(\"%d\",&t);  for(i=0; i {   mp.clear();   change[\"ab\"]=\"c\";   change[\"ba\"]=\"c\";   change[\"ac\"]=\"b\";   change[\"ca\"]=\"b\";   change[\"cb\"]=\"a\";   change[\"bc\"]=\"a\";      cin>>s;   int ans;   ans=get(s);   cout<< } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #include #include #include using namespace std;  string s; mapmp; mapchange; int get(string s) {  int i,j;  int len=s.size();  int ans=len;  if(mp.count(s)!=0)   return mp[s];  for(i=0; i {   string now=s.substr(i,2);   if(change.count(now)!=0)   {    string tp=s.substr(0,i);    string tp1=s.substr(i+2,len-(i+2));    string tp2=change[now];    string next=tp1+tp+tp2;    ans=min(ans,get(next));   }  }  return mp[s]=ans; } int main() {  int i,j,k,t;  freopen(\"in.txt\",\"r\",stdin);  scanf(\"%d\",&t);  for(i=0; i {   mp.clear();   change[\"ab\"]=\"c\";   change[\"ba\"]=\"c\";   change[\"ac\"]=\"b\";   change[\"ca\"]=\"b\";   change[\"cb\"]=\"a\";   change[\"bc\"]=\"a\";      cin>>s;   int ans;   ans=get(s);   cout<< } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"string reduce (string toReduce) \n{ \n    string [] paths = new srtring [6]; \n    string min = toReduce; \n \n    path[0] = toReduce.replace('ac', 'b'); \n    path[1] = toReduce.replace('ab', 'c'); \n    path[2] = toReduce.replace('bc', 'a'); \n    path[3] = toReduce.replace('cb', 'a'); \n    path[4] = toReduce.replace('ca', 'b'); \n    path[5] = toReduce.replace('ba', 'c'); \n \n    for (int i = 0; i < 6; i++) \n    { \n        if (path[i] != toReduce)  \n            path [i] = reduce (path[i]); \n        if (path[i].length < min.length) min = path[i]; \n    } \n    return min; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solvable with no code.  If all three types have either an even or odd number, then the smallest string has size 2.  Otherwise 1.  Or a special case like he original string is all 1 char which can be treated separately.     To see this consider that e odd/even imbalance is preserved by any combination.   If all are even or odd, then a combination switches their mode from all even to all odd or vice versa since the two combined lose 1 and the created char gains one.  Similarly an imbalance keeps the imbalance but switches it from odd to even or vice versa.   Thus no combination can ever get you from all odd or even to 1 char left since zero is not odd.   This does not fully prove our assertion since it does not prove that all cases are reducible to 2 or 1.  That is easily shown by proving that any imbalance is easily reduced to an off by one case e.g. 4/4/5.   I leave that up to readers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"char replace(char char1, char char2) {      if((char1=='a' && char2=='b') || (char1=='b' && char2=='a')) return 'c';      else if((char1=='a' && char2=='c') || (char1=='c' && char2=='a')) return 'b';      else return 'a'; } int main() {     string a = \"bcabccc\";    for(int i=0 ;i+1   {            if(a[i]!=a[i+1])            {              a[i] = replace(a[i],a[i+1]);              a.erase(i+1,1);              i= (i-2<-1)?-1:i-2;            }            cout << a <<\" \";    }    cout < \n   \n    \n   -  \n     ediston \n     on April 06, 2012 Edit | Flag  \n    \n    \n   Reply"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Count the number of occurences of each letter in the input string [numA, numB, numC]  If two of these counts are 0, then return string.length  Else if (all counts are even) or (all counts are odd), then return 2  Else, then return 1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int MinOfChars(int *Arr,int PrevSum) \n{ \n if(Arr[0] != 0 && (Arr[1] == 0 && Arr[2] == 0)) \n  return (Arr[0]); \n if(Arr[1] != 0 && (Arr[0] == 0 && Arr[2] == 0)) \n  return (Arr[1]); \n if(Arr[2] != 0 && (Arr[0] == 0 && Arr[1] == 0)) \n  return (Arr[2]); \n \n int CurrSum = Arr[0] + Arr[1] + Arr[2]; \n \n if(PrevSum == CurrSum) \n  return CurrSum; \n \n sort(Arr,Arr + 3); \n \n Arr[2] -= Arr[1]; \n Arr[0] += Arr[1]; \n Arr[1] = 0; \n \n return(MinOfChars(Arr,CurrSum)); \n} \n \nint MinOfChars(char *S) \n{ \n int Arr[3] = {0,0,0}; \n  \n for(int i = 0; i < strlen(S); ++i) \n { \n  Arr[S[i] - 'a']++; \n } \n \n return MinOfChars(Arr,-1); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int MinOfChars(int *Arr,int PrevSum) \n{ \n if(Arr[0] != 0 && (Arr[1] == 0 && Arr[2] == 0)) \n  return (Arr[0]); \n if(Arr[1] != 0 && (Arr[0] == 0 && Arr[2] == 0)) \n  return (Arr[1]); \n if(Arr[2] != 0 && (Arr[0] == 0 && Arr[1] == 0)) \n  return (Arr[2]); \n \n int CurrSum = Arr[0] + Arr[1] + Arr[2]; \n \n if(PrevSum == CurrSum) \n  return CurrSum; \n \n sort(Arr,Arr + 3); \n \n Arr[2] -= Arr[1]; \n Arr[0] += Arr[1]; \n Arr[1] = 0; \n \n return(MinOfChars(Arr,CurrSum)); \n} \n \nint MinOfChars(char *S) \n{ \n int Arr[3] = {0,0,0}; \n  \n for(int i = 0; i < strlen(S); ++i) \n { \n  Arr[S[i] - 'a']++; \n } \n \n return MinOfChars(Arr,-1); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class StringReduction { \n \n StringReduction() { \n } \n \n private int allEqual(String str) { \n  boolean ret = true; \n \n  char pc; \n \n  if (str.length() == 1) \n   return 1; \n \n  char[] ca = str.toCharArray(); \n \n  pc = ca[0]; \n \n  for (int i = 1; i < ca.length; i++) { \n   if (ca[i] != pc) \n    return 0; \n   pc = ca[i]; \n  } \n \n  return ca.length; \n } \n \n private String replaceTwo(String str, int i) { \n  if (str == null) \n   throw new NullPointerException(); \n \n  if (str.length() == 1) \n   return str; \n \n  if (str.length() - 1 < i + 1) \n   return str;// do not replace \n \n  char[] ca = str.toCharArray(); \n  char replaceC = '\\0'; \n \n  if (ca[i] == ca[i + 1]) \n   return str; \n \n  if (ca[i] == 'a' && ca[i + 1] == 'b') { \n   replaceC = 'c'; \n  } else if (ca[i] == 'b' && ca[i + 1] == 'c') { \n   replaceC = 'a'; \n  } else if (ca[i] == 'c' && ca[i + 1] == 'a') { \n   replaceC = 'b'; \n  } \n \n  if (i > 0 && (i + 2) < str.length()) { \n   return (i > 1) ? str.substring(0, i - 1) + replaceC \n     + str.substring(i + 2) : ca[0] + replaceC \n     + str.substring(i + 2); \n  } else if (i == 0 && (i + 2) < str.length()) { \n   return replaceC + str.substring(i + 2); \n  } else if (i > 0 && (i + 2) >= str.length()) { \n   return (i > 1) ? str.substring(0, i - 1) + replaceC : \"\" + ca[0] + replaceC; \n  } else if (i == 0 && (i + 2) >= str.length()) { \n   return replaceC + \"\"; \n  } \n \n  return \"\"; \n } \n \n private int min(int a, int b) { \n  if (a > b) \n   return b; \n  else \n   return a; \n } \n \n public int stringReduced(String str, int i) { \n  if (str.length() == 1) \n   return 1; \n \n  if (this.allEqual(str) > 0 || str.length() == i) \n   return str.length(); \n \n  String reduceString = this.replaceTwo(str, i); \n \n  int reduceVal = 0; \n \n  if (reduceString.equals(str)) { \n   reduceVal = stringReduced(str, i + 1); \n  } else { \n   reduceVal = stringReduced(reduceString, 0); \n  } \n \n  int noreduceVal = stringReduced(str, i + 1); \n \n  return min(noreduceVal, reduceVal); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.io.BufferedReader; \nimport java.io.IOException; \nimport java.io.InputStreamReader; \n \npublic class Solution{ \n \n public static void main(String[] args) throws IOException { \n  BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); \n  int T = Integer.parseInt(br.readLine().toString()); \n  for (int i = T; --i >= 0;) { \n   String S = br.readLine(); \n   if (S.length() < 2) { \n    System.out.println(S.length()); \n   } else { \n    process(S); \n   } \n  } \n   \n } \n \n private static void process(String S) { \n  for (int i = 0; i < S.length() - 1; i++) { \n   String temp = S.substring(i, i + 2); \n   if (temp.contains(\"ab\") || temp.contains(\"ba\")) { \n    S = S.replaceFirst(temp, \"c\"); \n    i = -1; \n   } else if (temp.contains(\"ac\") || temp.contains(\"ca\")) { \n    S = S.replaceFirst(temp, \"b\"); \n    i = -1; \n   } else if (temp.contains(\"bc\") || temp.contains(\"cb\")) { \n    S = S.replaceFirst(temp, \"a\"); \n    i = -1; \n   } \n  } \n  System.out.println(S.length()); \n \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#import \n#import \nchar diff(char a, char b) \n{ \n if((a == 'a' && b == 'b') || (a == 'b' && b == 'a')) \n  return 'c'; \n else if((a == 'b' && b == 'c') || (a == 'c' && b == 'b')) \n  return 'a'; \n else if((a == 'a' && b == 'c') || (a == 'c' && b == 'a')) \n  return 'b'; \n else \n  return '@'; \n} \nvoid  moveZeros(char* a) \n{ \n        size_t len = strlen(a); \n        int index0 = 0; \n        int indexN = 0; \n printf(\"-->before %s\",a); \n        for(int i = 0; i < len; i++) \n        { \n                if(a[i] != '@') \n                { \n                        int temp = a[i]; \n                        a[i] = a[index0]; \n                        a[index0] = temp; \n                        index0++; \n                } \n        } \n a[index0] = '\\0'; \n printf(\"--> %s\",a); \n} \n \nvoid stringCompression(char* str, size_t len) \n{ \n int i = 0; \n int j; \n int cont = 1; \n while(cont == 1){ \n  i = 0; \n  cont = 0; \n  for(j = 1; j < len;) \n  { \n   char r = diff(str[i], str[j]); \n   if(r != '@') \n   { \n    cont = 1; \n    str[i] = r; \n    str[j] = '@'; \n    i++;  \n   } \n   else \n    i = j; \n   j++;  \n  } \n  moveZeros(str); \n } \n printf(\"\\t%lu\\n\",strlen(str)); \n} \n \nint main() \n{ \n char a[] = \"acbb\"; \n char b[] = \"aaaabbbb\"; \n char c[] = \"aaa\"; \n char d[] = \"acacac\"; \n \n printf(\"For %s :\",a); \n stringCompression(a, strlen(a)); \n printf(\"For %s :\",b); \n stringCompression(b, strlen(b)); \n printf(\"For %s :\",c); \n stringCompression(c, strlen(c)); \n printf(\"For %s :\",d); \n stringCompression(d, strlen(d)); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"IN JAVA:  public class StringReduction{ static HashMap map = new HashMap();  static List len = new ArrayList();  static{   map.put(\"ab\", \"c\");   map.put(\"ba\", \"c\");   map.put(\"ac\", \"b\");   map.put(\"ca\", \"b\");   map.put(\"bc\", \"a\");   map.put(\"cb\", \"a\");     }  public static void main(String args[]) throws Exception {      reduce(\"abaaccbca\");   Collections.sort(len);   System.out.println(len.get(0));  } static void reduce(String s){   Object combinations[] = getCombinations(s);   //int count = 0;   for(Object comb : combinations){    if(map.containsKey((String)comb)){          reduce(s.replace((String)comb, map.get((String)comb)));    }   }   len.add(s.length());  }    static Object[] getCombinations(String s){   ArrayList list = new ArrayList();   for(int i = 0;i   list.add(s.charAt(i)+\"\"+s.charAt(i+1));   }   return list.toArray();  } } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is easily solvable in time O(n). Just observe that the reduction rules are the same as multiplication in Klein 4 group."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"The smallest we can get is the length of smallest substring formed by similar consecutive elements. e.g.  abcbac ( smallest consecutive is 1 ) so string reduces to size 1. conside aaaabbbccccc ( a4,b3,c5) it should reduce to 3 since smallest consecutive similar is 3 )  aaaabbbccccc -> aaaabbacccc ->  aaaabbacc -> aaaabccc -> aaacccc -> aabccc -> aaa. (length is 3)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"take the array  with O(n)  Walk through original array and whenever two adjacent character diff replace it and keep the final result in  second array  apply the same with second array,   Repeat above procedure unless all elements are same or length equal to 1.  Time O(n^2)  Space O(n)  Space complexity can avoided  if be put the result back to original array ."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13270698","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"15","title":"Write a program for Palindrome","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"boolean isPalindrome(String s) { \n    if (s == null || s.length() == 0) { \n        return false;  \n    } \n    for (int s = 0, e = s.length() - 1; s < e; ++s, --e) { \n       if (s.charSt(s) != s.charAt(e)) { \n            return false; \n        } \n    } \n    return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Is it that simple at Facebook ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"boolean palinCheck(String s) {     if(s.length()<=1)return true;     else if(s.charAt(0)==s.charAt(s.length()-1)))      return true&&palincheck(s.substring(1,s.length()-1));    else return false;    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Palindrome for what? string / array(int etc...) / linked list?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"its easy when you go with string. But if provided with integer, then here comes the trick. boolean prime(int n){   int length = 0;   int temp=n;   while( temp!=0 ) {temp/=10;length++;}   int i=0;   while(n!=0 ){    int lsd = n%10;    int msd = (int)(n/Math.pow(10,length-1));    if( lsd == msd ){     n %= Math.pow(10,length-1);     n /= 10;     length -= 2;    }else     return false;   }   return true;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For number just reverse the number and check if they are equal.  rev = 0; while ( num != 0 ) {    rev = rev*10 + num%10;   num=num/10; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It must work for numbers:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#!/usr/bin/python \n \ndef isPalindrome(s): \n for i in range(len(s) / 2): \n  if s[i] != s[len(s)-i-1]: \n   return False \n return True \n \ns = raw_input(\"Enter string: \") \nprint(isPalindrome(s))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \nint main() \n{ \n std::cout << \"1234321\" << std::endl; \n return 0; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13216725","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"36","title":"An expression consisting of operands and binary operators can be written in Reverse Polish Notation (RPN) by writing both the operands followed by the operator. For example, 3 + (4 * 5) can be written as \"3 4 5 * +\".  You are given a string consisting of x's and *'s. x represents an operand and * represents a binary operator. It is easy to see that not all such strings represent valid RPN expressions. For example, the \"x*x\" is not a valid RPN expression, while \"xx*\" and \"xxx**\" are valid expressions. What is the minimum number of insert, delete and replace operations needed to convert the given string into a valid RPN expression?  Input: The first line contains the number of test cases T. T test cases follow. Each case contains a string consisting only of characters x and *.  Output: Output T lines, one for each test case containing the least number of operations needed.  Constraints: 1 <= T <= 100 The length of the input string will be at most 100.  Sample Input:  5 x xx* xxx** *xx xx*xx** Sample Output:  0 0 0 2 0 Explanation:  For the first three cases, the input expression is already a valid RPN, so the answer is 0. For the fourth case, we can perform one delete, and one insert operation: xx -> xx -> xx","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This is similar to the famous edit distance problem.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Here is my solution. I didn't find any case which is not covered by the below solution. Will be waiting to get some testcases where this approach fails. Below one is the perfect java code, you can place it in main and change the input string to the testcase and can be executed."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int FixExpressionOpCount(string expression) \n{ \n    // Check for null and emptu \n    if (expression == null || expression == '') return 0; \n \n    // If the expression contains only one operand, there is nothing to fix \n    if (expression.length <= 1) return 0; \n     \n    // Reudce a valid subexpression to an operand \n    string reducedExpression = expression.replace('xx*', 'x'); \n     \n    // if there was a valid sub-expression, this would have got reduced. \n    if (reducedExpression.length < expression.length) \n        return FixExpressionOpCount(reducedExpression); \n \n    // If no reduction happened, get the number of times the operator '*' appears. \n    // Each of these operators will need to be deleted and inserted to the end (i.e. 2 operations). \n    return getCharCount(expression, '*') * 2; \n} \n \nint getCharCount(string str, char toFind) \n{ \n    int count = 0; \n    foreach (c in str) \n        if (c == toFind) count++; \n \n    return count; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This seems to work. An evaluation stack is sufficient."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I just remember binary tree, using different traverse method. But can't remember the detail"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A binary tree having the leaves as the numerical value and the nodes as the binary operation, traversing such a tree in post order traversal results in a RPN expression. For the given question, the number of operations would be the number of times, a value cannot be entered into the tree, and is inserted later, i.e 2 operations for every such value. The value can or cannot be inserted is based on if the value is an operand then it should be added at the node, else it should be added at the leaf. If there end result is not a binary tree then the input sequence cannot be converted to RPN."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  //---------- macros ---------- #define fp(i,a,b) for(int i=a; i#define fm(i,a,b) for(int i=a; i>b; i--)  using namespace std;  string reduce(string s) {        int n = s.length();        for(int i=0; i < n; i++)        if (s[i]=='*')        {           if(i>=2 && s[i-1]=='x' && s[i-2]=='x'){ s.erase(i-1,2);           i=i-2; }        }        return s; }  int main() {     int n;     cin >> n;     while(n--)     {       string s;       cin >> s;       int c = 0;       s=reduce(s);       while(s!=\"x\")       {         int firstStar = (int)s.find('*');         if(s.size()==2)         {           if(s==\"**\")             c = c+2;            else // \"x*\", \"*x\", \"xx\"              c++;           s = \"x\";         }         else         {          if(firstStar>=0)          {            if((int)s.find('x')<0) // all *'s            {              c = c+s.size()/2+1;              s = \"x\";            }            else            {             c++;             s[firstStar]= 'x';            }         }         else // all x's replace 1/2 by *.. if odd replace delete last one         {             c = c+s.size()/2;             s = \"x\";         }         if(s!=\"x\")            s=reduce(s);        }       }       cout << c << endl;     }     //-----------------------------    cout << endl;   // system(\"pause\");    return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We define S[i][j] to be the minimum number of operations required to convert substring a[i] .. a[j] into RPN.  Now we have the following recursive formulation of S[i][j]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"isn't it very simple???"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My suggestion: Simply go through the string and count x's and stars. When 'x' found, simply increase x-count. When star found, then: if there are at least 2 x's on the stack, decrease x count by one (because two x's and one star produced one x), otherwise inc error count by one (there might be two cases: x = 0 or x = 1, both solved by one operation: when no x, delete the star; when 1 x, add another and together with star we're ok). Finally, add to errors all stars (needed to be deleted) and x's/2 (for each 2 x's one star insert).   Long story short (C#): private int PolishErrors(string s) {  int x = 0;  int o = 0;  int err = 0;    foreach(char c in s)  {   if (c == 'x') ++x;   else    {    if (x >= 2)    {     x-=1;    }    else    {     err++;    }   }     }   err += x/2 + o;    return err; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.io.*; \n     \npublic class Solution { \n \n    public static void main(String[] args) throws IOException { \n        int step = test(\"xxx*\"); \n        System.out.println(step); \n    } \n     \n    public static int test(String s) { \n        int step = 0; \n        int operands = 0; \n         \n        while(s.indexOf(\"xx*\") == 0 || s.indexOf(\"*x*\") == 0 || \n          s.indexOf(\"x**\") == 0 || s.indexOf(\"*xx\") == 0 || \n          s.indexOf(\"**x\") == 0 || s.indexOf(\"x*x\") == 0  \n          || s.indexOf(\"***\") == 0) { \n         \n         if (s.indexOf(\"xx*\") == 0) { \n          s = s.replaceFirst(\"xx\\\\*\", \"x\"); \n          continue; \n         } \n          \n         if (s.indexOf(\"*x*\") == 0) { \n          s = s.replaceFirst(\"\\\\*x\\\\*\", \"x\"); \n          step++; \n          continue; \n         } \n          \n         if (s.indexOf(\"x**\") == 0) { \n          s = s.replaceFirst(\"x\\\\*\\\\*\", \"x\"); \n          step++; \n          continue; \n         } \n          \n         if (s.indexOf(\"x*x\") == 0) { \n          s = s.replaceFirst(\"x\\\\*x\", \"xx\"); \n          step+=1; \n          continue; \n         } \n          \n         if (s.indexOf(\"*xx\") == 0) { \n          s = s.replaceFirst(\"\\\\*xx\", \"xx\"); \n          step+=1; \n          continue; \n         } \n          \n         if (s.indexOf(\"**x\") == 0) { \n          s = s.replaceFirst(\"\\\\*\\\\*x\", \"x\"); \n          step+=2; \n          continue; \n         } \n          \n         if (s.indexOf(\"***\") == 0) { \n          s = s.replaceFirst(\"\\\\*\\\\*\\\\*\", \"x\"); \n          step+=2; \n          continue; \n         } \n        } \n         \n        for(int i=0; i= 2) { \n            step += (operands - 2 > 0) ? (operands - 2) : 1; \n        } \n         \n        return step; \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.io.*; \n     \npublic class Solution { \n \n    public static void main(String[] args) throws IOException { \n        int step = test(\"xxx*\"); \n        System.out.println(step); \n    } \n     \n    public static int test(String s) { \n        int step = 0; \n        int operands = 0; \n         \n        while(s.indexOf(\"xx*\") == 0 || s.indexOf(\"*x*\") == 0 || \n          s.indexOf(\"x**\") == 0 || s.indexOf(\"*xx\") == 0 || \n          s.indexOf(\"**x\") == 0 || s.indexOf(\"x*x\") == 0  \n          || s.indexOf(\"***\") == 0) { \n         \n         if (s.indexOf(\"xx*\") == 0) { \n          s = s.replaceFirst(\"xx\\\\*\", \"x\"); \n          continue; \n         } \n          \n         if (s.indexOf(\"*x*\") == 0) { \n          s = s.replaceFirst(\"\\\\*x\\\\*\", \"x\"); \n          step++; \n          continue; \n         } \n          \n         if (s.indexOf(\"x**\") == 0) { \n          s = s.replaceFirst(\"x\\\\*\\\\*\", \"x\"); \n          step++; \n          continue; \n         } \n          \n         if (s.indexOf(\"x*x\") == 0) { \n          s = s.replaceFirst(\"x\\\\*x\", \"xx\"); \n          step+=1; \n          continue; \n         } \n          \n         if (s.indexOf(\"*xx\") == 0) { \n          s = s.replaceFirst(\"\\\\*xx\", \"xx\"); \n          step+=1; \n          continue; \n         } \n          \n         if (s.indexOf(\"**x\") == 0) { \n          s = s.replaceFirst(\"\\\\*\\\\*x\", \"x\"); \n          step+=2; \n          continue; \n         } \n          \n         if (s.indexOf(\"***\") == 0) { \n          s = s.replaceFirst(\"\\\\*\\\\*\\\\*\", \"x\"); \n          step+=2; \n          continue; \n         } \n        } \n         \n        for(int i=0; i= 2) { \n            step += (operands - 2 > 0) ? (operands - 2) : 1; \n        } \n         \n        return step; \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#define MAX 100 \n \nint validRPN(char *s) \n{ \n    int n=strlen(s),i,res=0,counter=0; \n    for(i=0;i1) \n                counter--; \n            else \n                res++; \n        } \n    while(counter>1) \n    { \n        res++; \n        counter--; \n    } \n    return res; \n} \n \nvoid RPN() \n{ \n    char s[MAX]; \n    gets(s); \n    int t=atoi(s); \n    while(t>0) \n    { \n        gets(s); \n        printf(\"%d\\n\",validRPN(s)); \n        t--; \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a valid RPN should have n operands with n-1 operators, and at every postion i of the RPN, Num of operands from the 0 to i should always be larger than num of operators from 0 to i. So we can first count the number of operands and operators, if num(operands) < num(operators) +1, start from the beginning flip num(operators) +1 - num(operands) of operators to operands. else if num(operands) > num(operators) +1, start from the end flip num(operands) -1 - num(operators) of operands to operators.  Then start validate the RPN, loop from beginning to end, at every step validate if num(operands) == num(operators) +1. If not, fix by flipping(between operand and operator), while maintain num(operands) == num(operators) +1.  this should be able to generate a valid RPN, but may not be least steps"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class RPN { \n  \n public static boolean isValidRPN(String expr){ \n   \n  char arr[] = expr.toCharArray(); \n  int x = 0; \n   \n  for(char c: arr){ \n    \n   if ( c == 'x'){ \n    x++; \n   } \n   else if ( c == '*'){ \n     \n    if ( x >= 2){ \n     x--; \n    } \n    else { \n     return false; \n    } \n   } \n  } \n   \n  if ( x == 1){ \n   return true; \n  } \n   \n  return false; \n } \n  \n //Think of RPN recursively as x(RPN)* \n //The remaining code is self explanatory \n private static int computeToRPN(String expr){ \n   \n  int length = expr.length(); \n   \n  if ( length == 1 ){ \n     if (expr.equals(\"x\")){ \n      return 0; \n     } \n     else if ( expr.equals(\"*\")){ \n      return 1; \n     } \n  } \n   \n  if ( length == 2){ \n    \n   if ( expr.equals(\"xx\") || expr.equals(\"*x\") || expr.equals(\"x*\")){ \n    return 1; \n   } \n   else if ( expr.equals(\"**\")){ \n    return 2; \n   } \n  } \n   \n     char startChar = expr.charAt(0); \n     char endChar = expr.charAt(expr.length()-1); \n      \n     if ( startChar == 'x' ){ \n       \n      if ( endChar == 'x'){ \n       return 1 + compute2RPN(expr.substring(1,length-1)); \n      } \n      else if ( endChar == '*'){ \n       return compute2RPN(expr.substring(1,length-1)); \n      } \n     } \n      \n     return 2 + compute2RPN(expr.substring(1, length-1)); \n      \n      \n } \n  \n public static int compute2RPN(String expr){ \n   \n  if ( isValidRPN(expr) ) return 0; \n  else return computeToRPN(expr); \n   \n } \n \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n  // TODO Auto-generated method stub \n  System.out.println(compute2RPN(\"xx*\")); \n  System.out.println(compute2RPN(\"xxx**\")); \n  System.out.println(compute2RPN(\"xxxx\")); \n  System.out.println(compute2RPN(\"*xx\")); \n  System.out.println(compute2RPN(\"xxxx*\")); \n  System.out.println(compute2RPN(\"**xx\")); \n  System.out.println(compute2RPN(\"xx*xx**\")); \n \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Could you tell me what's wrong witht the following simple algorithm?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is actually very simple"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13225716","download_status":"DOWNLOAD_DONE","votes":"-2","answersCount":"1","title":"An expression consisting of operands and binary operators can be written in Reverse Polish Notation (RPN) by writing both the operands followed by the operator. For example, 3 + (4 * 5) can be written as \"3 4 5 * +\".  You are given a string consisting of x's and *'s. x represents an operand and * represents a binary operator. It is easy to see that not all such strings represent valid RPN expressions. For example, the \"x*x\" is not a valid RPN expression, while \"xx*\" and \"xxx**\" are valid expressions. What is the minimum number of insert, delete and replace operations needed to convert the given string into a valid RPN expression?  Input: The first line contains the number of test cases T. T test cases follow. Each case contains a string consisting only of characters x and *.  Output: Output T lines, one for each test case containing the least number of operations needed.  Constraints: 1 <= T <= 100 The length of the input string will be at most 100.  Sample Input:  5 x xx* xxx** *xx xx*xx** Sample Output:  0 0 0 2 0 Explanation:  For the first three cases, the input expression is already a valid RPN, so the answer is 0. For the fourth case, we can perform one delete, and one insert operation: xx -> xx -> xx","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Your sample data seems incorrect, why you need two operations in fourth line, if you can make this expression valid RPN by only one replace operation: *xx -> xx*"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=12986664","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"93","title":"Push all the zero's of a given array to the end of the array. In place only. Ex 1,2,0,4,0,0,8 becomes 1,2,4,8,0,0,0","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"27","title":"C version O(n):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"The code that works !!! Time complexity- 0(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Here is an implementation with O(N) time complexity and O(1) storage."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"void PushZero(int* pArray, int arraySize) {     if (pArray == NULL) return;      int firstZeroIndex = 0;     while (firstZeroIndex < arraySize)     {         if (pArray[firstZeroIndex] == 0) break;         else firstZeroIndex++;     }          if (firstZeroIndex == arraySize) return;      int zeroIndex = firstZeroIndex;     for (int index = firstZeroIndex + 1; index < arraySize; index++)     {         if (pArray[index] != 0)          {             pArray[zeroIndex] = pArray[index];             pArray[index] = 0;             zeroIndex++;         }     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Python Version O(n):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public class Runner { \n public static void main(String[] args)  { \n  int[] array = {1,2,0,4,0,0,8,0,0,4,2,1,5 }; \n   \n  shiftZeros(array, 0, array.length-1); \n   \n  StringBuilder builder = new StringBuilder(); \n  for(int i : array) { \n   builder.append(i); \n   builder.append(\" \"); \n  } \n  System.out.println(builder.toString()); \n } \n  \n public static void shiftZeros(int[] array, int begin ,int end) { \n  if(begin > end) { \n   return; \n  } \n   \n  while(array[begin] != 0) { \n   begin++; \n  } \n   \n  shiftArray(array, begin, end); \n \n  if(array[begin] == 0) { \n   shiftZeros(array,begin, end-1); \n  } else { \n   shiftZeros(array, begin+1, end); \n  } \n } \n  \n public static void shiftArray(int[] array, int begin, int end) { \n  while(begin < end) { \n   array[begin] = array[begin+1]; \n   begin++; \n  } \n  array[end] = 0; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#define SIZE 7 \nint tab[SIZE]={ 1,0,2,0,0,3,4}; \n \nvoid f(void) \n{ \n  int swapped, i, j, temp; \n  swapped=1; \n  i=0; \n  j=0; \n  while(swapped) \n  { \n    swapped=0; \n    while((i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void EndZero(int arr[], int size){ \n \n if(arr==NULL) return; \n int l=0; \n int r=size-1; \n while(l"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#define SIZE 10 int main(){    int array = { 2, 3, 0, 0, 7, 0, 2, 6, 4, 7};  int newArray[SIZE];    int i, j=0;  for(i=0;i  if(array[i]!=0){    newArray[j]=array[i];    j++;   }  }    for(i=j; i  newArray[i]=0;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my answer to this question:   basicalgos.blogspot.com/2012/03/21-push-all-zeros-of-given-array-to-end.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void set_end_zero(int arr[] ,int size) \n{ \n int i = 0 ,j = 0; \n while (j < size){ \n  while (i < size && arr[i] != 0) ++i; \n  j = i + 1; \n  while (j < size && arr[j] == 0) ++j; \n  if (j < size){ \n   arr[i] = arr[j]; \n   arr[j] = 0; \n  } \n  ++i; \n  ++j; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  // Driver program to test above function int main() {   int arr[]= {0,8,9,0,0,5};   int size=sizeof(arr)/sizeof(int);     int i;     int j=-1;   for(i=0;i   {    if(arr[i]!=0)     {     j++;     int tmp=arr[i];     arr[i]=arr[j];     arr[j]=tmp;     }    }    for(i=0;i  printf(\" %d \", arr[i]);   return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #define MAX 10 void shift_zero(int x[],int n); int main() {     int i=0,j=0,len=0,num[MAX];     printf(\"Enter length:\\t\");     scanf(\"%d\",&len);     printf(\"length=%d\\n\\n\",len);     printf(\"\\nEnter your number:\\n\");     for(i=0;i    {        scanf(\"%d\",&num[i]);     }      printf(\"\\nYour number:\\n\");     for(j=0;j     printf(\"%d\",num[j]);      shift_zero(num,len);     printf(\"\\nNumber after shifting 0s:\\n\");     for(j=0;j     printf(\"%d\",num[j]);      getch(); }  void shift_zero(int x[],int n) {      int i=0,count0=0,p=0,temp=0;       for(i=0;i     {         if(x[i]==0)         {           if(temp==0)            {            p=i;            temp=1;            }           count0 ++;           continue;         }          if(temp==1)         {            x[i-count0]=x[i];         }              }      for(i=n-count0;i      x[i]=0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"An effective solution, in case all the integers are not negative, just multiply the array by -1 and then quick sort in ascending order. Then multiply the array by -i again :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Sort { \n \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n  // TODO Auto-generated method stub \n  int arr[]={1,2,0,4,0,0,8}; \n   \n  int n=arr.length-1; \n  int left=n; \n   \n  for(int i=n;i>=0;i--) \n  { \n   if(arr[i]==0) \n   { \n    int temp=arr[i]; \n    arr[i]=arr[left]; \n    arr[left]=temp; \n    left--; \n   } \n  } \n  for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Sort { \n \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n  // TODO Auto-generated method stub \n  int arr[]={1,2,0,4,0,0,8}; \n   \n  int n=arr.length-1; \n  int left=n; \n   \n  for(int i=n;i>=0;i--) \n  { \n   if(arr[i]==0) \n   { \n    int temp=arr[i]; \n    arr[i]=arr[left]; \n    arr[left]=temp; \n    left--; \n   } \n  } \n  for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Sort { \n \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n  // TODO Auto-generated method stub \n  int arr[]={1,2,0,4,0,0,8}; \n   \n  int n=arr.length-1; \n  int left=n; \n   \n  for(int i=n;i>=0;i--) \n  { \n   if(arr[i]==0) \n   { \n    int temp=arr[i]; \n    arr[i]=arr[left]; \n    arr[left]=temp; \n    left--; \n   } \n  } \n  for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Sort {   /**   * @param args   */  public static void main(String[] args) {   // TODO Auto-generated method stub   int arr[]={1,2,0,4,0,0,8};      int n=arr.length-1;   int left=n;      for(int i=n;i>=0;i--)   {    if(arr[i]==0)    {     int temp=arr[i];     arr[i]=arr[left];     arr[left]=temp;     left--;    }   }   for(int i=0;i   System.out.print(arr[i]+\" \");     }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int main() {     int a[] = {1, 2, 0 , 4, 0 , 0 , 8 , 6 , 7 , 0 , 3 , 0};     int i , j;     i = 0;     j = 11;          while(i    {         if(a[i] != 0)         i++;         else if(a[i] == 0 && a[j] != 0)         swap(&a[i] , &a[j]);         if(a[j] == 0)         j--;                        }         for(i = 0;i<12;i++)         printf(\"%d\", a[i]);                  getch();         return 0;          }  swap(); a helper function.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#define ARRAY_SIZE 10 int _tmain(int argc, _TCHAR* argv[]) {  int arr[ARRAY_SIZE] = {2, 3, 0, 5, 0, 3, 1, 0, 0, 1};   int j = ARRAY_SIZE - 1;   for(int i = 0; i < j; ++i)  {   if(arr[i] == 0)   {    while(arr[j] == 0)    {     --j;    }        arr[i] = arr[j];    arr[j] = 0;   }  }    return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this Question asked to me in Microsoft written :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Logic: Traverse the Array and replace [first zero] with [first non-zero after first zero] 1, 2, 0 , 4, 0 , 0 , 8 , 6 , 7 , 0 , 3 , 0 -----> 1,2,4,0,0,0,8,6,7,0,3,0 keep Applying this rule till the end"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \nbool should_swap(int left, int right) { \n    return left == 0 && right != 0; \n} \n \nvoid print(int *a, int n) { \n    for(int i = 0; i < n; ++i) { \n        std::cout << a[i] << ' '; \n    } \n    std::cout << std::endl; \n} \n \nvoid move_zeros(int *a, int n) { \n    if(!a || !n) { \n            return; \n    } \n    for(int i = 0; i < n; ++i) { \n        for(int j = n - 1; j > i; --j) { \n            if(should_swap(a[j - 1], a[j])) { \n                int temp = a[j]; \n                a[j] = a[j - 1]; \n                a[j - 1] = temp; \n            } \n        } \n    } \n} \n \nint main() { \n    int a[] = {1,0,2,0,3,0,0}; \n    int n = sizeof(a) / sizeof(int); \n    print(a, n); \n    move_zeros(a, n); \n    print(a, n); \n    return (0); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"JAVA version.  pointer i at the last non-zero position. pointer j at the first zero position. exchange and increment both to next valid position.  public class PushZeroToEnd {  public static void swap(int[]arr, int i, int j) {   int tmp = arr[i];   arr[i] = arr[j];   arr[j] = tmp;  }  public static void main(String[] args) {   int[] arr = new int[]{1,2,0,4,0,0,8};   int i = 0;   while(arr[i] != 0) {    i++;   }   for(int j = i; j < arr.length && i < arr.length; j++) {    if(arr[j] != 0 && i < j) {     swap(arr, i, j);     while(arr[i] != 0)      i++;    }   }   System.out.println();  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int* moveZero(int *src, int size) {  int zero = 0;  while(zero < size && src[zero] != 0)   zero++;  for(int i = zero + 1; i < size; ++i)  {   if(src[i] != 0)   {    int tmp = src[i];    src[i] = 0;    src[zero++] = tmp;   }  }  return src; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int* moveZero(int *src, int size) {  int zero = 0;  while(zero < size && src[zero] != 0)   zero++;  for(int i = zero + 1; i < size; ++i)  {   if(src[i] != 0)   {    int tmp = src[i];    src[i] = 0;    src[zero++] = tmp;   }  }  return src; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"need the non 0 elements be sorted ? or the example is a coincidence. we can push all non zero elements in a stack also counting number of 0. then print 0 from reverse in array then pop elements in array right to left"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"To use constant space algorithm. keep 2 pointers. move left to right. P1 points to 0 and P2 points to non zero element next to P1. swap P1 and P2. P1++ and then move P2 till u find another non-zero element. O(n) time, O(1) space"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int[] zeros(int[] a, int val) \n        { \n            if (a == null) \n                throw new Exception(); \n \n            if (a.Length == 1) \n                return a; \n \n            int index = a.Length - 1; \n            while (a[index] == val) \n                index--; \n \n            for (int i = 0; i < index; i++) \n            { \n                if (a[i] == val) \n                { \n                    int temp = a[index]; \n                    a[index] = a[i]; \n                    a[i] = temp; \n \n                    index--; \n                }                 \n            } \n \n            return a; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Perl version  #!/usr/local/bin/perl  my @array = (100,0,0,100,0,0,0,100);  $j=0; for($i=0;$i<($#array );$i++){     if(($array[$j] eq 0) and ($array[$i+1] ne 0)){       $array[$j]=$array[$i+1];       $array[$i+1]=0;       $j++;     print \"swap took place \\n\";    }elsif($array[$j] ne 0){        $j++;    } }  print \"\\n\"; foreach $var(@array){    print $var . \"\\t\"; } print \"\\n\";"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Perl version  #!/usr/local/bin/perl  my @array = (100,0,0,100,0,0,0,100);  $j=0; for($i=0;$i<($#array );$i++){     if(($array[$j] eq 0) and ($array[$i+1] ne 0)){       $array[$j]=$array[$i+1];       $array[$i+1]=0;       $j++;     print \"swap took place \\n\";    }elsif($array[$j] ne 0){        $j++;    } }  print \"\\n\"; foreach $var(@array){    print $var . \"\\t\"; } print \"\\n\";"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20     #include using namespace std;  int main() {     int a[] = {1,2,0,0,4,0,8};     int i = 0, j = 0, t;     while (i < 7 && j < 7) {         if (a[i] != 0) i++;         if (a[j] == 0 || j <= i) j++;         if (j > i && a[j] != 0) {             t = a[i];             a[i++] = a[j];             a[j++] = t;         }     }     for (int i = 0;i<7; i++)       cout<    cout<}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nmain() \n{ \n      int a[20],i,k,n,j; \n       \n      printf(\"no. of elements:\"); \n      scanf(\"%d\",&n); \n       \n      printf(\"enter elements:\\n\"); \n      for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"According to question all values should be in ascending order and push the zero to the end... Find the answer below   #include  #include  #include  int main() { //    printf(\"Hello world!\\n\"); int i, j, x; int arr[7] = {1, 2, 0, 4, 0, 0, 8}; int arr1[7];     for(i = 0; i < 7; i++)     {         for(j = (i + 1); j < 7; j++)         {             if(arr[i] > arr[j])             {                 x = arr[i];                 arr[i] = arr[j];                 arr[j] = x;             }             else             {              }         }      }  for(i = 0; i < 7; i++) {     printf(\"The arr[%d] = %d \\n\", i, arr[i] );  // 0 0 0 1 2 4 8 } for(i = 0, j = 0; i < 7 ; i++) {     if(arr[i] != 0)     {     arr1[j] = (arr[i]); //<< i)/pow(2, i);     j++;     }      } for(i = j; i < 7; i++, j++) {     arr1[j] = 0; } for(i = 0; i < 7; i++) {     printf(\"The arr1[%d] = %d \\n\", i, arr1[i] );  //1 2 4 8  0 0 0  }      return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  using namespace std;   int main (){  int a[7] = {1,2,0,4,0,0,8};  int count1 = 0;    for(int i = 0; i < 7; i++)  {   if(a[i] != 0)   {    a[count1] = a[i];    count1++;   }  }     for(int k = count1; k < 7; k++)   a[k] = 0;    //Print it out  for(int i = 0; i < 7; i++)   printf(\"%d \",a[i]);     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void \nzeroes_to_end(int *a, size_t l) { \n  int i, lz; \n  for(i=0, lz=-1; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n), in place in C#"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for(int i=0; i   {       if(a[i]==0)       {         int newi = i+1;         while(newi        if(newi      }    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"$data= array(1,2,0,0,4,5,0,7,8,0,0); $i=0;$j=0; foreach($data as $value){     if($value !=0){         $data[$i]=$data[$j];         $i++;     }     $j++; } for($i; $i  $data[$i]=0; } foreach($data as $value){    echo $value . \",\"; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int arr[size] = {0, 0, 1, 2, 0, 4, 0, 0 ,8 ,9}; \nint start = 0; \nint end = 0; \n \nfor(int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a somewhat complex approach -- still O(n) since each element is touched only once  void push_zeros(int *a, int n) {   int s=-1,e=-2;   for(int i=0;i  {      if(a[i]==0)      {        if(e+1!=i)  s=i;        while(a[i]==0 && i       if(i==n) break;        //where zeros end        swap(a[s],a[i]);        s+=1;        e=i;      }      else      {        swap(a[s],a[i]);        s+=1;        e=i;      }   } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simplies, O(n), one for:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n), one for-cycle:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this is not a difficult problem with the array in order ignoring all the zeros."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"move from left to write in the array, shifting the non zero elements when encounter a zero. Keep count of 0s. at the end just write out the zeros."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int[] PushZero(int[] arr)         {             int startZero = -1;             int endNumber = -1;                           for(int i=0; i            {                 if(arr[i] == 0 && startZero == -1)                 {                     startZero = i;                 }                 else if (arr[i] != 0)                 {                     endNumber++;                      if (startZero != -1)                     {                         arr[startZero] = arr[i];                         arr[i] = 0;                         endNumber = startZero;                         startZero = endNumber + 1;                     }                                      }             }             return arr;          }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int[] PushZero(int[] arr)         {             int startZero = -1;             int endNumber = -1;                           for(int i=0; i            {                 if(arr[i] == 0 && startZero == -1)                 {                     startZero = i;                 }                 else if (arr[i] != 0)                 {                     endNumber++;                      if (startZero != -1)                     {                         arr[startZero] = arr[i];                         arr[i] = 0;                         endNumber = startZero;                         startZero = endNumber + 1;                     }                                      }             }             return arr;          }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int postIndex =0;  for(int j=0;j<=size;j++)   {    if(a[j]!=0)    {     int temp=a[j];     a[j]=a[postIndex];     a[postIndex]=temp;     postIndex++;    }   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You all are making this easy thing very complicated."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package my.work; \n public class Sort { \n  \n public static void main(String[] args) { \n int arr[]={1,2,0,4,0,0,8,2,-2,234,22,0,1,0}; \n int j=0; \n int len=arr.length; \n for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nusing namespace std; \nvoid swap(int*,int*); \nint main() \n{ \n    int a[]={1, 2, 3}; \n    int i=0; \n    int k; \n    int size=sizeof(a)/sizeof(a[0]); \n    do \n    { \n        while(a[i]!=0) \n        i++; \n        k=i+1; \n        while(a[k]==0&&k"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) {   // Preparing random input   int input[] = new int[5];   Random r = new Random();   for(int i=0;i<5;i++){    input[i] = r.nextInt(10);    if(input[i] > 4)     input[i] = 0;   }   //int input[] = {0,2,2,2,1};   for(int i=0;i<5;i++){    System.out.print(input[i]+\" \");   }   System.out.println(\"\\n\");      int j = 0,temp;   // Logic for pushing all zeros in place.   // If current element is 0 then, look for next non zero element and then swap with it.   // Worst case performance - O(n*n)   /*for(int i=0;i   if(input[i] == 0){     j = i + 1;     while(input[j] == 0 && j     j++;     }     // Exchange     if(input[j] != 0){      temp = input[i];      input[i] = input[j];      input[j] = temp;     }     //    }   }*/   //   // O(n) logic. First find first zeroIndex.   // now swap ZeroIndex with first nonZero index. \"then increment zeroIndex\"   while(input[j] != 0){    j++;   }   int zeroIndex = j;   for(int i=zeroIndex;i   if(input[i] == 0){     //zeroIndex = i;    }    else{     //swap     temp = input[i];     input[i] = input[zeroIndex];     input[zeroIndex] = temp;     zeroIndex++;    }   }   for(int i=0;i<5;i++){    System.out.print(input[i]+\" \");   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int i=0,zero=0; \n          for(;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Pseudo code with O(n) (Lemme know if it's wrong!)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorry, pressed enter prematurely in the last comment."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Partition algorithm:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#import \n \nint main() \n{ \n        int a[] = {1,2,0,3,0,4,0,5,0}; \n        size_t len = sizeof(a)/sizeof(int); \n        int index0 = 0; \n        int indexN = 0; \n        for(int i = 0; i < len; i++) \n                printf(\"%d \\t\", a[i]); \n        printf(\"\\n\"); \n        for(int i = 0; i < len; i++) \n        { \n                if(a[i] != 0) \n                { \n                        int temp = a[i]; \n                        a[i] = a[index0]; \n                        a[index0] = temp; \n                        index0++; \n                } \n        } \n        for(int i = 0; i < len; i++) \n                printf(\"%d \\t\",a[i]); \n        printf(\"\\n\"); \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here is my solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// a is the array \n// n is the size of the array \nvoid f(int* a, int n) \n{ \n   if(n<0) return; \n \n   int zeroSt = -1; // point to the first 0 element \n   for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java version - O(n) time and O(1) space"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{ #include  #include   main() {  int i=0; int j= 9; int k=0; int arr[10], arr1[10];  printf(\"Enter numbers for array :\");       for(i=0;i<10;i++) scanf(\"%d\",&arr[i]);  printf(\" \\n You entered :\\n \"); for(i=0;i<10;i++) printf(\"arr[%d] = %d\",i,arr[i]);  printf(\"After refinement : \\n\"); for(i=0;i<10;i++) {  if(arr[i] == 0)                   {    arr1[j]=arr[i];    j--;            }  else  {    arr1[k]=arr[i];    k++;            }  }   for(i=0;i<10;i++) printf(\"%d \\n\",arr1[i]); getch();    }   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"# ruby : push zeroes to end of array \np nums = [0, 2, 4, 0, 3, 0, 19, 34, 0, 12, 0, 3] \nnums.each_with_index do |num, idx| \n  if num == 0 \n    nums.delete_at(idx) \n    nums << 0 \n  end \nend \np nums"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  #include  #include   void pushCharsToEnd(std::string& str, char c) {     int cCount = 0;     for(auto it = str.begin(); it != str.end(); it++)     {         if(*it == c)             cCount++;         else if(cCount > 0)         {             std::swap(*(it - cCount), *it);         }     } }  int main(int argc, char** argv) {     std::string input;  std::getline(std::cin, input);     pushCharsToEnd(input, 'l');     std::cout << std::endl << input;     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void push0() \n        { \n            int[] arr = {0, 0, 1, 2, 0, 4, 0, 0 ,8 ,9}; //{1,9,9,4,0,0,2,7,0,6,7}; //  \n \n            int index = 0; \n \n            for (int i = 0; i < arr.Length; i++) \n            { \n                if (arr[i] != 0) \n                { \n                    arr[index] = arr[i]; \n                    if(index != i) arr[i] = 0; \n \n                    index++; \n                } \n            } \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void \nzp(int a[], int n) \n{ \n    int z = 0; \n    int nz = 0; \n    int idx = 0; \n    int i; \n \n    while (1) { \n        // position z \n        z = idx; \n        while (z < n && a[z]) z++; \n        if (z == n) break; \n \n        // position nz after z \n \n        nz = z + 1; \n        while (nz < n && !a[nz]) nz++; \n        if (nz == n) break; \n \n        a[z++] = a[nz]; \n        a[nz++]  = 0; \n    } \n \n    printf(\"\\nZero pushed out : \"); \n    for (i=0; i < n; i++) { \n        printf(\"%d, \", a[i]); \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Push all zeros in the matrix to the end \n#include \n#include \nusing namespace std; \n \nint main() \n{ \nint i,k ; \ncout<<\"Enter the number of elements in the array \" ; \ncin>>i ; \nint arr[i] ; \nfor(int p=0;p>arr[p] ; \nfor(int p=0;p"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Shortest code here:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void Split(std::vector & vec) { \n  int k = -1; \n  for (int i = 0; i < vec.size(); i++) { \n    if (vec[i] != 0) std::swap(vec[++k], vec[i]); \n  } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void PushZeros(int[] arr ){  \n  int pos = 0 ; \n  for(int i = 0 ; i < arr.length ; i++){ \n    if(arr[i]!= 0) arr[pos++] = arr[i]; \n  } \n  for(int i = pos ; i < arr.length ; i++) \n    arr[i] = 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void PushZeros(int[] arr ){  \n  int pos = 0 ; \n  for(int i = 0 ; i < arr.length ; i++){ \n    if(arr[i]!= 0) arr[pos++] = arr[i]; \n  } \n  for(int i = pos ; i < arr.length ; i++) \n    arr[i] = 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void putNumbersAtEnd(int[] arrayNum) {  if(arrayNum.length < 2) return;  int pointer1=0;  int pointer2=1;  int temp;    while(pointer2  {     if(arrayNum[pointer1]==0 && arrayNum[pointer2]!=0)   {    //Swap the values    temp =arrayNum[pointer1];    arrayNum[pointer1] = arrayNum[pointer2];    arrayNum[pointer2] = temp;      }   if(arrayNum[pointer1]!=0)   {    pointer1++;   }   pointer2++;  }  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=12442671","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"11","title":"Print the binary tree level by level. Suggest  methods. If one of your method is using queue and some delimiter is detect the change in levels, what is its space and time complexity. Prove your analysis. (yes, CLRS style proof is expected)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void Util::PrintLayers(BTree* RootNode) {  queue myqueue;  myqueue.push(RootNode);  BTree* tempNode = RootNode;  int OldLevel  = 1;  int NewLevel  = 0;  while(myqueue.size() != 0)  {   tempNode = myqueue.front();       cout<<\"\\t\"<Value;   if(tempNode->Left != 0)   {    myqueue.push(tempNode->Left);    NewLevel++;   }   if(tempNode->Right != 0)   {    myqueue.push(tempNode->Right);    NewLevel++;   }   myqueue.pop();   OldLevel--;   if(OldLevel == 0)   {    OldLevel = NewLevel;    NewLevel = 0;    cout<  }  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void print_LL(Node* node){//written in c++    queue curr;  if(node == NULL) return;  curr.push(node);   int k= curr.size();  while(!curr.empty()){   Node *node = curr.front();   cout<data<<\" \";   curr.pop();   k--;   if(node->left != NULL) curr.push(node->left);   if(node->right != NULL) curr.push(node->right);   if(k==0 && !curr.empty()) {k=curr.size(); cout< } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"queue.push(head); \nqueue.push(\"\"); \nwhile(queue.size != 0) \n{ \n      elem = queue.pop(); \n      if( elem == \"\" && queue.size() != 0) { \n               queue.push(\"\"); \n               continue; \n      } \n     if(elem->left) queue.push(elem->left); \n    if(elem->right) queue.push(elem->right); \n} \nif tree is as below: \n              50 \n     30             60 \n20       40   55    70 \n \nthen it will be as follows: \n1) 50->\"\" \n2) print 50, enque 30, 60, queue looks like \"\"->30->60 \n3) print \"\", enqueue \"\", queue looks like 30->60->\"\" \n4) print 30, enqueue 20, 40 queue looks like 60->\"\"->20->40 \n5) print 60, enqueue 55, 70 queue looks like \"\"->20->40->55->70 \n6) print \"\", enqueue \"\" queue looks like 20->40->55->70->\"\" \n7) since they are leaf nodes, we will just pop them off \n \nso output is: 50, \" \", 30,60, \" \", 20,40,55,70, \" \""},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Pseudocode"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Your nickname is great! *rofl*  Okay this has gotten way uglier than I anticipated but except for the printTree function the code doesn't really matter..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static void PrintTreeLevelOrderQueue(TreeNode root) \n        { \n            var q = new Queue(); \n            q.Enqueue(root); \n            var currentCount = 1; \n            var nextCount = 0; \n            while(q.Count > 0) \n            { \n                var currentNode = q.Dequeue(); \n                Console.Write(currentNode.Value + \" \"); \n                currentCount -= 1; \n                if (currentNode.Left != null) \n                { \n                    q.Enqueue(currentNode.Left); \n                    nextCount += 1; \n                } \n                if (currentNode.Right != null) \n                { \n                    q.Enqueue(currentNode.Right); \n                    nextCount += 1; \n                } \n                if(currentCount == 0) \n                { \n                    Console.WriteLine(); \n                    currentCount = nextCount; \n                    nextCount = 0; \n                } \n            } \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"LevelPrint(node* T ) \n{ \n if( T==NULL )return; \n queueQ ; \n Q.enqueue(T); \n Q.enqueue(NULL);  \n while(!Q.empty()) \n { \n       node* t = Q.dequeue(); \n       if( t!=NULL ) \n       { \n           if(t->left) \n           Q.enqueue(t->left); \n            \n           if(t->right) \n           Q.enqueue(t->right); \n            \n           print(t); \n       } \n       else \n       { \n           Q.enqueue(NULL); \n       } \n } \n               \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=12698695","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"32","title":"You are given C containers, B black balls and an unlimited number of white balls. You want to distribute balls between the containers in a way that every container contains at least one ball and the probability of selecting a white ball is greater or equal to P percent. The selection is done by randomly picking a container followed by randomly picking a ball from it.   Find the minimal required number of white balls to achieve that.  INPUT  The first line contains 1 <= T <= 10 - the number of testcases.  Each of the following T lines contain three integers  C B P separated by a single space 1<= C <= 1000; 0 <= B <= 1000; 0 <= P <= 100;  OUTPUT  For each testcase output a line containing an integer - the minimal number of white balls required.  (The tests will assure that it's possible with a finite number of balls)  SAMPLE INPUT  3 1 1 60 2 1 60 10 2 50  SAMPLE OUTPUT  2 2 8  EXPLANATION  In the 1st testcase if we put 2 white balls and 1 black ball in the box the probability of selecting a white one is 66.(6)% which is greater than 60%  In the 2nd testcase putting a single white ball in one box and white+black in the other gives us 0.5 * 100% + 0.5 * 50% = 75%  For the 3rd testcase remember that we want at least one ball in each of the boxes.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"//test cases above passed #include  #include  #include  using namespace std;  int main() {  int T;  long long C,B,P;  scanf(\"%d\",&T);  while(T--)  {   scanf(\"%lld %lld %lld\",&C,&B,&P);   if(100==P)   {    if(0==B)cout << C << endl;    continue;   }   if(100*(C-1)<=P*C)    cout << (C-B-1+(int ((double(100*B))/(double((100-P)*C))))) << endl;   else    cout << int (ceil((double(C*P)/100))) << endl;  }  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Are you sure this question was asked in an onsite interview ? This looks like a Facebook programming contest question."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I could not understand why do you have following condition   : if(p==100)    return Integer.MAX_VALUE;   ideally it should be if(p=100) return C;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I could not understand why do you have following condition   : if(p==100)    return Integer.MAX_VALUE;   ideally it should be if(p=100) return C;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"worked against examples provided above. This should be a bin search and greed problem. given W white balls. The best solution is to make the num of containers have one and only on white ball maxmized. see code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This code works fine: W=0; if(C==1) {   while(W*100"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For the third test case 10 2 50.  Can't we put 10Black balls + 1 white ball in first container and 1 white ball in second container So the probability  of selecting a white ball is  (1/2)*(1/11) + (1/2)*(1/1) =0.045  + 0.5 =0.545 which is greater than 0.5 Did i understand the question properly?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* Enter your code here. Read input from STDIN. Print output to STDOUT */  #include #include #include  #include   using namespace std;  int minNumberOfBalls(int c,int b, int p){   if(p==100)    return INT_MAX;      double targetprob=(double)p/100;   double containerprob=(double)1.0/c;      int min=0;   if(b   min=c-b;      double w1=(targetprob/containerprob);      double remainingprob=(targetprob-containerprob*(int)w1)*containerprob;      double w2=((double)remainingprob*b/(double)(1.0-remainingprob));      return max((int)(ceil(w1)+(w2)), min);  }    int main() {     int N;          cin>>N;     int c,b,p;     while(N--)     {         cin>>c>>b>>p;         cout<    } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n \nint minBalls( int containers, int bBalls, int prob ) \n{ \n        int min_wBalls = 0; \n        if ( containers == 0 || bBalls == 0 ) { \n                return containers; \n        } \n        if(containers > bBalls) \n        { \n                min_wBalls = containers - bBalls; \n        } \n        double dprob = (double)prob/100; \n        int wBalls = ceil (((min_wBalls*(dprob - 1)) + (bBalls * dprob))/(1 - dprob)); \n        wBalls = min_wBalls + wBalls; \n        if((wBalls + bBalls) < containers) \n        { \n                wBalls = wBalls + (containers - (wBalls + bBalls)); \n        } \n        return wBalls; \n} \n \n \nint main() \n{ \n        printf(\"\\t%d\", minBalls(1,1,60)); \n        printf(\"\\t%d\",minBalls(2,1,60)); \n        printf(\"\\t%d\",minBalls(10,2,50)); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include int main() {         float diff,c,b,p,w=0,p1;//b=blackball,c=container,w=whiteball         printf(\"enter containers , black ball and probability\");         scanf(\"%f%f%f\",&c,&b,&p);                 if(c>b)             w=c-b;         p1=(1/c)*w;         if(p1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include int main() {         float diff,c,b,p,w=0,p1;//b=blackball,c=container,w=whiteball         printf(\"enter containers , black ball and probability\");         scanf(\"%f%f%f\",&c,&b,&p);                 if(c>b)             w=c-b;         p1=(1/c)*w;         if(p1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This works for all the test cases."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Try this:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"int minBalls( int containers, int bBalls, int pct ) {    if ( containers == 0 || bBalls == 0 ) {     return containers;   }      double dbl_pct = (double) pct /100;      int min_wBalls = ceil (  ( double ) containers * pct / 100 );      while ( min_wBalls + bBalls < containers ) {     min_wBalls++;   }    return min_wBalls++; }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=12945663","download_status":"DOWNLOAD_DONE","votes":"-2","answersCount":"11","title":"Write a function f(n) which computes the number of scoring sequences that add up to score n.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"What's a scoring sequence?  I think I may know what kind of thing you're talking about.  Is this problem akin to \"If a basketball team scored 80 points in a game, how many scoring sequences of 2 or 3 points are possible?\"  In this case, the answer would be F(n) = F (n-2) + F(n-3), subject to base cases of F(2) = F(3) = 1 and F(1) = 0."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I start by thinking of it as a coin problem - given a total amount, how many different ways can you get that amount?  So the 'score' is the amount, and the points are the coin values.  For example, if score was s=100, and points were either {3, 5, 7} the minimum number of shots scored would be 16 (7x13 + 3x3).  You can work backwards from there to find all other possible combinations of shots that would result in a score of 100.  For each individual combination of shots, you then have to multiply by the different ways those shots could be ordered.  For example, all thirteen 7 pointers followed by the three 3 pointers, etc.  This is calculated by [total shots]! / [score-count-1]![score-count-2]!...  so, there are 16!/13!3! or 560 different ways you could make thirteen 7-pointers and three 3-pointers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can you give some example???"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#define SIZE 3 \nint tab[SIZE]={4, 10, 15}; \nint score=80; \n \nint f(s) \n{ \n  printf(\" %d\", s); \n  if(s<0)  \n  { \n    printf(\" nope\\n\"); \n    return(0); \n  } \n  else \n  if(!s) \n  { \n    printf(\" found\\n\"); \n    return(1); \n  } \n  else \n  { \n    return(f(s-tab[0]) || f(s-tab[1]) || f(s-tab[2])); \n  } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool is_bst(struct Node * node) {     return (node->left == NULL && node->right == NULL) ||           (               (node->left == NULL || (node->left->value<=node->value && is_bst(node->left)                &&               (node->right == NULL || (node->right->value>=node->value && is_bst(node->right);           ); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"answer(x) = 2^x EOF"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"answer(x) = 2^x EOF"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=12436663","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"20","title":"Given an unsorted array of integers, find a 3-element subset that sums to zero","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"9","title":"3SUM hard problem. O(n^2) is the best known.  First sort, then for each number x in the array, check if two numbers in the array exists whose sum is -x.  Sorting: O(nlogn). For given x, checking if two numbers in array exist whose sum is -x : O(n), by the standard two pointers method.  So total O(n^2)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"O(nlogn) + O(n^2) = O(n^2). Constant memory! Can be done using a set also but I am not sure if the time complexity can be reduced."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"vijay, i believe you need to change one variable; instead of decrementing k(k=n-1), increment(k=i+2). suppose array contains 6 number and leads to 2 0's it will miss the first pair. see modified code  int main(){  int array[] = {-2,-1,3,20,-30,10};  //int n=sizeof(array[]);  int n = sizeof(array)/sizeof(int);  printf(\"\\n Length-- %d --i\\n\",n);  for(int i = 0; i < n - 1; i++) {printf(\"\\n\\ni %d\",i);       int j = i + 1; printf(\"\\nj %d\",j);         int k = i + 2;//n - 1;         printf(\"\\nk %d\",k);         while(k > j) {             int sum = array[i] + array[j] + array[k];             if(sum == 0) printf(\"\\n %d %d %d\\n\",array[i], array[j], array[k]);             if(sum < 0) j++; else k--;         }   } //    return null; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi, How about we use a hashtable.  We take every two elements in the original array and check of the negative of their sum is there in the hash table. This is also O(n^2) and we dont destroy the original array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is there a way to get this without sorting the array at all?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"you can do it in O(n)  time...with some additional space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Well you need to compute N sets of 3 elements where N is P(n, 3) and while creating them sum up the elements. You need one pass through the array to create N sets of 3. For e.g. if you have array of 3 elements (2, 0, -2) and you want to find 2 elements with 0 sum then you would have the following sets after one pass (2, 0) (2, -2) (0, -2) and you can figure that the second set is 0 sum.   This requires more space but is faster than O(n^2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"This turns out to be a combination problem. In general given \"N\" elements and asked to find a subset of \"R\" elements, it is required to find all the combinations of ( R-1) size from (n-1) elements, and compare with \"N\" element which is taken as reference and this happens \"N\" times.  Hence for any give problem to find out the subset of \" R \" elements it takes  O( N^r+1) time complexity."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=12437661","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"13","title":"Given a set of points (x,y) in a 2-d plane, which are guesses of a particular unknown point (x',y'), how do find the best estimate of (x',y') using the set of points given.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"the question is simple. you need to know the guessing pattern. If not available the best way is to think of it as finding the average of the cluster of the sample points given after identifying the outliers. To find these clusters use a density based clustering algorithm. If a single cluster is formed, print its mean, but if there is more than 1 clusters are found the number could be the centroid of any of these clusters. Hence, in case of more clusters the result will not necessarily give you the right answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"What kind of guesses?  How were these guesses formed?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about just taking the averages? If there are n given points (x', y') = (sum(x)/n, sum(y)/n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I believe it could be solved by Expectation Maximization method."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"fentoyal -- I wrote the answer in the name field."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"best guess is the average point x'=sum of all xs divided by the number of points y'=sum of all ys divided by the number of points"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"maybe we can firstly find the mean using k-means, then calculate the average distance among all other points and the mean?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can mathematically prove that the optimal solution is [sum(x)/n , sum(y)/n].   I just can't figure out a way to type it out here though. Let me give it a try  You can try to minimize summation((x-x')^2) + summation((y-y')^2) and take partial derivatives on x and y. You get 2 equations. Upon solving them you get the optimal solution to be what is mentioned above."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Typical machine learning regression problem. You can use a bunch of method like Linear regression or Neuron Network."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-5","title":"We can find the best guess by finding the distance between two points. 1) Take original point (x,y) 2) Now take first point from points set, say (x1, y1) 3) Now calculate the distance between (x, y) and (x1, y1). 4) Store the distance and first point. 5) Now take second coordinate and find distance between original point (x,y) 6) If second distance is smaller then store second point distance and second point.  Similarly iterate on all points to find best approximate point."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=12332722","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"36","title":"Given a list of words, L, that are all the same length, and a string, S, find the starting position of the substring of S that is a concatenation of each word in L exactly once and without any intervening characters.  This substring will occur exactly once in S..    .   Example:.   L: \"fooo\", \"barr\", \"wing\", \"ding\", \"wing\".   S: \"lingmindraboofooowingdingbarrwingmonkeypoundcake\".                    fooowingdingbarrwing.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"This problem is easier than it appears. We can solve it in O(word length * string length) time.  I just give a hint here, because it shows it is from topcoder. Since all the words have the same length, we can conduct the search for  length-of-word passes, with each pass offsetting 1 more character. e.g. Given: lingmindraboofooowingdingbarrwingmonkeypoundcake we do it in 4 passes, spaces shows how we treat the strings. 1: ling mind rabo ofoo .. 2: ingm indr aboo  fooo 3: ngmi ndra .. 4: gmin drab ... You will find it is easy to handle 1 pass (O(string length) time), The remaining is trivial too."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"We can use well known KMP pattern matching. Search for the all of the strings in the list L for its starting position and save it. If there are multiple matches save all of them.  Find the current lowest index. As long as the current lowest index + current string length = next lowest index.. move on to the next string and do the same. until you have exhausted all the strings in the list L. If you exhaust all the strings return the starting position of first matching string."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"//took about O(N) where N is the length of the long string \n//each word in String[] v must be different! \n public void findString(String L,String[] v) \n { \n  Hashtable table = new Hashtable(); \n  int all = 0; \n  for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about suffix array?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.*; import java.io.*; import java.lang.*;  class stringproject {      public static void main(String[] args)throws IOException     {           String s,f,t;      int z=0;                 DataInputStream x=new DataInputStream(System.in);            String[] a={\"fooo\", \"barr\", \"wing\", \"ding\", \"wing\"};     String m=Arrays.toString(a);          char[] k=m.toCharArray();     java.util.Arrays.sort(k);      t=process(k);                    System.out.println(\"Enter the string\");      s=x.readLine();            try      {            for(int i=0;i<=s.length()-1;i++)      {                       f=s.substring(i,i+t.length());      char[] l=f.toCharArray();      java.util.Arrays.sort(l);              if(process(l).equalsIgnoreCase(t))      {       z=1;      }      }            }catch(StringIndexOutOfBoundsException e){}            if(z>0)      {       System.out.println(\"The given string is present at position\");      }      else      {       System.out.println(\"The given string is not  present\");      }                }          public static String process(char[] k)      {       StringBuffer n=new StringBuffer();       for(int j=0;j<=k.length-1;j++)     {     if(Character.isLetter(k[j]))     {      n.append(k[j]);     }     }     return n.toString();           }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class SubStringConcatentationTest { \n \n    private static String[] L = {\"fooo\", \"barr\", \"wing\", \"ding\", \"wing\"}; \n    private static String S = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\"; \n \n   public static void main(String[] args) { \n \n       Map lastFoundIndexOf = new HashMap(); \n       Integer minStartIndex = null, maxEndIndex = null; \n       int allLengthSum = 0; \n       for(String l : L) { \n           int i = S.indexOf(l, lastFoundIndexOf.get(l) == null ? 0 : lastFoundIndexOf.get(l) + l.length()); \n           if(i < 0) { \n               System.out.println(\"Not found at all.\"); \n               return; \n           } \n           lastFoundIndexOf.put(l, i); \n \n           allLengthSum += l.length(); \n           if(minStartIndex == null || minStartIndex > i) \n                minStartIndex = i; \n           if(maxEndIndex == null || maxEndIndex < i + l.length()) \n               maxEndIndex = i + l.length(); \n       } \n \n       if(allLengthSum > 0 && maxEndIndex != null && (allLengthSum == (maxEndIndex - minStartIndex))) \n           System.out.println(\"Found at start index: \" + minStartIndex + \", substring = \" + S.substring(minStartIndex, maxEndIndex)); \n       else { \n           System.out.println(\"Not found contigously.\"); \n       } \n \n   } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"python example;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use hash(strings) where strings.length = input string length  catch is use some commutative hash function which doesnt change with position of char in the string.  very weak solution( think of hash clashes, false positives)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for(i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int GetPositionStringContainsMultipleStrings(string str, string[] substrings)         {             if (String.IsNullOrEmpty(str)) return -1;              if (substrings == null || substrings.Length == 0) return 0;              var positions = new SortedDictionary();              foreach (var substring in substrings)             {                 int index = 0;                 string copy = str;                  while (index < copy.Length)                 {                     index = copy.IndexOf(substring, index);                      if (index == -1)                     {                         break;                     }                      positions.Add(index, substring);                      copy = copy.Substring(index + substring.Length);                 }             }              if (positions.Count < substrings.Length) return -1;              for (int i = 0; i < positions.Count; i++)             {                 var keys = new List();                  int key = positions.Keys.ElementAt(i);                 keys.Add(key);                  for (int j = 1; j < substrings.Length; j++)                 {                     key += substrings[0].Length;                      if (positions.ContainsKey(key))                     {                         keys.Add(key);                     }                 }                  if (keys.Count == substrings.Length &&                     IsDifferent(keys.ToArray(), positions))                 {                     return positions.Keys.ElementAt(i);                 }             }              return -1;         }          private bool IsDifferent(int[] keys, SortedDictionary positions)         {             for (int i = 0; i < keys.Length - 1; i++)             {                 for (int j = i + 1; j < keys.Length; j++)                 {                     if (positions[keys[i]] == positions[keys[j]])                     {                         return false;                     }                 }             }              return true;         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int GetPositionStringContainsMultipleStrings(string str, string[] substrings)         {             if (String.IsNullOrEmpty(str)) return -1;              if (substrings == null || substrings.Length == 0) return 0;              var positions = new SortedDictionary();              foreach (var substring in substrings)             {                 int index = 0;                 string copy = str;                  while (index < copy.Length)                 {                     index = copy.IndexOf(substring, index);                      if (index == -1)                     {                         break;                     }                      positions.Add(index, substring);                      copy = copy.Substring(index + substring.Length);                 }             }              if (positions.Count < substrings.Length) return -1;              for (int i = 0; i < positions.Count; i++)             {                 var keys = new List();                  int key = positions.Keys.ElementAt(i);                 keys.Add(key);                  for (int j = 1; j < substrings.Length; j++)                 {                     key += substrings[0].Length;                      if (positions.ContainsKey(key))                     {                         keys.Add(key);                     }                 }                  if (keys.Count == substrings.Length &&                     IsDifferent(keys.ToArray(), positions))                 {                     return positions.Keys.ElementAt(i);                 }             }              return -1;         }          private bool IsDifferent(int[] keys, SortedDictionary positions)         {             for (int i = 0; i < keys.Length - 1; i++)             {                 for (int j = i + 1; j < keys.Length; j++)                 {                     if (positions[keys[i]] == positions[keys[j]])                     {                         return false;                     }                 }             }              return true;         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include  using namespace std;  int Find_Index( string L[] , string S , int n ) { int index= 100 , current;          for( int i=0 ; i        {                 int current = S.find(L[i]);                 if( current < index )                         index= current;          } return index; }    int main() {         string l[5] ={ \"fooo\", \"barr\", \"wing\", \"ding\", \"wing\"};         string s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\";         int a = Find_Index(l , s , 5);          cout << a;         return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"an O(sizeof(long string) + sizeof(small string) * length-of-each-small-string )) solution lives here: computationalpuzzles.wordpress.com/2011/11/17/substring-with-concatenation-of-all-words-in-a-list/ but im highly suspicious if this is really a phone interview prob. The algorithm may be too hard to write in 45 minutes."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Build a trie structure with the words in 'L' Now take one letter per iteration from 'S' and try to find out whether all words in the 'L' have been covered!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I've got an easy one."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Does it remind you something?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"L: \"fooo\", \"barr\", \"wing\", \"ding\", \"wing\".  S: \"lingmindraboofooowingdingbarrwingmonkeypoundcake\".  Using brute-force hash based solution: 1. Hash all words in L. (hash value indicate number of occurrence) 2. For each substring of S with length (Number_of_words) * (word_length) 2.1 initialize visit count of the hashtable (and a global visit count) 2.2 for each possible word check and update visit count of the hashtable entry, and decrease global visit count 2.3 a match is fount when global visit count reaches 0  Total cost is O(m * n * l), where m is length of the string, n is number of words, l is length of word.  Can be reduced to O(m * l) with optimization."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def _get_subset_of_len_k(s, k): \n    ret = [] \n    for i in range(0, len(s)): \n        curr = [] \n        j = i \n        while j < len(s): \n            curr.append((s[j:j+4], j)) \n            j+=4 \n        ret.append(curr) \n    return ret \n \n#Given a list of words, L, that are all the same length, and a string, S, find the starting position of the substring of S that is a concatenation of each word in L exactly once and without any intervening characters. This substring will occur exactly once in S.. \ndef get_sub_str(s, words): \n    map = {w:\"\" for w in words} \n    ret = _get_subset_of_len_k(s, 4) \n    start = None \n    for l in ret: \n        start = -1 \n        match = 0 \n        for w, idx in l: \n            if w in map: \n                if start == -1: \n                    start = idx \n                match +=1 \n            else: \n                match = 0 \n                start = -1 \n            if match == len(words): \n                return start \n    return None"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void findString(String L , String[] V){ \n        Hashtable ht = new Hashtable(); \n        int unitNum = V.length; \n        if(unitNum == 0) return; \n        int unitLen = V[0].length(); \n        for(int i = 0 ; i < V.length ; i++){  \n            for(String t : v) ht.put(t , -1); \n            stringSearch(L , i , ht , unitNum , unitLen); \n        } \n    } \n    public void stringSearch(String L , int start , Hashtable ht , int unitNum  , int unitLen){ \n        int curNum = 0 , begin = 0; \n        while( start+unitLen <= L.length() ){ \n            String tem = L.substring(start, start+unitLen); \n            if(!ht.containsKey(tem)){ \n                curNum = 0 ; \n                begin = start+unitLen; \n            } \n            else{ \n              int t = ht.get(tem); \n              if(t >= begin){ \n                curNum -= (t - begin )/unitLen +1; \n                begin = t+unitLen; \n              } \n              ht.put(tem , start); \n              start+=unitLen; \n              curNum++; \n            } \n            if(curNum == unitNum){ \n              System.out.println(L.substring(begin , start)); \n            } \n        } \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"JavaScript implementation  1. Find anagram of all words merged together O(n * log(k)) 2. Check that anagram is actually combination of searched words"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Are you sure this is for phone interview? It is extremely unlikely that you are asked to solve this problem in what is known as \"facebook-45-min-technical\" interview. @topcoder99: can you confirm?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"1. I think we can construct a suffix tree for the input text S. Space and Time required for construction of suffix trees is linear.  2. Once the suffix tree is constructed, we start with each word in L and check if all words are a part of a prefix of a suffix, or its a suffix entirely in the suffix tree for S."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"as per i think just create the all possible permutation of the L and save it in any extra place.now one by one search the every permutation in the string source S as u find stop searching and u will get the locatin if u are using the kmp the trhe searching time will be O(len) where len is the lenghth of the over all words length .now the totac complexity in worst case will be O(k!*len) where k is the total number of words in L."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Please reply and let me know if my approach is wrong.please help me in job searching."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"For finding position    import java.util.*; import java.io.*; import java.lang.*;  class stringproject {     static int p=0;     public static void main(String[] args)throws IOException     {           String s,f,t;      int z=0;                 DataInputStream x=new DataInputStream(System.in);            String[] a={\"fooo\", \"barr\", \"wing\", \"ding\", \"wing\"};     String m=Arrays.toString(a);          char[] k=m.toCharArray();     java.util.Arrays.sort(k);      t=process(k);                    System.out.println(\"Enter the string\");      s=x.readLine();            try      {            for(int i=0;i<=s.length()-1;i++)      {                       f=s.substring(i,i+t.length());      char[] l=f.toCharArray();      java.util.Arrays.sort(l);          p++;             if(process(l).equalsIgnoreCase(t))      {       z=p;      }      }            }catch(StringIndexOutOfBoundsException e){}            if(z>0)      {       System.out.println(\"The given string is present at position\"+(z));      }      else      {       System.out.println(\"The given string is not  present\");      }                }          public static String process(char[] k)      {       StringBuffer n=new StringBuffer();       for(int j=0;j<=k.length-1;j++)     {     if(Character.isLetter(k[j]))     {      n.append(k[j]);     }     }     return n.toString();           }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"segment the s into tokens which are 4 charater length. Using the 4 characters' token as key to build inverted index."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"The implementation of solving the problem is a little complex.My idea is   1. according to L, permutation and concat all the strings, e.g.  L: \"fooo\", \"barr\", \"wing\" => L: A=\"fooo\", B=\"barr\", C=\"wing\" generate: (if the number of strings in L is m, words length is l, the time in this step is O(m!) ABC = \"fooobarrwing\" ACB = \"fooowingbarr\" ......  then generate \"next array\" for every string (which will be used to KMP find) the time is O(m*l)  2. use KMP algo the search every string above in S. (the length of S is n) kmp time complex is O(m*l + n)  so the whole time complex is O(m! + m*l + n)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=12150672","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"34","title":"You have a room-full of balances and weights. Each balance weighs ten pounds and is  considered perfectly balanced when the sum of weights on its left and right sides are   exactly the same. You have placed some weights on some of the balances, and you have placed   some of the balances on other balances. Given a description of how the balances are arranged   and how much additional weight is on each balance, determine how to add weight to the balances  so that they are all perfectly balanced.  There may be more than one way to balance everything, but always choose the way that places additional weight on the lowest balances.  The input file will begin with a single integer, N, specifying how many balances there are. Balance 0 is specified by lines 1 and 2, balance 1 is specified by lines 3 and 4, etc... Each pair of lines is formatted as follows:  WL  WR   WL and WR indicate the weight added to the left and right sides, respectively.   is a space-delimited list of the other balance that are on that side of this balance.    may contain zero or more elements.  Consider the following input:  4 0 1 0 2 0 0 3 3 0 0 0  Balance 0 has balance 1 on its left side and balance 2 on its right side Balance 1 has balance 3 on its right side Balance 2 has three pounds on its left side Balance 3 has nothing on it  Since balance 3 has nothing on it it is already perfectly balanced, and weighs a total of 10 pounds. Balance 2 has no other balance on it, so all we need to do is balance it by putting three pounds on its right side. Now it weighs a total of 16 pounds. Balance 1 has balance three on its right side, which weighs 10 pounds, so we just put 10 pounds on its left side. Balance 1 weighs a total of 30 pounds. Balance 0 has balance 1 on its left side (30 pounds), and balance 2 on its right side (16 pounds), we can balance it by adding 14 pounds to the right side.  The output should be N lines long, with the nth line listing the weight added to the nth balance, formatted as follows:  :    So the output for this problem would be:  0: 0 14 1: 10 0 2: 0 3 3: 0 0","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"binary tree, recurssion.  In each recursive step, balance subnodes (sub balances) before balancing current node.  struct Node{ int leftWeight int rightWeight Node[] leftNodes; Node[] rightNodes; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it seems that according to your input, logical, it can't generate the output sample.  .  Since balance 3 has nothing on it it is already perfectly balanced, and weighs a total of 10 pounds.  why the output is \"3:0 0\", not \"3: 5 5\"  .  Balance 1 has balance three on its right side, which weighs 10 pounds, so we just put 10 pounds on its left side. Balance 1 weighs a total of 30 pounds. why balance 1 weights a total of \"30\" pounds, not \"20\"? do you mean left weights 10 and right weights 10 as well? if Yes, why the output is not \"3:10 10\"?   so,my rough idea is  1. data struct"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am just wondering how many people made it to the end of this question ? ))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Did any one finish this question? Got the solution?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class BalanceProblem { \n \n public class Balance { \n  Integer id; \n  Balance leftBalance; \n  Balance rightBalance; \n  Integer leftBalanceId; \n  Integer rightBalanceId; \n  Integer leftWeight; \n  Integer rightWeight; \n  Integer totalWeight; \n \n  public Balance(Integer id) { \n   this.id = id; \n \n  } \n } \n \n Map balances; \n Map> balanced; \n \n public Map> getBalanced() { \n  return balanced; \n } \n \n public BalanceProblem(String file) throws IOException { \n  File f = new File(file); \n  BufferedReader reader = new BufferedReader(new FileReader(f)); \n  String line = reader.readLine(); \n  balances = new HashMap( \n    Integer.parseInt(line)); \n  boolean balanceProcessed = false; \n  Integer i = 0; \n  Balance b = null; \n  while ((line = reader.readLine()) != null) { \n   String[] split = line.split(\" \"); \n   if (!balanceProcessed) { \n    b = new Balance(i); \n    b.leftWeight = Integer.parseInt(split[0]); \n    if (split.length == 2) { \n     b.leftBalanceId = Integer.parseInt(split[1]); \n    } \n    balanceProcessed = true; \n   } else { \n    b.rightWeight = Integer.parseInt(split[0]); \n    if (split.length == 2) { \n     b.rightBalanceId = Integer.parseInt(split[1]); \n    } \n    balances.put(b.id, b); \n    balanceProcessed = false; \n    ++i; \n   } \n \n  } \n  initializeWeightsAndBalance(); \n } \n \n private int getBalanceWeight(Balance b, int weight) { \n  if (b.leftBalance != null) { \n   if (b.leftBalance.totalWeight == null) { \n    weight += getBalanceWeight(b.leftBalance, weight); \n   } else { \n    weight += b.leftBalance.totalWeight; \n   } \n  } \n  if (b.rightBalance != null) { \n   if (b.rightBalance.totalWeight == null) { \n    weight += getBalanceWeight(b.rightBalance, weight); \n   } else { \n    weight += b.rightBalance.totalWeight; \n   } \n  } \n  weight += b.leftWeight + b.rightWeight; \n  return weight; \n } \n \n private int getBalanceWeight(Balance b) { \n  if (b.totalWeight == null) { \n   return getBalanceWeight(b, 10); \n  } else { \n   return b.totalWeight; \n  } \n } \n  \n private void balanceLeaf(Balance b) { \n  int rightBalanceWeight = 0; \n  int leftBalanceWeight = 0; \n  if (b.leftWeight != b.rightWeight) { \n   if (b.leftWeight > b.rightWeight) { \n    rightBalanceWeight = b.leftWeight - b.rightWeight; \n    b.rightWeight += rightBalanceWeight; \n   } else { \n    leftBalanceWeight = b.rightWeight - b.leftWeight; \n    b.leftWeight += leftBalanceWeight; \n   } \n  }    \n  balanced.put(b.id, new Pair(leftBalanceWeight, \n    rightBalanceWeight)); \n } \n \n private void balanceNode(Balance b) { \n  int rightBalanceWeight = 0; \n  int leftBalanceWeight = 0; \n  int leftWeight = b.leftWeight; \n  if (b.leftBalance != null) { \n   if (!balanced.containsKey(b.leftBalanceId)) { \n    balanceNode(b.leftBalance); \n   } \n   leftWeight += getBalanceWeight(b.leftBalance); \n  } \n  int rightWeight = b.rightWeight; \n  if (b.rightBalance != null) { \n   if (!balanced.containsKey(b.rightBalanceId)) { \n    balanceNode(b.rightBalance); \n   } \n   rightWeight += getBalanceWeight(b.rightBalance); \n  } \n  if (leftWeight != rightWeight) { \n   if (leftWeight > rightWeight) { \n    rightBalanceWeight = leftWeight - rightWeight; \n    b.rightWeight += rightBalanceWeight; \n   } else { \n    leftBalanceWeight = rightWeight - leftWeight; \n    b.leftWeight += leftBalanceWeight; \n   } \n  } \n  balanced.put(b.id, new Pair(leftBalanceWeight, rightBalanceWeight)); \n } \n \n private void initializeWeightsAndBalance() { \n  ArrayList leafBalances = new ArrayList(); \n  ArrayList nodeBalances = new ArrayList(); \n  for (Balance b : balances.values()) { \n   if (b.leftBalanceId == null && b.rightBalanceId == null) { \n    leafBalances.add(b); \n   } else { \n    if (b.leftBalanceId != null) { \n     b.leftBalance = balances.get(b.leftBalanceId); \n    } \n    if (b.rightBalanceId != null) { \n     b.rightBalance = balances.get(b.rightBalanceId); \n    } \n    nodeBalances.add(b); \n   } \n  } \n \n  balanced = new HashMap>(); \n  for (Balance b : leafBalances) { \n   balanceLeaf(b); \n   b.totalWeight = getBalanceWeight(b); \n  } \n \n  for (Balance b : nodeBalances) { \n   if (!balanced.containsKey(b.id)) { \n    balanceNode(b); \n   } \n  } \n } \n \n public static void main(String[] args) throws IOException { \n  String file = \"balance.text\"; \n  BalanceProblem bp = new BalanceProblem(file); \n  Map> balanced = bp.getBalanced(); \n  for (Integer i : balanced.keySet()) { \n   System.out.println(String.format(\"%s : %s\", i, balanced.get(i))); \n  } \n   \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #include #include #include #include #include #include #include #include #include #include #include using namespace std; typedef long long ll; const int inf=1000000000; const double pi=acos(-1.0); #define eps (1e-15) #define L(x) ((x)<<1) #define R(x) ((x)<<1|1) #define see(x)(cerr<<\"[line:\"<<__LINE__<<\" \"<<#x<<\" \"<<#define se(x) cerr<<<\" \" templateT& ls(T& a,T b) { if(btemplateT& gs(T& a,T b) { if(b>a) a=b; return a;} inline int to_i(const string& s) {int n;sscanf(s.c_str(),\"%d\",&n);return n;} inline string to_s(int n) {char buf[32];sprintf(buf,\"%d\",n);return string(buf);}  const int maxn =1000; int n,m; struct node {  vector l,r;  int la,ra;  int sum,add;  node(){};  void init()  {   l.clear();   r.clear();   la=ra=0;   sum=10;   add=0;  } }tr[maxn]; int cur=0; char ch[1000];  int get(int rt) {  int i,j,k;  for(i=0; i {   k=get(tr[rt].l[i]);   tr[rt].la+=k;  }    for(i=0; i {   k=get(tr[rt].r[i]);   tr[rt].ra+=k;  }  tr[rt].add=tr[rt].la-tr[rt].ra;  return tr[rt].sum+=max(tr[rt].la,tr[rt].ra)*2; }  int main() {  freopen(\"in.txt\",\"r\",stdin);  int i,j,k,t,x,y;  cur=1;  scanf(\"%d\",&n);  getchar();  string s;  for(i=1; i<=n; i++)  {   tr[i].init();   stringstream  in;   cin.getline(ch,1000);   in<  in>>x;      tr[i].la=x;   while(in>>x)   {    x++;    tr[i].l.push_back(x);   }   in.clear();   cin.getline(ch,1000);   in<  in>>x;      tr[i].ra=x;   while(in>>x)   {    x++;    tr[i].r.push_back(x);   }  }  get(1);  for(i=1; i<=n; i++)  {   if(tr[i].add<0)   printf(\"%d:%d %d\\n\",i-1,-tr[i].add,0);   else   printf(\"%d:%d %d\\n\",i-1,0,tr[i].add);  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #include #include  typedef struct stacklist {  struct slinkedlist *val;  struct stacklist *next; }stack;  typedef struct slinkedlist {  int b;  int w;  int awr;  int awl;  int wl;  int wr;  stack *rnext;  stack *lnext; }slist;  int  pop(stack **head) {  stack *temp;  temp=(*head);  (*head)=temp->next;  free(temp); }  int sfree(stack **head) {  if((*head)!=NULL)  {   stack *temp=(*head)->next;   free((*head));   sfree(&temp);  }  return 0; }   int push(stack **head,slist *data) {  stack *temp=(stack *)malloc(sizeof(stack));  temp->val=data;  temp->next=(*head);  (*head)=temp; }  int sum(slist *num) {  stack *temp;  if(num->b==1) return num->w;  while(num->rnext!=NULL)  {   num->wr+=sum(num->rnext->val);   num->rnext=num->rnext->next;  }  while(num->lnext!=NULL)  {   num->wl+=sum(num->lnext->val);   num->lnext=num->lnext->next;  }  if(num->wr>num->wl)  {   num->awr=0;   num->awl=num->wr-num->wl;   num->w=10+2*(num->wr);  }  else  {   num->awl=0;   num->awr=num->wl-num->wr;   num->w=10+2*(num->wl);  }  num->b=1;  return num->w; }  int main() {  int i,j,k;  int n;  char c;  int temp;  slist *num;  scanf(\"%d\",&n);  num=(slist *)malloc(n*sizeof(slist));  for(i=0;i {   num[i].rnext=NULL;   num[i].lnext=NULL;   num[i].b=0;   scanf(\"%d\",&(num[i].wl));   scanf(\"%c\",&c);   while(c!='\\n')   {    scanf(\"%d\",&temp);    push(&(num[i].lnext),&num[temp]);    scanf(\"%c\",&c);   }   scanf(\"%d\",&(num[i].wr));    scanf(\"%c\",&c);   while(c!='\\n')   {    scanf(\"%d\",&temp);    push(&(num[i].rnext),&num[temp]);    scanf(\"%c\",&c);   }  }  for(i=0;i {   sum(&num[i]);  }  for(i=0;i {   printf(\"%d: %d %d\\n\",i,num[i].awl,num[i].awr);  }  for(i=0;i {   sfree(&(num[i].rnext));   sfree(&(num[i].lnext));  }  free(num);  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #include #include using namespace std;  class balances {         public:                 int lweight;                 int rweight;                 vector lchild;                 vector rchild;                 int total;         balances()         {                 lweight = rweight = total = -1;         } };  class output {         public:                 int lweight;                 int rweight;         output()         {                 lweight = rweight = -1;         } };  int main() {         stack st;         int num;         cin>>num;         balances balance[num];         output out[num];         cin.ignore();         for(int i=0;i        {                 int w = 0;                 string str;                 getline(cin, str);                 const char* s = str.c_str();                 char* line = const_cast (s);                 char* tok = strtok(line, \" \");                 balance[i].lweight = atoi(tok);                 tok = strtok(NULL, \" \");                 while(tok!=NULL)                 {                         balance[i].lchild.push_back(atoi(tok));                         tok = strtok(NULL, \" \");                 }                 getline(cin, str);                 s = str.c_str();                 line = const_cast(s);                 tok = strtok(line, \" \");                 balance[i].rweight = atoi(tok);                 tok = strtok(NULL, \" \");                 while(tok!=NULL)                 {                         balance[i].rchild.push_back(atoi(tok));                         tok = strtok(NULL, \" \");                 }                 if((balance[i].lchild.size() == 0) && (balance[i].rchild.size() == 0))                 {                         if(balance[i].lweight == balance[i].rweight)                         {                                 balance[i].total = balance[i].lweight + balance[i].rweight + 10;                                 out[i].lweight = out[i].rweight = 0;                         }                         else                         {                                 if(balance[i].lweight > balance[i].rweight)                                 {                                         out[i].lweight = 0;                                         out[i].rweight = balance[i].lweight - balance[i].rweight;                                         balance[i].total = balance[i].lweight + balance[i].rweight + 10 + out[i].rweight;                                 }                                 else                                 {                                         out[i].rweight = 0;                                         out[i].lweight = balance[i].rweight - balance[i].lweight;                                         balance[i].total = balance[i].lweight + balance[i].rweight + 10 + out[i].lweight;                                 }                         }                 }          }         int i=0;         while(i        {                 int flag = 0;                 int diff = 0;                 if(balance[i].total != -1)                 {                         if(st.size()!=0)                         {                                 i = st.top();                                 st.pop();                         }                         else                                 i++;                         continue;                 }                 for(int j = 0;j                {"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorry for the above post. Submitted by mistake.  Here is the code I wrote for it. I did not try and cleanup or improve it so might have redundant stuff. But it works."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Its a simple recursive DFS like soln Store set of left balances, right balances initialize each one to isBalanced = false"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my recursive implementation . ( pseudo code ) I am assuming input is stored in file.  No NULL checking."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n#include \n#include \n#include \nusing namespace std; \n \nstruct node \n{ \n int lw; \n int rw; \n vector l; \n vector r; \n}*start; \n \nint main() \n{ \n char s[100]; \n vector v; \n \n start=NULL; \n node *temp; \n int n,lw,rw,k,num,c,l; \n cin>>n; \n node **isset=new node*[n]; \n  \n for(int i=0;i=0) \n   { \n    num+=(v[l]*c); \n    c*=10; \n    l--; \n   } \n   lw=num; \n    \n   if(start==NULL) \n   { \n    start=new node; \n    isset[0]=start; \n   } \n    \n   if(isset[i]==NULL) \n   { \n    temp=new node; \n    isset[i]=temp; \n   } \n   if(j) \n    (isset[i])->rw=lw; \n   else \n    (isset[i])->lw=lw; \n    \n    \n   if(k!=strlen(s)) \n   { \n     \n    while(k!=strlen(s)) \n    { \n     k++; \n     v.clear(); \n     while(k!=strlen(s) && s[k]!=' ') \n     {  \n      v.push_back(s[k]-'0'); \n      k++; \n     } \n      \n     \n     num=0; \n     c=1; \n     l=v.size()-1; \n     while(l>=0) \n     { \n      num+=(v[l]*c); \n      c*=10; \n      l--; \n     } \n      \n     if(isset[num]==NULL) \n     { \n      temp=new node; \n      isset[num]=temp; \n     } \n      \n     if(j==0) \n      ((isset[i])->l).push_back(num); \n     else \n      ((isset[i])->r).push_back(num); \n      \n      \n    } \n   } \n     \n  } \n    \n } \n  \n v.clear(); \n int x,y,z; \n queue q; \n  \n temp=start; \n q.push(0); \n  \n while(!q.empty()) \n { \n  x=q.front(); \n  q.pop(); \n  v.push_back(x); \n   \n  y=0; \n  while(y!=((isset[x])->l).size()) \n  {  \n   q.push((isset[x]->l)[y]); \n   y++; \n  } \n  y=0; \n  while(y!=((isset[x])->r).size()) \n  {  \n   q.push((isset[x]->r)[y]); \n   y++; \n  } \n } \n  \n int **ans=new int*[n]; \n  \n for(int i=0;i=0) \n { \n  lw=(isset[v[y]]->lw); \n  z=0; \n  while(z!=(((isset[v[y]])->l).size())) \n  {  \n   lw+=(tw[(isset[v[y]]->l)[z]]); \n   z++; \n  } \n  z=0; \n  rw=(isset[v[y]]->rw); \n  while(z!=(((isset[v[y]])->r).size())) \n  {  \n   rw+=(tw[(isset[v[y]]->r)[z]]); \n   z++; \n  } \n    \n  if(lw>rw) \n  {  \n   ans[v[y]][1]=(lw-rw); \n   isset[v[y]]->rw=lw; \n   rw=lw; \n  } \n  else if(rw>lw) \n  {  \n   ans[v[y]][0]=(rw-lw); \n   isset[v[y]]->lw=rw; \n   lw=rw; \n  } \n  tw[v[y]]=lw+rw+10; \n \n  y--; \n   \n } \n  \n for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #include #include using namespace std; struct node  {  int nodenum;  int left;  int right;  vector leftbal;  vector rightbal;  int total;  }; int main() {  struct node *arr[10];  int N;  int l=1;  int level[100]={0};  char str[100];  int result=0; cin>>N; for(int i=0;i{  struct node *p;  p=(struct node *)malloc(sizeof(struct node));  p->nodenum=i;  p->total=0;  arr[i]=p;  fflush(stdin);  for(int j=0;j<2;j++)  {   fflush(stdin);   gets(str);   fflush(stdin);   int flag=0;   int number=0;      for(int k=0;k  {    if(str[k]==' ' && flag==0)    {         if(j==0)     {      p->left=number;     }     else     {      p->right=number;     }     number=0;     flag=1;     continue;    }    else if(str[k]==' ' && flag==1)    {       if(j==0)     {      p->leftbal.push_back(number);     }     else     {      p->rightbal.push_back(number);     }     level[l]=number;     l++;     number=0;     continue;       }       number=number*10+(str[k]-'0');     }      if(flag==0)   {     if(j==0)     {      p->left=number;     }     else     {      p->right=number;     }    }   else   {          if(j==0)     {              p->leftbal.push_back(number);     }     else     {          p->rightbal.push_back(number);     }      level[l]=number;   l++;      }   }  } for(int i=N-1;i>=0;i--) { int balance=level[i];  struct node *p=arr[balance]; int wl=p->left; int wr=p->right; int index=-1; for(int j=0;jleftbal.size();j++) {  index=p->leftbal[j];  wl=wl+arr[index]->total;  }  for(int j=0;jrightbal.size();j++) {  index=p->rightbal[j];  wr=wr+arr[index]->total; } p->left=wl; p->right=wr; if(wl>wr) {    result=result+(wl-wr);  p->total=2*wl + 10; } else {  result=result+(wr-wl);  p->total=2*wr +10; }   }  for(int i=0;i{  struct node *p;  p=arr[i];  if((p->left)>(p->right))  cout<nodenum<<\": \"<<0<<\" \"<<(p->left)-(p->right)<<\"\\n\";  else  cout<nodenum<<\": \"<<(p->right)-(p->left)<<\" \"<<0<<\"\\n\"; }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #include #include #include #include using namespace std; struct node  {  int nodenum;  int left;  int right;  vector leftbal;  vector rightbal;  int total;  }; int main() {  struct node *arr[10];  int N;    char str[100];  int result=0; cin>>N; for(int i=0;i{  struct node *p;  p=(struct node *)malloc(sizeof(struct node));  p->nodenum=i;  p->total=0;  arr[i]=p;  fflush(stdin);  for(int j=0;j<2;j++)  {   fflush(stdin);   gets(str);   fflush(stdin);   int flag=0;   int number=0;      for(int k=0;k  {    if(str[k]==' ' && flag==0)    {         if(j==0)     {      p->left=number;     }     else     {      p->right=number;     }     number=0;     flag=1;     continue;    }    else if(str[k]==' ' && flag==1)    {       if(j==0)     {      p->leftbal.push_back(number);     }     else     {      p->rightbal.push_back(number);     }         number=0;     continue;       }       number=number*10+(str[k]-'0');     }      if(flag==0)   {     if(j==0)     {      p->left=number;     }     else     {      p->right=number;     }    }   else   {          if(j==0)     {            p->leftbal.push_back(number);     }     else     {        p->rightbal.push_back(number);     }         }   }  } int start=0; for(int i=0;i{  struct node *p;  p=arr[i];  for(int j=0;jleftbal.size();j++) {  if(p->leftbal[j]==start)  start=i; }  for(int j=0;jrightbal.size();j++) {  if(p->rightbal[j]==start)  start=i; } } queue  myqueue; stack  final; myqueue.push(start); while(!myqueue.empty()) {  int id=myqueue.front();  myqueue.pop();  final.push(id);  struct node *p;  p=arr[id];  for(int j=0;jleftbal.size();j++)  {  myqueue.push(p->leftbal[j]);  }   for(int j=0;jrightbal.size();j++)  {  myqueue.push(p->rightbal[j]);  }  }    while(!final.empty()) { int balance=final.top(); final.pop(); cout<<\"balance is\"<<struct node *p=arr[balance]; int wl=p->left; int wr=p->right; int index=-1; for(int j=0;jleftbal.size();j++) {  index=p->leftbal[j];  wl=wl+arr[index]->total;  }  for(int j=0;jrightbal.size();j++) {  index=p->rightbal[j];  wr=wr+arr[index]->total; } p->left=wl; p->right=wr; if(wl>wr) {    result=result+(wl-wr);  p->total=2*wl + 10; } else {  result=result+(wr-wl);  p->total=2*wr +10; }   }  for(int i=0;i{  struct node *p;  p=arr[i];  if((p->left)>(p->right))  cout<nodenum<<\": \"<<0<<\" \"<<(p->left)-(p->right)<<\"\\n\";  else  cout<nodenum<<\": \"<<(p->right)-(p->left)<<\" \"<<0<<\"\\n\"; } cout<}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//taking input fronm a txt file named fb.txt #include typedef struct node{ int weight; int name; int lw; int rw; struct node*left; struct node*right;  }*NODEPTR; NODEPTR ptree; void inorder(NODEPTR p); void print_bal(NODEPTR p); void main() {     ptree=0;  //input   int N;      FILE *f;    int i,b,wl,wr,bl,br,t;    f=fopen(\"fb.txt\",\"r\");    fscanf(f,\"%d\",&N);  NODEPTR bal[N]; for(i=0;i{     bal[i]=(NODEPTR*)malloc(sizeof(struct node));     bal[i]->name=i;     bal[i]->left=0;     bal[i]->right=0;     bal[i]->weight=10;     bal[i]->lw=0;     bal[i]->rw=0; }  //create tree   for(i=0;i  {       //if no balance  then enter sothing above N       fscanf(f,\"%d\",&wl);       fscanf(f,\"%d\",&bl);       fscanf(f,\"%d\",&wr);       fscanf(f,\"%d\",&br);       if(bl<=N)       {           if(ptree==0)             ptree=bal[i];           bal[i]->left=bal[bl];       }       if(br<=N)       {           if(ptree==0)             ptree=bal[i];           bal[i]->right=bal[br];       }       bal[i]->lw=wl;       bal[i]->rw=wr;       //bal[i]->weight+=wl+wr;   }   print_bal(ptree); inorder(ptree); }  void inorder(NODEPTR p) {  if(p!=0)  {    inorder(p->left);    printf(\"%d ->\",p->weight);    inorder(p->right);   }  } void print_bal(NODEPTR p) {     int l,r;     if(p!=0)     {         print_bal(p->right);         print_bal(p->left);         if(p->left==0&&p->right==0) // printf(\"NOTHING TO ADD on :%c: w=%d\\n\",p->name,p->weight);          {              if(p->lw==0&&p->rw==0)               ;//do nothing               else if(p->lw!=0&&p->rw==0)                {                     printf(\"node :%d: add to R: %d \\n\",p->name,p->lw);                    // p->weight=p->weight+p->lw;                     p->rw+=p->lw;                 }                 else if(p->rw!=0&&p->lw==0)                 {                     printf(\"node :%d: add to L: %d \\n\",p->name,p->rw);                    // p->weight=p->weight+p->rw;                     p->lw+=p->rw;                  }                   else if(p->rw!=0&&p->lw!=0)                   {                      if(p->lw!=p->rw)                      {                         if(p->lw < p->rw)                           {                             printf(\"node :%d: add to L :%d\\n\",p->name,p->rw-p->lw);                           //  p->weight=p->weight+(p->rw-p->lw);                             p->lw+=(p->rw-p->lw);                           }                          else                          {                              printf(\"node :%d: add to R :%d\\n\",p->name,p->lw-p->rw);                            //  p->weight=p->weight+(p->lw-p->rw);                              p->rw+=(p->lw-p->rw);                          }                       }                  }                 p->weight+=(p->lw+p->rw); //updqte whole weight             }             else if(p->left==0&&p->right!=0)             {                 l=p->lw;                 r=p->rw+p->right->weight;                 if(l!=r)                 {                     if(l>r)                        {                           printf(\"node :%d: add to R :%d\\n\",p->name,l-r);                           p->rw+=l-r;                        }                        else                        {                            printf(\"node :%d: add to L :%d\\n\",p->name,r-l);                           p->lw+=r-l;                        }                 }                  p->weight+=p->rw+p->lw+p->right->weight;             }             else if(p->left!=0&&p->right==0)             {                 l=p->lw+p->left->weight;                 r=p->rw;                 if(l!=r)                 {                     if(l>r)                        {                           printf(\"node :%d: add to R :%d\\n\",p->name,l-r);                           p->rw+=l-r;                        }                        else                        {                            printf(\"node :%d: add to L :%d\\n\",p->name,r-l);                           p->lw+=r-l;                        }                 }                  p->weight+=p->rw+p->lw+p->left->weight;             }             else if(p->left!=0&&p->right!=0)             {                 l=p->right->weight;                 r=p->left->weight;                 l=l+p->lw;                 r=r+p->rw;                 if(l!=r)                 {                     if(l>r)                      {                          printf(\"node :%d: add to R :%d\\n\",p->name,l-r);                           p->rw+=(l-r);                      }                      else                      {                          printf(\"node :%d: add to L :%d\\n\",p->name,r-l);                          p->lw+=(r-l);                      }                 }                 p->weight+=p->rw+p->lw+p->right->weight+p->left->weight;             }       } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.StringTokenizer;  class balance {  int wl;// left weight  int wr;// right weight  int wt;// total weight  int init_wl;  int init_wr;  int[] left_bal;  int[] right_bal; }  public class Main {  public static int n;  public static balance[] bal;  public static int[] flag;   public static void main(String[] args) throws NumberFormatException,    IOException {   BufferedReader br = new BufferedReader(new InputStreamReader(System.in));   StringTokenizer st;    n = Integer.parseInt(br.readLine());   bal = new balance[n];   flag = new int[n];   for (int i = 0; i < n; ++i) {    flag[i] = 0;    /**     * indicates that the balance ith total weight is not calculated     */   }    for (int i = 0; i < n; ++i) {    // adding left balance part    st = new StringTokenizer(br.readLine());    bal[i] = new balance();    bal[i].init_wl = Integer.parseInt(st.nextToken());    bal[i].left_bal = new int[st.countTokens()];    int c1 = st.countTokens();    for (int j = 0; j < c1; ++j) {     bal[i].left_bal[j] = Integer.parseInt(st.nextToken());    }     // adding right balance part    st = new StringTokenizer(br.readLine());    bal[i].init_wr = Integer.parseInt(st.nextToken());    bal[i].right_bal = new int[st.countTokens()];    int c2 = st.countTokens();    for (int j = 0; j < c2; ++j) {     bal[i].right_bal[j] = Integer.parseInt(st.nextToken());    }   }    // Algo for balancing    for (int i = 0; i < n; ++i) {    find_balance(i);   }      //print result   for(int i=0;i  {    if(bal[i].wl>bal[i].wr)    {     System.out.println(i+\": \"+\"0\"+\" \"+diff(bal[i].wl,bal[i].wr));    }    else    {     System.out.println(i+\": \"+diff(bal[i].wl,bal[i].wr)+\" \"+\"0\");    }   }   }   public static void find_balance(int id) {   bal[id].wt=0;   // make sure weight of all left and right balances are found    // left   bal[id].wl=0;   bal[id].wl=bal[id].init_wl;   for (int j = 0; j < bal[id].left_bal.length; ++j) {    if (flag[bal[id].left_bal[j]] == 0) {     //System.out.println(\"find \"+bal[id].left_bal[j]);     find_balance(bal[id].left_bal[j]);         }    bal[id].wl+=bal[bal[id].left_bal[j]].wt;    //System.out.println(\"bal_wL \"+\"(\"+id+\")\"+\"=\"+bal[id].wl);   }   // right   bal[id].wr=0;   bal[id].wr=bal[id].init_wr;   for (int k = 0; k < bal[id].right_bal.length; ++k) {    if (flag[bal[id].right_bal[k]] == 0) {     //System.out.println(\"find \"+bal[id].right_bal[k]);     find_balance(bal[id].right_bal[k]);         }    bal[id].wr+=bal[bal[id].right_bal[k]].wt;    //System.out.println(\"bal_wR \"+\"(\"+id+\")\"+\"=\"+bal[id].wr);   }      //find the weight of current balance   bal[id].wt=bal[id].wl+bal[id].wr+10+diff(bal[id].wl,bal[id].wr);   //System.out.println(\"bal_wT \"+\"(\"+id+\")\"+\"=\"+bal[id].wt);      //set flag   flag[id]=1;   //System.out.println(\"EXIT(\"+id+\")\");   return;  }  public static int diff(int a,int b)  {   if(a>b)    return (a-b);   else    return (b-a);  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//C# : It Works  \nusing System; \n \n \nclass Balance \n    { \n        public int weightLeft; \n        public int weightRight; \n \n        public Balance leftBalance; \n        public Balance rightBalance; \n        public int totalWeight; \n \n        public Balance() \n        { \n            totalWeight = 10; \n            weightLeft = 0; \n            weightRight = 0; \n        } \n \n        public void addWeightLeft(int _value) \n        { \n            weightLeft = _value; \n            totalWeight = totalWeight + weightLeft; \n        } \n        public void addWeightRight(int _value) \n        { \n            weightRight = _value; \n            totalWeight = totalWeight + weightRight; \n        } \n \n \n        public void addLeftBalance(Balance _balance) \n        { \n            leftBalance = _balance; \n            weightLeft += _balance.totalWeight; \n            totalWeight += _balance.totalWeight; \n        } \n        public void addRightBalance(Balance _balance) \n        { \n            rightBalance = _balance; \n            weightRight += _balance.totalWeight; \n            totalWeight += _balance.totalWeight; \n        } \n \n        public void addLeftBalanceExtra() \n        { \n            if (leftBalance != null) \n            { \n                weightLeft += leftBalance.weightLeft; \n                weightRight += leftBalance.weightRight; \n            } \n        } \n        public void addRightBalanceExtra() \n        { \n            if (rightBalance != null) \n            { \n                weightLeft += rightBalance.weightLeft; \n                weightRight += rightBalance.weightRight; \n            } \n        } \n    } \n \n \n    class Program \n    { \n        static void Main(string[] args) \n        { \n \n            int N = Convert.ToInt32(Console.ReadLine()); \n            Balance[] balance = new Balance[N]; \n \n \n            for (int i = 0; i < N; i++) \n            { \n                balance[i] = new Balance(); \n            } \n \n             \n            for (int i = 0; i < N; i++) \n            { \n                string Line1 = Console.ReadLine(); \n                string Line2 = Console.ReadLine(); \n \n                string[] parts1 = Line1.Split(' '); \n                string[] parts2 = Line2.Split(' '); \n \n                 \n                balance[i].addWeightLeft(Convert.ToInt32(parts1[0])); \n                 \n                if (parts1.Length > 1) \n                { \n                    for (int j = 1; j < parts1.Length; j++) \n                    { \n                        balance[i].addLeftBalance(balance[Convert.ToInt32(parts1[j])]); \n                    } \n \n                } \n                balance[i].addWeightRight(Convert.ToInt32(parts2[0])); \n                if (parts2.Length > 1) \n                { \n                    for (int j = 1; j < parts2.Length; j++) \n                    { \n                        balance[i].addRightBalance(balance[Convert.ToInt32(parts2[j])]); \n                    } \n                } \n            } \n \n \n            for (int i = 0; i < N; i++) \n            { \n                balance[i].addLeftBalanceExtra(); \n                balance[i].addRightBalanceExtra(); \n            } \n \n \n \n            for (int i = 0; i < N; i++) \n            { \n                balance[i].addLeftBalanceExtra(); \n                balance[i].addRightBalanceExtra(); \n            } \n \n            for (int i = 0; i < N; i++) \n            { \n                if (balance[i].weightLeft < balance[i].weightRight) \n                { \n                    Console.WriteLine(i + \" : \" + (balance[i].weightRight - balance[i].weightLeft) + \" 0 \"); \n                } \n \n                if (balance[i].weightLeft > balance[i].weightRight) \n                { \n                    Console.WriteLine(i + \" : 0 \" + (balance[i].weightLeft - balance[i].weightRight)); \n                } \n                if (balance[i].weightLeft == balance[i].weightRight) \n                { \n                    Console.WriteLine(i + \" : 0 0\"); \n                } \n            } \n \n            \n            Console.Read(); \n        } \n \n         \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have passed this question in Facebook Programming Puzzle. Code is attached below:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my code !! I don't know but they say its not right !! :("},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The same question was posed as a problem in a coding competition organized at my workplace. Here is the working solution I submitted"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n#include \n#include \n#include \n#include \n#include \n#include \n#include \n#include \n#include \n#include \n#include   \nusing namespace std; \ntypedef long long LL; \ntypedef vector VI; \ntypedef vector VS; \ntypedef pair II; \ntypedef vector VII; \ntypedef vector VVII; \ntypedef vector VVI; \n \n \n#define INF 2000000000 \n#define INFLL (1LL<<62) \n#define FI first \n#define SE second \n#define PB push_back \n#define SS ({int x;scanf(\"%d\\n\", &x);x;}) \n#define SSL ({LL x;scanf(\"%lld\", &x);x;}) \n#define rep(i,n) for(i=0;i<(n);i++) \n#define _mp make_pair \nvector  l[1000] ,r[1000]; \nII w[1000]; \n \nint fun(int n){ \n        int l1,r1,i; \n        l1=r1=0; \n        l1+=l[n][0]; \n        r1+=r[n][0]; \n        rep(i,(int)l[n].size()-1){ \n                l1+=fun(l[n][i+1]); \n        } \n        rep(i,(int)r[n].size()-1){ \n                r1+=fun(r[n][i+1]); \n        } \n        if(l1>r1){ \n                w[n]=_mp(0,l1-r1); \n        } \n        else{ \n                    w[n]=_mp(r1-l1,0); \n        } \n        return 2*max(l1,r1)+10; \n}           \n         \nint main(){ \n        int n=SS,a,b,i,j,k; \n        rep(i,n){ \n                stringstream s; \n                string ss; \n                getline(cin,ss); \n                cout<<\"left \"<<>a){ \n                l[i].PB(a); \n                } \n                stringstream p; \n                getline(cin,ss); \n                p<>a){ \n                r[i].PB(a); \n                } \n                       \n          } \n         fun(0); \n        rep(i,n){ \n                cout<"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=10525951","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"6","title":"how would you detect mouth in a picture","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This can be solved using graphs. 1) each pixel in the image would represent a vertex in a graph with an edge between 2 neighboring pixels. The weight of the edge should be proportional to the darkness of the pixel. 2) identify different connected components (eye, node, mouth) in the image using spanning tree algorithm. 3) the last of the puzzle is to identify which of the connected component is the mouth. each connected component (eye, nose, mouth, etc) would be represented as a vertex in a graph and the edge weight is proportional to their distance from each other. using shortest path, you can identify 2 pair of eyes and the component that is farthest from the eyes is the mouth."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Is it a human mouth? an open mouth or a closed mouth? Is a mouth guaranteed to be present or not? If so how many mouths can exist in a single picture? Is the picture always in a particular orientation.  These are some questions that could be asked as clarification."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@future googler: it is not mentioned that the picture will have a full face. It can be only lips in the picture. I think different approach is needed. One basic property of lips is two points having three different lines touching them. I think if we consider a graph with nodes as pixels. Then each pair would have three lines where lines starting from one point would end in the other. Probably lines have different properties which can be figured out. I this can be one point to be considered. Also, the pair of points could be eyes too. These are just my thoughts.  Note that I don't have a solution/algorithm/design right now."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"An automatic face morphing algorithm is proposed.  The algorithm automatically extracts feature points on the face, and based on these feature points images are partitioned and face morphing is performed.  The algorithm has been used to generate morphing between images of faces of different people as well as between different images of the face of an individual.  The results of both inter- and intra-personal morphing are subjectively satisfactory.  ref-->/ ccrma.stanford.edu/~jacobliu/368Report/index.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Viola Jones ...."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=12266664","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"17","title":"You are given a list of points in the plane, write a program that  outputs each point along with the three other points that are closest  to it. These three points ordered by distance.  The order is less then O(n^2) .   For example, given a set of points where each line is of the form: ID  x-coordinate y-coordinate    1  0.0      0.0  2  10.1     -10.1  3  -12.2    12.2  4  38.3     38.3  5  79.99    179.99    Your program should output:    1 2,3,4  2 1,3,4  3 1,2,4  4 1,2,3  5 4,3,1","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"can be solved using kd trees. Best case/Average case: O(lg n)...worst case: O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Similar question was asked to me in amazon telephonic. Here is my solution, Take first 3 nodes and build the max heap. heap contains the distance between the given point and the remaining points. Starting from next point, compute the distance to given point and compare the current distance with max element.. if it is greater than the max element then go to next element otherwise pop the max element and add this element. In order to print the points, we can maintain a hash table (key=address to heap node, value = point(x,y))..  Any better solution?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is possible in O(n^2). There are C(n,2) pairs involved. Calculate and cache the distance between each of them. Then for each point calculate the 3 min ditance in O(n) time.  Total time=O(n^2)+O(n)=O(n^2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"By using O(N) memory and yet another extension of algorithm mentioned \nin Cormen (33.4), we can achieve an algorithm with O(NlogN) best case \nand O(N^2) worst case."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sort the vertices along x axis, ie sort points in increasing value of x coordinate. For each node maintain list of closest three points. After sorting do a horizontal scan of vertices. Once, the horizontal distance between two vertices becomes greater than furthest point of the vertex, it need not be part of further comparisons.  Ex, suppose points after sorting on x coordinate is , a,b,c,d,e,f,g.   Scan this list. By the time we reach point f, if horizontal dist between ,say a and f is greater than the biggest of the three closest points to a, the vertex a need not be part of any further comparisons.  I think this will limit the number of comparisons,( worst case is still O ( n2) though )."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First, sort along x-axis O(nlog(n)) Second, sort along y-axis O(nlog(n)) Third, find from nearest 6 (x and y) O(n) Totally: O(nlog(n))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i've tested this one , assuming that the distance cannot be equal to Double.MAX_VALUE =)  {{ public static void closest_points(Point[] points)  {   int[][] distances = new int[points.length][3];   for (int i=0; i  {    Point current_point = points[i];    Hashtable ht = new Hashtable();    double[] aux_distances = new double[points.length-1];    for (int j=0; j   {     if (i!=j){      double d = distance(current_point,points[j]);       aux_distances[j]=d;       if (d!=0)      ht.put(d,j);     } else     {      aux_distances[j]=Double.MAX_VALUE;       }    }   // print_array(aux_distances);    Arrays.sort(aux_distances);        for (int k=0; k<3; k++)    {     if (ht.get(aux_distances[k])!=null){     int index = (Integer)ht.get(aux_distances[k]);     distances[i][k] = index; }    }   }      for (int i=0; i< points.length; i++)   {    System.out.printf(\"%d  \", i+1);    for (int j=0; j<3;j++){     System.out.printf(\" %d \",distances[i][j]+1);    }    System.out.printf(\"\\n\");   }  } }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is straightforward Java implementation with quadratic asymptotic runtime. I think this should be sufficient for an interview."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5172577290944512","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"29","title":"Given an array write a function to print all triplets in the array which sum of 0. e.g:  Input: Array = [-1, -3, 5, 4] output:  -1, -3, 4","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Loop through the array...for every item reduce the problem to classic \"pairs with sum\" problem and solve using HashMap. The time would be O(n^2). E.g. [-1,-3,5,4] for first item -1 find all the pairs with sum= (0-(-1)=1.  which would be -3 and 4 (-3+4=1),so triplet will be -1,-3 and 4."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"My decision on python:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Iterate over the array and for each item reduce the problem to classic \"pairs with sum\" problem.  E.g. For [-1,-3,4,5]   for first item -1 find all the pairs in remaining [-3,4,5] whose sum is 0-(-1) =1. You can use HashMap to find the pairs. The time eff. would be O(n^2)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it is 3 sum problem. first of all, sort the array, then for each array[i], it is our job to find two elements from array[i+1] to array[n-1] that their sum is 0. then this question becomes 2sum problem.  if the array is unique the time complexity is O(n^2) if the array has replicated elements, time complexity is O(n^2log(n))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int searchit(int *t, int v, int i, int size) \n{ \n int h=v%size; \n \n if(t[h]==v && h!=i) \n  return h; \n int pos=(h+1)%size; \n int p=h-1; \n if(p<0) \n  p=size; \n while(pos!=p) \n { \n  if(t[pos]==v && pos!=i) \n   return pos; \n  pos=(pos+1)%size; \n } \n printf(\"\\n\"); \n return -1; \n} \n \n \nvoid ContinousSubArraySumZero_LimitedCount(int a[], int n, int count) \n{ \n int *t=new int[n+1]; \n \n memset(t,INT_MIN,sizeof(int)*(n+1)); \n t[0]=0; \n int i,j,k; \n \n for(i=1;ii && (j-i<=count)) \n  { \n   for(k=i;k"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"first we solve the classic subset sum problem,then we find the triplets subset.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can be solved in O(n^2). Iterate the array (i = 0 to n) and for each (i) add each other element in the array (j = i to n)m and check if difference to form sum 0, exist in the hashtable(h). if not found in h, add that a[j] to h as key and value as j (position). Here is the code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the array does not contain duplicated numbers, The algorithm's time complexity is O(n^2)?? But if not, let's set the array {-3, -3, 0, 3}. is the output: -3, 0, 3 or: -3, 0, 3 and -3, 0, 3? should we print all the duplicated triplets? If yes, I guess the problem is much more complex. Some one can give the code?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"void printTriplet(const int a[], int n) \n{ \n    for( int x = 0; x < n ; x ++ ) \n    { \n        for( int y = 0; y < n; y ++ ) \n        { \n            result[x][y] = a[x] + a[y]; \n            processed[x][y] = false; \n    } \n     \n    int[] sortedArray = sort( a, n ); \n     \n    for( int x = 0; x < n ; x ++ ) \n    { \n        for( int y = 0; y < n - x; y ++ ) \n        { \n            if( processed[x][y] ) \n                continue; \n                 \n            processed[x][y] = true; \n            int itemToLook = 0 - result[x][y]; \n            bool found = binarySearch( sortedArray, n, itemToLook ); \n            if( found ) \n            { \n                int z = search( a, n, itemToLook ); \n                processed[y][x] = true; \n                processed[x][z] = true; \n                processed[y][z] = true; \n                processed[z][x] = true; \n                processed[z][y] = true; \n                print( a[x], a[y], itemToLook ); \n            } \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"static void ArrayTriplesNoDupe(int[] sequence) \n        { \n            HashSet> hs = new HashSet>(); \n \n            int executions = 0; \n            for (int i = 0; i < sequence.Length - 2; i++) \n            { \n                for (int j = i + 1; j < sequence.Length - 1; j++) \n                { \n                    for (int k = j + 1; k <= sequence.Length - 1; k++) \n                    { \n                        Tuple t = new Tuple(sequence[i],sequence[j],sequence[k]); \n \n                        if (hs.Contains(t)) \n                        { \n                            Console.WriteLine(\"Collision: {0}\", t.ToString()); \n                            continue; \n                        } \n                        executions++; \n                        if ((sequence[i] + sequence[j] + sequence[k]) == 0) \n                        { \n                            hs.Add(t); \n                            Console.WriteLine(\"{0},{1},{2}\", sequence[i], sequence[j], sequence[k]); \n                        } \n                    } \n                } \n            } \n \n            Console.WriteLine(\"Executions: {0}\", executions); \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"divide the array in 2 arrays A1,A2. +ve numbers and -ve numbers. repeat the approach for both the arrays: - for each element e in array A1, find two elements in A2 such that A2[i]+A2[j]+e = 0.  you can sort the arrays to make searching efficient"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"public class TripletSumToZero { \n \n public static void main(String[] args){ \n  int [] A={ 1, 3,0, -5, 2, 4, -9 , 7, 8, 5, -6, -7, 4, 2}; \n  int l= A.length; \n  tripletSumZero(A, l); \n } \n  \n static void tripletSumZero(int [] A, int l){ \n   \n  for(int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"void printAllTriplesSummmedToZero(arr){ \n  \n for( i = 0; i < arr.size-2; i++ ){ \n  for( j = i+1; j < arr.size-1; j++ ){ \n   for( k = j+1; k < arr.size; k++ ){ \n    if( arr[i] + arr[j] + arr[k] == 0 ){ \n     println \"${arr[i]} + ${arr[j]} + ${arr[k]} = 0\" \n    }     \n   } \n  } \n } \n  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"yup its working ..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"This is the subset sum problem with  minor modifications on: 1. Target = 0 hence the new target value that is passed to subsequent iterations should be changed to target + a[i] instead of target - a[i]. It allows handling the negative values.   2. We need to keep track of a counter variable. This variable is incremented every time a new value is added to the subset vector, and decremented for every value that is popped out."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"You can solve this problem in O(n) by onsidering the following approach: a. Take an array that contains the negative elements. b. Take an array that will hold the sum of the negative values that will be a positive element in the array that is a triplet which sums up to 0. c. Whenever we have tracked two negative elements track the sum till now in prev_sum that will hold the positive value in the array Here is the  code:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=23170665","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"20","title":"Alex is standing on the top left cell (1,1) of a n*m table. The table has n rows and m columns. Initially, he is facing its right cell. He moves on the table in the following way:  >He moves one step forward. >He turns to his right >While moving forward, if he would go out of the table or reach a visited cell, he turns to his right.   He moves in the table as much as he can. Can you find out the number of cells he visits before he stops?  For example, given a 9x9 grid, the following would be his moves. The number on each cell represents the step he would land on that particular cell. 1  2 55 54 51 50 47 46 45  4  3 56 53 52 49 48 43 44  5  6 57 58 79 78 77 42 41  8  7 60 59 80 75 76 39 40  9 10 61 62 81 74 73 38 37  12 11 64 63 68 69 72 35 36  13 14 65 66 67 70 71 34 33  16 15 20 21 24 25 28 29 32  17 18 19 22 23 26 27 30 31   Input: The first line of the input contains two integer numbers n and m. n and m are between 1 and 100.  Output: Print an integer to the output being the answer of the test.  Sample input #00: 3 3  Sample output #00: 9  Sample input #01: 7 4  Sample output #01: 18","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"There is O(1) Solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can be improved but will do it. Ruby implementation"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"dir 1 represents right dir 2 represents down dir 3 represents left and dir 4 represents up"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if n and m are neither even nor 1 then will the answer be n*m?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  using namespace std; int main() {    int n,m,ans;    scanf(\"%d %d\",&n,&m);    if(n%2==0)    ans=2*n;    else    if(m%2==0)    ans=2*n+2*(m-2);    else    ans=n*m; printf(\"%d\",ans); return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \nusing namespace std; \nint main() \n{ \n   int n,m,ans; \n   scanf(\"%d %d\",&n,&m); \n   if(n%2==0) \n   ans=2*n; \n   else \n   if(m%2==0) \n   ans=2*n+2*(m-2); \n   else \n   ans=n*m; \nprintf(\"%d\",ans); \nreturn 0;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Working fast code using backtracking"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  using namespace std;  int i = 0 ; int j = 0 ; int* ptr_i = &i ; int* ptr_j = &j ;  enum dir{ r = 1 , down , l , up } ;   dir lastdir = up ;  bool visited( int* board , int i , int j , int n , int m ) {        if( board[ i*m+j ] == 1 )         return true ;     else         return false ; }  bool moveOneStep( int* board , int *ptr_i , int* ptr_j , int n , int m )  {     int temp_i = *ptr_i ;      int temp_j = *ptr_j ;           if( lastdir == up )     {      cout << temp_i << \" \" << temp_j << endl ;         if( !visited( board , temp_i , temp_j+1 ,n,m ) && (temp_j+1) != m )         {             board[ temp_i*m + temp_j+1 ] = 1 ;              *ptr_j = *ptr_j + 1 ;             lastdir = r ;              return true ;          }         else if( !visited( board , temp_i , temp_j-1 ,n,m ) && (temp_j-1) != -1 )          {             board[(temp_i)*m + (temp_j-1)] ;             *ptr_j = *ptr_j-1 ;             lastdir = l ;             return true ;         }      else if( !visited( board , temp_i-1 , temp_j,n,m )  && (temp_i-1) != -1 )         {             board[ (temp_i-1)*m + temp_j ] = 1 ;             *ptr_i = *ptr_i -1 ;             lastdir = up ;             return true ;          }         else              return false ;      }     else if( lastdir == r )      {      cout << temp_i << \" \" << temp_j << endl ;         if( !visited( board , temp_i+1 , temp_j,n,m ) && (temp_i+1) != n )         {             board[(temp_i+1)*m + temp_j ] = 1 ;              *ptr_i = *ptr_i + 1 ;             lastdir = down ;              return true ;          }         else if( !visited( board , temp_i-1 , temp_j ,n,m ) && (temp_i-1) != -1 )          {             board[ (temp_i-1)*m + (temp_j) ] = 1;             *ptr_i = *ptr_i-1 ;             lastdir = up ;             return true ;         }         else if( !visited( board , temp_i , temp_j+1 , n,m) && (temp_j+1) != m )         {             board[ (temp_i)*m + temp_j+1 ] = 1 ;             *ptr_j = *ptr_j+1 ;             lastdir = r ;             return true ;          }         else              return false ;     }     else if( lastdir == down )     {      cout << temp_i << \" \" << temp_j << endl ;         if( !visited( board , temp_i , temp_j-1,n,m)  && (temp_j-1) != -1 )          {             board[(temp_i)*m + (temp_j-1)] = 1;             *ptr_j = *ptr_j-1 ;             lastdir = l ;             return true ;         }         else if( !visited( board , temp_i , temp_j+1,n,m ) && (temp_j+1) != m )         {             board[temp_i*m + temp_j+1 ] = 1 ;              *ptr_j = *ptr_j + 1 ;             lastdir = r ;              return true ;          }         else if( !visited( board , temp_i+1 , temp_j,n,m) && (temp_i+1) != n )         {             board[ (temp_i+1)*m + temp_j ] = 1 ;             *ptr_i = *ptr_i+1 ;             lastdir = down ;             return true ;          }         else              return false ;     }     else if( lastdir == l )          {      cout << temp_i << \" \" << temp_j << endl ;         if( !visited( board , temp_i+1 , temp_j , n,m ) && (temp_i+1) != n )         {             board[(temp_i+1)*m + temp_j ] = 1 ;              *ptr_i = *ptr_i + 1 ;             lastdir = down ;              return true ;          }         else if( !visited( board , temp_i-1 , temp_j,n,m) && (temp_i-1) != -1 )          {             board[(temp_i-1)*m + (temp_j)] = 1 ;             *ptr_i = *ptr_i-1 ;             lastdir = up ;             return true ;         }         else if( !visited( board , temp_i , temp_j-1,n,m) && (temp_j-1) != -1 )         {             board[ (temp_i)*m + temp_j-1 ] = 1 ;             *ptr_j = *ptr_j-1 ;             lastdir = l ;             return true ;          }         else              return false ;             } }  int main() {     int n ;      int m ;     cin >> n >> m ;     int *board = new int[n*m] ;            for( int i = 0 ; i    {      for ( int j = 0 ; j      board[i*m+j] = 0 ;        }       board[0] = 1 ;      int steps = 1 ;     int i = 0 ;     int j = 0 ;           cout << endl ;          while( moveOneStep( board , &i , &j , n , m ) )         steps++ ;       cout << steps << endl ;       for( int i = 0 ; i    {      for ( int j = 0 ; j      cout << board[i*m+j] ;      cout << endl ;  }     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.awt.Point; \nimport java.io.*; \nimport java.util.*; \n \npublic class WalkingTable { \n \n public static void main(String[] args) { \n  InputStream in = System.in; \n  Scanner scanner = new Scanner(in); \n  while (scanner.hasNextLine()) { \n   String line = scanner.nextLine(); \n   String[] split = line.split(\" \"); \n   int rows = Integer.parseInt(split[0]); \n   int cols = Integer.parseInt(split[1]); \n   solve(rows, cols); \n  } \n  scanner.close(); \n } \n \n static void solve(int rows, int cols) { \n  Point pos = new Point(0, 0); \n  int dirIndex = 0; \n  Point[] directions = new Point[] { new Point(1, 0), new Point(0, 1), \n    new Point(-1, 0), new Point(0, -1) }; \n  boolean[][] table = new boolean[rows][cols]; \n  int moves = 0; \n  while (true) { \n   table[pos.y][pos.x] = true; \n   ++moves; \n   Point direction = directions[dirIndex]; \n   int attempts = 0; \n   while (attempts < 5 && !canMove(table, pos, direction)) { \n    dirIndex += 1; \n    dirIndex %= directions.length; \n    direction = directions[dirIndex]; \n    ++attempts; \n   } \n   if (!canMove(table, pos, direction)) { \n    break; \n   } else { \n    pos.translate(direction.x, direction.y); \n   } \n   dirIndex++; \n   dirIndex %= directions.length; \n  } \n  System.out.println(moves); \n } \n \n static boolean canMove(boolean[][] table, Point pos, Point moveDir) { \n  int x = pos.x + moveDir.x; \n  int y = pos.y + moveDir.y; \n  if (x < 0 || y < 0 || y >= table.length || x >= table[0].length || table[y][x]) { \n   return false; \n  } \n  return true; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the implementation in Java, complexity in O(n*m)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"PHP code Here"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This solution is O(mn)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"According to your code, the answer for the first sample test (3,3) is 6..."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=23672664","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"4","title":"We have a rectangle with n rows and m columns filled with numbers from 1 to n*m. Cell (i,j) of the rectangle is important iff:   * i = 1 and j = 1 (or)   *there is an important cell (a,b) such that (a,b) is a neighbor of (i,j) and the number    on (i,j) is greater than number on cell (a,b) and all of (a,b)'s neighbors except for (      (i,j) itself   Two cells are considered to be neighbors if they share a common edge between them. Unfortunately the number in some of the cells has been erased. We want to write a number to those cells such that the resultant rectangle has all the numbers between 1 to n*m and it contains as many important cells as possible. In case there are several ways to do that, we are interested with the rectangle which is lexicographically smallest.  A table is lexicographically smaller that the other if the string of its row-major view is lexicographically smaller than the other. Input:  The first line of the input contains two integers n and m, Each of the next n lines contains m tokens. Each token is either an integer between 1 and n*m or '?'. Output: Print the maximum number of important cells that can be obtained in the first line of the output and print the rectangle in the next n lines.   Constraints: 1 <=n,m <=6   Sample input #00: 2 3 2 ? ? ? ? 3   Sample output #00: 3 2 1 4  5 6 3   Sample input #01: 6 6  ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?  ? ? ? ? ? ?  ? ? ? ? ? ?  ? ? ? ? ? ?  Sample output #02: 24 1 2 3 13 14 15  4 6 8 10 11 16  5 7 9 12 19 17  28 26 24 22 20 18  29 27 25 23 21 36  30 31 32 33 34 35","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it is really hard"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include using namespace std; bool flag[7][7],res[7][7]; int result[7][7],r=0,maxi=0,n,m,c,x,next=1,temp[7][7],z[4][2],in[7][7]; int visited[7][7],used[40];   int get_next() {     while(used[next]==1)     next++;     used[next]=1;     return next; }   void input() {      char ch;      int i,j,k,p;      ch=getchar();      string s;      for(i=1;i<=n;i++)      {          p=1;          getline(cin,s);          for(j=0;j         {              if(s[j]=='?')              {                  in[i][p++]=0;                  j++;              }              else              {                  k=0;                  while(s[j]!=' ' && j                 {                     k=k*10+int(s[j])-48;                     j++;                  }                  in[i][p++]=k;              }          }      } }   inline bool isrange(int i,int j) {      return (i<=n && j<=m && i>0 && j>0); }   int mark_visited(int a,int b,int j,int k) {     int i,p=0;      for(i=0;i<4;i++)      {          if(isrange(a+z[i][0],b+z[i][1]) && visited[a+z[i][0]][b+z[i][1]]==j)              {                  visited[a+z[i][0]][b+z[i][1]]=k;                  p++;              }      }     return p; }   bool compare() {      int i,j,k=0;      if(result[0][0]==1)      {result[0][0]=0;      return 1;      }      for(i=1;i<=n;i++)      {          for(j=1;j<=m;j++)          {               if(temp[i][j]                 return 1;               if(result[i][j]                  return 0;          }      }      return 1; }        int count_ones(int a,int b) {     int k=0,i,j;     for(i=0;i<4;i++)     {            if(isrange(a+z[i][0],b+z[i][1]) && flag[a+z[i][0]][b+z[i][1]])            {                k++;                if(temp[a+z[i][0]][b+z[i][1]]==0)                  x=i;            }     }     return k; }            void save() {      int i,j;      for(i=1;i<=n;i++)         for(j=1;j<=m;j++)             res[i][j]=flag[i][j];      for(i=1;i<=n;i++)         for(j=1;j<=m;j++)             result[i][j]=temp[i][j]; }   void fill() {      int a=1,b=1,i,k,j;      for(i=0;i<=n;i++)         for(k=0;k<=m;k++)         {             temp[i][k]=in[i][k];             used[i*n+k]=0;         }      for(i=1;i<=n;i++)        for(j=1;j<=m;j++)        {             if(in[i][j]>0)             used[in[i][j]]=1;        }        next=1;      while(next<=n*m)      {          if(temp[a][b]==0)           temp[a][b]=get_next();           i=count_ones(a,b);           if(i==1 && a*b!=1)           break;           for(i=0;i<4;i++)           {               if(isrange(a+z[i][0],b+z[i][1]) && i!=x && temp[a+z[i][0]][b+z[i][1]]==0)               temp[a+z[i][0]][b+z[i][1]]=get_next();           }           if(x==2)           {                  for(i=1;i<=b;i++)                  temp[a][i]=(temp[a][i]==0 && flag[a][i]==0)?get_next():temp[a][i];           }           if(x==3)           {                   for(i=1;i<=m;i++)                  temp[a][i]=(temp[a][i]==0 && flag[a][i]==0)?get_next():temp[a][i];           }                   a=a+z[x][0];               b=b+z[x][1];      } }                     void display() {      int i,j,k;       for(i=1;i<=n;i++)      {          for(j=1;j<=m;j++)          cout<         cout<     }      cout<       for(i=1;i<=n;i++)           {             for(j=1;j<=m;j++)                cout<               cout<          }      cout<}   void compute(int a,int b,int i) {      int p,j,k=r;      j=count_ones(a,b);      if(in[a][b]>0)      {          j=(in[a][b]>=c)?j:2;      }       if(isrange(a,b) && !flag[a][b] && j<=1 && c<=m*n)      {          flag[a][b]=1;          r++;          c=c+mark_visited(a,b,0,k+1);          compute(a,b-1,i);          compute(a,b+1,i);          compute(a-1,b,i);          compute(a+1,b,i);          c=c-mark_visited(a,b,k+1,0);          if(r==maxi && i==1)          {             fill();            if(compare())                save();          }          if(r>maxi)              maxi=r;           r=k;          flag[a][b]=0;      } }              int main() {     int i,j;     cin>>n>>m;     for(i=0;i<=n;i++)     for(j=0;j<=m;j++)     {          temp[i][j]=0;          flag[i][j]=0;          visited[i][j]=0;     }    z[0][1]=z[1][0]=z[2][0]=z[3][1]=0;     z[2][1]=z[3][0]=1;     z[0][0]=z[1][1]=-1;     result[0][0]=1;     visited[1][1]=1;     input();     c=(in[1][1]>0)?in[1][1]:1;     compute(1,1,0);     compute(1,1,1);     cout<<    display();     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"#include \n#include \n \n \nint numImpCells = 0; \nint output[6][6] = { 0 }; \n \n \nint countImpCells( int a[][6], int n, int m ) \n{ \n int result = 0; \n bool temp[6][6] = { false }; \n for(int i = 0; i < n; i++ ) \n { \n  for( int j = 0; j < m; j++ ) \n  { \n   if( ( i == 0 ) && ( j== 0 ) ) \n   { \n    temp[i][j] = true; \n   } \n \n   bool imp = true; \n   if( ( i > 0 ) && temp[i-1][j] ) \n   { \n    if( a[i][j] <= a[i-1][j] ) \n     imp = false; \n \n    if( ( i > 1 ) && ( a[i][j] <= a[i-2][j] ) ) \n     imp = false; \n \n    if( ( j > 0 ) && ( a[i][j] <= a[i-1][j-1] ) ) \n     imp = false; \n \n    if( ( j < (m-1) ) && ( a[i][j] <= a[i-1][j+1] ) ) \n     imp = false; \n \n    temp[i][j] = (imp || temp[i][j]); \n   } \n \n   if( ( j < (m-1) ) && temp[i][j+1] ) \n   { \n    if( a[i][j] <= a[i][j+1] ) \n     imp = false; \n \n    if( ( j < (m-2) ) && ( a[i][j] <= a[i][j+2] ) ) \n     imp = false; \n \n    if( ( i > 0 ) && ( j < (m-1) ) && ( a[i][j] <= a[i-1][j+1] ) ) \n     imp = false; \n    temp[i][j] = (imp || temp[i][j]); \n   } \n \n   if( ( i < (n-1) ) && temp[i+1][j] ) \n   { \n    if( a[i][j] <= a[i+1][j] ) \n     imp = false; \n \n    if( ( i < ( n-1)) && ( j < ( m - 1) ) && ( a[i][j] <= a[i+1][j+1] ) ) \n     imp = false; \n \n    if( ( i < (n-2) ) && ( a[i][j] <= a[i+2][j] ) ) \n     imp = false; \n \n    if( ( j > 0 ) && ( i < (n-1) ) && ( a[i][j] <= a[i+1][j-1] ) ) \n     imp = false; \n    temp[i][j] = (imp || temp[i][j]); \n   } \n \n   if( ( j > 0 ) && temp[i][j-1] ) \n   { \n    if( a[i][j] <= a[i][j-1] ) \n     imp = false; \n \n    if( ( j > 1 ) && ( a[i][j] <= a[i][j-2] ) ) \n     imp = false; \n \n    if( ( i > 0 ) && ( a[i][j] <= a[i-1][j-1] ) ) \n     imp = false; \n \n    if( ( j > 0 ) && ( i < (n-1) ) && ( a[i][j] <= a[i+1][j-1] ) ) \n     imp = false; \n    temp[i][j] = (imp || temp[i][j]); \n   } \n  } \n   \n } \n \n for(int i = 0; i < n; i++ ) \n { \n  for( int j = 0; j < m; j++ ) \n  { \n   if( temp[i][j] ) \n    result ++; \n  } \n } \n \n return result; \n} \n \nvoid processsolution(int a[][6], int n, int m, bool usedNumbers[]) \n{ \n int count = countImpCells( a, n , m) ; \n if( count > numImpCells ) \n { \n  numImpCells = count; \n \n  for(int i = 0; i < n; i++ ) \n  { \n   for( int j = 0; j < m; j++ ) \n   { \n    output[i][j] = a[i][j]; \n   } \n  } \n } \n \n} \n \nvoid backtracking(int a[][6], int n, int m, bool usedNumbers[]) \n{ \n bool finished = true; \n for( int i = 1; i <= n*m; i++ ) \n { \n  if( usedNumbers[i] == false ) \n   finished = false; \n } \n \n if( finished == true ) \n  processsolution( a, n, m, usedNumbers ); \n \n for(int i = 0; i < n; i++ ) \n { \n  for( int j = 0; j < m; j++ ) \n  { \n   if( a[i][j] == -1 ) \n   { \n    for( int k = 1; k <= n*m; k++ ) \n    { \n     if( usedNumbers[k] == false ) \n     { \n      a[i][j] = k; \n      usedNumbers[k] = true; \n \n      backtracking( a, n, m, usedNumbers ); \n \n      usedNumbers[k] = false; \n      a[i][j] = -1; \n     } \n    } \n \n   } \n  } \n } \n \n} \n \nint main(int argc, char* argv[]) \n{ \n int n, m; \n scanf(\"%d %d\", &n, &m); \n int a[6][6]; \n bool usedNumbers[37] = {false}; \n \n for(int i = 0; i < n; i++ ) \n { \n  for( int j = 0; j < m; j++ ) \n  { \n   int result = scanf(\"%d\", &a[i][j]); \n   if( result <= 0 ) \n   { \n    char c; \n    scanf(\"%c\", &c); \n    a[i][j] = -1; \n   } \n   else \n   { \n    usedNumbers[a[i][j]] = true; \n   } \n  } \n } \n \n backtracking(a, n, m, usedNumbers); \n \n printf(\"\\nResult: %d\\n\", numImpCells); \n for(int i = 0; i < n; i++ ) \n { \n  for( int j = 0; j < m; j++ ) \n  { \n   printf(\"%d \", output[i][j]); \n  } \n  printf(\"\\n\"); \n } \n \n getch(); \n return 0; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=23869663","download_status":"DOWNLOAD_DONE","votes":"4","answersCount":"47","title":"A string is called sstring if it consists of lowercase english letters and no two of its consecutive characters are the same.  You are given string s of length n. Calculate the number of sstrings of length that are not lexicographically greater than s. Input format The only line of input contains the string s. It's length is not greater than 100. All characters of input are lowercase english letters.  Output format: Print the answer of test modulo 1009 to the only line of output.  Sample input: bcd  Sample output: 653","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"First, we need to realize that the number of sstrings of size N is 25^N - at each step, we can pick any of the 25 different letters than the last one. Then we can apply dynamic programming knowing the current index and the previous letter used.  Say we have \"bcd\". Pick 'a' for the first letter - since it's smaller than the first letter 'b', we sum the number of sstrings of size 2 (2 remaining characters). Do this for all letters less than the given letter at index i because all subsequent strings are lexicographically smaller. After this step, add the number of sstrings with the same first 'i' letters as the given string."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For e.g. passed string is 'bcd', then  1- 1(a)*25(b-z)*25(a,c-z) plus  2- 1(b)*1(a)*25(b-z) plus  3- 1(b)*1(c)*3(a,b,d) = 653  Similar idea is used here. During, each sstring generation, I have checked whether it's all it's previous chars are bounded or not. By bounded, I mean that the char at current index is same as passed string char at that index. So, if all previous chars are bounded so current char cannot go beyond the passed string char at current index else it can have any 25 chars."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Duplicate question -  previously posted at question?id=23869663  An approach to solve this would be to:  0. Maintain a counter variable.  1. Check if the given string itself is an SString. If yes, increment the counter 2. Start at the rightmost character  3. Decrement the  value of the current character 4. Check if the character >= 'a' and the character to the left is the same as the current character.    4a. If they are the same decrement the value of the current character   4b. If they are different, increment the value of the counter by 25^(Length_of_string - i) 5. Decrement i 6. Repeat steps 2 to 5 until i >=0  An implementation in java goes like below..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This ain't an optimization problem and hence no need of Dynamic Programming. A few loops with simple tricks can do the job.  An approach to solve this would be to:  0. Maintain a counter variable.  1. Check if the given string itself is an SString. If yes, increment the counter 2. Start at the rightmost character  3. Decrement the value of the current character 4. Check if the character >= 'a' and the character to the left is the same as the current character.    4a. If they are the same decrement the value of the current character   4b. If they are different, increment the value of the counter by 25^(Length_of_string - i) 5. Decrement i 6. Repeat steps 2 to 5 until i >=0  A less bloated implementation in java goes like below."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.io.*; \npublic class SString { \n \n     \n public static void main(String[] args) throws Exception{ \n  BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); \n  System.out.println(\"Give Input\"); \n  String inp = bf.readLine(); \n  int ans = calculateSString(inp, 0); \n  System.out.println((ans+1)%1009); \n \n } \n  \n public static int calculateSString(String inp, int d){ \n  if(inp.length()==0 || d==inp.length()) \n   return 0; \n  int a = inp.charAt(d) - 'a'; \n   \n  if(d>0) \n   if(inp.charAt(d-1)- inp.charAt(d)<0 ){ \n    System.out.println((a-1)*Math.pow(25, inp.length()-1-d)); \n    return (int)((a-1)*Math.pow(25, inp.length()-1-d) + calculateSString(inp, d+1)); \n   } \n     \n  System.out.println(a*Math.pow(25, inp.length()-1-d)); \n  return (int)(a*Math.pow(25, inp.length()-1-d) + calculateSString(inp, d+1)); \n   \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.lang.*; public class face {  public static void main(String[] args){   int result = countNumber(\"bcd\");   System.out.print(result);  }   public static int countNumber(String s){   if(s == null || s.equals(\"\")){    return 0;   }    int result = countNumberCore(s, 0, s.length() - 1, 0, false);   return result;  }   public static int countNumberCore(String s, int start, int end, int sum, boolean sameChar){   if(sameChar == true){    return sum;   }   if(start == end){    return sum + (s.charAt(start) - 'a');   }   char before = '\\0';   if(start != 0){    before = s.charAt(start - 1);   }    if(before == '\\0' || s.charAt(start) < before){    int difference = s.charAt(start) - 'a';    sum = countSubfunction(difference, start, end, sum);       }   else if(s.charAt(start) > before) {    int difference = s.charAt(start) - 'a' - 1;    sum = countSubfunction(difference, start, end, sum);   }   else{    sameChar = true;    int difference = s.charAt(start) - 'a';    sum = countSubfunction(difference, start, end, sum);       }      return countNumberCore(s, start + 1, end, sum, sameChar);  }  public static int countSubfunction(int difference, int start, int end, int sum){   for(int i = difference; i > 0; i--){    int tempSum = 1;    for(int j = start + 1; j <= end; j++){     tempSum = (tempSum * 25) % 1009;    }    sum += tempSum;   }   return sum % 1009;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#define MAXLEN 100 \n#define MOD 1009 \nlong possibleStrings[MAXLEN]; \n \nint calculate( string s, int pos ) \n{ \n int len = s.length(); \n if( pos == len ) \n  return 1; \n \n int result = 0; \n int chars = s.at( pos ) - 'a'; \n if( ( pos > 0 ) && ( s.at( pos ) > s.at( pos - 1 ) ) ) \n  chars--; \n \n return ( ( chars * possibleStrings[ len - pos - 1] ) + calculate( s, pos + 1 ) ) % MOD; \n \n} \n \nint getSStringCount(string s) \n{ \n // initialize possibeStrings array \n possibleStrings[0] = 1; \n for( int i = 1; i < MAXLEN; i++ ) \n  possibleStrings[i] = ( possibleStrings[i-1] * 25 ) % MOD; \n \n return calculate( s, 0 ); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \n#include  \n#define mod 1009 \nusing namespace std; \nint main() \n{ \n  string s; \n  int count=0,l,m,k; \n  cin>>s; \n  l=s.length(); \n  for( k=1;ks[i-1]) \n    m=m-1; \n    count+=(m*int(pow(25.0,l-i-1)))% mod; \n   } \n   printf(\"%d\",count); \n   return 0;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  #include  #include  #define mod 1009 using namespace std; int main() {   string s;   int count=0,l,m,k;   cin>>s;   l=s.length();   for( k=1;k  if(k==l)   {     k=l-1;     count+=1;   }  for(int i=0;i<=k;i++)   {     m=s[i]-'a';     if(i!=0)     if(s[i]>s[i-1])     m=m-1;     count+=(m*int(pow(25.0,l-i-1)))% mod;    }    printf(\"%d\",count);    return 0;    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nusing namespace std; \nlong processtring(char* s, long len, long position) \n{ \n    if(position==len-1) \n    { \n        return s[position]-'a'; \n    } \n    long cdiff=s[position]-'a'; \n    if((s[position-1]-'a')>s; \n    long num; \n    num=strlen(s); \n    long val=processtring(s, num, 0); \n    cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n#include \nusing namespace std; \nint main(){ \n    int n; \n    string s; \n     \n    cin>>s; \n    n=s.size(); \n    double long sum=0; \n    for (int i = 0; i < n; i++) \n    { int ch=s[i]-96; \n        double a=25; \n     if(i==0) \n      sum+=(ch-1)*pow(a,n-i-1); \n     else if(s[i]<=s[i-1]) \n      sum+=(ch-1)*pow(a,n-i-1); \n  else \n   sum+=(ch-2)*pow(a,n-i-1);   \n \n        if(s[i]==s[i-1]) { \n            sum-=1; break; \n        }   \n \n    } \n    int out = int(sum+1)%1009; \n    cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \nusing namespace std; \n \n \nint count(string str, char prev, char prevToPrev) \n{ \n if (prev==prevToPrev) return 0; \n if (str.length() == 1) \n { \n  if(str[0]>str; \n cout << count(str, 'z' + 1, 'z'+2) << endl; \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Working perfect for every test case."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \n \nusing namespace std; \n \nint main(){ \n string a; \n cin >> a; \n int L = a.length(); \n \n int count = 0; \n \n for (int i=0; i (int)a[i] ){ \n    int val = (int)a[i] -97; \n    count += val * pow(25, (L-i-1)); \n   } \n   else if( (int)a[i-1]  <= (int)a[i] ){ \n    int val = (int)a[i] -97; \n     \n    if(val > 0) \n     val -= 1; \n     \n    count += val * pow(25, (L-i-1)); \n   } \n  } \n } \n \n cout << count +1; \n cout << endl; \n return 0; \n} \n \n// a = 97 \n// z = 122"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int firstRepeatedCharIndex(String s) { \n for (int i = 1; i < s.length(); ++i) \n  if (s.charAt(i) == s.charAt(i - 1)) \n   return i; \n return -1; \n} \n \nint noOfPossibleSSubstringWithLen(int len) { \n if (len < 0) return 0; \n return (int)Math.pow(25, len); \n} \n \nint noOfSmallerSString(String s) { \n int counter = 0; \n int i = firstRepeatedCharIndex(s); \n if (i < 0) { // s is already an sstring. \n  i = s.length() - 1; \n  counter ++; \n } \n char[] sArr = s.toCharArray(); \n while (i >= 0) { \n  sArr[i] = (char)(sArr[i] - 1); \n  if (i > 0 && sArr[i] == sArr[i - 1]) \n   sArr[i] = (char)(sArr[i] - 1); \n  if (sArr[i] < 'a') { \n   i--; \n   continue; \n  } \n  counter += noOfPossibleSSubstringWithLen(s.length() - i - 1); \n } \n return counter; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"var a='bcd'; \n// console.log(z.charCodeAt(0)+1); \n \nconsole.log(lexLess(a,0,aAs1(a[0])-1)); \n \nfunction lexLess(a,iter,prev){ \n  var union=0; \n  if(a[iter+1]>a[iter]){ \n    union=1; \n  } \n  var many=((prev))*25; \n  var single=(aAs1(a[iter+1])-union-1); \n  if(iter==a.length-2){ \n    return (many+single+1)%1009; \n  } \n  return lexLess(a,iter+1,many+single); \n} \n \nfunction aAs1(a){ \n  var b='a'; \n  return a.charCodeAt(0)-b.charCodeAt(0)+1; \n};"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I'd go for dynamic programming"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"int b =1, ret(0); \n    for (int i=s.size()-1; i>=0; i--)  \n    { \n               ret += mod(b*(s[i]-'a'), M); \n               b *= 26; \n    } \n     return ret;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"bc{a-d} -> 4 b{a-b}{a-z} ->2*26 = 52 a{a-z}{a-z} -> 26*26 = 676  so total # of strings should be 4 + 52 + 676 = 732.. how the ans is 653 .. explain !!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"int b =1;     int ret = 1;     for (int i=s.size()-1; i>0; i--)      {      if (s[i] >= s[i-1])  {                ret += b * (s[i] - 'a' - 1);      } else {   ret += b * (s[i] - 'a');  }  b * = 25;   } return ret;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"int count(string str, int limited) \n{ \n if (str.length() > 26) \n  return 0; \n if (str.length() == 1) \n  return str[0] - 'a'; \n  \n int firstPos = str[0] - 'a'; \n int res = 1, num = 25 - limited; \n for (int i = 0; i < str.length() - 1; i++) \n  res *= num--; \n return firstPos * res + count(str.substr(1), limited + 1); \n} \n \nint main() \n{ \n cout << count(\"bbb\", 0) << endl; \n getchar(); \n return 0; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=23594662","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"83","title":"Given a sequence of numbers A(1) ..A(n), find the continuous subsequenceA(i)..A(j) for which the sum of elements is maximum.  condition: we should not select two contiguous numbers","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"Clear case of Dynamic Programming.  Follows the recursive structure: currentSum = max{A[i], max{A[i-2] + A[i], A[i-2]}, max{A[i-3] + A[i], A[i-3]}, }   // i runs from 2 to N.  Full working implementation in java is given below. Give the input numbers using space as delimiter.  Eg: 1 - 1 3 8 4 1 5 3 9 4 1 2 3 4 5"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"public class Facebook \n{ \n public static int maxSum(int[] arr, int i) \n { \n  if (arr.length > i) \n  { \n   if (arr[i] > 0) \n    return max(arr[i] + maxSum(arr, i + 2), maxSum(arr, i + 1)); \n   else \n    return max(maxSum(arr, i + 2), maxSum(arr, i + 1)); \n  } \n \n  return 0; \n } \n \n public static int max(int a, int b) \n { \n  if (a > b) \n   return a; \n  else \n   return b; \n } \n \n public static void main(String[] args) \n { \n  int[] arr = {1,3,5,-1,12,6,7,11 }; \n  System.out.println(maxSum(arr, 0)); \n \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"#include  \n#include  \n#include  \n#include  \n#include  \n#include  \n \nusing namespace std; \n \nint maxsubsetsum(int A[], int size, int index) \n{ \n if (index >= size) \n  return 0; \n \n int sumone = A[index] + maxsubsetsum(A, size, index + 2); \n int sumtwo = A[index+1] + maxsubsetsum(A, size, index + 3); \n \n return max(sumone, sumtwo); \n} \n \nint main (int argc, void** argv) \n{ \n int A[ ] = {1, - 1, 3, 8 ,4 }; \n int size = sizeof(A)/sizeof(int); \n cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"You can do this in linear time using dynamic programming. Here's the function you would want to call, giving it the array of numbers and the length of the array:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"@- sameep how this possible ??  in A[ ] = { 1,2,3,4, 5} max sum i s 1 + 3 + 8 = 12. Here 8 is not there in the input array. did you mean 1 + 3 + 5 = 9 ??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Solution: Just separate two arrays of odd index and even index. Then use maximum sub-array algorithm to find the highest."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Assume M(i) represents maximum sum from 1 to i without selecting two contiguous numbers. Base conditions A[1] if i=1 Max{A[1],A[2]} if i=2  if i > 2 Max{ A[i] + M(i-2) , M(i-1)} On this we can write recessive DP program as:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include int max_sum(int a[],int n) {  if(n==0) return;  if(n==1) return a[0];  if(n==2) return a[0]>a[1]?a[0]:a[1];  int s[n];  s[0]=a[0];  s[1]=a[1];  int max=s[0];  int i=0;  for(i=2;i {   if(a[i]+max>a[i])    s[i]=a[i]+max;   if(s[i-1]>max)    max=s[i-1];  }  return max>s[n-1]?max:s[n-1]; } void main() {  int a[]={4,1,6,9,-1,-2,8};  int n=sizeof(a)/4;  printf(\"%d\\n\",max_sum(a,n)); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Pseudo code :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what is adjutant numbers?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Guys, I got bit confused here .  I mean the subset of the given set without adjacent number included. Its clear case for me that:-  1> add all value in even place and store in variable 1 ,  2> add all value in odd place and store in variable 2. Now whichever is greater sum return it.    Is it what the question is asking for ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution: Take input array of n. Separate odd index and even index and save it in 2 separate arrays. Then use maximum sub-array algorithm to find the highest for both the arrays."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Will this solution fail in any situation:  public static void main(String[] args) {   int arr[]={100,24,25,11,50};   int n= arr.length;   int sum=0;   for(int i=0; i   int temp=arr[i];    if((i+2)    temp+= arr[i+2];     //   System.out.println(temp);    if(temp>sum){     sum=temp;    }       }      System.out.println(sum);   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Another very good approach"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"So the dynamic programming solution takes O(N square); is there a better solution?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi,guys,I do not quite understand this question.What do u mean by adjacent numbers. in the test case,A[ ] = {1, - 1, 3, 8 ,4 },numbers 1,8,4 seems to be not adjacent,why the result is not 1+8+4 but 1+8,can somebody tell me why"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Test"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int find_maxsum(int *a,int n) \n{ \n    int i=0; \n    int prev_sum=0,sum=0,t; \n    while(isum) \n        { \n            //printf(\"hii\"); \n            t=sum; \n            sum=prev_sum+a[i]; \n            prev_sum=t; \n            i++; \n            continue; \n        } \n \n        i++; \n        prev_sum=sum; \n    } \n    return sum; \n} \nint find_maxsum(int *a,int n) \n{ \n    int i=0; \n    int prev_sum=0,sum=0,t; \n    while(isum) \n        { \n            //printf(\"hii\"); \n            t=sum; \n            sum=prev_sum+a[i]; \n            prev_sum=t; \n            i++; \n            continue; \n        } \n \n        i++; \n        prev_sum=sum; \n    } \n    return sum; \n} \nint find_maxsum(int *a,int n) \n{ \n    int i=0; \n    int prev_sum=0,sum=0,t; \n    while(isum) \n        { \n            //printf(\"hii\"); \n            t=sum; \n            sum=prev_sum+a[i]; \n            prev_sum=t; \n            i++; \n            continue; \n        } \n \n        i++; \n        prev_sum=sum; \n    } \n    return sum; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why cant we use the greedy approach here..start with the highest number, then the second largest  if it is not adjacent with the highest and so on..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"in python; works for the three examples."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be solved easily in linear time and with constant storage using dynamic programming  the main idea is if we have an array like this [1, - 1, 3, 8 ,4, 0, 11, 3, 4, 20], we want to partition that array into smaller sub arrays around negative or zero elements as negative elements and zeros can not contribute to the maximum sum  so this array should be partitioned into [1], [3, 8, 4], [11, 3, 4, 20] Then we will find the maximum possible sum in each sub array and add it to the total sum  which should be (1) + (3 + 4) + (3 + 20)  We will assume that the maximum sum for an array of all negative numbers will be zero, otherwise, code can be easily modified to find the non-positive number nearest to zero and return it.  could for this should be something like"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use modified version of Kadane algorithm to find max subarray sum and run it two times: starting from 0 and starting from 1. So the space complexity is constant, runtime O(N). This version also outputs numbers, participated in sum:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def dpMaxSum(elements): \n  keyFunc = lambda x: (x[0], not x[1]) \n \n  dp = [(0, False) for i in xrange(len(elements))] \n  for i, v in enumerate(elements): \n    if i == 0: \n      dp[i] = max([(0, False), (v, True)], key=keyFunc) \n    elif i == 1: \n      dp[i] = max([(dp[0][0], False), (v, True)], key=keyFunc) \n    else: \n      candidates = [(dp[i - 2][0], False), \n                    (dp[i - 2][0] + v, True), \n                    (dp[i - 1][0], False)] \n      if not dp[i - 1][1]: \n        candidates.append((dp[i - 1][0] + v, True)) \n      dp[i] = max(candidates, key=keyFunc) \n \n  # print dp \n  return dp[-1][0] \n \nprint dpMaxSum([1, 5, 3, 9, 4]) \nprint dpMaxSum([1, 2, 3, 4, 5]) \nprint dpMaxSum([1, -1, 3, 8, 4])"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.io.*; \n \nclass subsetsum \n{    \n     static int l,arr[]={1,3,5,-1,12,6,7,11},max=0; \n                                                           \n     public static void main(String args[]) throws IOException \n     { \n            \n          l=8; \n          int sum=0,i=0; \n          max_sum(sum,i);  \n          System.out.println(max); \n      } \n   \n     static void max_sum(int sum,int i) \n      { \n             if(i>l-1) \n              { \n                max=max>sum?max:sum; \n                 return; \n              } \n               \n              if(arr[i]>0) \n                max_sum(sum + arr[i],i+2); \n                else \n                   max_sum(sum ,i+2); \n                  \n \n            if(i< l-1) \n             { \n                if(arr[i+1]>0) \n                 max_sum(sum + arr[i+1],i+3);  \n                  else \n                    max_sum(sum,i+3);  \n                    \n             }   \n      }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n \nint max_index(int A[], int size) \n { \n          int i,t = 0; \n          for(i = 0; i<= size-1; i++) \n           { \n                if(A[i]>A[t]) t = i; \n           } \n          return t; \n} \n \nint main() \n { \n          int A[20],B[20],T[20],n1,n2,sum; \n          //A = {} ; n1 =  \n          int i,j,temp; \n          n2 = 0; sum = 0; \n          int max,val; \n          cout<<\"Enter n1 : \"; cin>>n1; \n          cout<<\"Enter \"<<<\" numbers : \"; \n          for(i = 0; i>A[i]; \n          for(i = 0; i(A[max-1]+A[max+1])||B[max+2]||B[max-2]) \n                 { \n                     if(!(B[max-1] || B[max+1])){ \n                       B[max] = 1; //assume prev member is not added \n                       n2++; \n                       continue; \n                     } \n                 } \n           }     \n           \n          cout<<\"{\"; \n          for(i = 0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n) time, O(n) memory:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int count2(const vector & vec ){ \n    if(vec.size() == 0) \n        return 0; \n    else if(vec.size() == 1){ \n        return vec[0] >0 ? vec[0] : 0; \n    } \n    else if(vec.size() == 2){ \n        int result = vec[0] > vec[1] ? vec[0] : vec[1]; \n        if(result > 0) \n            return result; \n        else \n            return 0; \n    } \n \n    int max = vec[0] > 0 ? vec[0] : 0; \n    int result = INT_MIN; \n    vector d(vec.size()); \n    d[0] = vec[0] >0 ? vec[0] : 0; \n    d[1] = vec[0] > vec[1] ? vec[0] : vec[1]; \n \n    for(int i=2;i0) \n            d[i] = vec[i] + max; \n        else \n            d[i] = max; \n    } \n \n    for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Build yourself a max priority queue that accepts a basic struct of two values: the integer value from the original set (which will also be used for comparison within the priority queue), and its index in the original array. Then, as you remove each largest value from the priority queue, you'll have its original index handy. You'll also want to construct a second data structure to keep track of used indexes (be it an array of booleans, or a HashSet of used indexes). If that second data structure deems you clear to use the most recent value removed from the priority queue, apply it toward your sum, mark that index as used, rinse and repeat."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This solution seems to be quite clear:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static class Solution{ \n  public static int[] array={-1, -1, -3, 8 ,40}; \n  public static int[] flags=new int[array.length+2]; \n  public static int[] maxSumValues = new int[array.length+2]; \n  public static void main(String[] args){ \n   System.out.println(MaxSum(0)); \n  } \n \n  public static int MaxSum(int l){ \n   if(flags[l]==1) \n    return maxSumValues[l]; \n   if(l+2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Dynamic programming solution : guys please check this code & let me know ..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int findMaxSum(int arr[], int n) \n{ \n int incl = arr[0]; \n int excl, excl_new; \n for(int i = 1; i < n; i++) \n { \n  excl_new = incl > excl ? incl : excl; \n  incl = excl + arr[i]; \n  excl = excl_new; \n } \n return (incl > excl ? incl : excl); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If I am understanding the problem right, then it means that the elements we consider for optimal output shouldn't be continous (any two numbers). Hence only alternate numbers are supposed to be tried. e.g [A,a,B,b,C,c,D,d] Then we need to find max contiguous sum in [A,B,C,D] and in [a,b,c,d] and then print the max of the two."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why not just split the array into parts such that non contiguous elements form part of each array. So now u have two arrays and need to find the max subsequence. This is an O(n) operation where n is ideally half the size of the total number of elements in the array.   i.e. O(n1) + O(n2) or avg case = O(N/2) and worst case of O(N)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution in ruby:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.*; \nimport java.io.*; \n \n \npublic class MaxSum{ \n public static void main(String[] args){ \n  InputStream in = System.in; \n  Scanner scanner = new Scanner(in); \n  while(scanner.hasNextLine()){ \n   int[] ints = getInts(scanner.nextLine()); \n   Wrapper[] wrappers = new Wrapper[ints.length]; \n   for(int i=0;i list = new ArrayList(); \n  for(int i=0;i list, Wrapper wrapper) \n { \n  for(Wrapper w : list) \n  { \n   if(w.index==wrapper.index-1 || w.index==wrapper.index+1){ \n    return true; \n   } \n  } \n  return false; \n } \n \n static int[] getInts(String line){ \n  String[] str = line.split(\" \"); \n  int[] ints = new int[str.length]; \n  for(int i=0;i{ \n  public int index; \n  public int value; \n  public Wrapper(int index, int value){ \n   this.index = index; \n   this.value = value; \n  } \n  public int compareTo(Wrapper other){ \n   int diff = value - other.value; \n   if(diff<0) return 1; \n   else if(diff>0) return -1; \n   return 0; \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int maxsum(int[] a, int i, boolean skip) \n { \n  int sum = 0; \n   \n  if (i == a.length) \n   return sum; \n   \n  if (!skip) \n  { \n   sum = sum + a[i]; \n   sum = sum + maxsum(a, i + 1, true); \n  } \n  else   \n      sum = sum + Math.max(maxsum(a, i + 1, false), maxsum(a, i + 1, true)); \n   \n  return sum; \n } \n  \n public static void main(String[] args)  \n { \n  int[] a = { 1, 2, 3, 4, 5 }; \n  int index = 0; \n   \n  System.out.println(Math.max(maxsum(a, index, false), maxsum(a, index, true))); \n \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Linear solution with constant additional memory in JS:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I just made a small modification to kadane's algorithm and this seems to be working. Any comments will be much appreciated. And, I am guessing it's O(N). Cheers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{ public static int findMaxSubArray(int[] A){   if (A.length == 0) return -1;   //tracks the historical max;   int max = A[0];   //tracks the cur max possible path   int sum = 0;   for (int i = 0; i   sum = Math.max(A[i],sum+A[i]);    max = Math.max(max, sum);   }   return max;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{ public static int findMaxSubArray(int[] A){   if (A.length == 0) return -1;   //tracks the historical max;   int max = A[0];   //tracks the cur max possible path   int sum = 0;   for (int i = 0; i   sum = Math.max(A[i],sum+A[i]);    max = Math.max(max, sum);   }   return max;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This code will be ok."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"sort it and sum the highest two numbers, if those two numbers were next to each other in the original array, then go to the next highest number"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=22106665","download_status":"DOWNLOAD_DONE","votes":"-3","answersCount":"12","title":"Given a number x, less than 100. How will you generate true with probability x/100. So if x = 65, how will you generate true with probability 65/100. You can represent true by 1 and false by 0.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"14","title":"the easiest way i feel... int myrand(int x) { int y=rand()%100; if(yreturn 1; return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* \nGiven a number x, less than 100. How will you generate true with probability x/100. So if x = 65, how will you generate true with probability 65/100. You can represent true by 1 and false by 0. \nDeveloped BY:Suman Roy \nEmil : email.suman.roy@gmail.com \n*/ \n \n#include \n#include \n#include \nusing namespace std; \nint main(){ \n int x, temp; \n  std::cout<<\"Enter x\\n\"; \n  std::cin>>x; \n int count1=0; \n int count2=0; \n  for ( int i=0;i<100;i++){ \n  if ( x>100 ) { \n              std::cout<<\"X is greater than 100 \\n\"; \n              exit(EXIT_SUCCESS); \n              } \n temp=rand() % 100 + 1; \n         if ( temp <= x ){ \n            count1++; \n             std::cout<<\"true=\"<<1<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"developerslife.ru/3405"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n#include \n#include \nusing namespace std; \nint main(void) \n{ \n srand(time(NULL)); \n double prob = ((double)rand())/RAND_MAX; //preserving the assumed uniform-random-nature of output \n int input; \n cin >> input; \n if (prob < input*0.01) cout << \"True\" << endl; \n else  cout << \"Flase\" <<  endl; \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Probability { \n \n public static void main(String[] args) { \n  int x = 5; \n  // write a function to generate true with a probability of 65/100 \n  for (int i = 0; i < 10; i++) { \n   System.out.println(generateTrue(x)); \n  } \n \n } \n \n public static boolean generateTrue(int x) { \n  double random = Math.random() * 100; \n  if (random < x) { \n   return true; \n  } else { \n   return false; \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Fisher Yates Shuffle algo can be used using an array of size 100 ,defining the probability that every x end up in a position above x after shuffling(randomizing)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Step 1. Take an array of size 100.  Step 2. Fill it with 'x' number of 1s. Step 3. Apply Fisher Yates shuffle on it. Step 4. Pick an element at random. rand()%100 ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"In java you can do it as so:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Take an array,'a', of size 100 and fill it with 0's and 1's at random. Take care that number of 1's is exactly 'x'. Now randomly pick a number between 1 and 100,say 'i'. Output a[i].  Drawback: Every time the value of 'x' changes array has to be modified."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"JS:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=20982670","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"38","title":"Given -  a number (n) and a sorted array Find a number in the array having least difference with the given number (n).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"9","title":"sites.google.com/site/spaceofjameschen/home/search/find-a-number-in-the-array-having-least-difference-with-the-given-number-n----facebook int FindNearestNum(int* arr, int len, int n) {     if(len == 1) return arr[0];     if(n < arr[0]) return arr[0];     if(n > arr[len - 1]) return arr[len - 1];      int low = 0;     int up = len - 1;      while(low <= up){         int mid = low + (up - low) / 2;          if(arr[mid] == n){             return n;         }         else if(arr[mid] > n){             up = mid - 1;         }         else{             low = mid + 1;         }     }      return abs(arr[low] - n) > abs(arr[up] - n) ? arr[up] : arr[low]; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"This approach of binary search is considered as: a. Find the middle element in the array. If the middle element is equal to the number then we have find our minimum difference of that number that is 0 b. If the number is less than the middle element then find the difference and then search further in the left half. c. If the number is more than the middle element then find the difference and then search in the right half. d. Here the variable difference is static for comparing this diff with other scenarios. You can test this code below:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First approach- -if there is only one element return that element -check if it is less than first element of array then return first element -check if it is greater than the last element of the array then return last element -if there are two elements return the nearest element -else find the mid use modified binary search to return the nearest O(lgn) Second approach: Can we use interval tree some how? O(lgn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(log n) solution using Binary search notion :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for my solution every times array size is reduced to half  c++ code :  /* Given - a number (n) and a sorted array  Find a number in the array having least difference with the given number (n) */   for( int i=0 ; i  std::cin>>*( array_elementss + i );  for(int j=0 ; j using namespace std; int Difference ( int temp1 , int temp2 ){  if( temp1 > temp2 ) return (temp1 - temp2 );  else return ( temp2 - temp1); } int Search( int *array_elements , int i_start_index , int i_end_index , int &i_middle, int &i_search){  int i_returnvalue;  i_middle= ( i_start_index + i_end_index ) / 2;  std::cout<<\" middle = \"<<           int i_temp1=Difference ( * ( array_elements + i_middle ) , i_search );  //int i_temp2=Difference ( * ( aray_element + ( i_middle - 1) , i_search) );   if(i_temp1 ==0 )   return 0;   else {    if ( i_middle > i_start_index  && i_middle < i_end_index ) {      int i_temp2=Difference ( * ( array_elements + ( i_middle - 1) ) , i_search) ;      int i_temp3= Difference ( * ( array_elements + ( i_middle + 1) ) , i_search );                std::cout<<\"i_temp1 = \"<<<\"\\n i_temp2= \"<<<\"\\n i_temp3= \"<<            if( i_temp2 < i_temp3){      if ( i_temp1 < i_temp2 )       return i_temp1;      else       Search ( array_elements , i_start_index , i_middle - 1 , i_middle , i_search );     }     else {      if ( i_temp1 < i_temp3 )       return i_temp1;       else{        std::cout<<\"call\\n\";       Search ( array_elements , i_middle + 1 , i_end_index , i_middle , i_search ) ;       }     }    }                else{      std::cout<<<\" \" <<<\" \"<<     if( i_middle == i_start_index & i_middle == i_end_index ) return ( Difference ( * (array_elements + i_middle ) , i_search ) );        else{               std::cout<<\"call inside i_middle > start \\n\";         if ( i_middle > i_start_index ){              int i_temp2=Difference ( * ( array_elements + (  i_middle - 1 ) ) , i_search) ;        if ( i_temp1 < i_temp2 )        return i_temp1;        else         Search ( array_elements , i_start_index , i_middle - 1 , i_middle , i_search );      }      else      {       std::cout<<\" call inside middle < end\\n\";       int i_temp3= Difference ( * ( array_elements + ( i_middle + 1) ) , i_search );       if ( i_temp1 < i_temp3 )        return i_temp1;       else        Search ( array_elements , i_middle + 1 , i_end_index , i_middle , i_search ) ;      }     }     }      // std::cout<// return 1;     }   }  int main(){  int n_array_size , middle , i_search, i_temp1, i_temp2;  std::cin>>n_array_size;  std::cin>>i_search;  int *array_elementss=new int[ n_array_size ];   std::cout<< *( array_elementss + j )< int i_result=Search( array_elementss , 0 , n_array_size - 1 , middle ,i_search);  std::cout<<\"Result is :=\"<< }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int findDifference(int [] array, int target){      int left=0;   int right=array.length-1;   int min=Integer.MAX_VALUE;   int value=array[0];   int rightVal=Integer.MAX_VALUE;   int leftVal=Integer.MAX_VALUE;;      while (left<=right){    int mid=(left+right);    if (array[mid]==target){         return  array[mid];      }else if (target>array[mid]){      rightVal=Math.abs(target-array[mid]);      leftVal=Math.abs(target-array[right]);      if (rightVal      min=rightVal;       value=array[mid];      }else{       min=leftVal;       value=array[right];       }      left=mid+1;         }else{       rightVal=Math.abs(target-array[mid]);       leftVal=Math.abs(target-array[left]);       if (rightVal       min=rightVal;        value=array[mid];       }else{        min=leftVal;        value=array[left];       }       right=mid-1;      }   }      if (min>Math.abs(target-array[left])){    min=target-array[left];    value= array[left];     }      return value;     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int findDifference(int [] array, int target){ \n   \n  int left=0; \n  int right=array.length-1; \n  int min=Integer.MAX_VALUE; \n  int value=array[0]; \n  int rightVal=Integer.MAX_VALUE; \n  int leftVal=Integer.MAX_VALUE;; \n   \n  while (left<=right){ \n   int mid=(left+right); \n   if (array[mid]==target){ \n        return  array[mid];   \n   }else if (target>array[mid]){ \n     rightVal=Math.abs(target-array[mid]); \n     leftVal=Math.abs(target-array[right]); \n     if (rightValMath.abs(target-array[left])){ \n   min=target-array[left]; \n   value= array[left];   \n  } \n   \n  return value;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class arrayElementDiff { \n public static void main(String[] args){ \n  int[]num = {1, 2, 4, 6, 7, 18, 21, 39, 43, 98, 154}; \n  int givenNum = 150; \n  int left = 0, right = num.length, temp = 0, diff = 0, nearestNum = 0; \n  diff = Math.abs(givenNum - num[left]); \n  for (int i = 0; i < right; i++){ \n   temp = Math.abs(givenNum - num[left]); \n   if (temp <= diff){ \n    nearestNum = num[i]; \n    diff = temp; \n   } \n   left++; \n  } \n  System.out.println (\"Nearest = \" + nearestNum); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class arrayElementDiff { \n public static void main(String[] args){ \n  int[]num = {1, 2, 4, 6, 7, 18, 21, 39, 43, 98, 154}; \n  int givenNum = 150; \n  int left = 0, right = num.length, temp = 0, diff = 0, nearestNum = 0; \n  diff = Math.abs(givenNum - num[left]); \n  for (int i = 0; i < right; i++){ \n   temp = Math.abs(givenNum - num[left]); \n   if (temp <= diff){ \n    nearestNum = num[i]; \n    diff = temp; \n   } \n   left++; \n  } \n  System.out.println (\"Nearest = \" + nearestNum); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int ceil = upper_bound(a, n); // lowest i such that a[i] >= n \nint floor = lower_bound(a, n); // highest i such that a[i]<=n \nif ( floor == -1 )  return ceil \nif (ceil == -1) return floor \nelse  \n        return ceil - n <= n-floor ? ceil : floor;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int FindClosetNumber(int from, int to,int r1,int r2){ \n   if(from==to){ \n    if(sortedArray[from]==n) \n     return sortedArray[from]; \n    if(n-r1 < r2-n) \n     if(r1sortedArray[sortedArray.length-1]) \n      return sortedArray[sortedArray.length-1]; \n     else \n      return r2; \n   } \n   else{ \n    int mid = (int)(from+to)/2; \n    if(sortedArray[mid]==n) \n     return sortedArray[mid]; \n    else if (n"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void leastdiff() { int i,j,k,mid,low,high; int sorted[100]={0}; int min_num=0; int f_number=0; int n=0;  printf(\"enter the number of elements in sorted array\"); scanf(\"%d\",&n);  for(i=0;iscanf(\"%d\",&sorted[i]);  printf(\"enter the number for which least diff is to be calculated\"); scanf(\"%d\",&f_number);  mid=n/2; low=0; high=n;  while(low{    if(sorted[mid]low=mid+1; else high=mid-1;  mid=(high+low)/2; }    min_num=abs(sorted[mid]-f_number);    }   we can simply use the binary search with above code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void leastdiff() \n{ \nint i,j,k,mid,low,high; \nint sorted[100]={0}; \nint min_num=0; \nint f_number=0; \nint n=0; \n \nprintf(\"enter the number of elements in sorted array\"); \nscanf(\"%d\",&n); \n \nfor(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"logn solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My implementation in ruby:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Its a tricky question to use modified bunary search...here is my c++ code..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int getLeastDifference(int[] arr, int dst){     int distance = Integer.MAX_VALUE;     int leastIndex = -1;     int start = 0, end = arr.length;     while (start <= end){         int medium = (start + end) / 2;         int dis = Math.abs(arr[medium] -dst);         if (dis == 0){             return arr[medium];         } else {             if (dis < distance){                 distance = dis;                 leastIndex = medium;             }         }         if (arr[medium] < dst){             start = medium + 1;         } else {             end = medium - 1;         }     }          return arr[leastIndex]; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi, I am a beginner. I tried this very easily. Please Check it out:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It think the question is asking the Smallest value in the array that is larger than the given value. If so, it can be done in O(lg n) as:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{{ public static void main(String[] args) {   int array[] = {1, 10, 20, 30, 40, 50, 60, 70, 80};   int length = 9;   int n = 54;   System.out.println(numberWithLeastDiff(array, length, n));   }    public static int numberWithLeastDiff(int array[], int length, int n) {   if (length == 0) return -1;    if (length == 1) return array[0];   if (n <= array[0]) return array[0];   if (n >= array[length-1]) return array[length-1];      int min = 0, max = length - 1;   while (max - min > 1) {    int middleValue = array[(max+min)/2];     if (n == middleValue) return middleValue;    else if (n < middleValue) {     max = (max + min) / 2;    }    else {     min = (max + min) / 2;    }   }    return Math.abs(array[min] - n) < Math.abs(array[max] - n) ? array[min] : array[max];  } }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int find(int A[], int n, int target) \n{ \n if (target <= A[0]) return A[0]; \n if (target >= A[n - 1]) return A[n - 1]; \n int left = 0, right = n - 1; \n int minDiff = INT_MAX, res; \n while (left <= right) \n { \n  int mid = left + (right - left) / 2; \n  if (A[mid] == target) return target; \n  int diff = abs(A[mid] - target); \n  if (diff < minDiff) \n  { \n   minDiff = diff; \n   res = A[mid]; \n  } \n   \n  if (target < A[mid]) right = mid - 1; \n  if (target > A[mid]) left = mid + 1; \n } \n if (abs(A[left] - target) < minDiff) \n { \n  minDiff = abs(A[left] - target); \n  res = A[left]; \n } \n if (abs(A[right] - target) < minDiff) \n { \n  minDiff = abs(A[right] - target); \n  res = A[right]; \n } \n return res; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int findLeastDiff(int A[], int n, int target) \n{ \n if (target < A[0]) return A[0]; \n if (target > A[n - 1]) return A[n - 1]; \n  \n int left = 0, right = n - 1; \n while (left + 1 < right) \n { \n  int mid = left + (right - left) / 2; \n  if (A[mid] == target) return target; \n  else if (A[mid] > target) \n   right = mid; \n  else \n   left = mid; \n } \n return (abs(A[left] - target) < abs(A[right] - target))? A[left] : A[right]; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I said - we do a binary search for finding n, and when we are left with just 2 elements in the array we return the number with least difference with n."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"1. Do Binary Search on that input number -- O(lgn) 2. find successor than that's the least difference and if successor is not found than find  predecessor  - O(lgn)   because least difference has to be elements besides it. --- O(1)  Total - O(lgn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"private static int findMinDifNum(int[] a, int n) \n { \n  if (a.length == 1) \n   return a[0]; \n  else if (a[0] > n) \n  { \n   return a[0]; \n  } \n  else if (a[a.length-1] < n) \n  { \n   return a[a.length-1]; \n  }else if (a.length == 2) \n  { \n   return n - a[0] > a[1] - n ? a[1] : a[0]; \n  } \n  int left = 0; \n  int right = a.length - 1; \n  int mid = 0; \n  while (left <= right) \n  { \n   mid = (left + right) / 2; \n \n   if (a[mid] < n) \n    left = mid + 1; \n   else if (a[mid] > n) \n    right = mid - 1; \n   else \n    break; \n  } \n  if (left <= right) \n   return a[mid]; \n   \n  if (a[mid] < n) \n  { \n   return n-a[mid] > a[mid+1] - n ? a[mid+1] : a[mid]; \n  } \n  else \n  { \n   return a[mid] - n > n - a[mid-1] ? a[mid-1] : a[mid]; \n  } \n   \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Since the array is sorted, begin checking from the beginning and the end. For each check find the difference with the number (n) and compare the absolute value of the differences. If the left difference is more increment the left pointer. If the right difference is more decrement  the right pointer. Store the minimum difference. If in the next iteration, the minimum difference is more than the minimum difference so far,stop and return the last number."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Just do a binary search for n in the array. Get the number immediately lower and immediate larger. Pick the one closer to n."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"apply binary search with the key as number n 1.if number n is found,return n 2.else if low>0 && lowif high>0 && highif(abs(x-n)>abs(y-n)) return y; else return x;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-4","title":"Insert those numbers in a BST and then insert the number given to u...so now calculate its difference between its root node (and leaf nodes if they exist)....whichever is the minimum value...that shud be the answer...must be done in O(logn) if m nt wrong ! :)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=19587667","download_status":"DOWNLOAD_DONE","votes":"4","answersCount":"40","title":"Pattern Matching ---------------- Characters: a to z Operators: * + * -> matches zero or more (of the character that occurs previous to this operator) + -> matches one or more (of the character that occurs previous to this operator)  Output if a given pattern matches a string. Example: pattern:a*b string:aaab    b, ab, aab, aaab, ab output:1  pattern:a+aabc     string:ab    aabc, aaabc, aaaabc ..  output:0  pattern:aa*b*ab+ string:aab  aab, aabab, aaaabbab output:1  pattern: a+a*b* string: a ab, aab, aaabb output: 1  Valid Assumptions: Please assume that both the pattern and string input are valid","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"You need to construct an NFA to do pattern matching with regular expressions."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Below is the code you can check it it takes the following approach: a.If currently both the characters match increment both the pointers that is first and second. b.If currently a * is there then you have to consider either the current character of second string or ignore it. c.If there is a + then consider the fact such as the previous character of first string is equal to the previous character of second string (if there is only one instance) and then consider both either consider the current character or ignore it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If a simple match (i.e. no repetition sign following) just recurse with str.substring(1) and regex.substring(1) IFF match found. At any given point we either pass down unmodified regex with str.substring(1) OR unmodified str with \"*\" part taken away. We need to reduce + to *. For that, if current char matches recurse with str.substring(1) and regex where + is replaced by *."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"as per example 1 in the question, we are having four matching patterns , right.? ab, aab, aaab, ab   the above four patterns are satisfying a*b . a is occuring 0 or more times and then single 'b' is at end of the string. so the output should be 4, right.?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Yes.. thats it.  Cool.. thanks a lot. :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How can anyone write this code in a 45 min interview? One needs extreme practice and one should have seen such questions earlier. There is no way one can think about the algorithm in the interview, leave alone the edge cases."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can anyone explain why Example 2 output is 0? The pattern a+aabc matches the 2nd string (aaabc), does not it?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Following is my code in python. 1. First the pattern string is converted into a pattern list of tuples.    A) a* becomes (a, True, 0) where True signifies that the # of occurence is \"GREATER THAN EQUAL\" to 0    B) a+ becomes (a, True, 1) where True signifies that the # of occurence is \"GREATER THAN EQUAL\" to 1    C) a with no */+ becomes (a, False, 1) meaning that there is no \"GREATER THAN\" condition but only \"EQAUL\" condition to 1 a+aabc => [('a', True, 1), ('a', False, 1), ('a', False, 1), ('b', False, 1), ('c', False, 1)]  2. Then the pat list simplified so that we accumulate contiguous occurences of the same character. => [('a', True, 3), ('b', False, 1), ('c', False, 1)]  3. Then the resulting pat list is expanded so that either we have exact matches or \"*\" matches .. there are no \"+\" matches => [('a', False, 1), ('a', False, 1), ('a', False, 1), ('a', True, 0), ('b', False, 1), ('c', False, 1)]  with the expanded pattern list consisting of exact matches and * matches, we iterate over the expanded pattern list and the match_string"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just wrote a solution using NFA in Java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think your code will not work for  aab aa*b*ab+"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"And it will give yes for   aab aa*b*ac+"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static bool pattern(string input,string regx) \n    { \n     \n      if(input.Length==0 && regx.Length==0){ \n       return true; \n      } \n       \n      if(input.Length>0 && regx.Length==0){ \n          return false; \n      } \n       \n       \n      if(input.Length==0 && regx.Length>0) \n      { \n          return true; \n      } \n       \n       string curStr=input.Substring(0,1); \n       string curReg=regx.Substring(0,1); \n       string nextReg=regx.Substring(1,1); \n       \n     \n       \n      if(curStr==curReg) \n      { \n       return   pattern(input.Substring(1,input.Length-1),regx.Substring(1,regx.Length-1)); \n      } \n       \n      if(curReg==\"*\") \n      { \n          while(true) \n          { \n              if(curStr==nextReg && input.Length>0) \n              { \n                  input=input.Substring(1,input.Length-1); \n                 \n              } \n              else \n              { \n              if(regx.Length>2)     \n                   regx=regx.Substring(2,2); \n                  else \n                  regx=\"\"; \n         \n              break; \n              } \n          } \n           \n          return   pattern(input,regx); \n           \n      } \n       \n      if(curReg==\"+\") \n      { \n          if(curStr==nextReg) \n          { \n              while(true) \n              { \n               if(curStr==nextReg  && input.Length>0) \n               { \n                input=input.Substring(1,input.Length-1); \n               } \n               else \n               { \n                     \n                if(regx.Length>2) \n                  regx=regx.Substring(2,2); \n                else \n                  regx=\"\"; \n                  break; \n               } \n              } \n               \n              return   pattern(input,regx); \n          } \n          else \n          return false; \n      } \n       \n      return false; \n         \n    }  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* \n \n*********** USAGE ************* \nPass the pattern you wish to match as a command line argument \nThen enter the patterns you wish to match (one on each line) \n \nThe program will print the input string followed by a 1 or 0 indicating a match  \nor mis match respectively. \nEg: \n$./a.out a*b*c*abc \nabc \nabc:1 \naabbcc \naabbcc:0 \n \n*/ \n \n#include  \n#include  \n \nusing namespace std; \n \nclass matcher { \n  string pattern; \n   \n  void compile(); \n  string candidates(int p, char& prev, int& inc); \n  bool match_helper(string input, int p, int s, char& prev); \n \n  public: \n    matcher(string pattern) : pattern(pattern){ \n    } \n    bool match(string input); \n}; \n \nbool matcher::match(string input){ \n  int p = 0; \n  int s = 0; \n  char prev = '\\0'; \n  return match_helper(input, p, s, prev); \n} \n \nbool matcher::match_helper(string str, int p, int s, char& prev) { \n  if(p == pattern.length()) { \n    return true; \n  } \n  string c; \n  int inc = 0; \n  c = candidates(p, prev, inc); \n  for (int i = 0; i < c.length(); ++i) { \n    if (str[s] == c[i]){ \n      if(!match_helper(str, p+inc, s+1, prev)) \n        continue; \n      else \n        return true; \n    } \n    if(c[i] == '\\0'){ \n      prev = '\\0'; \n      return match_helper(str, p+1, s, prev); \n    }  \n  } \n  return false; \n} \n \nstring matcher::candidates(int p, char& prev, int& inc) { \n  string c; \n  if(pattern[p] == '*' || pattern[p] == '+'){ \n    c += prev; \n    c += '\\0'; \n    inc = 0; \n    return c; \n  } \n  else if(p+1 < pattern.length() &&  \n      (pattern[p+1] == '*' || pattern[p+1] == '+')) { \n    c += pattern[p]; \n    prev = pattern[p]; \n    if(pattern[p+1] == '*'){ \n      c += '\\0'; \n    } \n    inc = 1; \n    return c; \n  } \n  else { \n    c += pattern[p]; \n    prev = '\\0'; \n    inc = 1; \n    return c; \n  } \n} \n \n \nint main(int argc, char** argv){ \n  if(argc < 2){ \n    cout << \"Please enter a pattern to match!\" << endl; \n    return 0; \n  } \n \n  matcher m(argv[1]); \n  string input; \n  while(true){ \n    cin >> input; \n    cout << input << \":\"; \n    cout << (m.match(input) ? \"1\" : \"0\") << endl; \n  } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static class Solution{ \n  public static String str=\"\"; \n  public static NDFA machine; \n  public static void main(String[] args){ \n   boolean match = true; \n   String input = \"aab aab, aabab, aaaabbab\"; \n   machine=CreateNDFA(\"aa*b*ab+\"); \n   for(int i=0;i='a' && input.charAt(i)<='z') \n     str+=input.charAt(i); \n    else{ \n     if(str.length()>0 && !DoesMatch(0, 0)){ \n      System.out.println(\"0\"); \n      match = false; \n      break; \n     } \n     str=\"\"; \n    } \n   } \n   if(match) \n    System.out.println(1); \n  } \n   \n  public static NDFA CreateNDFA(String pattern){ \n   NDFA machine = new NDFA(); \n   for(int i=0;i0){ \n       if(machine.list.get(machine.list.size()-1).next=='0'){ \n        char preloop=machine.list.get(machine.list.size()-1).loop; \n        machine.list.remove(machine.list.size()-1); \n        machine.Add(preloop,pattern.charAt(i));   \n       } \n       else \n        machine.Add('0',pattern.charAt(i));  \n      } \n      else \n       machine.Add('0',pattern.charAt(i));  \n     } \n    } \n    else{ \n     if(machine.list.get(machine.list.size()-1).next=='0'){ \n      char preloop=machine.list.get(machine.list.size()-1).loop; \n      machine.list.remove(machine.list.size()-1); \n      machine.Add(preloop,pattern.charAt(i));   \n     } \n     else \n      machine.Add('0',pattern.charAt(i));    \n     machine.Add('0','1'); \n    } \n   } \n   return machine; \n  } \n   \n  public static class NDFA{ \n   public ArrayList list = new ArrayList(); \n    \n   public void Add(char l, char n){ \n    list.add(new State(l,n)); \n   } \n    \n   public String ToString(){ \n    String result=\"\"; \n    for(int i=0;i \"+ i + \"  \" + list.get(i).loop + \"\\n\"; \n      if(list.get(i).next != '1') \n       result += i + \" --> \"+ (i+1) + \"  \" + list.get(i).next + \"\\n\"; \n    } \n    return result; \n   } \n \n   class State{ \n    public char loop; \n    public char next; \n     \n    State(char l, char n){ \n     loop = l; \n     next = n; \n    } \n     \n    boolean IsFinal(){ \n     if(next=='1') \n      return true; \n     return false; \n    } \n   } \n  } \n   \n  public static boolean DoesMatch(int state,int charIndex){ \n   if(charIndex == str.length()){ \n    while(machine.list.get(state).next=='0') \n     state++; \n    if(machine.list.get(state).next=='1') \n     return true; \n    else \n     return false;     \n   } \n   if(machine.list.get(state).loop == str.charAt(charIndex)) \n    if(DoesMatch(state,charIndex+1)) \n     return true; \n   if(machine.list.get(state).next == str.charAt(charIndex)) \n    if(DoesMatch(state+1, charIndex+1)) \n     return true; \n   if(machine.list.get(state).next == '0') \n    if(DoesMatch(state+1, charIndex)) \n     return true; \n   return false; \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My code is working you can try ,I  always welcome  peoples who will find out sum issue :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a simple code in C:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Did they really ask this question on a white board interview? The solution would be very time consuming."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think we can use 2-order DP, here is my python code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can build a \"Trie\", where every edge will represent alphanumeric symbols from pattern. '+' and '*' will result in a tree loops. After building a trie, we can traverse it recursively following every loop, until the whole string is matched."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simple recursive solution :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This code will be ok."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=19300678","download_status":"DOWNLOAD_DONE","votes":"6","answersCount":"111","title":"If a=1, b=2, c=3,....z=26. Given a string, find all possible codes that string can generate. Give a count as well as print the strings.  For example: Input: \"1123\". You need to general all valid alphabet codes from this string.  Output List aabc   //a = 1, a = 1, b = 2, c = 3 kbc     // since k is 11, b = 2, c= 3 alc      // a = 1, l = 12, c = 3 aaw    // a= 1, a =1, w= 23 kw      // k = 11, w = 23","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"call"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Basically, just go through the string recursively, always eating one and two characters (where possible)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Non recursive Java code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Yeah, so you can recursively solve the sub-problems and memoize the results using dynamic programming. In other words:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This has a simple linear time algorithm. say the string is given as an array a[1...n]  You maintain another array which maintains the valid counts of prefixes, count[k] = valid count of a[1...k].  Now you scan a from 1 to n.  When you are considering j, there two possible splits involving j which end a j:  \"a[1...j-1]\" :\"a[j]\" or \"a[1...j-2]\" : \"a[j-1] a[j]\"  Now all you need to do is add the relevant counts (already computed till j-1 in count array)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"def get_interpretations(string): \n def get_branchs(string): \n  if not string or len(string) == 1: \n   return 0 \n  if string[0:2] <= '26': \n   if '0' not in string[1:3]: \n    return 1 + get_branchs(string[1:]) + get_branchs(string[2:]) \n   else: \n    return get_branchs(string[2:]) \n  else: \n   return get_branchs(string[1:]) \n return 1 + get_branchs(string)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"The solution is more like fibonaci series where there is a choice F(n) = F(n-1)+F(n-2) or F(n) = F(n-1) and the condition is atoi(string[n-1] string[n] ) < 27"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Here is a simple code with recursion"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public class PrintStringsAccordingToNumber { \n static String alphabet=\"#abcdefghijklmnopqrstuvwxyz\"; \npublic static void main(String[] args) { \n  \n parseNumber(0,3,\"1123\",\"\"); \n  \n  \n  \n  \n} \n \nprivate static void parseNumber(int i, int j, String string,String result) { \n if(j0){ \n  c=Integer.parseInt(string.charAt(j-1)+\"\"+string.charAt(j)+\"\"); \n  if(c<=26)parseNumber(i, j-2, string, alphabet.charAt(c)+result); \n } \n  \n} \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"In python:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Generally, because there are some recomputations on the subproblems, we can use a hash map to store the sub solutions. The recursive calls on each string are sometimes called twice(because there might be combination of two numbers which are possible to map to a char) , and combine the two sub solutions into one, and then return."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This has an O(n) time and O(1) space algorithm, by noting that there are locations where only one choice is possible, which causes \"breaks\" and valid counts for substrings without breaks are fibonacci numbers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static int CountValid(string s) \n        { \n            int count = 0; \n            if (string.IsNullOrWhiteSpace(s)) return 0; \n            if (s.IndexOf('0') == -1) \n                count++; //one valid interpretation with all single digit numbers transformed to chars 'a' - 'i' \n            for (int i = 0; i < s.Length - 1; i++) \n            { \n                int twoCharInterpretation = GetInt(s, i); \n                if (twoCharInterpretation != 10 // since 10 can only have one interpretation => j \n                    && twoCharInterpretation != 20 // since 20 can only have one interpretation => t \n                    && twoCharInterpretation > 9 // 06 cannot be valid interpretation since it is either part of 10 or 20 \n                    && twoCharInterpretation <= 26) \n                { \n                    count++; \n                } \n                if (twoCharInterpretation % 10 == 0 && twoCharInterpretation > 26) \n                { \n                    return 0;// like 11301 334508 are invalid 10, 20 can be valid, but 30 is not \n                } \n            } \n            return count; \n        } \n \n        private static int GetInt(string s, int index) \n        { \n            string twoChars = string.Empty; \n            twoChars = twoChars + s[index] + s[index + 1]; \n            return int.Parse(twoChars); \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \n#define CHAR_SIZE 26 \n#define PERMUTE_SIZE 1000 \n \nstatic char *permu[PERMUTE_SIZE]; /*Right now I am interested in only 3 chars */ \nstatic int k; \n \nvoid swap(char *string, int i, int j) \n{ \n        char temp = string[i]; \n        string[i] = string[j]; \n        string[j] = temp; \n} \n \nvoid permute(char *string, int i, int n) \n{ \n        int j = 0; \n \n        if(i == n) { \n                permu[k] = malloc(strlen(\"1122\")); \n                strcpy(permu[k], string); \n                k++; \n        } else { \n                for(j=i;j<=n;j++) { \n                        swap(string, i, j); \n                        permute(string, i+1, n); \n                        swap(string, i, j); \n                } \n        } \n} \n \nint main() \n{ \n        int i, j, count = 0; \n        char a[CHAR_SIZE+1] = {0}; \n        char *string = malloc(strlen(\"1122\")); \n \n        strcpy(string, \"1122\"); \n \n        /*let's permute now*/ \n        permute(string, 0, strlen(\"1122\")-1); \n \n        /*make hashtable*/ \n        for(i=0;i<=CHAR_SIZE;i++) \n                a[i] = 'a' + i; /*TOD0:Take care of CAPS*/ \n \n        for(i=0;i CHAR_SIZE){ /* take 2 elements */ \n                                decimal = decimal/100; \n                        } else { \n                                if(a[decimal%100 - 1] != -1) { \n                                        printf(\"%c\", a[decimal%100 - 1]); \n                                        count++; \n                                } \n                                a[decimal%100 - 1] = -1; \n                                decimal = decimal/100; \n                        } \n                } \n                printf(\"\\n\"); \n        } \n        printf(\"total count %d\\n\", count+strlen(\"1122\")); \n        return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"InterpretString(String oldstring,String remdigitsleft){ \n \nif (remdigitsleft==null){ \nif (oldstring.length!=0) system.out.println(oldstring); \n \n return; \n} \n \nfor (int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n#include \n#include \n#include \n#include \n \nusing namespace std; \n \nset< vector > sequence(string s, int start, int end){ \n    set< vector > output; \n    if (start > end){ \n        vector seq; \n        output.insert(seq); \n    }else if (start == end){ \n        vector seq; \n        char singleChar[1]; \n        singleChar[0] = s[start]; \n        int singleDigit = atoi(singleChar); \n        seq.push_back(char ( 'a' - 1 + singleDigit)); \n        output.insert(seq); \n    }else{ \n        set  > sub_output = sequence(s, start+1, end); \n        set  >::iterator it = sub_output.begin(); \n        char singleChar[1]; singleChar[0] = s[start]; \n        char zero[1]; zero[0] = '0'; \n        int singleDigit = atoi(singleChar); \n        char charFromSingleDigit = (char) ('a' - 1 + singleDigit); \n        for (; it != sub_output.end(); ++it){ \n            vector sub_v = (*it); \n            sub_v.push_back(charFromSingleDigit); \n            output.insert(sub_v); \n        } \n        char bothChars[2];  \n        bothChars[0] = s[start];  \n        bothChars[1] = s[start+1]; \n        int bothDigits = atoi(bothChars) - atoi(zero); \n        if (bothDigits <= 26){ \n            char charFromBothDigits = (char) ('a' - 1 + bothDigits); \n            sub_output = sequence(s, start+2, end); \n            it = sub_output.begin(); \n            for (; it != sub_output.end(); ++it){ \n                vector sub_v = *it; \n                sub_v.push_back(charFromBothDigits); \n                output.insert(sub_v); \n            } \n        } \n    } \n    return output; \n} \n \nint main(){ \n    string s; \n    cin >> s; \n    cout << \"Input string is: \" << s << endl; \n    set< vector > output = sequence(s, 0, s.length()-1); \n    set< vector >::iterator it = output.begin(); \n    for (; it != output.end(); ++it){ \n        for (int i = 0; i< ((*it).size()); ++i){ \n            printf(\"%c\", ((*it)[i])); \n        } \n        printf(\"\\n\"); \n    } \n    return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Your company has got a project for developing a software system. A similar software system was developed in your previous company. You discover that your company's interpretation of requirements is different from the interpretation taken by your previous company. Cost of project will tremendously increase if ambiguities in requirements are not resolved. You have also an ethical responsibility of confidentiality to your previous company. Discuss what you should do in such a situation? :please help me in this topic and give me the answer solution because i am a juniour student of computer science"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"char arr[]={'-','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};         public void method2(String till,int numbers[],int from){         if(from==numbers.length){             System.out.println(till);             return ;         }             char c=arr[numbers[from]];            method(till+c,numbers,from+1);                     if((from                method(till+arr[numbers[from]*10+numbers[from+1]], numbers, from+2);                    }             }     public static void main(String args[]){         stringval sv=new stringval();         int num[]={1,2,1,1};         sv.method2(\"\",num,0);            }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Dynamic programming solution. O(n) time, O(n) space, can be optimized to O(1) space by just remembering the previous two values in the array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include using namespace std; static int i=0; int numberstring(char*); int main() { char s[100]; cin>>s; if((s==NULL)||(strlen(s)==0)) return 0; else {i++;numberstring(s);} cout<<\"number of strings \"<<} int numberstring(char* s) {  if((strlen(s))>1)  {   if((*s-'0')>2) numberstring(++s);   else {     char *t=s;t++;     if(((*s-'0')==2)&&((*t-'0')>6)) numberstring(t);     else    {       i++;       if ((*t-'0')==0) { i--; if(strlen(t)>1) numberstring(++t);}       else { if(strlen(t)>1) {char *r=t; if(*++r=='0') i--;numberstring(t);} }       }    }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(1) space and time:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{  class FacebookQ1     {         public static void GetInterpretationCount(int[] l)         {             Node head = new Node();             AddChild(head, 0, l);             int x = FindCount(head);         }           static void AddChild(Node n, int pos, int[] l)         {             if (pos < l.Length)             {                 char y = (char)(l[pos] + 64);                 n.left = new Node(y);                 AddChild(n.left, pos + 1, l);                 if (pos + 1 < l.Length)                 {                     int x = l[pos] * 10 + l[pos + 1];                     if (x <= 26)                     {                         n.right = new Node((char)(x + 64));                         AddChild(n.right, pos + 2, l);                     }                 }             }         }         private static int FindCount(Node head)         {             int x = 0; int y = 0;             if (head.left != null)             {                 x += FindCount(head.left);             }             if (head.right != null)             {                 y += FindCount(head.right);             }             if (head.right == null && head.left == null)             {                 return 1;             }             return x + y;         }     }     class Node     {         public Node()         {         }         public Node(char x)         {             c = x;         }         public char c;         public Node left;         public Node right;     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My code in C, linear time and space"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My code in C, linear time and space"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"let us do it recursively.please correct me if I am wrong a[0...n-1] now add a[n].then let A(n-1) be the number of valid interpretations.then A(n)=A(n-1)+A(n-2) if a[n-1]<3 else A(n-1)+1.Hence we can do it by dynamic programming"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static int CountOfValidInterpretations(String input) { \n  return countLeafNodes(createSuffixTree(input)); \n } \n  \n static class Node { \n  int valid = 1; \n  Node right = null; \n  Node left = null; \n } \n  \n private static int countLeafNodes(Node root) { \n  if (root == null) \n   return 0; \n  else { \n   int child = countLeafNodes(root.left) + countLeafNodes(root.right); \n   if (child == 0 && root.valid == 1) \n    return 1; \n   return child; \n  } \n } \n \n static Node createSuffixTree(String input) { \n  if (input.length() == 0) { \n   Node root = new Node(); \n   return root; \n  } else if (input.length() == 1) { \n   Node root = new Node(); \n   root.left = createSuffixTree(input.substring(1)); \n   if (input.substring(0, 1).equalsIgnoreCase(\"0\")) { \n    root.valid = 0; \n    root.left.valid = 0; \n   } \n   return root; \n  } else { \n   if (input.substring(0, 1).equalsIgnoreCase(\"1\")) { \n    Node root = new Node(); \n    if (!input.substring(1, 2).equalsIgnoreCase(\"0\")) \n     root.left = createSuffixTree(input.substring(1)); \n    root.right = createSuffixTree(input.substring(2)); \n    return root; \n   } else if (input.substring(0, 1).equalsIgnoreCase(\"2\")) { \n    Node root = new Node(); \n    if (!input.substring(1, 2).equalsIgnoreCase(\"0\") \n      && !input.substring(1, 2).equalsIgnoreCase(\"7\") \n      && !input.substring(1, 2).equalsIgnoreCase(\"8\") \n      && !input.substring(1, 2).equalsIgnoreCase(\"9\")) \n     root.left = createSuffixTree(input.substring(1)); \n    root.right = createSuffixTree(input.substring(2)); \n    return root; \n   } else { \n    Node root = new Node(); \n    root.left = createSuffixTree(input.substring(1)); \n    return root; \n   } \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the problem can be solved recursively as stated previously and also iteratively. Iterative version is presumably tough to do.  Full implementation of recursive method in java is given below."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Below is the code using Iterative approach.  1. Find all combinations sum to string length using  1's & 2's 2. Find possible words for each combination"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def computeCombos(x): \n  def codeToChar(x): \n    return chr(ord('a') + x - 1) \n  \n  def numToArray(x): \n    result = [] \n    while x > 0: \n      result.append(x % 10) \n      x /= 10 \n \n    result.reverse() \n    return result \n \n  def yieldCombo(digits): \n    if not digits: \n      yield [] \n      return \n    if digits[0] > 2: \n      for i in yieldCombo(digits[1:]): \n        yield [digits[0]] + i \n    elif digits[0] == 2: \n      if len(digits) > 1: \n        if digits[1] == 0: \n          for i in yieldCombo(digits[2:]): \n            yield [20] + i \n        else: \n          for i in yieldCombo(digits[1:]): \n            yield [2] + i \n          if digits[1] < 7: \n            for i in yieldCombo(digits[2:]): \n              yield [20 + digits[1]] + i \n      else: \n        yield [2] \n    else: \n      if len(digits) > 1: \n        if digits[1] == 0: \n          for i in yieldCombo(digits[2:]): \n            yield [10] + i \n        else: \n          for i in yieldCombo(digits[1:]): \n            yield [1] + i \n          for i in yieldCombo(digits[2:]): \n            yield [10 + digits[1]] + i \n      else: \n        yield [1] \n \n  return [''.join([codeToChar(i) for i in entry])  \n              for entry in yieldCombo(numToArray(x))] \n \nprint computeCombos(1123) \nprint computeCombos(1023) \nprint computeCombos(1120) \nprint computeCombos(1129)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"listString = list() \n \ndef getChar(num): \n if  num >= 1 and num <= 26: \n  return chr(num + 96) \n return '' \n \ndef getNum(char): \n return ord(char) - 96 \n \ndef generateStrings(numString, length): \n \n newNum = int(numString[length-1]) \n if length == 1: \n  listString.append(getChar(newNum)) \n  return \n \n generateStrings(numString, length - 1) \n \n # Check if the new number can be summed with the existing number \n for i in range(len(listString)): \n \n  string =  listString[i] \n  newChar = getChar(newNum + getNum(string[-1])*10) \n  if newChar: \n   if newNum != 0: \n    listString.append(string[:-1] + newChar)     \n   else: \n    listString[i] = string[:-1] + newChar \n  if newNum != 0: \n   listString[i] =  string + getChar(newNum) \n \nx = \"1123\" \nx = \"101523\" \nx = \"1020\" \ngenerateStrings(x, len(x))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class GenerateCode{ \n private static char getCharacterForValue(int n) { \n  return (char)('A' + n - 1); \n } \n private static boolean isValidOneLengthString(String s) { \n  return Integer.parseInt(s) > 0; \n } \n private static boolean isValidTwoLengthString(String s) { \n  int val = Integer.parseInt(s); \n  return val > 9 && val < 27; \n } \n private static void generate(String prefix, String input) { \n  if (input.length() == 0) { \n   System.out.println(prefix); \n   return; \n  } \n  if (isValidOneLengthString(input.substring(0, 1))) { \n   generate(prefix + getCharacterForValue(Integer.parseInt(input.substring(0, 1))), input.substring(1)); \n  } \n  if (input.length() > 1 && isValidTwoLengthString(input.substring(0, 2))) { \n   generate(prefix + getCharacterForValue(Integer.parseInt(input.substring(0, 2))), input.substring(2)); \n  } \n } \n public static void main(String[] args){ \n  generate(\"\", \"1123\"); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.io.*; \npublic class face \n{      private static int count=0;   \n       private static char ar[]=               {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};     \n       static void  print_word(String str,String str1,int l,int i) \n       {      \n             if(i>(l-1)) \n             { \n               System.out.println(str1); \n               System.out.println(\"\\n\"); \n               count++; \n               return; \n        } \n \n             int a=(int) (str.charAt(i));    \n             print_word(str,str1 + ar[a-1-48],l,i+1); \n               \n             if((l-1-i) >= 1) \n            { \n                int b= (int) (str.charAt(i+1));  \n                b=b-48; \n                b= (a-48)*10 + b; \n                    \n                if(b<=26) \n                print_word(str,str1 + ar[b-1],l,i+2);  \n                    \n \n                \n            } \n              \n        } \n \n \n       public static void main(String args[]) throws IOException \n  \n        { \n \n        \n               String str,str1; \n               str=\"1123\";   \n               str1=\"\"; \n              \n               int l=str.length(); \n               int i=0; \n               print_word(str,str1,l,i); \n               System.out.println(count); \n \n \n \n        } \n    \n \n       }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"string res; \nvoid possibletext(char* input) \n{ \n if (input == nullptr || \n  input[0] == '\\0') \n { \n  cout<<='1' && input[0] <='9' && input[1] != '0') \n { \n  int num = (input[0] - '0') - 1; \n  res += ('a'+num); \n  possibletext(input+1); \n  res.pop_back(); \n } \n \n // handle the special case where two digits can be combined \n if (input[0] == '1' || \n  (input[0] == '2' && input[1] >= '1' && input[1] <='6')) \n { \n  int num = (input[0]-'0')*10 + (input[1]-'0') - 1; \n  res += (char)('a'+num); \n  possibletext(input+2); \n  res.pop_back(); \n } \n} \nint main(int argc, char** argv) \n{ \n char* one = \"1123\"; \n possibletext(one); \n _getch(); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For any query mail me at sahilkb23@gmail.com This code was compiled using Dev-Cpp"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include   using namespace std;  void print(int n[],char s[],int nn,int ns,int num) {     if(nn==num)     {         s[ns]='\\0';         cout<<\"\\n\"<        return;     }     if(n[nn]==0)     {         print(n,s,nn+1,ns,num);         return;     }     s[ns]=(char)(n[nn]+64);     print(n,s,nn+1,ns+1,num);     if(ns    {         int a=n[nn]*10+n[nn+1];         if(a<=26)         {             s[ns]=(char)(a+64);             print(n,s,nn+2,ns+1,num);         }     } } int main() {     int n[]={1,1,0,2,0,3};     int size=sizeof(n)/sizeof(int);     char *s=new char[size+5];     print(n,s,0,0,size);     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Javascript Solution  {{ function getLetterRankWords(str) {   var letterRanks = {};   var alphabet = 'abcdefghijklmnopqrstuvwxyz';   for (var i = 0; i < alphabet.length; i++) {     letterRanks[ i+1 ] = alphabet[i];   }    var results = {};    var gobbleString = function(str, remainingStr, posToConsider) {     if (remainingStr === \"\") {       results[str] = true;       return;     }      if (posToConsider === 2 && remainingStr.length >= 2) {       // Consider the next two numbers       var nextTwoNum = parseInt( remainingStr[0] + remainingStr[1], 10 );       var letter = letterRanks[ nextTwoNum ];       if (letter) {         gobbleString(str + letter, remainingStr.substring(2), 1);         if (remainingStr.length >= 2) {           gobbleString(str + letter, remainingStr.substring(2), 2);         }       }     } else {       var letter = letterRanks[ parseInt(remainingStr[0], 10) ];       if (letter) {         gobbleString(str + letter, remainingStr.substring(1), 1);         if (remainingStr.length >= 2) {           gobbleString(str + letter, remainingStr.substring(1), 2);         }       }     }   }    gobbleString(\"\", str, 1);   if (str.length >= 2) {     gobbleString(\"\", str, 2);   }    return Object.keys(results); } getLetterRankWords('1123'); }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static void getTranslation(String str, int cursor, String current) \n    { \n if (str.length() == cursor) \n { \n     System.out.println(current); \n     return; \n } \n  \n int one = Integer.parseInt(str.substring(cursor, cursor+1)); \n if (one >0 && one <=26) \n { \n     getTranslation(str, cursor+1, current + getChar(one)); \n } \n  \n int two = cursor+1 < str.length() ? Integer.parseInt(str.substring(cursor, cursor+2)):-1; \n if (two >0 && two <= 26) \n { \n     getTranslation(str, cursor+2, current + getChar(two)); \n } \n    } \n     \n    private static char getChar(int num) \n    { \n int a = 'a'-1; \n  \n return (char) (num+a); \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"f (n) = f(n-1) {if a[n] is not zero} + f(n-2) {if a[n-1]*10+a[n] <= 26} [f denotes no of ways] 1. Take two vectors v1 , v2 2. append a[0] to v1 3. i = 1 4. if a[i] is not zero, append a[i] to v1, else clear vector v1 5. if (b = a[i-1]*10+a[i]) <= 26 && >= 10, append b to v2; else clear vector v2 6. swap v1 & v2 7. i++, repeat step 4 till end 8. return v1 union v2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"my solution. Maybe is a duplicate of other people's solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution using backtracking:  #include    void print(int N, char *s, int i) {     int j;     if (N == 0)     {         for(j=(i-1);j>=0;j--)         {             printf(\"%c\",s[j]);         }         printf(\"\\n\");     }     else     {         s[i] = 96 + N % 10;         i++;         print(N/10, s, i);         i--;                  if ((N % 100 > 9) && (N % 100 <= 26))         {             s[i] = 96 + N % 100;             i++;             print(N/100, s, i);         }     } }   int main() {     int N;     char s[100];     scanf(\"%d\",&N);     print(N,s,0);     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"string = \"110203\" \n \ncodes = [ chr(ord('a') + i) for i in range(0, 26) ] \n \ndef find_codes(num, code=[]): \n    if len(num) == 0: \n        try: \n            print ''.join([ codes[int(char) - 1] for char in code ]) \n        except: \n            pass \n    else: \n        if num[0] != '0': \n            find_codes(num[1:], code[:] + [num[0]]) \n \n            if len(num) > 1: \n                find_codes(num[2:], code[:] + [num[:2]]) \n \nfind_codes(string)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The solution is based on the creation of a binary tree, left branch values smaller than the node, right branch values greater than the node and smaller than 26. A visitor then will visit the tree and create all the strings based on the path."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using System; using System.Collections.Generic; using System.Linq; using System.Text;  namespace printAllCombo {     class Program     {         static void printCombo(string input,int index,string stringToPrint,int tempIndex)         {             if (tempIndex == input.Length-1)             {                 Console.WriteLine(\"String:\"+stringToPrint);                 return;             }             for (int i = index; i < input.Length; i++)             {                                  int temp=int.Parse(input.Substring(index, i-index+1));                 if (i + 1 < input.Length && input[i + 1] == '0')                     {if((temp*10)>=1 && (temp*10)<=26)                     {                         i++;                         printCombo(input, i + 1, stringToPrint + (char)((temp*10) + 'a' - 1), i);                      }                     }                 else                 {                     if (temp >= 1 && temp <= 26)                     {                         printCombo(input, i + 1, stringToPrint + (char)(temp + 'a' - 1), i);                     }                 }             }         }         static void Main(string[] args)         {              printCombo(\"110203\", 0, \"\", 0);             Console.Read();         }     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \n \nusing namespace std; \n \nclass alphaCodes { \n   \n  int convertToInt(string s); \n  bool isValidLetter(int n); \n  void printCode(char* a, int k); \n  void backtrack(char* a, int k, string input, int s, int& count); \n \n  public: \n    void printAllCodes(string input); \n  char getLetter(int n); \n \n}; \n \nvoid alphaCodes::printAllCodes(string input) { \n  char* a = new char[input.length() + 1]; \n  int k = 0; \n  int s = 0; \n  int count = 0; \n  backtrack(a, k, input, s, count); \n  cout << \"Count:\" << count << endl; \n} \n \nint alphaCodes::convertToInt(string s){ \n  int val; \n  istringstream ( s ) >> val; \n  return val; \n} \n \nchar alphaCodes::getLetter(int n) { \n  return (n-1) + 'a'; \n} \n \nbool alphaCodes::isValidLetter(int n) { \n  return (n > 0 && n < 27); \n} \n \nvoid alphaCodes::printCode(char* a, int k){ \n  for (int i=0; i < k; ++i){ \n    cout << a[i]; \n  } \n  cout << endl; \n} \n \nvoid alphaCodes::backtrack(char* a, int k, string input, int s, int& count) { \n  if(s == input.length()){ \n    printCode(a, k); \n    count++; \n  } \n  else { \n     \n    int n = convertToInt(input.substr(s, 1)); \n    if(isValidLetter(n)){ \n      a[k] = getLetter(n); \n      backtrack(a, k+1, input, s+1, count); \n    } \n    if(s+1 < input.length()){ \n      n = convertToInt(input.substr(s,2)); \n      if(isValidLetter(n)){ \n        a[k] = getLetter(n); \n        backtrack(a, k+1, input, s+2, count); \n      } \n    } \n  } \n} \n \nint main(int argc, char** argv) { \n  if (argc < 2){ \n    cout << \"Please enter an input number string!\" << endl; \n    return 0; \n  } \n  alphaCodes a; \n  a.printAllCodes(argv[1]);  \n  return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/// Just another recursive solution. Who know iterative solution? Plz show me."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/** \n * If a=1, b=2, c=3,....z=26. Given a string,  \n * find all possible codes that string can generate.  \n * Give a count as well as print the strings.  \n * \n * For example:  \n * Input: \"1123\". You need to general all valid alphabet codes from this string.  \n * \n * Output List  \n * aabc //a = 1, a = 1, b = 2, c = 3  \n * kbc // since k is 11, b = 2, c= 3  \n * alc // a = 1, l = 12, c = 3  \n * aaw // a= 1, a =1, w= 23  \n * kw // k = 11, w = 23 \n *  \n * @author patrick \n * \n */ \npublic class Digit2String { \n \n public static void main(String[] args) { \n  d2s(\"\",new int[]{1, 1, 2, 3}, 0); \n } \n  \n public static void d2s(String accumulator, int[] A, int start) { \n  if(start>=A.length) { \n   System.out.println(accumulator); \n   return; \n  } \n  d2s(accumulator + new String(d2c(A[start])), A, start+1); \n  if(start"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{{using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks;  namespace Puzzle2 {     class Program     {         /*If a=1, b=2, c=3,....z=26. Given a string, find all possible codes that string can generate. Give a count as well as print the strings.   For example:  Input: \"1123\". You need to general all valid alphabet codes from this string.   Output List  aabc //a = 1, a = 1, b = 2, c = 3  kbc // since k is 11, b = 2, c= 3  alc // a = 1, l = 12, c = 3  aaw // a= 1, a =1, w= 23  kw // k = 11, w = 23*/         public static Dictionary map = new Dictionary();         static void Main(string[] args)         {             for (int i = 1; i <= 26; i++)             {                 map[i] = (char)('a' + (i - 1));             }             PrintCodes(string.Empty, \"1123\");             Console.ReadKey();         }          public static void PrintCodes(string codePrefix, string subString)         {             if(subString.Length==0)                 Console.WriteLine(codePrefix);              for (int i = 1; i <= 2; i++)             {                 if (i > subString.Length)                     break;                 else if (i == subString.Length)                     Console.WriteLine(codePrefix + map[int.Parse(subString)].ToString());                 else                 {                     string subSubString =  subString.Substring(0, i);                     string codePre = map[int.Parse(subSubString)].ToString();                     PrintCodes(codePrefix + codePre, subString.Substring(i));                 }              }         }     } } }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using System; \nusing System.Collections.Generic; \nusing System.Linq; \nusing System.Text; \nusing System.Threading.Tasks; \n \nnamespace Puzzle2 \n{ \n    class Program \n    { \n        /*If a=1, b=2, c=3,....z=26. Given a string, find all possible codes that string can generate. Give a count as well as print the strings.  \n \nFor example:  \nInput: \"1123\". You need to general all valid alphabet codes from this string.  \n \nOutput List  \naabc //a = 1, a = 1, b = 2, c = 3  \nkbc // since k is 11, b = 2, c= 3  \nalc // a = 1, l = 12, c = 3  \naaw // a= 1, a =1, w= 23  \nkw // k = 11, w = 23*/ \n        public static Dictionary map = new Dictionary(); \n        static void Main(string[] args) \n        { \n            for (int i = 1; i <= 26; i++) \n            { \n                map[i] = (char)('a' + (i - 1)); \n            } \n            PrintCodes(string.Empty, \"1123\"); \n            Console.ReadKey(); \n        } \n \n        public static void PrintCodes(string codePrefix, string subString) \n        { \n            if(subString.Length==0) \n                Console.WriteLine(codePrefix); \n \n            for (int i = 1; i <= 2; i++) \n            { \n                if (i > subString.Length) \n                    break; \n                else if (i == subString.Length) \n                    Console.WriteLine(codePrefix + map[int.Parse(subString)].ToString()); \n                else \n                { \n                    string subSubString =  subString.Substring(0, i); \n                    string codePre = map[int.Parse(subSubString)].ToString(); \n                    PrintCodes(codePrefix + codePre, subString.Substring(i)); \n                } \n \n            } \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static class Solution{ \n  public static void main(String[] args){ \n   AllPossibleChars(\"\",\"1123\"); \n  } \n   \n  public static void AllPossibleChars(String prefix,String str){ \n   if(str.length()==0){ \n    System.out.println(prefix); \n    return; \n   } \n   char c = (char)(Integer.parseInt(str.substring(0,1))+96); \n   AllPossibleChars(prefix+c, str.substring(1)); \n   if(str.length()>=2) \n    if(Integer.parseInt(str.substring(0,2))<=26){ \n     c = (char)(Integer.parseInt(str.substring(0,2))+96); \n     AllPossibleChars(prefix+c, str.substring(2)); \n    } \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nusing namespace std; \n#include \n#include \n#include \nint main() \n{ \n    int i,j,k,t,y,m; \n    int a[100]; \n    cout<<\"enter the length of the number\"; \n    cin>>j; \n    for(i=0;i>a[i]; \n    } \n    for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Its a simple backtracking question...here is my c++ code for it..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"By using recursion: From each position we move by 1 and then by 2 positions:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.io.*; \nimport java.util.*; \n \npublic class PatternPrint { \n public static ArrayList str= new ArrayList(); \n public static String input; \n public static void main(String[] args) throws IOException, NullPointerException{ \n  BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); \n  System.out.println(\"Give the input:\"); \n  input = bf.readLine(); \n  getPatterns(input, \"\"); \n  for(int i=0; i=2){ \n   String s2 = getString(inp.substring(0,2)); \n   if(s2.equals(\"Error!\")) \n    return; \n   getPatterns(inp.substring(2), ans+s2); \n  } \n } \n public static String getString(String s){ \n  int n1 = Integer.parseInt(s); \n  char ch1 = (char) ('a'+n1-1); \n  if(n1>26) \n   return \"Error!\"; \n  return Character.toString(ch1); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My implementation in ruby"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nusing namespace std; \nint n; \nvector a[100]; \nvoid dfs(string s,int i,string x) \n{ \n     if(i>=n){cout<<>s; \n    n=s.size(); \n    dfs(s,0,0); \n    cin>>s; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorry !it should be dfs(s,0,x) instead of dfs(s,0,0) and x should be an empty string initialized in main()"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A simple dfs implementation"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"DP, O(n), with python"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A really simple recursive code in python:  str_list = []  def str_map(str1, f_str, i):     if i == len(str1):         str_list.append(f_str)              if i < len(str1):         t_str = list(f_str)         t_str.append(chr(96+int(str1[i])))                  str_map(str1, t_str, i+1)              if i+1 < len(str1):         t1_str = list(f_str)         t1_str.append(chr(96+int(str1[i:i+2])))         str_map(str1, t1_str, i+2)           def test():     str1 = \"1123\"     str_map(str1, [], 0)     print str_list      test()"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Following code works on all inputs, even corner cases which include 0 in the input string. I have assumed that if more than two consecutive 0's occur in the input string, there is no valid interpretation of the given string since we do not have any character which maps to 0."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool validChar(char a,char b) \n{ \n if(10*(a-'0')+(b-'0')<26) \n  return true; \n return false; \n} \n \nvoid print(int i,string s,string p) \n{ \n if(i==s.length()) \n { \n  cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool validChar(char a,char b) \n{ \n if(10*(a-'0')+(b-'0')<26) \n  return true; \n return false; \n} \n \nvoid print(int i,string s,string p) \n{ \n if(i==s.length()) \n { \n  cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's a python implementation"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's my dynamic approach in python (repost after signing in)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import string \n \n \nLETTERS = string.lowercase \nMAX_DIGITS = len(str(len(LETTERS))) \n \ndef to_letter(n): \n    n = int(n) \n    if n <= 0 or n > len(LETTERS): \n        return None \n    return LETTERS[n - 1] \n \ndef find_codes(input_str): \n    # Base case: a one-digit or zero-digit number is supplied \n    if len(input_str) == 0: \n        return [] \n    elif len(input_str) == 1: \n        return [to_letter(input_str)] \n \n    result = [] \n    # MAX_DIGITS == 2 -> xrange(1, 3) -> [1, 2] \n    for i in xrange(1, MAX_DIGITS + 1): \n        curr_letter = to_letter(input_str[0:i]) \n        if curr_letter is None: \n            continue \n \n        sub_codes = find_codes(input_str[i:]) \n        if len(sub_codes) == 0: \n            sub_codes = [\"\"] \n        for sub_code in sub_codes: \n            result.append(curr_letter + sub_code) \n \n    return result \n \ndef print_codes(input_str): \n    result = find_codes(input_str) \n    print len(result) \n    print \"\\n\".join(result)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \nvoid decodeString(char *input, char *solution, int startIndex, int indexInSolution) { \n    int size = strlen(input); \n    if (startIndex == size) { \n        solution[indexInSolution] = '\\0'; \n        printf(\"%s\\n\", solution); \n        return; \n    } \n    int value = input[startIndex] - '0'; \n    solution[indexInSolution] = 'a' + value - 1; \n    startIndex++; \n    indexInSolution++; \n    decodeString(input, solution, startIndex, indexInSolution);     \n     \n    if ((startIndex < size) && \n        (value == 1) || \n        (value == 2 && input[startIndex] <= '6')) { \n        int nextValue = value * 10 + (input[startIndex] - '0'); \n        solution[indexInSolution - 1] = 'a' + nextValue - 1; \n        decodeString(input, solution, startIndex + 1, indexInSolution); \n    } \n} \n \nint main(void) { \n    char string[256], result[256]; \n     \n    fgets(string, sizeof(string), stdin); \n    decodeString(string, result, 0, 0); \n \n    return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"somebody please explain the algorithm to solve this problem rather than source code."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"somebody please explain the algorithm to solve it rather than the code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//just implement \"printL\" method to print to the output of your choice \n \n(function () { \n \nvar h = function (str, i, cach) { \n if(cach[i]) return cach[i]; \n  \n if(i === str.length) return []; \n  \n var r = []; \n var cur, curH; \n var j; \n var k; \n for (j = i+1; j < str.length+1 ; j++){ \n  cur = parseInt(str.substring(i, j)); \n  if(cur > 26) break; \n  cur = String.fromCharCode(96 + cur);//turn into char \n  curH = h(str, j, cach); \n  if(!curH.length) r.push(cur); \n  else{ \n   for(k = 0; k < curH.length ; k++){ \n    r.push(cur + curH[k]); \n   } \n  } \n } \n cach[i] = r; \n return r; \n}; \n \nvar findCode = function (str) { \n if(!str || !str.length) return []; \n var cach = {}; \n return h(str, 0 , cach); \n}; \n \nvar printCode = function (str) { \n \n var strArr = findCode(str); \n var i; \n for(i = 0; i < strArr.length ; i++){ \n  printL(strArr[i]);  \n } \n}; \n \n \nvar test = function (str){ \n printCode(str); \n}; \n \nvar str = \"1123\"; \ntest(str); \n \n}())"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here my C++ solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The following is my solution in Objective-C"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public Set decode(String prefix , String code){ \n  Set set = new HashSet(); \n  if(code.length() == 0){ \n    set.add(prefix); \n    return set; \n  } \n  if(code.charAt(0)=='0'){ \n    return set; \n  } \n  set.addAll(decode(prefix+(char)(code.charAt(0) - '1' + 'a'), code.substring(1))); \n   \n  if(code.length() <2) return set; \n  int tem = (code.charAt(0)-'0') *10 + code.charAt(1) - '0'; \n  if(tem > 26) return set; \n  set.addAll(decode(prefix + (char)(tem + 'a' -1) , code.substring(2)); \n  return set; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The correct code in C++. Enjoy!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"def generate(num): \n if num < 1: return [''] \n if num <= 10: return [str(chr(96 + num))] \n \n first_two, mag = num, 1 \n while first_two > 99:  \n  first_two /= 10 \n  mag *= 10 \n \n res = [] \n if first_two <= 26: \n  for s in generate(num - ((first_two // 10) * mag * 10)): \n   res.append(chr(96 + first_two//10) + s) \n \n for s in generate(num - (first_two * mag)): \n  res.append(chr(96 + first_two) + s) \n return res"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"class Decode { \n    private static char[] alpha = \n    { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', \n      'w', 'x', 'y', 'z' }; \n    private static int[] B = { 1, 2, 3, 1, 2, 3 }; \n \n    public static void print(int[] A) { \n        int n; \n        String s = \"\"; \n        for (int i = 0; i < A.length; i++) { \n            if (A[i] == 1) \n                s += alpha[B[i] - 1]; \n            if (A[i] == 2) { \n                n = (B[i] * 10) + B[i + 1]; \n                if (n < 27) \n                    s += alpha[n - 1]; \n                else \n                    return; // don't print the string as it had an invalid alphabet \n                i++; \n            } \n        } \n        System.out.println(s); \n    } \n \n    public static void combination(int[] A, int k, int n) { \n        if (k == n)  print(A); \n        else { \n            A[k] = 1; \n            combination(A, k + 1, n); \n            A[k] = 2; \n            if (k + 2 > n)  return; \n            combination(A, k + 2, n); \n        } \n    } \n \n    public static void main(String args[]) { \n        int n = B.length; \n        int[] A = new int[n]; \n        combination(A, 0, n); \n    } \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16760663","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"45","title":"Given an array, find all unique three-member subsets, with unique being that [0,2,3] and [3,2,0] are the same set. Should run in faster than 2^n time","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"After going through all the comments I hv found that people are not understading the question properly. Actually if a number has more than or equal to 2 occurrences then we also have to print the subset in which element has occurred more then 1 time..take a example if string is 112113 then we need to print all unique subset which are 111 112 113 123  So for doing this we store the numbers with their corresponding count(no. of occurence) for this I hv used map, we can use array also. And then we take the first element and decrease its count if now its count is  0 then it can't appear more than once so we increament the iterator and then we go for the subset of size two... Once go through the below program u will be able to understand it easily.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"void solve(char[]in){ \n  Arrays.sort(in); \n  int N = in.length; \n  for(int i=0;i0 && in[i]==in[i-1]) continue; \n     for(int j=i+1;ji+1 && in[j]==in[j-1]) continue; \n        for(int k=j+1;kj+1 && in[k]==in[k-1]) continue; \n           System.out.println(in[i]+\",\"+in[j]+\",\"+in[k]); \n        } \n    } \n  } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Assuming the elements are unique, you can do nested for loops to ensure less than the normal 2^n runtime seen when generating all possible subsets."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"What about this simple solution? The assumption I made are: - the input is a sorted array without duplication - the result will contain sets shorter than 3 elements  - it's trivial to meet two above assumptions"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Step 1: Sort the array. Time: O(n.lgn).  Step 2: Create another array (in same sorted order) but eliminating all repetitions. Time: Theta(n). Memory: O(n).  Step 3: Create pairs and store in a 2D array. Say the first element is at index 'k' in the given array. This will be paired with all elements from 'k+1' to 'n' in the given aray and stored at an appropriate index in 2D array. Do this for k=1 to n. Time: O(n^2). Memory: O(n^2). Note that all pairs are in themselves sorted and the 2D array will have all possible combinations of pairs.  Step 4: Extend the same logic to create all 3-member subsets. Use the larger number's index (element at (x,1) in 2D array) to create all three-member subsets ( If the larger value is at index k in the given array, use from indices 'k+1' to 'n' to create triplets). Time: O(n^3), Memory: O(n^3). Note: All triplets will be sorted and would exhaust all possible combinations out of the given set of size n.  The same can be extended to any number of desired elements in subsets, in polynomial time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import  java.io.*; class SetTest { public static void main(String args[]) { Console con=System.console(); int  sum=0; int no=Integer.parseInt(con.readline(\"enter how many nos\")); int arr[]=new int[no]; int brr[]=new int[no]; for(int i=0;i{ arr[i]=Integer.parseInt(con.readLine()); sum^=arr[i]; } for(int i=0;i{ brr[i]=Integer.parseInt(con.readLine()); sum^=brr[i]; } if(sum==0) System.out.println(\"all the nos same\"); else System.out.println(\"all the nos are not same\"); } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sort the array, then count up how many times each item occurs and create another array in which the items occur only once. Then recurse through the arrays, building the sets."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. sort array in O(nlogn) 2. remove duplicate elements in one go O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. find unique: hashSet 2. sort 3. pick subset in order: 123,124,125...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This problem belongs to 3-SUM hard class of problem. It can be solved in O(n^2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"After eliminating dublicate values, the code below will work."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algorithm is as follows:  1) Go from i = 0 to i = n-2 of given array 2) For every i, get \"hash\" of elements A[i],A[i+1],A[i+2]. Hash is generated this way: elements A[i],A[i+1],A[i+2] are sorted and glued together with some separator. So. for {1,2,3} and {3,2,1} and {2,1,3} \"hash\" will be the same - \"1|2|3\". 3) Remember \"hash\" and its position in hash table: HashPositions[\"1|2|3\"].push(i); 4) At the end, go through all HashPositions, and those which have only 1 position, are unique subsets.  Complexity:  1) We loop from 0 to n-2 (n-2 steps) 2) On every step we sort 3 elements (it takes constant time C) 3) At the end, we go through all hashes (maximum n-2 hashes) So, complexity is C*(n-2) + (n-2) = (C+1)(n-2) = O(n)  Speedup: if we have sorted three elements A[i],A[i+1] and A[i+2] and need to get sorted next three elements A[i+1],A[i+2],A[i+3] we should not sort them again. We should just remove A[i] and insert A[i+3] into previous sorted array. It works faster."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class ThreeMemberSubSet implements Serializable, Comparable { \n  \n private static final long serialVersionUID = 1L; \n private int firstValue ; \n private int secondValue ; \n private int thirdValue ; \n  \n /** \n  *  \n  */ \n public ThreeMemberSubSet() { \n } \n /** \n  * @param firstValue \n  * @param secondValue \n  * @param thirdValue \n  */ \n public ThreeMemberSubSet(int firstValue, int secondValue, int thirdValue) { \n  super(); \n  this.firstValue = firstValue; \n  this.secondValue = secondValue; \n  this.thirdValue = thirdValue; \n } \n /** \n  * @return the firstValue \n  */ \n public int getFirstValue() { \n  return firstValue; \n } \n /** \n  * @param firstValue the firstValue to set \n  */ \n public void setFirstValue(int firstValue) { \n  this.firstValue = firstValue; \n } \n /** \n  * @return the secondValue \n  */ \n public int getSecondValue() { \n  return secondValue; \n } \n /** \n  * @param secondValue the secondValue to set \n  */ \n public void setSecondValue(int secondValue) { \n  this.secondValue = secondValue; \n } \n /** \n  * @return the thirdValue \n  */ \n public int getThirdValue() { \n  return thirdValue; \n } \n /** \n  * @param thirdValue the thirdValue to set \n  */ \n public void setThirdValue(int thirdValue) { \n  this.thirdValue = thirdValue; \n } \n /* (non-Javadoc) \n  * @see java.lang.Object#hashCode() \n  */ \n @Override \n public int hashCode() {   \n  return this.toString().hashCode(); \n } \n /* (non-Javadoc) \n  * @see java.lang.Object#equals(java.lang.Object) \n  */ \n @Override \n public boolean equals(Object obj) { \n  if ( obj == null ){ \n   return false; \n  } \n  if (!(obj instanceof ThreeMemberSubSet)){ \n   return false; \n  } \n  ThreeMemberSubSet otherObj = (ThreeMemberSubSet) obj; \n  if ( this.toString().equals(otherObj.toString())){ \n   return true; \n  } \n  return false; \n } \n /* (non-Javadoc) \n  * @see java.lang.Object#toString() \n  */ \n @Override \n public String toString() { \n  StringBuilder toStringMsg = new StringBuilder(); \n  toStringMsg.append(\"ThreeMemberSubSet::[\"); \n  toStringMsg.append(getFirstValue()); \n  toStringMsg.append(getSecondValue()); \n  toStringMsg.append(getThirdValue()); \n  toStringMsg.append(\"]\"); \n  return toStringMsg.toString(); \n } \n /* (non-Javadoc) \n  * @see java.lang.Comparable#compareTo(java.lang.Object) \n  */ \n @Override \n public int compareTo(ThreeMemberSubSet otherObj) { \n  if (otherObj == null){ \n   return 0; \n  } \n  if ( (this.getFirstValue() == otherObj.getFirstValue()) \n    && (this.getSecondValue() == otherObj.getSecondValue()) \n    && (this.getThirdValue() == otherObj.getThirdValue())) { \n   return 0; \n  } \n  if ( (this.getFirstValue() == otherObj.getSecondValue()) \n    && (this.getSecondValue() == otherObj.getFirstValue()) \n    && (this.getThirdValue() == otherObj.getThirdValue())) { \n   return 0; \n  } \n  if ( (this.getFirstValue() == otherObj.getThirdValue()) \n    && (this.getSecondValue() == otherObj.getFirstValue()) \n    && (this.getThirdValue() == otherObj.getSecondValue())) { \n   return 0; \n  } \n  if ( (this.getFirstValue() == otherObj.getFirstValue()) \n    && (this.getSecondValue() == otherObj.getThirdValue()) \n    && (this.getThirdValue() == otherObj.getSecondValue())) { \n   return 0; \n  } \n  if ( (this.getFirstValue() == otherObj.getSecondValue()) \n    && (this.getSecondValue() == otherObj.getThirdValue()) \n    && (this.getThirdValue() == otherObj.getFirstValue())) { \n   return 0; \n  } \n  if ( (this.getFirstValue() == otherObj.getThirdValue()) \n    && (this.getSecondValue() == otherObj.getSecondValue()) \n    && (this.getThirdValue() == otherObj.getFirstValue())) { \n   return 0; \n  } \n  return 1; \n } \n} \n \npublic class ThreeMemberSubSetEx { \n public static void main(String[] args) { \n  SortedSet uniqueSubset= new TreeSet(constructThreeMemberSubset()); \n  System.out.println( \"Unique Value = \" + uniqueSubset); \n } \n private static List constructThreeMemberSubset(){ \n  List subset= new ArrayList(); \n  ThreeMemberSubSet ob1 = new ThreeMemberSubSet(1,2,3); \n  ThreeMemberSubSet ob2 = new ThreeMemberSubSet(2,1,3); \n  ThreeMemberSubSet ob3 = new ThreeMemberSubSet(1,3,2); \n  ThreeMemberSubSet ob4 = new ThreeMemberSubSet(2,3,1); \n  ThreeMemberSubSet ob5 = new ThreeMemberSubSet(3,2,1); \n  ThreeMemberSubSet ob6 = new ThreeMemberSubSet(3,1,2); \n  subset.add(ob1); \n  subset.add(ob2); \n  subset.add(ob3); \n  subset.add(ob4); \n  subset.add(ob5); \n  subset.add(ob6); \n  return subset; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Better logic: A 3 element subset (3e) can be one of following form: (a,b,c) (3 different numbers) (a,a,b) (a,a,a)  Now loop through the array and eliminate repeated number, mark number of appearance for them as (1, 2 or >3) ---> S1, S2, S3  List out all (a,b) which a is from S2 and b is from S1 or S2 List out all (a,b,c) which all from S1 and a So, from that observation, you can see that we only need to separate number which appear only 1 time in the array and others which appear more than 1 in the array.  That is my idea, and the complexity can be minimal as N^3"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Perl implementation:   #input: abcdefg 3 #Note: the string should be sorted and all letters should be distinct # This program can output any length of non-duplicate  # combinations given a string and a length n  #!/usr/bin/perl  $str = ; chomp($str);  ($s, $n) = split(' ', $str); $st = substr $str, 0, $n;  $ary{$st} = 1;  #print $st.\"|\".$n.\"\\n\"; subset($n, $s);  for my $key (keys %ary){         $count ++;         print $key.\" \".$count.\"\\n\"; } sub subset{         $index = $_[0];         $str = $_[1];         if($index >= length($str)){ # Stop at the string end                 return;         }         #print $index.\"\\t\".$str.\"\\t\".$st.\"\\n\";         $st = substr $str, $index, 1;         #print $index.\"\\t\".$str.\"\\t\".$st.\"\\n\";         my %hash = ();         for my $key (keys %ary){ # Go through each previous combination                 for($i = 0; $i < $n; $i ++){                         my $k = $key;                         substr($k, $i, 1) = ''; # Remove one element                         $k = $k.$st;    # Add a new one                         #print $key.\" \".$k.\" \".$i.\" \".$n.\" \".$st.\"\\n\";                         if($hash{$k} != 1){ # Check if this has been generated                                 $hash{$k} = 1;                         }                 }         }         @ary{keys %hash} = values %hash; # union the two hashes into one         subset($index + 1, $str); #Repeat this until the end of the string  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be done recursively for K out of N numbers. Assuming unique numbers here is c++ code."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int[] arr =  {0,2,3,3,2,0};  \narr = ArrayUtils.removeDuplicates(arr); \n   \n  int n = arr.length; \n  int k = 3;  \n   \n  List> subsets = generateSubsets(arr, 0, 3); \n \n public List> generateSubsets( final int[] arr, int index, int size){ \n \n  if( size > (arr.length-index) ){ \n   return new ArrayList<>(); \n  } \n   \n  if( size == 1 ){     \n   List> oneElementSubsets = new ArrayList<>();    \n   for( int i = index; i < arr.length; i++ ){ \n    oneElementSubsets.add( create(arr[i]) ); \n   }    \n   return oneElementSubsets; \n  } \n   \n  List> allSubsets = new ArrayList<>(); \n   \n  List> smallerSizeSubsets = generateSubsets(arr, index+1, size-1); \n   \n  for( List curSubset : smallerSizeSubsets ){ \n    \n   List singleElem = create(arr[index]); \n   singleElem.addAll( curSubset ); \n    \n   allSubsets.add( singleElem ); \n  } \n   \n  List> sameSizeSubsets = generateSubsets(arr, index+1, size); \n   \n  for( List curSubset : sameSizeSubsets ){ \n   allSubsets.add( curSubset ); \n  } \n   \n  return allSubsets; \n \n   \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"** \n *  \n * Given an array, find all unique three-member subsets,  \n * with unique being that [0,2,3] and [3,2,0] are the same set.  \n * Should run in faster than 2^n time \n * @author patrick \n * \n */ \npublic class UniqueGroup { \n \n public static void main(String[] args) { \n  int[] values = new int[] {1, 2, 3, 4, 5}; \n   \n  List r = unique(values); \n   \n  for(int[] t : r) { \n   System.out.println(\"[\" + t[0] + \" \" + t[1] + \" \" + t[2] + \"]\"); \n  } \n } \n  \n public static List unique(int[] values) { \n  List results = new ArrayList(); \n   \n  for(int j=0; j"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package com.my.tst;  import java.util.Arrays; import java.util.HashSet; import java.util.Set; import java.util.Stack;  public class SetOfThree {   public Set getGroupsOfThree(int[] in){   Set groupSet = new HashSet();   Stack group = new Stack();   doGetGroupsOfThree(in, 0, group, groupSet);   return groupSet;  }    public void doGetGroupsOfThree(int[] in, int start, Stack group, Set groupSet){   if(group.size() == 3){    addGroup(group, groupSet);    return;   }   if(start >= in.length || group.size() + in.length - start < 3){    return;   }   for(int i = start; i   group.push(in[i]);    doGetGroupsOfThree(in,i+1,group, groupSet);    group.pop();   }  }    void addGroup(Stack group, Set groupSet){   Integer[] intArray = group.toArray(new Integer[group.size()]);   Arrays.sort(intArray);   String groupString = Arrays.asList(intArray).toString();   if(!groupSet.contains(groupString)){    groupSet.add(groupString);    System.out.println(groupString);   }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package com.my.tst; \n \nimport java.util.Arrays; \nimport java.util.HashSet; \nimport java.util.Set; \nimport java.util.Stack; \n \npublic class SetOfThree { \n \n public Set getGroupsOfThree(int[] in){ \n  Set groupSet = new HashSet(); \n  Stack group = new Stack(); \n  doGetGroupsOfThree(in, 0, group, groupSet); \n  return groupSet; \n } \n  \n public void doGetGroupsOfThree(int[] in, int start, Stack group, Set groupSet){ \n  if(group.size() == 3){ \n   addGroup(group, groupSet); \n   return; \n  } \n  if(start >= in.length || group.size() + in.length - start < 3){ \n   return; \n  } \n  for(int i = start; i group, Set groupSet){ \n  Integer[] intArray = group.toArray(new Integer[group.size()]); \n  Arrays.sort(intArray); \n  String groupString = Arrays.asList(intArray).toString(); \n  if(!groupSet.contains(groupString)){ \n   groupSet.add(groupString); \n   System.out.println(groupString); \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a basic solution in python. Sort out the elements, get a unique array and then iterate. Since we are looking for sets repetitions are not allowed ({1,1,3} is not a valid solution)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Another simple solution with time o(n^2)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Another solution with Time O(n^2)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void PrintUniqueTriplets(int[] arr) \n        { \n            int n = arr.Length; \n            Hashtable h = new Hashtable(); \n            string s = \"\"; \n            int min,max,mid; \n            for (int i = 0; i < n ; i++) \n            { \n                for (int j = 0; j < n - 1; j++) \n                { \n                    min = Math.Min(arr[i], Math.Min(arr[j], arr[j + 1])); \n                    max = Math.Max(arr[i], Math.Max(arr[j], arr[j + 1])); \n                    mid = arr[i] + arr[j] + arr[j + 1] - min - max; \n                    s = min.ToString() + mid.ToString() + max.ToString(); \n                    if (i == j || i==j+1 || h.ContainsKey(s)) \n                        continue;                     \n                    h.Add(s, 1); \n                    Console.WriteLine(arr[i] + \" \" + arr[j] + \" \" + arr[j + 1]); \n                } \n            } \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void PrintUniqueTriplets(int[] arr) \n        { \n            int n = arr.Length; \n            Hashtable h = new Hashtable(); \n            string s = \"\"; \n            int min,max,mid; \n            for (int i = 0; i < n ; i++) \n            { \n                for (int j = 0; j < n - 1; j++) \n                { \n                    min = Math.Min(arr[i], Math.Min(arr[j], arr[j + 1])); \n                    max = Math.Max(arr[i], Math.Max(arr[j], arr[j + 1])); \n                    mid = arr[i] + arr[j] + arr[j + 1] - min - max; \n                    s = min.ToString() + mid.ToString() + max.ToString(); \n                    if (i == j || i==j+1 || h.ContainsKey(s)) \n                        continue;                     \n                    h.Add(s, 1); \n                    Console.WriteLine(arr[i] + \" \" + arr[j] + \" \" + arr[j + 1]); \n                } \n            } \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* \nGiven an array, find all unique three-member subsets, with unique being that [0,2,3] and [3,2,0] are the same set. Should run in faster than 2^n time \n*/ \n \n#include  \n#include  \n \nusing namespace std; \n \n/* Main Code Starts from here */ \n \nvoid solve(vector< vector > &vii, vector &res, vector &vi, int pos, int n) { \n if(n==3) { \n vii.push_back(res); \n return; \n    } \n    else { \n        for(int i=pos; i > subset(vector vi) { \n vector< vector > vii; \n vector subvec; \n solve(vii, subvec, vi,0, 0); \n return vii; \n} \n \nint main() { \n \n    int arr[] = {1,2,3,4,5}; \n    vector vi(arr, arr+sizeof(arr)/sizeof(int) ); \n \n    vector< vector > out = subset(vi); \n    for(auto i: out) { \n        for(auto j:  i) \n            cout << j << \" \"; \n        cout<< endl; \n    } \n    return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void print3SubSets(int[] arr, int ai, int[] sol, int level, bool marked[][] marked) { \n     \n    if(level == 4) { \n        print(sol, level); \n    } \n     \n    if(ai >= arr.length()) { \n        return; \n    } \n         \n    if(marked[level][arr[i]] == false) { \n        marked[level]arr[i]] = true; \n        sol[level] = arr[i]; \n        print3SubSets(arr, ai + 1, sol, level +1 , marked); \n         \n        for(int i = level + 1; i <= 3; i++) { \n            for(int j = 0; j < 9; j++) { \n                marked[i][j] = false; \n            } \n        } \n         \n        print3SubSets(arr, ai + 1, sol, level +1 , marked); \n    } else { \n        print3SubSets(arr, ai + 1, sol, level, marked); \n    } \n     \n     \n     \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This code will be ok."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=18824667","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"47","title":"You are given an array of 1's 2's and 3's. Sort this list so the 1's are first, the 2's come second, and the 3's come third.  Ex:  Input [1, 3, 3, 2, 1]         Output [1, 1, 2, 3, 3]  But there is a catch!! The algorithm must be one pass, which means no merge/quick sort. Also no extra list allocations are allowed, which means no bucket/radix/counting sorts.   You are only permitted to swap elements.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"11","title":"dutch national flag problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"10","title":"Here is the java code for dutch national flag problem. Catering this scenario.  The logic is to align 1's to the left and 3's to the right. the 2's will automatically get into their respective positions."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"A java solution below. Note that given that I do have to keep track of where the ones and threes go, it'd only take an extra variable to count the twos as well and do a bucket sort... but I think this is most in keeping with the spirit of the question."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Its like two values in array just 0 and 1  Now here there are three values 1, 2, 3. Run a loop,with three indexes for three values. two at start and one at the last"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  using namespace std;  #define SIZE 10  int main() {     int two=0, three=0, size=SIZE-1;      int arr[SIZE] = {1,3,3,2,1,2,3,1,3,2};      for(int i=0;i    {         if(arr[i]==1)             continue;         else if(arr[i]==2)         {             two++;             arr[i] = 1;         }         else if(arr[i]==3)         {             three++;             arr[i] = 1;         }     }      for(int i=0;i    {         cout<    }     cout<      cout<<\"THREE:: \"<<    cout<<\"TWO:: \"<<      while(three!=0)     {         arr[size] = 3;         three--;         size--;     }     while(two!=0)     {         arr[size] = 2;         two--;         size--;     }      for(int i=0;i    {         cout<    }     cout<     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Have two pointers, one representing beginning index of 2 and the other representing beginning index of 3.  2.Let their initial values be -1.  3. Traverse from left to right. If you get 1 and the two indices are -1 just leave it, no swap required 4. Let i be the looping index 5. If threestartindex is -1 and twostartindex isnt or viceversa, swap a[correspondingpointer] and a[i], increment correpondingpointer by one 6. if twostartindex is -1 and the two startindex isnt -1 and we have 2 as input, no swaps are necessary, they are in order. Do similarly for vice versa 7. If none of the indices are -1 and we get 2 as input, swap a[i] and a[threestartingpointer] and increment threestartingpointer by one 6. If none of the indices are -1 and we get 1 as input, swap a[i] and a[threestartingpointer] and increment threestartingpointer by one. Swap a[threestartingpointer-1] and a[twostartingpointer] and increment a[twostartingpointer] 7. If none of the indices are -1 and the input is 3, no swap required.  Hope this will work."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/**   * time: O(n)   * space: O(1)   */  void sort(int[] arr){      int one = -1;   int two = -1;      for( int i =0; i < arr.length; i++ ){    if( arr[i] == 2 ){     ArrayUtils.swap(arr, i, two+1);     ++two;    }       else if( arr[i] == 1 ){     ArrayUtils.swap(arr, i, two+1);         ArrayUtils.swap(arr, two+1, one+1);         ++one;     ++two;    }       else if( arr[i] != 3 ){     throw new IllegalStateException(\"Incorrect value for array: \" + arr[i]);    }   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void sort012(int a[], int arr_size) \n{ \n   int lo = 0; \n   int hi = arr_size - 1; \n   int mid = 0; \n  \n   while(mid <= hi) \n   { \n      switch(a[mid]) \n      { \n         case 0: \n           swap(&a[lo++], &a[mid++]); \n           break; \n         case 1: \n           mid++; \n           break; \n         case 2: \n           swap(&a[mid], &a[hi--]); \n           break; \n      } \n   } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Its Dutch national flag problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include using namespace std; int main() {     int o,i,m=0,n=6,temp,max=7;     int a[]={3,3,2,1,1,2,2};     for(i=0;i    {if(a[i]==1)      {temp=a[m];       a[m]=a[i];       a[i]=temp;      m++;}     if(a[i]==3)      {temp=a[n];       a[n]=a[i];       a[i]=temp;      n--;max--;}     if(a[i]==2)      {temp=a[m];       a[m]=a[i];       a[i]=temp;}}       for(i=0;i<7;i++)     { cout<    return 0; }   if this code is correct ans of question"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Wouldn't the partition algorithm work?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void Sort(int[] array) \n{ \n    int below = -1; \n    int above = array.Length; \n \n    for (int i = 0; i < above; ) \n    { \n        if (array[i] == 1) \n        { \n            // below \n            Swap(array, i, ++below); \n            i++; \n        } \n        else if (array[i] == 3) \n        { \n            // above \n            Swap(array, i, --above); \n        } \n        else \n        { \n            // middle \n            i++; \n        } \n    } \n} \n \nvoid Swap(int[] array, int i, int j) \n{ \n    int tmp = array[i]; \n    array[i] = array[j]; \n    array[j] = tmp; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for(i=1;i0;j--) \n   { \n    if(a[j-1]<=a[j]) \n     break; \n    else \n    { \n     tmp=a[j]; \n     a[j]=a[j-1]; \n     a[j-1]=tmp; \n    } \n   } \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is my solution, with complexity O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void swap(int * input,int i,int j) \n{ \n int temp = input[j]; \n input[j] = input[i]; \n input[i] = temp; \n} \nvoid sorting(int length, int *input) \n{ \n int onePointer = 0; \n int threePointer = length-1; \n for(int i = 0; i <= threePointer; i++) \n { \n  while(input[onePointer]==1) \n  { \n   i++; \n   onePointer++; \n  } \n  while(input[threePointer]==3) \n  { \n   threePointer--; \n  } \n \n  if(input[onePointer] == 3 && input[threePointer] == 1) \n  { \n   onePointer++; \n   threePointer--; \n   swap(input,i,threePointer); \n  } \n  else if(input[i] == 1) \n  { \n   swap(input,i,onePointer); \n   onePointer++; \n  } \n  else if(input[i] == 3) \n  { \n   swap(input,i,threePointer); \n   threePointer--; \n   i--; \n  } \n   \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package array;  public class arrangeNumbers {    public void arrangeData(int arr[]){   int oneLen=-1;   //int twoLen=-1;   int threeLen=-1;   int arrLen=arr.length-1;   System.out.println(\"arrlen:\"+arrLen);   for (int i=0;i   if (arr[i]==3 && threeLen!=i){     if (threeLen<0){      threeLen=arrLen;     }          while(arr[threeLen]==3 ){      threeLen--;     }      swap(i,threeLen,arr);     threeLen--;    }        if (arr[i]==2){     swap(i,oneLen+1,arr);    }    if (arr[i]==1){     if (oneLen<0){      swap(i,0,arr);     }     else{      swap(oneLen+1,i,arr);     }     oneLen++;          //printnumbers(arr);    }        if (i==threeLen && threeLen>0){     break;    }   }   printnumbers(arr);  }  private void printnumbers(int arr[]){   for(int i:arr){    System.out.println(i);   }     }  private static void swap(int i, int j, int[] arr) {  if (arr[i]==arr[j]||i==j){   return;  }  int temp=arr[i];  arr[i]=arr[j];  arr[j]=temp;  }  public static void main(String args[]){   int[] arr={1,2,2,2,2,1,3,2,3,1,2,3,3,2,2,3,1,1,2,3,2,1};   arrangeNumbers an=new arrangeNumbers();   an.arrangeData(arr);  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class arrangeNumbers { \n  \n public void arrangeData(int arr[]){ \n  int oneLen=-1; \n  int threeLen=-1; \n  int arrLen=arr.length-1; \n  System.out.println(\"arrlen:\"+arrLen); \n  for (int i=0;i0){ \n    break; \n   } \n  } \n  printnumbers(arr); \n } \n private void printnumbers(int arr[]){ \n  for(int i:arr){ \n   System.out.println(i); \n  } \n   \n } \n private static void swap(int i, int j, int[] arr) { \n if (arr[i]==arr[j]||i==j){ \n  return; \n } \n int temp=arr[i]; \n arr[i]=arr[j]; \n arr[j]=temp; \n } \n public static void main(String args[]){ \n  int[] arr={1,2,2,2,2,1,3,2,3,1,2,3,3,2,2,3,1,1,2,3,2,1}; \n  arrangeNumbers an=new arrangeNumbers(); \n  an.arrangeData(arr); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here is a python code.  go through the elements of the list.  when encountering 1, throw it to the front; when encountering 2, do nothing; when encountering 3, throw it to the end."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void dutchFlag(int [] array) \n    { \n int top = 0; \n int bottom = array.length-1; \n \n int cursor = 0; \n while (cursor <=bottom) \n { \n     if (array[cursor] == 0) \n     { \n  swap(array, top, cursor); \n  top++; \n  cursor++; \n     } \n     else if (array[cursor] == 2) \n     { \n  swap(array, bottom, cursor); \n  bottom--; \n     } \n     else \n     { \n  cursor++; \n     } \n } \n    } \n  \n    public static void swap(int[] arr, int i, int j) { \n        int temp = arr[i]; \n        arr[i] = arr[j]; \n        arr[j] = temp; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/** \n * You are given an array of 1's 2's and 3's. Sort this list so the 1's are first, the 2's come second, and the 3's come third.  \n *  \n * Ex: Input [1, 3, 3, 2, 1]  \n * Output [1, 1, 2, 3, 3]  \n *  \n * But there is a catch!! The algorithm must be one pass, which means no merge/quick sort. Also no extra list allocations are allowed, which means no bucket/radix/counting sorts.  \n *  \n * You are only permitted to swap elements. \n *  \n * @author patrick \n * \n */ \npublic class App { \n \n private static void swap(int[] values, int i, int j) { \n  int x = values[j]; \n  values[j] = values[i]; \n  values[i] = x; \n } \n  \n public static void sort(int[] values) { \n  for(int i=1; i0) { \n    int v = values[j]; \n    //adjacent value \n    int pv = values[j-1]; \n    //if current value is smaller than adjacent \n    if(v < pv) { \n     swap(values, j-1, j); \n     j--; \n    } \n    else { \n     break; \n    } \n   } \n  } \n } \n  \n public static void main(String[] args) { \n  int[] values = new int[] {1, 3, 3, 2, 1}; \n   \n  sort(values); \n   \n  for(int v : values) { \n   System.out.print(v + \" \"); \n  } \n } \n  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my PHP code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"shouldn't it be just a counting sort problem?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \nvoid swap(int *a, int i, int j) { \n    int temp = a[i] ; \n    a[i] = a[j] ; \n    a[j] = temp ; \n} \n \nvoid sort(int *a, int len) { \n \n    int low = 0 ; \n    int mid = 0 ; \n    int high = len -1 ; \n \n    while(mid <= high) { \n switch(a[mid]) { \n     case 1: \n  swap(a, low, mid) ; \n  ++low; \n  ++mid;; \n  break; \n     case 2: \n  ++mid; \n  break; \n     case 3: \n  swap(a, mid, high) ; \n  --high; \n  break; \n } \n    } \n} \n \nint main() { \n    int a[] = {1,3,3,2,1,3,2} ; \n \n    sort(a, 7) ; \n \n    for(int i = 0 ; i < 7 ; ++i) \n printf(\"%d \", a[i]) ; \n    printf(\"\\n\"); \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i dnt knw d exact code..... but what if we consider d 3,3 as single element nd swap it with 1 in i/p array... {1,3,3,2,1} swaping 3,3 with 1 in d end about 2 will just b a single pass... and d array wl b sorted...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My ruby code in O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a simple C implementation with one swap"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class FacebookSort{ \n \n static int length; \n static int[] a; \n static int start; \n static int end; \n static int temp; \n  \n public static void sort(){ \n  temp = start; \n  while(temp <= end){ \n   if(a[temp] == 1){ \n    a[start] = a[temp] + (a[temp] = a[start]) - a[start]; \n    start ++; \n    temp ++; \n   } \n   else if(a[temp] == 3){ \n    a[end] = a[temp] + (a[temp] = a[end]) - a[end]; \n    end --; \n   } \n   else{ \n    temp ++; \n   } \n  } \n } \n  \n public static void display(){ \n  for(int i = 0; i < length; i ++){ \n   System.out.print(a[i] + \" \"); \n  } \n } \n   \n public static void main(String[] args){ \n  length = args.length; \n  a = new int[length]; \n  end = length - 1; \n  for(int i = 0; i < length; i ++){ \n   a[i] = Integer.parseInt(args[i]); \n  } \n  sort(); \n  display(); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void modify123OnePass(int[] array) { \n  int oneEnd = -1; \n  int twoEnd = -1; \n  int threeEnd = -1; \n  for (int c : array) { \n   if(c == 1) { \n    array[++OneEnd] = 1; \n    if (twoEnd != -1) { \n     array[++twoEnd] = 2; \n    } \n    if (threeEnd != -1) { \n     array[++threeEnd] = 3; \n    } \n   } else if (c == 2) { \n    if (twoEnd == -1 && oneEnd != -1) { \n     twoEnd = oneEnd; \n    } \n    array[++twoEnd] = 2; \n    if (threeEnd != -1) { \n     array[++threeEnd] = 3 \n    } \n   } else { \n    if (threeEnd == -1) { \n     if (twoEnd != -1) { \n      threeEnd = twoEnd; \n     } else { \n      threeEnd = oneEnd; \n     } \n    } \n    str[++threeEnd] = 'B'; \n   } \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void rearrange(vector& v) \n{ \n for (int i = 0, p = -1, q = v.size(); i < q; ) { \n  if (v[i] == 1 && i != p) { \n   ++p; \n   swap(v[p], v[i]); \n   continue; \n  } else if (v[i] == 3 && i != q) { \n   --q; \n   swap(v[q], v[i]); \n   continue; \n  } \n   \n  ++i; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think we need to check each element in the array twice for both 1 and 3. Here is my code with time complexity O(n):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"g"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public class Test { int a[]={1,2,1,3,1,2,3,2}; int b[]= new int[20]; static int index=0;  void arrange(int val) {  for(int i=0;i {   if(a[i]==val)     {    b[index] = a[i];    index++;   }    }  }  public static void main(String args[]){   Test obj = new Test();    obj.arrange(1);    obj.arrange(2);    obj.arrange(3);    for(int j=0;j   {     System.out.print(obj.b[j]);    }    } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-5","title":"Bubble sort ?????  I think it will work???"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16381662","download_status":"DOWNLOAD_DONE","votes":"4","answersCount":"18","title":"Write a function that accepts two or more strings and returns the longest common substring in all of them.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"We can use suffix tree to solve this problem. But can you write the necessary code in an interview on the blackboard correctly? That's difficult!!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"1> If people already knows the len of each strings, sort the strings in the ascend order of the strings. 2> pick two strings from the list, build the suffix tree for each strings.   3> Based on the suffix tree of the shortest string, prune suffix tree based on the another  suffix tree. 4> If the result tree is empty one, return NULL; 5> pick another string from the list if one exist, build suffix tree of that string, and go to 3.  6> If there is no more string in the list, return the longest path of the result tree as the result."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Another way to slice this is to do sort of a breadth-first search.  First make a hash of all the common 2-grams across all the lists, pruning as you march down the lists.  For each 2-gram, keep a cache of locations within each list.  (If the list of 2-grams is empty, just have special case code to find a single character in all strings.)  Then when you go the 3-gram  phase, start with all the 2-grams for the first list, and find their 3rd character.  Let's say you start with ce and the first occurrence of ce in the first list is followed by x, giving you the 3-gram of cex.  If \"ex\" is not in the map of 2-grams common to all lists, then you'll know that cex won't be in all lists either (for obvious reasons), so you can prune immediately.  Otherwise, push it on to the list of working 3-grams, and then keep proceeding through the 2-grams for list one.  In processing the second list, update the working list of 3-grams, then at the end, sweep all the 3-grams that only showed up in both of the first two lists.  Keep continuing in this fashion until you can't extend any of the n-grams."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"string maxsub(string[] strA) \n for (i=0;i Len(result) \n    result = test \n return result"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/**      * Returns the longest shortest substring (LCS) of two strings.      *       * @param aString First string.      * @param bString Second string.      * @return The longest common substring of aString and bString.      */     public String longestSubstring(final String aString, final String bString) {             // Get length of the 2 string      final int m = aString.length();         final int n = bString.length();                  // to ensure O(min(m,n)) space complexity         // the biggest string should be the first parameter         // so i swap them and try again         if (n > m){          return longestSubstring(bString,aString);         }                  // Initialize the 2 array to the length of the longest string          int maxLength = Math.min(m,n);         int[] last = new int[maxLength];         int[] next = new int[maxLength];         StringBuffer result = new StringBuffer();                   int len = 0;         final char []a = aString.toCharArray();         final char []b = bString.toCharArray();          for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 if (a[i] == b[j]) {                     next[j] = 1 + (j - 1 >= 0 ? last[j - 1] : 0);                     if (next[j] > len) {                         len = next[j];                         result.setLength(0);                         final int beginIndex = i - len + 1;                         final int endIndex = len + beginIndex;                         result.append(aString.subSequence(beginIndex, endIndex));                     }                 }             }             System.arraycopy(next, 0, last, 0, maxLength);             Arrays.fill(next, 0);         }         return result.toString();     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Working PHP solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Say there are N strings.  (1) Construct a suffix tree with the first string. In each node of the suffix tree maintain a count, which will be initialized to zero. (2) Now search all the suffix strings of each string, and while searching increment the count of the suffix-tree-node if found. (3) Repeat step (2) for all the N-1 strings (except the first string). (4) Do DFS on the suffix tree and return the longest-string, where node is considered valid only if its count is equal to N-1.  Here is the C++ code ..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. For every char in the first string starting from position 0, do 2 - 4 below. 2. Find the same char in every other string. Keep their positions in a vector. If not found in any string, loop back to 1. 3. Keep moving the positions in every string until they do not match. Return the substring; 4. If the substr is longer than the max str, replace the max string with it 5. return max str."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static String longestCommonSubstring(String str, String str2) \n    { \n String result = \"\"; \n  \n int i=0; \n int duration=0; \n  \n while (i result.length()) \n      { \n   result = str.substring(i, i+duration); \n      } \n      j++; \n      duration =0; \n  } \n     } \n     i++; \n } \n  \n return result; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using System; \nusing System.IO; \nusing System.Collections.Generic; \n \nclass FaceBook \n{ \npublic static void Main(){ \n                                                      \n \n   string[] input={\"coldheartedly\",\"closefistedly\",\"bigotedly\",\"belatedly\",\"antedlon\"}; \n    \n   foreach(var l in LongestCommonSubString(input)) \n     Console.WriteLine(\"Longest Common SubString={0}\",l); \n} \n \npublic static HashSet LongestCommonSubString(string[] inputStrings){ \n     \n    \n    HashSet maxSet=new HashSet(); \n    int inputCount=inputStrings.Length; \n    string smallestString=inputStrings[inputCount-1]; \n \n    for(int length=smallestString.Length ; length>=0;length--) \n    { \n         if(maxSet.Count>0) \n          return maxSet; \n           \n       \n         HashSet tempSubs= new  HashSet(); \n         \n        tempSubs=getAllSubs(smallestString,length); \n        bool isCommon=true; \n       \n        foreach(var sub in tempSubs) \n        {  \n             isCommon=true; \n          \n                 for(int i=inputCount-2; i>=0;i--) \n                  {  \n                     if(inputStrings[i].IndexOf(sub)==-1) { \n                      isCommon=false; \n                      break;    \n                     } \n                       \n                  } \n                   \n             if(isCommon)    \n                   maxSet.Add(sub); \n            } \n        \n    } \n     \n    return maxSet; \n     \n} \n \nprivate static HashSet getAllSubs(string input,int length){ \n   HashSet subs =new HashSet(); \n    \n   for(int i=0;i<=input.Length-length;i++) \n   { \n    subs.Add(input.Substring(i,length)); \n   \n   } \n    \n   return subs; \n} \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"please provide ur answers barry!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"///"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15856737","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"6","title":"Design the Facebook newsfeed for an Android app. The actual design would be very complex so you may limit your solution to only status updates and photo posts. Keep your answer broad rather than deep since it would need to fit in a 45-minute interview.   Normally you would need to ask the interviewer a lot of questions but since that is not possible here, state your assumptions.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This  is a bare minimum logic:  There are users. User has a list of Posts. User has a list of friends. There is a news feed for each user. News feed has a list of Posts collected from your friends list Using Observer pattern."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Barry, Did you interview in Palo Alto or Seattle?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"barry...can u share ur answer too"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use MVC where  public class Controller { //User updates will make a call to this class    statusUpdate(String userId, Status status); //makes call to model    postPhoto(String userId, Photo photo); }  public class Model { //Does db updates and notifies view   statusUpdate(String userId, Status status); //Updates status in DB, finds user and his friends, notifies friends views with new status   postPhoto(String userId, Photo photo); }  public class View {   String userId;   Wall wall;   updateWall(User user, Status status);   updateWall(User user, Photo photo);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Create a NewsFeed Activity that uses a List Adapter to populate a ListView with data from a Cursor returned by a request to a Content Provider."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16142677","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"52","title":"Given an virtual 4x4 boggle board, and some 4 letter words, determine if the words are in the board  ex.   S M E F R A T D L O N I K A F B  STAR- no TONE- no NOTE- yes SAND- yes etc.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I think the other solutions do not handle usage of the same character twice. Below is the bug free solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Heres a DFS implementation with a hash lookup for the first letter written in objective-c"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We need to build a hash for each character in the boggle board, and make a recursive search on each character of the string:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this is the same idea as chenic626, but I couldn't understand their code very well, so I did it myself."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Build a hash map keyed on position. For every letter of the word you have to find, search every adjacent position of the previous letter. For the first letter, you will have to search all positions. This does it in O(n). Please correct me if I am wrong."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@rfaccone Can you please clarify how is NOTE - Yes and TONE - No as I could see all the four chars in the two words same?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Words can be constructed from the letters of sequentially adjacent cubes, where \"adjacent\" cubes are those horizontally, vertically, and diagonally neighboring"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This doesn't handle the duplicate characters.If someone can suggest a way to handle that ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"findWord(int[][] data,char[] word){ \n int k=0;//position of character in checking word. \n for(int i=0;i<4;i++){ \n  for(int j=0;j<4;j++){ \n   if(data[i][j]==word[k]){ \n    if(checkWord(i,j,k++,data,words){ \n     System.out.println(\"word exists\"); \n     break; \n    } \n   } \n  } \n } \n} \npublic boolean checkWord(int i,int j,int k,int[][] data,char[] word){ \n if(k==words.length) return true; \n char letter=words[k]; \n if(j!=3 && data[i][j+1]==letter) return checkWord(i,j++,k++,data,word); \n if(i!=3 && data[i+1][j]==letter) return checkWord(i++,j,k++,data,word); \n if(i!=3 && j!=3 && data[i+1][j+1]==letter) return checkWord(i++,j++,k++,data,word); \n if(i!=0 && data[i-1][j]==letter) return checkWord(i--,j,k++,data,word); \n if(j!=0 && data[i][j-1]==letter) return checkWord(i,j--,k++,data,word); \n if(i!=0 && j!=0 && data[i-1][j-1]==letter) return checkWord(i--,j--,k++,data,word); \n if(i!=3 && j!=0 && data[i+1][j-1]==letter) return checkWord(i++,j--,k++,data,word); \n if(i!=0 && j!=3 && data[i-1][j+1]==letter) return checkWord(i--,j++,k++,data,word); \n} \ntime complexiy is O(N*M*K) in worst case, where N is number of rows, M is number of columns and K is length of word for which we are searching.  Please let me know for improvements since I used brute force technique here"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public String verifyWords(String word){     char[] a={'S','M','E','F'};   char[] b={'R','A','T','D'};   char[] c={'L','O','N','I'};   char[] d={'K','A','F','B'};    int count=0;    for (int i = 0; i < word.length(); i++) {     char my=word.charAt(i);     for (int j = 0; j < a.length; j++) {      if(my==a[j]){       count=count+1;     }    }     for (int k = 0; k < b.length; k++) {       if(my==b[k]){        count=count+1;      }      }  for (int L = 0; L < c.length; L++) {        if(my==c[L]){         count=count+1;       }     }       for (int M = 0; M < d.length; M++) {         if(my==d[M]){          count=count+1;        }         }       }        System.out.println(\"count is--->\"+count);    if(count>=4){  return \"Yes\"; } else{  return \"NO\"; }       }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the answer in C#. This generalize into any size word and and size board (dimension mxn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Make a graph of 26 vertices and the edges representing the 8 neighbors. Note that some of the vertices would have more than 8 neighbors because the vertex character may be appearing multiple times. Now perform BFS upto level 4 and stop when the word is found."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"To clarify, can we use one alphabet repeatedly? If so, LOLO is yes, otherwise LOLO is no."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What do u think?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"just use a hash-map:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a solution, precompiling the boggle with a Trie and then doing the search in O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a javascript solution that's a bit more readable and extensible, however it is slower than some of the other solutions."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Working PHP code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Most solutions proposed here are overly complicated. This is just a simple recursion question. write a top down solution. if a character matches then try to match the next character in the 8 characters around.. here's a simple approch  char board[4][4] = { 'S', 'M', 'E', 'F',                       'R', 'A', 'T', 'D',                       'L', 'O', 'N', 'I',                       'K', 'A', 'F', 'B' } ;  bool matchword(char*in, int x, int y) {  bool match = false;  if (*in == '\\0')   return true;   int newX;  int newY;  for ( int i = -1; i <=1; i++)  {   for (int j = -1; j <=1; j++)   {    newX = x+i;    newY = y+j;    if (newX < 0 || newX > 4) newX = x;    if (newY < 0 || newY > 4) newY = y;     if (board[newX][newY] == *in)     match = matchword(in+1, newX, newY);   }  }  return match; }  bool matchword(char* in) {  bool match = false;  for (int i = 0; i < 4; i++)  {   for (int j = 0; j < 4; j++)   {    if (board[i][j] == *in)     match = matchword(in+1, i, j);    }  }  return match; }  void main (int argc, char** argv) {  char* array[]={ \"STAR\", \"TONE\", \"NOTE\", \"SAND\" };  for (int i = 0; i < 4; i++)  {   char* res;   if (matchword(array[i]))    res = \"YES\";   else    res = \"NO\";   cout< }  _getch(); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think we can use BST to solve this problem by having another one variable to keep the count of each character. Since the word contains only four characters.so we can use four variables to keep track of the count while searching for given word..  For eg:   when we search for the word STARS let us assume BST contains count for S-1,T-3,A-2,R-1. first we will check S in BST and store the count in a variable by decrementing one.now the count will become zero.when  we search for S at the end of the string ,before that we search the count variable..Now count for char S will be 0..So the given word doest exist..  Its enough to form a BST with 26 different letters[a-z] at the maximum..if each char occurs at any no of time we can have count variable.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I found another one solution to this problem.The idea is take each character from 4*4 matrix and compare it with the all character of the given word to search.  if matches then replace that char in the given word to 0 0r some other special char. and also have a count variable which incremented by one for each char matches.. If the count be 4 and all the char in the given word is replaced by 0. then given word found in the matrix."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's a recursive solution in Java :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/** \n * Given an virtual 4x4 boggle board, and some 4 letter words, determine if the words are in the board  \n * ex.  \n *  \n * S M E F  \n * R A T D  \n * L O N I  \n * K A F B  \n *  \n * STAR- no  \n * TONE- no  \n * NOTE- yes  \n * SAND- yes  \n * etc. \n * @author patrick \n * \n */ \npublic class Board { \n \n \n  \n public static void main(String[] args) { \n  char[][] board = new char[][]{ \n    {'S','M','E','F'}, \n    {'R','A','T','D'}, \n    {'L','O','N','I'}, \n    {'K','A','F','B'} \n  }; \n   \n  String[] words = new String[] {\"STAR\", \"TONE\", \"NOTE\", \"SAND\"}; \n   \n  for(String word : words) { \n   char[] letters = word.toCharArray(); \n   Coordinate[] starters = find(board, letters[0]); \n   boolean found = false; \n   for(Coordinate starter : starters) { \n    if(boggleHelper(board, letters, 1, starter, null)) { \n     System.out.println(word + \" - YES\"); \n     found = true; \n     break; \n    } \n   } \n    \n   if(!found) { \n    System.out.println(word + \" - NO\"); \n   } \n    \n    \n  } \n } \n  \n private static boolean boggleHelper(char[][] board, char[] word, int index, Coordinate current, Coordinate origin) { \n  if(index >= word.length) { \n   return true; \n  } \n  Coordinate[] neighbors = findNeighbors(board, current, origin); \n  for(Coordinate neighbor : neighbors) { \n   if(board[neighbor.y][neighbor.x] == word[index]) { \n    if(boggleHelper(board, word, index+1, neighbor, current)) { \n     return true; \n    } \n   } \n  } \n   \n  return false; \n } \n  \n public static Coordinate[] findNeighbors(char[][] board, Coordinate current, Coordinate origin) { \n   \n  Coordinate[] all = new Coordinate[] { \n   new Coordinate(current.y+1, current.x-1), \n   new Coordinate(current.y+1, current.x), \n   new Coordinate(current.y+1, current.x+1), \n   new Coordinate(current.y, current.x-1), \n   new Coordinate(current.y, current.x+1), \n   new Coordinate(current.y-1, current.x-1), \n   new Coordinate(current.y-1, current.x), \n   new Coordinate(current.y-1, current.x+1) \n   }; \n   \n  List result = new ArrayList(all.length); \n   \n  for(Coordinate c : all) { \n   if(c.y >=0 && c.y<4 && c.x>=0 && c.x<4 && !c.equals(origin)) { \n    result.add(c); \n   } \n  } \n   \n  return result.toArray(new Coordinate[result.size()]); \n } \n  \n private static Coordinate[] find(char[][] board, char c) { \n  List results = new LinkedList(); \n  for(int y=0; y<4; y++) { \n   for(int x=0; x<4;x++) { \n    if(board[y][x] == c) { \n     results.add(new Coordinate(y, x)); \n    } \n   } \n  } \n  return results.toArray(new Coordinate[results.size()]); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using System; using System.IO; using System.Collections.Generic;  class FaceBook { public static void Main(){     char[][] board=new char[][]{              new char[]{'S','M','E','F'},              new char[]{'R','A','T','D'},              new char[]{'L','O','N','I'},              new char[]{'K','A','F','B'}             };                                                                                   BoggleBoard _4x4Board=new BoggleBoard(board);            Console.WriteLine(\"STAR:{0}\", _4x4Board.Match(\"STAR\"));    Console.WriteLine(\"TONE:{0}\", _4x4Board.Match(\"TONE\"));    Console.WriteLine(\"NOTE:{0}\", _4x4Board.Match(\"NOTE\"));     Console.WriteLine(\"SAND:{0}\", _4x4Board.Match(\"SAND\"));  }  public class BoggleBoard {   public  Dictionary listBorad=new Dictionary();      List> foundList=new List>();    HashSet setOKLoc =new HashSet();    HashSet foundLoc =new  HashSet();      private  char[][] board;         public  BoggleBoard(char[][] board1)     {        this.board=board1;        for(int i=0;i<4;i++)         for(int j=0;j<4;j++)           {             listBorad.Add((i*4)+j+1,board[i][j]);                      }              }          public bool Match(string input){         setOKLoc.Clear();         foundList.Clear();         foundLoc.Clear();         for(int i=0;i        {                int loc=0;         if(Find(input[i],out loc))           {           generateNighbure(loc);             if(i!=0 && !IsNighbour(loc))               return false;              }         }                return true;     }          private bool Find(char chr,out int loc){         loc=-1;         foreach(var pair in listBorad)         {             if(pair.Value==chr){                               if(foundLoc.Add(pair.Key))                {                      loc=pair.Key;                      return true;                }              }         }                  return false;     }          private void generateNighbure(int loc)     {         int[] nighbours={1,4};         int temp=0;         for(int i=0;i<=1;i++)         {             temp=loc+nighbours[i];             if(temp>0 && temp<=16)             {                 setOKLoc.Add(temp);             }              temp=loc-nighbours[i];             if(temp>0 && temp<=16)             {                 setOKLoc.Add(temp);             }         }          }          private bool IsInFoundList(int i,int j)     {         foreach(var l in foundList)         {             if (l[0]==i && l[1]==j  )               return true;                        }         return false;     }                 private bool IsNighbour(int newLoc)     {         foreach(var item in setOKLoc){             if(item==newLoc)             return true;                      }         return false;          } }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  #include  #include  #include  #include  #include   using namespace std;   bool check(vector > v,string str){      for(int i=0;i   for(int j=0;j        int index=0;         stack stkx;         stack stky;          stkx.push(i);         stky.push(j);          while(!stkx.empty()){           int x = stkx.top();           int y = stky.top();                      stkx.pop();           stky.pop(); //          cout<<<\" \"<<          if(v[x][y]==str[index]){            //cout<           index++;            //we got out letter..lets apply dfs here            for(int k=-1;k<2;k++){             for(int l=-1;l<2;l++){              if(k==0 && l==0){}              else{              if(x+k>=0 && x+k<4 && y+l>=0 && y+l<4 && v[x+k][y+l]==str[index]){               stkx.push(x+k);               stky.push(y+l);               }              }             }            }             if(index == str.length())             return true;           }          }      }      }    return false;   }   int main(){  vector > v;   for(int i=0;i<4;i++){   vector temp;   for(int j=0;j<4;j++){    char x;    cin>>x;    temp.push_back(x);   }   v.push_back(temp);  }   int n;  do{   string str;   cin>>str;    if(check(v,str))    cout<<\"This word is in board\"<  else    cout<<\"This word is not in board\"< }while(1);  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This problem can be solved using recursion. For each a[i][j] check if a[i][j] == word[k] if(yes) { go to eight neighbors and check if any of them is equal word[k+1]  } else {  return false; } Additionally keep track of the visited elements to avoid faulting results"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ruby implementation:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"C# - iI think is the most efficient way:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static boolean scan(String wordToCheck) { \n     boolean flag = true; \n     int count = 0; \n     for (char character: wordToCheck.toCharArray()) { \n         for (int j=0; j<4; j++) { \n             for (int k=0; k<4; k++) { \n                 if (array[j][k] == character) { \n                  count++; \n                  if (count == wordToCheck.length()) {return true;} \n                 } \n             } \n         }   \n     } \n     return false; \n }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15974664","download_status":"DOWNLOAD_DONE","votes":"3","answersCount":"23","title":"Given a set of 2D points, some integer k, find the k points closest to the origin, (0,0).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"In fact you don't need a heap or a binary search tree here, because all the array is already loaded into memory. So you can use some modification of Quick-Select algorithm, to achieve O(n) speed and O(1) extra-memory (because tail recursion can be effectively eliminated) in case you don't need your initial array later on  See wikipedia for \"Selection_algorithm\" and \"Partial_sorting\"  Actually, one would need a heap, if 1) points are not yet loaded, and you receive them one-by-one (i.e. it's not a set of points, but a stream) 2) or maybe you are out of memory, and you have to preserve the initial array (quickselect-based algoritm would modify it) - then you can use heap with O(k) memory instead of O(n) copy of array  So here is my C++ solution of finding k largest nums in the array - one can easily modify it to work with points and distances. To eliminate worst case one should also randomize selecting pivot"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Build a max heap of first k elements. Now for every element left, check if it is smaller than the root of max heap. If it is, then replace the root and call heapify. Do it till the end  Time complexity : klogk"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Wouldnt it be O(n logk)?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A classic kd tree problem in finding 'n' nearest neighbours for a given 2D point. Check this link : en.wikipedia.org/wiki/K-d_tree#Nearest_neighbour_search"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can get linear time by using selection rank and then returning the first k elements.  Essentially we find a pivot, shift larger items to the right, smaller or equal items to the left.  If the final position of our pivot point is k then we're done, if our pivot is greater than k then we repeat to the left otherwise we repeat to the right.  Finally copy and return the first k elements.  O(n) time complexity since the first partition will cost n, subsequent partitions will (on the average case) be half of the previous partition (the randomized selection of the pivot point locks in the expected time), so O(n) + O(n/2) + O(n/4)... then one final O(k) to copy the k items for a total of O(n) time.  This solution assumes you can modify the input array, if you can't you could copy it initially and bump up the space complexity to O(n) but the algorithm would still be linear."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// this is max heap problem \n#include  \n#include  \n#include  \n#include  \n#include  \n#include  \n \nusing namespace std; \n \nstruct point{ \n int x; \n int y; \n double dist; \n }; \n \nbool operator<(const point& a, const point& b) { \n  return a.dist > b.dist; \n} \n \nint main(){ \n  \n priority_queue pq; \n int n; \n cin>>n; \n \n vector v; \n \n for(int i=0;i>xco>>yco; \n  p.x = xco; \n  p.y = yco; \n  p.dist = sqrt((xco*xco)+(yco*yco)); \n  v.push_back(p); \n  } \n    \n int k; \n cin>>k; \n \n for(int i=0;i v[i].dist){ \n   pq.pop(); \n   pq.push(v[i]); \n   } \n  } \n \n  \n while(!pq.empty()){ \n  point temp = pq.top(); \n  pq.pop(); \n   \n  cout<<<\" \"<<<\" \"<<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Max(klogk , (n-k)logk)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@interface KTPoint : NSObject \n@property (nonatomic, assign) float x; \n@property (nonatomic, assign) float y; \n@property (nonatomic, assign) float distance; \n@end \n \n@implementation KTPoint \n \n- (NSString *)description \n{ \n    return [NSString stringWithFormat:@\"x:%f y:%f distance:%f\",self.x,self.y,self.distance]; \n} \n@end"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This question tells - given the set of points meaning the points are already available and also it says find the first K points and not Kth point closest to 0,0. My approach to this is to calculate the distances of every point to the 0,0 by creating distanceSquared array. Then this array gets sorted by distance from 0,0 by using quick sort algorithm O(n log n). As a result first K points are printed out. Space complexity is O(2n) and time complexity is O(2n log n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"- (NSArray *)closeToOriginPoints:(NSArray *)points forK:(int)k { \n    [points sortedArrayUsingComparator:^NSComparisonResult(id obj1, id obj2) { \n        CGPoint p1 = ((NSValue *)obj1).CGPointValue; \n        CGPoint p2 = ((NSValue *)obj2).CGPointValue; \n         \n        float dist1 = sqrt(p1.x*p1.x + p1.y*p1.y); \n        float dist2 = sqrt(p2.x*p2.x + p2.y*p2.y); \n         \n        return (dist1 > dist2) ? NSOrderedDescending : (dist1 == dist2) ? NSOrderedSame : NSOrderedAscending; \n     \n    return [points objectsAtIndexes:[NSIndexSet indexSetWithIndexesInRange:NSMakeRange(0, k)]]; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Likewise, std::algorithm's partial_sort works too here."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What about this solution in python?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15944701","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"14","title":"Implement this Java function:  int findNeedleInHaystack(String haystack, String needle)  If needle is a substring of haystack, it should return the index of needle.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Did they want some optimized solution (KMP/Rabin-Karp/FA)? Or you could just use a naive approach?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int findSubstring(String haystack, String needle) \n{ \n  if(haystack.contains(needle)) \n    return haystack.indexOf(needle); \n  else \n    return -1; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"KMP"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"kmp"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Discussions around string search algos like KMP or Boyer Moore is what should be done."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why people only know KMP? Boyer Moore is used much more in practice."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  #include  #include  #include   using namespace std;   vector prefixtable(string p){  vector temp;   int i=1,j=0;   while(i  if(p[i] == p[j]){    temp.push_back(j+1);    i++;    j++;    }   else if(j>0){    j = temp[j-1];    }   else{    temp.push_back(0);    i++;       }   }   return temp; }   int kmp(vector temp,string s,string p){  int i=0,j=0;   while(i  if(s[i] == p[j]){    if( j == p.length()-1)     return (i-j);    else{     i++;     j++;       }       }   else if(j > 0){    j = temp[j-1];    }   else{    i++;       }              }  return -1;  }   int main(){  string s,p;  cin>>s>>p;  vector prefix = prefixtable(p);   // for(int i=0;i//  cout<//  cout< cout< return 0;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"yay"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class NeedleInHaystack {  \n    private static String  substractString (String source,int pos1, int pos2) \n    { \n        String ret=\"\"; \n        for (int i=pos1;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"KMP"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* \n        Implement indexOf function to find a substring from a given string \n        So, implement indexOf(String str) from index 0 \n \n        Can use KMP as well for O(n) time complexity... \n       \n        Salesforce interview question \n        Facebook question \"find needle in haystack\" \n     */ \n    public static int indexOf(String str, String substring) \n    { \n        char[] strArray = str.toCharArray(); \n        char[] subArray = substring.toCharArray(); \n        char first  = subArray[0]; \n \n        int max = (strArray.length - subArray.length); \n \n        for (int i = 0; i <= max; i++) { \n               /* Look for first character of the substring in the original. */ \n            if (strArray[i] != first) { \n                while (++i <= max && strArray[i] != first); \n            } \n            /* Found first character (i is now at the start of substring in original string), now look at the rest of v2 \n             * to make sure the whole substring is in the string */ \n \n            if (i <= max) { \n                int j = i + 1; \n                int end = j + subArray.length - 1; //the end index of the substring in the original string \n                for (int k = 1; j < end && strArray[j] == subArray[k]; j++, k++); \n                if (j == end) { \n                    /* Found whole string. */ \n                    return i; \n                } \n            } \n \n        } \n        return -1; \n    }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16239684","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"31","title":"Write a function that takes a string and returns true if the entire string is a palindrome, otherwise return false. The function should be case-insensitive and ignore any whitespace or punctuation.  For example, return true for: \"A man, a plan, a canal: Panama.\"","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"1> Setup two pointers Left and Right to the start/end of the string. 2> If Left is white space or punctuation char,  move Left to another non whitespace and non punctuation char Left to it unless end of string. If Right is white space or punctuation char, move Right to the another non white space and non punctuation char Right to it unless start of string. If Left>=Right, return TRUE. (Either all are whitespace or punctuation key or only one non whitespace and punctuation key). 3>  Other compare LOWERCASE(*Left) and LOWERCASE(*Right), if they are the same, go to 2>. Otherwise return FALSE."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Function Call :  isPalandrome(str.toLowerCase()"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Set; \nimport java.util.HashSet; \nimport java.util.Arrays; \n \npublic class Palin { \n \n  public static void main(String args[]) { \n String original = \"A man, a plan, a canal: Panama.\"; \n String c1 = \"\", c2 = \"\"; \n \n Set set = new HashSet(Arrays.asList('.', ';', ' ', ',', ':')); \n \n for (char c : original.toLowerCase().toCharArray()) { \n    if (set.contains(c)) continue; \n    c1 = c1 + c; \n    c2 = c + c2; \n        } \n \n System.out.println(c1); \n System.out.println(c2); \n \n System.out.println(c1.equals(c2)); \n  } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Set; \nimport java.util.HashSet; \nimport java.util.Arrays; \n \nclass Palindrome { \n public static void main(String args[]) { \n \n  String string = \"A man, a plan, a canal: Panama.\"; \n  String str = string.toLowerCase(); \n \n  int start = 0; \n  int end  = str.length() - 1; \n \n  Set set = new HashSet(Arrays.asList('.', ';', ' ', ',', ':')); \n \n  while (start < end) {  \n   char cStart = str.charAt(start); \n   char cEnd = str.charAt(end); \n   if (set.contains(cStart)) {  \n    start++; \n    continue; \n   } \n   if (set.contains(cEnd))  { \n    end--; \n    continue; \n   }  \n   if (cStart != cEnd)  \n    break; \n   start++; \n   end--; \n  } \n  \n  if (start < end)  \n   System.out.println(\"String is not palindrom\"); \n  else  \n   System.out.println(\"String is palindrom\"); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \nint strlen(char *p) \n{ \n int len=0; \n  while(*p++!='\\0') \n    len++; \n  return(len); \n} \n    \nint main() \n{ \n int strlen(char* p); \n    \n int i,len; \n char str[50]; \n // two ptrs to point for beg & end of string str \n char *f,*s; \n  \n //read string -- a line of text \n puts(\"enter a line : \"); \n gets(str); \n  \n //display given line \n puts(\"\\ngiven line is : \"); \n puts(str); \n  \n len=strlen(str); \n printf(\"\\nline length is : %d \\n\",len); \n  \n f=str; \n s=&str[len-1]; \n  \n //checking for palindrome \n for(i=0;i<(len/2);i++) \n {   \n  // check for 1st ptr value is a char or not \n if(((((int)*f>=65)&&(int)*f<=90)||((int)*f>=90&&(int)*f<=122))) \n { \n  // check for 2nd ptr value is a char or not \n   if((((int)*s>=65&&(int)*s<=90)||((int)*s>=90&&(int)*s<=122))) \n  { \n    // compare both char values \n      if(!(*f=*s||*f==*s+32||*f==*s-32||*f+32==*s||*f-32==*s)) \n    { \n    printf(\"false--not palindrome\\n\"); \n    exit(1); \n    } \n   else \n    { \n    // both chars are same , so increment 1st ptr & decrement 2nd ptr \n    f++; \n    s--; \n    }   \n      } \n      else \n       {  \n   // 1st val is char but 2nd val is not a char \n   // so decrement one addresss of 2nd ptr \n   s--; \n    }     \n    } \n    else   \n    { \n  // 1st ptr is not a char so check for 2nd val is char or not \n  if(((int)*s>=65&&(int)*s<=90)||((int)*s>=90&&(int)*s<=122)) \n  { \n   // 1st val is not a char  & 2nd val is a char \n               f++; \n        } \n       else \n       { \n     // 1st val & 2nd val both r not chars \n      f++; \n      s--; \n    } \n }         \n   \n } // end of for  \n printf(\"true--given string is a palindrome\\n\"); \n    \n return(0); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"boolean palindrome?(String s) \n{ \n \nif (s==Null) \n return False; \nint strLen = s.length(); \n \n// Return true if given string is one charachter long \nif (strLen==1) \n return True; \n \n \n// delete all char beyond ascii of a-z \ns.sanitize(); \n//convert all char to lower case \ns.tolowercase(); \n \nint leftPtr =0; \nint rghtPtr =0; \n \nif(strLen%2==0) \n{ \n leftPtr=strLen/2 - 1; \n rghtPtr= leftPtr + 1; \n} \nelse  \n{ \n leftPtr=strLen/2 - 1; \n rghtPtr= leftPtr + 2; \n} \n \nwhile(leftPtr <= 0 && rghtPtr > strLen) \n{ \n if(s[leftPtr].equals(s[rghtPtr])) \n   { \n  leftPtr--; \n  rghtPtr++; \n } \n else  \n return False; \n} \nreturn True; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def is_palindrome(string): \n     if not string: \n         return false \n     black_list = [\",\", \".\", \":\", \" \", \";\"] \n     for c in black_list: \n         string = \"\".join(string.split(c)) \n     string = string.lower() \n     return string==string[::-1]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static boolean isPalindrom(String originalString, Set ignoreCharacters){ \n  String manipulatedString = removeSpecialCharacters(originalString.toString().toLowerCase(), ignoreCharacters); \n  int length = manipulatedString.length(); \n  int traverseIndex = length/2 ; \n   \n  for ( int startIndex = 0; startIndex < traverseIndex ; startIndex ++){ \n   char char1 = manipulatedString.charAt(startIndex); \n   char char2 = manipulatedString.charAt( (length -1) - startIndex ); \n   if ( char1 != char2 ){ \n    return false; \n   } \n  } \n   \n  return true; \n   \n } \n  \n private static String removeSpecialCharacters(String orginalString, Set ignoreCharacters){ \n  int length = orginalString.length();   \n  StringBuilder tagettedString = new StringBuilder(); \n  for ( int startIndex = 0; startIndex < length ; startIndex ++){ \n   char ch = orginalString.charAt(startIndex);  \n   if (!ignoreCharacters.contains(ch)){ \n    tagettedString.append(ch); \n   } \n  }   \n  return tagettedString.toString(); \n   \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What about this one? For Javascript."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a recursive solution to the problem:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Palindrome { \n \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n \n  String str = \"A man, a plan, a canal: Panama.\"; \n \n  StringBuilder sb = new StringBuilder(); \n  char c; \n \n  for (int i = 0; i < str.length(); i++) { \n   c = str.charAt(i); \n   if (c == ':' | c == ',' | c == ' ' | c == '.') \n    continue; \n   sb.append(c); \n  } \n  str = sb.toString().toLowerCase(); \n \n  int length = str.length(); \n  for (int i = 0; i < length; i++) { \n \n   if (str.charAt(i) == str.charAt(length - i - 1)) \n    continue; \n   else { \n    System.out.println(\"Not a Palindrome\"); \n    length = -1; \n    break; \n   } \n  } \n \n  if (length != -1) \n   System.out.println(\"Hope this is a palindrome\"); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static boolean isPalindrome(String stext){ \n   char [] chs=stext.toCharArray(); \n   int i=0; \n   int j=chs.length-1; \n   boolean found=false; \n   for (;i='a'&&ch<='z')||(ch>='A'&&ch<='Z')){ \n   return true; \n  } \n   \n  return false;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A one liner ruby code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Split the string in half, or into even parts ignoring the middle character if the length is odd. Then push the first half onto a stack, ignoring whitespace/punctuation. Then pop the stack and test against every character in the second half, again ignoring whitespace/punctuation. If there is mismatch return false."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool isValid(char c) { \n    return c >= 'a' && c <= 'z' && c >= 'A' && c <= 'Z'; \n} \nbool isPal(string s) { \n    int len = s.length(); \n    int l = 0, r = len - 1; \n    while (l <= r) { \n        while (l + 1 <= r && !isValid(s[l])) { \n            l++; \n        } \n        while (r - 1 >= l && !isValid(s[r])) { \n            r--; \n        } \n        if (!isValid(s[l]) ^ !isValid(s[r])) { \n            return false; \n        } \n        if (isValid(s[l]) && isValid(s[r])) { \n            if (s[l] != s[r]) return false; \n        } \n        l++; \n        r--; \n    } \n    return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"2 lines"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The following is written in Objective-C"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This code will be ok."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16097677","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"10","title":"Given a stock prices 20,50,52,10,45,34 and each day the stock price will buy and sold in another n days.Calculate which day the maximum profit will get.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Keep track of minimum from left to right and take the difference with the current stock[i]. If it is greater than maxprofit, then update the maxprofit. Repeat it with all the stock values while going from left to right."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Could you clarify your question please?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This question was a little hard to read. The question does say the stock is sold n days after the stocks is purchased. So you need to keep track of a running max that is price[today] - price[n days later]  Here is a solution in php:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"pair bestbuyoutprice(int A[], int size, int &maxprofit) \n{ \n int min = A[0]; \n int tempmin = min; \n int max = A[0]; \n int currentprofit = 0; \n maxprofit = 0; \n for (int i = 0; i < size; i++) \n { \n  if (A[i] < min) \n  { \n   tempmin = A[i]; \n   currentprofit = 0; \n  } \n  else \n  { \n   currentprofit = A[i] - tempmin; \n   if (currentprofit > maxprofit) \n   { \n    maxprofit = currentprofit; \n    max = A[i]; \n    min = tempmin; \n   } \n  } \n } \n return make_pair(min,max); \n} \nvoid main (int argc, char** argv) \n{ \n int A[] = {20,50,52,10,45,34, 5}; \n int size = sizeof(A)/sizeof(int); \n int profit; \n pair res = bestbuyoutprice(A, size, profit); \n \n for ( int i = 0; i < size; i++) \n  cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static int[] profits = null;         private static bool[] calculated = null;         public static int CalculateProfit(int []prices, int index, int []profits)         {             if (prices.Length - index <= 1 ) return 0;             int curPrice = prices[index];             int maxValue = 0; int value=0;             for (int i = index + 1; i < prices.Length; ++i)             {                  value =  prices[i] - curPrice;                 if (i + 1 != prices.Length && !calculated[i+1])                 {                     profits[i+1] = CalculateProfit(prices, i+1, profits);                     value = value + profits[i + 1];                 }                  if(value> maxValue)                     maxValue =value;             }             if (profits[index + 1] > maxValue)                 maxValue = profits[index + 1];             return maxValue;         }          static void Main(string[] args)         {             // 20, 50, 52,             int[] prices = new int[] { 20, 50, 52,  10, 45, 35 ,36, 45};             profits = new int[prices.Length];             calculated = new bool[prices.Length];             int value = CalculateProfit(prices, 0, profits);             Console.WriteLine(\"Value:\"+value);         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi, it has been some time already, but you may find exactly the same problem in the Cormen's famous book, where he simplifies the problem to finding maximum sum, by converting the stock values to it's day to to day changes."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def computeMaxProfitBuySell(ll=None): \n    lst = ll or [20,50,52,10,45,34] \n    maxProfit = 0 \n    i=0 \n    for j in xrange(1,len(lst)): \n        print maxProfit, i,j \n        if lst[i] < lst[j]: \n            profit = lst[j] - lst[i] \n            if profit > maxProfit: \n                maxProfit = profit \n        else: \n            #lst[i] < lst[j], so bring i to j \n            i=j \n     \n    return maxProfit \n \nprint computeMaxProfitBuySell()"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16012676","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"How would you implement call for canceling queued blocks with dispatch_after?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There's no technique to cancel blocks which were defined within a dispatch_after call. There's no handle or reference to them."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15842672","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"How will you describe iOS manual memory management for a new developer in few words?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Objective-C provides two methods of application memory management. a) ??Manual retain-release??? or MRR : Here you explicitly manage memory by keeping track of objects you own. This is implemented using a model, known as reference counting, that the Foundation class NSObject provides in conjunction with the runtime environment. b) Automatic Reference Counting, or ARC: Here, the system uses the same reference counting system as MRR, but it inserts the appropriate memory management method calls for you at compile-time. You are strongly encouraged to use ARC for new projects."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15886680","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"24","title":"Write a program to print the powerset. E.g. given this set {1,2,3}, it will print {},{1},{2},{3},{1,2},{1,3}, {2,3}, {1,2,3}","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"You can use bit operators, here is how I would do it:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"#include  \n#include  \n#include  \n \nusing namespace std; \n \nvoid PrintVariant(vector& v, vector& vb, int idx) \n{ \n        if (idx<0) { \n                cout<< \"{\"; \n                for (int i=0; i& v) \n{ \n        vector vb(v.size(), true); \n        PrintVariant(v, vb, v.size()-1); \n} \n \nint main(int argc, char** argv) \n{ \n        int a[] = {1, 2, 3}; \n        vector v (a, a+(sizeof(a)/sizeof(int))); \n \n        cout << \"Input is : \"; \n        for (int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Python Power Set.  This basically does binary counting to mutate a list of True/False values that determine which elements get included in the next subset."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can go the binary way....start with the number 7, = 2^3 - 1   go on subtracting 1, and count the position of 1's in the binary number ...map to digits and u haev the set."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.*; public class Powerset {   public static void main(String[] args) {   int ar[]=new int[10];   int n;   Scanner sc=new Scanner(System.in);   System.out.println(\"enrter the length of the set\");   n=sc.nextInt();   System.out.println(\"enter the set elements\");   for(int a=0;a  ar[a]=sc.nextInt();   System.out.print(\"{\"+0+\"} \");   int nn=n;   //int x=0;   for(int i=0;i  {          int j=0;      for(int p=0;p     {       System.out.print(\"{\");       int y=0;       for(;y      {        System.out.print(ar[y]+\",\");       }       j=y+p;       System.out.print(ar[j]);       System.out.print(\"} \");      }      nn--;   }   System.out.print(\"{\");   for(int l=0;l   System.out.print(ar[l]+\",\");   System.out.print(\"}\");   }  } sample o/p:enrter the length of the set 5 enter the set elements 1 2 3 4 5 {0} {1} {2} {3} {4} {5} {1,2} {1,3} {1,4} {1,5} {1,2,3} {1,2,4} {1,2,5} {1,2,3,4} {1,2,3,5} {1,2,3,4,5,}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"are there any duplicates in the set?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This could be done using combinations, here is JS code (run it in nodejs):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void printsubset(int*arr,int*aux,int start,int depth,int n) { if(start<=n)     { for(int i=0;i          cout<        cout<<\"\\n\";     }  for(int j=start;j<=n;j++)    { aux[depth]=arr[j];     printsubset(arr,aux,start+1,depth+1,n);      start++;   } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think it may work but it wont produce the o/p in given order.........  #include #include  int n,a[10],b[10];  void display(int k) {  cout<<\"{\";  for(int i=0;i cout< cout<<\"\\b},\"; }  void func(int i,int j,int k,int m) {   b[m]=a[j];  display(k);   for(;j {   func(i,j+1,k+1,m+1);  } }  void main() {  int i,j,k;   clrscr();   cout<<\"Number of trems\";  cin>>n;   for(i=0;i cin>>a[i];   for(i=0;i {   for(j=i+1;j  if(a[i]>a[j])   {    a[i]=a[i]+a[j];    a[j]=a[i]-a[j];    a[i]=a[i]-a[j];   }  }    for(i=0;i {   func(i,i,1,0);  }  getch(); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution in Javascript. The idea is to iteratively fetch an object and combine it with all the sets that are already in the superset being created:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include    typedef int bool; #define true 1 #define false 0   void genpowset(bool *check, int i, int N, int *arr) {     int j;     if (i == N)     {         printf(\"{\");         for (j=0;j        {             if (check[j])             printf(\"%d\",arr[j]);         }         printf(\"}\\n\");     }       if (i < (N))     {         check[i] = true;      genpowset(check,i+1,N,arr);      check[i] = false;      genpowset(check,i+1,N,arr);         }   }   main () {     int N, i;     scanf(\"%d\",&N);     int arr[N];     bool checkArr[N];     for(i=0;i    scanf(\"%d\",&arr[i]);     genpowset(checkArr,0,N,arr); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"python!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Recursive solution in C#."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":">>> for i in range(1,8):  new=[]  while (i >1):   new.append(i%2)   i=int(i/2)  if i ==1:   new.append(i)  if len(new)==1:   new.append(0)   new.append(0)  if len(new)==2:   new.append(0)  new.reverse()  #print new  new1=[]  for m in range(len(new)):   if new[m]<>0:    new1.append(list[m])  print new1    ['3'] ['2'] ['2', '3'] ['1'] ['1', '3'] ['1', '2'] ['1', '2', '3']"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the simple solution in PHP:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15888677","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"12","title":"Write a program to clone a graph","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"BFS or DFS traversal would work,and we can use hash table to deal with cycles. below is the DFS code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"We need to use a hash table which will take input as node of input graph and give output as node of new graph, if there is an input node that is not yet mapped then we need to allocate new node and insert that mapping into hash table."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"digraph or directed ; positive or negative weighted graph ; any  cycles( particulary negative) ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It was for a directed graph with cycles"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It was for a directed graph with cycles E.g. If we have a graph like A->B->C->D->B the cloning algorithm will produce A'->B'->C'->D'->B'"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why don't you simply traverse the graph using dfs with standard coloring scheme to mark visited nodes? That should deal with cycles too."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"As we copy a node, we insert it into the table. If we later find that one of a node??s neighbor is already in the table, we do not make a copy of that neighbor, but to push its neighbor??s copy to its copy instead. Therefore, the hash table would need to store a mapping of key-value pairs, where the key is a node in the original graph and its value is the node??s copy."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my Java code. DFS search, storing visiting nodes in a HashMap. Nodes must be labeled for the hash to work.  Complexity is O(|V| + |E|)  Usage:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You don't need to do any traversal. Just get the object structure which represents the graph (usually a  list of vertex) and clone it. No need to put special attention to cycles etc."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Everyone here is talking about the linked list implementation of graph. How would the solution change for adjacency matrix representation of the graph? I believe just returning a copy of adjacency matrix should do it."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15645665","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"48","title":"Find the k'th largest element in a binary search tree. Write code for","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"Traverse in reverse in-order (i.e. descending order).    Something like this (quick code without thinking, so bugs will be there)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"struct Node { \n    int val; \n    struct Node *left; \n    struct Node *right; \n} Node; \n \nstruct Node * kth_largest(struct Node *root, unsigned int k); \n{ \n if( ! root ) \n  return NULL; \n int pos = 0; \n return kth_largest_helper(root, k, &pos); \n} \n \n/*  \n   Help find the kth_largest by comparing the rank of root from  \n   the largest/rightmost node in the BST. \n*/ \nstruct Node *kth_largest_helper(struct Node *root, unsigned int k , int *rank) \n{ \n if( ! root ) \n  return root; \n \n struct Node *temp = NULL ; \n if( root-> right ) \n { \n  /* we have not seen the rightmost node yet => rank ordering has not started */ \n  temp = kth_largest_helper(root->right, k, rank); \n  \n  if ( temp ) \n   return temp; \n } \n (*rank)++; // increment position rank \n  \n if( *rank == k ) \n  return root; // kth element \n \n return root->left ? kth_largest_helper(root->left, k, rank) : temp; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"void kthlargest(struct Node *node,int k,int &index,int &res) {  if(!node || index>k)   return;  kthlargest(node->right,k,index,res);  index++;  if(k==index)  {   res=node->data;  }  kthlargest(node->left,k,index,res); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"My solution in Java. I created a class K to hold k since an int will not work with recursion.  Like the solutions above, it performs a reverse in-order traversal."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"traverse inorder, return the kth node traversed"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  #include   typedef struct tree  {  int data;  struct tree* left;  struct tree* right; }TREE;   TREE* createNode(int x) {  TREE *ptr;  ptr=(TREE*)malloc(sizeof(TREE));  ptr->data=x;  ptr->left=NULL;  ptr->right=NULL;  return ptr; }        void kthLargest(TREE *root,int *kth,int k) {  static int counter=0;   if(root==NULL)   return;   else   {                  kthLargest(root->left,kth,k);      counter=counter+1;      if(k==counter)    {     *kth=root->data;     return;         }          printf(\"%d\",counter);      kthLargest(root->right,kth,k);        }       } int getCount(TREE *ptr) {  if(ptr==NULL)  return 0;  else  return 1+getCount(ptr->left)+getCount(ptr->right);   }  TREE *root; void initialize() {   root=NULL; }  int main() {    initialize();  root=createNode(8);  root->left=createNode(6);  root->right=createNode(11);  root->left->left=createNode(5);  root->left->right=createNode(7);  root->left->left->left=createNode(4);  root->right->left=createNode(10);  root->right->right=createNode(13);  int kth,k;  k=5;  kth=0;  kthLargest(root,&kth,getCount(root)-k+1);  printf(\"\\n the kth largest number =%d\",kth);     return 0;    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"traverse the tree in inorder try to find kth_temp element which is equal to kth_temp=number of nodes - (k-1). Suppose taking above comment example kth_temp = 8(num of nodes)-(2(k)-1)=7th. and 7th element is 99 that is the answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) count the total number of nodes in the BST,one pass traversal,time cost:O(n) 2) traverse inorder, the (n-k+1)-th smallest node is the answer,time cost:O(n) below are the C++ code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node iterativeInorderForKthLargest(Node root, int k) { \n Stack s = new Stack(); \n s.push(new NodeWatchedCount(root, 1)); \n int currentLargest = 0; \n while(!s.isEmpty()) { \n  NodeWatchedCount n = s.pop(); \n  if(n.count == 2) { \n   currentLargest++; \n   if(currentLargest == k) { \n    return n.node; \n   } \n   s.push(new NodeWatchedCount(n.node.right, 1)); \n  } else { \n   n.count = 2; \n   s.push(n); \n   s.push(n.left); \n  } \n } \n} \n \nNodeWatchedCount { \n int count; \n Node node; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if k < n/2 then it will be in right subtree else it'll be in right subtree halve the limit and repeat until there is only 1 element between previous iteration and current iteration which will be the kth largest number  O(log(n))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"right, root, left traversal"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hello, I have a inorder method to solve this problem. I used showell30@yahoo.com's code to create the BST, thanks."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"As everybody has figured out we can solve it in O(n) using inorder:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution in C:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java version:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/// Using Some Method Like mid-order Trans"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A solution using Inorder iterator, and call Next() k times."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The famous algorithms book -- \"Introduction to Algorithms\" actually contains a solution to the problem. It's idea is to first find the minimum node of the tree, and then traverse from it and find its kth SUCCESSOR.  Please check out the detials from 12.2-7, Chapter 12 of CLRS, Second edition."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node *find_k_largest_node(Node *n, int k) {  stack s;  bool done = false;   while (!done) {   if (n) {    s.push(n);    n = n->left;   }   else {    if (s.empty()) {     done = true;    }    else {     n = s.top();     s.pop();      k--;      if (k == 0) {      return n;     }      n = n->right;    }   }  }   return NULL; }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15503949","download_status":"DOWNLOAD_DONE","votes":"4","answersCount":"35","title":"Given a function KNOWS(A,B), which returns 1 if A knows B (and not necessarily the other way around) and 0 if A does not know B.  A Celebrity is one who does not know anyone, and one who is known by everybody.  For a list of N people, find all celebrities in linear time.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"21","title":"There can be at most one celebrity.  Suppose A and B are both celebrities.  A knows B by virtue of B's celebrity.  But then A can't be a celebrity, by virtue of the rule that celebrities can't know anyone.  Given that you have only celebrity, you can use a linear algorithm.  Start with person 1, and they're the provisional celebrity.  With person 2, see if either 2 doesn't know 1 or 1 knows 2, and if so, 1 is no longer a celebrity, and swap 1 and 2.  For each new person, try to see if you can eliminate the celebrity's status with two simple checks, and then swap as needed.  After the first linear pass, you'll have a provisional celebrity, and then take another linear pass to verify that he really is a celebrity.  If there are no celebrities, then the second pass will be terminate fairly quickly."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@Showell  nice answer. but at the first glance of the question, I was thinking about KNOWS(A,B) as some kind of comparative function, which can be used in sorting. and once we sort the list we would get the celebrities at one end, ofcourse there is no comparitive sort which can perform in linear time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"given a and b : check Knows(a,b) and Knows(b,a). If both result match eliminate both a and b to move forward as none are celebrity candidate , if only one is true say Knows(a,b) then eliminate a , b is still a candidate. get the next person in the list . On each step you exhaust at least one and hence linear time"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I too tried something on it.  Please let me know for impvements.  My thought of doing it is as follows: 1. Assume list is {A,B,C,D,E} and i=0,j=1 initially. Since only one celebrity or none exists, start with first two elements in list. 2. If knows() returns true, change i,j to j,j+1 else i,j+1. 3. Once j reaches last position, it means either i or j can be celebrities. So check which one is celebrity using normal for loop. It returns position of celebrity in list. It visits each element for 2 times hence O(2N)=O(N)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"geeksforgeeks . org  /the-celebrity-problem/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"idk dude"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Code in C#."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This problem is similar to finding a universal sink in a graph in linear time. If A knows B then there is a edge between node A and node B.  Universal Sink is then a node with all incoming edges and no outgoing edges  You can also find the universal sink problem in Cormen et al and its solution in its solution manual."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if cur don't know next one means:  next one is not celebrity so i++; if cur know next one means: cur is not celebrity so cur = i; the people between i and cur don't known by cur so they are all not celebrity."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sorry the last line should be return arr[cur]; if cur don't know next one means:  next one is not celebrity so i++; if cur know next one means: cur is not celebrity so cur = i; the people between i and cur don't known by cur so they are all not celebrity."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"compare in pairs.. if a knows b and b doesnt know a, b is celebrity. viceversa. if both dont know each other, both celebrity.  in one loop.. check i and i+1, put all celebrities in array as u find it.."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15501978","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"12","title":"Describe the actions performed by two functions: Publish(user, msg) - publishes a new post on behalf of 'user' GetNewsFeed(user) - gathers 30 posts from 'user's friends to show on his/her news feed.  I was asked to map out the relations required for holding large amounts of data.  As a followup, I had to calculate the number of machines facebook would have to initially buy to start off using this news feed.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Guess this fits into publish subscribe model - Observer design pattern  1. Each user owns his/her data in his/her user area (data structure). Can be"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15538686","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"15","title":"Convert a string of Roman numerals to an integer in O(n) time","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"#include  \n#include  \n \nusing namespace std; \n \nint Roman2Num(string &a){ \n int sum = 0; \n int cur = 1001; \n int pre = 0; \n for (int i = 0; i> a; \n cout << Roman2Num(a) << endl; \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"int Roman2Int(string s)  \n{ \n if(s.length()==0)return 0; \n unordered_map table; \n table['I'] = 1; \n table['V'] = 5; \n table['X'] = 10; \n table['L'] = 50; \n table['C'] = 100; \n table['D'] = 500; \n table['M'] = 1000; \n int ans = table[s[s.length()-1]]; \n for(int i=s.length()-2;i>=0;i--) \n { \n  if(table[s[i]] < table[s[i+1]]) \n   ans -= table[s[i]]; \n  else \n   ans += table[s[i]]; \n } \n return ans; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"O(k) space O(n) time"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Javascript solution inspired by @showell30 comment:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Your code doesn't work for some cases. eg, III =3; but your code will produce 1 as the answer. Like @showell30 said, you have to process the string right to left."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static int Convert(string s) { \n            Dictionary map = new Dictionary(); \n            map.Add('I', 1); \n            map.Add('V', 5); \n            map.Add('X', 10); \n            map.Add('L', 50); \n            map.Add('C', 100); \n            map.Add('D', 500); \n            map.Add('M', 1000); \n \n            int total = 0; \n            int previous = map[s[0]]; \n \n            for (int i = 0; i < s.Length; i++) { \n                if (previous >= map[s[i]]) \n                { \n                    total = total + map[s[i]]; \n                } \n                else { \n                    total = total + map[s[i]] - 2 * previous; \n                } \n                previous = map[s[i]]; \n            } \n            return total; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static int Convert(string s) { \n            Dictionary map = new Dictionary(); \n            map.Add('I', 1); \n            map.Add('V', 5); \n            map.Add('X', 10); \n            map.Add('L', 50); \n            map.Add('C', 100); \n            map.Add('D', 500); \n            map.Add('M', 1000); \n \n            int total = 0; \n            int previous = map[s[0]]; \n \n            for (int i = 0; i < s.Length; i++) { \n                if (previous >= map[s[i]]) \n                { \n                    total = total + map[s[i]]; \n                } \n                else { \n                    total = total + map[s[i]] - 2 * previous; \n                } \n                previous = map[s[i]]; \n            } \n            return total; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static int Convert(string s) { \n            Dictionary map = new Dictionary(); \n            map.Add('I', 1); \n            map.Add('V', 5); \n            map.Add('X', 10); \n            map.Add('L', 50); \n            map.Add('C', 100); \n            map.Add('D', 500); \n            map.Add('M', 1000); \n \n            int total = 0; \n            int previous = map[s[0]]; \n \n            for (int i = 0; i < s.Length; i++) { \n                if (previous >= map[s[i]]) \n                { \n                    total = total + map[s[i]]; \n                } \n                else { \n                    total = total + map[s[i]] - 2 * previous; \n                } \n                previous = map[s[i]]; \n            } \n            return total; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My attempt at it. Salient features of my solution: 1. I am using no auxiliary memory.  2. Code is more readable as I am only flipping signs for 2 cases.  3. I am scanning the string from left to right. Following is a C++ solution."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15501897","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"21","title":"This Question was asked in written round on one of the online coding round, The Question was to code this. Question is as follows.  You want to create a staff to use in your martial arts training, and it has to meet some specific requirements.      You want it to be composed of two smaller staves of equal length so that you can either use it as a single staff or as two smaller ones.      You want the full sized staff's center of gravity to be exactly in the middle of the staff.  You have a very, very long branch from which you can cut the pieces for your staff. The mass of the branch varies significantly throughout it, so you use just any two pieces of the same length. Given a description of the mass throughout the branch, determine the longest staff you can make, then return three integers on a single line, the first two indicating the first index of each half-staff, and the third indicating the length of each half-staff.  The input will be given on a single line as a string of digits [1-9], each digit representing the mass of a section of the branch. All sections are the same size and the maximum length of the string is 500. Here is an example:                         41111921111119                         11119   11119  If the indicated sections are cut from the branch they will satisfy your requirements. They are both the same length, and they can be put together as either 9111111119 or 1111991111, both of which have a center of gravity exactly in the center of the staff.  Center of gravity can be determined by taking a weighted average of the mass of each section of the staff. Given the following distances and masses: Distance: 12345678 Mass: 22241211  Sum of the mass of each section: 2 + 2 + 2 + 4 + 1 + 2 + 1 + 1 = 15 Weighted sum of the masses: 2*1 + 2*2 + 2*3 + 4*4 + 1*5 + 2*6 + 1*7 + 1*8 = 60 Weighted sum / regular sum = 60 / 15 = 4  This means that the center of mass is in section 4 of the staff. If we wanted to use this staff the center of gravity would need to be (8+1)/2 = 4.5.  Here is an example problem:  131251141231 ---- ----  If we take the sections indicated we get 1312 and 1231. By reversing the first one and putting them together we get 21311231  Sum of the mass of each section: 2 + 1 + 3 + 1 + 1 + 2 + 3 + 1 = 14 Weight sum of the masses: 2*1 + 1*2 + 3*3 + 1*4 + 1*5 + 2*6 + 3*7 + 1*8 = 63 Weighted sum / regular sum = 63 / 14 = 4.5  This puts the center of mass exactly in the center of the staff, for a perfectly balanced staff. There isn't a longer staff that can be made from this, so the answer to this problem is  0 8 4  Because the half-staves begin at indices 0 and 8 (in that order) and each is of length 4","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Maybe this, in Python:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This seems like an homework assignment, you cannot remember the whole question as is, as a matter of fact even if they ask you such a long question it will take at least 15-20 minutes to get it and then 20 minutes to design a solution and 20 minutes to code it, depends on your typing speed. Stop asking solutions for your assignments."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Make a 2D matrix of size n*n where n is length of string 2. fill matrix while matrix[i][j] has sum of all values from i to j. can be done in n2 using bottom up approach of dynamic programming 3. traverse matrix and put all values in hash table. while key is matrix[i][j] and value is (i,j). if already present, append new (i,j) (dont replace) 4. sort hash table key values from high to low 5. for each key in sorted hash key values, get hash value. 6. if hash value has 1 value go to next. else go to step 7 7. for each (i,j) pair, check if any pair exists such that (j1-i1)==(j2-i2) and they are not overlapping. if exists. return with this pair"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I didn't test this code, but it should be simple to understand. The question is really asking if there're two same sized continuous segments that has the same sum. so: 1. construct a table T[n/2][n] // longest segment is half the size 2. T[i][j] stores the weight of the segment starting at j, with size i 3. fill the table 4. searching from the last row (longest), if in the array T[i] there are two segment of the same weight, say T[i][k] and T[i][l], return k (first segment start), l (second segment start) and i (length).  Here's the code which I wrote without testing:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Move a summing box (window) throw the input digit array. Start with max possible window size=N/2 and decrement it on the next step."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15532723","download_status":"DOWNLOAD_DONE","votes":"4","answersCount":"29","title":"Given n, output the numbers from 0 to 2^n-1 (inclusive) in n-bit binary form, in such an order that adjacent numbers in the list differ by exactly 1 bit.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"10","title":"Just do a loop from 0 to 2^n-1 with the following.  unsigned int binaryToGray(unsigned int num) {         return (num >> 1) ^ num; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Gray code."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Here is a code which can achieve this (I think); some optimizations and cleaning are possible."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"How about this."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is an iterative version, (also added recursive version just for comparison) So, that is as optimal as it gets! in space and time"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static int next(int n, int i) \n { \n  int x = (n >> i) & 0b11; \n  switch (x) \n  { \n  case 0b00: x = 0b01; break; \n  case 0b01: x = 0b11; break; \n  case 0b11: x = 0b10; break; \n  case 0b10: x = 0b00; break; \n  } \n  n &= ~(0b11 << i); \n  n |= x << i; \n  return n; \n } \n  \n private static int grayCode(int n, int i, int base) \n { \n  if (i >= 2) \n  { \n   for (int j=0; j<4; ++j) \n   { \n    base = grayCode(n, i - 2, base); \n    base = next(base, i - 2); \n   } \n  } \n  else if (i == 0) \n  { \n   System.out.println(toBinaryString(base, n)); \n  } \n  else \n  { \n   System.out.println(toBinaryString(base, n)); \n   System.out.println(toBinaryString(base ^ 1, n)); \n  } \n  return base; \n } \n \n private static void grayCode(int n) \n { \n  grayCode(n, n, 0); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void printAdjacent(int n) \n{ \n if(n <= 0) \n { \n  std::cout << \"0\" << std::endl; \n } \n else \n { \n  std::vector nums = {0, 1}; \n  int x = 1; \n \n  while(x <= n) \n  { \n   std::reverse(nums.begin(), nums.end()); \n   for(int i = nums.size() - 1; i >= 0; i--) nums.push_back(std::pow(10, x) + nums[i]); \n   x++; \n  } \n \n  for(auto e : nums)  \n  { \n   std::cout << e << std::endl; \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Recursive solution in python"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"vector grayCode(int n) {         vector seq;         seq.push_back(0);         if (n == 0) return seq;         seq.push_back(1);                  for (int i = 1; i < n; i++) {             int size = seq.size();             for (int k = size-1; k >= 0; k--) {                 seq.push_back(seq[k] | (1 << i));             }         }                  return seq;             }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Something very interesting i came across:  wisc-online.com/ Objects/ ViewObject.aspx? ID=IAU8307"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"interesting read;  introcs.cs.princeton.edu / java/ 23recursion/ GrayCode.java.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the C# implementation of Gray Code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void printAllGrayCodes(int n) { \n \n  for (int num = 0; num < 1 << n; num++) { \n \n   int val = 0; \n   for (int i = n; i > 0; i--) { \n    int x = 0; \n    if (i == n) { \n     if (num >= Math.pow(2, n - 1)) \n      x = 1; \n    } else { \n     int modn = num % (int) Math.pow(2, i + 1); \n     if (modn >= Math.pow(2, i - 1) \n       && modn + Math.pow(2, i - 1) < Math.pow(2, i + 1)) \n      x = 1; \n    } \n    val |= (x << i - 1); \n   } \n   System.out.println(val); \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \n \nvoid print(std::vector const & number) \n{ \n   for (int i = number.size(); i > 0; --i) { \n      std::cout << (int)number[i-1]; \n   } \n   std::cout << std::endl; \n} \n \nvoid modify(std::vector & number, std::vector & base, std::vector const & cnt) \n{ \n   for (int i = 0; i < number.size(); ++i) { \n      --base[i]; \n      if (base[i] == 0) { \n         number[i] = number[i] ^ 1; \n         base[i] = cnt[i]; \n      } \n   } \n} \n \nvoid solve(int n) \n{ \n   std::vector number(n, false); \n \n   // idx:   3 2 1 0 \n   // cnt:  16 8 4 2 \n   // base:  8 4 2 1 \n    \n   std::vector base(n, 0); \n   std::vector cnt(n, 0); \n   for (int i = 0; i < base.size(); ++i) { \n      base[i] = 1 << i; \n      cnt[i] = 1 << (i+1); \n   } \n \n   long long total = (long long)1 << n; \n   // the loop condition can be changed so it breaks out when 0000...0000 appears after 'modify' call, in that case the \"n\" can be very large \n   // now it is limited to number of bits in long long - 1 \n   for (long long idx = 0; idx < total; ++idx) { \n      std::cout << std::setw(3) << idx << ' '; \n      print(number); \n      modify(number, base, cnt); \n   } \n} \n \nint main() \n{ \n   int n; \n   std::cin >> n; \n   solve(n); \n   return 0;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class GrayCode {   static char charArray[] = {'0','0','0','0'};    public static void main(String[] args) {   grayCode(4);  }   static void grayCode(int i){   if (i == 1){    System.out.println(charArray);    charArray[0] = (charArray[0] == '0'?'1':'0');    System.out.println(charArray);    return;   }   grayCode(i-1);   charArray[i-1] = (charArray[i-1] == '0'?'1':'0');   grayCode(i-1);  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void print(int n) { \n  int limit = 1 << n; \n  for (int i = 0; i < limit; i++) { \n   int x = i; \n   if(x == 0){ \n    System.out.print(x); \n   } \n   while(x > 0){ \n    System.out.print((x & 1)); \n    x = x >> 1; \n   } \n   System.out.println(\"\"); \n  } \n \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def recursive_solve(n): \n    if n == 1: \n        yield \"0\" \n        yield \"1\" \n    else: \n        sub_result = list(recursive_solve(n - 1)) \n        for n in sub_result: \n            yield \"0\" + n \n        for n in sub_result: \n            yield \"1\" + n[::-1]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"n=2: 00, 01, 11, 10 \n    n=3: 000, 001, 011, 010, 110, 111, 101, 100"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15468738","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"24","title":"Given an expression (in single variable) like 4x+13(x-(4x+x/3)) = 9, evaluate x The expression is a string and the variable is always x.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"note that equation is of the form y(x)=E[x]=mx+c now y(x)=0 => x=(-c/m) E[0]=c and m=E[1]-E[0] thus the required solution is  x = E[0]/(E[0]-E[1])  for arbitrary form of the expression we should use newton-raphson method, however for linear equation it is already simple enough!  now assume that we are given the expression in the form of a string  note that in the expression every two entities are separated by an operator except for multiplication, like 4x, 5x, etc. also 3(4+x), etc.  so update the expression to make up for that, then evaluate it for 0 and 1.0  please refer to this code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if there is only X i.e one degree expression,then you can use 2 stacks here, Stack 1: for keeping all the operators Stack 2:for keeping terms keep pushing data to stacks,when you hit a left parenthesis (\")\"),pop 1 element from stack 1 and  2 elements from stack 2,then apply the operator to the terms and push the result again on the stack..you will end up with a simple expression in X that can be solved easily.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The example given is a linear equation in x, and if it is then its do-able I think. any higher power, I have no clue. For this.  1. divide the LHS by x. you get an equation with only constants 2. Evaluate LHS using the 2 stacks as mentioned by Gitesh.  3 x = RHS / evaluated (LHS)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Not really an answer. just hints:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Not ideal code there is space for improvements, but..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"first expand expression( i mean remove braces) then separately evaluate constants and get the coefficient by substituting x=1 then calculate x value using x=summation(constants)/summation(coefficient)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"first expand expression( i mean remove braces) then separately evaluate constants and get the coefficient by substituting x=1 then calculate x value using x=summation(constants)/summation(coefficient)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"build a tree with operator as parene as values children..then inorder traversal"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use two Stacks first for operators and the other for operands. Just like in postfix expression conversion algo."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Use newton-raphson method. to find the root upto the required precision.  xn+1 = xn- f(xn)/f'(xn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"What if the expression some 100th degree polynomial. What kind of solution is expected?  Are there any constraints on the expression?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15466752","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"10","title":"Given a list of integer numbers, a list of symbols [+,-,*,/] and a target number N, provide an expression which evaluates to N or return False if that is not possible. e.g. let the list of numbers be [1,5,5] and the target number is 9, one possible solution could be 5+5-1.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For the first element in the list, solve the problem recursively for each symbol.  For +, recursively look for a way to combine all the remaining elements to equal the target minus the current element.  For *, recursively look for a way to comine all the elements to equal the target divided by the current element.  For -, look for target+x as well x - target.  If pulling out the first element doesn't yield a solution, move on the second, and so on."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my recursive solution in javascript. Complexity is 4^(n-1) because in the worst case we simply generate all possible combinations of ??C + * /"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think we need to consider the last number as well for * and / operations. And do the needful to get the right total. Here is how i would solve it"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In gist:  1. Create a combination of operators that is array of numbers length long. 2. Interleave it with the elements of the array of numbers to create an expression. 3. Create postfix expression. 4. Evaluate the expression and report back if it matches;  The idea here is to generate combinations of the operators as long as the length of the array ( identified by k here).   Once you generate a combination, prune the invalid operator combinations defined as the combination that either start with '*' or '/' .  If the combination of the operator starts with either + or - , simply prefix 0 to it and it will be a valid expression.   Next is a trivial case of converting it into postfix and evaluating the postfix ( code not shown here). After evaluating the postfix expression, compare if the result is the same as desired. If so, print it after removing the 0 that we had added prior."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I constructed an expression tree recursively. It works well. If there is n numbers and 4 operators, then the time should be O(4^n*n!), and the space is O(n^2) (mainly used in stack when doing recursion)."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6026101998485504","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"43","title":"Given an unordered array of positive integers, create an algorithm that makes sure no group of integers of size bigger than M have the same integers.  Input:    2,1,1,1,3,4,4,4,5    M = 2 Output: 2,1,1,3,1,4,4,5,4","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"we can take two pointers and store the occurance count and move left to right and swapping at any occurance of more than M with the next difference number.. this will leave same digits in the end .. so you will need to move from right to left and refill them.. will have no solution if a digit occurs more than N - (N/M) times in the pattern"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"O(nlog(n)) solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can you please explain output. Do we need to remove excess integers from output or we have to reposition them ?? As what 4 is doing in the end of output?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"is output 112344514 correct for input  2,1,1,1,3,4,4,4,5 M = 2 ? i am using hashtable of size 10 to store occurrence of digits in the number entered. if any digit is occurring more than M times continuously, I am printing M digits at that time and printing remaining digits later at the end... How's that?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can you please explain the question? Did you mean any group with size less than M should not contain same integers? Also, I think the group in this case would be formed from continuous sequence of integers?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the code works only for array of size 10 as i have statically defined an array of size 10"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hashset+moving window?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java Code. Complexity O(n). Done by using two array indexes."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include void main() {  int a[10],i,j,k,value,temp,count,M;  clrscr();  printf(\"\\n\\nEnter array:\");  for(i=0;i<10;i++)   scanf(\"%d\",&a[i]);  printf(\"\\nEnter M\") ;  scanf(\"%d\",&M);   printf(\"\\nYour array :\");  for(i=0;i<10;i++)   printf(\"  %d\",a[i]);   count=0;  for(i=0;i<10;i++)  {   count=0;   for(j=i;j<10;j++)   {    if(a[i]==a[j])     count++;    else     break;    if(count>M)    {     for(k=j;k<10;k++)     {      if(a[j]!=a[k])      {       value=a[k];       break;      }     }     temp=a[j];     a[j]=value;     a[k]=temp;     break;    }   }  }  printf(\"\\nYour Output:\");  for(i=0;i<10;i++)   printf(\"  %d\",a[i]);  getch(); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include void main() {  int a[10],i,j,k,value,temp,count,M;  clrscr();  printf(\"\\n\\nEnter array:\");  for(i=0;i<10;i++)   scanf(\"%d\",&a[i]);  printf(\"\\nEnter M\") ;  scanf(\"%d\",&M);   printf(\"\\nYour array :\");  for(i=0;i<10;i++)   printf(\"  %d\",a[i]);   count=0;  for(i=0;i<10;i++)  {   count=0;   for(j=i;j<10;j++)   {    if(a[i]==a[j])     count++;    else     break;    if(count>M)    {     for(k=j;k<10;k++)     {      if(a[j]!=a[k])      {       value=a[k];       break;      }     }     temp=a[j];     a[j]=value;     a[k]=temp;     break;    }   }  }  printf(\"\\nYour Output:\");  for(i=0;i<10;i++)   printf(\"  %d\",a[i]);  getch(); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* \nc# \n*/ \n        static int[] GroupOfIntegers(int[] unOrdered, int m) \n        { \n         if(unOrdered == null) \n          throw new ArgumentNullException(); \n \n         SortedDictionary grouped = new SortedDictionary(); \n \n         foreach(int i in unOrdered) \n         { \n          if(grouped.Keys.Contains(i)) \n           grouped[i]++; \n          else \n           grouped.Add(i, 1); \n   \n         } \n \n            int[] ordered = new int[unOrdered.Count()]; \n            int z = 0; \n                 \n         foreach(KeyValuePair kvp in grouped) \n         {                 \n          for(int i = 0; (i <= m - 1) && (i <= kvp.Value -1); i++) \n          { \n           Console.Write(\"{0} \", kvp.Key); \n           ordered[z] = kvp.Key;   \n          } \n                z++; \n         } \n \n            Console.ReadLine(); \n         return ordered; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int[] process(int[] arr, int m) { \n  int current = 0, j = 0; \n  int count = 1; \n  int last = -1; \n \n  int i = arr.length - 1; \n  while (i > 0) { \n   if (arr[i] == last) { \n    count++; \n \n    if (count > m) { \n     current = i; \n     j = current - 1; \n     // find the next different element \n     while (j > 0 && arr[j] == last) { \n      j--; \n     } \n \n     // swap arr[j] <-> arr[current] \n     int temp = arr[j]; \n     arr[j] = arr[current]; \n     arr[current] = temp; \n \n     count = 1; \n    } \n   } else { \n    count = 1; \n   } \n   last = arr[i]; \n   i--; \n  } \n  return arr; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Arrays;   public class Unordered_Array {     public static int[] swap (int a [] , int k, int j)   {   int temp;   temp = a[k];   a[k] = a[j];   a[j] = temp;      return a;  }    public static void main(String[] args)   {   int [] a = new int []{2,1,1,1,3,4,4,4,5};   int i=0,j=-1,k=0,count=1,first;   int M=2;      while (j < a.length-1)   {        first = a[i];    j = j+1;        if(first == a[j])    {               count ++;          if (count > M)     {      k = j+1;            while (first == a[k])      {       k++;       if (k == a.length)       {        break;       }      }            if (k == a.length)      {       System.out.println(\"Not Applicable\");       break;      }      else      {       a = swap(a,k,j);       i = j+1;       j=i;       count =1;      }           }              }    else     i=j;       }      System.out.println(Arrays.toString(a));     }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Arrays;   public class Unordered_Array {     public static int[] swap (int a [] , int k, int j)   {   int temp;   temp = a[k];   a[k] = a[j];   a[j] = temp;      return a;  }    public static void main(String[] args)   {   int [] a = new int []{2,1,1,1,3,4,4,4,5};   int i=0,j=-1,k=0,count=1,first;   int M=2;      while (j < a.length-1)   {        first = a[i];    j = j+1;        if(first == a[j])    {               count ++;          if (count > M)     {      k = j+1;            while (first == a[k])      {       k++;       if (k == a.length)       {        break;       }      }            if (k == a.length)      {       System.out.println(\"Not Applicable\");       break;      }      else      {       a = swap(a,k,j);       i = j+1;       j=i;       count =1;      }           }              }    else     i=j;       }      System.out.println(Arrays.toString(a));     }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def rearange(list: List[Int], m: Int): List[Int] = { \n    import Math._ \n \n    def fill(n: Int, i: Int) = \n      List.tabulate(n)(_ => i) \n \n    def findFreq(l: List[(Int, Int)]) = \n      if(l.length < 2) (l.head, Nil) \n      else l.tail.foldLeft((l.head, List.empty[(Int, Int)])) { \n        case ((a @ (_, c1), lst), b @ (_, c2)) => if(c1 > c2) (a, b :: lst) else (b, a :: lst) \n      } \n \n    def H(e: (Int, Int), l: List[(Int, Int)]) =  \n      min(m, (l.map { case (_, c) => c }.sum + 1) / ((e._2 + m - 1) / m)) \n \n    def rearange0(f: (Int, Int), lst: List[(Int, Int)], dx: Int): List[Int] = { \n      if(dx == 0) ??? \n \n      (f, lst) match { \n        case ((_, c), l @ (_ :: _)) if c == 0 =>  \n          val (e, t) = findFreq(l) \n          rearange0(e, t, H(e, t)) \n \n        case ((k1, c1), l @ (_ :: _)) => \n          val ((k2, c2), t) = findFreq(l) \n          val (s1, s2) = (min(c1, m), min(c2, dx)) \n          val tail = (if(c2 - s2 > 0) (k2, c2 - s2) :: t else t) \n          fill(s1, k1) ::: fill(s2, k2) ::: rearange0((k1, c1 - s1), tail, dx) \n \n        case ((k, c), Nil) => \n          fill(c, k) \n      } \n    } \n \n    val base = list \n      .groupBy { x => x } \n      .mapValues { _.length } \n      .toList \n \n    if(list.length == 0) Nil \n    else if(base.length == 1) { \n      if(list.length > m) Nil \n      else list \n    } \n    else { \n      val (e, t) = findFreq(base) \n      rearange0(e, t, H(e, t)) \n    } \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"variation of kadane algorithm..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//keep the running count of only the current repeating integer  \n \nvoid modify(int arr[],int n,int M) \n{ \n    int i,count = 0; \n    //count holds count of repeating integer \n    for(i = 0; i < n-1; i++) \n    { \n        if(count == 0 || count <= M)       //no character in continuation or allowed sequence \n        { \n        if(count == 0) \n        count = 1;            //at least one occurence \n        while(i != n-1 && arr[i] == arr[i+1]) \n        { \n            count++; \n            i++; \n        } \n        //now arr[i] != arr[i+1] or i = n-1 \n        if(count > M) \n        { \n            if(i == n-1)     //all characters repeating can't do a thing \n            break; \n            //else arr[i] != arr[i+1] \n            swap(arr+i+1,arr+i-count+M+1); \n            count -= M; \n        } \n        else              //repetition is less than M,stay at original location \n        count = 0;       //since count < M and arr[i] != arr[i+1]  \n       } \n       else \n       { \n           //count > M \n           if(i != n-1 && arr[i] == arr[i+1]) \n           { \n               count++; \n               i++; \n           } \n           //count > M definitely \n           if(i == n-1) \n           break; \n           swap(arr+i+1,arr+i-count+M+1); \n           count -= M; \n       } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I found an O(n log(n)) solution.  I first find the number of occurrences of each object.  Then, break each number into batches of \"M\" repetitions, i.e., one Run. Example: sequence: 1, 1, 1, 1, 4, 4, 1 M = 2 Runs: (1, 1), (1, 1), (1) for type  = 1 (4, 4) for type = 4   An object \"Type\" is defined as a set of Runs of same type. Type1 > Type2 if Type1 has more runs. This way, I can sort all Types descending. This is of course O(nlog(n)).  Lets assume \"1\" is the type with largest number of runs. Now if the total number of \"other\" runs is equal or greater than the number of runs of \"1\", we can proceed to making a proper output (\"MakeSequence()\" routine). Otherwise, I will break the runs into smaller runs until that happens. If not, then there is no solution. This step is linear in the number of Runs() < number of elements.  To make the sequence we do this: a) Take out head of line in queue and remove one run add to sequence. If the Type is empty now, throw it away. If not, keep it somewhere but don't put in queue.  b) Take out another type. Add to sequence. If non-empty, keep it somewhere.   c) Now if there is a type outside, put it back into queue.  e) go back to a) until queue is empty.  Example (above): Type1 = [(11), (11), (1)] Type2= [(4,4)] since Type1.nRuns() == 3 > Type2.nRuns() + 1, we will break Type2. Type2=[(4),(4)]. Now we go to make sequence: seq = \"\"; a)-> seq = \"11\", Type1 = [(1,1),(1)]; b)->seq=\"4\",Type2=[(4)],  c) Type1 goes back into queue. a)-> seq=\"11411\" b)->seq=\"114114\"; c)->Type1 goes back in a)->seq=\"1141141\" done!  here is the code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Python:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5344154741637120","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"27","title":"Sink Zero in Binary Tree. Swap zero value of a node with non-zero value of one of its descendants  so that no node with value zero could be parent of node with non-zero.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"preorder Traversal{ IF(parent == zero && non-zerochild) swap;  preorder left; preorder right; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I did not understand very well.  If child node > parent node && parent node = 0, then swap values. But the child node has children with values larger than 0. So, is the idea to swap recursively by levels? Could you write an example, please?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"from what i understood the main motive is to make sure that no parent with child node or(sub tree) which has none zeros should  have value zero."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can do it like making the heap.. We can use two functions 1)makeheap -> to traverse the tree by postorder traversal and checking the root and its childs. If root is zero then swap it with its nonzero child and apply second function heapify . 2) heapify apply on swapped element and traverse the tree down from there for putting this zero at its proper position . (means if after swapping zero there are child nodes with non zero values then we have to recursively do the same process for all the nodes which are downwords from this swapped zero)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Well I think we should do post order traversal so that we start searching from the bottom of the tree. Every time we find 0 which any of the children is different from 0 do the following relocation: 1) Swap not 0 child with the 0 parent 2)Repeat 1 point till both children of 0 parent are also equal 0 or 0 parent is leaf node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This isn't well-tested, but it's the same general idea as beartung's post, which is to order the nodes according to level using breadth-first search. I separated the traversal from the zero-sinking so the algorithm is clearer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Some thoughts.  For N node and possibility of multiple zeros, the worst case scenario appears to be N^2, i.e. we blindly look for a zero and when found we sink it to the bottom of the current subtree (square because for a degenerate tree, i.e. a tree is a list, it's N^2).   Alternatively we may look for the first non-zero child and swap with it and repeat. This may improve N^2 but I am not positive by how much.  Sinking N zeros is sinking of 1 zero N times, thus since sinking 1 is at worst N (if we have to traverse the whole tree and find no zero) then sinking N is N^2."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be achieved using post-order traversal -"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class SinkZero { \n  \n private static class Node { \n  public K data; \n  public Node left; \n  public Node right; \n   \n  public Node(K data, Node left, Node right) { \n   this.data = data; \n   this.left = left; \n   this.right = right; \n  } \n   \n  @Override \n  public String toString() { \n   return \"Data:\"+data; \n  } \n } \n  \n public static void sinkZero(Node root) { \n  if(root != null) { \n   Stack> zeroStack = new Stack>(); \n    \n   if(root.data == 0) { \n    zeroStack.push(root); \n   } \n    \n   if(root.left != null) { \n    sinkZero(root.left, zeroStack); \n   } \n   if(root.right != null) { \n    sinkZero(root.right, zeroStack); \n   } \n  } \n } \n  \n public static void sinkZero(Node node, Stack> zeroStack) { \n   \n  //do a postorder traversal. in pre recurssion if the data is zero add to stack \n  //in post recursion step pop from queue and swap it with the node \n   \n  if(node.data == 0) { \n   zeroStack.push(node); \n  } \n   \n  if(node.left != null) { \n   sinkZero(node.left, zeroStack); \n  } \n  if(node.right != null) { \n   sinkZero(node.right, zeroStack); \n  } \n   \n  if(zeroStack.size() > 0) { \n   Node zeroNode = zeroStack.pop(); \n   zeroNode.data = node.data; \n   node.data = 0; \n  } \n } \n  \n private static void printTree(Node tree) { \n  if(tree == null) { \n   System.out.print(\"Null tree\"); \n  } else { \n   Queue currentLevel = new LinkedList(); \n   Queue nextLevel = new LinkedList(); \n    \n   currentLevel.add(tree); \n   printTreeBFS(currentLevel,nextLevel); \n  } \n } \n  \n private static void printTreeBFS(Queue currentLevel, Queue nextLevel) { \n  if(currentLevel.size() > 0) { \n   Node elem = currentLevel.poll(); \n   if(elem.left != null) { \n    nextLevel.add(elem.left); \n   } \n   if(elem.right != null) { \n    nextLevel.add(elem.right); \n   } \n   System.out.print(\"Data:\"+elem.data+\"    \"); \n   if(currentLevel.size() == 0) { \n    Queue temp = currentLevel; \n    currentLevel = nextLevel; \n    nextLevel = temp; \n    System.out.println(); \n   } \n   printTreeBFS(currentLevel, nextLevel); \n  } \n } \n  \n public static void main(String[] args) { \n  //create a dummy tree \n  Node tree1 = new Node(0,new Node(0,new Node(2,null,null),new Node(3,null,null)),new Node(0,new Node(4,null,null),new Node(5,null,null))); \n   \n  printTree(tree1); \n   \n  sinkZero(tree1); \n   \n  printTree(tree1); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static NodeBT postOSink(NodeBT root){ \n  if(root!=null){ \n  postOSink(root.left); \n  postOSink(root.right); \n  if(root.data==0){ \n   if(root.left!=null && root.left.data!=0){ \n    root.data=root.left.data; \n    root.left.data=0; \n   } \n   else if(root.right!=null && root.right.data!=0) \n    { \n    root.data=root.right.data; \n    root.right.data=0; \n    } \n  } \n  } \n  return root;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Just  breadth-first traverse the tree, keep all node in a array or list. Then swap the 0 node from the head of the list and non 0 node from the end of the list:  java codes:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5765850736885760","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"18","title":"Mapping '1' = 'A','B','C' '2' = 'D','E','F' ... '9' =  input: 112 output :ouput = [AAD, BBD, CCD, AAE, AAF, BBE, BBF, CCE, CCF]","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This problem is known as telephone words and can be solved using simple recursion."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hope my code is understandable with the comments. the main function is the permute just before the main."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Mapping {   private char[][] array = { {}, { 'A', 'B', 'C' }, { 'D', 'E', 'F' },    { 'G', 'H', 'I' }, { 'J', 'K', 'L' }, { 'M', 'N', 'O' },    { 'P', 'Q', 'R', 'S' }, { 'T', 'U', 'V' }, { 'W', 'X', 'Y', 'Z' } };   private String input = \"1223\";   private char[] c = input.toCharArray();  private char[] index = new char[10];  private char[] result = new char[c.length];   public Mapping() {   for (int i = 0; i < 10; i++) {    index[i] = '0';   }  }   private void judge(int pos) {   if (pos == c.length) {    System.out.println(result);    return;   }   char[] f = { c[pos] };   String s = new String(f);   int k = Integer.parseInt(s);   if (index[k] == '0') {    for (int j = 0; j < array[k].length; j++) {     index[k] = array[k][j];     result[pos] = array[k][j];     judge(pos + 1);     index[k] = '0';    }   } else {    result[pos] = index[k];    judge(pos + 1);   }  }   /**   * @param args   */  public static void main(String[] args) {   // TODO Auto-generated method stub   new Mapping().judge(0);  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This should suffice basically just a permutation generator with remembrance"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is the inverse of the telephone problem. Here's a quick but complete solution in Python..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This will not work for an input like '113'. Thats because numbers in this case would be [1,3] and combination[int(c) - 1] at c=3, will look for combination[2], which is incorrect. One small modification to your code will solve the issue. Store the values of set as a list and find the index of int(c) in the list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I hope this code is nice and simple. Each recursive branch gets its own re-defined mapping"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why does the output not have ABD or BAD for 112? Am I missing something here?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/** Given a mapping as follows: \n'1' = 'A','B','C'  \n'2' = 'D','E','F'  \n...  \n'9' = 'X','Y','Z' \n \nIf each number can represent exactly 1 letter in a given mapping, print all the results \nfrom all possible mappings. \n \ninput: 112  \noutput :ouput = [AAD, BBD, CCD, AAE, AAF, BBE, BBF, CCE, CCF] \n*/ \npublic class letterMapping { \n \n    public static void main (String[] args) { \n        map.put('1', one); \n        map.put('2', two); \n        map.put('3', three); \n        possibleMappings(112); \n    } \n    public static void possibleMappings(int input) { \n        char[] test = new char[8]; \n        int mod = 0; \n        for (int i = 0;;i++) { \n            if (input - Math.pow(10, i) < 0) { \n                mod = i - 1; \n                break; \n            } \n        } \n        possibleMappings(input, \"\", mod,test); \n    } \n    public static void possibleMappings(int input, String result, int mod, char[] memo) { \n        if (input == 0) { \n            System.out.println(result); \n            return; \n        } \n        int curr = (int) (input / ((Math.pow(10, mod)))); \n        if (memo[curr] != 0) { \n            possibleMappings(input - (int)(curr * (Math.pow(10, mod))), result + memo[curr], mod - 1, memo); \n            return; \n        } \n        for (char c : map.get(Character.forDigit(curr, 10))) { \n            memo[curr] = c; \n            possibleMappings(input - (int)(curr * (Math.pow(10, mod))), result + c, mod - 1, memo); \n            memo[curr] = 0; \n        } \n    } \n     \n    static HashMap map = new HashMap<>(); \n    static char[] one = {'A','B','C'}; \n    static char[] two = {'D', 'E', 'F'}; \n    static char[] three = {'G', 'H', 'I'};  \n     \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// C solution,  by simulating permutation  void Print() {     char array[8][4] = {\"ABC\", \"DEF\", \"GHI\", ... \"XYZ\"};     char output[4];          output[3] = '\\0';          printCore(array, output, 3, -1); }  void PrintCore(char array[][4], char output[], int length, int index) {     if (index == length - 1)     {         printf(\"%s  \", output);         return;     }          for (i = 0; i < 3; ++i)     {         output[index+1] = array[index + 1][i];         PrintCore(array, output, length, index + 1);     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// C  void Print() {     char array[8][4] = {\"ABC\", \"DEF\", \"GHI\", ... \"XYZ\"};     char output[4];     char input = \"112\"; // could be scanf a string here, modify later          output[3] = '\\0';          printCore(array, output, 3, -1); }  void PrintCore(char array[][4], char output[], char input[], int length, int index) {     int i;      if (index == length - 1)     {         printf(\"%s  \", output);         return;     }          while (input[i])     {         output[index+1] = array[index + 1][input[i] - '0'];         PrintCore(array, output, length, index + 1);     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//keep array for digits such that it is -1 if character is unlocked(not used before) and else store the index to which it should belong. see the code below \n \n#define N 9 \n#define M 3 \n#define SIZE 10 \n \nvoid permute(char * str,int hash[],char arr[N][M],int pos) \n{ \n    static char si[SIZE]; \n    int i;       //this iterates over all possible choices \n    if(str[pos] == '\\0') \n    { \n        si[pos] = '\\0'; \n        printf(\"\\n%s\",si); \n        return; \n    } \n    //take the current element of the string str \n    //str[i] can be between 1 to 9 ,map it to index 0 to 8 \n    if(hash[str[pos]-'0'-1] != -1)          //some index fixed from 0 to 2 \n    { \n    si[pos] = arr[str[pos]-'0'-1][hash[str[pos]-'0'-1]]; \n    permute(str,hash,arr,pos+1); \n    } \n    else \n    {  \n        //hash[str[pos]-'0'-1] == -1 so this is not a locked character \n        int end = ((str[pos] == '9')?M-2:M-1);          //'9' has two letters only Y and Z \n        for(i = 0; i <= end; i++) \n        { \n            //try all permutations \n            si[pos] = arr[str[pos]-'0'-1][i]; \n            hash[str[pos]-'0'-1] = i;      //lock the character \n            permute(str,hash,arr,pos+1); \n            hash[str[pos]-'0'-1] = -1;     //unlock the character \n        } \n    } \n} \n     \n \nint main() \n{ \n    char arr[N][M] = {{'A','B','C'},{'D','E','F'},{'G','H','I'},{'J','K','L'},{'M','N','O'},{'P','Q','R'}, \n    {'S','T','U'},{'V','W','X'},{'Y','Z','0'}}; \n    int hash[N]; \n    for(int i = 0; i < N; i++) \n    hash[i] = -1; \n    char * str = \"112\"; \n    permute(str,hash,arr,0); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* Modify program to print desired above mentioned */  char* mapping[] ={\"\",\"ABC\",\"DEF\",\"GHI\",\"JKL\",\"MNO\",\"PQR\",\"STU\",\"VWX\",\"YZ\"}; void printallcombination(char* s, int idx, char* res) {  if(idx > strlen(s))  {   cout<<<\"\\n\";   return;  }   int c = (int)(s[idx-1] - '0');  for(int i=0; i< strlen(mapping[c]);i++)  {   char* temp = (char*)malloc(sizeof(char) * 100);   memset(temp, 0, sizeof(char) * 100);   temp[0] = mapping[c][i];    char* temp1 = (char*)malloc(sizeof(char) * 100);   memset(temp1, 0, sizeof(char) * 100);   strcat(temp1, res);   printallcombination(s,idx+1, strcat(res, temp));   strcpy(res, temp1);   delete(temp);   delete(temp1);  } }    void main( ) {  char* result = (char*)malloc(sizeof(char)*100);  memset(result, 0, sizeof(char)*100);  printallcombination(\"12\",1,result); }   Output :  ABD ABE ABF ACD ACE ACF BAD BAE BAF BBD BBE BBF BCD BCE BCF CAD CAE CAF CBD CBE CBF CCD CCE CCF"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* Modify program to print desired above mentioned */  char* mapping[] ={\"\",\"ABC\",\"DEF\",\"GHI\",\"JKL\",\"MNO\",\"PQR\",\"STU\",\"VWX\",\"YZ\"}; void printallcombination(char* s, int idx, char* res) {  if(idx > strlen(s))  {   cout<<<\"\\n\";   return;  }   int c = (int)(s[idx-1] - '0');  for(int i=0; i< strlen(mapping[c]);i++)  {   char* temp = (char*)malloc(sizeof(char) * 100);   memset(temp, 0, sizeof(char) * 100);   temp[0] = mapping[c][i];    char* temp1 = (char*)malloc(sizeof(char) * 100);   memset(temp1, 0, sizeof(char) * 100);   strcat(temp1, res);   printallcombination(s,idx+1, strcat(res, temp));   strcpy(res, temp1);   delete(temp);   delete(temp1);  } }    void main( ) {  char* result = (char*)malloc(sizeof(char)*100);  memset(result, 0, sizeof(char)*100);  printallcombination(\"12\",1,result); }   Output :  ABD ABE ABF ACD ACE ACF BAD BAE BAF BBD BBE BBF BCD BCE BCF CAD CAE CAF CBD CBE CBF CCD CCE CCF"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void printcombinations(deque&digits, map&index,vector& dictionary) { \n if(index[digits[0]]==3) { \n  return; \n } \n for(int i=digits.size()-1;i>=0;i--) { \n  int nextIndex=index[digits[i]]; \n  if(nextIndex==3 && index[digits[0]]!=3 ){ \n   if(i-1>=0) { \n    index[digits[i-1]]++; \n   } \n \n   index[digits[i]]=0; \n  } \n  if(index[digits[0]]==3) {return;} \n } \n \n for(int i=0;i dictionary; \n \n dictionary.push_back(\"\"); \n dictionary.push_back(\"ABC\"); \n dictionary.push_back(\"DEF\"); \n dictionary.push_back(\"GHI\"); \n dictionary.push_back(\"JKL\"); \n dictionary.push_back(\"MNO\"); \n dictionary.push_back(\"PQR\"); \n dictionary.push_back(\"STU\"); \n dictionary.push_back(\"VWX\"); \n \n dequedigits; \n int temp=n; \n while(temp>0) { \n  int digit=temp%10; \n  digits.push_front(digit); \n  temp=temp/10; \n } \n map index; \n for(int i=0;i"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5733320654585856","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"13","title":"Group Anagrams input = [\"star, astr, car, rac, st\"] output = [[\"star, astr\"],[\"car\",\"rac\"],[\"st\"]);","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Create Map>. - Key is a sorted string. - Values is a List of strings which after sorting are equal to the key and the original key itself. Code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A very easy problem in Python."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution done in golang. Converts each word to an array of character counts in one pass. O(n). This array is the key, the word list is the value.   So O(n+m) where n is the word length and m is the number of words. Also uses stores a 256 length byte array for each anagram (regardless of length of each word and frequency of each anagram)  Sorting at best is O(n log n) so be careful of sorting based solutions. Also since strings are usually immutable across most languages be careful of solutions that use string split and string append as they add (and hide) complexity."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why sort? Just add the ASCII values, and you have a premitive hash. Use that as your key, and value is a list of words with the same sum"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.HashMap; \nimport java.util.LinkedList; \nimport java.util.List; \nimport java.util.Map; \nimport java.util.Map.Entry; \n \nimport org.slf4j.Logger; \nimport org.slf4j.LoggerFactory; \n \npublic class PermutationFinder { \n  \n //Assumption: Only lowercase characters are present in a string. \n // we can handle uppercase similarly. Instead of 26 unique characters then we \n // can have 52 unique characters. \n  \n private final Logger logger = LoggerFactory.getLogger(PermutationFinder.class); \n  \n private static class MyString { \n  private final String str; \n  private final int hashCode; \n      \n     public MyString(String str) { \n         this.str = str; \n         //Optimization. Computing hashCode once. \n         long hash = 1; \n      for(char c:this.str.toCharArray()) { \n       hash = hash * getPrime(c);  \n      } \n       \n      hashCode = (int)hash%Integer.MAX_VALUE; \n     } \n      \n     @Override \n     public int hashCode() { \n      return hashCode; \n     } \n      \n     @Override \n     public boolean equals(Object obj) { \n          if(obj != null && obj instanceof MyString) { \n               MyString sobj = (MyString)obj; \n               if(sobj.str.length() == str.length()) { \n                 \n                //It doesnt matter even if there are million characters as there are just 26 unique characters. \n                //So maximum number of keys can be 26(x2 for uppercase and lowercase) \n                Map mapChars1 = new HashMap(sobj.str.length()); \n                for(Character c: sobj.str.toCharArray()) { \n                 Integer count = mapChars1.get(c); \n                 if(count == null) { \n                  mapChars1.put(c, new Integer(1)); \n                 } else { \n                  mapChars1.put(c, count + 1); \n                 } \n                } \n                 \n                Map mapChars2 = new HashMap(str.length()); \n                for(Character c: str.toCharArray()) { \n                 Integer count = mapChars2.get(c); \n                 if(count == null) { \n                  mapChars2.put(c, new Integer(1)); \n                 } else { \n                  mapChars2.put(c, count + 1); \n                 } \n                } \n                 \n                //Compare the two maps \n                return isEqual(mapChars1, mapChars2); \n               }  \n          } \n          return false;    \n     } \n      \n     private static boolean isEqual(Map map1, Map map2) { \n         if(map1.size() == map2.size()) { \n       for(Entry entry1:map1.entrySet()) { \n        Integer value2 = map2.get(entry1.getKey()); \n        if(value2 ==null || !value2.equals(entry1.getValue())) { \n         return false; \n        } \n       } \n       return true; \n         } \n         return false; \n     } \n      \n     //getPrime(char c) will return corresponding prime number of a char(first 26 prime numbers) \n     private static final int[] primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101}; \n     private static final int getPrime(Character c) { \n      return primes[c-'a']; \n     } \n \n } \n  \n public static List> getPermutations(List input) { \n     Map> map = new HashMap>(); \n      \n     for(String inputStr:input) { \n          MyString key = new MyString(inputStr); \n          List value = map.get(key); \n          if(value == null) { \n              value = new LinkedList(); \n              map.put(key,value); \n         } \n         value.add(inputStr); \n     } \n      \n     List> output = new LinkedList>(); \n     for(List val: map.values()) { \n               output.add(val); \n     } \n     return output; \n } \n  \n public static void main(String[] args) { \n  List input = new LinkedList(); \n  input.add(\"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzztzztzz\"); \n  input.add(\"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzztt\"); \n  input.add(\"star\"); \n  input.add(\"david\"); \n  input.add(\"jean\"); \n  input.add(\"sumo\"); \n  input.add(\"brian\"); \n  input.add(\"rats\"); \n  input.add(\"jane\"); \n  input.add(\"tars\"); \n  input.add(\"brain\"); \n  input.add(\"jaen\"); \n   \n  List> output = PermutationFinder.getPermutations(input); \n  System.out.println(\"Output is:\"+output); \n   \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for each string- sort it and put in a map where the key is the sorted string. \nO( n*klogk ) \n \nfunction func($arr) { \n $res = array(); \n foreach($arr as $string) { \n  $chars = str_split($string); \n  sort($chars); \n  $chars = implode($chars); \n  $res[$chars] []= $string; \n } \n return $res;  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public ArrayList> findAnagrams(String[] arr){ \n    \n       Hashtable> ht = new Hashtable>(); \n       for(String str : arr){ \n           String de_str= decode(str); \n           if(ht.containsKey(de_str )){ \n               ht.get(de_str).add(str); \n           } \n           else{ \n               ArrayList tem = new ArrayList(); \n               tem.add(str); \n               ht.put(de_str,tem); \n           } \n       } \n       ArrayList> res     = new ArrayList>(ht.values()); \n} \n \npublic String decode(String str){ \n    int[] arr = new int[26]; \n    for(int i = 0 ; i < str.length() ; i++){ \n        arr[str.charAt(i)-'a'+1]++; \n    } \n    StringBuffer sb = new StringBuffer(); \n    for(int k : arr){ \n        sb.append(k); \n        sb.append(','); \n    } \n    return sb.toString(); \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5720759351640064","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"1","title":"Minimum Spanning Tree using alghoritm prim","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is your previous question id=5346858440327168 on the same subject. Continue this problem there instead of spamming portal."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4892713614835712","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"36","title":"You have two numbers decomposed in binary representation, write a function that sums them and returns the result.  Input: 100011, 100100 Output: 1000111","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In Java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int[] add( int[] a, int[] b ){ \n int len = a.length + 1; \n int[] newa = a; \n int[] newb = b; \n if( a.length < b.length ){ \n  len = b.length + 1; \n  newa = new int[b.length]; \n  for( int i = a.length; i < b.length; i ++ ) \n   newa[ i ] = 0; \n } else { \n  len = a.length + 1; \n  newb = new int[a.length]; \n  for( int i = b.length; i < a.length; i ++ ) \n   newb[ i ] = 0; \n } \n int t = 0; \n for( int i = len - 1; i > 0; i -- ){ \n  ret[ i ] = ( newa[i-1] + newb[i-1] + t ) % 2; \n  t = newa[i-1] + newb[i-1] > 1 ? 1 : 0; \n } \n ret[ 0 ] =t; \n return ret; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. add \"0\" to the MSB of the two strings so that their lengths match 2. iterate on the two strings one bit at a time starting with LSB and do bitwise addition and accumulate result 3. reverse the result"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Am I wrong in assuming what they want you to *bitwise OR* both numbers"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int binaryToInt(string binaryString) \n{ \n int convertedInt = 0; \n for (int i = binaryString.length; i > 0; i-- ) \n { \n  convertedInt += binaryString.charAt(i) == \"1\" ? 2^(binaryString.length - i) : 0; \n } \n return convertedInt; \n} \n \npublic string binaryAddition(string one, string two) \n{ \n string binarySum = \"\"; \n var sum = binaryToInt(one) + binaryToInt(two); \n while (sum > 0) \n { \n  binarySum += sum % 2; \n  sum = sum / 2; \n } \n return binarySum; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just add from right to left. C++ version:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In c: { int sumTwoBinaryNumbers(int a, int b) {     int firstNumber = 0;          for (int i = 0; a > 0; i++) {         int remainder = a % 10;                  firstNumber += (remainder * pow(2, i));         a /= 10;     }          int secondNumber = 0;          for (int i = 0; b > 0; i++) {         int remainder = b % 10;                  secondNumber += (remainder * pow(2, i));         b /= 10;     }          return firstNumber + secondNumber; }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Wow this one looks easy but still took me a while. I am taking the standard approach of adding up the digits one by one (starting from the end of the strings)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Step 1: Iterate through the bits in larger binary number and perform bitwise addition  with smaller binary number with carry forward. Step 2: Add the result in a list and reverse the final result and store it in result array"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Theory  sum = a xor b xor c carry = ab + bc+ ac  Code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Well, it seem that the question is really about bitwise operations. The following code was intentionally left unoptimized in variables use just to preserve logic simplicity."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"string addBitStrings( string first, string second ) {     string result;  // To store the sum bits       // make the lengths same before adding     int length = makeEqualLength(first, second);     int carry = 0;  // Initialize carry       // Add all bits one by one     for (int i = length-1 ; i >= 0 ; i--)     {         int firstBit = first.at(i) - '0';         int secondBit = second.at(i) - '0';           // boolean expression for sum of 3 bits         int sum = (firstBit ^ secondBit ^ carry)+'0';           result = (char)sum + result;           // boolean expression for 3-bit addition         carry = (firstBit&secondBit) | (secondBit&carry) | (firstBit&carry);     }       // if overflow, then add a leading 1     if (carry)  result = '1' + result;       return result; }   //source geeksforgeeks"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#define MIN(x,y) ((x) < (y))?(x):(y) \n#define MAX(x,y) ((x) > (y))?(x):(y) \n#define SAFE_STRLEN(x) ((x)?strlen(x):0) \n \n//Returns dynamically allocated string needs to be freed                                                                                                                                                                                                                       \nchar * addNums(char*num1,char * num2) \n{ \n \n  int lenOfSum = MAX(SAFE_STRLEN(num1),SAFE_STRLEN(num2)) + 2; \n  int lenOfCommonParts = MIN(strlen(num1?num1:\"\"),strlen(num2?num2:\"\")); \n \n  char * num = new char[lenOfSum]; \n  int i; \n \n  memset(num,0,lenOfSum); \n \n  bool digit1, digit2,carry = false; \n \n  for(int i = 0; i < lenOfCommonParts; i++) \n  { \n    digit1 = num1[strlen(num1?num1:\"\") - i -1] == '1'; \n    digit2 = num2[strlen(num2?num2:\"\") - i -1] == '1'; \n \n    num[i] = ((digit1 ^ digit2) ^ carry)?'1':'0'; \n    carry = ((int)digit1 + (int)digit2 + (int)carry) > 1; \n \n  } \n  char * leftOver = strlen(num1?num1:\"\") > strlen(num2?num2:\"\") ? num1 : num2; \n \n  for(int i = lenOfCommonParts; i < SAFE_STRLEN(leftOver); i++) \n    { \n      digit1 = leftOver[strlen(leftOver) - i -1] == '1'; \n      num[i] = (digit1  ^ carry)?'1':'0'; \n      carry = ((int)digit1  + (int)carry) > 1; \n    } \n \n    if(carry) \n      num[strlen(num)] = '1'; \n \n    int length = strlen(num); \n    puts(num); \n    for(int i = 0; i < length/2; ++i) \n      { \n        char dig = num[i]; \n        num[i] = num[length - i - 1]; \n        num[length -i-1] = dig; \n      } \n  return num; \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Python implementation:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#Ruby 2.0.0 implementation"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  #include  #define max(a,b) ((a) > (b))?(a):(b)  void SomaBinario(char *b1, char *b2, char *result) {  int l1, l2, carrie = 0, i;  l1 = strlen(b1)-1;  l2 = strlen(b2)-1;  i = max(l1,l2) + 3;  result = (char*)malloc((i)*sizeof(char));  result[--i] = '\\0';  i--;    while ((l1 >= 0) && (l2 >= 0)){   int n1 = b1[l1] - '0';   int n2 = b2[l2] - '0';   int soma;   soma = n1 + n2 + carrie;      carrie = (soma > 1)?1:0;      result[i] = (soma%2) + '0';          i--;   l1--;   l2--;  }      if (l1 > l2) {     while (l1 >= 0){    int n1 = b1[l1] - '0';    int soma;    soma = n1 + carrie;        carrie = (soma > 1)?1:0;        result[i] = (soma%2) + '0';             i--;    l1--;   }     } else {   while (l2 >= 0){    int n2 = b2[l2] - '0';    int soma;    soma = n2 + carrie;        carrie = (soma > 1)?1:0;        result[i] = (soma%2) + '0';            i--;    l2--;   }     }   if (carrie)    result[i] = carrie + '0';    printf(\"%s\", result);    }   int main(){  char bin1[] = \"101111\", bin2[] = \"1110101\", *resultado;    SomaBinario(bin1, bin2, resultado);  return 0;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \n#define max(a,b) ((a) > (b))?(a):(b) \n \nvoid sum(char *b1, char *b2, char *result) { \n int l1, l2, carrie = 0, i; \n l1 = strlen(b1)-1; \n l2 = strlen(b2)-1; \n i = max(l1,l2) + 3; \n result = (char*)malloc((i)*sizeof(char)); \n result[--i] = '\\0'; \n i--; \n  \n while ((l1 >= 0) && (l2 >= 0)){ \n  int n1 = b1[l1] - '0'; \n  int n2 = b2[l2] - '0'; \n  int soma; \n  soma = n1 + n2 + carrie; \n   \n  carrie = (soma > 1)?1:0; \n   \n  result[i] = (soma%2) + '0';   \n     \n  i--; \n  l1--; \n  l2--; \n } \n    \n if (l1 > l2) { \n  \n  while (l1 >= 0){ \n   int n1 = b1[l1] - '0'; \n   int soma; \n   soma = n1 + carrie; \n    \n   carrie = (soma > 1)?1:0; \n    \n   result[i] = (soma%2) + '0';   \n       \n   i--; \n   l1--; \n  } \n   \n } else { \n  while (l2 >= 0){ \n   int n2 = b2[l2] - '0'; \n   int soma; \n   soma = n2 + carrie; \n    \n   carrie = (soma > 1)?1:0; \n    \n   result[i] = (soma%2) + '0';  \n   printf(\"[%c]\", result[i]); \n       \n   i--; \n   l2--; \n  } \n   \n }  \n if (carrie) \n   result[i] = carrie + '0'; \n  \n printf(\"%s\", result); \n   \n} \n \n \nint main(){ \n char bin1[] = \"101111\", bin2[] = \"1110101\", *resul; \n  \n Sum(bin1, bin2, result); \n return 0; \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution in Java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class BitwiseOperation { \n public static String sumOfBinaryNumbers(String a,String b) \n { \n  a=a.replace(\" \", \"\"); \n  b=b.replace(\" \", \"\"); \n     char n[]=a.toCharArray(); \n  char m[]=b.toCharArray(); \n  StringBuffer result=new StringBuffer(); \n  int carry=0; \n  int i=n.length-1,j=m.length-1; \n  while(i>=0 && j>=0) \n  { \n   int r1=Integer.parseInt(n[i]+\"\"); \n   int r2=Integer.parseInt(m[j]+\"\"); \n   int value=(r1^r2^carry); \n   carry=((r1 & r2) | (r1 &carry)) | (r2 & carry);  \n   result.append(value); \n   i--; \n   j--; \n  } \n  while(i>=0) \n     { \n   int value=Integer.parseInt(n[i]+\"\")^carry; \n   if(value==1) \n    carry=0; \n   else \n    carry=1; \n   result.append(value); \n   i--; \n     } \n  while(j>=0) \n  { \n   int value=Integer.parseInt(m[j]+\"\")^carry; \n   if(value==1) \n    carry=0; \n   else \n    carry=1; \n   result.append(value); \n   j--; \n  } \n  if(carry==1) \n  result.append(carry); \n  result.reverse(); \n   return result.toString(); \n } \n public static void main(String[] args) \n { \n  String result= sumOfBinaryNumbers(\"100011\",\"100100\"); \n  System.out.println(\"Result \"+result); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"std::string Add(std::string & str1, std::string & str2) {   int m = str1.size();   int n = str2.size();   int i = m - 1;   int j = n - 1;   int c = 0;   std::string rs(std::max(m, n), '0');   int k = rs.size() - 1;   while (i >= 0 || j >= 0 || c >0) {     int t = c;     if (i >= 0) t += str1[i--] - '0';     if (j >= 0) t += str2[j--] - '0';     c = t / 2;     t = t % 2;     if (k >= 0) rs[k--] = t + '0';     else rs.insert(rs.begin(), t + '0');   }   return rs; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is my code in Objective-C"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a nice question as any basic addition for a n&m n>m bit there will be n XORs, n AND and carry management this can be reduced based on the number of 1's in the numbers let the numbers be a&b;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Recursive solution with tail recursion:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A Java impl with the main driver. Takes the binary numbers as args."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// Sum binary numbers \nvoid sum_binary(int num1[], int num2[], short size) \n{ \n int *result = new int[size + 1]; \n int carry = 0; \n for (short i = size; i > 0; --i) \n { \n  result[i] = num1[i-1] ^ num2[i-1] ^ carry; \n  carry = (num1[i-1] && num2[i-1]) || (carry && (num1[i-1] || num2[i-1])); \n } \n result[0] = carry; \n  \n cout << \" \"; \n for (auto x = 0; x < size; ++x) \n  cout << num1[x]; \n cout << endl << \" \"; \n for (auto x = 0; x < size; ++x) \n  cout << num2[x]; \n cout << endl; \n for (auto x = 0; x < size + 1; ++x) \n  cout << result[x]; \n cout << endl; \n  \n delete [] result;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int main() {  char a[8] = \"00100011\";  char b[8] = \"00100100\";  char c[8] = {0};  int i = 7;  //i = strlen(a)-1;  for(i = 7;i>=0;i--)  {   c[i] = a[i] +b[i] - '0';   if(c[i] > '1'){    c[i] = '0';    a[i-1] = '1';   }      //printf(\"%c\", c[i]);  }  for(i=0;i<8;i++)   printf(\"%c\",c[i]); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is JavaScript implementation. Can you explain what they actually test here? Writing binary number string to number converter? Imitating bit-wise operations? What?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void foo(const char *s1, const char *s2) \n{ \n    int l1, l2, l; \n    char *s; \n \n    if (s1 == NULL || s2 == NULL || s1[0] == '\\0' || s2[0] == '\\0') return; \n \n    l1 = strlen(s1); \n    l2 = strlen(s2); \n \n    if (l1 < l2) { \n        l = l2 + 1; \n    } else { \n        l = l1 + 1; \n    } \n \n    s = (char *)malloc(l + 1); \n    if (s == NULL) return; \n    s[l] = '\\0'; \n \n    l1--; \n    l2--; \n    l--; \n \n    int sum, carry = 0; \n \n    while (l1 >= 0 && l2 >= 0) { \n        //printf(\"carry: %d\\n\", carry); \n \n        sum = s1[l1] - '0' + s2[l2] - '0' + carry; \n \n        //printf(\"sum: %d\\n\", sum); \n \n        if (sum > 1) { \n            sum -= 2; \n            carry = 1; \n        } else { \n            carry = 0; \n        } \n \n        s[l--] = (char)(sum + '0'); \n \n        l1--; \n        l2--; \n    } \n \n    while (l1 >= 0) { \n        sum = s1[l1] - '0' + carry; \n \n        if (sum > 1) { \n            sum -= 2; \n            carry = 1; \n        } else { \n            carry = 0; \n        } \n \n        s[l--] = (char)(sum + '0'); \n \n        l1--; \n    } \n \n    while (l2 >= 0) { \n        sum = s2[l2] - '0' + carry; \n \n        if (sum > 1) { \n            sum -= 2; \n            carry = 1; \n        } else { \n            carry = 0; \n        } \n \n        s[l--] = (char)(sum + '0'); \n \n        l2--; \n    } \n \n    if (l >= 0) { \n        if (carry > 0) s[l--] = '1'; \n        else while (l >= 0) s[l--] = '0'; \n    } \n \n    printf(\"s1: %s\\ns2: %s\\nsum: %s\\n\", s1, s2, s); \n \n    free(s); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int sumOfBinaryNumber() {  long binary1, binary2;     int i = 0, remainder = 0, sum[20];       printf(\"Enter the first binary number: \");  cin>>binary1;     printf(\"Enter the second binary number: \");     cin>>binary2;     while (binary1 != 0 || binary2 != 0)     {         sum[i++] =(binary1 % 10 + binary2 % 10 + remainder) % 2;         remainder =(binary1 % 10 + binary2 % 10 + remainder) / 2;         binary1 = binary1 / 10;         binary2 = binary2 / 10;     }     if (remainder != 0)         sum[i++] = remainder;     --i;     printf(\"Sum of two binary numbers: \");     while (i >= 0)         printf(\"%d\", sum[i--]);     return 0; }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5152893422272512","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"16","title":"You have a dictionary which is an array of words and array of strings.  Write two functions  1. Prepare the array of strings to be searched in the dictionary 2. Check if the string contains all valid words or not.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"I think you should use trie data Structure in this."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"struct TrieTrieNode { \n  TrieNode() : isWord(false) { \n for(int i = 0;i < 26;++i) \n   children[i] = 0; \n  } \n \n  ~TrieNode() { \n for(int i = 0;i < 26;++i) \n   if(children[i])  \n  delete children[i]; \n  } \n \n  TrieNode*& child(char c) { \n //For Simplicity, converts all characters to lowercase \n return children[tolower(c)-'a']; \n  } \n \n  TrieNode* children[26]; \n  bool isWord ; \n}; \n \nclass Trie { \n  public: \n    Trie() { \n      root = new TrieNode; \n    } \n \n    ~Trie() { \n      delete root; \n    } \n \n    void addWord(string word) { \n      TrieNode* curr = root; \n      for(int i = 0;i < word.length();++i){ \n        char& c = word[i]; \n        if(!isalpha(c))  \n   continue; \n        if(!curr->child(c)) \n          curr->child(c) = new TrieNode; \n        curr = curr->child(c); \n      } \n      curr->isWord = true; \n    } \n \n    bool searchWord(string word) { \n      TrieNode* curr = root; \n      for(int i = 0;i < word.size();++i) { \n        char& c = word[i]; \n        if(!isalpha(c))  \n   continue; \n        if(!curr->child(c))  \n   return false; \n        curr = curr->child(c); \n      } \n      return curr->isWord; \n    } \n  private: \n    TrieNode* root; \n};"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"IMO they want you to create an inverted index.   We have an array of words, and an array of strings. Here is a simple approach:  1. Create an hash table where key = word, and values = array of indices of strings which contain that word.  2. Parse each of the strings in the strings array and update the hash table.   Search:  Break down the search query into words and return the indices of strings that contain that each of those words.   The best match is the string which is returned maximum number of times.   karanAThealthtapDOTcom"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please can you clarify the quiestion? You've got array of strings, how would you search string in dictionary?  Check whether string contains only words from dict or not?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You don't need to use trie data Structure, is too complex for the solution.  Considering that the dictionary of strings is something like:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class trieNode{ \n public char key; \n public Hashtable< char, trieNode> children; \n public static trieNode root; \n public boolean isWord; \n \n public trieNode( char k ){ \n  key = k; \n  children = new Hashtable< char, trieNode> (); \n  isWord = false; \n } \n  \n public static void constructTrie( ArrayList input ){ \n  for( int i = 0; i < input.size(); i ++ ){ \n   String st = input.at( i ); \n   n = root; \n   for( int j = 0; j < st.size(); j ++ ){ \n    trieNode newN; \n    if( ( newN = n.children.get( st.charAt( j ) ) )== null ){ \n     newN = new trieNode( st.charAt( j ) ); \n     n.children.add( newN ); \n      \n    } \n    n = newN; \n   } \n   n.isWord = true; \n  } \n } \n \n public static boolean search( String word ){ \n  trieNode n = root; \n  trieNode newN; \n  for( int i = 0; i < word.size(); i ++ ){ \n   if( ( newN = root.children.get( word.charAt( i ) ) ) == null ) \n    return false; \n   n = newN; \n  } \n  if( n.isWord ) \n   return true; \n  return false; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the best solution is a trie."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A simple trie implementation in Python, using nested dictionary objects."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A simple trie implementation in Java assuming the charset as alphabets:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"$arr = array(\"abc\",\"jl\"); \n$strings = array(\"hey hey\",\"no go\"); \n$trie = new Trie($arr); \nforeach($strings as $string) { \n var_dump($trie->validateSentence($string)); \n} \n  \nclass Trie { \n  \n public $root; \n  \n function __construct($wordArr) { \n  $this->root =  array('val'=>'','children'=>array()); \n  foreach($wordArr as $word)  \n   $this->pushWord($this->root,$word); \n } \n  \n public function validateSentence($string) { \n  $res = true; \n  $words = explode(\" \",$string); \n  foreach($words as $word) { \n   $res &= $this->validateWord($this->root,$word); \n  } \n  return $res; \n } \n  \n public function validateWord($node,$str) { \n   \n  if (empty($str)) {  \n   return true; \n  } \n   \n  foreach($node['children'] as $index=>$child) { \n   if ($child['val'] == $str[0]) { \n    return $this->validateWord($node['children'][$index],substr($str,1)); \n   } \n  } \n  return false; \n } \n  \n public function pushWord(&$node,$str) { \n \n  if (!empty($str)) {  \n   $found = false; \n   foreach($node['children'] as $index=>$child) { \n    if ($child['val'] == $str[0]) { \n     $found = true; \n     $this->pushWord($node['children'][$index],substr($str,1)); \n    } \n   } \n   if (!$found) { \n    $newNode = array('val'=>$str[0],'children'=>array()); \n    $node['children'] []= $newNode; \n    $this->pushWord($node['children'][0],substr($str,1)); \n   } \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If dictionary is too big to use hashtable, you can use binary search tree. Definitely, to use in production you should either unsure that the tree is balanced(shuffle input for example) or implement balanced tree."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6234634354425856","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"45","title":"Given \"n\", generate all valid parenthesis strings of length \"2n\".  Example:  Given n=2  Output: (()) ()()","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"The code prints all forms without duplicates. This question (solution) is in \"Cracking the coding interview\" Book."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"C version:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Recursive version.   Keep track of how many open and close brackets are remaining.  Also keep track of number of open - number of closed used so far (called the balance_factor).  Python code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The code above looks correct. I am still posting the java version I wrote using a similar approach. The recursive implementation is in fact dynamic programming."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class NBrackets{ \n \n public static void main( String[] args ){ \n  sumCombination( \"\", Integer.parseInt( args[0] ) ); \n } \n \n static void sumCombination( String output, int sum ){ \n  if( sum == 0 ) { \n   generateOutput( output ); \n   return; \n  } \n  \n  for( int i = 1; i <= sum; i++ ){ \n   sumCombination( output + i, sum - i ); \n  } \n } \n  \n static void generateOutput( String output ){ \n  StringBuilder builder = new StringBuilder(); \n    \n  for( int i = 0; i < output.length(); i++){ \n   char c = output.charAt( i ); \n   builder.append( toBrackets( c - 48 ) ); \n  } \n   \n  System.out.println( builder.toString() ); \n } \n  \n static String toBrackets( int n ){ \n  StringBuilder builder = new StringBuilder(); \n  for( int i = 0; i < n; i ++ ){ \n   builder.append( \"(\" ); \n  } \n  for( int i = 0; i < n; i ++ ){ \n   builder.append( \")\" ); \n  } \n   \n  return builder.toString(); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Python code below:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nvoid printParanthesis(char *str,int index,int num,int open,int close) \n{ \n  if( open==close&&open==num) \n  { \n   printf(\"\\n %s\",str); \n     return; \n  } \n    \n   if(openclose) \n  { \n     \n     str[index]=')'; \n     printParanthesis(str,index+1,num,open,close+1); \n \n   } \n} \nint main() \n{ \n \nchar str[50]={'\\0'}; \n printParanthesis(str,0,3,0,0); \n \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Another C Program using \"BackTracking\""},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void generateValidParanthesis(int n, String s) { \n  if(n == 0) { System.out.println(s); return; } \n   \n   \n  String s1 = \"(\" + s + \")\"; \n  String s2 = \"()\" + s; \n  String s3 = s + \"()\" ; \n   \n  if(!s1.equals(s2) && !s1.equals(s3)) { \n   generateValidParanthesis(n-1, s1 ); \n  } \n  if(!s2.equals(s3)) { \n   generateValidParanthesis(n-1, s2); \n  } \n   \n  generateValidParanthesis(n-1,  s3 ); \n   \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Haha,how about this bit-flipping solution 1.define an int , i1, with n length bit initialized to 0 2.flip i1 to acquire i2 3. Starting from i2 , you read the two ints bit by bit,  print a left paran for a set bit and a right paran for an unset. 4. Increment i1, if the highest bit is still 0, print a line separator and loop back to step 2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Haha,how about this bit-flipping solution 1.define an int , i1, with n length bit initialized to 0 2.flip i1 to acquire i2 3. Starting from i2 , you read the two ints bit by bit,  print a left paran for a set bit and a right paran for an unset. 4. Increment i1, if the highest bit is still 0, print a line separator and loop back to step 2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Another C++ version"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def gen(n, left=0, right=0,index=0,str=\"\"): \n \n    if index == 2*n: \n        print(str) \n        return \n \n    if left < n: \n        gen(n, left+1, right, index+1, str+\"(\") \n \n    if right < left: \n        gen(n, left, right+1, index+1, str+\")\")"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def generateParenComb(left, right, left_stack, output): \n    if right == 0: \n        print output \n    if left > 0: \n        generateParenComb(left-1, right, left_stack+1, output+'(' )      \n    if right>0 and left_stack>0: \n        generateParenComb(left, right-1, left_stack-1, output+')') \n         \ndef topGenerateParenComb(num): \n    generateParenComb(num, num, 0, \"\")     \n \n \ntopGenerateParenComb(4)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"anyone knows the complexity?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ArrayList pairs(int n){ \n return pairs(n, n, \"\"); \n} \nArrayList pairs(int open, int close, String s){ \n ArrayList ret = new ArrayList(); \n if(open == 0){ \n  for(int i = 0; i open){ \n   ret.addAll(pairs(open, close-1, s+\")\"); \n  } \n } \n return ret; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import unittest \n \ndef paren(n): \n    if n == 0: yield \"\" \n    for i in xrange(n): \n        for j in paren(i): \n            for k in paren(n - i - 1): \n                yield j + \"(\" + k + \")\" \n \ndef generate(n): \n    print(\"Generating: 2 * {}\".format(n)) \n    for s in paren(n): \n        if len(s) == 2 * n: \n            print(s) \n \nclass Test(unittest.TestCase): \n    def test_generate(self): \n        generate(0) \n        generate(1) \n        generate(2) \n        generate(3) \n \nif __name__ == \"__main__\": \n    unittest.main()"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class ParanTest { \n public static void main(String[] args) { \n  buildParan(new StringBuilder(), 0, 0, 3); \n } \n  \n public static void buildParan(StringBuilder sb, int open, int close, int tot){ \n  if(close < open){ \n   StringBuilder newSb = new StringBuilder(sb.toString()); \n   newSb.append(')'); \n   int newClose = close; \n   if(++newClose == tot){ \n    System.out.println(newSb.toString()); \n   } \n   else{ \n    buildParan(newSb, open, newClose, tot); \n   } \n  } \n   \n  if(open < tot){ \n   int newOpen = open+1; \n   sb.append('('); \n   buildParan(sb, newOpen, close, tot); \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class AllBrackets { \n \n    public static void main(String... a) throws Exception { \n        printAll(Integer.parseInt(a[0])); \n    } \n \n    public static void printAll(int n) { \n        printAll(new char[2 * n], 0, 0); \n    } \n \n    private static void printAll(char[] c, int index, int level) { \n        if (index >= c.length) { \n            System.out.println(new String(c)); \n            return; \n        } \n        if (level > 0) { \n            c[index] = ')'; \n            printAll(c, index+1, level-1); \n        } \n        if (c.length - index > level) { \n            c[index] = '('; \n            printAll(c, index+1, level+1); \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"function printParanthesis(array $str,$index,$num,$open,$close) {     if($open == $close && $open == $num)     {         echo implode(\"\",$str).\"\\n\";         return;     }         if($open < $num)     {         $str[$index]='(';         printParanthesis($str,$index+1,$num,$open+1,$close);     }       if($open > $close)     {         $str[$index]=')';         printParanthesis($str,$index+1,$num,$open,$close+1);     }  }  //main $str = array(); $n = trim(fgets(STDIN)); printParanthesis($str,0,$n,0,0);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include using namespace std; int n; void f(int o,int c,string t){  if(o==n && c==n){cout<<<\"\\n\";}  else{   if(o+1<=n && o+1-c>=0){f(o+1,c,t+'(');}   if(c+1<=n && o-c-1>=0){f(o,c+1,t+')');}    } } int main(){  cin>>n;cout<<\"\\n\\n\";  string t;f(0,0,t); }  However this is a recursive solution.. I'm wondering if we can use memorization to solve it for a better time complexity..."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6321181669982208","download_status":"DOWNLOAD_DONE","votes":"6","answersCount":"37","title":"Given a number N, write a program that returns all possible combinations of numbers that add up to N, as lists. (Exclude the N+0=N)  For example, if N=4 return {{1,1,1,1},{1,1,2},{2,2},{1,3}}","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"c++ recursive version \n// practice.cpp : Defines the entry point for the console application. \n// \n \n#include \"stdafx.h\" \n#include \nusing namespace std; \n \n \nvoid combination(int n,int i,int k); \n \n \nvoid display(int * arr,int n) \n{ \n cout<<\"{\"; \n for(int i=0;i>n; \n  \n  \n    combination(n,0,n-1); \n \n system(\"pause\"); \n} \n \n \nvoid combination(int n,int i,int kk) \n{ \n  \n static int * arr=new int [kk]; \n  \n  if (n == 0) \n  { \n    display(arr, i); \n  } \n  else if(n > 0) \n  { \n    int k;  \n    for (k = 1; k <= kk; k++) \n    { \n      arr[i]= k; \n      combination(n-k, i+1,k); \n    } \n  } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"static void printAllPossibleSum(int n) \n        { \n            Queue> q = new Queue>(); \n \n            for (int i = 1; i <= n/2; i ++) \n            { \n                List l = new List(); \n                l.Add(i); \n                l.Add(n - i); \n                q.Enqueue(l); \n            } \n             \n            while(q.Count > 0) \n            { \n                List l = q.Dequeue(); \n                printList(l); \n                for (int i = l[l.Count - 2]; i <= l[l.Count -1]/2; i++) \n                { \n                    List a = new List(); \n                    for (int j = 0; j < l.Count -1; j ++) \n                    { \n                        a.Add(l[j]); \n                    } \n                    a.Add(i); \n                    a.Add(l[l.Count -1] - i); \n                    q.Enqueue(a); \n                } \n            } \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use this recursion:  makeSum(n, n-1), returns sets such that sum of its elements is n and the elements in the set are less than or equal to n-1.  makeSum(n, n-1) = CreateSet(n-1, n-1...i times) U ForEach set in (makeSum(n-i(n-1), n-2)), where 0 <= i <= n/(n-1)  makeSum(n, 1) = CreateSet(1,1,...n times)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"you start with 4 as {1,3} and recurse down with 3 next. you save the history of 1 so that you can reconstruct results as {1,1,2} in the next iteration . the code is below"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ODOMETER! WOO HOO!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Given a number N, write a program that returns all possible combinations of numbers that add up to N, as lists. \n//(Exclude the N+0=N)  \n//For example, if N=4 return {{1,1,1,1},{1,1,2},{1,3}} \n \n//if N = 6 ... expected results \n//1,1,1,1,1,1 \n//2,1,1,1,1 \n//2,2,1,1 \n//2,2,2 \n//3,1,1,1 \n//3,2,1 \n//3,3 \n//4,1,1 \n//4,2 \n//5,1 \n \n \nimport java.util.*; \n \nclass Solution { \n \n    public static void addNext(ArrayList> results, ArrayList list, int sum, int last, int target, boolean isFirst) { \n        if (sum == target) { \n         results.add(list); \n         return; \n        } \n             \n             \n        while (sum + last > target) { \n            last--; \n        } \n \n        int less = last - 1; \n        if ( !isFirst && less > 0 && less + last < target ) { \n         ArrayList copyList = new ArrayList(list); \n         addNext(results, copyList, sum, less, target, false); \n        } \n         \n        sum = sum + last; \n        list.add(last); \n         \n        addNext(results, list, sum, last, target, false); \n    } \n \n    public static void main(String[] args) { \n        int n = 6; \n        ArrayList> results = new ArrayList>(); \n         \n        ArrayList list; \n         \n        for (int i=1; i(); \n            addNext(results, list, 0, i, n, true); \n        } \n \n        print(results); \n          \n    } \n     \n    public static void print(ArrayList> results) { \n     for (ArrayList list: results) { \n      for (Integer i: list) { \n       System.out.print(String.format(\"%d \", i)); \n      } \n      System.out.println(\"\\n----------\"); \n     } \n    } \n     \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if N=4 return {{1,1,1,1},{1,1,2},{1,3}} why no {2,2}?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"my previous answer is wrong. it missed (2,2). but here is the correct and elegant solution. you start the recursion with target = 4,  solutionSpace = [1,2,3] and result = []  at each step of recursion you make a decision whether you want to include the first digit in the solution  space in the result or not. if you don't include the digit in result, remove it from solution space. if you include the first digit in the solution space, save the digit in the result and adjust the target. the recursion ends if target is zero or target is less than first digit in solution space or solution space is empty.. a thing of beauty !!!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Get all possible sets of 2 elements and store them as a list [the list is sorted as each element is greater than its predecessor] Enqueue all the lists in a a queue Store them as a List in  Queue  Dequeue the elements from the queue [and print a possible set] and expand the last element if it is 2 time or more than its previous one and store the resulting list back to queue, and loop until the queue is empty.  Here is the code in C#          static void printAllPossibleSum(int n)         {             Queue> q = new Queue>();              for (int i = 1; i <= n/2; i ++)             {                 List l = new List();                 l.Add(i);                 l.Add(n - i);                 q.Enqueue(l);             }                          while(q.Count > 0)             {                 List l = q.Dequeue();                 printList(l);                 for (int i = l[l.Count - 2]; i <= l[l.Count -1]/2; i++)                 {                     List a = new List();                     for (int j = 0; j < l.Count -1; j ++)                     {                         a.Add(l[j]);                     }                     a.Add(i);                     a.Add(l[l.Count -1] - i);                     q.Enqueue(a);                 }             }         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java based on Umer Javaid answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use simple recursion. There are two cases: 1) Include the given number in the sum 2) Exclude the number from the sum and proceed to next number Code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Objective-C, iOS solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is the partition problem (wikipedia.org/wiki/Partition_(number_theory)).  Does the following help someone? 1111111 (n=1) ======= 111112  (n=2) ====== 11113 (n=3) ===== 11122 1114 (n=4) ==== 1123 115 (n=5) === 1222 124 133 16 (n=6) == 223 25 34 7 (n=7)  The number of lines is the number of possible partitions and the list of partitions for each n. So the algorithm is recursive, computing the partitions for n-1, running over them and adding 1 to the left of the of each partition. In addition, we add all partitions that have incremental values starting with 2. I'm stuck with calculation the incremental final part :(  BTW, my email is kilaka at gmail.com :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void decomposition (int N){ \n  System.out.println(decomp(N-1,N).toString()); \n } \n public static LinkedList> decomp (int max, int N){ \n  LinkedList> res = new LinkedList>(); \n  if (N==0){ \n }else{ \n  for (int i=max; i>0;i--){ \n   ajouter (res,i,decomp(Math.min(i, N-i),N-i)); \n  } \n } \n return res; \n } \n  public static void ajouter(LinkedList> res, int a, LinkedList> aux){ \n   LinkedList l = new LinkedList(); \n   if (aux.isEmpty()){ \n    l.add(a); \n    res.add(l); \n   }else{ \n   for (int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"An other solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"define m = max {m1, m2, m3, ...mi} n = m1 + m2 + m3 ...mi  if n == 1 || m == 1  then  f(n, m) = 1 if n == m then f(n, m) = 1 + f(n, m-1) if n > m then f(n, m) = f(n -m, m) + f(n, m-1)  recursive itself."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algorithm from page 392 of The Art of Computer Programming, Volume 4A."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Python code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public ArrayList< ArrayLIst< Integer> > generate( int n, int lb ){ \n ArrayList< ArrayList< Integer> > allSols = new ArrayList< new ArrayList< Integer >() >(); \n for( int k = lb; k < n/2 + 1; k ++ ){ \n  ArrayList< ArrayList< Integer > > subSols = generate( n - k, k ); \n  for( ArrayList< Integer > subsol : subSols ) \n   allSols.add( subsol.add( 0, (Integer) k ) ); \n } \n return allSols; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class TestEnumN { \n    static int N = 10; \n    static int solution = 0; \n    static Stack sol=new Stack(); \n \n    public static void main(String args[]) { \n        enumeratePaths(N, 1); \n        System.out.println(solution); \n    } \n \n    public static void enumeratePaths(int n, int start) { \n        if(n==0/*is solution*/){ \n            solution++; \n            System.out.println(\"sol = \" + sol); \n            return; \n        } \n        while (n>0 && start <= n && start != N) { \n            for (int j = 1; j <= Math.ceil(n / start); j++) { \n                for(int k=0;k"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ruby 2.0.0 implementation"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ruby 2.0.0 implementation updated with non exponential time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void Trace(std::vector > & rs, std::vector & path, int c, int t) { \n  if (c == t) rs.push_back(path); \n  if (c >= t) return; \n  for (int i = 1; i < t; i++) { \n    path.push_back(i); \n    Trace(rs, path, c + i; t); \n    path.pop_back(); \n  } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my code in Objective-C"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my code in Objective-C"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"C++"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  #include   using namespace std; //10:24  vector >& all_combinations(int N,int prev,vector v,vector > &v_prime) {     if(N < 0)     return v_prime;     if(N == 0)     {         //Print and return         v_prime.push_back(v);         return v_prime;     }     v.push_back(0);//dummy element     for(int i=prev;i>0;i--)     {         v.pop_back();         v.push_back(i);         all_combinations(N-i,i,v,v_prime);     } }  //10:33 void print_vect(vector &v) {  int i=0,size = v.size();  for(i =0 ;i < size;i++)   printf(\"%d \", v[i]);  printf(\"\\n\"); } void print_vects(vector > &v) {  int i,size=v.size();  for(i=0;i  print_vect(v[i]); }  int main(int argc, char const *argv[]) {  vector > u;//empty vector of vector  vector v;//empty vector;  all_combinations(8,8-1,v,u);  print_vects(u);  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \n \nusing namespace std; \n//10:24 \n \nvector >& all_combinations(int N,int prev,vector v,vector > &v_prime) \n{ \n    if(N < 0) \n    return v_prime; \n    if(N == 0) \n    { \n        //Print and return \n        v_prime.push_back(v); \n        return v_prime; \n    } \n    v.push_back(0);//dummy element \n    for(int i=prev;i>0;i--) \n    { \n        v.pop_back(); \n        v.push_back(i); \n        all_combinations(N-i,i,v,v_prime); \n    } \n} \n \n//10:33 \nvoid print_vect(vector &v) \n{ \n int i=0,size = v.size(); \n for(i =0 ;i < size;i++) \n  printf(\"%d \", v[i]); \n printf(\"\\n\"); \n} \nvoid print_vects(vector > &v) \n{ \n int i,size=v.size(); \n for(i=0;i > u;//empty vector of vector \n vector v;//empty vector; \n all_combinations(8,8-1,v,u); \n print_vects(u); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \n \nusing namespace std; \n//10:24 \n \nvector >& all_combinations(int N,int prev,vector v,vector > &v_prime) \n{ \n    if(N < 0) \n    return v_prime; \n    if(N == 0) \n    { \n        //Print and return \n        v_prime.push_back(v); \n        return v_prime; \n    } \n    v.push_back(0);//dummy element \n    for(int i=prev;i>0;i--) \n    { \n        v.pop_back(); \n        v.push_back(i); \n        all_combinations(N-i,i,v,v_prime); \n    } \n} \n \n//10:33 \nvoid print_vect(vector &v) \n{ \n int i=0,size = v.size(); \n for(i =0 ;i < size;i++) \n  printf(\"%d \", v[i]); \n printf(\"\\n\"); \n} \nvoid print_vects(vector > &v) \n{ \n int i,size=v.size(); \n for(i=0;i > u;//empty vector of vector \n vector v;//empty vector; \n all_combinations(8,8-1,v,u); \n print_vects(u); \n return 0; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5177378863054848","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"45","title":"Write a function for retrieving  the total number of substring palindromes. For example the input is 'abba'  then the possible palindromes= a, b, b, a, bb, abba So the result is 6.  Updated at 11/11/2013: After the interview I got know that the O(n^3) solution is not enough to go to the next round. It would have been better to know before starting implementing the solution unnecessarily ...","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"import java.io.BufferedReader; \nimport java.io.IOException; \nimport java.io.InputStreamReader; \n \n \npublic class Banana { \n \n public static void main(String[] args) throws IOException { \n  BufferedReader inp = new BufferedReader(new InputStreamReader(System.in)); \n  String line = inp.readLine(); \n  for(int i = 0 ; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Manacher's algorithm can be modified to get an O(n) time solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First solutions that comes to mind:  C++:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"function allpalindromes(str) { \nvar len = str.length; \n//case 1 div at gap \"abc^cba\" i=3 \nfor(var i=1;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The solution to this problem may base on the dynamic programming approach to palindrom finding (google it, as there is plenty of implementation). Then when we have a table P[i][j] and it's value is greater than zero, we know the value between i and j in the original string is a palindrom, so we may print it. The solution would be O(n^2)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"let the sting of length(n)  the for each char index x we check(assuming it is the center element in palindrone) that for iif index char[x] ==char[ x--] ||char[x]==char[x++] then we need to do another search assuming length of palin is even x is one of the mid elements another (n/2) comparison at max  now if we know [i,j] the limits of palindrone with x as the centre element  then number of palinds = summation of over all elements( if(j-i == even)? (j-i) /2 : (j-j+3)/2)  complexity = n*(3n/2) = n^2   As i read more on this , this is similar to Manacher's algorithm which can construct[i,j] in linear time and also inserts # to make sure all palin substring are odd length .. so  yes the complexity can be reduced to O(n)  O(n) solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ajeet stop voting down my code.  Your code stinks."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/** \n *  \n * @author Marcelo Filho \n * @email marcelolfilho@gmail.com \n * @facebook facebook.com/idemax.green \n *  \n */ \npublic class PalindromePratice { \n \n    /** \n     * Buffer of results to be displayed. \n     */ \n    private static StringBuilder strB; \n \n    /** \n     * Main called by Java. \n     *  \n     * @param args \n     */ \n    public static void main( final String[] args ) { \n        PalindromePratice.palindrome( \"abba\" ); \n    } \n \n    /** \n     * Add some {@link String} to result buffer. \n     *  \n     * @param value \n     */ \n    private static void addToBuffer( final String value ) { \n        if ( PalindromePratice.strB == null ) { \n            PalindromePratice.strB = new StringBuilder(); \n        } \n \n        PalindromePratice.strB.append( value ); \n        PalindromePratice.strB.append( ',' ); \n    } \n \n    /** \n     * Display results in buffer. \n     */ \n    private static void displayResults() { \n        if ( PalindromePratice.strB != null ) { \n            PalindromePratice.strB.deleteCharAt( PalindromePratice.strB.length() - 1 ); \n            System.out.println( PalindromePratice.strB.toString() ); \n        } \n    } \n \n    /** \n     * Scan for palindromes. \n     *  \n     * @param value \n     *            {@link String} with two or more chars. \n     */ \n    private static void palindrome( final String value ) { \n        PalindromePratice.palindrome( value, true ); \n        PalindromePratice.displayResults(); \n    } \n \n    /** \n     * Scan for palindromes. \n     *  \n     * @param value \n     *            {@link String} with two or more chars. \n     * @param recursive \n     *            If algorithm has to scan recursively. \n     */ \n    private static void palindrome( final String value, final boolean recursive ) { \n        final int valueLen = value.length(); \n \n        if ( valueLen > 0 ) { \n            final int halfValueLen = valueLen / 2; \n            boolean isPalindrome = true; \n \n            if ( recursive ) { \n                int wordSize = 1; \n \n                for ( int i = 0; i < valueLen; i++ ) { \n                    while ( ( wordSize < valueLen ) && ( i <= wordSize ) ) { \n                        PalindromePratice.palindrome( value.substring( i, wordSize++ ), false ); \n                    } \n \n                    wordSize = 1; \n                } \n            } \n \n            for ( int i = 0, j = ( valueLen - 1 ); i <= halfValueLen; i++, j-- ) { \n                isPalindrome = value.charAt( i ) == value.charAt( j ); \n \n                if ( !isPalindrome ) { \n                    break; \n                } \n            } \n \n            if ( isPalindrome ) { \n                PalindromePratice.addToBuffer( value ); \n            } \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package com.egain.platform.module.kb.workflow;  public class NumberOfParliments {   /**   * @param args   */  public static void main(String[] args)  {   System.out.println(findNumberOfPalindromes(\"abbc\"));  }   public static int findNumberOfPalindromes(String a)  {    int sum = 0;   if (a.length() > 0)   {    char c = a.charAt(0);    for (int i = 0; i < a.length(); i++)    {     if (a.charAt(i) == c)     {      if (isPalindrome(a.substring(0, i + 1)))      {       sum = sum + 1;      }      }     }     return sum = sum + findNumberOfPalindromes(a.substring(1));   }    return 0;   }   private static boolean isPalindrome(String s)  {    if (s.length() == 1)   {    return true;   }   else if (s.length() > 1)   {    boolean bool = s.charAt(0) == s.charAt(s.length() - 1);    return bool && isPalindrome(s.substring(1, s.length() - 1));   }   else    return true;   } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package com.egain.platform.module.kb.workflow;  public class NumberOfParliments {   /**   * @param args   */  public static void main(String[] args)  {   System.out.println(findNumberOfPalindromes(\"abbc\"));  }   public static int findNumberOfPalindromes(String a)  {    int sum = 0;   if (a.length() > 0)   {    char c = a.charAt(0);    for (int i = 0; i < a.length(); i++)    {     if (a.charAt(i) == c)     {      if (isPalindrome(a.substring(0, i + 1)))      {       sum = sum + 1;      }      }     }     return sum = sum + findNumberOfPalindromes(a.substring(1));   }    return 0;   }   private static boolean isPalindrome(String s)  {    if (s.length() == 1)   {    return true;   }   else if (s.length() > 1)   {    boolean bool = s.charAt(0) == s.charAt(s.length() - 1);    return bool && isPalindrome(s.substring(1, s.length() - 1));   }   else    return true;   } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{{ import java.util.ArrayList; import java.util.List;  import org.junit.Assert; import org.junit.Test;   public class Palindromes {    public int countPal(String str){   int count = 0;   for(int i=0; i   for(int j=i+1; j<=str.length(); j++){     String term = str.substring(i, j);     if(isPal(term)){      count++;     }    }   }   return count;  }    public boolean isPal(String t){   StringBuilder rev = new StringBuilder();   char[] chars = t.toCharArray();   for(int i=chars.length-1; i>=0; i--){    rev.append(chars[i]);   }   return t.equals(rev.toString());  }    @Test  public void testCountPal(){   Assert.assertEquals(6, countPal(\"abba\"));     Assert.assertEquals(1, countPal(\"b\"));     Assert.assertEquals(3, countPal(\"bb\"));     Assert.assertEquals(6, countPal(\"bbab\"));     Assert.assertEquals(6, countPal(\"aacc\"));    }    @Test  public void testIsPal(){   Assert.assertTrue(isPal(\"abba\"));   Assert.assertTrue(isPal(\"aa\"));   Assert.assertTrue(isPal(\"a\"));   Assert.assertFalse(isPal(\"ac\"));  }  } }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void combinationPalindrome(string ms) \n{ \n    int length = (int)ms.length(); \n    int count = length; \n    int offset =1, left = 1, right = 0; \n \n    for(int i=1; i=0) && (i+offset < length) && ms[i-offset] == ms[i+offset]) \n            { \n                cout<<<\"Odd \"<=0) && (i+right < length) && ms[i-left] == ms[i+right]) \n            { \n                cout<<<\"Even \"<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this my working code, written in c"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1 #include   2    3 int main(void)   4 {   5     char str[100];   6     int i, m, n, len, Count;   7    8     scanf(\"%s\", str);   9   10     len = 0;  11     while(str[len])  12         len++;  13   14     Count = 0;  15   16     for(i = 0; i < len - 1; i++)  17     {  18         m = i;  19         n = i + 1;  20   21         while(m >= 0 || n < len)  22         {  23             if(str[m--] == str[n++])  24                 Count++;  25             else  26                 break;  27         }  28     }  29   30     printf(\"%d\\n\", Count);  31   32     return 0;  33 }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Expand along every possible center n-1 spaces and n-2 characters and traverse along both directions to see if characters on both the sides are equal. Total time is O(n2). Example a|b|c|b|a|d space centers are given by | symbol and character centers will be b,c,b,a.. Another algorithm is also possible in O(n) time, called manacher's algorithm. It is available on leetcode.com"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This problem can be resolved using dynamic programming."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Dynamic programming : O(n?) in time and O(n) in space. Count separately palindromes depending on their lengths' parities.  Java :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the string is S and its reverse is S', consider the set of all suffixes of  S and all suffixes of S'. For each suffix of S, append a special character $ to the end. For each suffix of S', append a special character # to the end. Now build the trie corresponding to this set of suffixes. In this tree, every node that has both special symbols as children corresponds to a palindromic substring of S (namely, that string obtained by concatenating the edges of the unique path from the node to the root of the tree).  There is a (very clever) algorithm for building a suffix tree in linear time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def findpals(string, cut = 0): \n    \"\"\"                                                                                                \n    Summation(N - k) from k = 0 to k = N                                                               \n    O(N^2)                                                                                             \n    \"\"\" \n    i = 0 \n    j = i + cut \n \n    if j > len(string): \n        return \n \n    while j < len(string): \n        sliced = string[i:j+1] \n        if sliced == sliced[::-1]: \n            print sliced \n        i += 1 \n        j = i + cut \n \n    findpals(string, cut + 1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Not the best thing ever, but here is a python implementation in a very simple manner:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I could be solved using dynamic programming algorithm and extend the idea of given by   shuaixin.david.  We will use this recurrence relation P(i,j) = true if the string is palindrome between index i and j. P(i,j) = P(i+1,j-1) As a base case we to calculate all of the palindromes with length 1(for odd case) and 2(for even case). So, we will calculate P(i,i) and P(i,i+1) for all i. Now, we will calculate the P(i,j) with growing difference between j. So, we will calculate P(i)(i+2) then P(i)(i+3) in this manner.  For all the P(i,j) we get true we will increment the count and return the count which is the all the substring palindromes possible."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"void printPal(string s, int start, int end) \n{ \n //first check whether the given string is a palindrome \n if (isPalindrome(substring(s, start, end - start + 1))) \n { \n  println(s); \n } \n \n for (int i = start; i < end; i++) \n { \n  //recursively call this function on all splits of the given string \n  printPal(s, start, i); \n  printPal(s, i + 1, end); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"void LongestPalindromic(char *s) \n{ \n if(!*s) \n { \n  printf(\"\\nNull String\\n\"); \n  return; \n } \n int TotalPalindromes=0; \n int n=strlen(s); \n int i,len,maxlen,longestBegin; \n bool t[30][30]={false}; \n \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Solution in plain C:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"int cntP(char[] A){ \n int total = 0; \n int[][] B = new int[A.length+1][A.length]; \n for(int j = 0; j< A.length; j++){ \n  B[0][j] = 1; \n  B[1][j] = 1; \n  total += 1; \n } \n for(int i = 2; i<=A.length; i++){ \n  for(int j = 0; j<= A.length-i; j++){ \n   if(A[j] == A[j+i-1]){ \n    B[i][j] = A[i-2][j+1]; \n    total += B[i][j]; \n   } else{ \n    B[i][j] = 0; \n   } \n  } \n } \n return total; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Easy Java Solution::  String[] s = \"AmanaplanacanalPanama\".split(\"\");      for (int i = 1; i < s.length / 2; i++)      {       int l = s.length-i;          if (s[i].equalsIgnoreCase(s[l]))            System.out.println(\"Machhed \"+i+\" \"+ l+\" \"+s[i]+\" \"+s[l]);          else           System.out.println(\"Failed\");      }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public static void palindrome(){ \n  String[] s = \"AmanaplanacanalPanama\".split(\"\"); \n     for (int i = 1; i < s.length / 2; i++) \n     { \n      int l = s.length-i; \n         if (s[i].equalsIgnoreCase(s[l]))  \n          System.out.println(\"Machhed \"+i+\" \"+ l+\" \"+s[i]+\" \"+s[l]); \n         else \n          System.out.println(\"Failed\"); \n     } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public int Question1(string palindrom){                          int count = 0;               for (int i = 0; i < palindrom.Length; i++)              {                  //int length = pallArr.Length - i;                  for (int j = 1; j <= palindrom.Length - i; j++)                  {                      //if (pallArr[i] == pallArr[j])                       string pal = palindrom.Substring(i, j);                      if (IsPalindrom(pal))                      {                          count++;                          Console.WriteLine(pal);                      }                  }                            }               return count;          }           public bool IsPalindrom(string str) {               bool isPalindrom = true;               int startInd = 0;              int endInd = str.Length-1;               for (int i = startInd; i < endInd; i++)              {                   if (str[startInd] != str[endInd])                  {                      isPalindrom = false;                      return isPalindrom;                  }                   startInd++;                  endInd--;              }               return isPalindrom;          }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Recursive with memoization for backtracking/pruning trees."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"function palindrome(inputString){ \n    var palindromes = []; \n \n    for(var i = 0; i < inputString.length; i++){ \n        for(var j = 1; j <= (inputString.length - i); j++){ \n            if(inputString.substring(i, j+i) == inputString.substring(i, j+i).split(\"\").reverse().toString().replace(/,/gm,\"\")){ \n                palindromes.push(inputString.substring(i, j+i)); \n            } \n        }  \n    }    \n \n    return palindromes;  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This is O(n+p) solution where p is the number of palindromes"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Agree to Joe kidd, should use dynamic programming.  Java code:   public static int numOfPalin(String s) {     boolean[][] dp = new boolean[s.length()][s.length()];     int count = 0;     for (int i = s.length() - 1; i >= 0; i--) {       for (int j = i; j < s.length(); j++) {          if (j - i < 2 && s.charAt(i) == s.charAt(j))           dp[i][j] = true;         if (i < s.length() - 1 && j > 0           && dp[i + 1][j - 1]           && s.charAt(i) == s.charAt(j))           dp[i][j] = true;         if (dp[i][j]) {            count++;         }       }     }      return count;   }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4907555595747328","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"26","title":"Given a set of n points (coordinate in 2d plane) within a rectangular space, find out a line (ax+by=c), from which the sum of the perpendicular distances of all the points will be minimum. This can has a general usecase like, in a village there are few house, you have to lay a road, such that sum of all the approach roads from each house will be minimum.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"FYI, this is regression analysis using orthogonals.  Seems to be a rather difficult question to be answered over the phone if you don't know the math behind it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"link: theory.stanford.edu/~megiddo/pdf/leastdis.pdf   I think the first proof in this paper suggests a O(n^3) algorithm by showing an optimal line lies along at least two points. Moreover, they give a more efficient algorithm. May be worth the read for those stuck (like me)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"it can be solved in O(n^2), for each pair of points form a line, {as if a point is on line perpendicular distance is zero (minimum)}, calculate perpendicular distance from each point not in pair to the current line O(constant) Distance_from_a_point_to_a_line in wiki,  sum it and compare it to min sum found so far,  for the minimum sum print out line found from the two points"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Which location and what job title was the interview? Curious."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We are trying to minimize the sum of the distances from the points to the line. So the objective function is:  $$\\min \\sum_{i = 1}^n (axi + byi - c)^2$$  We can expand it to be:  $$\\min \\sum_{i = 1}^n (xi^2a^2 + yi^2b^2 + c^2 + 2xiyi ab - 2xi ac - 2yi bc)$$  Let $$X = \\sum_{i = 1}^n xi^2, Y = \\sum_{i = 1}^n yi^2, C = \\sum_{i = 1}^n 2xiyi, B = \\sum_{i = 1}^n -2xi, A = \\sum_{i = 1}^n -2yi $$  Then the objective function is:  $$\\min Xa^2 + Yb^2 + c^2 + C ab + B ac + A bc$$  Therefore, we only need to solve the following equations:  $$ 2X a + C b + B c = 0 2Y b + C a + A c = 0 2 + B a + A b = 0 $$  Therefore, the algorithm is to compute the X, Y, A, B, C first, which is O(n). Then solve the linear equations, which is O(1).  The output of the algorithm is (a, b, c)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.awt.Point; \nimport java.util.ArrayList; \n \n/** \n *  \n * @author Marcelo Filho \n * @email marcelolfilho@gmail.com \n * @facebook facebook.com/idemax.green \n *  \n */ \npublic class LessDistBetNPoints { \n \n    /** \n     * @param args \n     */ \n    public static void main( final String[] args ) { \n        final ArrayList nPoints = new ArrayList(); \n \n        nPoints.add( new Point( 1, 2 ) ); \n        nPoints.add( new Point( 3, 1 ) ); \n        nPoints.add( new Point( 4, 1 ) ); \n        nPoints.add( new Point( 6, 2 ) ); \n        nPoints.add( new Point( 6, 4 ) ); \n        nPoints.add( new Point( 4, 3 ) ); \n        nPoints.add( new Point( 2, 4 ) ); \n        nPoints.add( new Point( 4, 6 ) ); \n        nPoints.add( new Point( 7, 6 ) ); \n        nPoints.add( new Point( 7, 1 ) ); \n \n        LessDistBetNPoints.findOutALine( nPoints ); \n    } \n \n    private static void findOutALine( final ArrayList nPoints ) { \n        final int nPointsSize = nPoints.size(); \n        final ArrayList lessWalkWay = new ArrayList(); \n        Point lastPoint, currentPoint, nextCandidate; \n        int currentNPointsSize; \n        double distBetPoints, lessDist, minDist = 0; \n \n        lessWalkWay.add( nPoints.remove( 0 ) ); \n \n        while ( nPoints.size() > 0 ) { \n            lastPoint = lessWalkWay.get( lessWalkWay.size() - 1 ); \n            currentNPointsSize = nPoints.size(); \n            lessDist = Double.MAX_VALUE; \n            nextCandidate = null; \n \n            for ( int i = 0; i < currentNPointsSize; i++ ) { \n                currentPoint = nPoints.get( i ); \n                distBetPoints = Math.abs( Math.sqrt( Math.pow( ( lastPoint.x - currentPoint.x ), 2 ) + Math.pow( ( lastPoint.y - currentPoint.y ), 2 ) ) ); \n \n                if ( distBetPoints < lessDist ) { \n                    lessDist = distBetPoints; \n                    nextCandidate = currentPoint; \n                } \n            } \n \n            if ( nextCandidate != null ) { \n                lessWalkWay.add( nPoints.remove( nPoints.indexOf( nextCandidate ) ) ); \n                minDist += lessDist; \n            } \n        } \n \n        final StringBuilder strB = new StringBuilder(); \n \n        for ( int i = 0; i < nPointsSize; i++ ) { \n            currentPoint = lessWalkWay.get( i ); \n \n            strB.append( \"{\" ); \n            strB.append( currentPoint.x ); \n            strB.append( \",\" ); \n            strB.append( currentPoint.y ); \n            strB.append( \"}\" ); \n            strB.append( \",\" ); \n        } \n \n        strB.deleteCharAt( strB.length() - 1 ); \n \n        System.out.println( \"Minimum route: \" + strB.toString() ); \n        System.out.println( \"Minimum route: \" + minDist ); \n \n        // Minimum route: {1,2},{3,1},{4,1},{4,3},{6,2},{7,1},{6,4},{7,6},{4,6},{2,4} \n        // Minimum route: 20.113122279787035 \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This problem  can be solved by total least squares method. If in 2 plane, its equation can be computed exactly."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Rotate the axes so that x axis is parallel to the line. Find the median of all y values in the rotated version. Rotate back and find the equation of line that passes through this median."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5690879515820032","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"57","title":"Given an array, remove the duplicates and return a unique array keeping the first occurrence of the duplicates and the order.  [@2, @1, @3, @1, @2] --> [@2, @1, @3]","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"Manually like this.   Whenever you think of \"have I seen it before\" problems, think \"hash tables.\"   h is hash table for elements in your array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"# Python \n \narray = [\"@2\", \"@1\", \"@3\", \"@1\", \"@2\"] \nresult = [] \n \nfor item in array: \n    if item not in result: \n        result.append(item) \n \nprint result"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Didn't read all these this might have already been done this way, but here it is in Ruby"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void removeDup(int[] a)  {   int N =a.length;   int r=0;   ArrayList arrayList = new ArrayList();   for(int i =0;i  {            if((r&(1<   r+=(1<   arrayList.add(a[i]);   }   System.out.println(arrayList);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ArrayList removeDup(int[] A){ \n HashMap map = new HashMap (); \n ArrayList ret = new ArrayList(); \n for(int i = 0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"One way to solve it in java: 1. go through all the items in the list. 2. Check if the item is in a hashmap or set, if it's true, ignore it. Otherwise, put the item to the map and append it to an ArrayList"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n#include \n#include \n \nusing namespace std;  \nint removeDuplicate(int arr[],int len){ \n long  positive = 0L; \n long  negative = 0L; \n int i, j =0; \n for(i=0;i=0){ \n   if(positive&1<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n#include \n#include \n \nusing namespace std;  \nint removeDuplicate(int arr[],int len){ \n long  positive = 0L; \n long  negative = 0L; \n int i, j =0; \n for(i=0;i=0){ \n   if(positive&1<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class Program \n    { \n        static void Main(string[] args) \n        { \nstring[] arr = { \"@2\", \"@1\", \"@3\", \"@1\", \"@2\" }; \n            string[] arr2 = iQ.myFunction(arr); \n            foreach (string str in arr2) \n                Console.Write(\"[\" + str + \"]\"); \n \n            Console.ReadLine(); \n} \n \n} \n \npublic string[] myFunction(string[] strArr) { \n             List strList = new List(); \n             string[] tempStr = {}; \n \n             for (int i = 0; i < strArr.Length; i++) { \n \n                 for (int j = i; j < strArr.Length; j++) {  \n                     if(!strList.Contains(strArr[j])) \n                        strList.Add(strArr[j]); \n                                    \n                 } \n              \n             } \n \n             tempStr = strList.ToArray(); \n             \n             return tempStr; \n         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nmain() \n{ \n int i; \n int a[]={11,2,3,3,11,34,2,3,54,34,10,32,32,54}; \n int b[10]; \n for(i=0;i<14;i++) \n { \n  b[a[i]]=0; \n  } \n  for(i=0;i<14;i++) \n  { \n   if(b[a[i]]==0) \n   printf(\"%d \",a[i]); \n   b[a[i]]=1; \n  } \n  getch(); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nmain() \n{ \n int i; \n int a[]={11,2,3,3,11,34,2,3,54,34,10,32,32,54}; \n int b[10]; \n for(i=0;i<14;i++) \n { \n  b[a[i]]=0; \n  } \n  for(i=0;i<14;i++) \n  { \n   if(b[a[i]]==0) \n   printf(\"%d \",a[i]); \n   b[a[i]]=1; \n  } \n  getch(); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"- (NSMutableString *) removeDuplicates:(NSString *) string \n        if(string && [string length] > 1){ \n            NSMutableString *stringMutable = [string mutableCopy]; \n            CFMutableBitVectorRef charExists = CFBitVectorCreateMutable(kCFAllocatorDefault,0); \n            unsigned int index = 0; \n \n            while( index < [stringMutable length]) \n            { \n                if(CFBitVectorGetBitAtIndex(charExists,[stringMutable characterAtIndex:index]) == 0){ \n                    CFBitVectorFlipBitAtIndex(charExists,[stringMutable characterAtIndex:index]); \n                    index++; \n                } else { \n                    [stringMutable deleteCharactersInRange:NSMakeRange(index,1)]; \n                } \n                 \n            } \n            NSLog(@\"%@\",stringMutable); \n        } else { \n            return string; \n            NSLog(@\"Nothing to be done here\"); \n        } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java:  public static void main(String args[]) {         ArrayList list = new ArrayList();         list.add(\"A\");         list.add(\"B\");         list.add(\"A\");         list.add(\"C\");         list.add(\"B\");                  ArrayList newList = new ArrayList();         for(String string : list){             if(!newList.contains(string)){                 newList.add(string);             }         }         System.out.println(newList);     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static String[] getUniqueArray(String[] arr) { \n  String[] buffer = new String[arr.length]; \n  Set set = new HashSet(); \n  for (int i = 0; i < arr.length; i++) { \n   if (set.contains(arr[i])) \n    continue; \n   else { \n    set.add(arr[i]); \n    buffer[i] = arr[i]; \n   } \n  } \n  return buffer; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \n \nusing namespace std; \n \nvoid removeDups(list & values) \n{ \n    unordered_set seenValues; \n    list::iterator iter = values.begin();  \n     \n    while(iter != values.end()) \n    { \n        if(seenValues.find(*iter) == seenValues.end()) \n        { \n            seenValues.insert(*iter); \n            iter ++; \n        } \n        else \n        { \n            iter = values.erase(iter); \n        }     \n    } \n} \n \nint main() \n{ \n    list values; \n    values.push_back(1); \n    values.push_back(1); \n    values.push_back(4); \n    values.push_back(6); \n    values.push_back(5); \n    values.push_back(4); \n    values.push_back(5); \n    values.push_back(0); \n    values.push_back(6); \n    values.push_back(7); \n    values.push_back(7); \n    values.push_back(7); \n     \n    removeDups(values); \n     \n    for(list::iterator iter = values.begin(); iter != values.end(); iter ++) \n    { \n        printf(\"%d \",*iter); \n    } \n     \n    return 0; \n     \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int Remove(std::vector & v) { \n  int k = -1; \n  std::set seen; \n  for (int i = 0; i < v.size(); i++) { \n    if (seen.count(v[i])) continue; \n    seen.insert(v[i]); \n    v[++k] = v[i]; \n  } \n  return k + 1; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"in perl:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a one-liner in Python."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#Objective-C      for(int i=0; i<[array count]; i++) {        [array removeObject:array[i] inRange:NSMakeRange(i+1,[array count]-i-1)];     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"-(NSArray *)removeDuplicates:(NSArray *)uncheckedArray{ \n    NSMutableSet *checkList = [NSMutableSet set]; \n    NSMutableArray *uniqueArray  = [NSMutableArray array]; \n    for (id object in uncheckedArray) { \n        BOOL isDuplicate = [checkList containsObject:object]; \n        if (!isDuplicate) { \n            [checkList addObject:object]; \n            [uniqueArray addObject:object]; \n        } \n    } \n    return [uniqueArray copy]; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"int k=0,i=0;  a[k++]=a[i];  while(i{     if((a[i]!=a[i+1])&&(notcomesbefore()))        a[k++]=a[i+1];  i++;  }  notcomesbefore() {   use hash table   ..........//hash table is initialised to zero  if(hash array has value 1)      //this value is already taken              return 0;  else    return 1;   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"List numList = new ArrayList(); \n   \nfor(int i = 0; i < a.length; i++) \n{ \n    if(!numList.contains(a[i])) \n    { \n    numList.add(a[i]); \n    }    \n} \n   \nSystem.out.println(numList);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"+(NSArray*)removeDuplicates:(NSArray*)array {  NSMutableOrderedSet *set = [[NSMutableOrderedSet alloc]init];  for (NSString *str in array) {   if (![set containsObject:str]) {    [set addObject:str];   }    }    return [set array]; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I would like to use LinkedHashMap to hold values from array one by one, this way, no dups will be stored, while order will be maintained:    public void removeDup(String[] strArr){   LinkedHashMap linkedhmap = new LinkedHashMap();   for (int i=0; i   linkedhmap.put(strArr[i], 1);   }      Iterator iter = linkedhmap.keyset().iterator();   while (iter.hasNext()){    System.out.println(iter.next());   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"void RemoveDuplicate(int *a) \n{ \nif(a==NULL) \n  return; \nint *q=a; \nn=sizeof(a)/sizeof(a[0]); \nint *tb=new int[n+1]; \nmemset(t,0,sizeof(int)*(n+1)); \nvectorvec; \nint cnt=0; \nwhile(cnt::iterator p=vec.begin(); \nwhile(p!=vec.end()) \n cout<<*p++<<\"\\t\"; \ncout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"+(NSArray*)removeDuplicateNumbers \n{ \n NSArray *array = @[@\"2\",@\"1\",@\"3\",@\"1\",@\"2\"]; \n NSMutableOrderedSet *set = [[NSMutableOrderedSet alloc]init]; \n for (NSString *str in array) { \n  if (![set containsObject:str]) { \n   [set addObject:str]; \n  }   \n } \n   return [set array]; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"This can be achieved using Hashset for example in C#, add items to HashSet from beginning to end and print them using either foreach loop or HashSet.elementAt(): for example:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"I can think of 4 solutions as of now: Solution 1: Time O(nlogn) Space O(1) Sort the array using quicksort. Traverse the array if the consecutive values are same then remove it and keep shifting the corresponding further values.  Solution 2: Time O(n) Space O(n) Use hashmap to store the value while traversing the array. If value is already present then remove the element,  Solution3: Time O(n2) Space O(1) Use two for loops (Brute force method)  Solution 4: Time O(n) Space O(Max value in an array) Find the largest element in the array  ( considering @ can be ignored since its constant for all the values). Create an array of that size. Iterate the given array and mark the corresponding index in the new array as visited. If value is already marked visited then it is the duplicate."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"C#"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4798365246160896","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"43","title":"Question was on Arithmetic progression  Example :  Given the AP :- 1 3 7 9 11 13 find the missing value \"which would be 5 here\".  Conditions :  Get an user for the length of AP sequence and make sure user provides length is above 3. Get the input in a single line ex:- \"1 3 5 7 9 11\" Provide the solution in O(n) or less if you can.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Considering that only one value is missing.   Method 1: Find the sum(S) of AP using:  S = (N/2)(First Term + Last Term);  First Term = a;  Last Term = a+(N-1)*(Delta);  where N = Number of terms in AP,   and, Delta is the difference between any two consecutive terms.  Hopefully this should work. Let me know if I missed anything."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Or we can loop from left to right until we find a difference double any other difference."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Divide and conquer with time complexity O(lgn):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Average of an AP is (first_tearm+last_term)*Number_Of_Elements/2 So expected sum would be (average* number of items). To get the missing number subtract actual_sum from expected_sum.  Following is the code."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int findMissing(int[] nums, int min, int max, \n   int difference) { \n  int middle = (min + max) / 2; \n  int predicted = middle * difference + nums[0]; \n  while (min < max && max < nums.length) { \n   if (min == max - 1) { \n    //the skipped number is between min and max \n    return (nums[min] + nums[max])/2; \n   } \n   else if (nums[middle] > predicted) { \n    // the skipped number is on the left \n    return  findMissing(nums, min, middle, difference); \n   } else { \n    // the skipped number is on the right \n    return findMissing(nums, middle, max, difference); \n   } \n  } \n  return (nums[min] + nums[max-1])/2; \n \n \npublic static void main (String[] args){ \nint nums = {3, 5, 7, 9, 11, 15}; \nint difference = 0; \n  if (nums[2] - nums[1] == nums[1] - nums[0]) { \n   difference = nums[1] - nums[0]; \n  } else { \n   if (nums[2] - nums[1] > nums[1] - nums[0]) \n    System.out.println((nums[2] + nums[1]) / 2); \n   else \n    System.out.println((nums[0] + nums[1]) / 2); \n   return; \n  } \n  System.out.println(findMissing(nums, 2,  nums.length-1, difference)); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think a binary search algorithm may solve this problem. For example, the input array is 1 3 7 9 11 start = 0 end = len(A) while(start    if A[mid] == mid*2+1         start = mid+1     if A[mid] > mid*2+1         end = mid  return start*2+1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If we can assume that the first and the last elements are always available, then we can use"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A binary search algorithm is able to solve this problem in O(lgn) time complexity.  def missing_item_in_arithmetic_progression(array):  if len(array) < 3:   return None    d = min(array[-1] - array[-2], array[1] - array[0])   if array[-1] - array[0] == d * (len(array)-1):   return None   l = 0  r = len(array) - 1  while r - l > 1:   m = (l + r) / 2   if (array[r] - array[m]) != (r - m) * d:    l = m   else:    r = m  return (array[l] + array[r]) / 2  print missing_item_in_arithmetic_progression([1, 3, 7, 9, 11, 13])"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have a similar solution to 1 explained why not do this a1,.........,an  go to n/2 index if (n/2) even then if a(n/2)+a(1) = a(n/4+1)+a(n/4-2) if (n/2) odd if a(n/2)+a(1) = 2*a(n/4) then left half is correct and right has the missing number  this is using the average concept of the AP where sum of first and last term is 2wice the middle term or equal to sum of middle terms"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int findMissing(){ \n Console c = System.console(); \n String input = c.readLine(\"Input the length: \"): \n int length = 0; \n try{ \n  length = Integer.parseInt(input); \n  if(length < 3){ \n   System.out.println(\"Error input: length should be no less than 3\"); \n   System.exit(0); \n  } \n } catch(Exception e){ \n  System.out.println(\"Please input an integer.\"); \n  System.exit(0); \n } \n \n input = c.readLine(\"Input your sequence: \"); \n int[] A = parse(input); // the parse function converts the string to an int array. \n assert(A.length == length); \n if(A[1] - A[0] < A[2] - A[1]){ \n  return A[1] + A[1] - A[0]; \n } \n if(A[1] - A[0] > A[2] - A[1]) { \n  return A[0] + A[2] - A[1]; \n } \n int start = A[0]; \n int step = A[1] - A[0]; \n int left = 0; \n int right = length - 1; \n while(left < right - 7){ \n  int mid = (left+right)/2; \n  if(A[mid] > start + mid*step){ \n   right = mid-1; \n  } else { \n   left = mid + 1; \n  } \n } \n for(int i = left; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int findMissing(){ \n Console c = System.console(); \n String input = c.readLine(\"Input the length: \"): \n int length = 0; \n try{ \n  length = Integer.parseInt(input); \n  if(length < 3){ \n   System.out.println(\"Error input: length should be no less than 3\"); \n   System.exit(0); \n  } \n } catch(Exception e){ \n  System.out.println(\"Please input an integer.\"); \n  System.exit(0); \n } \n \n input = c.readLine(\"Input your sequence: \"); \n int[] A = parse(input); // the parse function converts the string to an int array. \n assert(A.length == length); \n if(A[1] - A[0] < A[2] - A[1]){ \n  return A[1] + A[1] - A[0]; \n } \n if(A[1] - A[0] > A[2] - A[1]) { \n  return A[0] + A[2] - A[1]; \n } \n int start = A[0]; \n int step = A[1] - A[0]; \n int left = 0; \n int right = length - 1; \n while(left < right - 7){ \n  int mid = (left+right)/2; \n  if(A[mid] > start + mid*step){ \n   right = mid-1; \n  } else { \n   left = mid + 1; \n  } \n } \n for(int i = left; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class MissingFinder { \n    public static int findMissing(int[] list) { \n        int length = list.length; \n        long sum = (length + 1) * (list[0] + list[length - 1]) / 2; \n        for(int i = 0; i < length; i++) { \n            sum -= list[i]; \n        } \n \n        return (int)sum; \n    } \n \n    public static void main(String[] args) { \n        int[] list = {1, 3, 7, 9, 11, 13}; \n \n        System.out.println(findMissing(list)); \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Little different approach but this one works :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Little different approach but this one works :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I believe that none of the suggestions above considered the case of decreasing AP (i.e. for the input {9,5,3,1} the result should be still 7). The following code does, in O(lgn) complexity:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class fxc {      public static void main(String args[]) throws Exception  {   String br;   int j1=0,k=0,e = 0,a,l = 0;   Scanner s = new Scanner(System.in),s1=new Scanner(System.in);   System.out.println(\"enter the no of terms : \");   int n=s.nextInt();   int[] arr=new int[50];   int[] d=new int[50];   System.out.println(\"enter the sequence : \");    br=s1.nextLine();    String[] strarr = br.split(\" \");    for(int i=0;i   {     arr[i]=Integer.parseInt(strarr[i]);    }       for(int j=0;j<=n-2;j++)    {     d[j]=arr[j+1]-arr[j];    //System.out.println(d[j]);                  }    for(int j=0;j   {          if(d[j]<=d[j+1])     {      e=d[j];      l=j;                 }     else      e=d[j+1];      l=j+1;     }        a=arr[0];           System.out.println(a+((l+1)*e));                            }        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For ex - 1 3 7 9 11 13  Here we start at 1 and then jump to 7 diff = 6 (indexes 0 and 2) then to 11 diff = 4 (indexes 2 and 4) Jump until we ascertain the 2 diff values So next jump will give 4 again which we have already seen . So the solution lies between 0 and  2 and common diff is (4/2 =2) Now just compute missing vaue  1,3,7 ,start with 1 , next element = 1+2 =3 , matches with array, next element 3+2 = 5 not match 7 so return 5.  Complexity would be less than linear as we would be scanning n/2+3  elements in worst case."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What if We jump to alternate elements and calculate diff   For ex - 1 3 7 9 11 13  Here we start at 1 and then jump to 7 diff = 6 (indexes 0 and 2) then to 11 diff = 4 (indexes 2 and 4) Jump until we ascertain the 2 diff values So next jump will give 4 again which we have already seen . So the solution lies between 0 and  2 and common diff is (4/2 =2) Now just compute missing vaue  1,3,7 ,start with 1 , next element = 1+2 =3 , matches with array, next element 3+2 = 5 not match 7 so return 5.  Complexity would be less than linear as we would be scanning n/2+3  elements in worst case."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can use a binary search to optimize this to O(logn)  int findmissingnumber(int A[], int n)  {   int dis1 = A[1] - A[0];   int dis2 = A[2] - A[1];   int dis = dis1<= dis2? dis1:dis2;   return findmissingnumber(A, 0, n-1, dis);  }   int findmissingnumber(int A[], int s, int e, int d)  {   if ((A[e] - A[s]) == d*(e-s))   {    return A[e] + d;   }    if (e - s == 1)   {    return (A[e] + A[s]) / 2;   }    int m = (s+e)/2;   if ((A[m] - A[s]) == d * (m-s))   {    return findmissingnumber(A, m ,e ,d);   }   else   {    return findmissingnumber(A, s ,m ,d);   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// log(n) \nint Missing(std::vector & v) { \n  int b = 0; \n  int e = v.size() - 1; \n  while (b <= e) { \n    int mid = b + (e - b) / 2; \n    if (v[mid] == 2 * mid + 1) b = mid + 1; \n    else e = mid - 1; \n  } \n  return 2 * b + 1; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  int main() {     /* Enter your code here. Read input from STDIN. Print output to STDOUT */     int a[10],b,c,d,i,j,n;     printf(\"\\n Enter the number of elements:\");     scanf(\"%d\",&n);     for(i=0;i    {      scanf(\"%d\",&a[i]);     }     b=a[1]-a[0];     c=a[2]-a[1];     d=a[3]-a[2];     if(b==c)     b=c;     else if(c==d)         b=d;     else if(d==b)         b=d;     else     {}     printf(\"The difference is:%d\",b);     for(i=1;i    {         if(a[i]==a[i-1]+b)         {}         else         {             printf(\"Missing term is:%d\",a[i-1]+b);         }     }      return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Granted not as elegant or efficient in terms of time complexity, but here is a functional Python implementation executed in O(log n) time:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) {   // TODO Auto-generated method stub    ArrayList a = new ArrayList();   Scanner input = new Scanner(System.in);   int noInt = input.nextInt();   input.nextLine();   int i = 0 ;   while(i < noInt){    a.add(input.nextInt());    i++;   }   int a1,a2,a3,cd = 0;   a1=a.get(1)-a.get(0);   a2=a.get(2)-a.get(1);   a3=a.get(3)-a.get(2);      if(a1 == a2 || a1 == a3)    cd = a1;   if(a2 == a3 || a1 == a2)    cd = a2;      int found = 0 ;    for (int j = 0; j < noInt && found != 1; j++) {    if((a.get(j+1)-a.get(j)) != cd){     found = 1;     System.out.print(a.get(j) + cd);     System.out.println(\" is d missing no\");    }   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the Javascript solution for the problem..."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5632735657852928","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"31","title":"Check if a given tree is a valid BST","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"boolean isBST(TreeNode node,int min,int max) \n { \n  \n  if(node==null) \n   return true; \n   \n  if(node.leftchild==null && node.rightchild==null) \n   return true; \n   \n  else if(node.value>min&&node.value"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Somebody has already made excellent point \"If the inorder traversal of the tree is sorted, the tree is BST else not.\"  Didn't get why people are still trying for other implementations?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I guess the normal recursion, with two variable for allowed min and max would be sufficient for this question. Following is the fully working code for the same."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the inorder traversal of the tree is sorted, the tree is BST else not."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@Swapnil/Urik - Will this fix my code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"boolean isBST (TreeNode node){  if(node == null) return true;  if(node.leftchild == null) return isBST(node.rightchild);  if(node.rightchild== null) return isBST(node.leftchild)  return (isBST(node.rightchild) && isBST(node.leftchild)); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"non-recursion implementation:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"boolean isBST(TreeNode node) { \n    if(node == null) \n        return true; \n \n    if(node.left == null || node.right == null) { \n        if(node.left != null) \n            return (node.value > node.left.value) && isBST(node.left); \n        else if(node.right != null) \n            return (node.value < node.right.value) && isBST(node.right); \n        else \n            return true; \n    } \n    return isBST(node.left) && isBST(node.right); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"boolean isBST(TNode root){ \n return isBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE); \n} \nboolean isBST(TNode node, int lb, int rb) { \n if (!(lb < node.value < rb)){ \n  return false; \n } \n return isBST(node.left, lb, node.value) && isBST(node.right, node.value, rb); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just fix a small issue in my previous code."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include   class Node  {     private:     int value;     Node *left,*right;     public:          Node(int nValue,Node * nLeft, Node *nRight)     {         this->value = nValue;         this->left = nLeft;         this->right = nRight;     }     Node * leftChild()     {         return left;     }     Node * rightChild()     {         return right;     }     int data() {return value;} };  // If the root is root of BST returns the last node in the BST, else NULL Node* isBST(Node * root,Node * predecessorNode) {     if(!root)     {         return predecessorNode;     }          Node * predecessorOfRoot;     if(root->leftChild())     {         if((predecessorOfRoot = isBST(root->leftChild(),predecessorNode)) == NULL)             return NULL;     }     else         predecessorOfRoot = predecessorNode;              if(predecessorOfRoot && predecessorOfRoot->data() > root->data())       return NULL;            return isBST(root->rightChild(),root);   }  bool isBST(Node * root) {     return root == NULL || isBST(root,NULL); }  int main() {     Node * root = new Node (8,         new Node(6,             new Node(4,NULL,NULL),             new Node(7,NULL,NULL)         ),                  new Node(12,             new Node(10,NULL,NULL),             new Node(14,NULL,NULL)         )             );      Node * root2 = new Node (8,         new Node(6,             new Node(12,NULL,NULL),             new Node(7,NULL,NULL)         ),                  new Node(12,             new Node(10,NULL,NULL),             new Node(14,NULL,NULL)         )             );      Node * root3 = new Node (8,         new Node(6,             new Node(4,NULL,NULL), NULL         ),                  new Node(12,             new Node(10,NULL,NULL),             new Node(14,NULL,NULL)         )             );          puts((isBST(root)?\"BST\\n\":\"Not BST\\n\"));     puts((isBST(root2)?\"BST\\n\":\"Not BST\\n\"));     puts((isBST(root3)?\"BST\\n\":\"Not BST\\n\"));   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \nclass Node  \n{ \n    private: \n    int value; \n    Node *left,*right; \n    public: \n     \n    Node(int nValue,Node * nLeft, Node *nRight) \n    { \n        this->value = nValue; \n        this->left = nLeft; \n        this->right = nRight; \n    } \n    Node * leftChild() \n    { \n        return left; \n    } \n    Node * rightChild() \n    { \n        return right; \n    } \n    int data() {return value;} \n}; \n \n// If the root is root of BST returns the last node in the BST, else NULL \nNode* isBST(Node * root,Node * predecessorNode) \n{ \n    if(!root) \n    { \n        return predecessorNode; \n    } \n     \n    Node * predecessorOfRoot; \n    if(root->leftChild()) \n    { \n        if((predecessorOfRoot = isBST(root->leftChild(),predecessorNode)) == NULL) \n            return NULL; \n    } \n    else \n        predecessorOfRoot = predecessorNode; \n         \n    if(predecessorOfRoot && predecessorOfRoot->data() > root->data()) \n      return NULL; \n       \n    return isBST(root->rightChild(),root);  \n \n} \n \nbool isBST(Node * root) \n{ \n    return root == NULL || isBST(root,NULL); \n} \n \nint main() \n{ \n    Node * root = new Node (8, \n        new Node(6, \n            new Node(4,NULL,NULL), \n            new Node(7,NULL,NULL) \n        ), \n         \n        new Node(12, \n            new Node(10,NULL,NULL), \n            new Node(14,NULL,NULL) \n        )         \n    ); \n \n    Node * root2 = new Node (8, \n        new Node(6, \n            new Node(12,NULL,NULL), \n            new Node(7,NULL,NULL) \n        ), \n         \n        new Node(12, \n            new Node(10,NULL,NULL), \n            new Node(14,NULL,NULL) \n        )         \n    ); \n \n    Node * root3 = new Node (8, \n        new Node(6, \n            new Node(4,NULL,NULL), \nNULL \n        ), \n         \n        new Node(12, \n            new Node(10,NULL,NULL), \n            new Node(14,NULL,NULL) \n        )         \n    ); \n     \n    puts((isBST(root)?\"BST\\n\":\"Not BST\\n\")); \n    puts((isBST(root2)?\"BST\\n\":\"Not BST\\n\")); \n    puts((isBST(root3)?\"BST\\n\":\"Not BST\\n\")); \n \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"python solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public boolean isBST(Node node) { \n List lst = new LinkedList(); \n getInOrder(node, lst); \n for (int i = 1; i < lst.size() - 1; i++) { \n  if (lst.get(i) < lst.get(i - 1)) { \n   return false; \n  } \n } \n return true; \n} \n  \npublic void getInOrder(Node node, List values) { \n if (node == null) \n  return; \n \n getInOrder(node.left, values); \n values.add(node.value); \n getInOrder(node.right, values); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool isBST(TreeNode * root, int min, int max, int &depth)  {   if (!root){    depth = 0;    return true;   }    if (root->val < min || root->val > max){    return false;   }    int ldep, rdep;   if (isBST(root->left, min, root->val, ldep) && isBST(root->right, root->val, max, rdep))   {    if ((ldep - rdep) <= 1 && (ldep - rdep) >= -1)    {     depth = 1+ max(ldep, rdep);     return true;    }   }    return false;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool IsValidBST(TreeNode * root, TreeNode * & pre) { \n  if (root == NULL) return true; \n  if (!IsValidBST(root->left, pre)) return false; \n  if (pre != NULL && pre->val >= root->val) return false; \n  pre = root; \n  if (!IsValidBST(root->right, pre)) return false; \n  return true; \n} \n \nbool IsValidBST(TreeNode * root) { \n  TreeNode * pre = NULL; \n  return IsValidBST(root, pre); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"bool isValidBST(struct node *root) {     static struct node *prev = NULL;      if(root==NULL)         return true;      isValidBST(root->left);      if(prev && root->data<=prev->data)         return false;     prev = root;      isValidBST(root->right); }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5309537623998464","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"52","title":"There are n points on a 2D plan, find the k points that are closest to origin ( x=0, y=0)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"13","title":"You can do it in O(n), but you have to avoid heaps. First build an array with the distances to the origin and the corresponding point. O(n) Then find the Kth largest distance using the Selection algorithm. O(n) The K-1 smallest distances are to the left of the Kth distance, in no particular order.  So the total is O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Not elegant, but it works.  (Java)  Could probably make the code more elegant with more time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First idea could be: calculate all the distances in an array, sort the array, then get the k smallest values from there. This would work fine, but as the  fastest sorting algorigthms are O(nlog(n)), there is a faster, O(n) solution.  While iterating over the array you fill a max-heap of length k with new values.  The exact implementation of the heap was not asked.  In PHP:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My thoughts:  1)  Never use distance, but rather use the square on distance. We don't want to get caught up in the ugliness of sqrt.  2) We can do this in place (and in most apps. this should be allowed because the set of points is just a \"bag\" of points):    3)  Modify QuickSelect or MedianOfMedians to use a distance^2 comparison function \"on the fly\" on the original array itself. This gets the k closest points into the first k elements of _original_ array of points.  Should be O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Am I crazy but can't we do a BFS search on the 2D plane with a K count. Once K has hit its value we just return a list of found points? Here is the code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"from random import random as rand \n \ndef knth(sample, n): \n  pivot = sample[0] \n  below = [s for s in sample if s < pivot] \n  above = [s for s in sample if s > pivot] \n  i, j = len(below), len(sample)-len(above) \n  if n < i:      return knth(below, n) \n  elif n >= j:   return knth(above, n-j) \n  else:          return pivot \n \ndef kmindist(sample, n): \n  distsquared = [x**2+y**2 for x,y in sample] \n  last_element = knth(distsquared, n) \n  return [d for d in distsquared if d < last_element] \n \ndef main(): \n  # Tester \n  sample = [(rand(),rand()) for i in range(20)] \n  print sample \n  print kmindist(sample, 5) \n \nif __name__ == \"__main__\": \n  main()"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"But Like to know, when there are utility methods to sort still Interview expect to write a fresh sort? Running code sample below with Two possible ways to solve this:  import java.util.ArrayList; import java.util.Collections; import java.util.Iterator; import java.util.Random; import java.util.TreeMap;     public class PuzzleRunner {      public static void main(String[] args) {   try {    Plane2D plane2d = new PuzzleRunner().new Plane2D(10,5);    plane2d.fillRandomPoints(10);    plane2d.showGenetatedPoints();    System.out.println(\"Result by n log(n) performance\" +  plane2d.getClosedPoint());    System.out.println(\"guaranteed log(n) time cost\" +plane2d.getClosedPoint2());       } catch (Exception e) {    System.out.println(e.getMessage());   }   }      protected class Plane2D {        private int length;   private int breath;   private ArrayList points;      Plane2D(int length, int breath) throws Exception{    if(length <= 0 || breath <= 0){     throw new Exception(\"Size is less then zeros not allowed in this version\");    }    this.length = length;    this.breath = breath;       }      public void fillRandomPoints(int numberOfPoints){    points = new ArrayList(numberOfPoints);    Random randomX = new Random();    Random randomY = new Random();    for (int i = 0; i < numberOfPoints; i++) {     points.add(new Point(randomX.nextInt(length), randomY.nextInt(breath)));     }       }      public Point getClosedPoint(){    /**     * The sorting algorithm is a modified merge sort      * This algorithm offers guaranteed n log(n) performance     */    Collections.sort(points);    return points.get(0);   }      public Point getClosedPoint2(){        //This implementation provides guaranteed log(n) time cost for the containsKey    TreeMap treeMap = new TreeMap();    for (Point point : points) {     treeMap.put(point.getDistanceOfPointsFromOrigin(), point);    }    return treeMap.get(treeMap.firstKey());   }      public void showGenetatedPoints(){        for (Iterator iterator = points.iterator(); iterator.hasNext();) {     Point point = (Point) iterator.next();     System.out.println(point);         }   }         }    protected class Point implements Comparable {      private double x;   private double y;   private double distanceOfPointsFromOrigin;      Point(double x, double y){    this.x = x;    this.y = y;    this.distanceOfPointsFromOrigin = Math.sqrt(getX()*getX() + getY()*getY());   }       public double getX() {    return x;   }    public double getY() {    return y;   }      @Override   public int compareTo(Point o) {    if(this.distanceOfPointsFromOrigin < o.getDistanceOfPointsFromOrigin()){     return -1;    }else if (this.distanceOfPointsFromOrigin > o.getDistanceOfPointsFromOrigin()){     return 1;    }else{     return 0;    }   }     @Override   public String toString() {    return \"Point [x=\" + x + \", y=\" + y + \"]\";   }     public double getDistanceOfPointsFromOrigin() {    return distanceOfPointsFromOrigin;   }                }   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Java  import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.List;  class Point{  private float x;  private float y;  private Float distFrmOrig;    Point(float xaxis, float yaxis){   x=xaxis;   y=yaxis;   distFrmOrig=(x*x)+(y*y);  }  public float getX() {   return x;  }  public void setX(float x) {   this.x = x;  }  public float getY() {   return y;  }  public void setY(Float y) {   this.y = y;  }  public Float getDistFrmOrig() {   return distFrmOrig;  }  public void setDistFrmOrig(Float distFrmOrig) {   this.distFrmOrig = distFrmOrig;  }   }  public class KPointAlgo {    public static void main(String[] args){      ListpointList=new ArrayList();   pointList.add(new Point(2,2));   pointList.add(new Point(3,3));   pointList.add(new Point(4,4));   pointList.add(new Point(5,5));   pointList.add(new Point(6,6));   pointList.add(new Point(7,7));   pointList.add(new Point(8,8));   pointList.add(new Point(9,9));   pointList.add(new Point(10,10));      //Let K =5   int k=5;   List KpointList= getKpointClosetoOrigin(pointList,k);   if(KpointList!=null){    for(Point point:KpointList){     System.out.println(\"X axis: \" + point.getX()+\" Y axis: \"+ point.getY()+\" and distance from origin is \"+ point.getDistFrmOrig());    }   }     }   private static List getKpointClosetoOrigin(List pointList,    int k) {     if(pointList!=null && pointList.size()>0){    Collections.sort(pointList,new Comparator(){         @Override     public int compare(Point o1, Point o2) {       return o1.getDistFrmOrig().compareTo(o2.getDistFrmOrig());       }    });    return pointList.subList(0,k);   }      return null;  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Updated solution.  This one is designed for practical use.  In a typical scenario, I would expect to be given a very large number of points (i.e. 10,000,000) to search through & only a small number of k-points (i.e. 15 or less) that need to be returned.  Storing 10-million pointers and their distance values, or 'cheating' by having a point class that stores it's distance from (0,0) (what?!) would be extremely inefficient.  Instead, we just store the k-closest points so far, and their distances.  As far as calculations, we save by using distance-squared and storing those distances.  For fun, I ran a test on my old laptop with 10-million random points and 15-closest, and the results returned in 125ms."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@JonG collabedit.com/4k9d4  Add and fix things in there as you please."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// k-closest-points-to-origin.cpp : Defines the entry point for the console application. //  #include #include using namespace std; struct point{ int x,y; }; point p[10];  int Dist(int i) {  return p[i].x*p[i].x + p[i].y*p[i].y; }  int partition(int low, int high,int mid) {  int lookat=low;  int midr = Dist(mid);  while(lookat<=high)  {   int loDtr = Dist(lookat);   if(loDtr < midr)   {    swap(p[lookat],p[low]);    lookat++;low++;   }   if(loDtr > midr)   {    swap(p[lookat],p[high]);    high--;   }   else    lookat++;  }  return low; }  void quickSelect(int k, int low, int high) {  int mid = (low+high)/2;  int index = partition(low,high,mid);  int len = index-low+1;  if(k == len)   return;  else if (k < len)   quickSelect(k,low,index-1);  else   quickSelect(k-len,index+1,high);   } int main() { for(int i=0;i<10;i++) {  p[i].x = rand()%10;  p[i].y = rand()%10; }  for(int i=0;i<10;i++) {  cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"3 step operation: (1) calculate distances for all Points; (2) sort; (3) select K points closest to origin"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ArrayList kNearestPts(Coordinates[] C, int k){ \n double[] A = new double[C.length]; \n for(int i = 0; i selectTopK(ArrayList A, int k){ \n if(A.size() < 26){ \n  return selectBruteForce(A, k); \n } \n int m = (A.size()-1)/5 + 1; \n double[] M = new double[m]; \n for(int i = 0; i mom = selectTopK(M, m/2); \n int r = partition(A, mom.get(mom.size()-1)); \n if(k < r+1){ \n  return selectTopK(new ArrayList(A.subList(0, r)), k); \n } \n if(k > r+1) { \n  return selectTopK(new ArrayList(A.subList(r+1, A.size()), k-r-1); \n } \n return new ArrayList(A.subList(0, r+1)); \n} \n \nArrayList selectBruteForce(double[] A, k){ \n ArrayList ret = new ArrayList(); \n while(k > 0){ \n  int min = Double.MAX_VALUE; \n  for(int i = 0; i A, int start, int end){ \n ArrayList temp = new ArrayList(); \n for(int i = start; i<= end; i++){ \n  temp.add(A.get(i)); \n } \n for(int i = 1; i temp.get(j)){ \n    double t = temp.get(i); \n    temp.set(i, temp.get(j)); \n    temp.set(j, t); \n   } \n  } \n } \n return temp.get((0+temp.size())/2); \n} \nint partition(ArrayListA, double pivot){ \n int r = 0; \n int c = 0; \n while(c < A.size()){ \n  if(A.get(c) < pivot) { \n   double t = A.get(r); \n   A.set(r, A.get(c)); \n   A.set(c, t); \n   r ++; \n  } \n  c++; \n } \n return r; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"One idea about the solution: 1. Calculate the distances of all points, they will get stored in an array. 2. The question can be attributed to the question to find the smallest k items in an array. To solve this question, we can use several ways, including sorting and find the kth, quicksort like way to partition the array to parts, that all based on the items are not that big enough, they can be loaded into memory. The following part is sample code to find the Kth number:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use TreeMap to put the points, compared by their distance from origin. Then iterate over the first k. Complexity: O(nlogn) - n because running over all the elements and logn because the depth of the tree logn."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here my C++ solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Did a solution in golang see comment for explanation:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5111068527427584","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"34","title":"Input - List  [\"star\", \"rats\", \"ice\", \"cie\", \"arts\"] print all anagrams in buckets: [\"star\", \"rats\", \"arts\"] [\"ice\", \"cie\"]  The signature of unimplemented method is given:","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Here is the full java implementation: It takes advantage of hashing and sorting. Sort each string alphabetically via quicksort. Hash each string to avoid multiple comparisons, we can compare numbers easily. Then print out buckets which are just hashtable values."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Sorry I am not going to answer this in java,"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Here's my implementation in Obj-C.  The isAnagram function takes the letters of the first string and puts them in a bag.  As we walk through the second string we pull those same letters out.  If there are still letters left in the bag when we end, or if any of the letters in the second string aren't in the bag, we return NO;  In the second algorithm I'm trying to limit comparisons by selecting one member of the bucket to act as the prototype (key) for all the members of that bucket.  We only compare against the key, and build the list of key/values progressively.  Should keep calls to isAnagram a little lower."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The output of the following code is: [ice,cie,] [star,rats,arts,]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; \nimport java.util.Arrays; \nimport java.util.List; \n \n \npublic class Sort { \n \n public static void main(String[] args) { \n \n  String[] words = {\"star\", \"rats\", \"ice\", \"cie\", \"arts\"}; \n  List> result = new ArrayList>(); \n  boolean isFound = false; \n  char[] charArray = null; \n  char[] tempCharArray = null; \n  for(String str:words){ \n   charArray = str.toCharArray(); \n   isFound = false; \n   Arrays.sort(charArray); \n   for(List list:result){ \n    for(String tempStr:list){ \n     tempCharArray = tempStr.toCharArray(); \n     Arrays.sort(tempCharArray); \n     if(String.valueOf(tempCharArray).equals(String.valueOf(charArray))){ \n      list.add(str); \n      isFound = true; \n      break; \n     } \n    } \n   } \n   if(!isFound){ \n    List tempList = new ArrayList();  \n    tempList.add(str); \n    result.add(tempList); \n   } \n    \n  } \n  System.out.println(result); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"C# Implementation"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sort each string and put it in a trie. Sorting a string can be done in O(n) time and constant space - keep track of count of each characters and print in sorted order. Trie insertion = O(n) Total complexity - O(n*m) m = number of strings in array n = size of strings in array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would use the List as a dictionary and do the following: 1. Pre-process -- Sort letters in string and form key -- Add the word from list to hash table, with key from previous step 2. Print values (list of words with same key) for each key in bucket"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class AnagramAI \n    { \n        public static void Do() \n        { \n            List inputs = new List() { \"star\", \"rats\", \"ice\", \"cie\", \"arts\" }; \n            AnagramBuckets(inputs); \n        } \n \n        public static void AnagramBuckets(List input) \n        { \n            List processed = new List(); \n            List> buckets = new List>(); \n \n            List anagrams = null; \n            for (int i = 0; i < input.Count; i++) \n            { \n                //Console.Write(\"{0}\", input[i]); \n                if (processed.Contains(input[i])) \n                { \n                    continue; \n                } \n                else \n                { \n                    anagrams = new List(); \n                    anagrams.Add(input[i]); \n                    processed.Add(input[i]); \n                } \n                for (int j = i + 1; j < input.Count; j++) \n                { \n                    if (!processed.Contains(input[j]) && IsAnagram(input[i], input[j])) \n                    { \n                        //Console.Write(\",{0}\", input[j]); \n                        anagrams.Add(input[j]); \n                        processed.Add(input[j]); \n                    } \n                } \n                //Console.WriteLine(); \n                buckets.Add(anagrams); \n            } \n \n            foreach (List buck in buckets) \n            { \n                foreach (string s in buck) \n                { \n                    Console.Write(\"{0},\", s); \n                } \n                Console.WriteLine(); \n            } \n        } \n \n        private static bool IsAnagram(string a, string b) \n        { \n            if (a.Length == b.Length) \n            { \n                char[] charas = a.ToCharArray(); \n                Array.Sort(charas); \n                char[] charbs = b.ToCharArray(); \n                Array.Sort(charbs); \n \n                for (int i = 0; i < charas.Length; i++) \n                { \n                    if (charas[i] != charbs[i]) \n                    { \n                        return false; \n                    } \n                } \n \n                return true; \n            } \n \n            return false; \n        } \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package com.test;  import java.util.ArrayList; import java.util.LinkedList; import java.util.List;  public class Anagram {   /**   * @param args   */  public static void main(String[] args) {   List anagrams = new LinkedList();   anagrams.add(\"star\");   anagrams.add(\"rats\");   anagrams.add(\"ice\");   anagrams.add(\"cie\");   anagrams.add(\"arts\");    List> anagramBuckets = anagramBuckets(anagrams);   System.out.println(anagramBuckets);   }   public static List> anagramBuckets(List input) {   List> buckets = new LinkedList>();   for (String instr : input) {    int i = 0;    System.out.println(i);    while (true) {     if (i == buckets.size()) {      //System.out.println(i);      System.out.println(instr);      buckets.add(new ArrayList());      buckets.get(i).add(instr);      break;     } else if (isAnagram(buckets.get(i).get(0), instr)) {      // System.out.println(instr);      buckets.get(i).add(instr);      break;     }     i++;    }   }   return buckets;  }   public static boolean isAnagram(String str1, String str2) {    for (int i = 0; i < str1.length(); i++) {    int indexOf = str2.indexOf(str1.charAt(i));    if (indexOf < 0) {     return false;    }    String tmp = str2.substring(0, indexOf)      + str2.substring(indexOf + 1, str2.length());    str2 = tmp;   }   if (str2.equals(\"\")) {    return true;   } else {    return false;   }  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"n max number of chars in a string (sort the chars) m number of strings  (group and print strings) Total complexity: O(m*nlogn) Code in C#:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ruby Implementation:-   a = ['star', 'rats', 'ice', 'cie', 'arts']  a.group_by{|x| x.chars.sort.join}  Ans:  #[\"star\", \"rats\", \"arts\"], \"cei\"=>[\"ice\", \"cie\"]}>"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// assuming 'star' == 'rats' == Ascii calculation is always same \npublic static void anagramBuckets(List input) { \n \nHashMap> hashMap = new HashMap>(); \n \nfor (String stringValue : input) { \n      int temp = 0; \n      for (int i = 0; i < stringValue.length(); i++) { \n             temp = temp + (int) stringValue.charAt(i); \n      } \n     if (hashMap.containsKey(temp)) { \n        List list = hashMap.get(temp); \n        list.add(stringValue); \n        hashMap.put(temp, list); \n     } else { \n       List list = new ArrayList(); \n       list.add(stringValue); \n       hashMap.put(temp, list); \n     } \n} \n \nSet keys = hashMap.keySet(); \nfor (Integer key : keys) { \nSystem.out.println(hashMap.get(key)); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void ShowAnagrams(liststr) \n{ \n if(str.empty()) \n  return; \n multimapm; \n multimap::iterator ptr; \n list::iterator p; \n for(p=str.begin();p!=str.end();p++) \n { \n  string s=(*p); \n  sort(s.begin(),s.end()); \n  m.insert(make_pair(s,(*p))); \n } \n  \n string prev=str.front(); \n sort(prev.begin(),prev.end()); \n for(ptr=m.begin();ptr!=m.end();ptr++) \n {   \n  if(prev==(*ptr).first) \n   cout<<(*ptr).second<<\"\\t\"; \n  else \n  { \n   prev=(*ptr).first; \n   cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void anagramBuckets(List input) {   \n   \n  Map> bucket = new HashMap>(); \n  for (String word : input) { \n   char[] charArr = word.toCharArray(); \n   Arrays.sort(charArr); \n   Collection collection = null; \n   String str = new String(charArr); \n   if (bucket.containsKey(str))  \n    collection = bucket.get(str);    \n   else  \n    collection = new ArrayList();    \n   collection.add(word); \n   bucket.put(str, collection); \n  } \n   \n  for (Entry> entry : bucket.entrySet()) { \n   System.out.println(entry.getValue());    \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simple one via C#:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"similiar solutions. 1. go through the list 2. for each string in the list, change it to char array. 3. sort the char array. Put the sorted char array as key, the original string as value, to a HashMap. 4. compare each sorted string with the HashMap. 5. go through the hashmap to print all the result."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void anagramBuckets(List input) { \n  Map> anagrams = new HashMap>(); \n \n  for (String word : input) { \n   TreeMap tree = getTree(word); \n   if (anagrams.containsKey(tree.hashCode())) { \n    List words = anagrams.get(tree.hashCode()); \n    anagrams.remove(tree.hashCode()); \n    words.add(word); \n    anagrams.put(tree.hashCode(), words); \n   } else { \n    List words = new ArrayList(); \n    words.add(word); \n    anagrams.put(tree.hashCode(), words); \n   } \n  } \n \n  for (Entry> entry : anagrams.entrySet()) { \n   System.out.println(entry.getValue()); \n  } \n \n } \n \n private static TreeMap getTree(String word) { \n  TreeMap tree = new TreeMap(); \n \n  for (int i = 0; i < word.length(); i++) { \n   tree.put(word.charAt(i), 0); \n  } \n \n  return tree; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sort all words and compare - n*k*logk Using hashing that always works will make the sort redundant - n*k (I don't know how to do a hash that always works)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"vector < vector < string > > anagrambuckets(vector < string > s) \n{ \n    int n = s.size(); \n    map < string, vector < string > > track; \n    vector < vector < string > > ret; \n    for(int i = 0; i < n; ++i) \n    { \n        string sorted = s[i]; \n        sort(sorted.begin(), sorted.end()); \n        track[sorted].push_back(s[i]); \n    } \n    for(map < string, vector < string > >::iterator it = track.begin(); it != track.end(); ++it) \n    { \n        ret.push_back(it->second); \n    } \n    return ret; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static void anagrams() { \n        String[] list = new String[]{\"star\", \"rats\", \"ice\", \"cie\", \"arts\"}; \n \n        Map> anagramsMap = new HashMap<>(); \n \n        for (String word : list) { \n            ArrayList charList = new ArrayList<>(); \n            for (char character : word.toCharArray()) { \n                charList.add(character); \n            } \n            Set set = new TreeSet<>(charList); \n            StringBuilder sb = new StringBuilder(); \n            Iterator iterator = set.iterator(); \n            while (iterator.hasNext()) { \n                sb.append(iterator.next()); \n            } \n \n            if (sb != null && sb.length() > 0) { \n                String newWord = sb.toString(); \n                int hashCode = newWord.hashCode(); \n                if (anagramsMap.containsKey(hashCode)) { \n                    anagramsMap.get(hashCode).add(word); \n                } else { \n                    ArrayList valueList = new ArrayList<>(); \n                    valueList.add(word); \n                    anagramsMap.put(hashCode, valueList); \n                } \n            } \n        } \n \n        for (List anagramsList : anagramsMap.values()) { \n            System.out.println(\"[ \" + StringUtils.join(anagramsList, \", \") + \" ]\"); \n        } \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"For each string in the list, sort the string alphabetically and store in a hashmap. For a given key,  the values will be the anagrams. // Sample  HashMap> anagramsBuckets = new HashMap(); //Parse the input and store in map star, rats, arts will be arst sorted alphabetically  arst -> rats, star, arts (key) -> (values)  For the given input string whose anagrams we should find, sort the input again and find all values for that key. That will be all the anagrams of the string."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"One needs two things to identify elements belonging to the same bucket: 1.length 2.A bit string that correspond to the asciii values present in the anagram. This will be a 32bit int value if the words are limited to lower case. --------------- declare a list for buckets: listB then iterate though the input list for each element in the input list, iterate through listB if(cur belongs to a bucket in listB)  {add cur to listB} else  {establish a new bucket based on the two aforementioned properties of cur}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6631993756352512","download_status":"DOWNLOAD_DONE","votes":"5","answersCount":"43","title":"Given a regular expression with characters a-z, ' * ', ' . ' the task was to find if that string could match another string with characters from: a-z where ' * ' can delete the character before it, and ' . ' could match whatever character. ' * ' always appear after a a-z character.  Example: isMatch(\"a*\", \"\") = true; isMatch(\".\", \"\") = false; isMatch(\"ab*\", \"a\") = true; isMatch(\"a.\", \"ab\") = true; isMatch(\"a\", \"a\") = true;","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"try this?  inspired the the recursive approach.Processing the string from the end."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Does * also mean any repetitions of the character before it ? So for instance"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Simple recursive approach :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"+ (BOOL)isMatch:(NSString *)expression :(NSString *)string; \n{ \n    if(expression==nil || string==nil) return NO; \n    if(!expression.length && !string.length) return YES; \n    if([expression hasPrefix:@\"*\"] || [expression hasPrefix:@\".\"]) return NO; \n    NSMutableString *expreCopy = [NSMutableString stringWithString:expression]; \n    for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"s1 contains special chars, s2 is only a-z.  Iterative:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public class RegularExpression { \n \n    // s1 regex s2 match \n \n    public static boolean isMatch(String s1, String s2) { \n            // recursive implementation keeps shortening both strings from the right to left \n        if (s1.length() == 0 && s2.length() == 0) return true; \n \n \n        int i, j; \n        boolean point = false; \n        boolean star = false; \n \n        for(i = s1.length() - 1, j = s2.length() - 1;i >= 0 && j >= 0;) { \n            if(s1.charAt(i) == s2.charAt(j)) { \n                i--; \n                j--; \n                continue; \n            } \n \n            if(s1.charAt(i) == '.') { \n                i--; \n                j--; \n                point = true; \n                continue; \n \n            } \n \n            if(s1.charAt(i) == '*') { \n                j -= 2; \n                star = true; \n                continue; \n            } \n \n            if(s1.charAt(i) != s2.charAt(j)) { \n                if(star) { \n                    if(s1.charAt(i) == s2.charAt(j + 1)) { \n                        i--; \n \n                        star = false; \n                        continue; \n                    }else \n                        return false; \n                } \n                return false; \n \n            } \n \n        } \n \n        return true; \n        } \n \n    public static void main(String []argc) { \n        System.out.println(isMatch(\"a*\", \"\")); \n        System.out.println(isMatch(\"Co.s*\", \"Cos\")); \n        System.out.println(isMatch(\"Co.s\", \"Coas\")); \n        System.out.println(isMatch(\"Co.sb*\", \"Coss\")); \n        System.out.println(isMatch(\"a*abc\", \"abc\")); \n \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Otherwise this would be simple edit distance with minor modifications :  substitutions not allowed, if one of the characters is * then deletion cost is 0 otherwise 1, if one of the characters is . then insertion cost is 0 otherwise 1, in the end if the edit distance returns a non-zero  distance then false, otherwise true."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"FYI: Qus filler has commented missed clause in qus: [I forgot to clarify that * can only delete the character before it, but * can be skipped. So \"a*\" is \"a\" or is an empty string \"\"]  Approach: -Traverse both of the strings from right side  -In case found char [a-z] in str_1 just match this particular char  in str_2  -In case found [.] in str_1 skip one char in str_2  -In case found [*] in str_1, check the char before [*] and check also no. of time it is repeating consecutively say N.  [For ex: abbb*c    :  Here before [*] char 'b' is repeating 3 times]  -Now check in str_2 it should have either (N) or (N-1) no. of time char 'b'  [As in case of abbb*c valid str are: {abbc} & {abbbc}]  -Repeat above steps until anything unmatch not occurs or string ends."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nvoid ismatch(char str1[], char str2[]) \n{ \nint i, j, len= strlen(str1), flag=0; \n \n \nfor(i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"javacode: public class MatchStr {   public static void main(String[] args) { //  String s1 = \"a*abc\"; //  String s2 = \"abc\"; //  String s1 = \"a*a*a\"; //  String s2 = \"a\"; //  String s1 = \"a.\"; //  String s2 = \"ab\"; //  String s1 = \"a*bd*c\"; //  String s2 = \"abdc\";   String s1 = \"ada*d*a\";   String s2 = \"ada\";   System.out.println(isMatch(s1,s2,0,0));      }  public static boolean isMatch(String s1,String s2,int n1,int n2){   int l1 = s1.length();   int l2 = s2.length();   System.out.println(\"n1:\"+n1+\"-----n2:\"+n2);   if(n1 > l1 || n2 > l2 ){      return false;   }else if(n1 == l1  && n2 == l2){     return true;   }else{     if(n2 < l2 && n1 < l1 && ((s1.charAt(n1) == s2.charAt(n2)) || s1.charAt(n1) == '.')){     return isMatch( s1, s2, n1+1, n2+1);    }else if( n1 < l1 && s1.charAt(n1) == '*'){     if(n2>0){      return isMatch( s1, s2, n1+1, n2-1) || isMatch( s1, s2, n1+1, n2);     }else{      return isMatch( s1, s2, n1+1, n2);     }    }else{     if(n1+1 < l1 && s1.charAt(n1+1) == '*'){      return isMatch( s1, s2, n1+2, n2);     }else{      return false;     }    }   }     }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static boolean match(String s1, String s2) { \n        if (s1.equals(s2)) \n            return true; \n        if (isHeadWithAsterisk(s1) && match(s1.substring(2), s2)) \n            return true; \n        if (isHeadWithAsterisk(s2) && match(s1, s2.substring(2))) \n            return true; \n        if (!s1.isEmpty() && !s2.isEmpty()) { \n            if (s1.charAt(0) == '*') return match(s1.substring(1), s2); \n            if (s2.charAt(0) == '*') return match(s1, s2.substring(1)); \n            return matchChars(s1.charAt(0), s2.charAt(0)) &&  \n                    match(s1.substring(1), s2.substring(1)); \n        } else { \n            return false; \n        } \n    } \n \n    private static boolean isHeadWithAsterisk(String s1) { \n        return s1.length() > 1 && s1.charAt(1) == '*'; \n    } \n \n    private static boolean matchChars(char c1, char c2) { \n        return c1 == c2 || c1 == '.' || c2 == '.'; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how about 2 counters i&j going from m and n.  while(iif (str1.charAt(i)==str2.charAt(j) || str1.charAt(i)=='.') i++,j++ else(str1.charAt(i+1)=='*') i+=2, j++; else return false; } if(str1.length()==i and str2.length==j) this is O(m+n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"-(BOOL)isTheMatch:(NSMutableString *)first withString:(NSString *)second{ \n    BOOL result = YES; \n    for (NSUInteger i = [second length]-1; i<= 0; i--) { \n        NSString *firstChar = [first substringFromIndex:i]; \n        NSString *secondChar = [second substringFromIndex:i]; \n        if ([firstChar isEqualToString:@\"*\"]) { \n            [first deleteCharactersInRange:NSMakeRange(i-1, 1)]; \n            continue; \n        } \n        else if ([firstChar isEqualToString:secondChar]){ \n            continue; \n        } \n        else if ([firstChar isEqualToString:@\".\"]){ \n            continue; \n        } \n        else{ \n            result = NO; \n            break; \n        } \n         \n    } \n    return result; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is recursion an inefficient way to handle this?  Here's a fully functional php script which reverses both strings for comparison and then recurses only if the it finds a successful \"*\" match, in order to determine whether to skip or match it.  I also assume that \".*\" is not legal."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Finite state machine. Sudo code:  {{ fun IsMatch(s1, s2):  pos1 = 0; pos2 = 0;  while (pos1 < s1.Length && pos2 < s2.Length)   match = false;   if (s1[pos1] == s2[pos2] || s1[pos1]=='.') //A charachter match    match = true;    pos1++; pos2 ++;   if (s1[pos1] == '*') //Ignorable *    match = true;    pos1++; //pos2 doesn't change   if (!match && pos < s1.Length - 1 && s1[pos+1] == '*')    //Deleted charachter match    match = true;    pos1+=2; pos2 ++;   if (!match)    break;  if (match) print \"Match\" }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have never been on a technical interview, so please don't laugh at me... But how do I understand if I can use something already built-in in the language or whether I have to write everything from scratch? For example, in this situation, why can't we just write something like this:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Another solution for this would be to, simply replace the '*' by a '?' and use your languages regex library to check the string.  Pros: Less Code (fewer potential bugs), Easy to understand code."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using System; \nusing System.Collections.Generic; \nusing System.Diagnostics; \nusing System.Linq; \nusing System.Text; \nusing System.Threading.Tasks; \n  \n/* \nGiven a regular expression with characters a-z, ' * ', ' . '  \nthe task was to find if that string could match another string with characters from: a-z  \nwhere ' * ' can delete the character before it, and ' . ' could match whatever character. \n * ' * ' always appear after a a-z character. \n  \nExample:  \nisMatch(\"a*\", \"\") = true;  \nisMatch(\".\", \"\") = false; \nisMatch(\"ab*\", \"a\") = true;  \nisMatch(\"a.\", \"ab\") = true;  \nisMatch(\"a\", \"a\") = true; \n */ \nnamespace fb_regex \n{ \n class Program \n { \n  static bool isMatch(string pattern, string input) \n  { \n   if (pattern == null) \n    throw new ArgumentNullException(\"pattern\"); \n   if (input == null) \n    throw new ArgumentNullException(\"input\"); \n  \n   if (pattern.Length >= input.Length) \n   { \n    int i = 0, j = 0; \n    while (i < pattern.Length && j < input.Length) \n    { \n     if (pattern[i] != '.' && pattern[i] != input[j]) \n     { \n      // Ignore the current pattern character \n      if (i + 1 < pattern.Length && pattern[i + 1] == '*') \n      { \n       i += 2; \n      } \n      else \n      { \n       // The pattern and the input just don't match \n       return false; \n      } \n     } \n     // characters match \n     else \n     { \n      i++; \n      j++; \n       \n      // pattern: a*ab (same character before and after star) \n      if (i+1 < pattern.Length && pattern[i] == '*' && \n       pattern[i-1] == pattern[i+1]) \n      { \n       // try matching with 1) consuming the * 2) ignoring the * \n       return isMatch(pattern.Substring(i + 1), input.Substring(j - 1)) || \n         isMatch(pattern.Substring(i + 1), input.Substring(j)); \n      } \n      // character match, ignore the * \n      else if (i < pattern.Length && pattern[i] == '*') \n      { \n       i++; \n      } \n     } \n    } \n  \n    // pattern that matches the empty string \n    for (; i < pattern.Length; i += 2) \n    { \n     if (i + 1 == pattern.Length || pattern[i + 1] != '*') \n      return false; \n    } \n  \n    // no more pattern, but still some input left \n    if (j < input.Length) \n    { \n     return false; \n    } \n  \n    return true; \n   } \n   else \n   { \n    return false; \n   } \n  } \n  \n  static void Main(string[] args) \n  { \n   Debug.Assert(isMatch(\"abcd\", \"abcd\")); \n   Debug.Assert(isMatch(\"a*\", \"\")); \n   Debug.Assert(isMatch(\"a\", \"a\")); \n   Debug.Assert(isMatch(\"a*\", \"a\")); \n   Debug.Assert(isMatch(\"\", \"\")); \n   Debug.Assert(isMatch(\"aa*b\", \"aab\")); \n   Debug.Assert(isMatch(\"aa*b\", \"ab\")); \n   Debug.Assert(isMatch(\"a*a*a*.\", \"b\")); \n   Debug.Assert(!isMatch(\"a*a*a*.c\", \"b\")); \n   Debug.Assert(isMatch(\"a*a*a*.c\", \"bc\")); \n   Debug.Assert(isMatch(\"a*a*a*.c\", \"abc\")); \n   Debug.Assert(isMatch(\"a*a*a*.c\", \"aaabc\")); \n   Debug.Assert(!isMatch(\"a*a*a*.c\", \"aaaabc\")); \n   Debug.Assert(isMatch(\"a*b*c*d*\", \"c\")); \n   Debug.Assert(isMatch(\"a.\", \"ab\")); \n   Debug.Assert(!isMatch(\"\", \"a\")); \n   Debug.Assert(!isMatch(\".\", \"\")); \n   Debug.Assert(isMatch(\"b*.b*\", \"bab\")); \n   Debug.Assert(isMatch(\"b*.b*\", \"ab\")); \n   Debug.Assert(isMatch(\"b*.b*\", \"ba\")); \n   Debug.Assert(!isMatch(\"b.b*\", \"babc\")); \n   Debug.Assert(isMatch(\"a*abc\", \"abc\")); \n   Debug.Assert(isMatch(\"ab*c*d.\", \"abdg\")); \n   Debug.Assert(isMatch(\"abc*def\", \"abcdef\")); \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"+ (BOOL)isMatch:(NSString *)expression :(NSString *)string; {     if(expression==nil || string==nil) return NO;     if(!expression.length && !string.length) return YES;     if([expression hasPrefix:@\"*\"] || [expression hasPrefix:@\".\"]) return NO;     NSMutableString *expreCopy = [NSMutableString stringWithString:expression];     for(int i=0;i        unichar c = [expression characterAtIndex:i];         unichar ch = '*';         if (c == ch) {             [expreCopy replaceCharactersInRange:NSMakeRange(i-1, 2) withString:@\"**\"];         }     }     expression = [expreCopy stringByReplacingOccurrencesOfString:@\"**\" withString:@\"\"];     if(expression.length != string.length)return NO;     for(int i=0;i        BOOL match = ([expression characterAtIndex:i] == '.') || ([expression characterAtIndex:i] == [string characterAtIndex:i]);         if(!match) return NO;     }     return YES; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can achieve the O(n) solution without using recursion def isMatch(reg, str):     if not reg and not str:##both reg and str are NULL  return True     if len(reg) == 2 and reg[1]=='*':##reg='a*' and b=''  return str==''      i = 0     j = 0     while i < len(reg) and j < len(str):  if i+2     if reg[i] == str[j]:   i = i + 3   j = j + 1      else:   return False       elif reg[i] == '.':   i += 1   j += 1  else:      if reg[i]==str[j]:   i += 1   j += 1      else:   return False      return (i == len(reg) and j==len(str))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Run over the chars in the regexp and try find matches in the string itself.  Pseudo code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the usage of Java's Pattern object is allowed, this is a simple Regular Expression question - each 'a*' turns into \"(a)?\" regex string, and each '.' turns into '.' regex string.  For example, \"ab*..d\" turns into \"a(b)?..d\" regex string. Compile the pattern and match away."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class RegularExpression {      // s1 regex s2 match      public static boolean isMatch(String s1, String s2) {             // recursive implementation keeps shortening both strings from the right to left         if (s1.length() == 0 && s2.length() == 0) return true;           int i, j;         boolean point = false;         boolean star = false;          for(i = s1.length() - 1, j = s2.length() - 1;i >= 0 && j >= 0;) {             if(s1.charAt(i) == s2.charAt(j)) {                 i--;                 j--;                 continue;             }              if(s1.charAt(i) == '.') {                 i--;                 j--;                 point = true;                 continue;              }              if(s1.charAt(i) == '*') {                 j -= 2;                 star = true;                 continue;             }              if(s1.charAt(i) != s2.charAt(j)) {                 if(star) {                     if(s1.charAt(i) == s2.charAt(j + 1)) {                         i--;                          star = false;                         continue;                     }else                         return false;                 }                 return false;              }          }          return true;         }      public static void main(String []argc) {         System.out.println(isMatch(\"a*\", \"\"));         System.out.println(isMatch(\"Co.s*\", \"Cos\"));         System.out.println(isMatch(\"Co.s\", \"Coas\"));         System.out.println(isMatch(\"Co.sb*\", \"Coss\"));         System.out.println(isMatch(\"a*abc\", \"abc\"));      } } Is this ok? It should be better than the recursive solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nusing namespace std; \n \nbool isMatch(string s1, string s2) \n{ \n if(s1.length()==0 && s2.length()==0) \n  return true; \n string s1_next = s1.substr(0, s1.length()-1); \n string s2_next = s2.substr(0, s2.length()-1); \n if(s1[s1.length()-1]=='*') \n { \n  string s1_next_next = s1.substr(0, s1.length()-2); \n  return isMatch(s1_next, s2) || isMatch(s1_next_next, s2); \n } \n else if(s1[s1.length()-1]=='.' && s2[s2.length()-1]!='\\0') \n { \n  return isMatch(s1_next, s2_next); \n } \n else \n { \n  return s1[s1.length()-1]==s2[s2.length()-1] && isMatch(s1_next, s2_next); \n }     \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"DP solution.  use array to record previous match. when s[i] == p[j] or p[j] is '.' current match is true only when p's previous match s's previous  but when p[j] is '*', there are two conditions: 1) ignore the '*', current match is true only when p's previous match current s 2) delete previous p[j-1], current match is true only when p's previous'previous match with current s     bool isMatch(string s, string p)  {   int n = s.length();   int m = p.length();    vector pv(n+1, false); // row -2   vector v(n+1, false); // row - 1   v[0] = true;    for(int i=0; i  {    vector nv(n+1, false);    for(int j=0; j   {     if (p[j] == s[i] || p[j] == '.') // 'a' == 'a'     {      nv[j+1] = v[j]; // only when previous match     }     else if (p[j] == '*')     {      nv[j+1] = v[j+1] || pv[j+1]; // ignore * || delete previous c     }    }    pv = v; // row i-2 for next round    v = nv; // row i-1 for next round   }    return v[n];  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool isMatch(const char* s, const char* p){ \n        if(*p == '\\0') return *s == '\\0'; \n        if(*(p+1) == '*'){ \n                if(*p == *s || (*s != '\\0' && *p == '.')) return isMatch(s+1, p+2) || isMatch(s, p+2); \n                else return isMatch(s, p+2); \n        } \n        else{ \n                if(*p == *s || (*s != '\\0' && *p == '.')) return isMatch(s+1, p+1); \n                else return false; \n        } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ruby 2.0.0 implementation"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"How about comparing the string and the regex from the end. The non-trivial case of '*', we need to follow both paths of deleting and not deleting the previous character.   Can be solved using recursion."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public bool isMatch(char* text, char* pattern){ \n    if(text == NULL && pattern == NULL){ \n        return true; \n    } \n    if(pattern == NULL){ \n        return false; \n    } \n    if(text == NULL && *(pattern + 1) != '*'){ \n        return false; \n    } \n    if(*(pattern + 1) == '*'){ \n        return isMatch(text, pattern + 2) \n          || (*text == *pattern || *pattern == '.') && isMatch(text + 1, pattern); \n    } \n    return (*text == *pattern || *pattern == '.') && isMatch(text + 1, pattern + 1); \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6193320829124608","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"11","title":"Given a undirected graph, source and destination, write the code to find the total number of distinct nodes visited, considering all possible paths.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Since we need to consider all the simple paths, I propose the following algorithm: Do a normal dfs(or bfs) rooted at the src node. We keep a visited array to track that we do not run into loops. When we have found the destination at some point in the traversal, we return from that search branch. At the end of the recursive call, we mark the node as un-visited, so that we can explore other paths which may emerge from this node. Also to track the uniqueness of the nodes visited, we add all the nodes on a particular path in a set(set have the property of storing only unique elements). I think that we can do better in space complexity. Sample code is as follows, I've tested it for small inputs:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since you didn't say \"simple path\" we must consider a loop off of any simple path from src to dest and count the vertices in the loop too.  And if such a loop exists, there are infinite paths from src to dest.   So take care to make sure any algorithms that correctly add the vertices of such a loop doesn't run forever...  :)  That is to say your \"considering all paths\" should not be literally translated to \"must traverse all paths.\""},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It's an undirected graph, so paths dont matter. You could go to a far away node, come back to the source and then go to the destination. The only thing that matters is if the two nodes are in the same connected component (if they are not you should return -1 or something of a sort). Otherwise pick all of source neighbours, and there neighbours etc and put them into a set, if the node is already in the set, then you dont need to go to it heighbours again. When you are done, if destination is in the set, just count the nodes in the set (which you could have done on your way to building the set) and possibly substract 2, in case you don't want to consider the source and destination"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"practically... we cannot use loops... as it will only add to complexity... also.. in computr netwrx... if u keep visiting a group of hops again and again... it will send back an icmp packet... so may be it is obvious to rule out the possibility of loops... now.. for each node.. we first mpodify the structure to contain a boolean flag.. which we will turn on visiting each node... so thus.. it will tell us if we have entered some loop or not... then.. we can use the recursive function... to generate all posiible paths..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is part of a class that could solve the problem. The key is to DFS and recurse on any nodes not in your current path while looking for the destination node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static int CountDistinctNodesFromSourceToDestination(List[] graph, int n, int source, int dest) \n{ \n    bool[] inPath = new bool[n]; \n \n    DFS(source, dest, graph, new bool[n], inPath); \n \n    return inPath.Where(_ => _).Count(); \n} \n \nstatic bool DFS(int v, int dest, List[] g, bool[] used, bool[] inPath) \n{ \n    bool pathFound = false; \n    if (v == dest) \n    { \n        pathFound = true; \n    } \n    else \n    { \n        used[v] = true; \n \n        foreach (int u in g[v]) \n        { \n            if (!used[u]) \n            { \n                pathFound |= DFS(u, dest, g, used, inPath); \n            } \n        } \n \n        used[v] = false; \n    } \n \n    inPath[v] |= pathFound; \n \n    return pathFound; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"is it allowed to visit to visit a node more than 1 time in different paths?  how many paths are there in the following graph: ideone.com /YD2KMm ? src = 0, dst = 6"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I propose a recursive solution using memoization. You start DFS from the source, visiting all the nodes till you meet destination. If you can reach a destination from a given node, then you add it to the sum, otherwise you don't. Please see the following pseudo code."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5922416572235776","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"10","title":"Write code to print all different paths in an undirected graph from a given source to destination with no loop(any node can be at most once in a path ).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"You can do smth similar to DFS( or BFS) travel that you only visit the node that you have not visited to prevent loop. You also have to keep track the path from the source so that we can print it out when you reach the destination.  Something to note - The length of the path is less or equal to N which is the number of vertices - When you reach the destination then print the path and stop the current search branch since the destination can not be visited second time  - We need to un-visit a node at the end of the recursive function to allow investigation from other branch that might come back to the same node (this is the main different from original DFS or BFS)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{{ class Graph { public:     Graph(int n) : g(n), visit(n, false), path(n, -1) {}     void add(int from, int to) {          g[from].push_back(to); g[to].push_back(from); }     void print_path(int l) const {           for (int i=0; i< l; ++i) cout << path[i] << ' ';           cout << endl;      }     void traverse(int source, int dest) {  fill(visit.begin(), visit.end(), false);  DFS(source, dest, 0);      }   private:     void DFS(int u, int dest, int level) {  path[level] = u;  if (u == dest) {      print_path(level+1);      return;  }  visit[u] = true;  for (auto v : g[u] )      if (!visit[v])           DFS(v, dest, level + 1);         visit[u] = false;     }     vector > g;     vector visit;     vector path; } }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class Graph { \npublic: \n    Graph(int n) : g(n), visit(n, false), path(n, -1) {} \n    void add(int from, int to) {  \n        g[from].push_back(to); g[to].push_back(from); } \n    void print_path(int l) const {   \n        for (int i=0; i< l; ++i) cout << path[i] << ' ';   \n        cout << endl;  \n    } \n    void traverse(int source, int dest) { \n fill(visit.begin(), visit.end(), false); \n DFS(source, dest, 0);  \n    }   \nprivate: \n    void DFS(int u, int dest, int level) { \n path[level] = u; \n if (u == dest) { \n     print_path(level+1); \n     return; \n } \n visit[u] = true; \n for (auto v : g[u] ) \n     if (!visit[v])  \n         DFS(v, dest, level + 1); \n        visit[u] = false; \n    } \n    vector > g; \n    vector visit; \n    vector path; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void PrintAllPaths(List[] graph, int n, int source, int dest) \n{ \n    DFS(source, dest, graph, new List(), new bool[n]); \n} \n \nstatic void DFS(int v, int dest, List[] g, List path, bool[] used) \n{ \n    path.Add(v); \n    used[v] = true; \n     \n    if (v == dest) \n    { \n        Print(path); \n    } \n    else \n    { \n        foreach(int u in g[v]) \n        { \n            if (!used[u]) DFS(u, dest, g, path, used); \n        } \n    } \n     \n    path.RemoveAt(path.Count - 1); \n    used[v] = false; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"print path in a recursive way"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ArrayList> allPath(Node s, Node t){ \n Queue> q = new Queue>(); \n ArrayList list = new ArrayList (); \n list.add(s); \n q.enque(list); \n ArrayList> result = new ArrayList>(); \n while(!q.empty()){ \n  ArrayList cur = q.deque(); \n  Node temp = cur.get(cur.size()-1); \n  for(Node n : temp.neighbors){ \n   if(!cur.contains(n)){ \n    ArrayList tar = new ArrayList(cur.subList(0, cur.size())); \n    tar.add(n); \n    if(n == t){ \n     result.add(tar); \n    }  \n    else \n     q.enque(tar); \n   } \n  } \n } \n return result; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here my C++ solution:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5978392075698176","download_status":"DOWNLOAD_DONE","votes":"-2","answersCount":"21","title":"As we know facebook always asks questions from graph theory he asked me this problem to code-  there is a grid of n*n where each cell represent an Island or and some of these are very dangerous so u have to avoid these during path selections.You can move up,down,left ,right.You are given your starting position ,positions of dangerous Islands and position some specific  Islands.Your task is to deliver a message to all the specific Islands in minimum number of moves to all specific Islands(NOTE- there are also chances that no moves are  possible to cover all specific Island ,in such case you have to tell \"NOT POSSIBLE TO DELIVER ALL \",otherwise output minimum moves).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"This is similar to the Travelling Salesman problem, which is NP-hard.  - If the number S of specific islands is quite small, say <= 20, we can perform S+1 Breadth First Searches to find all pairs of distances between the S islands and the initial position. Then, we can check all permutations of the S islands and calculate the cost of the possible paths \"Initial pos -> Island_1 -> .. Island_S\" using the distances calculated above. We can use dynamic programming to find the best path. The DP state can be the current specific island and a bitmask with the covered islands so far. The running time will be O(S^2 * 2^S + S * N^2).  Note that 2^20 is about 1 million which allows this solution to be fast.  - If there are more specific islands, we can try A*. I don't know much about heuristics but we should try to discuss them with the interviewer. Like using the number of the islands covered so far and the current cost."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think Gedo Mazo might be right....  He is saying use grid's geometric properties instead of viewing this problem in isolation as an abstract graph.  The example that Miguel posted seems misleading, since on a grid it would look something like this:  ############### E_ _D_ _A_B_ _C ############### so the distances are from A { B=1, D=2, C=3, E=4} Select B. from B { D=3, C=2, E=5} Select C. from C {D=5, E=7} Select D From D { E=2} select E total : 1+2+5+2 = 10.    Maybe the question poster should add if edges between the given islands need to be calculated or are already provided ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this problem is not asked by FB, but it is asked in Illuminati Hiring Challenge that ended today on HackerRank.com. Only the words have been changed, problem seems to be exactly what was asked there."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi, i implemented this algo...i dont print NOT POSSIBLE TO DELIVER ALL...but the rest should be there...  please give me some feedback."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this could be done by BFS several times.  1) find the first reach able island by BFS from start point.  and let's count the #mov 2)  empty that start point, and set the node the we found from previous as start point and repeat  1) again      int valid(vector> &vv, int n, int nx, int ny, queue &nq)  {   if (nx >= 0 && nx < n && ny >=0 && ny < n && (vv[nx][ny] == 0 || vv[nx][ny] == 1))   {    Point * p = new Point(nx, ny);    nq.push(p);    int ret =  vv[nx][ny];    vv[nx][ny] = -1;    return ret;   }   return -1;  }   int traval(int n, vector &spec, vector &dan, Point* start){   // no need to travel   if (spec.size() == 0)    return 0;    // init matrix, set as all pass   vector> vv;   for(int i=0; i  {    vector v(n, 0);    vv.push_back(v);   }    // set spec points   for(int i=0; i  {    vv[spec[i].x][spec[i].y] = 1;   }    // set dangerous points   for(int i=0; i  {    vv[dan[i].x][dan[i].y] = 2;   }   int mov = 0;   for(int i=0; i  {    int nmov = nextNode(n, vv, start);    if (nmov > 0){     mov +=nmov;    }    else{ // no possible path     return -1;    }   }   return mov;  }   int nextNode(int n, vector> &vv, Point* &start)  {   // reset   for(int i=0; i  {    for(int j=0; j   {     if (vv[i][j] < 0)     {      vv[i][j] = 0;     }    }   }    // BFS, start from start point   queue q;   vv[start->x][start->y] = -1;   q.push(start);    int mindepth = INT_MAX;   int depth = 0;   while(!q.empty())   {    queue nq;    depth ++;    while(!q.empty())    {     // for each current, add children     Point* p = q.front();     q.pop();     if (valid(vv, n, p->x-1, p->y, nq) == 1)     {      start = p;      return depth;     }     if (valid(vv, n, p->x, p->y-1, nq) == 1)     {      start = p;      return depth;     }     if (valid(vv, n, p->x+1, p->y, nq) == 1)     {      start = p;      return depth;     }     if (valid(vv, n, p->x, p->y+1, nq) == 1){      start = p;      return depth;     }    }    q = nq;   }    return 0; // not possible  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"Its a simple MST problem. There is no condition that the tour should end at the starting point, therefore its not a TSP problem.  I would use Prims since edges need to be calculated.  Edge calculation can be tricky. I would use the line formula to get the straight line between two \"islands\". , if it has any objectionable islands, just move around them. If the dangerous islands are together and form some random shape, then go around the shortest periphery.  Repeat that for all the islands, then you get a set of edges, select the one with least number of steps and add it to your edge set.  proceed till no vertices are left untouched."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-4","title":"MST"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-6","title":"variation of flood fill algorithm"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5435439490007040","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"15","title":"// merge sorted arrays 'a' and 'b', each with 'length' elements, // in-place into 'b' to form a sorted result. assume that 'b' // has 2*length allocated space. // e.g. a = [1, 3, 5], b = [2, 4, 6] => b = [1, 2, 3, 4, 5, 6]  //how to do it without rearanging the b array","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"The idea is merging from the back of the b array so the write op of the merge is never interfered with read op from b"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"We just need to merge from the end. Here is my python solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It can be done in one loop."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int[] inplaceSort(int x[], int y[]) { \n        int endIndex = x.length-1; \n        int xIndex = y.length-1; \n        int yIndex = xIndex; \n        // Starting at the end of x iterate backwards putting each value in it's place \n        for (int i=endIndex; i>=0; i--) { \n            System.out.println(\"Comparing \"+x[xIndex]+\" and \"+y[yIndex]); \n            //find the max value between x[xIndex] & y[yIndex] \n            if (x[xIndex] > y[yIndex]) { \n                System.out.println(\"x[\"+xIndex+\"](\"+x[xIndex]+\") > y[\"+yIndex+\"](\"+y[yIndex]+\")\"); \n                x[i] = x[xIndex]; \n                xIndex--; \n                if (xIndex < 0 && i>0) { \n                    x[0]=-1; \n                    xIndex=0; \n                } \n            } else { \n                System.out.println(\"x[\"+xIndex+\"](\"+x[xIndex]+\") <= y[\"+yIndex+\"](\"+y[yIndex]+\")\"); \n                x[i] = y[yIndex]; \n                yIndex--; \n                if (yIndex < 0 && i>0) { \n                    y[0] = -1; \n                    yIndex = 0; \n                } \n            } \n        } \n        return x; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Starting from the last element of b and going towards the first, we apply a merge similar to the merge step of mergeSort.  If B has moved completely and A still has elements, move the remaining elements of A to B. Otherwise, no need to move anything. B elements are already there!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"-(NSArray *)mergeFirstSortedArray:(NSArray *)firstArray withSecondSortedArray:(NSArray *)secondArray{ \n    NSMutableArray *secondMutable = [secondArray mutableCopy]; \n    NSInteger secondArrayCount = [secondArray count]; \n    NSInteger currentIndex = 0; \n    for (NSNumber *num in firstArray) { \n        while (currentIndex < secondArrayCount) { \n            if ([num integerValue] < [secondMutable[currentIndex] integerValue]) { \n                [secondMutable insertObject:num atIndex:currentIndex]; \n                currentIndex++; \n                break; \n            } \n            else{ \n                currentIndex++; \n            } \n        } \n    } \n    return secondMutable; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void Merge(int[] a, int[] b) // assumption: length of b is twice bigger than length of a \n{ \n    int i = a.Length - 1; \n    int j = a.Length - 1; \n     \n    for (int p = b.Length - 1; p >=0; p--) \n    { \n        if (i >= 0 && (j < 0 || a[i] > b[j])) \n        { \n            b[p] = a[i--]; \n        } \n        else \n        { \n            b[p] = b[j--]; \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void merge(int[] a, int[] b, int length){ \n assert(a.length == length); \n assert(b.length == 2*length); \n int i = length-1; \n int j = length-1; \n for(int k = 1; k<=length*2; k++){ \n  a[i] > b[j]? i--:j--; \n  b[length*2-k] = a[i] > b[j]? a[i]: b[j]; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"JavaScript  }}} function merge(left, right){  var result = [];  while(left.length && right.length){   if(left[0] <= right[0]){    result.push(left.shift());   }else{    result.push(right.shift());   }  }   while(left.length){   result.push(left.shift());  }  while(right.length){   result.push(right.shift());  }   return result;  } }}}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#Seems to be fairly straightforward with Ruby  def merge_arrays a, b"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#Seems to be fairly straightforward with Ruby  \ndef merge_arrays a, b \n (a | b).sort \nend"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Java solution. Took about 15 mins, including testing edge cases. Code could be improved."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5188884744896512","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"10","title":"boolean isBST(const Node* node) {   // return true iff the tree with root 'node' is a binary search tree.   // 'node' is guaranteed to be a binary tree. }       n     / \\    a   b     \\      c","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"We have to traverse the tree and check the validity at each node. Even though this condition is often expressed as:   max(left_child)  < node_value < min(right_child)  which lead to the following code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There is one more solution to this problem, which provides the result in O(n):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This method may be helpful though signature of the method is little different."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"method (3) suggested by LinhHA05 seems the best one to remember. I had used in the past"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"See also oj.leetcode.com/problems/validate-binary-search-tree/  My solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Keep an out-side array and fill it by in-order traversal - if this array is ascending then we have a BST"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Can't it be this simple? I was amazed at the complex code above. If I am not right, please correct me. Thanks in advance!  Write it in Java, as the language choice is not important."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5399897561890816","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"32","title":"Initially there is a number n written on board. Two players start playing a game turn by turn. Each player has to replace the number n written on the board by n-2^k (for some k >= 0 such that 2^k < n)?  Also the number n-2^k has to be as beautiful as n (The beauty of a  number depends on the number of one's in its binary representation). The  player loses the game when he can't select any such k. Given the initial number n, determine which player will win the game if both players play optimally. n > 0 and n <= 10^9.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"The total number of rounds would be number of 0s before each 1 bit set in n. If n = 12 (1100). Then the player-1 selects k=1 to conserve the same number of 1s in the number. So, now n becomes 10(1010). Then player-2 selects k=0 and n becomes 9(1001). Then it continues to 5(0101)->3(0011). Total number of rounds is 4 which is number of zeroes before each 1 bit set in n. If you further look to conserve the property of equal number of 1s the player will select a k such that it is the first zero that has next higher bit set to 1. Here is the code in action:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"For the input n, in binary format \"100101\", the first player, A will lose the game, and the second player B, will win. BC, A can change n to \"100011\" or \"10101\", at the first round. For \"100011\", B can easily win the game. For \"10101\", B can win the game by change it to \"10011\". We can change the model of this problem to the following. Considering there are several buckets, in each of them, there are some balls (means the number of '0'), or, nothing. For instance, \"100101\" can be represented by 2 buckets, the first bucket has 2 balls and second has 1. Then, for each player, he can pick one bucket and move one ball from the this bucket (ith one) to the (i - 1)th bucket. Of cause, we can only move the ball forward. The guy that moves the last ball win the game."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"As oldtimer said, the game ends when all ones are on the least significant bits. So we basically need to count how many swaps we need to make the zeros go to the most significant bits. For each bit set to 1, the number of swaps needed is equal to the number of 0s in the least significant bits. If the total number of swaps is odd, player A wins, else B wins."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what if n= 11 written on board..... the binary representation will be [1111] now second there can be no value of K for which you can get more then 4 one's for eq: n-2^k"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the last move made by a player was such that allones in binary representation are moved to the lsb position then that player becomes the winner.  eg. A : 10 [1010] B : 9   [1001]   -> diff.from previous = 2^0 A : 5   [0101]   -> diff.from previous = 2^2 B : 3   [0011]   -> diff.from previous = 2^1 ==> winner  eg.  A : 13  [1101] B : 11  [1011]   -> diff.from previous = 2^1 A :  7  [0111]     -> diff.from previous = 2^2  ==> winner"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My answer is, if you have the value n, and the indexes for n = n[i]*2^i-1 + n[i-1]*2^i-2 + ... + n[2]*2 + n[1] if you add the indexes a of the values n for which n[a] == 0, and that value is even, then team Friend 1 wins if you add the indexes and that value is odd then Friend 2 wins"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Brute force :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void judgeWinner(int n){ \n String b = Integer.toBinaryString(n); \n int extra = 0; \n for(int i = 1; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Based on the previous discussion, we can change the question to judge the number of moves to compact the number so at last all the number 1 get stay together, like '11111'. So in order to calculate the total number of moves, we can go through the following ways. First, find the first occurrence of 0 in the sequence. Then find the number 1 just behind this first 0. Then the moves for this round should be the subtract of both first 0 and 1 after it. Then we swap these two numbers in the array.      We keep on the process until we cannot find number 1 after the so called first 0. Then the total number of moves will be the judge base. Let it as count. If count is odd, then that means player 1 wins. Otherwise player 2 wins. The code are attached below, I just print the total move number:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"f(1) = false; f(n) = !f(n-2^0) | !!f(n-2^1) ... !f(n-2^k)    (2^k < n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"is this for phone interview or on site?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Isn't the question to come up with a number that has same number of 1's as the given number before they all run out? If yes, it would be n!/a!(n-a)! where n is the number of all binary digits the max number (10^9) can have, and a is the number of 1's in the given number x. If the result is even one wins otherwise..."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5197969674469376","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"21","title":"Given a string Sting=\"ABCSC\" Check whether it contains a Substring=\"ABC\"?  1)If no ,  return \"-1\". 2)If yes , remove the substring from string and return \"SC\".     use very simple code and concept(ALGORITHM)..","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Since the question says \"use very simple code and concept(ALGORITHM)\", I suppose they don't want any sophisticated like the KMP algorithm to find substring occurrences."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"#include  \n#include  \n \nusing namespace std; \n \nint main()  \n{ \n string a,b;  // I will take both string input from user and check whether b is substing of a or not. \n cin>>a; \n cin>>b; \n int idx = 0; \n idx = a.find(b); // Checking whether b is substring of a. \n if(idx == 0) \n { \n  int l = b.length(); \n  a = a.substr(l); \n  cout<<<\"\\n\"; \n } \n else if(idx > 0) \n { \n  int l = b.length(); \n  string temp=\"\"; \n  temp = a.substr(0,idx); \n  a = a.substr(idx+l); \n  cout<<<<\"\\n\"; \n } \n else \n { \n  cout<<\"-1\\n\"; \n } \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"var string = \"ABCSC\"; ((string.indexOf(\"ABC\") != -1) ? (string.replace(/ABC/gm,\"\")) : (-1));"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"JavaScript"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Maybe you should use hashing and Rabin-Karp Algo?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Examples: \"zabcaabcbcs\" should result \"zs\" , if there is multiple existence of substring. can be done very simply in java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Well here is a code written very easily in Python 3.3.2, have a look :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for 'ABABCCSC' what do you think ans should be 'ABCSC'  OR 'SC' ??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"KMP to find the target in the source string. Then do the following:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public string ABC(string str) { \n             string temp=\"\"; \n             string res = \"\"; \n             int j; \n             for (int i = 0; i < str.Length; i++) { \n \n                 //j = str.Length - i; \n                 for (j=str.Length - i; j > 0; j--) \n \n                     if (str.Substring(i, j) == \"ABC\") \n                     { \n                         res = str.Replace(\"ABC\", \"\"); \n                         return res; \n                     } \n                     else \n                         res = \"-1\"; \n              \n             } \n \n             return res; \n \n         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) {          String string = \"ABCSC\";         String substring = \"ABC\";          System.out.println(containsSubString(string, substring));     }      public static String containsSubString(String string, String substring){         if (string.contains(substring)){             int leftIndex = string.indexOf(substring);             int rightIndex = leftIndex + substring.length();             StringBuilder stringBuilder = new StringBuilder(string);             stringBuilder.replace(leftIndex, rightIndex, \"\");             return stringBuilder.toString();         }         return Integer.toString(-1);     }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Dynamic prorgamming for Longest Common Substring where the substring found needs to be of the length of the needle. And if there could be recursively embedded abcs, then we would probably have to run this continually until the function eventually returns -1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"<br/>var str=\"ABCSC\"; <br/>reg=/ABC/; <br/> <br/>if(reg.exec(str)) <br/>       str=str.replace(\"ABC\", \"\"); <br/>else <br/>       return -1; <br/>document.write(str); <br/>"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This is fairly simple in javascript using the .contains and .replace String methods."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"Use KMP!!"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5761467236220928","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"22","title":"Given an array of randomly sorted integers and an integer k, write a function which returns boolean True if a pair of numbers exists in the array such that A[i] + A[j] = k and False otherwise.  Provide an O(N) and an O(N log N) solution.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"Method 1: Sort the array and then do the following (O(n log n)):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"O(N):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can you elaborate more on \"randomly sorted\"? Perhaps also give an example."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. NlogN to sort (from smallest to largest), then two indices: i=0, j=N; if A(i)+A(j) > k, j--; if(A(i)+A(j) < k) i++ 2. bucket sort?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"from collections import defaultdict \n \ndef check(a): \n    #a = [...] # array \n    n = len(a)  \n    h = defaultdict(int) \n    for i in range(n): \n        h[a[i]] += 1 \n    for i in range(n): \n        d = k - h[a[i]] \n        if (h[d] > 0) return True \n    return False"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If we know about the range (max value of elements) than we use redix sort and than use first approach of Anonymous ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(N) -- two pointer one at starting and one at end  i=0; j=a.length if a[i]+a[j]==NUM  return a[i] and a[j] if a[i]+a[j]>NUM      j--  else    i++  O(NLOGN) for each a[i]    do binary search in the sorted array to find the othe number which makes up the sum"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int diff = k - a[i] // where i is an index of the array Then find element equals to 'diff' in array except index i This gives a O(n) solution, right?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"-(BOOL)checkSumInArray:(NSArray *)myArray isEqualTo:(NSInteger)k{ \n    int front = 0; \n    int back = [myArray count]-1; \n    BOOL result = NO; \n    //sort array \n    [myArray sortedArrayUsingSelector: @selector(compare:)]; \n    while (front < back) { \n        NSInteger sum = [myArray[front] integerValue] + [myArray[back] integerValue]; \n        if (sum == k) { \n            result = YES; \n            break; \n        } \n        else if (sum > k){ \n            back--; \n            continue; \n        } \n        else{ \n            front++; \n            continue; \n        } \n    } \n    return result; \n     \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(N logN):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.HashSet; \nimport java.util.Set; \npublic class TwoNumSum { \n public static void main(String[] args) {  \n  int sum = 20; \n  int [] nums = {1,4,5, 16, 17, 20}; \n  for(int i : twoNumSum(sum, nums)) \n   System.out.print(i + \"\\t\"); \n } \n public static int[] twoNumSum(int sum, int [] nums){ \n  //This is O(n) algorithm.  \n  int [] r  = new int[2]; \n  Set  hs = new HashSet(); \n  for(Integer intg: nums ) \n   hs.add(intg);  \n   \n  for(Integer intg: nums ){ \n   if (hs.contains(sum - intg)){ \n    r[0] = intg; \n    r[1] = sum -intg; \n   } \n  } \n  return r; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int sum_pair_n(const int *i, const int size, const int sum) \n{ \n int tail = size - 1; \n int head = 0; \n int iSum; \n \n while(head < tail) \n { \n  iSum = i[head] + i[tail]; \n  if(iSum == sum) \n  { \n   return 1; \n  } \n  else if(iSum < sum) \n  { \n   head++; \n  } \n  else if(iSum > sum) \n  { \n   tail--; \n  } \n } \n return 0; \n} \n \nint sum_pair_logn(const int *i, const int size, const int sum) \n{ \n int head = 0; \n int look_for; \n \n while(head < size) \n { \n  look_for = sum - i[head]; \n  int h=head+1, t=size; \n  while(h<=t) \n  { \n   if(i[(h+t)/2] == look_for) \n   { \n    return 1; \n   } \n   else if(i[(h+t)/2] > look_for) t = (h+t)/2 - 1; \n   else if(i[(h+t)/2] < look_for) h = (h+t)/2 + 1; \n  } \n  head++; \n } \n return 0; \n} \n \nint main() \n{ \n int i[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; \n printf(\"%d\\n\", sum_pair_n(i, 10, 5)); \n printf(\"%d\\n\", sum_pair_logn(i, 10, 4)); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"1. Sorting the array in (NlogN)  and then find out the pair in (logN) by using binary search. 2. Divide n Conquer would go."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6189585818189824","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"26","title":"We are given a set of integers with repeated occurences of elements. For Example, S={1,2,2}. We need to print the power set of S ensuring that the repeated elements of the power set are printed only once. For the above S, the power set will be {NULL, {1}, {2}, {2}, {1,2}, {1,2}, {2,2}, {1,2,2}}. So, as per the question requirements, we need to print {NULL, {1}, {2}, {1,2}, {2,2}, {1,2,2}}","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"\"set of integers with repeated occurences of elements\" this is mathematically incorrect. A set does not have repeated elements. A Multiset does.  Anyway, we can shrink the input in pairs: (number, n_occurrences) and generate the power set with a recursive function. Sample code in C++:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"It looks like powerset problem!   for each element of input : If it is visited for the first time, just add it to all sets that has been added to powerset.   else check hashmap to find number of this element that has been visited, then add new element to set(s) that has exactly this number of duplication."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"import java.lang.*; import java.util.*; import java.math.*; public class powerset_without_repeating { public static void main(String[] args) {  int a[]={1,2,2};  int n=a.length;  int cf=(int)Math.pow(2,n);  Listl=new ArrayList();  for(int c=0;c  String s=\"\";   for(int j=0;j   int x=c&(1<   if(x!=0){     s+=a[j];         }   }   if(!l.contains(s)){    l.add(s);   }  }  for(String st:l){   System.out.println(st);  }   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void power_set(vector& v, vector< vector > >& res){ \n res.push_back(vector >(1, vector())); \n if(v.size() == 0){ \n  return; \n } \n res.push_back(res[0]); \n res.back().push_back(vector(1,v[0])); \n if(v.size() == 1) \n  return ; \n for(int i = 1; i < v.size(); i++){ \n  int start = 0; \n  res.push_back(res.back()); \n  if(v[i] == v[i-1]) start = res[res.size()-3].size(); \n  vector > tmp = res[res.size()-2]; \n  for(int j = start;j < tmp.size(); j++){ \n   tmp[j].push_back(v[i]); \n   res.back().push_back(tmp[j]); \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"js code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can we assume that the input set is sorted and can contain duplicates as in  S={1,2,2} instead of  S={2,1,2}?  If we can assume so, the solution becomes simpler: To generate a power set of a given a set of length n 1) Generate sets of size 0 to n. Use the permutation/ combination algorithm for each sizes to generate the sets. 2) When doing so, you just need to remember the previously generated set. For example, when generating sets of size 2, I would get {1,2} and {1,2} twice right after each other since they are sorted. So, I just record the previously generated set, compare with the currently generated set. If the set is different, print it.  Running time - 2^n Space - Constant"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ssds"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"python solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Scanner; class ARR { public static void main(String a[]) { int m,s; int k=0; int arr[]=new int[5]; int temp[]=new int[5]; System.out.println(\"enter values for array\"); Scanner sc=new Scanner(System.in); for(int i=0;i<5;i++) { arr[i]=sc.nextInt(); } for(int i=0;i<5;i++) { int f=0; for(int j=i-1;j>=0;j--) { if(arr[i]==arr[j]) { f=1; break; } } if(f==0) { temp[k]=arr[i]; k++; } } for(s=1;s<=k;s++) { int i; for( i=0;i{System.out.print(\"{\"); System.out.print(temp[i]); for(int j=i+1;j{ System.out.print(\",\"+temp[j]); }  System.out.println(\"}\\n\"); } } } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Scanner; class ARR { public static void main(String a[]) { int m,s; int k=0; int arr[]=new int[5]; int temp[]=new int[5]; System.out.println(\"enter values for array\"); Scanner sc=new Scanner(System.in); for(int i=0;i<5;i++) { arr[i]=sc.nextInt(); } for(int i=0;i<5;i++) { int f=0; for(int j=i-1;j>=0;j--) { if(arr[i]==arr[j]) { f=1; break; } } if(f==0) { temp[k]=arr[i]; k++; } } for(s=1;s<=k;s++) { int i; for( i=0;i{System.out.print(\"{\"); System.out.print(temp[i]); for(int j=i+1;j{ System.out.print(\",\"+temp[j]); }  System.out.println(\"}\\n\"); } } } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Scanner; class ARR { public static void main(String a[]) { int m,s; int k=0; int arr[]=new int[5]; int temp[]=new int[5]; System.out.println(\"enter values for array\"); Scanner sc=new Scanner(System.in); for(int i=0;i<5;i++) { arr[i]=sc.nextInt(); } for(int i=0;i<5;i++) { int f=0; for(int j=i-1;j>=0;j--) { if(arr[i]==arr[j]) { f=1; break; } } if(f==0) { temp[k]=arr[i]; k++; } } for(s=1;s<=k;s++) { int i; for( i=0;i{System.out.print(\"{\"); System.out.print(temp[i]); for(int j=i+1;j{ System.out.print(\",\"+temp[j]); }  System.out.println(\"}\\n\"); } } } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static List AllSets(int[] a) \n{ \n    return AllSets(a, 0, new List()).ToList(); \n} \n \nstatic IEnumerable AllSets(int[] a, int i, List curr) \n{ \n    if (i == a.Length) \n    { \n        yield return curr.ToArray(); \n    } \n    else \n    { \n        foreach(var s in AllSets(a, i + 1, curr)) \n        { \n            yield return s;         \n        } \n         \n        curr.Add(a[i]); \n         \n        foreach(var s in AllSets(a, i + 1, curr)) \n        { \n            yield return s;         \n        } \n         \n        curr.RemoveAt(curr.Count - 1); \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class PowerSet { \n \n static void go(int index, int [] inp,String out) { \n  if( index == inp.length) return; \n  int pre = -1; \n  for(int i=index;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"C solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; \nimport java.util.Comparator; \nimport java.util.Set; \nimport java.util.TreeSet; \n \npublic class PowerSet { \n \n public static void main(String[] args) { \n  int []  ns = {0, 2, 1, 2}; \n  System.out.println(powerSet(ns).toString());  \n } \n public static Set> powerSet(int [] ns){ \n  AListComparator comp = new AListComparator(); \n  Set > all = new TreeSet>(comp); \n   \n  ArrayList al = new ArrayList();  \n  all.add(null); \n  perm(0, ns, all, al); \n  return all; \n } \n  \n private static void perm(int size, int [] ns, Set> all, ArrayList al){ \n  for(int i = size; i < ns.length; i++ ){ \n   ArrayList tal = new ArrayList(); \n   if( al != null ) \n    tal.addAll(al); \n   tal.add(ns[i]); \n   all.add(tal); \n \n   ArrayList tal2 = new ArrayList(); \n   tal2.addAll(tal); \n   //And further processing.  \n   perm(i + 1, ns, all, tal2); \n  } \n } \n  \n} \nclass AListComparator implements Comparator>{ \n \n public int compare(ArrayList o1, ArrayList o2) { \n  if(o1 == o2){ \n   return 0; \n  }else if ( o1 == null && o2 != null){ \n   return -1; \n  }else if ( o1 != null && o2 == null ){ \n   return 1; \n  }else if ( o1.size() < o2.size() ){ \n   return -1; \n  }else if ( o1.size() > o2.size() ){ \n   return 1; \n  } \n  for( int i = 0 ; i < o1.size(); i++ ){ \n   if( o1.get(i) > o2.get(i)) \n    return 1; \n   else if ( o1.get(i) < o2.get(i)) \n    return -1; \n  } \n  return 0;   \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Look similar to oj.leetcode.com/problems/subsets/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the key thing is that if the inputs are sorted. we should skip expending the powerset from current element, if it has the same value as previous."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This code will be ok."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"set < vector < int > > PowerSet(vector < int > a) \n{ \n  int n = a.size(); \n    set < vector < int > > ret; \n    int num = (1 << n); \n    for(int i = 0; i < num; ++i) \n    { \n        vector < int > v; \n        for(int j = 0; j < n; ++j) \n        { \n            if(i & (1 << j)) v.push_back(a[j]); \n        } \n        ret.insert(v); \n    } \n    return ret; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Folks, why aren't we discussing our algorithms in psuedocode or in english (writing steps)?  That is the most important part if we want to discuss our solutions.  For this problem, you can solve it by using \"techniques\" that you should already have in your mind (but then later you can find a custom technique if it's worth optimizing.. but in this case you won't be able to do better):  {First step, figure out if you can remove duplicates in O(n) } {There is a standard technique for this:  } 1) Hash the elements of your array (which removes duplicates) -> Assume you picked the write hash table and you can do the operations in amortized average time of O(1)  2) Reverse the hash table into a simple array A[i], which will now have no duplicates {you can use the oringal array to store A}  [Steps 1 and 2 are a technique for removing duplicates of integers from an array in O(n) time]  [If you didn't know how to do above, you could do it less optimally  a) Sort your original list  (nlgn or n if you are able to use bucket/count sort)  b) Linear scan and create a new array without duplicates  { Or even less optimally:  Brute force O(n^2) to remove duplicates  POINT:  Don't give up.  Break your problem into steps and use brute force methods in some steps if you can't think of any better. }  3) Use a \"n-bit generating\" function to generate bits strings of length n     [You should have such a function memorized for use in these set generation problems... if not commit to memory how to make this function]  4) In the base case of 3), instead of printing the n-bit binary numbers, print sets from the array you created in 2) above in this way:    if your binary number is 0011010...    your output set will be { A[i]  such that position i in bit string is 1 }      Algorithm runtime: These type of problems always require a 2^n solution because you need to generate 2^n sets (and there is no way around this).  And you can confirm this by noting:  1) Step 1: O(n) time, plus O(n) 2) Step 2): O(n) time, plus no extra space (as you can use your original array)                                     at this point you can also delete the hash table  3) Step 3:  O(2^n) time, plus O(n) bits space"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4852029923000320","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"20","title":"You are given an integer K, and a sorted array as an input which has been rotated about an unknown pivot. For example, 4 5 6 7 8 9 1 2 3. We need to write a function which should return the index of K in the array, if K is present, else return -1.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Actually, you can do a little simpler than that. You don't actually need the pivot index. We just need to compare the mid element with rightmost and leftmost elements. If mid element is larger than leftmost element, bottom half of the array is properly sorted. In this case, we have a plain binary search (if element we are searching for is between leftmost and middle element, look at the lower half of the array; otherwise look at the upper half of the array). If mid element is smaller than leftmost element, upper half of the array is sorted. Accordingly, we look if the given element is at the upper of lower part."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would use Ternary Search to find the pivot and then a normal Binary Search, knowing the pivot. The time complexity is O(log n) if the values are distinct"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simple binary search, with slight change will work. See the code below."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the scala solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution (considers duplicates as well):  One half of the array is normally ordered. It's either the left or the right. Find the normally ordered half and perform binary search on that if X is inside it. Otherwise, search the other half.  Complexity: O(logN) without duplicates, O(n) with all elements duplicates (because we need to search both halves)  CODE:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package com.test; \n \npublic class Test { \n \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n \n  int[] array = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; \n  int pivot = -1; \n  for (int i = 0; i < array.length - 1; i++) { \n   if (array[i] < array[i + 1]) { \n    continue; \n   } else { \n    pivot = i; \n   } \n  } \n \n  System.out.println(\"pivot: \" + pivot); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void binarySearchRotated(int [] A, int i, int l, int x){ // i=0; l=A.length-1; \n  if(i>l){ \n   return; \n  } \n  int mid=(i+l)/2; \n  if(x==A[mid]){ \n   System.out.print(mid); \n   return; \n  } else if(A[mid]>=A[l]){ \n   if(x>=A[i] && xA[mid] && x<=A[l]){ \n    binarySearchRotated(A, mid+1, l, x); \n   }  \n   else  \n    binarySearchRotated(A, i, mid-1, x); \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can someone please comment on this code? It seems to work, but I would like to know how efficient it is..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// 1. L < M < R (1,2,3) - regular QuickSort \n// 2. L < M > R (2,5,1) \n// 3. L > M < R (5,1,3) \n// 4. L > M > R (3,2,1) - reverse QuickSort \nstatic int FindInRotatedArray(int[] a, int k) \n{ \n    int l = 0; \n    int r = a.Length - 1; \n    while (l < r) \n    { \n        int m = l + (r - l) / 2; \n \n        if (k == a[m]) return m; \n \n        if (a[l] <= a[m] && a[m] <= a[r]) // 1 \n        { \n            if (a[m] > k) r = m - 1; \n            else l = m + 1; \n        } \n        else if (a[l] <= a[m] && a[m] >= a[r]) // 2 \n        { \n            if (a[l] <= k && k < a[m]) r = m - 1; \n            else l = m + 1; \n        } \n        else if (a[l] >= a[m] && a[m] <= a[r]) // 3 \n        { \n            if (a[m] < k && k <= a[r]) l = m + 1; \n            else r = m - 1; \n        } \n        else // 4 \n        { \n            if (a[m] > k) l = m + 1; \n            else r = m - 1; \n        } \n    } \n \n    return a[l] == k ? l : -1; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Time Complexity: O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Tab { \n \npublic static int res (int K, int g, int d, int[] tab){ \nif (tab.length==0){ \n return -1; \n} \n if (g==d){ \n    if (K==tab[g]){ \n        return g; \n                  } \n        else{ \n        return (-1); \n            } \n        } \nelse{ \n    int N = (g+d)/2; \n    if (tab[N]==K){ \n        return N; \n                  } \n        else{ \n            if (tab[N]=tab[g]){ \n                                  return res(K,g,N,tab); \n                              } \n                              else{ \n                                  return res (K,N,d,tab); \n                                  } \n               } \n            } \n    } \n} \n \npublic static void main (String[] args){ \nint[] tab = {4,5,6,7,8,9,1,2,3}; \nSystem.out.println(res(1,0,tab.length,tab)); \n} \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class kParlindrome {  public boolean check(String s, int threshold)  {   return checkKparlindrome(s, 0, s.length()-1, 0, threshold);  }  public boolean checkKparlindrome(String s, int bpointer, int epointer, int misCnt, int threshold)  {   if(bpointer< 0 || epointer>=s.length())    return false;   if(epointer <= bpointer)    return true;   if(misCnt > threshold)   {    return false;   }   if(s.charAt(bpointer) == s.charAt(epointer))   {    boolean res = checkKparlindrome(s, bpointer+1, epointer-1, misCnt+2,threshold);    if (res)     return res;    else     return false;   }   else   {    //move bpointer    boolean res = checkKparlindrome(s, bpointer+1, epointer, misCnt+1,threshold);    if(res)     return true;    //move epointer    res = checkKparlindrome(s, bpointer, epointer-1, misCnt+1,threshold);    if(res)     return true;    //move    res = checkKparlindrome(s, bpointer+1, epointer-1, misCnt+2,threshold);    if(res)     return true;    return false;   }  }  public static void main(String[] args)  {   kParlindrome kp = new kParlindrome();   System.out.println(kp.check(\"bacdedafdeafdakljlke\",3));  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This code will be ok."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4635417542393856","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"15","title":"Write a function which returns the square root of a given number upto a precision of 0.0001. Only arithematic operations like addition, subtraction, division and multiplication are allowed.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"An easy and reasonably fast approach is to use binary search to the required precision"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Another pretty elegant solution is to use the Newton's method. Newton's method is a method for finding roots of a function, making use of a function's derivative. At each step, a value is calculated as: x(step) = x(step-1) - f(x(step-1))/f'(x(step-1))  This might be faster than binary search (because in this question, precision is quite high, 4 decimal places). My implementation in Java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The method where u check the midpoints successively is called the bisection method (it's kind of like binary search). It doesn't converge that fast, but these are not problems where we can label the efficiency with a big O(f(n)).  Newton's method converges faster.  But this solution requires one to remember calculus.  I'm a math nerd so I know a cool solution: For these problems there is always an implicity range of floating point values that one intent to use.  Using the range of floating point numbers we intend to use , we can use Taylor's remainder theorem to figure out the number of terms in the taylor expansion of sqrt(1+x) we need to achieve that precision for our inputs.  Then we can get the taylor polynomial of whatever degree we need, say n, inside our function.  To evaluate a polynomial of degree n, it seems like we require O(n^2) arithmetic operations because there is an x^n term. But we can use Horner's scheme to make it O(n). For example:  Horner's scheme on a random quartic: -3x^4 + 2x^3 + 2x + 6 = 6 + x(2 + x(2 + (-3(x))))  So to evaluate a polynomial of degree n, we only need O(n) operations.  So a solution is: Find the taylor polynomial with enough terms to guarantee that precision on all inputs, then put then evaluate that polynomial internally using Horner's scheme.  This is O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using Newton Raphson Method, it will converge quadratically"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6287528252407808","download_status":"DOWNLOAD_DONE","votes":"15","answersCount":"68","title":"A k-palindrome is a string which transforms into a palindrome on removing at most k characters.  Given a string S, and an interger K, print \"YES\" if S is a k-palindrome; otherwise print \"NO\". Constraints: S has at most 20,000 characters. 0<=k<=30  Sample Test Case#1: Input - abxa 1 Output - YES Sample Test Case#2: Input - abdxa 1 Output - No","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"20","title":"The question asks if we can transform the given string S into its reverse deleting at most K letters. We could modify the traditional Edit-Distance algorithm, considering only deletions, and check if this edit distance is <= K. There is a problem though. S can have length = 20,000 and the Edit-Distance algorithm takes O(N^2). Which is too slow.   (From here on, I'll assume you're familiar with the Edit-Distance algorithm and its DP matrix)   However, we can take advantage of K. We are only interested *if* manage to delete K letters. This means that any position more than K positions away from the main diagonal is useless because its edit distance must exceed those K deletions.   Since we are comparing the string with its reverse, we will do at most K deletions and K insertions (to make them equal). Thus, we need to check if the ModifiedEditDistance is <= 2*K Here's the code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"I made a recursive algorithm"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"There are two approaches you may apply. The first one is to reverse the input string and find the LCS of the input string, and it's reversal. This gives you the lenght of the longest palindrom. Now you substract the LCS value from the lenght of the string and you get the k - so just check if it matches.  The second approach just looks for a palindrom. Let's say p[n] is a palindrom with lenght n. Let l will be begining, end e the end of a palindrom. Then we can see that: 1) p[l] == p[h], then we need to check p[l+1] == p[h - 1], i.e abcba, where p[l] == a == p[h] 2a) p[l] != p[h], then we need to check p[l+1],p[h] (we removed p[l]) 2b) p[l] != p[h], then we need to check p[l], p[h-1], (we removed p[h])  Now simply use this in your dynamic programming aproach. If you have a problem with that, I am more than glad to help you more.  As I was bored, I typed the code for the second solution:)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"boolean isKPalindromeRec(char[] arr, int k, int left, int right){ \n   \n  if( left >= right ){ \n   return k >= 0; \n  } \n   \n  if( arr[left] == arr[right] ){ \n   return isKPalindromeRec(arr, k, left+1, right-1); \n  } \n   \n  return isKPalindromeRec(arr, k-1, left+1, right) || isKPalindromeRec(arr, k-1, left, right-1);   \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this question can be solve by following idea. I define the function like this :   bool isKPalindrom(string s, int start, int end, int k)  The input is string s , its begin position, its end position and k.  If s[start:end] is palindrome then return true else      if k < 0 return false     else if s[start] == s[end-1] then recursively call isKPalindrome(s,start+1,end-1,k)     else return isKPalindrome(s,start+1,end,k-1 ) || isKPalindrome(s,start,end-1,k-1)   We can also use a array to record the result of whether s[start,end]  is palindrome  The time complxity is (n^2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would use recursion to solve this problem:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@joe_kidd : I thought of the same solution as yours before I looked at posted solutions ! I am glad that you also came up that. Well, what do you think is complexity of the algorithm? I think it's O(n). Is that right?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@joe_kidd : I thought of the same solution as yours before I looked at posted solutions ! I am glad that you also came up that. Well, what do you think is complexity of the algorithm? I think it's O(n). Is that right?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a recursive approach, and works for all possible cases.  This is a back tract approach. Maximum matches can be n (n is the size of input array) and minimum matches can be n-k."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Python code:  def isPalindrome(String):     stringSize = len(String)     start = 0     end = stringSize - 1     while start < end and String[start] == String[end]:         start += 1         end -= 1     if start < end:         return False     else:         return True  def isKPalindrome(String, k):     if k > 0:         for i in range(len(String)):             subString = String[:i] + String[i+1:]             if isKPalindrome(subString, k-1) == True:                 return True         return False     elif k == 0:         return isPalindrome(String)     else:         print 'Error number k'         return False   Testing Set: print isPalindrome('1') print isPalindrome('11') print isPalindrome('11111') print isPalindrome('11211') print isPalindrome('13231') print isPalindrome('1221') print isPalindrome('133121331')  print isPalindrome('11221') print isPalindrome('13211') print isPalindrome('23') print isPalindrome('123')  print isKPalindrome('abxa', 1) print isKPalindrome('abxa', 2) print isKPalindrome('abdxa', 2) print isKPalindrome('abdxa', 1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"inpt = raw_input('Enter a string and an integer: ') \ninpt = inpt.split(' ') \nstring = inpt[0] \nk = int(inpt[1]) \nposition = 0 \n \ndef kPalindrome(string,pos,k): \n if string == string[::-1]: \n  print 'True: ', string \n elif k > 0: \n  if len(string) - pos > k: \n   for i in range(pos,len(string)): \n    kPalindrome(string[:i]+string[i+1:],pos,k-1) \n    pos += 1 \n    \nkPalindrome(string,position,k)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Correction to previous python solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include int main() {     int k,i=0,j,flag=1,count=0;     char a[20];     printf(\"ENTER THE VALUE OF K\");     scanf(\"%d\",&k);     printf(\"ENTER THE STRING\");     scanf(\"%s\",a);     j=strlen(a);     j=j-1;     while(i    {               if(a[i]!=a[j])               {                             if(a[i+1]==a[j])                             {                                             count++;                             }                             else if(a[i]==a[j-1])                             {                                             count++;                             }                             else                             {                                 flag=0;                                 break;                             }               }               if(count>k)               {                      flag=0;                      break;               }               i++;               j--;                    }     if(flag==0)        printf(\"NO\");     else        printf(\"YES\");     getch(); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"map , int> F;  \n  \nint min(int a, int b, int c)  \n{  \n    return min(min(a,b),c);  \n}  \n  \nint f(const string &s, int i, int j, int k)  \n{  \n    if (k < 0)  \n        return MAX;  \n    else if (i >= j)  \n        return 0;  \n  \n    if (F.find(mp(i,j)) != F.end())  \n    {  \n        return F[mp(i,j)];  \n    }  \n  \n    if (s[i] == s[j])   \n    {  \n        int tmp_result = min(f(s, i+1, j-1, k), f(s, i+1, j, k-1) + 1, f(s, i, j-1, k-1) + 1);  \n        F[mp(i,j)] = tmp_result;  \n        return tmp_result;  \n    } else {  \n        int tmp_result = min(f(s, i+1, j, k-1), f(s, i, j-1, k-1)) + 1;  \n        F[mp(i,j)] = tmp_result;  \n        return tmp_result;  \n    }  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What about this one?   def palin_k(str, k):  if k == 0 or str == str[::-1]:   return str == str[::-1]  l_index = 0  r_index = len(str) - 1  while str[l_index] == str[r_index]:   l_index = l_index + 1   r_index = r_index - 1  return palin_k(str[l_index:r_index], k-1) or palin_k(str[l_index+1:r_index+1], k-1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"you can do something like that :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def is_k_palindrome(word, K): \n    # Check upfront if it's a palindrome. \n    # This will catch the one-character case. \n    if word == word[::-1]: \n        return True \n \n    # Not a palindrome and we're out of removal options, so there's no hope. \n    if K == 0: \n        return False \n \n    if word[0] == word[-1]: \n        return is_k_palindrome(word[1:-1], K) \n \n    return (is_k_palindrome(word[1:], K - 1) or \n            is_k_palindrome(word[:-1], K - 1))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is in javascript, I measure the distance of the palindrome of the string and divide it by 2, since it each extra character will appear twice"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@miguel - great solution! i used the dp / edit distance approach like you suggested and i think it works.. not sure if i did it exactly like you said... but same general idea.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// C Version - Recursive approach. \n \nbool isKPalindrom(char * str, int len, int k) \n{ \n while (len >=1 && str[0] == str[len-1]) \n { \n  str++; len-=2; \n } \n \n if (len <= 1) return true; \n \n if (k > 0) \n  return isKPalindrom(str + 1, len-1, k-1) || isKPalindrom(str, len-1, k-1); \n \n return false; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static String isKPalindrome(String input, int k) { \n \n  if (k >= (input.length() - 1)) { \n   return \"YES\"; \n  } else if (input.charAt(0) == input.charAt(input.length() - 1)) { \n   input = input.substring(1, input.length() - 1); \n   return isKPalindrome(input, k); \n  } else if (k > 0) { \n   k--; \n   String input1 = input.substring(0, input.length() - 1); \n   String input2 = input.substring(1, input.length()); \n \n   String res1 = isKPalindrome(input1, k); \n   String res2 = isKPalindrome(input2, k); \n    \n   if (\"YES\".equals(res1) || \"YES\".equals(res2)) { \n    return \"YES\"; \n   } else { \n    return \"NO\"; \n   } \n \n  } \n \n  return \"NO\"; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"LCS should work, the worst case is O(N^2) when there is no match. But we would be able to return early when this is match with K."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There is another DP solution: Firstly I will present a simple quadratic solution dp[l][r] - state where we hold minimum number of removes in order to transform the segnment s[l]...s[r] into palindrome. Transitions will be as follows: if(s[l] == s[r]) dp[l][r] = min(dp[l][r], dp[l + 1][r - 1]); else dp[[l][r] = min(dp[l][r], min(dp[l + 1][r], dp[l][r - 1]) + 1); But the problem is in that it works too slowly, therefore we can convert our solution by the following way: dp[l][k]  - will hold the rightmost position in S where we can reach removing exactly k characters and starting from l;  if(S[dp[l + 1][k]] == s[l]) dp[l][k] = max(dp[l][k], dp[l + 1][k] + 1); else dp[l][k] = max(dp[l][k], dp[l + 1][k - 1] + 1); The implementation demands to go through from right to left; At the end it is enough just to look at states dp[0][i], where 0<=i <= k;  if(dp[0][i] == s.length()) then \"yes\" else \"no\";"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution in java-  Take an array R of size 26.   Loop through each character of the string and increment the index of R for that character.  If a string is palindrome then the count of each character in R %2 will give 0 and if string length is odd then except one character rest of character's count %2 will be 0.  Now, if you want to calculate k-palindrom add the k to the comparison as shown below."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool is_palindrome(char* text, const uint& text_size, const int& k) \n{ \n    if (text_size == 0 || k < 0) \n        return false; \n    if (text_size == 1 || (text_size == 2 && (text[0] == text[1] || k > 0))) \n        return true; \n \n    if (text[0] == text[text_size - 1]) \n        return is_palindrome(text + 1, text_size - 2, k); \n    if (text[0] == text[text_size - 2]) \n        return is_palindrome(text + 1, text_size - 3, k - 1); \n    if (text[1] == text[text_size - 1]) \n        return is_palindrome(text + 2, text_size - 3, k - 1); \n \n    return is_palindrome(text + 2, text_size - 2, k - 2); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"find the longest palindromic subsequence. get its difference with length of string , say diff. if diff <= k , then its a k-pali string."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Below are my solutions in C++. The first one is a recursive function which gives a good idea of how to tackle the problem. This solution has a huge complexity (something like O(L * 2^K) though I cannot prove an exact formula - L is the length of the string).  The second one is a solution which uses a matrix of size 2*L*K^2 and which fills it step by step (a change of indices is used to avoid building a L * L * K matrix). This solution has O(L*K^2) complexity which is quite acceptable with the given parameters."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I made a C# method for it. This appears to work and I BELIEVE it'll cover cases that result from larger strings also. Little bit lengthy, but recursive method seemed most logical to handle the total number of removed characters. There's obviously driver code, but its not all that important."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"I tested it, you are right it will not work with \"axxba\". So I am removing it."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5172027535130624","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"51","title":"Given an array write a function to print all continuous subsequences in the array which sum of 0. e.g:  Input: Array = [-1, -3, 4, 5, 4] output:  -1, -3, 4","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"There is another solution that works as following:  Array = [6, -1, -3, 4, 5, 4, -15, 7] then create another array that for position i - keeps the sum of all elements from [0, i] so that we get something like  SumArray = [6, 5, 2, 6, 11, 15, 0, 7]  Now by looking in the SumArray we can see that: 1) when 0 appears at i-position it means that from the begining of the array till i-th position we have a \"zero sequence\". 2) if there is a matching (two the same elements, like 6, 6 in our case) then we know that from [i+1,j], where i is the first and j is the second matching, the overall change was equall to zero, so we have a \"zero sequence\" again."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Can be done by using a dynamic programming approach. Create a matrix say A such that A[i][j]  = sum of the numbers from index i to j in the original array. and also i <= j To build this matrix use A[i][j] = A[i][j-1] + Input[j]  Input is the input array. Print the i and j indices for which the value of A[i][j] = 0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"It could be done with O(n)  1) run cumulate sum on the original array 2) append [0] in font of this cum_sum_array 3) check if two item in this cum_sum_array are same (for requirement sum==0, this could be done in O(n))  Totally time spend is O(2n) = O(n)  I'm using python:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void printTriplet(const int a[], int n) \n{ \n    int result[n][n] = {0}; \n     \n    for( int x = 0; x <= n ; x ++ ) \n    { \n        for( int y = 0; y < n; y ++ ) \n            result[x][y] = MAXINT; \n    } \n     \n     \n    for( int i = 0; i < n; i ++ ) \n    { \n        for( int x = 0; x <= i ; x ++ ) \n        { \n            for( int y = i; y < n; y ++ ) \n            { \n                if( result[x][y] == MAXINT ) \n                    result[x][y] = 0; \n                     \n                result[x][y] += a[i]; \n            } \n        } \n    } \n     \n    for( int x = 0; x <= n ; x ++ ) \n    { \n        for( int y = 0; y < n; y ++ ) \n            if( result[x][y] == 0 ) \n                print( a, x, y ); \n    } \n     \n} \n \nvoid print( int a[], int x, int y ) \n{ \n    printf(\"Triplet: \"); \n    for( int i = x; i <= y; i++ ) \n    { \n        printf(\"%d \", a[i] ); \n    } \n    printf(\"\\n\"); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the problem is looking for subarrays, then it can be solved by divide and conquer;  Split the problem into three subproblems:  1. All subarrays in array A[0...n/2 - 1] that sum to 0 2. All subarrays containing element a[n/2] that sum to 0 3. All subarrays in array A[n/2 + 1..n] that sum to 0  The time complexity is O(n (logn)^2) T(n) = 2T(n/2) + nlogn  Space complexity is O(n)  Otherwise it is subset sum problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a simple recursive solution. You can optimize it by storing the solution to the sub-problems (dynamic programming)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int main() \n{ \n int a[] = {6, -1, -3, 4, 5, 4, -15, 7}; \n int N = 8; \n  \n for(int i = 0; i < N; i++) \n { \n  int sum = 0; \n  for(int j = i; j < N; j++) \n  { \n   sum += a[j]; \n   if(sum == 0) \n   { \n    for(int k = i; k <= j; k++) \n     printf(\"%d, \", a[k]); \n    printf(\"\\b\\b  \\n\"); \n   } \n  } \n } \n  \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this question can be solved by one pass traversal. Use an additional array sum which sum[i] represents sum from data[0] to data[i]. If we find two elements in array sum that they have the same value, for example, sum[i] = sum[j] then we can sure that the sum of continuous sequence data[i+1] to data[j] is zero. Note that there maybe an exception. If any sum[i]`s value is zero, that means the sum of sequence from data[0] to data[i] is zero  For example  input is -1, -3, 4, 5, 4 sum is -1, -4, 0, 5,9  sum[2] is zero that means data[0] + data[1] + data[2] = 0  input is 1,3,5,7,9,-2,2 sum is 1 4 9 16 25 23 25 sum[4] = sum[6], that means data[5] + data[6] = 0  Time complexity is O(n) Space complexity is O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Author : A.NAsimunni //Cse student  #include main() { int n; printf(\"\\n\\tEnter size of an array  : \"); scanf(\"%d\",&n); int a[n];int i; for(i=0;i{ scanf(\"%d\",&a[i]); } int j=0,s=0,m; int t[n];int k=0;  for(i=0;i{ s=0; k=0;t[k]=a[i];s=s+a[i];k=k+1;  for(j=i+1;j{ t[k]=a[j];k=k+1; s=s+a[j]; if(s==0) {printf(\"\\n\\t\\tYour array : \"); for(m=0;m} else {;} } } printf(\"\\n\\n\"); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Author : A.NAsimunni //Cse student  #include main() { int n; printf(\"\\n\\tEnter size of an array  : \"); scanf(\"%d\",&n); int a[n];int i; for(i=0;i{ scanf(\"%d\",&a[i]); } int j=0,s=0,m; int t[n];int k=0;  for(i=0;i{ s=0; k=0;t[k]=a[i];s=s+a[i];k=k+1;  for(j=i+1;j{ t[k]=a[j];k=k+1; s=s+a[j]; if(s==0) {printf(\"\\n\\t\\tYour array : \"); for(m=0;m} else {;} }  } printf(\"\\n\\t\\tThank you\\n\"); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Another approach by using maps. Assume we keep track of cumulative sum of array. If there is a subsequence starting from index n1 to n2 summing to zero, then the cumulative sum is equal at n1 and n2. Just need to remember the locations."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nusing namespace std; \nint main() \n{ \n    int n,i,a[10001]; \n    cin>>n; \n    for(i=0;i>a[i]; \n    sort(a,a+n); \n    for(i=0;ik) \n                                         { \n                                                           r--; \n                                         } \n                                         else if(a[l]+a[r]>n; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nusing namespace std; \nint main() \n{ \n    int n,i,a[10001]; \n    cin>>n; \n    for(i=0;i>a[i]; \n    sort(a,a+n); \n    for(i=0;ik) \n                                         { \n                                                           r--; \n                                         } \n                                         else if(a[l]+a[r]>n; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n#include \nusing namespace std; \nstruct range{int x,y;}; \nstruct xyz{int su,in;}s[100001]; \nbool c(const xyz &l,const xyz &r){if(l.su==r.su)return(l.in ra; \nint main() \n{ \n    int n,a[100001],i,j; \n    cin>>n; \n    for(i=1;i<=n;i++)cin>>a[i]; \n    for(i=1;i<=n;i++){s[i].su=s[i-1].su+a[i];s[i].in=i;} \n    //for(i=1;i<=n;i++)cout<>n; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Python Code:  startend = {}  def getZeroSubsFromIndex(array, startIndex):     sum = 0     for i in range(startIndex, len(array)):         sum += array[i]         if sum == 0:             if startIndex not in startend:                 startend[startIndex] = [i]             else:                 startend[startIndex].append(i)  def getAllZeroSubs(array):     for i in range(len(array)):         getZeroSubsFromIndex(array, i)     print startend"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int countSubArray(int A[], int n) \n{ \n map accumCountMap; \n accumCountMap[0] = 1; \n int sum = 0; \n for (int i = 0; i < n; i++) \n { \n  sum += A[i]; \n  if (accumCountMap.find(sum) == accumCountMap.end()) \n   accumCountMap[sum] = 1; \n  else \n   accumCountMap[sum]++; \n } \n  \n int cnt = 0; \n for (auto iter = accumCountMap.begin(); iter != accumCountMap.end(); iter++) \n { \n  int val = iter->second; \n  if (val > 1) \n   cnt += val * (val - 1) / 2; \n } \n return cnt; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static List> zeroSumSubsequence(final List list) { \n  if (list.isEmpty()) { \n   return Collections.emptyList(); \n  } \n  List> result = new ArrayList<>(); \n  final List sum = new ArrayList<>(list); \n  sum.add(0, 0); \n  for (int i=1; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be done in one pass. Take a hash table(say h) with a key (0) and value (-1). Add one by one element (i is incerementing) from the array to sum (say sum) and also add the sum as key into the hashtable(h) with value as i (current counter). Before adding to hashtable(h),each time check, if a key already exists in the hashtable with the cumulative sum. If exists, means zero sum formed from h(sum)+1 to current pointer(i), so print them. if the sum not exist in h, simply add it (need to update h(sum) with current i, even it found, so that we can track next occurrence of that sum).  Here is the code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Main { \n \n    public static final void main(String[] args) { \n        printSubsequence(new int[] {-1, -3, 4, 5, 4}, 0); \n    } \n \n    private static void printSubsequence(int[] array, int sumTotalToFind) { \n        final LinkedList list = new LinkedList(); \n        for(int i = 0, arrLen = array.length; i < arrLen; i++) { \n            int sum = 0; \n            for(int j = i; j < arrLen; j++) { \n                list.add(array[j]); \n                sum += array[j]; \n \n                if(sum == sumTotalToFind) { \n                    System.out.println(list); \n                } \n            } \n \n            list.clear(); \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Folks.... this is the situation. Subarray summing to K is the problem. There are two distinct subcases:  1) If arrays elements are assumed to be nonnegative, then you can do a slick O(N) solution  2) If array elements can be negative too, you can't beat O(N^2) ... last time I tried I couldn't :P"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static int[] input_array = {-1, -3, 4, 5, 7};  static int l=input_array.length;  static int total;  static int first;    public static void addThreeSub()  {   for (int i=0; i  {    first = input_array[i];    total = input_array[i]+input_array[i+1]+input_array[i+2];    //System.out.println(\"comparing \" + first +\" with:\" + input_array[i+1]+ \" & \" +input_array[i+2]);    if (total==0)    {     System.out.println(first +\" AND \" + input_array[i+1]+ \" AND \" +input_array[i+2]);    }       }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My decision on python:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution in JavaScript - not sure about the time complexity."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void printZero(int[] input) \n    { \n        int[] sum = new int[input.Length]; \n        int currSum = 0; \n        for (int i = 0; i < input.Length; i++) \n        { \n            currSum += input[i]; \n            sum[i] = currSum; \n        } \n \n        List> storePairs = new List>(); \n        Hashtable map = new Hashtable(); \n \n        for (int i = 0; i < input.Length; i++) \n        { \n            if (sum[i] == 0) \n            { \n                KeyValuePair kvp = new KeyValuePair(0, i); \n                storePairs.Add(kvp); \n            } \n \n            if (map.ContainsKey(sum[i]) == false) \n            { \n                map.Add(sum[i], i); \n            } \n            else \n            { \n                object key = (object)sum[i]; \n                int startIndex = (int)map[key]; \n                KeyValuePair kvp = new KeyValuePair(startIndex + 1, i);  \n                storePairs.Add(kvp); \n            } \n        } \n \n        foreach(KeyValuePair kvp in storePairs) \n        { \n            int startIndex = kvp.Key; \n            int endIndex = kvp.Value; \n            for (int j = startIndex; j <= endIndex; j++) \n                Console.Write(input[j] + \" \"); \n \n            Console.WriteLine(); \n        } \n    } \n \n    static void Main(string[] args) \n    { \n        printZero(new int[] { -1, -2, 4, -1, 0, 4, 2, 3, -5 }); \n        Console.Read(); \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This is the classic subset sum problem, which is asked here many many many times before and is NP-complete problem. You can check out en.wikipedia.org/wiki/Subset_sum_problem for more info."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"So, if we are talking about  \"continuous subsequences\", then we just need to traverse the array once, add a[i], a[i+1], a[i+2], and print a[i], a[i+1], a[i+2] whenever the sum is 0, right? Am I missing something here?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=10072145","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"54","title":"three points are randomly chosen on a circle.what the probability that 1.triangle formed is right angled triangle. 2.triangle formed is acute angled triangle. 3.triangle formed is obtuse angled triangle.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"The first two points selected on a circle do lie in a semicircle (name it as first). The third point could either be in this semicircle (the first) or the other one (name it as second). In case if the third point lies in first semicircle (50% probability) then it forms obtuse angled triangle. In case if the third point lies in the second semicircle (50% probability) then it forms acute angled triangle.  So far so good. If the third point is diametrically opposite to either first point or second point then it forms right angled triangle. The probability of this is almost neglible. Please correct me if I am wrong. My email id is kishore.jinka@gmail.com"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"0,1/4,3/4 randomly choose the first two points A and B, they determine a string (A,B) C and D are the centralsymmetric points of A and B, in order to have an acute triangle, the third point has to sit somewhere on the shorter arc determined by C and D.  Use the law total probability and integration, we get the probability of getting acute triangle is 1/4."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"0, 1/4, 3/4"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"the points are picked up at random so the outcome of each point is independent of one another .. as such it would not be correct to first pick two points and the decide if the the third point lies in one semi sphere or the other .. however, once all the three points have been picked, it is certain that the outcome would be either one of the two (ignoring the right hand triangle case) : either all three lie in the same semi-sphere or two lie in the same semi-sphere. We can compare this to a coin toss problem, where we independently toss three coins and see the outcome. In this case, the two semi-spheres depict H or T. and the total outcome space is TTT,HHH, THT, HTH, TTH, HTT, HHT, THH. We can now deduce that the probability of obtuse angle triangle (TTT, HHH) is 2/8 and prob of acute angle triangle (the other cases) is 6/8."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"no no no no right angle = 0 acute and obtuse are both 1/2  0>x>pi/2 & pi/2>x>pi.  The semi-circle is split in half on the unit circle into these two spaces ... 1/2 & 1/2. Assuming infinite distribution a right angle will always be 0."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"not getting what u want to say please elaborate"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First is obviously 0. Second is 1-third.  So for the third: Take any 2 of the 3 points of the random triangle, and make the obvious rectangle you can make with those 2 and the other 2 points on the \"other\" side of the circle. Whether the triangle is acute or obtuse depends on which of the 4 arcs made by those 4 points lie. If the 4 points make a square, the likelihood is 1/2. For every \"fat\" rectangle there is a corresponding \"skinny\" rectangle, so the likelihood is 1 (i.e. for every rect that yields a probability p for acuteness, there is one that yields p for obtuseness)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Lets assume radius=1, circumference=2*pi Lets select first point randomly.  For second point, using symmetry, can fall onto a semicircle, at anywhere from 0 to pi distance from first point. lets assume second point is at x distance, and its length is dx. probability of point getting selected=dx/pi.  Now for if third points falls on the smaller side (length which is x) it will be acute angle triangle else obtuse. acute angle probability = x/(2*pi). acute angle probabilty at this point= dx * x/(2*pi*pi) total acute angle probability can be calculate by integrating above from 0 to pi. which will be = 1/4. obtuse angle probability=1-1/4=3/4"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why the probability for right angled triangle is Zero. If u select two diametrical opposite points ..and the third point any where in the circle..the triangle formed will be Right Angled..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Let there be total n pixels or points. If we assume that the width of each pixel is 'x' and x tends to 0, then: n = 2.pi.r/x  So number of ways of making a Right Angled Triangle = 2/infinity = 0 (as explained earlier). Now, we choose 2 points randomly. Let us assume that the angle made by the 2 chosen points with the center = theta. Therefore, Number of Pixels on Acute Side = (2.pi.r/x - pi.r.theta/180.x) And number of Pixels on Obtuse side = (pi.r.theta/180.x)  And x tends to 0.  So, P(Acute) = Ways of choosing a pixel on acute side / Ways of choosing 3 pixels in the circle As written earlier, total pixels = n = 2.pi.r/x P(Acute) = lim x->0 C(n - pi.r.theta/180x, 1) / C(n , 3)  Where C is the 'combination' symbol in combinatorics (equivalent to writing nC3)  So replace n by 2pi.r/x, take out all the constants and apply L'hospital Rule.  We get the answer as 1/2.  Hence P(Obtuse) = 1-1/2 = 1/2.  This is a limit problem because of the trade off between n (total number of pixels) and x (size of each pixel) where n tends to infinity and x tends to 0.  Hope the solution is clear. If any doubts, mail on at[dot]whitemagic[at]gmail[dot]com"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it is very simple choose any two point.now after selecting two point draw diameter parallel to chord obtained.now select the third point. if in same region of chord it is obtuse and else acute.either case probability = .5."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1/2 for right angle and 1/4 foracute and obtuse both.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think all of your understanding of problem is wrong.  The 3 points are randomly selected, so all 3 points can fall in same semi circle, when you add 3 points in one half of circle, it forms obtuse triangle.  There is no restriction that, once you select a point, second will be diametrically opposite."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The probability according to me is: For right angled triangle: 2/359 For acute: 178/359 For obtuse: 179/359  Assuming there are 360 points on the circle at one degree away the chances of each of the above cases happenin are(neglecting r as it will be cancelled): Right=360*358*2  Acute=360*358*178  Obtuse=360*358*179"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The probability according to me is: For right angled triangle: 2/359 For acute: 178/359 For obtuse: 179/359  Assuming there are 360 points on the circle at one degree away the chances of each of the above cases happenin are(neglecting r as it will be cancelled): Right=360*358*2  Acute=360*358*178  Obtuse=360*358*179"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It should not be 1/4 and 3/4. Should be 1/2,0,1/2. Consider the following solution : Event A = Point A lies in the same semi circle as B and C. Event B = Point B lies in the same semi circle as C. P(Obtuse) = P(A) * P(B) We are assuming that C can be randomly placed. Now P(B) = 1 AND NOT 1/2, because no matter where we place B, it will always be inside a semicirle containing C. They may become end points of a diameter, otherwise they will always form a chord. Now A can be placed in either of the two semi circles leading to probability 1/2. Hence P(A) = 1/2 and P(Obtuse) = 1/2 resulting in P(Acute) = 1/2."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"0 1/4 3/4 Denote the first two points A and B that make the longest edge of the triangle, the third one is C, and O is the center of the circle. Also let the circumstance of the circle to be 1, the shorter curve AB is x, where 0<=1/2.  First, the probability that edge AB are the diameter, where x=1/2 is 0, so the prob for right angle triangle is 0.  Second, to make an obtuse triangle, and given the assumption that AB is the longest edge, C can only lie on the shorter curve AB on the circle. Otherwise AB will not be the longest edge or ABC is not an obtuse triangle. This gives the possibilities of 2*int_{x=0}^{1/2} x = 1/4, where the factor of 2 is due to symmetry.  Third, to make an acute triangle, C can be only chosen under the condition that angle AOC < angle AOB, and angle BOC < angle AOB. Otherwise, AB will not be the longest edge. Translated to the curve lengths, given shorter curve AB = x, we have 1-2x < curve AC < x. So x should be greater than 1/3 and the length of possible C, given B, is x - (1-2x) = 3x-1.  The total possibilities are 2*int_{x=1/3}^{1/2} 3x-1 = 1/12, where the factor of 2 is due to symmetry.  So the possibilities of obtuse and acute triangles are 1/4:1/12 = 3:1. So the probabilities for them are 3/4 and 1/4 respectively."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"there are three pints, A,B,C consider A, and draw the diameter passing through A, and the two semi-circles  B and C are on the same semicircle IFF the angle is obtuse, and this happens with probability 1/2  the right angle has probability 0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"there are three pints, A,B,C consider A, and draw the diameter passing through A, and the two semi-circles  B and C are on the same semicircle IFF the angle is obtuse, and this happens with probability 1/2  the right angle has probability 0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Acute & obtuse are 89/180 each Right angle is 1/90"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"monte carlo is pretty handy for problem like this.  here is a python implementation, and returns the same answer as many have posted: 0 for right triangle, 1/4 for acute, and 3/4 for obtuse."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"right : 0+ acute : 0.25-  obtuse : 0.75-  Semicircle formed by first two points can cover min 50% to max 100% of the points on the circle based on their position on the circle. But never less than 50%. On an average 75%. Third point can be any point on the circle, it means third point will be on the semicircle for about 75% times."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Guys .... there are only 3 types of triangles differentiated based on angles .... acute , obtuse and right angled so ... the dnt confuse ua self wid semi circles or sme thg .... answer is 1/3 for all !!!!"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=10517903","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"write iterative version of seed fill algorithm","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"FloodFill(Pixel p, Color curr, Color new) {  if Color(p) != curr then return  Q.Add(p);  // Q is a queue that stores pixels  while Q is not empty do  {   p = Q.getFirst();   if Color(p) == curr then set color(p) = new;   Q.Add(p.rightPixel());   Q.Add(p.leftPixel());   Q.Add(p.topPixel());   Q.Add(p.bottomPixel());  }  return; }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=10018885","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"19","title":"Given an array of size n, find all the possible sub set of the array of size k(all the subsets must be of size k).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Here's code in C#."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Two solutions, one with complexity 2^n and the other with n!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"for(int i=0; i<(1< subset; \n        for(int j=0; j 0) { \n                subset.push_back(a[j]); \n            } \n        } \n         \n        if(subset.size() == k) { \n              // print the subset or return \n        } \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#define SUBSET_LENGTH 3  void generateSubset(int array[], int subset[], int used[], int length, int index, int lastoffset) {     int k;      if (index == SUBSET_LENGTH)     {         printf(\"subset %d%d%d\\n\", subset[0], subset[1], subset[2]);         return;     }      for (k = 0; k < length; k++)     {         if (used[k]) continue;         if (k < lastoffset) continue;         subset[index] = array[k];         used[k] = 1;         generateSubset(array, subset, used, length, index + 1, k);         used[k] = 0;     } }  int main() {     int array[4] = {1, 2, 3, 4};     int used[4];     int subset[SUBSET_LENGTH];      memset((void *)used, 0,  sizeof(array)/sizeof(int));     memset((void *)subset, 0, SUBSET_LENGTH);      generateSubset(array, subset, used, sizeof(array)/sizeof(int), 0, 0);      return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"please anyone explain above code?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The above code is similar to the DFS algorithm.  But, this code will not work for input that has duplicate entry like (1 1 2 6 8)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include int temp[3] = {0,0,0}; int arr[] = {1,2,3,4,5}; void rec( int k , int j) {      int i;      if(k == 3)      {           printf(\"%d %d %d\\n\",temp[0],temp[1],temp[2]);           return;      }      for(i = j; i < 5;i++)      {            temp[k] = arr[i];            rec(k+1,i + 1);      } }             void main() {          rec(0,0);      getchar();      }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what to do.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Each number between [0 and 2^n) in its bit form corresponds to which elements to include from array and which to exclude.  Generate those subsets whose corresponding bit vector has k number of 1s."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Given an array, this function finds the startIdx of subset array of size k // The indices are stored in the startId vector // Recursively call void FindSubset(int curPos, int k, int arraySize, vector& startId) {  if(curPos+k > arraySize)   return;  startId.push_back(curPos);  curPos++;  FindSubset(curPos, k, arraySize, startId); }  int main () {  vector startId;  int k = 4;  int arr[10] = {1,2,3,4,5,6,7,8,9,10};  FindSubset(0, k, 10, startId);  int sizeSubSets = startId.size();  cout << \"total subsets found:\" << sizeSubSets << endl;  for(int i=0; i < sizeSubSets; i++)  {   int currPos = startId[i];   cout << \"SubsetArray= {\";   for(int j=currPos; j < currPos+k; j++)   {    cout << arr[j] << \" \";   }   cout << \"}\" << endl;  }  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The simplest way is to think recursively..  method signature :  allsubets(int[] input, i, k);   here i denotes the starting index of the input array to consider and  k denotes the size of subsets to generate.  subsets_1 = allsubset(input, i+1, k-1)  /* use i. */ for (subset s : subsets_1)   add input[i] to s  subsets_2 = allsubsets(input, i+1, k-1)  /* don't use i */  return combine(subsets_1, subsets_2);  Note: not handling trivial case. Its easy enough. Also we can easily memoize this."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include   void subarray(int arr[], int t[], int n, int ind, int k, int kk) {      int i;      if (n == 0)         return;      if (kk == k) {         for (i = 0; i < kk; i++)            printf(\"%d \", t[i]);         printf(\"\\n\");         return;      }      if (n - ind < k - kk)         return;      t[kk] = arr[ind];      subarray(arr, t, n, ind + 1, k, kk + 1);      subarray(arr, t, n, ind + 1, k, kk); }   int main() {     int i, arr[100], t[100], n, k;     do {         printf(\"Enter array size:\");                 scanf(\"%d\", &n);         for (i = 0; i < n; i++)            scanf(\"%d\", arr + i);         printf(\"Enter sub-array-size:\");         scanf(\"%d\", &k);                subarray(arr, t, n, 0, k, 0);     } while(n);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a simple python solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a simple python solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Set {   int[] elem;   int size;   Set(int n) {    elem = new int[n];   }      public Set clone() {    Set temp = new Set(elem.length);    int[] clonedElem = elem.clone();    int clonedSize = size;    temp.elem = clonedElem;    temp.size = clonedSize;        return temp;   }   public void add(int n) {    elem[size]=n;    size++;   }   public String toString() {    StringBuffer sb = new StringBuffer();    sb.append(\"{\");    for(int i=0;i    sb.append(elem[i]);     sb.append(\",\");    }    sb.append(\"}\");    return sb.toString();   }     }  public List setsOfSizeK(int[] a,int index, int k, Set s) {   List ls=new ArrayList();      for(int i=index;i<=a.length;i++) {    if(k>0 && i< a.length) {     Set temp = s.clone();     temp.add(a[i]);     List res = setsOfSizeK(a,i+1,k-1,temp);     if(!res.isEmpty())      ls.addAll(res);    } else if(k==0 && i<= a.length) {     ls.add(s);     break;    }    }         return ls;   }    @Test  public void testSetsOfSizeK() {   int[] a = {1,2,3,4};   List l = setsOfSizeK(a,0,2,new Set(2));   System.out.print(l.size());  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"am i understand the problem in a wrong way?  set full(all(vals)); for (auto it = full.begin(); it != full.end(); it++) for (auto it2 = ++it--; it2 != full.end(); it2++) for (auto it3 = ++it2--; it3 != full.end(); it3++)   cout << *it << ' ' << *it2 << ' ' << *it3 << endl;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think it can be done in O(kn) where k is subarray size and n is the given array size.  Let A be the array of numbers with size n. Let C be an array such that C[i,j] contains the possible subsets of size j from array A with size i. We want C[n,k]. We will find it by Dynamic Programming using Memoized version. Here is the algorithm:  SET(A,n,k)   for i<-1 to n     f     C[i,1]={A[i]}     for j<-1 to n     for i<-1 to k       C[j,i]=empty set   return MEMOIZED(A,C,n,k)     MEMOIZED(A,C,n,k)   if k=0 or n=0     C[n,k]=empty set   else if k=1 and C[n,k]=empty set          for j<-1 to n            C[n,k]=C[n,k] U {A[j]}// here U adds subset {A[j]} to set of subsets in C[n,k]           return C[n,k]        if n          return C[n,k]        if n=k           C[n,k]= MEMOIZED(A,C,n-1,k-1) U A[n] //here U will add A[n] to every subset in C[n-1,k-1]        else           C[n,k]= MEMOIZED(A,C,n-1,k) U (MEMOIZED(A,C,n-1,k-1) U A[n])    return C[n,k]        Clearly we reach each box in array C only once .So Time Complexity is O(kn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Isn't this just finding nCk?? (combinatorial problem)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=9753898","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"6","title":"Read in a list of words.Create a 20x20 grid.Put the first word at 0,0 across Each of the following words in the list should be placed so that they intersect at as many letters as possible (the input words will always have at least one letter of overlap.)  If there is one more than one spot with the same number of intersected letters, place the word at all positions. (if some positions cause others to be invalid, choose the positions that allow the most words to be placed.)  Words can read across, backwards (right to left), down, and up. A word is two or more characters in a row. Positions are not valid if they cause non-words to appear in the grid. If a word could fit in either direction (across/backwards) (up/down) choose across or down.    the question   example input: alley zebra bole bolero wares forgetmenot carbonate aardvarks trombone arts example output: alley      c         r  l s f  aardvarks  b  orelob  r         elob r r   b    s    z r  a g enobmort     seraw e t n    r      l    t a aardvarks  forgetmenot           b  t e o e              a n b                n o r           enobmort aardvarks        b   c                r               aardvarks                 c","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can you please explain a little more about how u get the output. I am not getting it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can anybody please explain this ques....  its really difficult to get the question"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what does this statement mean \"A word is one or two characters in a row\" :-o"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can't understand what you said."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"example output should have been more clear, i don't understand the question"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=9820788","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"57","title":"there is a pyramid with 1 cup at level , 2 at level 2 , 3 at level 3 and so on.. It looks something like this                                            1                                        2    3                                      4   5   6 every cup has capacity C. you pour L liters of water from top . when cup 1 gets filled , it overflows to cup 2,3 equally, and when they get filled , Cup 4 and 6 get water only from 2 and 3 resp but 5 gets water from both the cups and so on. Now given C and M .Find the amount of water in ith cup.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"Solved it with O(k). The idea is simple. Pour L into coup 1. Divide into its children if overflows. Do this for subsequent elements, until find k. The biggest problem is to find the children. The first child of a coup is the same of last if height does not change. The second one is first + 1. For the given example, children would found in the the folowing order (se how children repeats when height repeats (kth is one based!):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"What about this? I am building up the nodes from top-bottom and assigning water to it. I can know the 2 children of a node based on the level of a node, since at each level there are (level+1) nodes."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I write this in Java. I think this is more easy to understand, but maybe not short enough. {  public double calculateWaterVol(double c, double l, int kth)  {   // the first cup is numbered as 1, not 0.   int height = 1;   int currentTotal = height;   double water[] = new double[kth];    water[0] = l;      for (int i=1; i  {    if (i > currentTotal)                         {                                 height++;     currentTotal += height;    }    if (water[i-1] > c)    {     double overLoad = (water[i-1] - c)/2;     int leftChild = i + height;     int rightChild = i + height + 1;     if (leftChild > kth)      break;     else      water[leftChild-1] = overLoad;          if (rightChild > kth)      break;     else      water[rightChild-1] = overLoad;      water[i-1] = c;    }     }      return water[kth-1]>c? c: water[kth-1];  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I think we can do it in O(level of ith cup) also, idea is to calculate the water required to fill ALL the cups till nth level. Water required to fill 1st level = C Water required to fill 2nd level = 2C ( because 2 cups are there ) Water required to fill 3rd level = 3C ( 3 cups) and so on  so water required to fill all the cups till nth level will be: C + 2C + 3C + 4C + .... + nC = C * n * (n+1) / 2  Ok, now that we are given the cup number i, we can determine its level in O(level) let say L.  Now we need to check how much water is required to  fill the cups completely till (L-1)th level."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the pyramid actually looks like                                    1                                   2  3                                  4  5  6"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am nt able to make the pyramid properly . Its in acute triangle shape. and wen water flows from 1 it gets transfered to both 2 and 3 equally."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's what you meant:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what is M here?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@ anon yaa this is what i meant :) and M is the total amount of water poured initially"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my solution : for L leter of water max full cup level :l=Log(L/C+1) this gives the max level of nodes which are full. Now if i<=l then cup number i is full otherwise i should be at the next level which should contail (L-lC)/nodes at that level. nodes at that level=pow(2,l).  problem wud be more tuff if the capacity of each cup wud vary according to their label. Any suggestions are appriciable."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The i th row starts with i*(i-1)/2+1 indexed cup and ends with i*(i+1)/2 indexed cup. We have three cases, two for the cups at ends and one for the cups between them. The cups at the end are filled by only one cup lying above while the ones in between are filled by two cups. We find the amount of water spilled by the cups responsible for filling a cup recursively. For the cup whose content needs to be determined returns the spilledWater or capacity whichever is less   #include #include #include bool isLeftMost(int index); bool isRightMost(int index); #define GETROW(index)((1 + (int)sqrt(-1+4*(index)*2*1.0))/2) #define GETLEFTMOST(row)((row)*((row)-1)/2+1) #define GETRIGHTMOST(row)((row)*((row)+1)/2) double getSpilled(int cap, int vol, int index); double getRecv(int cap, int vol, int index); int getLeftParent(int index); using namespace std; int main() {  int temp;  cout<<\"Enter the capacity \";  int c;  scanf(\"%u\", &c);  cout<<\"Enter the volume of fluid \";  int vol;  scanf(\"%u\", &vol);  while(true)  {   cout<<\"Enter the number of cup \";   int num;   scanf(\"%u\", &num);   double content = getRecv(c,vol, num);   cout<<\"fluid content = \"<<<'\\n';  }   } double getRecv(int cap, int vol, int index) {  double recv;  if(index == 1)   return vol else if(isLeftMost(index))  {   int upperIndex = GETLEFTMOST(GETROW(index)-1);   recv = getSpilled(cap, vol, upperIndex)/2;  }  else if(isRightMost(index))  {   int upperIndex = GETRIGHTMOST(GETROW(index)-1);   recv = getSpilled(cap, vol, upperIndex)/2;  }  else  {   recv = getSpilled(cap, vol, getLeftParent(index))/2     + getSpilled(cap, vol, getLeftParent(index)+1)/2;  }  return recv} double getSpilled(int cap, int vol, int index) {  double recv = 0;  if(index == 1)   return vol-cap>0?vol-cap:0;  else if(isLeftMost(index))  {   int upperIndex = GETLEFTMOST(GETROW(index)-1);   recv = getSpilled(cap, vol, upperIndex)/2;  }  else if(isRightMost(index))  {   int upperIndex = GETRIGHTMOST(GETROW(index)-1);   recv = getSpilled(cap, vol, upperIndex)/2;  }  else  {   recv = getSpilled(cap, vol, getLeftParent(index))/2     + getSpilled(cap, vol, getLeftParent(index)+1)/2;  }  return recv-cap>0?recv-cap:0; } int getPos(int index) {  return 1 + index - GETLEFTMOST(GETROW(index)); } int getLeftParent(int index) {  int pos = getPos(index);  return GETLEFTMOST(GETROW(index)-1)+pos-2; } bool isLeftMost(int index) {  int num = GETROW(index);  if(GETLEFTMOST(num) == index)   return true;  return false; } bool isRightMost(int index) {  int num = GETROW(index);  if(GETRIGHTMOST(num) == index)   return true;  return false; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Thanks for pointing out. I think, complexity is O(n) where n is the index of the cup, for the above solution. We can modify each recursive call to store the values of spilled water."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Pseudo code:  float findAmount(int L, int C, int i) {      int j=0;      float jc=0.0f;      while(L && i>0)      {           j++;           if(L>=(C*j))           {               jc=C;               L=L-(C*j);           }           else           {               jc= L/j;           }           i-=j;     }     return jc; }   Plz correct me if it is wrong..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"float findAmount(int L, int C, int i) \n{ \n    int j=0; \n    float jc=0.0f; \n    while(L && i>0) \n    { \n        j++; \n        if(L>=(C*j)) \n        { \n            jc=C; \n            L=L-(C*j); \n        } \n        else \n        { \n            jc= (float)L/j; \n            L=L-(jc*j); \n        } \n        i-=j; \n    } \n    if(L<=0 && i>0) \n        return 0.0f; \n    return jc; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I use recursive method to solve the problem.ps: php language."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Given r the row of cup there are r/2 * (r+1) cups. So we need to find the first r such that r/2 * (r+1) * C > L. for the i < r/2 * (r-1) they are filled. for i > r/2 * (r-1) they are (L - r/2 * (r-1) * C) / r filled.  So the trick is to find r. There are two way either solve the in eq. r^2 + r - 2L/C >= 0 or doing the following:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I do not think that this solution is right... The rate of inflow will vary for the cups in same row.. cups at the ends will have slower inflow.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This will calculate the overflows, from which it is easy to calculate what each cup holds:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if L<=C  then L goes to cup #1  if C<=3C then #1 is filled, cups #2 and #3 gets (L-C)/2  if 3C<=5C then cups #1,#2,and #3 are filles,  cup #4 and #6 gets (L-3C)/4  and cup #5 gets 2(L-3C)/4  if 5C<=7C then cups #1,#2,#3,#4, #5, #6 are filled, cups #8 and #9 are half, and rest are empty  if 7C<7.5 then cups #1 to #6 and #8, and #9 are filled, cups #7 and #10 are 1/4 filled  so, the next step is to generalized this formula"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Same logic as above, but building the pyramid instead of calculating its children."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The cups are arranged in form of pascal's triangle, the amount will be equal to (L-C) times the corresponding Pascal's coefficient."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1        2 3"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"since we are only interested in the water at cup i, you can just go back up by tracing the parents instead of tracing the kids. algorithmically it should be < O(n) but i dont know how to prove that. ie   water(cup i ) = water (cup (1stparent(i)) + water (cup(2ndparent(i))  That way you only calculate water for the tree that is responsible for pouring water into cup i."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class FillCups { \n     public static float _calc(int capacity, float water, int level, int cur, int i) { \n         if (water <= 0) { \n             return 0; \n         } \n \n         if (cur == i) { \n             return water > capacity ? capacity : water; \n         } else { \n             if (water <= 0) { \n                 return 0; \n             } \n \n             float per_child = (water - capacity) / 2; \n \n             float res = _calc(capacity, per_child, level+1, level+cur, i) + \n                         _calc(capacity, per_child, level+1, level+cur+1, i); \n \n             return res > capacity ? capacity : res; \n         } \n     } \n \n     public static float calc(int capacity, float water, int nth) { \n         return FillCups._calc(capacity, water, 1, 1, nth); \n     } \n \n     public static void main(String args[]) { \n         int capacity = 3; \n         float water = 10f; \n \n         System.out.format(\"water: %.2f\\n\", FillCups.calc(capacity, water, 5)); \n     } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution using array array strats from 1...n // as difference of elements in each level is in AP so we can easily tell the 1st element in level as a quadractic equation  let equation be ax^2+bx+c  gives 1 = a+b+c; 2=4a+2b+c; 4=9a+3b+c  solving which we get equation as (x^2-x+2)/2  f(y) gives the level in which cup y belongs to  f(y) = floor(1/2+sqrt(2y-2+1/4))  also a element y children are y + f(y) and y + f(y) +1  so start form index 1 fill overflow to children, then goto 2nd element fill its children and so oncomplexity O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"so if 1 Cup can hold 1 L, if I want to know amount of water I need to fill cup in cup 6, then it will be 6L.  Am I wrong?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"C: capacity of each cup M: total flow of water n: the cup for which amount of water is required."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"wouldn't finding the height in pyramid and then if it is edge node or not, sufficient to determine?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"An easy approach: 1. Name the levels as 1,2,3.... A cup numbered i will pour extra water into cups with number    i+level and i+level+1.  I am using an integer array cup[] to store the amount of water in each cup. The same logic applies to the float also.  Here is the pseudo code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the ith number in level x 's index is :  (x-1)*x/2 + i, and it's child is (x+1)*x/2 +i, (x+1)*x/2 + i +1;  use the same method just like  lucas.eustaquio ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static double calculateWaterVol(double water, double capacity, int kth) \n    { \n double[] curLevel = new double[1]; \n curLevel[0] = water; \n  \n boolean overflow = true; \n  \n while(overflow) \n { \n     double[] nextLevel = new double[curLevel.length+1]; \n \n     overflow = false; \n      \n     for (int i=0; i capacity) \n  { \n      overflow = true; \n      double over = (curLevel[i] - capacity)/2; \n      curLevel[i] = capacity; \n \n      nextLevel[i] += over; \n      nextLevel[i+1] += over; \n  } \n     } \n \n     if (kth > curLevel.length) \n     { \n  kth -=curLevel.length; \n     } \n     else \n     { \n  return curLevel[kth-1]; \n     } \n      \n     curLevel = nextLevel; \n } \n  \n if (kth > curLevel.length) \n { \n     return 0; \n } \n  \n return curLevel[kth-1]; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solved with recursion:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=9670311","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"3","title":"It's A Small World As a popular engineer, you know many people in your home city. While traveling around town, visiting your friends, you realize it would be really handy to have a program that tells you which of your friends are closest based upon which friend you are currently visiting.   Being an engineer who is interested in writing software that is useful to everyone, you decide to write a general solution to your quandary. Each of your friends lives at a unique latitude and longitude. For the purposes of this program, the world is flat, and the latitude and longitude are for all intents and purposes Cartesian coordinates on a flat plane. For example, in our flat world, lat 45, long -179 is not as close to lat 45, long 179 when compared to lat 45, long 170.   Write a program that takes a single argument on the command line. This argument must be a file name which contains the input data. Your program should output the nearest three other friends for each friend in the list. You are virtually a celebrity and your friend list can be astoundingly huge. Your program must exhibit better than quadratic asymptotic growth in runtime as a function of the size of your friend list, and be robust and resource efficient.     Input specifications  The input file consists of multiple lines, all of which follow the same format. Each line has three values separated by an amount of white space. The first value is the unique id number of that friend, expressed as an integer. The second value is the latitude of that friend, expressed as a rational number. The third and last value is the longitude of that friend, expressed as a rational number. Every friend lives at a unique combination of latitude and longitude (e.g. no two friends will ever share the exact same values). Each line ends with a single new line, except for the last line of the file, which may or may not have a terminating new line.   Example input file:  1  0.0      0.0 2  10.1     -10.1 3  -12.2    12.2 4  38.3     38.3 5  79.99    179.99 You are guaranteed that your program will run against an input file that is well formed, and has at least four lines. You are also guaranteed that your list of friends have unique distances between one another; no two distinct pairs of friends will have the same distance between them.     Output specifications  In the order presented in the input file, output the nearest three friends for each friend. Each line of output should start with the integer id of the friend followed by a single space character, and then the list of three nearest other friend ids followed by a single new line. Even the last line of the output should terminate in a new line. This list should be comma-delimited, with no spaces. The list must be in order of proximity, with the closest of the three being first, and the farthest of the three being last.   Example output:  1 2,3,4 2 1,3,4 3 1,2,4 4 1,2,3 5 4,3,1","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"#include  \n#include  \n#include  \n#include  \n#include  \n#include  \n#include  \nstruct Point { \n double pt[2]; \n int id; \n double distance; \n}; \ntypedef std::vector PointList; \ntypedef PointList::iterator PointListItr; \nstruct compareX { \n    bool operator ()(const Point& left, const Point& right) const { \n        return left.pt[0] < right.pt[0]; \n    } \n}; \nstruct compareY { \n    bool operator ()(const Point& left, const Point& right) const { \n        return left.pt[1] < right.pt[1]; \n    } \n}; \nstruct compareD { \n    bool operator ()(const Point& left, const Point& right) const { \n        return left.distance < right.distance; \n    } \n}; \nstruct kdNode { \n Point point; \n kdNode *left; \n kdNode *right; \n \n kdNode(PointListItr begin,  \n     PointListItr end,int depth); \n}; \nkdNode::kdNode( PointListItr begin,  \n    PointListItr end,int depth = 0) { \n left = right = 0; \n if (begin == end) { \n  return ; \n } \n if( end - begin == 1) { \n  point = *begin; \n  return; \n } \n if(depth & 1) \n  std::sort( begin, end, compareY()); \n else \n  std::sort( begin, end, compareX()); \n PointList::size_type median = (end - begin) / 2; \n point = *(begin + median ); \n if ( begin != ( begin + median )) \n  left  = new kdNode(begin , begin + median , depth + 1); \n if ( (begin + median + 1 ) != end ) \n  right = new kdNode(begin + median + 1, end, depth + 1); \n} \nvoid readPoints(const char* fileName, PointList& points) { \n    std::ifstream input(fileName); \n    if ( input.peek() != EOF ) { \n  while(!input.eof()) { \n   int id = 0; \n   double x_cord, y_cord; \n   input >> id >> x_cord >> y_cord; \n   Point t ; \n   t.pt[0] = x_cord; \n   t.pt[1] = y_cord; \n   t.id    = id; \n   points.push_back(t); \n  } \n  input.close(); \n }  \n} \ndouble dist(Point &p1, Point &p2) { \n double a = p1.pt[0] - p2.pt[0]; \n double b = p1.pt[1] - p2.pt[1]; \n return (a * a) + (b * b); \n} \nPoint nearest(kdNode *node, Point &point, Point &min, int depth = 0) { \n if ( node ) { \n  int axis = depth % 2; \n  double d = point.pt[axis] - min.pt[axis]; \n  kdNode *near = d <= 0 ? node->left  : node->right; \n  kdNode *far  = d <= 0 ? node->right : node->left; \n  min = nearest(near, point, min, depth + 1); \n  if ((d * d) < dist(point, min)){ \n   min = nearest(far, point, min, depth + 1); \n  }  \n  if (dist(point,node->point) < dist(point, min)) { \n   min = node->point; \n  } \n } \n return min; \n} \nvoid nearest_k(kdNode *node, Point &point,  \n      PointList &min, \n      double k_dist = std::numeric_limits::max(),  \n      int depth = 0) { \n if ( node ) { \n  int axis = depth % 2; \n  double d = point.pt[axis] - node->point.pt[axis]; \n  kdNode *near = d <= 0 ? node->left  : node->right;   \n  kdNode *far  = d <= 0 ? node->right : node->left; \n  nearest_k(near, point, min, k_dist, depth+1); \n  if ( (d * d ) < k_dist ) { \n   nearest_k(far, point, min, k_dist, depth+1); \n  } \n  d = dist(point, node->point); \n  if ( d < k_dist) { \n   node->point.distance = d; \n   min.push_back(node->point); \n  } \n  std::sort(min.begin(), min.end(), compareD()); \n  if ( min.size() > 3 ) { \n   for ( int i = 0; i < min.size() - 3; i++) { \n    min.erase(min.begin() + i ); \n   } \n  } \n  k_dist = min[0].distance; \n } \n return; \n} \nvoid printLevelWise(kdNode *root) { \n std::queue Q; \n Q.push(root); \n while ( !Q.empty()) { \n  root = Q.front(); \n  if( root->left) { \n   Q.push(root->left); \n  } \n  if ( root->right) { \n   Q.push(root->right); \n  } \n  Q.pop(); \n } \n} \nvoid printPoint(Point p) { \n std::cout << \"( \" << p.pt[0] << \",\" << p.pt[1] << \" )\" << std::endl; \n} \nint main(int argc, char** argv ) { \n    if ( argc <= 1 ) { \n        return 0; \n    } \n PointList locations; \n readPoints(argv[1], locations); \n if ( locations.size() == 0 ) \n  return 0; \n \n kdNode *pKdTree = new kdNode(locations.begin(), locations.end(),0); \n printLevelWise(pKdTree); \n Point t; \n t.pt[0] = 6; \n t.pt[1] = 5; \n Point root =  pKdTree->point; \n Point p = nearest(pKdTree, t, root, 0); \n \n PointList result; \n for ( PointListItr itr = locations.begin(); itr != locations.end(); ++itr) { \n  nearest_k( pKdTree, *itr, result); \n  std::cout << (*itr).id << \" \" << result[0].id << \",\" << result[1].id << \",\" << result[2].id << std::endl; \n } \n delete pKdTree; \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hey buddy your program is giving wrong output for the sample program  2 4,5,0 1 0,5,0 3 0,5,0 4 0,5,0 5 5,0,2 0 0,2,2 which is not matching the sample output"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about sorting the file based on longitude/latitude. Then print 2 closest of nth id as i-1, i+1 and max(i-2,i+2). Quicksort should be nlog(n) and printing will be O(n)."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=9608562","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"11","title":"Gattaca You have a DNA string that you wish to analyze. Of particular interest is which intervals of the string represent individual genes. You have a number of \"gene predictions\", each of which assigns a score to an interval within the DNA string, and you want to find the subset of predictions such that the total score is maximized while avoiding overlaps. A gene prediction is a triple of the form (start, stop, score). start is the zero-based index of the first character in the DNA string contained in the gene. stop is the index of the last character contained in the gene. score is the score for the gene.     Input Specification  Your program will be passed the name of an input file on the command line. The contents of that file are as follows.   The first line of the input contains only n, the length of the DNA string you will be given.   The next ceiling(n / 80) lines each contain string of length 80 (or n % 80 for the last line) containing only the characters 'A', 'C', 'G', and 'T'. Concatenate these lines to get the entire DNA strand.   The next line contains only g, the number of gene predictions you will be given.   The next g lines each contain a whitespace-delimited triple of integers of the form     representing a single gene prediction. No gene predictions will exceed the bounds of the DNA string or be malformed (start is non-negative and no more than stop, stop never exceeds n - 1).   Example Input:  100 GAACTATCGCCCGTGCGCATCGCCCGTCCGACCGGCCGTAAGTCTATCTCCCGAGCGGGCGCCCGATCTCAAGTGCACCT CACGGCCTCACGACCGTGAG 8 43  70  27 3   18  24 65  99  45 20  39  26 45  74  26 10  28  20 78  97  23 0   9   22    Output Specification  Print to standard out the score of the best possible subset of the gene predictions you are given such that no single index in the DNA string is contained in more than one gene prediction, followed by a newline. The total score is simply the sum of the scores of the gene predictions included in your final result.   When constructing your output, you may only consider genes exactly as they are described in the input. If you find the contents of a gene replicated elsewhere in the DNA string, you are not allowed to treat the second copy as a viable gene. Your solution must be fast and efficient to be considered correct by the robot.   Example Output:  100","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I think it is a weighted interval scheduling. It can be solved by Dynamic Programming i O(N) time. Given a set of DNA substrings --> intervals (structured in term of ). I[j] is not overlapped with I[k] if end_j < bgn_k. The trick is to sort the interval in earliest finish. We shall have an array of interval I of size N. Given OPT(j) be the optimal path defined on the first jth interval. OPT(j) has two options; one that include I[j] and one doesn't."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"IMO its a good variation of longest increasing sub sequence."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \n#include  \n#include  \n \ntypedef struct { \n    long start, finish, weight; \n} Interval; \nInterval  *I; \nlong *M; \nlong *P; \n \n#define MAX(x, y)  (((x) > (y)) ? (x) : (y)) \n \n \nint compare(const void * left, const void * right) { \n return (((Interval *)left)->finish - ((Interval *) right)->finish); \n} \n \nint IntervalSearch(int start, int high){ \n if (high == -1) return -1; \n \n int low = 0; \n int best = -1; \n int mid; \n int finish; \n \n while (low <= high) { \n  mid = (low + high) /2 ; \n  finish = I[mid].finish; \n  if (finish >= start) { \n   high = mid-1; \n  } else { \n   best = mid; \n   low = mid + 1; \n  } \n } \n return best; \n} \n \nlong Compute_Opt(long j) { \n if (j == 0) \n  return 0; \n if (M[j] != -1l) { \n  return M[j]; \n } \n M[j] = MAX(I[j].weight + Compute_Opt(P[j]), Compute_Opt(j - 1)); \n return M[j]; \n} \n \nint main( int argc, char **argv) { \n    if ( argc <= 1 ) { \n        return 0; \n    } \n    std::ifstream dnaInput(argv[1]); \n    if ( dnaInput.peek() == EOF ) { \n        return 0; \n    } \n    int lenDnaStr; \n    dnaInput >> lenDnaStr ; \n    for(int index = 0; index <= std::ceil(((float)lenDnaStr)/80.0); index++) { \n        dnaInput.ignore( lenDnaStr + 1, '\\n'); \n    } \n    int numOfIv = 0; \n    dnaInput >> numOfIv; \n    if ( numOfIv == 0 ) { \n        return 0; \n    } \n numOfIv = numOfIv + 1; \n \n I = (Interval *) malloc (sizeof(Interval) * numOfIv); \n M = (long *)malloc(sizeof(long) * numOfIv); \n P = (long *)malloc(sizeof(long) * numOfIv); \n \n Interval t; \n t.start     = 0; \n t.finish    = 0; \n t.weight    = 0; \n I[0] = t; \n  \n \n    for ( int index = 1; index < numOfIv; index++) { \n        int start = 0, finish = 0, weight = 0; \n        dnaInput >> start >> finish >> weight; \n  Interval t; \n  t.start     = start; \n  t.finish    = finish; \n  t.weight    = weight; \n  I[index] = t; \n } \n    dnaInput.close(); \n qsort(I, numOfIv, sizeof(Interval), compare); \n \n int best; \n for (int index = 1; index < numOfIv; index++){ \n  M[index] = -1l;  \n  best = IntervalSearch(I[index].start,index - 1); \n  if (best != -1) { \n   P[index] = best; \n  } else { \n   P[index] = 0; \n  } \n } \n long res = Compute_Opt(numOfIv - 1); \n \n free ( P ); \n free ( I ); \n free ( M ); \n    std::cout << res << std::endl; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Seriously, is this a Facebook interview question? I could be wrong, but this sounds more like the puzzles on Facebook than an interview question."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \n#include  \n \nusing namespace std; \n \nstruct Endpoint { \n  int loc; \n  int score; \n  int best_score; \n  Endpoint * other; \n \n  Endpoint (int _loc, int _score) : loc(_loc), score(_score), best_score(0) {} \n}; \n \nbool comp_endpt_ptr(Endpoint * e1, Endpoint * e2) { \n  return e1->loc < e2->loc; \n} \n \nint N, G; \nvector endpts; \n \nint main() { \n  // ignore actual DNA sequence... we only need this if we want to                \n  // print results                                                                \n  string s; \n  cin >> N; \n  for (int i = 0; i < (N - 1)/80 + 1; i++) \n    cin >> s; \n \n  cin >> G; \n  for (int i = 0; i < G; i++) { \n    int start, end, score; \n    cin >> start >> end >> score; \n    Endpoint * left = new Endpoint(start, score); \n    Endpoint * right = new Endpoint(end + 1, score); \n    left->other = right; \n    right->other = left; \n    endpts.push_back(left); \n    endpts.push_back(right); \n  } \n \n  sort(endpts.begin(), endpts.end(), comp_endpt_ptr); \n \n  for (int i = 1; i < endpts.size(); i++) { \n    Endpoint * pt = endpts[i]; \n    if (pt->other->loc > pt->loc) \n      pt->best_score = endpts[i - 1]->best_score; \n    else \n      pt->best_score = max(endpts[i - 1]->best_score, \n                           pt->score + pt->other->best_score); \n    //    cout << pt->loc << \": \" << pt->best_score << endl;                      \n  } \n \n  cout << endpts.back()->best_score << endl; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) What is the use DNA string given in the input ? 2) The order of algorithm is O(nlogn) not O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"code in C#      class DNA : IComparable     {         public int Start { get; set; }         public int End { get; set; }         public int Score { get; set; }          public DNA( int s, int e, int ds )         {             this.Start = s;             this.End = e;             this.Score = ds;         }          public int CompareTo( DNA d )         {             return this.End.CompareTo( d.End );         }     }  public static void FindMaxScore()         {             List dnas = new List();             // read input             dnas.Sort();              int N = 100;             int[] scores = new int[N];             int[] seleceted = new int[N];              for (int i = 0; i < dnas.Count; i++)             {                 DNA d = dnas[i];                 if (d.Score + scores[d.Start] >= scores[d.End - 1])                 {                     scores[d.End] = d.Score + scores[d.Start];                     seleceted[d.End] = i+1;                 }                 else                 {                     scores[d.End] = scores[d.End - 1];                     seleceted[d.End] = seleceted[d.End - 1];                 }                  int iEnd = N;                 if (i < dnas.Count - 1)                 {                     iEnd = dnas[i + 1].End;                 }                 for (int j = d.End + 1; j < iEnd; j++)                 {                     scores[j] = scores[j - 1];                     seleceted[j] = seleceted[j - 1];                 }             }              //output max score             Console.WriteLine( scores[N - 1] );              //output selected DNA strings             int idx = seleceted[N - 1];             while (idx > 0)             {                 Console.WriteLine( idx - 1 );                 idx = seleceted[dnas[idx - 1].Start];             }         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"\"weighted interval scheduling\" question takes time O(n*log(n))."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=9672248","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"8","title":"Find Sophie After a long day of coding, you love to head home and relax with a loved one. Since that whole relationship thing hasn't been working out for you recently, that loved one will have to be your cat, Sophie. Unfortunately you find yourself spending considerable time after you arrive home just trying to find her. Being a perfectionist and unable to let anything suboptimal be a part of your daily life, you decide to devise the most efficient possible method for finding Sophie.   Luckily for you, Sophie is a creature of habit. You know where all of her hiding places are, as well as the probability of her hiding in each one. You also know how long it takes you to walk from hiding place to hiding place. Write a program to determine the minimum expected time it will take to find Sophie in your apartment. It is sufficient to simply visit a location to check if Sophie is hiding there; no time must be spent looking for her at a location. Sophie is hiding when you enter your apartment, and then will not leave that hiding place until you find her. Your program must take the name of an input file as an argument on the command line.     Input Specifications  The input file starts with a single number, m, followed by a newline. m is the number of locations available for Sophie to hide in your apartment. This line is followed by m lines, each containing information for a single location of the form (brackets for clarity):    probability is the probability that Sophie is hiding in the location indicated. The sum of all the probabilities is always 1. The contents of these lines are separated by whitespace. Names will only contain alphanumeric characters and underscores ('_'), and there will be no duplicate names. All input is guaranteed to be well-formed. Your starting point is the first location to be listed, and in effect it costs you no time to check if Sophie is there.   The file continues with a single number, c, followed by a newline. c is the number of connections that exist between the various locations. This line is followed by c lines, each of the form:       The first two entries are the names of locations and seconds is the number of seconds it takes you to walk between the them. Again these lines are whitespace-delimited. Note that the locations are unordered; you can walk between them in either direction and it will take the same amount of time. No duplicate pairs will be included in the input file, and all location names will match one described earlier in the file.   Example input file:  4 front_door    .2 in_cabinet    .3 under_bed     .4 behind_blinds .1 5 front_door under_bed     5 under_bed  behind_blinds 9 front_door behind_blinds 5 front_door in_cabinet    2 in_cabinet behind_blinds 6    Output Specifications  Your output must consist of a single number followed by a newline, printed to standard out. The number is the minimum expected time in seconds it takes to find Sophie, rounded to the nearest hundredth. Make sure that the number printed has exactly two digits after the decimal point (even if they are zeroes). If it is impossible to guarantee that you will find Sophie, print \"-1.00\" followed by a newline instead.   Example output:  6.00","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Dijsktra, using as weight the following function  w(A,B) = (time to got from A to B) * (probability of B)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Would someone please delete this Facebook puzzle as: 1. It is not a real interview question. 2. It clutters the list of questions. 3. Solution requires several steps and it is pointless to publish it in its entirety."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@Dan, what ever it is, but it got some strategy to solve I recommend two data structures, one is to maintain a array of pointers to lists,each pointer is pointing to list of reachable locns from  locn, in non decreasing order of their probabilities  ----- addr1| ->locn3(0.4,4 sec)->locn4(0.1,45 sec)->null ----- addr2|->null ----- addr3|->locn2(0.2,34 sec)->locn1(0.2, 76 sec)->null -----  other is a map set to all false on start, which on reaching is set to true   typdef struct {  prob;  duration;  locn;  List* next; }List;  typdef struct {   locn;   bt * next; }bt;  Bt *bt;  int locate(vector list ,map m) {   int i=0;   double total_duration;   List temp = list[i];   bool found = false;   int total_locn = m.size();//total entries   int total_visited =1;    do   {     if( total_locn == total_visited)     {           print(total_duration);        return 0;       }                while(temp || m(temp)) temp=temp->next;     if(!temp)  // no more movements     {           print(\"NO SoLUTION\");        return 1;       }     else     {        m(temp) = true;        total_duration += temp->duration;        add_traversal_path(bt,temp->locn);        temp = set_vector_index(temp);// sets temp with list pointer of current locn        total_visited++;        add_traversal_path(bt,temp);// for tracking path              }       }(while(!found))   return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Well, I agree with Dan. This type of puzzle is not good suit to be posted here. Thousands of puzzle are on Wu Riddle forum. Or, you could better post on stackoverflow. I'm not saying there is no point to solve a puzzle, but as Dan pointed few reasons already.  On the other hand, it could be possible to narrate the original problem concisely. That way, more people would be encouraged to get the problem, and try to solve it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how about using A* search ?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=9619312","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"Given a node in a graph that is reachable, how do you find all the nodes that are reachable ? How would you enable parallel computation of this information ? Given a number of cores, how many threads would you choose ?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Given a node in a graph that is reachable, how do you find all the nodes that are reachable ? Perform BFS and print all nodes reachable from the graph's node How would you enable parallel computation of this information ?  Implement the threading with Queue syncronized"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=9381092","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"8","title":"Question: Design a component that implements the following functionality..  1) Record an Event (For the sake of simplicity, treat the Event as an integer code)   2) Return the number of Events recorded in the last one minute.   3) Return the number of Events recorded in the last one hour. i.e implement the following interface  - Design the interface first - Give the implementation detail.  <<>>  Open ended question: What if there isn't enough storage available to store each individual event ?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"To count # of requests Maintain a circular queue of size 3600*(# sample per second). That is, if you are sampling every millisecond then (# of sample per second is 1000) Now, if you request last 1 hr then sum all elements in the queue, if you request last 1 min, then sum top 60*1000 elements if you request last 1 sec, then sum top 1000 elements"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the interface must be something as below , each event must have the capability of reporting itself , on occurrence . The Event class will have something like this interface   class Event { private:        int code ; public :        Event(int code);        abstract notify();// do the purpose of the event and call the register method of the Register class  }   class Register {          Register(int fno) ;          RegisterEvent(int code) ; // register this event with number \"code\" private:          int lasthr ;// the number of events in the lasthour           int lastmin ;// the number of events in the lastmin , updated with every call to RegisterEvent           time_t time1 , time2 ;// to calculate the time            int alloc_new_file(); // the new file is allocated , which gives the new file , if the new file is overidden ; } many other choices are there for handling the overflow problem , but this seems to be the fastest"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The key point here is about how to store the events and report them. Considering the storage space and reporting method, you do not need to store all events but dynamically aggregate them for saving the space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming we only need the two counters (last hour\\minute) here is my idea: keep a buffer of pairs in the main memory . Keep aside the start and end of this buffer. Every time a new event is entered: iterrate from the start, deallocate the memory of an event which is older than 1 hour and decrement the last-hour-events by one. enter your new event at the end and increment the counter by one.  Corrections are welcome."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class Register { \n  private: \n    int counters[3600]; \n \n  public: \n \n    Register() { \n      for(int i = 0; i < 3600; ++i) counters[i] = 0; \n    } \n \n    void add(const Event& e) { \n      long time = e.timestamp; /* In Seconds */ \n      int bucket = time % 3600; \n      counters[bucket]++; \n    } \n \n    long getLastHour() { \n      long sum = 0; \n      for(int i=0; i < 3600; ++i) sum += counters[i]; \n      return sum; \n    } \n \n    long getLastMinute() { \n      long now = time(NULL); \n      long sum = 0; \n      for(int i = now; i > now - 60; --i) { \n        sum += counters[i%3600]; \n      } \n      return sum; \n    }  \n};"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we can use splay tree for this. In this we can keep adding the new nodes to the top."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=9382096","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"17","title":"Design a system to calculate the number of unique words in a file..  1) What if the file is huge ? (i.e cannot fit in the main memory)  2) Assuming that you have more than one computers available, how can you distribute the problem ?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Merge sort 2) Hadoop + Hive"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. I think you are thinking of external sorting. In any case, you don't need to sort the words... just use a hash-map to store the occurrences of each word."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"have a Counter and a hashmap in the external memory. Whenever  a new word comes in add it to hastable and increment the counter . Do the process and increment the counter only if the word is not present in Hashtable ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Divide the file in chunks.  Use Map reduce methodology And Apply Merge sort on each chunk."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why not simply inserting all your words in a Set, i.e. HashSet and then mySet.size() when the computation is ended? In a multi-threaded environment you can safely use ConcurrentSkipListSet unless there are some sort of compound operations.  If the number of words is N, the complexity is O(N) (if an HashSet is used) or O(NlogN) if a SkipList is used."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using hash counting and then map-reduce for the size issue."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hash is an in-memory thing and file is too large to be stored in primary memory. So we have to thing of something external data structure.  My suggestion is B-Tree, where for each word first search it in BTree. If word exists increase the count of that word and if word doesn't exist insert it into the tree.  Once scanning of whole file is done, all entries which has count as 1 will be the words which were unique in the document."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#Create a TRIE tree, with a special node at the end of each WORD. #Read the words one by one until EOF.  #Whenever a new word is added in the TRIE, write 1 in it's special terminal node and increment unique_count. #Whenever a word is repeated, increment the counter in it's terminal node. If the counter is incremented from 1 to 2, also decrement the unique_counter."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"map task :- finds the unique words makes all words the keys reduce task:- combines the output of two mapped task/reduce task  tinyurl {dot} com/bvwtm3f"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1>If the input is too large to fit into memory, do the mappings, based on the word as key, and value does not  matter.    2> In the MAP phase, map function only emit pairs      The output is written over a buffer, when buffer gets full O(N)      The output is spilled over the disk, and then combine function operates on the spilled data and produces a sorted key outuput. (this is manageable in the memory)      At the end it is merged with the already processed data in the map phase.(sorted data merging is O(N)      This avoids problem of memory being less than the amount of data to be processed.       Reduce Phase:- we can do similar thing, where merge is done for all the data received by the map phase.(if you understand hadoop implementation) . Every reducer is guaranteed to receive data from the same key.  I have done a implementation ,assuming i dont end up in data being handled is larger than the memory. Quite a simple framework which illustrates the DC. Check out this tinyurl {dot} com/bvwtm3f"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=9332640","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"28","title":"Really like the linear solution of this problem. You have an array of 0s and 1s and you want to output all the intervals (i, j) where the number of 0s and numbers of 1s are equal.  Example  pos = 0  1  2  3  4  5  6  7  8           0  1  0  0  1  1  1  1  0  One interval is (0, 1) because there the number of 0 and 1 are equal. There are many other intervals, find all of them in linear time.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"A possible solution. 1. Convert the array such that arr[i]=(number of zeros-number of ones) in original arr [0]to arr[i]...can be done in O(n) 2. Now, find all the indexes pairs (m,n), m3. Convert back the array to original form...again can be done in O(n).  The main problem here is to do step 2 in O(n). One thing we can do is to hash the modified array with element as the key and index as the value. But, again corresponding to one element there can be different indexes in the hash. So,if we find that element again, we will have to pair up its index with all the indexes (index+1) in the hash corresponding to that element. I am not sure if its gonna be O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Step-1: Convert all 0 to -1 (to simplify understanding) step-2: Keep total of all elements values and put that in hashtable. For exa:  10111000110011 => 1-1111-1-1-111-1-111 Now Keep Sum all the time. 10123210121012  Also put index of sum array in hash. i.e. insert_hash(1,0), insert_hash(0,1), insert_hash(1,2), insert_hash(2,3) and so on..  Now, Each sum can map to sum-1 to its right and each sum can map to sum+1 to its left.  For exa: 1 can map with all 0s to its right. Any 2 will map to all 3s to its left  Any 3 will map to all 2s to its right and all 4s to its left.  Processing time O(N) Extra space: O(N) in hash table"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I think there is no linear time alg, since in the worst case, there are sum(i) = n(n+1)/2 -1 combinations"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Are you sure if it is possible in linear time?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Yeah..exactly, the 2nd step requires forming all the index pairs, which would take a complexity of O(num_pairs)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Take two Counters  for 0 (ZCtr) and 1 (OCtr) set to 0. If index [0] has 0, Initiate with ZCtr else OCtr,  For example start with 0. Increment the counter till \"1\" found. Switch the counter to OCtr. Increment till \"0\" found. Compare two counter If Match : First Pattern found Reset both counter to 0. If not Reset ZCtr. Do till array ends.  Hope it works :-)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There is no linear solution as there are O(n^2) intervals from an array of length N as all 0s and 1s must be consecutive. For each interval, determine if 0s == 1s (let's calls isEqual(int i, int j)) takes O(k) where k is the size of the interval. Hence, there are O(n^3). Observations: 1. Let??s replace 0s with -1(thank you Jack), we can see that for a given interval I(i,j):  a) if sum(I(i,j)) < 0 there are 0s > 1s  b) if sum(I(i,j)) > 0 there are 1s > 0s c) if sum(I(i,j)) == 0 there are 0s == 1s  2. an interval I(i,j) has equal number of 0s and 1s if I(i+1,j-1):  d) sum(I(i+1,j-1)) == 0 and a[i] != a[j] or e) sum(I(i+1,j-1)) == -2 and a[i] == a[j] == 1 or f) sum(I(i+1,j-1)) == -2 and a[i] == a[j] == 0.  3. an interval I(i,i+1) is you-know-what if a[i] != a[i+1] --> base case  So we can reduce complexity of isEqual(int i, int j) to O(1) using dynamic programming.  1 First build an NxN matrix then fill all base cases I(i,i) diagonally. 2. do the following procedure  For (k=2;k For (i=0;i<=N-k) do   I(i,j) = a[i] + a[j] + I(i+1,j-1) // j = i+k-1   If I(i,j) == 0 then print interval  End End"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There is no linear solution as there are O(n^2) intervals from an array of length N  \nas all 0s and 1s must be consecutive. For each interval, determine if 0s == 1s  \n(let's calls isEqual(int i, int j)) takes O(k) where k is the size of the interval. \nHence, there are O(n^3). \nObservations: \n1. Let??s replace 0s with -1(thank you Jack), we can see that for a given interval I(i,j):  \na) if sum(I(i,j)) < 0 there are 0s > 1s  \nb) if sum(I(i,j)) > 0 there are 1s > 0s \nc) if sum(I(i,j)) == 0 there are 0s == 1s \n2. an interval I(i,j) has equal number of 0s and 1s if I(i+1,j-1):  \nd) sum(I(i+1,j-1)) == 0 and a[i] != a[j] or \ne) sum(I(i+1,j-1)) == -2 and a[i] == a[j] == 1 or \nf) sum(I(i+1,j-1)) ==  2 and a[i] == a[j] == 0. \n3. an interval I(i,i+1) is you-know-what if a[i] != a[i+1] --> base case \n \nSo we can reduce complexity of isEqual(int i, int j) to O(1) using dynamic programming. \n \n1 First build an NxN matrix then fill all base cases I(i,i) diagonally. \n2.Do the following procedure \n \nFor (k=2;k"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hhhhhh"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can count them in O(N), but not output them..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can just keep a vector of size 2n+1 (-n to +n) which keeps the positions of original array Where Vector position i specifies that from travelling from beginning of array to some  positions difference between number of 0's and 1's will be i now let this V(k) has position p,q,r so one of the possible solution will (p+1,q),(q+1,r),(p+1,r)  Also add  -1 at the 0th postns of vector as we are taking something like (p+1,r) kind of thing All the finding will be O(n) Yeah but displaying sets is just a iterative thing for me its O(n^2) If someone can suggest a better method please"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There is actually a O(N) algorithm. Suppose the input is data[1...n]. We make a new array which is called count[1...n]. count[i] means the amount difference between 0s and 1s for data[1...i]. If (i,j) is a interval in which the number of 0s and 1s are the same, then count[i]=count[j]. So we just apply radix sort to sort count[1...n] and to find all the identical values in count[1...n].  Radix sort is O(N)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int[] arrs = {0,0,1,0,0,1,1,1,1,0}; //prepend a zero to the array \n  int i = 0; \n  HashMap> hm = new HashMap>(); \n  Stack stk; \n  stk = new Stack(); \n  stk.push(0); \n  hm.put(0, stk); \n   \n  for(i = 1; i(); \n    hm.put(arrs[i], stk); \n   }else \n   { \n    stk = hm.get(arrs[i]); \n   } \n   stk.push(i); // in fact, we can push the item in an increasing order \n  } \n  for(i = 1; i < arrs.length; i++) \n  { \n   stk = hm.get(arrs[i]); \n   for(Integer x : stk) \n   { \n    if(x < i) \n    { \n     System.out.println( \"( \" + x + \" , \" + (i-1) + \" )\" ); \n    } \n   } \n    \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"They are hard coded values... but I ran this in Visual C++ and it is correct, but like everyone else it still runs at worst O(n^2) I don't get how you can can get all possible sets in just one pass, without looping through the previous values to check for new sets"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n*(n-1)) = O(n^2) solution in C#:          static void GetIntervals()         {             int[] array = {0,0,1,0,0,1,1,1,1,0}; //prepend a zero to the array              for (int x=0; x                if (array[x]==0) array[x]=-1;              for (int i = 0; i < array.Length - 1; i++)             {                 int sum=array[i];                  for (int j = i+1; j < array.Length; j++)                 {                     sum += array[j];                     if (sum == 0)                         Console.WriteLine(\"({0}, {1})\", i, j);                 }             }         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"* create a count array. Which starts with counting 1 or 0 till that point."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"01010101010101 -> n-1 intervals with 2 entries 01010101010101 -> n-3 intervals with 4 entries 01010101010101 -> n-5 intervals with 6 entries ... 01010101010101 -> n-1-2k intervals with 2k entries  implies that there are O(n^2) intervals with balanced 0 and 1... (Gauss sum) implies that there is no linear solution to this problem!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"keep 2 index say start and end. Initialize both to 0. Keep a counter (number of extra ones)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* An efficient program to print subarray with sum as given sum */ \n#include \n  \n/* Returns true if the there is a subarray of arr[] with sum equal to 'sum' \n   otherwise returns false.  Also, prints the result */ \nint subArraySum(int arr[], int n, int sum) \n{ \n    /* Initialize curr_sum as value of first element \n       and starting point as 0 */ \n    int curr_sum = arr[0], start = 0, i,max=0; \n  \n    /* Add elements one by one to curr_sum and if the curr_sum exceeds the \n       sum, then remove starting element */ \n    for (i = 1; i <= n; i++) \n    { \n        // If curr_sum exceeds the sum, then remove the starting elements \n        while (curr_sum > sum && start < i-1) \n        { \n            curr_sum = curr_sum - arr[start]; \n            start++; \n        } \n  \n        // If curr_sum becomes equal to sum, then return true \n        if (curr_sum == sum) \n        { \n            printf (\"Sum found between indexes %d and %d\\n\", start, i-1); \n     //if(i-start>max) \n  //max=i-start; \n        } \n  \n        // Add this element to curr_sum \n        if (i < n) \n          curr_sum = curr_sum + arr[i]; \n    } \n  return max; \n} \n  \n// Driver program to test above function \n \nint main() \n{ \n    int arr[] = {-1,1,-1,-1,1,1,1,1,-1}; \n    int n = sizeof(arr)/sizeof(arr[0]); \n    int sum = 0; \n subArraySum(arr, n, sum); \n    return 0; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=9333969","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"10","title":"A tree is serialized in such a way that all the leaves are market with L and all the other nodes with N. The tree is serialized keeping the order derived by a pre-order traversal. Write an algorithm for reconstructing the tree. Also, suggest a methodology for improving the serialization.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"is it possible? A B CD and A BD C preorder and marks are all the same: (A,N)(B,N)(C,L)(D,L)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what if introducing left and right extra characters (denoting null) for leaf nodes?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node* formtree(char *preorder, int &num) \n{ \n   if(preorder[num]=='\\0') return NULL; \n   Node *t=new Node(); \n   if(preorder[num++]=='L') \n   { \n      t->left=t->right=NULL; \n   } \n   else \n   { \n      t->left=formtree(preorder,num); \n      t->right=formtree(preorder,num); \n   } \n   return t; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"its the other way to ask the same question in which given the preorder of tree & construct the tree with preorder..isn't it you may wants to look @ this & can modify if need to achieve answer  http dot shashank7s dot blogspot dot com/2011/03/special-type-of-tree-is-given-where-all dot html  correct me if anything wrong"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If we assume that tree nodes either have 0 or 2 nodes, then the tree constructed should be unique. Build the tree in recursion just like a preorder traverse."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=9337669","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"11","title":"Find top log(n) or top sqt(n) values in an array of integers in less than linear time.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"I think \"less than linear time\" is not correct term in this case.  I think they mean that such a raising function like log(x) or sqt(n) doesn't require to make calculations for each element in the array. You should simply find the largest element in the array and only then calculate the function."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"FB wants chuck norris!!!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"IS it possible to find even in linear time. The best I can think of maintaining a min heap of size K, where K= log(n) or sqrt(n) Even in this case complexity is O(n*log(K))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I don't think it is feasible because without traversing the integers(i.e, in linear time) how can you resort to a judgement regarding the top values?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is possible only when... 1. Array is sorted. We can find out the intervals like top(sqrt(26)) and top(sqrt(36)) is 6 and so on. keep jumping in the array 2 elements at a time or more according to your assumption... compare with apex values of interval..."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=9333968","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"30","title":"Given an array A of positive integers. Convert it to a sorted array with minimum cost. The only valid operation are: 1) Decrement with cost = 1 2) Delete an element completely from the array with cost = value of element","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I have a O(n^2) solution to it. Though I guess that it can be improved to O(nlogn) somehow, I did not figure it out. My method is DP. For your testing purpose, I copy the whole code to here. I will very briefly explain the logic later."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"The idea is: to compute cost_arr[i], you need to know all potential contributors. I will give a example. 7 2 5 2 8 3 1 6. To compute cost_arr[7] (for 6), we nee to know these numbers: 5 3 1. These numbers are computed in this way: Eliminate all numbers greater than 6 before 6. we get: 2 5 2 3 1. Then from RIGHT to LEFT, find the increasing sequence: 5 3 1 That's it. cost_arr[indexof(6)] = min { cost_arr[indexof(1)]  + cost_between(indexof(1), indexof(6)) , cost_arr[indexof(3)]  + cost_between(indexof(3), indexof(6)) ,  cost_arr[indexof(5)]  + cost_between(indexof(5), indexof(6))  } Whats the final answer. Still using 7 2 5 2 8 3 1 6. The final answer is  from cost_arr value at these numbers: 8 6 These numbers are computed in this way: Find from the very RIGHT the increasing sequence: 8 6 final_ans = min{cost_arr[indexof(8)] , cost_arr[indexof(6)]} It is equivalent to compute cost_arr[last_index] for this sequence: 7 2 5 2 8 3 1 6 INFINITY  That's how it works. I do not want to try to prove its correctness, but we can see its correctness through how it works."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the greedy strategy will work here. Iterate from left to right. For an element at index i, if there's an element at index j(j>i) with value(j) Worst case running time O(n^2)  Segment tree can reduce this to O(nlgn)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"*correct the statment value(i) = value(j) as value(i) = min(value(j)) for all j>i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Wait I think I got it"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"OK..I used all that stack and queue trying to do  O(n) solution but couldn't,  Here is O(n^2) solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{3,2,4,1}  Start with 1, since there is no element smaller in right of it, nothing to do. Start with 4"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@XYZ the solution you posted uses greedy ans is incorrect. Try it on {5, 3, 5, 3}. The correct way to solve this is DP."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Any help using Longest Increasing subsequence and then pointing those elements which are not in that LIS and then either: 1. decrement the to a value equal to their leftside or rightside? 2. delete it which ever is minimal?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Check out the DP solution given here. Seems correct to me. shashank7s. blogspot. com/2011/05/ wap-to-find-minimum-value-in-window-of . html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I got an DP in N^2... It is easy to notice that your maximum value of the solution will be A[i] where 'i' is an index from 0 to n-1; You DP[i][j] must says the minimum cost considering the solution till n, where the maximum value has the same value of the index[j]; And j >= i So: if A[i] <= A[j]:  then     DP[i][j] = min(A[i]+ DP[i-1][j], DP[i-1][i]); else      DP[i][j] = A[i]-A[j] + DP[i-1][j]; When A[i] <= A[j] you need to notice that you can continue with A[i] at your solution, or you can erase A[i] and then maybe it will be good for you..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It has a greedy approach. Suppose you have sorted till i, you can add ith element by either deleting it or making the first i-1 element ai - (i-1),ai-(i-2) and so on."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use DP. The following expression seems to work:  A is the input array. OPT[i] is the optimal cost to generate a sorted array after having looked at the array elements from 0 to i."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"DP problem. can be solved in O(n*n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"longest increasing sequence. By dp in quadratic time"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be solved in )(n) using DP and additional memory. sum[0] = a[0]; numElements[0] = 1; OPT[0] = 0; for ( i = 1; i < n ; i++ ) {  if ( a[i] < a[i-1]) {    m1 = OPT[i-1] + a[i]; // delete current element;   m2 = sum[i] - numElem[i-1]*a[i]; // This is the amount we need to delete on all previous elements to be in sorted order;   if ( m1 < m2) {       OPT[i] = OPT[i-1] + m1;       numElements[i] = numElements[i-1];   } else {      OPT[i] = m2;      numElements[i] = numElements[i-1] + 1;    } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I will go with the following strategy O(n)."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=9097380","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"32","title":"Given a list of n objects, write a function that outputs the minimum set of numbers that sum to at least K. (better than NLOGN)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I think you can solve this in expected O(n), with the same method that u can find the k-th  order statistics, which uses the Quicksort preprocessing method."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Assuming the minimal subset contains m numbers. We can do:  1. put all numbers in an array and compute the total sum along the way - O(n). 2. heapify the array (use min heap) - O(n) 3. start removing min from root as long as the total sum is still >= k - O((n-m)*logn)  Above will work well if m is close to n, i.e. it takes most of the numbers to sum up to k.   If it's the opposite case, i.e. it only takes few numbers to sum up to k, then we can try a different approach:  1. insert array elements into min heap until the sum of heap is >=k. 2. remove min from root as long as remaining sum is >=k. 3. scan the remaining array elements. If bigger than heap root than add it to the heap. 4. repeat step 2.  Above will take O(n*logm) where m is heap size. Since the assumption is that m is small, it'll be better than O(n*logn)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using  Direct Hashing it can be done in O(n)..let me know if more clarification needed..??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bucket sort"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) sort the list 2) start from the end of the list and keep inserting the elements in the set until the sum is alteast K....i guess this is the greedy approach  O(nlogn)  may be use count sort to sort the list in O(n)..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Max heap can be used here. If m is the minimum number of elements (from given n) that sums up atleast k, then the complexity would be O(m logn). In worst case it could be O(n logn)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my code, which uses Radix sort. It runs in O(logbase2(k) * n) which for most values of n and k is better than n*log(n). I don't think it's possible to guarantee performance better than n*log(n) for all values of n and k."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think we can use max heap to grab the m elements and thus it is O(m*logn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Take first m numbers and find sort them find sum if sum is less than k then add next number and delete the smallest number till you find sum as k if sum is not k then add numbers in reverse order as deleted till you find sum k this will take O(mlogm)+O(n-m) for optimization m is calculated on value of n given"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be done using partial quick sort technique.  1. Take k as the pivot element and parse the array, if there is atleast 1 element greater than k return that element. If not, go to 2,  2. Now take k/2 as pivot and parse the array, if there are atleast 2 elements greater than k/2 return those elements. Here, the output could be 0 elements greater than k/2, 1 element greater than k/2 if that is the case in the next step update no_of elements_required accordingly.  .....if we continue doing that, at the log(n) step, we will have k/2^(logn) expecting n elements if we don't get then we are done.  So the complexity is there are log(n) passes and every time we parse <= n elements. so the over all complexity is <= O(nlog(n))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be done using partial quick sort technique.  1. Take k as the pivot element and parse the array, if there is atleast 1 element greater than k return that element. If not, go to 2,  2. Now take k/2 as pivot and parse the array, if there are atleast 2 elements greater than k/2 return those elements. Here, the output could be 0 elements greater than k/2, 1 element greater than k/2 if that is the case in the next step update no_of elements_required accordingly.  .....if we continue doing that, at the log(n) step, we will have k/2^(logn) expecting n elements if we don't get then we are done.  So the complexity is there are log(n) passes and every time we parse <= n elements. so the over all complexity is <= O(nlog(n))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assume you know the linear algorithm for finding the median. 1. Find the median M. 2. Partition the array such  that the first half is smaller than M, and the second half is larger than M. 3. Compute the sum S of the elements in the second half. 4. If S < K, recurse on the first half to find the smallest set whose sum is larger than K - S. If S > K, recurse on the second half. If S == K, you find the solution."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=9125830","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"10","title":"Sort 1TB file on machine with 1GB RAM.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"load 1Gb file content onto the main memory...sort it using inplace heap sort...write the sorted data in a temporary file....do this for all 1000 chunks and then merge these files"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"two way external sort."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"external sorting"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"D&C shud work...obviously merge sort"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Geek joke: Assuming we are sorting Int32's, and having whole 1GB for allocation (program is running 'elsewhere'), allocate 1GB array (0-2^32-1) and use RadixSort. Linear complexity 8)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=9122832","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"9","title":"Implement function to find needle from a haystack. Interviewer was looking for coding skills.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"while (!haystack.empty()) { if (haystack.element() == needle) return true; else haystack.removeElement(); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"lol...haystack aint hay+Data structure wala stack.its haystack!!!! first of all the above solution is wrong as its O(n) and n=millions in a Haystack.  Possible tools used: a very precise weighing machine that can weigh a needle and a hay.  Logic: 1.Divide the haystack in half by weight 2.Search for needle in the heavier one.  Algo:binary search Possible test for needle: wieght or magnet"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assume each needle is unique there can be many way to think about it like haystack can array of needles or linked list of nodes then 2nd thing is that on the basic of what criteria we will find the needle is that size or type/colour etc..  then if needle are unsorted then we can sort the needle on the basis of size & then search using binary search so time O(nlogn) in case of linked list we will use merge sort thats also has O(nlogn) where n is size of haystack  else if array or linked are sorted then we can find the needle in O(logn) in array & O(n) in linked list  else as its the grayStack so put all the needles into stack & retrieve one by one until retrieve needle is not equals to given needle we checking the needle here based on some type /name/ranking/etc on the basis of which we can compare the needle with others.  while (!haystack.empty()) { if (haystack.element() == needle) return true; else haystack.removeElement(); }  it can also be done in O(n)  Correct me if anything wrong"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"rajcools if you are not satisfied with above answer you may like it using KMP Algorithm  basically we have to Write a program that finds all occurences of a given pattern in a given input string. This is often referred to as finding a needle in a haystack.  The algorithm has to detect all occurences of the needle in the haystack. It should take the needle and the haystack as input, and output the positions of each occurence, as shown below. The suggested implementation is the KMP algorithm, as, a naive approach will probably exceed the time limit, whereas other algorithms are more complicated...e.g Rabin Karp so The choice is yours.  so if we do pattern matching using KMP algorithm we can find the needle inn O(m+n) n=length of haystack m=length of needle  also it depends on how one understand the question & how one approach as i am sure this problem can be solved by many ways but i think KMP is best Suitable for this.  I provide the efficient solution let me know if better one exist  Shashank"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Knuth Moris Pratt Algorithm"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"OMG! Boyer Moore is the only one :D hehe"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=8659794","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"12","title":"What is the time and space complexity of Fibonacci series recursive function.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Why dont you people try recursion as dynamic programming and make it linear :D"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"space is exponential too, I think. the recursion uses exponential stacks."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why dont you people try recursion as dynamic programming and make it linear :D"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Linear time and constant for storage.  fibonacci(n) {     int x2 = 0;     int x1 = 1;     int x;      if (n == 0) return 0;      for(int i = 2; i     {         x = x2 + x1;         x2 = x1;         x1 = x;     }  return x2+x1; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"wat nonsense methods u people hav put up, seriously..!!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Time complexity is O(n) space complexity: total space used by all,recursive calls : O(n) fibo(1) and fibo(0) is base case fibo(3)= fibo(2)+fibo(1) -->2 calls we need space for local variables and function arguments, but also some space for remembering where each call should return to.The argument at each node in the path is ONE(1) or TWO(2) units smaller than the argument at its PARENT(3). The length of any such path can be at most n, so the space needed by the recursive algorithm is again (some constant factor times) n."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=8674807","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"16","title":"Efficient way to count number of 1s in the binary representation of a number. How can you do it in O(1) if you have enough memory to play with.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"only count the number of one."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is always constant time. Your number can have at most as many bits as the architecture allows. It is not dependent upon how big or small the number is."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include    int main(){  int x=65536; x = (x & 0x55555555) + ((x >> 1) & 0x55555555);    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);    x = (x & 0x0F0F0F0F) + ((x >> 4) & 0x0F0F0F0F);    x = (x & 0x00FF00FF) + ((x >> 8) & 0x00FF00FF);    x = (x & 0x0000FFFF) + ((x >>16) & 0x0000FFFF);  printf(\"%d\",x); }  this is O(1) I think.  Since we got enough space.  int a [32]={1,1,1.....32 1's}; no_bits=n&a[0]+n&a[1]+......n&a[31]; return no_bits;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There is no limit on memory. So just use a array map for each possibility."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why not be keep a table of size 2^8. Each entry in table will hold number of bits in the number with number as the index into the table entry. Solution then will be like this --> Each number is composed of consecutive bytes, say 4 bytes.  1) Get the size of memory location holding the number. 2) right shift 8 bits from the number and store them in a variable, say X 3) update the number with right shifted value or use another variable to store updated value, say Y 4) index into the table of size 2^ 8 using X. 5) Repeat step step 2 to 4 using Y.  Now the size of a number is constant (even if it is machine dependent). So run time of this algorithm will be O(1)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In C# (this is the simplest solution but not O(1)):          public static int CountOnes(int value)         {             int counter = 0;             byte b = 1;              while (value>0)             {                 if ((value & b) == b)                     counter++;                 value = value >> b;             }             return counter;         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O (lg n) where is n = 32 for 32-bit integer.  For loop, other are discussing is O(n).  Hash table is surely is O(1), but it unfeasible for  4 billions values.  lg n solution for 64-bit number will take lg n = lg 64 = 6 arithmatics  (does not justify 2^64 hash entries)."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=8674806","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"21","title":"Re-arrange an array containing only 0s,1s and 2s, so that all 1s follow all 0s and all 2s follow 1s. e.g. 00000011111111222222.  Linear time algorithm.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"#include  \n \nvoid print_array(int arr[], int cnt, const char* hdr) \n{ \n    printf(\"%s\\n\", hdr); \n    for (int i = 0; i < cnt; i++){ \n        printf(\"%d \", arr[i]); \n    } \n    printf(\"\\n\"); \n} \n \nvoid rearrange(int arr[], int cnt) \n{ \n    int cn[3] = {0}; \n    int k = 0; \n \n    /* Count the number of integers */ \n    for (int i = 0; i < cnt; i++){ \n        cn[arr[i]]++; \n    } \n    \n    print_array(arr, cnt, \"Array before:\"); \n \n    /* Now fill back the array with the count of consecutive ints */ \n    for (int i = 0; i < 3; i++){ \n        for (int j = 0; j < cn[i]; j++) { \n            arr[k] = i; \n            k++; \n        } \n    } \n \n    print_array(arr, cnt, \"Array after:\"); \n \n    return; \n} \n \n/* \n  Re-arrange an array containing only 0s,1s and 2s,  \n  so that all 1s follow all 0s and all 2s follow 1s.  \n  e.g. 00000011111111222222. Linear time algorithm. \n*/ \nint main(int argc, char *argv[]) \n{ \n    int arr[] = {0,0,0,0,2,1,2,0,2,1,2,1,2,0,1,0,1,0,2,0,1}; \n    int cnt = sizeof(arr)/sizeof(arr[0]); \n \n    rearrange(arr, cnt); \n    return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"int [] arr = {0,0,0,0,2,1,2,0,2,1,2,1,2,0,1,0,1,0,2,0,1}; \nint pointer1 = 0,pointer2 = arr.length - 1; \nfor(int i = 0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* My algorithm: 1. iterate thru array and count number of 0,1,2 2. based on the counts update the new array as we know the elements in the array are just 0,1,2 using this peice of information form the solution.  */ public class ArrangeInOrder {            public static void main(String args[])  {   int[] inputArray={0,1,2,0,1,2,2,2,2,1,0,0,0,0};   System.out.println(\"Initial array is: \");   display(inputArray);   inputArray=Rearrange(inputArray);   System.out.println(\"ordered array is: \");   display(inputArray);  }   private static void display(int[] inputArray) {   for(int ii=0;ii  {   System.out.println(inputArray[ii]);   }     }   private static int[] Rearrange(int[] inputArray) {   int countZeros=0;   int countOnes=0;   int countTwos=0;   int i= 0;   int j= 0;   int k=0;      for(int ii=0;ii  {    if(inputArray[ii] ==0)    {     countZeros++;    }    if(inputArray[ii] ==1)    {     countOnes++;    }    if(inputArray[ii] ==2)    {     countTwos++;    }   }   System.out.println(\"zero =\" +countZeros + \" and ones: \"+countOnes+ \" and two's: \"+countTwos);      for(i=0;i  {    inputArray[i]=0;    System.out.println(\"entering at location: \"+i +\" value= 0\");   }   System.out.println(\"i is-----: \"+i);   for(j=i;j  {    inputArray[j]=1;    System.out.println(\"entering at location: \"+j +\" value= 1\");   }   System.out.println(\"j is-----: \"+j);   for(k=j;k  {    System.out.println(\"entering at location: \"+k +\" value= 2\");    inputArray[k]=2;   }   System.out.println(\"k is-----: \"+k);   return inputArray;  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is so called Dutch_national_flag_problem and it has a linear and clear solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a special case of quick sort, which can be done efficiently in-place and by going through the array only once.   void rearrange(int *arr, int size) {   if (NULL == arr || size <= 0) return;    int head = 0;   int tail = size-1;   int idx  = 0;    while (idx <= tail) {     if (arr[idx] == 0) {       arr[head++] = 0;       arr[idx++]  = 1;      } else if (arr[idx] == 1)       idx++;     else       swap(arr+(tail--), arr+idx);   } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"dutch national flag problem....use three pointers...solvable in linear time"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use counting sort. Requires extra space for array of size 3 for this problem, or the range of numbers in the list. e.g. if numbers are 4,3,4,5,6,2,2,2,7,3 then range is (7-2) + 1 = 6."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi Geeks Visit My Blog  shashank7s dot blogspot dot com/2011/04/wap-to-given-doubly-linked-list-with dot html  or type query on google \"cracking the code shashank\" to visit"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Count the number of 0s, 1s and 2s. Then print as many 0s out, then 1s, then 2s."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void arrange(int a[],int size) { int n1=0,n2=0,n3=0; for(i=0;i{ if(i==0) n1++; else if(i==1) n2++; else n3++; } for(i=0;i{ if(ia[i]=0; else if(i>=n1 && ia[i]=1; else a[i]=2; } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Come on just count all 0s, 1s and 2s in linear time and recreate the array :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static int[] arranger(int []A){   int num0 = 0;    int num1 = 0;       for (int el:A){    if (el==0)     num0++;    else if (el == 1)     num1++;   }    for (int i=0; i   if (i+1<=num0){     A[i] = 0;    }    else if(i+1<= (num0+num1))     A[i] = 1;    else     A[i] =2 ;    }   return A;   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void dutchFlag(int[] array) \n    { \n int start = 0; \n int end = array.length - 1; \n \n int cursor = start; \n \n while (cursor < end) \n { \n     int current = array[cursor]; \n \n     if (current == 1) \n     { \n  swap(array, cursor, start); \n  start++; \n  cursor++; \n     } \n     else if (current == 3) \n     { \n  swap(array, cursor, end); \n  end--; \n     } \n     else \n     { \n  cursor++; \n     } \n } \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void Sort(std::vector & vec) { \n  int b = 0; \n  int e = v.size() - 1; \n  int k = -1; \n  while (b <= e) { \n    if (v[b] == 0 && b != k +1) { \n      std::swap(v[b], v[++k]); \n    } else if (v[b] == 2 && b != e) { \n      std::swap(v[b], v[e--]); \n    } else b++; \n  } \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=8656028","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"6","title":"Clone a connected undirected graph. Input is a node*. Return the node* of the cloned graph.  struct node {  int value;  vector neighbors;   }","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"by doing a bfs starting at given node we can visit all nodes, each time an new node is discovered (until the termination of bfs), create a new node copying its value, however leaving neightbors field null. create a hashtable mapping address of the old node to newly created node. now its just a matter of translation and returning the address (translated from old) of the new root."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Node     {         public int Value { get; set; }         public List Neighbors { get; set; }          public Node(int value)         {             this.Value = value;         }     }      public static Node CloneGraph(Node srcGraph)     {         if (srcGraph == null)         {             return null;         }          Dictionary srcToDestNodeMapping = new Dictionary();          Node destGraph = DfsCreateDestNodes(srcGraph, srcToDestNodeMapping);          foreach (Node srcNode in srcToDestNodeMapping.Keys)         {             foreach (Node neighbor in srcNode.Neighbors)             {                 srcToDestNodeMapping[srcNode].Neighbors.Add(srcToDestNodeMapping[neighbor]);             }         }          return destGraph;     }      private static Node DfsCreateDestNodes(Node srcNode, Dictionary srcToDestNodeMapping)     {         if (srcToDestNodeMapping.ContainsKey(srcNode))         {             return null;         }          Node destNode = new Node(srcNode.Value);         destNode.Neighbors = new List();          srcToDestNodeMapping.Add(srcNode, destNode);          foreach (Node n in srcNode.Neighbors)         {             DfsCreateDestNodes(n, srcToDestNodeMapping);         }          return destNode;     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Node \n    { \n        public int Value { get; set; } \n        public List Neighbors { get; set; } \n \n        public Node(int value) \n        { \n            this.Value = value; \n        } \n    } \n \n    public static Node CloneGraph(Node srcGraph) \n    { \n        if (srcGraph == null) \n        { \n            return null; \n        } \n \n        Dictionary srcToDestNodeMapping = new Dictionary(); \n \n        Node destGraph = DfsCreateDestNodes(srcGraph, srcToDestNodeMapping); \n \n        foreach (Node srcNode in srcToDestNodeMapping.Keys) \n        { \n            foreach (Node neighbor in srcNode.Neighbors) \n            { \n                srcToDestNodeMapping[srcNode].Neighbors.Add(srcToDestNodeMapping[neighbor]); \n            } \n        } \n \n        return destGraph; \n    } \n \n    private static Node DfsCreateDestNodes(Node srcNode, Dictionary srcToDestNodeMapping) \n    { \n        if (srcToDestNodeMapping.ContainsKey(srcNode)) \n        { \n            return null; \n        } \n \n        Node destNode = new Node(srcNode.Value); \n        destNode.Neighbors = new List(); \n \n        srcToDestNodeMapping.Add(srcNode, destNode); \n \n        foreach (Node n in srcNode.Neighbors) \n        { \n            DfsCreateDestNodes(n, srcToDestNodeMapping); \n        } \n \n        return destNode; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"void clone(struct node* root) { if(p == NULL) retutn ; struct node *p = (struct node *)malloc(sizeof(struct node)); p->left = clone(root->right); p->right = clone(root->left); }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=8684808","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"6","title":"Implement strstr function without using any library functions.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"The Knuth-Morris-Pratt or the Morris-Pratt algorithms are extensions of the basic Brute Force algorithm. They use precomputed data to skip forward not by 1 character, but by as many as possible for the search to succeed.  Here is some code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"rabinkarp string searching algorithm  or use suffix trees....could be build in O(n) and searched using O(m) n =length of base string m=length of pattern to be searched"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use boyer-moore its more effiecient than all string patter matching"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I don't think it is a good interview question."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int MyStrStr(char * a,char * b) \n{ \n    int a_p = 0; \n    int b_p = 0; \n    int ret = -1; \n    if(a == NULL || b == NULL) \n        return -1; \n    while(true) \n    { \n        if(a[a_p] == '\\0') \n            break; \n        if(a[a_p] == b[0]) \n        { \n            ret = a_p; \n            b_p = 0; \n            //start check \n            while(true) \n            { \n                if(b[b_p] == '\\0') \n                    break; \n                if(a[a_p+b_p] != b[b_p]) \n                { \n                    return -1; \n                } \n                b_p++; \n            } \n        } \n        a_p++; \n    } \n    return ret; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"char * strstr(const char *s1, const char *s2) { \n    const char *a = s1, *b = s2; \n    for (;;) { \n        if (!*b) return (char *)s1; \n        if (!*a) return NULL; \n        if (*a++ == *b++) continue; \n        a = ++s1; \n        b = s2; \n    } \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=8659793","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"13","title":"Count words in a sentence. Words can be separated by more than one space.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"public class CountWords { \n \n public static void main(String[] args) { \n  String str = \"  an b  c   d\"; \n  //String str = \" c        d\"; \n  System.out.println(\"String: \" + str); \n  System.out.println(\"Word Count: \" + countWords(str)); \n } \n  \n public static int countWords(String string) { \n  if (null == string) { return -1; } \n   \n  int count = 0; \n  int len = string.length(); \n    \n  char lastChar = string.charAt(0); \n  for (int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"If previous one is a 'space' and current character is not a space then increase the word count."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class CountWordInSentence {    public static void main(String args[])  {   String sentence=\"Hello World        is                 beautiful          \";   int count= countWords(sentence);   count=count+1;   System.out.println(\"Total words: \"+count);  }   private static int countWords(String sentence) {    int wordCount=0;   for(int i=0;i  {    if(i==sentence.length()-1 &&(sentence.charAt(i)==' ' ))    {     System.out.println(\"found space at: \"+i);     break;     //wordCount++;    }    else if(sentence.charAt(i)==' ' && sentence.charAt(i+1)!=' ')     {     System.out.println(\"found space at: \"+i);     wordCount++;    }   }   return wordCount;  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class CountWordInSentence {   public static void main(String args[]){   String sentence1=\" Hello World is beautiful   \";   String sentence=\"Hello \";   System.out.println(sentence+\"\\nTotal words: \"+countWords(sentence));  }   private static int countWords(String sentence) {   int wordCount=0;   if (sentence == null) return wordCount;   for(int i=1;i   if(sentence.charAt(i-1) == ' ' && sentence.charAt(i) != ' ')      wordCount++;   }   if(sentence.charAt(0)!= ' ') wordCount++;  return wordCount;  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class countwords{  string m_str;  void trim()  {   size_t len = m_str.length();   if(len != 0)   {    size_t count= 0;    size_t b = m_str.find_first_of(\" \"), e = m_str.find_last_of(\" \");    while( (b= m_str.find_first_of(\" \",b)) == 0)     m_str = m_str.substr(b+1,len);    len = m_str.length();    while( (e= m_str.find_last_of(\" \",e)) == len-1){     m_str = m_str.substr(0,e);     len =m_str.length();     }       }  } public :  countwords(string &str)  {   m_str = str;  } countwords()  {     } int count(){  trim();  size_t br =0;   int count =0;  while((br = m_str.find(\" \",br))!= string::npos)  {   count++;   br++;   while(m_str[br] == ' ')    br++;     }  return count+1; } };  void main() {  string str(\"    abcd efgh ijkl   \"); countwords cn(str); std::cout<getchar(); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include   using namespace std;  int count(string a) {  int n = 0;  for(int i = 1; i <= a.length(); i++)  {   if(i == a.length() || a[i] == ' ') {    if(a[i - 1] != ' ') n++;   }  }  return n; }  int main() {  cout << count(\"a     b cc ccccc\") << endl;  cout << count(\"a\") << endl;  cout << count(\"\") << endl; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int wordCount(String s){ \nreturn s.trim().split(\"\\\\s+\").length; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static int wordCount(String s) { \n \n        int i = 0, wordCount = 0; \n        boolean inSpace = true; \n        while(i < s.length()) { \n            char c = s.charAt(i); \n            boolean isBlank = c == ' '; \n            if(inSpace && isBlank) { \n                // do nothing, still in space \n            } else if(inSpace && !isBlank) { \n                wordCount++; // got a new word! wohoo! \n                inSpace = false; \n            } else if(!inSpace && !isBlank) { \n                // mid word, do nothing. \n            } else if(!inSpace && isBlank){ \n                // oh snap, end of word! into space I go! \n                inSpace = true; \n            } \n            i++; \n        } \n        return wordCount; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main (String args[]){   int i = count (\" adfasdf  asidfa  asdfa sa  as\");   System.out.println(i);  }    public static int count (String s){   int count = 0;   boolean inWord = false;   boolean inSpace = true;   for (int i = 0 ; i< s.length (); i++){    if (s.charAt(i) == ' '){     if (inWord){      //count ++;      inWord = false;     }          inSpace = true;         } else {     if (inSpace){      count ++;      inSpace = false;     }     inWord = true;         }       }   return count;     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int CountWordsIn_A_Sentence(char * sentence) \n{ \n    int c = 0; \n    int p = 0; \n    bool w = false; \n    if(sentence == NULL) \n        return -1; \n \n    while(true) \n    { \n        if(sentence[p] == '\\0') \n            break; \n        if(sentence[p] == ' ') \n        { \n            w = false; \n        } \n        else \n        { \n            if(!w) \n                c++; \n            w = true; \n        } \n        p++; \n    } \n    return c; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int countWord(String str) \n    { \n int cursor =0; \n int count =0; \n boolean word = false; \n  \n while (cursor < str.length()) \n { \n     char ch = str.charAt(cursor); \n      \n     if (ch==' ') \n     { \n  if (word == true) \n  { \n      count++; \n  } \n  word = false; \n  cursor++; \n     } \n     else \n     { \n  word = true; \n  cursor++; \n     } \n } \n \n if (word== true) \n { \n     count++; \n } \n  \n return count; \n    }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=8635794","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"18","title":"Print a binary tree in level order with a new line after every level.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Use 2 Queues. When printing nodes from Q1 enqueue their children in Q2 and VICE-VERSA. When Q1 or Q2 becomes empty while printing the node then print a new line."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"We can use BFS to implement this. In BFS nodes at a level are processed before heading on to the next level nodes."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Below is a simple implementation of the level order scan application using a single queue along with the driver program. Also pasting the output."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"// Using only one queue and without any marker. \n \nvoid print(node *root){ \n    queue q; \n     \n    q.push(root); \n    int parent_nodes = 1; \n    int child_nodes = 0; \n    while(!q.empty()){ \n        node *t = q.front(); \n        q.pop(); \n         \n        parent_nodes -= 1; \n        cout<val<<\" \"; \n        if(t->left) { \n            q.push(t->left); \n            child_nodes += 1; \n        } \n        if(t->right) { \n            q.push(t->right); \n            child_nodes += 1; \n        } \n         \n        if(parent_nodes == 0){ \n            cout<<\"\\n\"; \n            parent_nodes = child_nodes; \n            child_nodes = 0; \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using 2 queues...is run time linear???"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using the following code we can print the levels  with using only one queue.  void levelorder(struct node * root) {  struct node * temp = root;   int quesize = 0;  if(root==NULL)   return;  cout<data<<\",\";  while(temp!=NULL)  {   if(temp->left!=NULL)    mynodequeue.push(temp->left);   if(temp->right!=NULL)    mynodequeue.push(temp->right);   if(quesize ==0)   {    quesize = mynodequeue.size();    cout<   //temp1 = NULL;   }        temp = mynodequeue.front();   mynodequeue.pop();   quesize--;      cout<data<<\",\";   //cout<data<<\"(next),\";    if(mynodequeue.empty())   {    temp = NULL;   }     }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1 Queue  void print(Node root){   if(root != null){      LinkedList queue = new LinkedList();   queue.add(root);   int level = 0   queue.add(new Integer(level++));      while(!queue.isEmpty()){       if(queue.peek() instanceof Node){         Node n = (Node)queue.pop();          for(Node child:n.getChildren())      queue.add(child);          System.out.print(\"-\"+n.data+\"-\");         }else{         Integer i = (Integer)queue.pop();          System.out.println(\"-Finished Line: \"+i)         if(!queue.isEmpty())      queue.add(new Integer(level++));    }   }  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think a similar question has been answered elsewhere in this site. The simple approach would be use a dummy node to differentiate between levels."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It's like BFS, but use two Queues to determine the end of each level"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void BinaryTreeNode::PrintTree() {  std::stack s;  BinaryTreeNode *curr;   s.push(this);  s.push(NULL);   while (!s.empty()) {   curr = s.top();   s.pop();   if (curr == NULL) {    printf(\"\\n\");    if (!s.empty()) {     s.push(NULL);    }   } else {    printf(\"%d \", curr->data);    if (curr->left != NULL) s.push(curr->left);    if (curr->right != NULL) s.push(curr->right);   }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void BinaryTreeNode::PrintTree() \n{ \n std::stack s; \n BinaryTreeNode *curr; \n \n s.push(this); \n s.push(NULL); \n \n while (!s.empty()) { \n  curr = s.top(); \n  s.pop(); \n  if (curr == NULL) { \n   printf(\"\\n\"); \n   if (!s.empty()) { \n    s.push(NULL); \n   } \n  } else { \n   printf(\"%d \", curr->data); \n   if (curr->left != NULL) s.push(curr->left); \n   if (curr->right != NULL) s.push(curr->right); \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//C#  \nusing System; \nusing System.Collections; \n \nclass Node \n{ \n    public int value; \n    public Node leftNode; \n    public Node rightNode; \n    public Node(int _value) \n    { \n        value = _value; \n    } \n} \n \nclass BinarySearchTree \n{ \n    Node rootNode; \n    Queue[] printQueue; \n \n    public BinarySearchTree(int _value) \n    { \n        rootNode = new Node(_value); \n    } \n \n    public void add(int _value) \n    { \n        addRec(rootNode, _value); \n        printQueue = new Queue[maxDepth(rootNode)]; \n        for (int i = 0; i < maxDepth(rootNode); i++) \n        { \n            printQueue[i] = new Queue(); \n        } \n    } \n \n    public void addRec(Node _node, int _value) \n    { \n        if (_node == null) return; \n \n        if (_value < _node.value) \n        { \n            addRec(_node.leftNode, _value); \n            if (_node.leftNode == null) \n            { _node.leftNode = new Node(_value); } \n \n        } \n        else if (_value >= _node.value) \n        { \n            addRec(_node.rightNode, _value); \n            if (_node.rightNode == null) \n            { \n                _node.rightNode = new Node(_value); \n            } \n        } \n    } \n \n    public void print() \n    { \n        printQueue[0].Enqueue(rootNode.value); \n        BreadthFirst(rootNode, 1); \n \n        for (int i = 0; i < printQueue.Length; i++) \n        { \n            while (printQueue[i].Count != 0) \n            { \n                Console.Write(printQueue[i].Dequeue()); \n            } \n            Console.WriteLine(); \n        } \n    } \n \n    public void BreadthFirst(Node _node, int _level) \n    { \n        if (_node == null) { return; } \n        if (_node.leftNode != null) \n        { \n            printQueue[_level].Enqueue(_node.leftNode.value); \n        } \n        if (_node.rightNode != null) \n        { \n            printQueue[_level].Enqueue(_node.rightNode.value); \n        } \n        ++_level; \n        BreadthFirst(_node.leftNode, _level); \n        BreadthFirst(_node.rightNode, _level); \n    } \n \n    public int maxDepth(Node root) \n    { \n        if (root == null) { return 0; } \n \n        return 1 + Math.Max(maxDepth(root.leftNode), maxDepth(root.rightNode)); \n    } \n \n} \n \nclass Program \n{ \n    static void Main(string[] args) \n    { \n        BinarySearchTree myTree = new BinarySearchTree(6); \n        myTree.add(4); \n        myTree.add(5); \n        myTree.add(8); \n        myTree.add(2); \n        myTree.add(9); \n        myTree.add(11); \n        myTree.add(10); \n        myTree.print(); \n        Console.Read(); \n    } \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=8279320","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"18","title":"Remove Duplicate slashes  \"/root//foo/bar\"=> \"/root/foo/bar\"  Obviously no extra memory and minimum number of elements moved","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"char* remove(char* str) \n{ \n   char* writer=str,*reader=str; \n   char lastchar='.'; \n   while(*reader) \n   { \n     if(*reader=='/'){ \n        if(lastseen!='/'){ \n          *writer++=*reader; \n          lastseen=*reader; \n        } \n        *reader++; \n      } \n     else{ \n        *writer++=*reader; \n        lastseen=*reader++; \n     }     \n   } \n   *writer='\\0'; \n   return str; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this has to be solved by scripting instead of writing a program. just use a grep and pipeline it to convert it to the desired string."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If you rewrite below code using c-strings you could make space complexity O(1). \n \n \n/** \n  * Time: O(N) \n  * Space: O(1) \n  */ \n public String removeDuplicateSlashes(String str){ \n   \n  if( str == null ){ \n   throw new IllegalArgumentException(\"NULL str passed\"); \n  }   \n   \n  int copyIndexOffset = 0; \n   \n  // Space: O(N) make array copy \n  final char[] arr = str.toCharArray(); \n   \n  boolean previouslySlashFound = false; \n   \n  for( int i = 0; i < arr.length; i++ ){ \n    \n   if( arr[i] ==  '/' ){ \n    if( previouslySlashFound ){ \n     continue; \n    }     \n    previouslySlashFound = true; \n   } \n   else { \n    previouslySlashFound = false; \n   }    \n    \n   arr[copyIndexOffset++] = arr[i]; \n  } \n   \n  // Space: O(N) allocate new array \n  return new String(arr, 0, copyIndexOffset);   \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I agree with XYZ algorithm..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Would a regex solution consume significant amounts of extra memory?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we can use sed command instead of the program or we can use a shell script which is just of 2 or 3 lines"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what about this"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Keep two pointers One to move forward in Input-String characters and another to rewrite the Input-String. we rewrite only if current read char is not slash, if it's slash then check for previous char's being slash. Keep a variable to maintain state, possible states - last-char-slash, last-char-not-slash."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Actually according to the question, only minimum no. of elements need to be moved. But the algorithms mentioned above always move the elements to the right of the current duplicate slash, that is wrong.  For ex: /foo//baaaaaaaaaaaar. Here when we encounter the duplicate slash we are moving the string \"baaaaaaaaaaaar\" to its left, and that is not minimum. Ideally, the string \"/foo/\" needs to be moved to its right."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is an algorithm.  1. First count the total number of non-duplicate elements (non-de-count) 2. Now iterate through the array, whenever we encounter a sequence of duplicate slashes i.e. one or more slashes, calculate the non-duplicate elements to its left and non-duplicate elements to its right. How? the current index will give the no. of non-duplicate elements to its left and non-de-count-current will give the non-duplicate elements to its right. 3. if(non-de-left <= non-de-right){              shift left characters to the right;     }else{               call removeDuplicates(str, currentStart,end);               shift right characters to the left;      }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here is a very simple O(n) algorithm using O(1) space   void rem_dup(char *a) {    int n=strlen(a);    int s=0,e=0;     for(int i=0;i   {      if(a[i]=='/')      {        s=i;        while(a[i]=='/' && i       e=i;        for(int j=s+1;j     }    }     int pos=0;    for(int i=0;i   {      if(a[i]!='\\0')      {        a[pos]=a[i];        pos+=1;      }    }    a[pos]='\\0'; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here is a very simple O(n) algorithm using O(1) space   void rem_dup(char *a) {    int n=strlen(a);    int s=0,e=0;     for(int i=0;i   {      if(a[i]=='/')      {        s=i;        while(a[i]=='/' && i       e=i;        for(int j=s+1;j     }    }     int pos=0;    for(int i=0;i   {      if(a[i]!='\\0')      {        a[pos]=a[i];        pos+=1;      }    }    a[pos]='\\0'; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void delSlash(char *s) \n{ \n if (s == NULL) \n  return; \n \n int i = 1; \n int j = 1; \n int len = strlen(s); \n \n if (len == 0) \n  return; \n \n while(j < len) \n { \n  if (s[j] == '/' && s[i-1] == '/') \n   j++; \n  else \n  { \n   s[i] = s[j]; \n   i++; \n   j++; \n  } \n } \n s[i] = '\\0'; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void RemoveDuplicateSlashes(char * str) \n{ \n    int l = strlen(str); \n    int p = 0; \n    for(int i=0;i"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=8105373","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"10","title":"Tell me all possible methods for removing duplicate elements from an array and sorted array....which one is the best according to you.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"traverse through each element from the unsorted element and check whether the value is present or not in the unsorted array using binary search...  use a hash table and store the frequency of every values. remove all the elements that have frequency more than one..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if i understood properly \"from an array and sorted array\", i have two arrays one sorted and one unsorted  for unsorted array: 1) hash table 2) buckets (much like hashing though) 3) make BST of all elements 4) sort it and do methods that i will use in sorted array :D  for sorted array: 1) check consecutive elements 2) one can use hash/bucket/BST but they have same effect as checking consecutive elemetns"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the array is unsorted this has an nlogn lower bound. Can be reduced to the element uniqueness problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I love it when they say things like \"which one is the best\" or whatever. I had an interview recently where they asked me some bullshit question, and I wrote the code, and the questioner asked \"is that optimal\" and I (without the intention of being a dick) automatically asked \"optimal in space or time?\". The questioner seemed clueless about my counter. It was a shitty company anyways."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Unsorted Array Sort - O(nlog(n)) Compare consecutive elements - O(n)  Overall - O(nlogn)  2. Sorted Array Compare consecutive elements - O(n) Hash Table would not be space optimal  Bucket Sort would also be not space optimal"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/*  * To change this template, choose Tools | Templates  * and open the template in the editor.  */ package javaapplication1;  import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Set;  /**  *  * @author lalit  */ public class RemoveDuplicate {          Map map1= new HashMap();          public Map removeDuplicates(int [] A){          Map map = new HashMap();          for(int i=0;i             if(!map.containsKey(A[i]))map.put(A[i],1);         else map.put(A[i],new Integer((Integer)map.get(A[i]))+new Integer(1));                       }     return map;     }          public void initialize(){          int [] array = new int[]{4,5,2,5,6,2,6,7,1,1,8,4,7,1};     map1=removeDuplicates(array);     displayMap();     }          public void displayMap(){              Set set = map1.entrySet();         Iterator it = set.iterator();                  while(it.hasNext()){         Map.Entry entry = (Map.Entry)it.next();         System.out.println(entry.getKey()+\"  \"+entry.getValue());         }                          }          public static void main(String args[]){     new RemoveDuplicate().initialize();     }      }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n) space, O(n) time.  Can handle sorted and unsorted.  Sorted version can be done O(1) space and O(n) time."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=7937661","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"23","title":"Write a c++ program to find the LCM of all the elements of an array.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I have a solution that doesn't require any prime test. Basically note that  LCM (a, b, c) = LCM(LCM (a, b), c)    This is easy to prove: basically LCM(a, b) takes the maximum index in the prime factorization of a, b. LCM(a, b, c) takes the maximum index of all possible primes in a, b, and c, which is equivalent to finding the maximum index of primes from a, b and then c.   Based on these, and the fact that LCM(a, b) = a * b / GCD(a, b), we can do an iterative algorithm that only requires a GCD procedure, which can be easily done using the Euclid's algorithm."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"int GCD(int a, int b){ \n    if(b==0) return a;     \n    return GCD(b, a%b); \n} \n \nint LCM(int a, int b){ \n    return a*b/GCD(a,b); \n} \n \nint LCM2(int *a, int i, int n){ \n    if(i == n){ \n        return 1; \n    } \n     \n    return LCM(a[i],LCM2(a,i+1,n)); \n} \n \nint a[] = {3,5,2}; \nLCM2(a,0,3) will be the call."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"LCM = product of number/GCD use it for all numbers"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@Kishore: LCM is 90 for your example. I got similar kind of idea after looking your approach. 1. Minheapify the array. 2. Divide all the elements of array till first element becomes 1 at the same time maintain count for all prime divisors. 3. exchange 1st element to last and decrease array size. 4. if array size is is not zero go to 1 else stop. So after step 1 - 4 if we have count n1,n2,n3 for primes p1,p2,p3 then the LCM is LCM=p1*p1*..n1times * p2*p2*..n2 times, p3*p3*...n3times. e.g. Array = 10, 9 15, size is 3.  step 1 9,10,15 size 3 prime divisor none step 2 3,10,5  size 3 prime divisors 3-->1 step 2 1,10,5  size 3 prime divisors 3-->2 step 3 5,10,1  size 2 prime divisors 3-->2 step 4 go to 1.  step 1 5,10,1  size 2 prime divisors 3-->2 step 2 1,2,1   size 2 prime divisors 3-->2 5-->1 step 3 2,1,1   size 1 prime divisors 3-->2 5-->1 step 4 go to 1  step 1 2,1,1   size 1 prime divisors 3-->2 5-->1 step 2 1,1,1   size 2 prime divisors 3-->2 5-->1 2-->1 step 3 1,1,1 size 0 step 4 STOP  LCM = 3*3*2*5 = 90"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Test"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Based on Eric Xu's comment:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is an iterative version based on Xu's comment, also would it be a little faster if mod-based GCD computation is used instead of subtraction-based?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"have a simple code for LCM   #include #include #include  void main() { int i=2,j,n,*num,ct=0,lcm; printf(\"Enter the total no:\"); scanf(\"%d\",&n); if(n==0) { printf(\"Total no should be more then ZERO\"); getch(); exit(1); } num=(int *)malloc(n*2); for(i=0;i<=n-1;i++) { printf(\"enter the %d number:\",i+1) ; scanf(\"%d\",&num[i]); } i=2; while(i) { for(j=0,ct=0;j<=n-1;j++) { if(i%num[j]==0) ct=ct+1; } if(ct==n) { lcm=i; break; } i++; } printf(\"\\nlcm=%d\",lcm); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int LCM(int d,int e) {      int a=d,b=e,c,lcm;      while((a=a%b)!=0)      {       c=a;       a=b;       b=c;       }       lcm=(d*e)/b;       return lcm;       }  in main function() {     for(i=2;i          lcm=LCM(lcm,a[i]);   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@vicky its complexity would be something like nlogn considering the while loop in LCM()"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{{ karmaandcoding.blogspot.com /2011/03/lcm-of-array-of-numbers_16.html }}}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Does anybody know a more efficient solution?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Nothing new same solution has been proposed earlier."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=7894677","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"30","title":"You are given N ranges of date offsets when N employees are present in an organization. Something like  1-4 (i.e. employee will come on 1st, 2nd, 3rd and 4th day ) 2-6 8-9 ..   1-14  You have to organize an event on minimum number of days such that each employee can attend the event at least twice. Write an algorithm (there is apparently an O(n) algorithm for this).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Here is a simpler greedy solution: First, sort all ranges based on ENDING date in increasing order   Since dates are usually in small range we could make this step O(n) by using bucket based sorting like counting sort. Then, from first range to last:   Select last two days (because they produce maximum possibility to overlap next range)   Skip following ranges that also contains those two days, until a range that either covers only one day (we then select last day of this range) or does not cover any of the two (we then select last two days of this range). Then continue."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I doubt that it can be done in O(n), unless we use some O(n) sorting algorithm. I have a piece of code solving this problem, but just a rough draft. I have tested it with many cases, it should be correct. It runs on O(n*d) time, where d is the required events numbers for each employee (here, it's 2).  Here is the data structure I use:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"use a min-heap to extract-min based on end times. Keep track of the last 2 scheduled times and if an interval does not intersect the 2 most recent schedules, add a new one. Select new meeting schedules based on (end) and (end-1) times of each interval to maximize likelihood of intersection with future intervals."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question seems incomplete. Is there a constraint on number of people that can attend \"an\" event?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for all employee find maximum of minimum number of days plus one.. it will give  required number of days.. pls comment on my ans.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sort the bands using the start date Take the 1st band as 'w' compare 'w' with the next band. It decreases or stays the same according to the overlap with this (next) band continue with lower bands when it becomes less than 2,stop and set those 2 dates Take the next band as 'w' and start once again"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Does the event has to happen in consecutive days?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Let us say interval of dates for employee i is (xi,yi). Sort all xi,yi together but keep a tag whether its starting or ending. e.g.,   (x1,start),(y1,start),(y2,end) and so on. Now keep another array of counts such that count[0]=1; and count[i]=count[i-1]+1, if ith element is a start else count[i]=count[i-1]-1; Now, keep choosing dates by picking up dates corresponding to highest values of counts in greedy way until all employee are choosen 2 times."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Writing a sample code in python assuming days will be between 1 and 30. This can be done away with some more modification. Running time seems to be o(n*d) (n: size of input, d: number of days)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Thanks for explanation. However, how could you prove that this greedy method indeed gives optimum solution?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There isn't O(n) algorithm in total. But if we exclude the sorting part, there is an O(n) algorithm indeed.  Greedy algorithm.  1. sort the ranges in ascending order according to their left bound.  2. delete all ranges which satisfy that there exists at least one bound which is contained by it. For example, range [a, b]. If there is a range [c, d], (a<=c, d<=b), then we delete [a,b], because if the solution can satisfy [c, d], it can also satisfy [a, b]  3. examine each remaining range from left right. let's say we are examining range Ri=[Ai, Bi], if we already organized at least 2 events between Ai and Bi,  then we just pass this range, else we organize new event(s) as near to Bi as possible, to make 2 events in Ai and Bi.   For example, [1, 8], [5, 10], [10, 14], [14, 16] we check [1, 8] first, and select day-7 and day-8 as the event day. then we check [5, 10], there are already 2 events, pass it. Then [10, 14], we choose day-13 and day-14, then [14, 16], there is only 1 events, we then add day-16 to it. Finished.  It's easy to prove this greedy algorithm is correct as long as no range-containing relationship.  Btw, in step 2, we can use \"double-ended queue\" to eliminate all [a, b] ranges in O(n)'s time. If you want to know more, please wiki this data structure, or feel free to contact me.   lionxuemao@gmail.com"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a very nice problem. My solution :  Idea: Start with maximum possible range which effectively includes all ranges. Then start to shrink it as much as possible depending on each employee range. At the end, we will be left with 1) valid range which indicates number of days that are mutual to all employees or 2) Invalid range (start > end) which indicates failure  Here is a possible solution with O(n) running time.   1) Start with maximum possible range . call it \"result\" 2) Go through each employee's availability range. call it \"x\"    if(result.start < x.start) {        result.start = x.start;    }    if(result.end > x.end) {        result.end = x.end;    }    if(result.start > result.end) {        // No possible date(s) found which allows all the employees to attend event       Print(\"Sorry, no dates found\");    } 3) Return result"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"karmaandcoding.blogspot.com /2011/03/event-scheduling-for-n-employees-in.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Get the  min end time and max start time from all the employees. We have to include both these employees and all the other will have times overlapping with this time. So, our answer would be difference of these times + 2 (to include these two employee one more day)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=7208176","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"First the interviewer have called me on time, he introduced himself and his project which takes about 10 minutes, then he asked me why do you want to join facebook.. Then he started in the technical questions, the first questions was: he described to me a game called othelo (http://en.wikipedia.org/wiki/Reversi) which is a 2 player board game using for example X and O, if player X placed X in an empty space _OOOX the O's between the two X's will be converted to X XOOOX ==> XXXXX this will happen on the current row, column, and the two diagonals in every directions and if the following case happened __OOX and the X player placed X in the first space X_OOX nothing occured for the two Os  given a certain state of the board, location on the board, a certain piece to place on the given location  update the board, and make the required validations  Then I started to code the required method, then have revised it and fixed small bugs, then he told me that it seems to be working.  then we turned to the second question: which is given a Collection words, return a Collection of anagrams found in the given collection for example \"The rat fell in the tar\" => returned [rat tar]  Then I have discussed him in an algorithm with O(n k lg k) where n is the number of words and k is the average length of the word, then I started to code it and then he said that it seems to be working.  then the interview is finished.  Notes: * Try to practice a lot before the interview, by solving such problems and try to mimic the interview environment by coding in the collabedit.com text editor * Don't use Ctrl + S while coding in collabedit as it may lead to some problems. * Don't be afraid before the interview, just calm down as the interviewers are very friendly.  Good Luck :)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I cannot finish the question, you can check(remove the '/' among 'w') /w/w/w.careertea.com/techforum/post.aspx?PostID=37"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Could some one please write the solution to 2nd question."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A hash table may reduce to amortise O(nk), which n is the number of words and k is the length of words, with space O(nk)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=7273847","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"18","title":"given a set of distinct integers {a1, a2, a3, a4, a5, ...} and a set of exclusion rules: R = {{a1, a3}, {a2, a4, a10}, ...} can you print out all the valid subsets? Example: what is a valid subset? {a1, a4} what is an invalid subset? {a1, a2, a4}","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"We can imagine the set {a1,a2,a3,..} like a graph where initially all nodes are connected with each other.This means that initially this is a complete graph. Now we check the exclusion set, and for all 2 nodes in the same exclusion set, we remove the edge that connects them.Now, the remaining graph is full with nodes that are connected only and only if they can be in the same graph. Now, in order to find a valid subset, we can run a Depth First search to find all connected components.Every connected component will be a valid subset according to the way we created the graph. Now, for any of this subsets, we must generate the subsets to find all the solutions. Final complexity O(2^N). I think this solution is more interesting than raw backtracking."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"could u tell us your definition for valid and invalid"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"assuming number of distinct integers is less than 32 (WLOG) assign each value a bit position create a mask for each of the exclusion rule set generate subsets from original set (different n-bit values)   for mask in masks:     if value & mask == mask     then exclude, continue generation   print value  exponential:-( to generate all subsets"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Assume: The exclusion rules are converted into a vector of numbers where each number's binary representation tells us which numbers are in the exclusion set e.g: {(a1,a3,a5), (a1,a2)} = {00010101, 00000011) // Assume: We have n distinct numbers"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I don't think it's possible to have (a1,a2,a3) a valid subset and (a1,a2) an exclusion rule.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this sol.  Treat all points as nodes of graph. For each exclusion rule add edges between all elements of the exclusion set. Now run BFS and collect nodes into different components. Suppose number of Components = N. Now run a for loop of i between 1 to 2^N-1. This would give us a Bit Vector to generate different subsets. In the for loop look at the bit pattern of the i, i'th bit signifies that it includes the an element from i'th component. Iterate and print all the different subsets."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bogdan.cebere, your solution is correct. Just that insted of looking for strongly connected components, look out for cliques in the remaining graph. All the cliques will go into one valid set and then we can create subsets out of it. If there is no clique, then all the edges would correspond to valid subsets."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1, Treat the exclusion rules as the elements b1 ={a1, a3},b2= {a2, a4, a10} , find all non-null subsets {b1} {b2} {b1,b2}, O(2^|R|) 2, for each subsets, substitute b1 with every possible specific number, b1 => {a1}, {a2}, |b1| x |b2| ... 3. add {} empty set to the answer, which I think a valid subset.  how about this?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Start with 00000(of length of number of characters), print all permutations of it Start with 10000, print all permutations. and so on. so you start with 2^i+1 and shift it to length of the string and call permutations on that.  For excluding just convert them to bit representation and directly compare them."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think we cannot get rid of creating subsets for all integers of size N. So we are looking at a size of O(2^n).  The real trick is to help detect the wrong subsets.  1. Assign a prime number to each number in the given subset (a1->2, a2->3, a3->5 etc) 2. Create a product of the exclusion sets. Each product of unique prime numbers is unique. 3. When creating subsets, calculate the product of the items in the subset. If the product is divisible by any of the products of the exclusion sets, then it is invalid.   The extra complexity is of K where K is the number of exclusion sets."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@deveffort: The third step is not correct.  It should be 3. When creating subsets, calculate the product of the items in the subset. If the LCD of the product and any of the products of the exclusion sets is not a prime number, then it is invalid."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void \ngenerate_valid_subset(int *a, int n, int curr_loc, int *form, int form_len, struct list_node **applicable_rules, int *exclusion_refs, struct exclusion_rule *rules) \n{ \n    struct list_node *curr; \n    int i, j; \n \n    for (;curr_loc < n; ++curr_loc) { \n        if (exclusion_refs[curr_loc] == 0) { \n            form[form_len++] = a[curr_loc]; \n             \n            // Output form 0..form_len-1 \n            for (i = 0; i < form_len; ++i) { \n                printf(\"%d \", form[i]); \n            } \n            printf(\"\\n\"); \n \n            curr = applicable_rules[curr_loc]; \n            while (curr != NULL) { \n                i = curr->data; \n                curr = curr->next; \n                for (j = 0; j < rules[i].n; ++j) { \n                    ++exclusion_refs[rules[i].rule_elements[j]]; \n                } \n            } \n \n            /* Recursive call can be done via stack. */ \n            generate_valid_subset(a, n, curr_loc + 1, form, form_len, applicable_rules, exclusion_refs, rules); \n \n            /* clean-up*/ \n            form_len--; \n            curr = applicable_rules[curr_loc]; \n            while (curr != NULL) { \n                i = curr->data; \n                curr = curr->next; \n                for (j = 0; j < rules[i].n; ++j) { \n                    --exclusion_refs[rules[i].rule_elements[j]]; \n                } \n            } \n        } \n    } \n} \n \nint valid_subsets(int *a, int n, struct exclusion_rule *rules, int rules_count) \n{ \n    struct list_node **applicable_rule; \n    struct list_node *prealloc_nodes, *next_free; \n    int *exclusion_refs; \n    int *form; \n \n    int total_exclusions = 0, i, j, k; \n \n    applicable_rule = (struct list_node **)malloc(sizeof(struct list_node *) * n); \n    memset(applicable_rule, 0, sizeof(struct list_node *) * n); \n \n    exclusion_refs = (int *)malloc(sizeof(int) * n); \n    memset(exclusion_refs, 0, sizeof(int) * n); \n \n    form = (int *)malloc(sizeof(int) * n); \n \n    for (i = 0; i < rules_count; ++i) { \n        total_exclusions += rules[i].n; \n    } \n \n    prealloc_nodes = next_free = (struct list_node*)malloc(sizeof(struct list_node) * total_exclusions); \n    for (i = 0; i < rules_count; ++i) { \n        for (j = 0; j < rules[i].n; ++j) { \n            k = rules[i].rule_elements[j]; \n            next_free->data = i; \n            next_free->next = applicable_rule[k]; \n            applicable_rule[k] = next_free++; \n        } \n    } \n \n    generate_valid_subset(a, n, 0, form, 0, applicable_rule, exclusion_refs, rules); \n \n    free(applicable_rule); \n    free(exclusion_refs); \n    free(form); \n    free(prealloc_nodes); \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6964830","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"15","title":"Convert an ASCII representation of a positive integer to it's numeric value","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int a2i(char* str) \n{ \n   int num = 0; \n   int i=0; \n    \n   for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int num = 0; int mul = 1;     for(int i=0; i < strlen(str); mul *= 10, ++i) {     num += (str[i] - 0x30) * mul; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"in the for loop {   num*=10;   num+= char[i] - '0'; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include int main() {  char b[]=\"-40\";  int flag=1;  int num=0;  for(unsigned int i=0;i        if(b[i]=='-') flag=-1;         else num=num*10+b[i]-'0'; } printf(\"%d\",flag*num); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int Ascii_To_Int (char * str) {  int num = 0;  int mul = 1;  int End = strlen(str);   for(int i = End-1; i >= 0 ; mul *= 10, i--)  {      num += (str[i] - 0x30) * mul;  }   return num; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I didn't get the question correctly. can any one post a sample input and output value?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what do you mean by ASCII representation? Is it any different from string representation"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what about int overflow?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int atoi(char *str, int strLen){     int sign = 1;     int i = 0;     int result = 0;          if(str == NULL) return -1;     if(str[i] == '-') {         sign = -1;         i++;     }      while (i < strLen){         if(isdigit(str[i])){             checkIntOverflow(result, INT_MAX);             result = result*10 + str[i] - '0';         }else{             fprintf(stderr, \"not valid integer string\\n\");         }         i++;     }     return result; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"enum err_t \n{ \n ERR_OK, \n ERR_ARG, \n ERR_INVAL, \n ERR_OVERFLOW, \n}; \ntypedef int BOOL; \n#define TRUE 1 \n#define FALSE 0 \n \nerr_t atoi(const char *str, int *num) \n{ \n BOOL negative = FALSE; \n err_t err = ERR_OK; \n unsigned int result = 0, temp; \n unsigned int addition; \n \n if (num == NULL) { \n  err = ERR_ARG; \n  goto out; \n } \n \n if (str == NULL) { \n  err = ERR_ARG; \n  goto out; \n } \n \n if (*str == '-') { \n  negative = TRUE; \n  ++str; \n } else if (*str == '+') { \n  ++str; \n } \n \n while (*str) { \n  if (*str >= '0' && *str <= '9') { \n   addition = (unsigned int)(*str - '0'); \n   if (0 != (result & (0xF0 << (8 * (sizeof(unsigned int) - 1))))) { \n    err = ERR_OVERFLOW; \n    goto out; \n   }  \n \n   temp = result << 1; // temp = result * 2; \n   result <<= 3;  // result *= 8; \n \n   if (temp + result < result) { \n    err = ERR_OVERFLOW; \n    goto out; \n   } \n   result = temp + result;  // finally multiplied by 10, NO overflow. \n \n   if (addition + result < result) { \n    err = ERR_OVERFLOW; \n    goto out; \n   } \n   result += addition; \n   ++str; \n  } else { \n   err = ERR_INVAL; \n  } \n } \n \n if (0 != (result & (1 << (8 * sizeof(unsigned int) - 1)))) { \n  err = ERR_OVERFLOW; \n  goto out; \n } \n \n *num = (int)result; \n if (negative) { \n  *num *= -1; \n } \n \nout: \n return err; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int Atoi(const char * ptr) { \n  long long rs = 0; \n  bool minus = false; \n  while (*ptr == ' ') ptr++; \n  if (*ptr == '-') { \n    minus = true; \n    ptr++; \n  } else if (*ptr == '+') ptr++; \n  while (*ptr >= '0' && *ptr <= '9') { \n    rs = rs * 10 + *ptr - '0'; \n    ptr++; \n    if (rs > INT_MAX) break; \n  } \n  if (minus) rs *= -1; \n  if (rs > INT_MAX) return INT_MAX; \n  if (rs < INT_MIN) return INT_MIN; \n  return rs;  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"user atoi"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6913773","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"28","title":"Find the minimum depth of a binary tree","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"int min_depth(struct Node* root, int depth) \n{ \n if (root->left == NULL && root->right == NULL) \n  return depth; \n \n int x = (root->left != NULL) ? min_depth(root->left, depth+1) : depth; \n int y = (root->right != NULL) ? min_depth(root->right, depth+1) : depth; \n \n return (x < y) ? x : y; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Using Level Order Traversal (using Queue) Added null after all nodes in one level are added in queue, as an indicator of one level traversal  int min_depth(BT t) {  int depth=0;  Queue q;  if(!t || (!t->left && !t->right))   return 0;  Enqueue(Q,t);  Enqueue(q,null);  while(!IsEmptyQ(q))  {   node=Dequeue(q);   if(q==null)   {    depth++;    if(!IsEmptyQ(q))     Enqueue(q,null);   }   else   {    if(!t->left && !t->right)     return depth;    else    {     if(t->left)      Enqueue(q,t->left);     if(t->right)      Enqueue(q,t->right);    }   }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int MinDepth(TreeNode *node) \n{ \n  if( node == 0 ) \n  { \n    return 0; \n  } \n  int hL = MinDepth(node->left); \n  int hR = MinDepth(node->right); \n  if( (hL == 0) || (hR == 0) ) \n  { \n    return max( hL, hR ) + 1; \n  } \n  return min( hL, hR ) + 1; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"None of the two approaches seem good since they end up searching the entire tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"no moderation or manual moderation ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static int mindep=0; \nvoid Min(NODE* node, int dep) \n{ \n  if(!node) \n  { \n    return; \n  } \n \n  int curDep = dep+1; \n  if(!node->l && !node->r) \n  { \n    mindep=curDepl) Min(node->l, curDep); \n    if(node->r) Min(node->r, curDep);        \n  } \n} \n \nmain() \n{ \n  Min(root,0); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int min_depth(node_type *root) {     if(root==NULL)     {        return 0;     }     else     {        return (1 + min(min_depth(root->left) , min_depth(root->right)));      } }  please mind that in the called function we have to deduct 1  h=min_depth(root);  depth=h-1; so depth is the minimum depth of the tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorry I don't have a working code, but using BFS should tell you the min depth of a tree. Just check for a node with no children. This would not require full tree scan."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int MinDepth(Node *root) { \n    Queue  ; \n    if (root== NULL) { \n       return 0; \n    } \n    q.push_back(root); \n    int currLevelChildCount = 1; \n    int nextLevelChildCount = 0; \n    int minDepthLevel = 1; \n     \n    while (!q.empty())     { \n       Node *root = q.pop();   \n       currLevelChildCount--;     \n \n       if (root->children.size() == 0)        { \n           return minDepthLevel; \n       } \n       for (int i=0; i < root->children.size(); i++) { \n           q.push_back(root->children[i]);            \n           nextLevelChildCount += 1; \n       }    \n        \n       if (currLevelChildCount == 0) { \n           minDepthLevel += 1; \n           currLevelChildCount = nextLevelChildCount; \n           nextLevelChildCount = 0; \n       } \n    }  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int compute_min_depth (struct node *root, int depth) {   int tmp;    if (root == NULL)   return MAX_INT;   if (root->left == NULL && root->right == NULL) {   return depth;  }   tmp = compute_min_depth(root->left, depth + 1);  if (tmp < min_depth) {   min_depth = tmp;  }   tmp = compute_min_depth(root->right, depth + 1);  if (tmp < min_depth) {   min_depth = tmp;  }  return min_depth; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int minDepth(node *root) {     if(root==null) return 0;     queue< node *, int> >bfsList;     bfsList.push(pair< node *, int>(root,1);     while(!bfsList.empty())     {          node *me=bfsList.front().first;          int myLvl=bfsList.front().second;          if(me->left==NULL && me->right==NULL) return bfsList.second;          if(me->left!=NULL) bfsList.push(pair< node *, int>(me->left,myLvl+1);          if(me->right!=NULL) bfsList.push(pair< node *, int>(me->right,myLvl+1);          bfsList.pop();     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class BinaryTree { public:  BinaryTree();    ~BinaryTree();    BinaryTree * left() {   return mLeft;  }    BinaryTree * right() {   return mRight;  }    int BinaryTree::minDepth(int *curMin, int curDepth) {   int leftMinDepth = 0, rightMinDepth = 0;   if (mLeft != NULL) {    if (curDepth > curMin) {     leftMinDepth = INT_MAX;    } else {     leftMinDepth = mLeft->minDepth(curMin, curDepth+1);    }   }   if (mRight != NULL) {    if (curDepth > curMin) {     rightMinDepth = INT_MAX;    } else {     rightMinDepth = mRight->minDepth(curMin, curDepth+1);    }   }   if (rightMinDepth) == rightMinDepth == INT_MAX) {    return INT_MAX;   }   int thisNodeDepth = (leftMinDepth < rightMinDepth) ? (leftMinDepth + 1) : (rightMinDepth + 1);   if (thisNodeDepth > curMin) {    return INT_MAX;   } else {    curMin = thisNodeDepth;    return thisNodeDepth;   }  }   private:  BinaryTree *mLeft;  BinaryTree *mRight; }  // Test program int main() {     BinaryTree *BinaryTreeree = someTreeAlreadyCreated;     int *curMin = INT_MAX;     BinaryTreeree->minDepth(curMin, 0);     delete trie; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class BinaryTree { public:  BinaryTree();    ~BinaryTree();    BinaryTree * left() {   return mLeft;  }    BinaryTree * right() {   return mRight;  }    int BinaryTree::minDepth(int *curMin, int curDepth) {   int leftMinDepth = 0, rightMinDepth = 0;   if (mLeft != NULL) {    if (curDepth > curMin) {     leftMinDepth = INT_MAX;    } else {     leftMinDepth = mLeft->minDepth(curMin, curDepth+1);    }   }   if (mRight != NULL) {    if (curDepth > curMin) {     rightMinDepth = INT_MAX;    } else {     rightMinDepth = mRight->minDepth(curMin, curDepth+1);    }   }   if (rightMinDepth) == rightMinDepth == INT_MAX) {    return INT_MAX;   }   int thisNodeDepth = (leftMinDepth < rightMinDepth) ? (leftMinDepth + 1) : (rightMinDepth + 1);   if (thisNodeDepth > curMin) {    return INT_MAX;   } else {    curMin = thisNodeDepth;    return thisNodeDepth;   }  }   private:  BinaryTree *mLeft;  BinaryTree *mRight; }  // Test program int main() {     BinaryTree *BinaryTreeree = someTreeAlreadyCreated;     int *curMin = INT_MAX;     BinaryTreeree->minDepth(curMin, 0);     print curMin; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This problem must be solved using breadth first traversal. Recursive solution given above would waste CPU cycles for a scenario where a root has a million nodes in left subtree and just one in the right subtree. So why traverse all the million nodes.  We use a Sentinal node to indicate end of a level."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a java version, similar to Dmitry's"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int BinaryTreeNode::MinDepth() \n{ \n    struct list_node *head = NULL; \n    struct list_node **tail = &head; \n    struct list_node *temp; \n    BinaryTreeNode *curr; \n    int min_level = 0; \n \n    temp = (struct list_node *)malloc(sizeof(struct list_node)); \n    temp->tree_node = this; \n    temp->next = NULL; \n    *tail = temp; \n    tail = &temp->next; \n \n    temp = (struct list_node *)malloc(sizeof(struct list_node)); \n    temp->tree_node = NULL; \n    temp->next = NULL; \n    *tail = temp; \n    tail = &temp->next;  \n \n    while (head != NULL) { \n        temp = head; \n        head = head->next; \n \n        curr = temp->tree_node; \n        if (curr == NULL) { \n            ++min_level; \n            if (head != NULL) { \n                temp->next = NULL; \n                *tail = temp; \n                tail = &temp->next; \n                continue; \n            } else { \n                break; \n            } \n        } else if (curr->left == NULL && curr->right == NULL) { \n            break; \n        } \n         \n        if (curr->left != NULL) { \n            temp->tree_node = curr->left; \n            temp->next = NULL; \n            *tail = temp; \n            tail = &temp->next; \n            temp = NULL; // signal that same node has been used. \n        } \n \n        if (curr->right != NULL) { \n            if (temp == NULL) { \n                temp = (struct list_node *)malloc(sizeof(struct list_node)); \n            } \n            temp->tree_node = curr->right; \n            temp->next = NULL; \n            *tail = temp; \n            tail = &temp->next; \n        } \n \n        // no need to free temp, it is either used by left or right. \n    } \n \n    /* drain the built up queue. */ \n    while (head != NULL) { \n        temp = head; \n        head = temp->next; \n        free(temp); \n    } \n \n    return min_level; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//C# \n public int minDepth(Node root) \n        { \n            if (root == null) { return 0; } \n            return 1 + Math.Min(minDepth(root.leftNode), minDepth(root.rightNode)); \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int minDepth(Node root){ \n if(root == null) return 1; \n int l = minDepth(root.left); \n int r = minDepth(root.right); \n return 1 + Math.min(l, r); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int minDepth(node *root){ \n if(root == NULL) return 0; \n return min( minDepth(root->left), minDepth(root->right) ) + 1; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int minDepth(TreeNode *root) {         // Note: The Solution object is instantiated only once and is reused by each test case.         if(root == NULL)             return 0;         int path = 0;         int flag = 0;         TreeNode *tt = root;         queue nodeQueue;         nodeQueue.push(root);         while(!nodeQueue.empty()) {             TreeNode *t = nodeQueue.front();             if(tt == t) {                 path++;                 flag = 1;             }             if(t->left == NULL && t->right == NULL)                 break;             if(t->left != NULL) {                 nodeQueue.push(t->left);                 if(flag == 1) {                     tt = t->left;                     flag = 0;                 }             }             if(t->right != NULL) {                 nodeQueue.push(t->right);                 if(flag == 1) {                     tt = t->right;                     flag = 0;                 }             }             nodeQueue.pop();         }         return path;     }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6910676","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"17","title":"Write a function to find the depth of a binary search tree","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"#define MAX(x,y) ((x > y) ? x:y) int height(struct node *root) {  if(root == null) return 0; ldepth = height(root->left) + 1; rdepth = height(root->right) + 1;  return MAX(ldepth, rdepth); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"int maxDepth(struct node * node){ \n if(node==NULL) \n  return(0); \n else { \n  int ldepth=maxDepth(node->left); \n  int rdepth=maxDepth(node->right); \n  if(ldepth>rdepth) \n   return(ldepth+1); \n  else \n   return(rdepth+1); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"but where is the usage of binary search tree property this is like the solution for binary tree"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In this problem, we are not required to use the searching property of the BST (left <= right), since we are not concerned about that when finding the depth. So, then it  remains a binary tree only."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int btree::minheight(btreenode *k,queue q1,queue q2) {     int h = -1;     q1.enqueue(k);     while(q1.front != -1)     {                    btreenode* temp;                    while(q1.front != -1)                             q2.enqueue(q1.dequeue());                    h++;                    while(q2.front != -1)                    {                             temp = q2.dequeue();                             if(temp -> leftchild != NULL)                             {                                     q1.enqueue(temp -> leftchild);                             }                             else                             {                                     cout << \"Min height = \" << h << endl;                                     system(\"pause\");                                     exit(0);                             }                                                         if(temp -> rightchild != NULL)                             {                                     q1.enqueue(temp -> rightchild);                             }                             else                             {                                     cout << \"Min height = \" << h << endl;                                     system(\"pause\");                                     exit(0);                             }                        }     }     return h; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Recursive approach:  int depthTree(Tree t) {   if(t==null || t.left==null || t.right==null)  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Recursive approach:  int depthTree(Tree t) {   if(t==null || t.left==null || t.right==null)     return 0;   return(MAX(1+depthTree(t.left) , 1+depthTree(t.right)); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can take advantage of BST by using heuristic DFS with pruning"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Clue: create two string of preorder and inorder and apply some logic"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can you utilize the sorted BST behavior?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int maxDepth(Node root)         {             if (root == null) { return 0; }              return 1 + Math.Max(maxDepth(root.leftNode), maxDepth(root.rightNode));         }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6305921","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"33","title":"Given a unordered array of numbers, remove the fewest number of numbers to produce the longest ordered sequence. Print count of fewest numbers to be removed, and the remaining sequence. For example, if input is 1 2 3 4 5 6 7 8 9 10, no (zero) numbers are removed, and input is the longest sequence. If input is,  1 2 3 8 10 5 6 7 12 9 4 0, then fewest number of elements to be removed is 5 is the fewest number to be removed, and the longest sequence is 1 2 3 5 6 7 12.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Longest increasing subsequence is the answer. And can be done in O(nlog(n)) in the worst case."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1 2 3 5 6 7 9 is also a longest sequence"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"one possible solution using dynamic programming."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"make a tree with each element as node and make the next element as next node if present element is less than the last element then go to a element in the tree which is just lest than this element and make a new branch there and continue  finally print the largest possible path of that tree may be u can maintain the height while constructing so the no of elements to remove is total no of elements - height of the tree"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"input array a[] output array ord[]  N = 0; M = 0; for (i=1;i    if (a[i] >= a[i-1]){         if (M == 0){             tmp[0] = a[i-1];             tmp[1] = a[i];             M = 2;         }         else             tmp[M+1] = a[i];     }     else         if (M > N){             copy (tmp, ord);             N = M;             M = 0;         } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args){         int[] a={1,2,3,4,5,6,7,8,9,10,5,6,8,12,7,3,14,2,20};         int i=1,j=0;         int count=0;         while(i            if(a[j]                System.out.print(a[j]);                 j=i;                 i=i+1;             }else if(a[j]>a[i]){                 i++;                 count++;             }         }         System.out.print(a[j]);         System.out.println(\"count \"+count);     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The only way I found to be able to do this is to generate all subsets of the array and find the max increasing subset using dynamic programming. The code is pretty simple, but it's O(2^n - 1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using dynamic programming    if a[i] >= max(a[0 ... i-1] then l(i) = l(i - 1) + 1, put a[i] into result array.    else l(i) = l(i-1);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"patience sort is the best and easiest one .."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int[] longestSubesequence(int[]a, int start, int end, int[] result, int max)throws IOException{               //Input:  1 2 3 8 10 5 6 7 12 9 4 0              //output:  1 2 3 5 6 7 12.   //1 2 3 8 10 5 6 7 12 9 4 0   int []prevArray = new int[0];   int []arr;   for(int i = start; i   if(max==0||result[max - 1] < a[i]){     result[max] = a[i];     arr = longestSubesequence(a, i + 1, end, result, max + 1);     if(arr.length > prevArray.length){      prevArray = arr;           }    }   }   if(prevArray.length < max){    prevArray = Arrays.copyOfRange(result, 0, max);   }   return prevArray;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"answer will N-length of Longest Increasing Subsequence . Such a easy question :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sort the array. find the LCS of the sorted array and the old array.  The rest is the elements need to be removed."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this can be done in O(n). (Similar to max sub array in given array but with twist)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void longest_increasing_subseq(int *a, int n) \n{ \n int seq_buffer[4096]; \n int next_buffer[4096]; \n \n int *seq_length = NULL; \n int *next_index = NULL; \n int max_len = 0; \n int start_index; \n int i, j; \n \n if (n > 0) { \n  max_len = 1; \n  start_index = 0; \n  /* avoid malloc if request can be service through stack memory. */ \n  if (sizeof(int)*n <= sizeof(seq_buffer)) { \n   seq_length = seq_buffer; \n  }else { \n   seq_length = (int *)malloc(sizeof(int)*n); \n  } \n \n  if (sizeof(int)*n  <= sizeof(next_buffer)) { \n   next_index = next_buffer; \n  } else { \n   next_index = (int *)malloc(sizeof(int)*n); \n  } \n \n } \n \n for (i = 0; i < n; ++i) { \n  seq_length[i] = 1; \n } \n \n for (i = n - 1; i >= 0; --i) { \n  for (j = i + 1; j < n; ++j) { \n   if ((a[i] <= a[j]) && (seq_length[i] < seq_length[j] + 1)) { \n    seq_length[i] = seq_length[j] + 1; \n    next_index[i] = j; \n    if (seq_length[i] > max_len) { \n     max_len = seq_length[i]; \n     start_index = i; \n    } \n   } \n  } \n } \n \n if (seq_length != seq_buffer) { \n  free(seq_length); \n } \n \n printf(\"Removal count: %d\\n\", n - max_len); \n while (max_len--) { \n  printf(\"%d \", a[start_index]); \n  start_index = next_index[start_index]; \n } \n printf(\"\\n\"); \n \n if (next_index != next_buffer) { \n  free(next_index); \n } \n \n \n return; \n} \n \nint main() \n{ \n \n int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; \n int b[] = {1, 2, 3, 8, 10, 5, 6, 7, 12, 9, 4, 0}; \n \n longest_increasing_subseq(a, sizeof(a)/sizeof(a[0])); \n \n longest_increasing_subseq(b, sizeof(b)/sizeof(b[0])); \n \n    return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be done in O(n)."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6322661","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"12","title":"Print an arbitrary tree, level by level","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void print_tree(const node * root) \n{ \n    list pending_nodes; \n \n    pending_nodes.push_back(root); \n    while ( !pending_nodes.empty() ) \n    { \n        const node* cur = pending_nodes.front(); \n        pending_nodes.pop_front(); \n \n        cout << cur->key << endl; \n        if ( cur->left ) pending_nodes.push_back(cur->left); \n        if ( cur->right ) pending_nodes.push_back(cur->right); \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"BFS should do the job, right?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"But how would you know when to hit a new line? Eg  1 2 3 4 5 6 7 8 9 I suppose this is per level printing.. You need to know the structure of the tree..or can use 2 queues and keep switching between them...add children to second queue while iterating over first one till its empty...then switch first and second queue and again perform...pretty poor space complexity but time will be theta(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is it a binary tree? How is the structure of the tree defined if it isn't"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"every node stores two references: first child and next sibling."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"do one rthing do more"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Create two Queues A, B. 2. Start from Root. 3. Put all childrens into A. 4. Do a While A is not Empty. Print the Node, put all thier children into QueueB. 5. Now copy B into A. Repeat 4. 6. if A is empty and B is empty. Quit."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Added null after all nodes in one level are added in queue, as an indicator of one level traversal  int min_depth(BT t) {  Queue q;  Enqueue(Q,t);  Enqueue(q,null);  while(!IsEmptyQ(q))  {   node=Dequeue(q);   if(q==null)   {    printf(\"\\n\");    if(!IsEmptyQ(q))     Enqueue(q,null);   }   else   {    printf(\"%d \",node->data);    Enqueue all childs of node in q;   }  } }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6268663","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"21","title":"Print out all the subsets of an array","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void print_all_subset(const int numbers[], const size_t size, const int begin_index, int print[]) \n{ \n    if ( begin_index == size ) \n    { \n        for ( unsigned i = 0; i < size; i ++ ) \n        { \n            if ( print[i] ) cout << numbers[i] << \" \"; \n        } \n        cout << endl; \n        return; \n    } \n    print[begin_index] = 1; \n    print_all_subset(numbers, size, begin_index + 1, print); \n    print[begin_index] = 0; \n    print_all_subset(numbers, size, begin_index + 1, print); \n} \n \nvoid print_all_subset(const int numbers[], const size_t size) \n{ \n    vector print; \n    print.resize(size); \n    print_all_subset(numbers, size, 0, &print[0]); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void PrintSubsets() {     int source[3] = {1,2,3};     int currentSubset = 7;     int tmp;     while(currentSubset)     {         printf(\"(\");         tmp = currentSubset;         for(int i = 0; i<3; i++)         {             if (tmp & 1)                 printf(\"%d \", source[i]);             tmp >>= 1;         }         printf(\")\\n\");         currentSubset--;     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The above idea explained  If there are n objects than all 2^n subsets can be determined by iterating from 0 to 2*n and in each iteration by selecting the elements at the position having set bit in the counter. Like for given ex 000--{} 001--{1} 010--{2} 011--{2,3} 100--{3} 101--{1,3} 110--{2,3} 111--{1,2,3}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@raden  Nice solution !!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@Rayden and Nitin great sol and awesome explaination :) thanks guys"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@Rayden and Nitin  Good Solution dudes keep it up..Thanks a lot"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Rayden and Nitin I am inspired from Solution,Please folk have a another piece of code   #include  int main() { int i,j,a[100],total;  printf(\"Enter the total Number:\"); scanf(\"%d\",&total);   for(i=0;iprintf(\"Enter the %d Number : \",i+1); scanf(\"%d\", &a[i]); printf(\"\\n\"); }  i=1<while(i>0){  printf(\"{\"); for(j=total-1,k=0;j>=0;j--){        if( 1<        printf(\"%d\",a[k]);         k++; } i--; printf(\"}\\n\");  }  return 0;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this one?  vector L;  void PrintSubset(const vector& v, const int idx) {     for (int i = idx; i < v.size(); ++i)     {         L.push_back(v[i]);         Print(L);         PrintSubset(v, i + 1);         L.pop_back();     } }  PrintSubset([1,2,3], 0);  Output:  1 12 123 13 2 23 3"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include   #define N (3)  void printSet(int s[N]) {  int i;   printf(\"\\n{ \");   for(i=0; i {   printf(\"%d \",s[i]);  }   printf(\"}\\n\"); }  void allSubset(int s[N], int k, int n) {  int i;   if(k == n) /* we found one solution */  {   printSet(s);    return;  }   /* either we select the kth element */  s[k] = 1;  allSubset(s, k+1, n);   /* or we don't select the element */  s[k] = 0;  allSubset(s, k+1, n);          return; }  void allSubset_driver() {  int a[N] = {1,2,3};  int s[N], i;   /* initialize set */  for(i=0; i {   s[i] = 0;  }   allSubset(s, 0, N); }  int main() {  allSubset_driver();"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"output will look like this:  { 1 1 1 }  { 1 1 0 }  { 1 0 1 }  { 1 0 0 }  { 0 1 1 }  { 0 1 0 }  { 0 0 1 }  { 0 0 0 }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void printSubSetsV2(int[] set) \n        { \n            int n = set.Length; \n            int currentSubset = (int) Math.Pow(2, n) - 1;                      \n \n            while(currentSubset != 0) \n            { \n                Console.Write(currentSubset + \": { \"); \n                for(int i = 0; i< n; ++i) \n                {                     \n                    if (BitManipulation.GetBit(currentSubset, i)) \n                        Console.Write(set[i]);                    \n                } \n \n                Console.WriteLine(\" }\");             \n                currentSubset --; \n            } \n        } //end"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; \n \n \npublic class Subset_of_set { \n \n public static ArrayList> getSubset(ArrayList set) \n { \n  ArrayList> allsubset = new ArrayList>(); \n  int max = 1< subset = converInttoSet(i,set); \n   allsubset.add(subset); \n \n  } \n \n  return allsubset; \n \n \n } \n \n private static ArrayList converInttoSet(int i,ArrayList set) \n { \n  ArrayList subset=  new ArrayList(); \n  int index =0; \n  for(int k = i;k>0; k>>=1) \n  { \n   if((k&1)>0) \n    subset.add(set.get(index));  \n   index++; \n  } \n  return subset; \n } \n \n public static void main(String[] args) { \n \n  ArrayList a = new ArrayList<>(); \n  for (int i = 0; i < 5; i++)  \n  { \n   a.add(i+1); \n  } \n  ArrayList> result = getSubset(a); \n \n  System.out.println(result); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; \n \n \npublic class Subset_of_set { \n \n public static ArrayList> getSubset(ArrayList set) \n { \n  ArrayList> allsubset = new ArrayList>(); \n  int max = 1< subset = converInttoSet(i,set); \n   allsubset.add(subset); \n \n  } \n \n  return allsubset; \n \n \n } \n \n private static ArrayList converInttoSet(int i,ArrayList set) \n { \n  ArrayList subset=  new ArrayList(); \n  int index =0; \n  for(int k = i;k>0; k>>=1) \n  { \n   if((k&1)>0) \n    subset.add(set.get(index));  \n   index++; \n  } \n  return subset; \n } \n \n public static void main(String[] args) { \n \n  ArrayList a = new ArrayList<>(); \n  for (int i = 0; i < 5; i++)  \n  { \n   a.add(i+1); \n  } \n  ArrayList> result = getSubset(a); \n \n  System.out.println(result); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; \n \n \npublic class Subset_of_set { \n \n public static ArrayList> getSubset(ArrayList set) \n { \n  ArrayList> allsubset = new ArrayList>(); \n  int max = 1< subset = converInttoSet(i,set); \n   allsubset.add(subset); \n \n  } \n \n  return allsubset; \n \n \n } \n \n private static ArrayList converInttoSet(int i,ArrayList set) \n { \n  ArrayList subset=  new ArrayList(); \n  int index =0; \n  for(int k = i;k>0; k>>=1) \n  { \n   if((k&1)>0) \n    subset.add(set.get(index));  \n   index++; \n  } \n  return subset; \n } \n \n public static void main(String[] args) { \n \n  ArrayList a = new ArrayList<>(); \n  for (int i = 0; i < 5; i++)  \n  { \n   a.add(i+1); \n  } \n  ArrayList> result = getSubset(a); \n \n  System.out.println(result); \n } \n \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4470681","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"9","title":"Telephone Dir lookup: Given mapping: number to letters (just like on the telephone buttons) i/p: digit string e.g. \"1234\" 1. o/p: all possible letter strings based on the mapping.  2. o/p only those strings that are in a given dictionary. (and length of the dictionary is small.)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For 1st part: If one digit represents 3 letters. So, 4 digit will represent 3^4 combinations of strings. We can do that in a for loop ?  For 2nd part: After getting output from 1st part, we can check if (combination present in dict. ) ? and output accordingly. ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Phone2Text { \n private static String[] mapping = { \"ABC\", \"DEF\", \"GHI\", \"JKL\", \"MNO\", \n   \"PQR\", \"STU\", \"VW\", \"XY\", \"Z*#\" }; \n \n public static void combinations(int[] number, char[] buf, int numIndex) { \n \n  for (int i = 0; i < mapping[number[numIndex]].length(); i++) { \n   buf[numIndex] = mapping[number[numIndex]].charAt(i); \n   if (numIndex < number.length - 1) { \n    combinations(number, buf, numIndex + 1); \n   } else \n    System.out.println(buf); \n  } \n } \n \n public static void main(String[] args) { \n  int num[] = { 5, 8, 5, 5, 0, 3, 3, 4, 4, 7 }; \n  Phone2Text.combinations(num, new char[num.length], 0); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#pay attention to the mapping."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Build a trie by number instead of character"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"python:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import Data.Array (listArray, (!)) import Data.Char (digitToInt) import Data.Set (fromList, member)  keyMap = listArray (2, 9) [\"ABC\", \"DEF\", \"GHI\", \"JKL\", \"MNO\", \"PQRS\", \"TUV\", \"WXYZ\"]  digitCombinations digits = sequence $ [keyMap ! i | i <- digits]  dictionary = fromList [\"DOG\", \"CAT\", \"BIRD\", \"REPTILE\"]  main = do   numberString <- getLine   let numberCombinations = digitCombinations $ map digitToInt numberString   return $ filter ((flip member) dictionary) numberCombinations"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"string lookup[10] = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"}; \n \nint coi(char c){ \n return ((int)c - 48); \n} \n \nvoid print(string oldString, string newString) \n{ \n if (oldString.length() == 0) { \n  cout << newString << endl; \n  return; \n } \n else { \n  string characters = lookup[coi(oldString[0])]; \n  int numOfChars = characters.length(); \n   \n  for(int i=0; i"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4449674","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"Imagine you are running a typical dropbox website (like x-drive) where users can upload their files/data. How will you go about monetizing this website using online advertising? What are the factors you will consider to match users to ads?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"maybe we can just read the file attributes and extensions, you can guess that user X is a developer if he is uploading python, perl scripts, by OS tells you a lot too, i know people who would pay to target a user running OSX, or maybe the antivirus companies would like to advertise to people to, mmh maybe even offer free virus detection, and try to fix quarantine files on the cloud for a fixed rate  just to mention a few"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Names of the files uploaded, location from where data was uploaded,Amount of data uploaded by user,types of the file uploaded"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4423692","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"17","title":"Given a histogram of n items stacked next to each other, find the Max area under a given rectangle. Each bar in the histogram has width = 1 unit and hight is variable.  Hint: Brute force approach gives you O(n2) solution. Can you do better?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Look at: w/w/w/.homeofcox-cs.blogspot.com/2010/04/max-rectangle-in-histogram-problem.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"could you elaborate the question, max are under given rectangle? what rectangle? and how is the rectangle represented?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Start from lowest left corner and go right one by one, putting sums to the block 1,2 3. Go up to second level and do the same but cells will go like 2,4,6 since they have blocks under them. 3rd level will have 3 6 9,and so on. Choose the block with largest sum and go to the left till there are no cells on the left and you have your rectangle. If i understand the question correctly :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can use divide and conquer approach.  Let h[] be the array and kth element be the minimum element in h[] from index i to j  max_area = max(max_area(i, k-1), max_area(k+1, j), h[k]*(j-i))  i will be set to 0 and j will be set to array length initially"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What does question say ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what does Max Area mean? The highest value in the histogram that this rectangle area ovrlaps with?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Question doesn't make sense the way it is stated right now."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Question doesn't make sense the way it is stated right now."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Working C++ code:  int MaxRectangleAreaHistogram(vector  HistogramVec, unsigned int length, int width, int MaxHeight) {  if (length >= HistogramVec.size()) // processed all histograms  {   return 0;  }  int HistHeight = HistogramVec[length];      if (MaxHeight > HistHeight)  //prev recursive call does not apply to this  {   return 0;  }   int sum = 0;  int maxSum = 0 ;    if (MaxHeight < 0 ) {   maxSum = HistogramVec[length];   sum = MaxRectangleAreaHistogram(HistogramVec, length + 1, width, -1);    if (sum > maxSum) {    maxSum = sum;   }     for (int i=0; i   {    sum = (i+1)*width + MaxRectangleAreaHistogram(HistogramVec, length + 1, width, i+1);    if (sum > maxSum) {     maxSum = sum;    }   }  }  else  {   sum = MaxHeight + MaxRectangleAreaHistogram(HistogramVec, length + 1, width, MaxHeight);   if (sum > maxSum) {    maxSum = sum;   }  }    return maxSum; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \nusing namespace std; \n \nint DEBUG = 1; \n \n// \n// Note that if s->size() becomes 0, then left = start. \n// This is useful when entry in hist[] can be zero. \n// If all entries in hist[] are positive, then no need to use start, \n// In that case, use -1 in place of start in this function. \n// \nvoid getMax(int hist[], stack * s, \n            int newHeight, int right, int & max, int & start) \n{ \n    int height, left = 0, area; \n    while (s->size() > 0 && hist[s->top()] > newHeight) \n    { \n        height = hist[s->top()]; \n        s->pop(); \n        left = (s->size() > 0) ? s->top() : start; \n        while (s->size() > 0 && hist[s->top()] == height) \n        { \n            s->pop(); \n            left = (s->size() > 0) ? s->top() : start; \n        } \n \n        area = height * (right - left); \n        if (DEBUG) cout<<\"\\narea: \"<<<\"*(\"<<<\"-\"<<<\") = \" < max) max = area; \n    } \n \n} \n \n// \n// Note that when hist[i] == top_v, we push i. \n// In the acm judge site, it says skip i if equal. \n// But I feel somehow it can't keep track of the left value \n// when multiple columns have the same height. \n// \nint doHist(int hist[], int len) \n{ \n    stack * s = new stack; \n    int i, max, top_v; \n    int start = -1; // the position before the last 0, used by left. \n \n    max = 0; \n    for (i = 0; i < len; i ++) \n    { \n        if (s->size() == 0) \n        { \n            s->push(i); \n            continue; \n        } \n \n        top_v = hist[s->top()]; \n        if (hist[i] >= top_v) \n        { \n            s->push(i); \n        } \n        else if (hist[i] < top_v) \n        { \n            getMax(hist, s, hist[i], i - 1, max, start); \n            s->push(i); \n            if (hist[i] == 0) start = i - 1; \n        } \n    } \n \n    getMax(hist, s, 0, i - 1 , max, start); \n \n    cout << \"\\nmax = \" << max << endl; \n    return max; \n} \n \nint main() \n{ \n    //int hist[] = {3, 5, 4, 7, 6, 5, 2}; // answer: 20 \n    int hist[] = {1,2,1}; \n    doHist(hist, sizeof(hist) / sizeof(int)); \n    return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A good explanation with figures tech-queries.blogspot . com /2011/03/ maximum-area-rectangle-in-histogram.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n) solution ; implemented the algorithm for this question found on stackoverflow"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"w..w.w..w.w.wtech-queries.blogspot.in/2011/03/maximum-area-rectangle-in-histogram.html"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4472683","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"13","title":"Find and delete nodes from a linked list with value=k. What's the complexity? Does it handle boundary cases?  Hint: Make sure to free the memory when deleting a node using delete() or free()","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Delete(node** head, int k) \n{ \n     node* curr = *head; \n     node* prev = NULL; \n \n     while(curr != NULL) \n     { \n         if(curr->val == k) \n         { \n             if(prev != NULL) \n             { \n                 prev->next = curr->next;  \n                 delete curr; \n                 curr = prev->next;  \n             } \n             else \n             { \n                 curr = curr->next; \n                 delete *head; \n                 *head = curr; \n             } \n         } \n         else \n         { \n            prev = curr; \n            curr = curr->next; \n          } \n     } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This comment has been deleted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int delete (node** head,int k) \n{ \n if(*head->val == k) \n { \n  node* temp=*head; \n  *head=*head->next; \n  free(temp); \n  return 0; \n } \n node **n=head; \n while(*n->next->val!=k && *n->next) \n { \n  *n=*n->next; \n } \n if(*n->next) \n { \n  node* temp=*n->next; \n  *n->next=*n->next->next; \n  free(temp); \n  return 0; \n } \n return -1; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"in C#: Node Delete(Node head, int k) // return node as new head {     while (head != null && head.Data == k)         head = head.Next; // skip initial nodes that equal to k     while (head != null && head.Next != null)     {         if (head.Next.Data == k)             head.Next = head.Next.Next; // delete next node         else             head = head.Next; // advance pointer     }     return head; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node* Delete(Node* head, int k) {  if (! head) return head;   while (head && head->GetValue() == k) {   Node* next = head->GetNext();   delete head;   head = next;  }   if (! head) return head;   Node* pre = head;  Node* node = head->GetNext();   while(node) {   if (node->GetValue() == k) {    Node* next = node->GetNext();    delete node;    pre->GetNext() = next;    node = next;   } else {    pre = node;    node = node->GetNext();   }  }   return head;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void DeleteElements(Node **head, int k) \n{ \n   if (*head == NULL) return; \n \n   Node *prevNode = *head; \n   Node *nextNode = NULL; \n   for (Node *cur = head->next; cur != NULL; cur = nextNode) { \n       next = cur->next; \n       if (cur->val == k) { \n           delete cur; \n           prevNode->next = next; \n       } else { \n           prevNode = cur; \n       } \n   } \n \n   if ((*head)->val == k)) { \n      Node *tmp = *head; \n      head = (*head)->next; \n      delete tmp; \n   } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void remove_node(struct link_node **head, int k) \n{ \n     struct link_node *temp; \n     while (*head != NULL) { \n           if ((*head)->data == k) { \n                temp = *head; \n                *head = (*head)->next; \n           } else { \n                 head = &(*head)->next; \n           } \n     } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ListNode* delete(ListNode* head, int k) \n{ \n     ListNode* h = head, prev = NULL; \n     while (h != NULL) \n     { \n                if (h->val == k) { \n                     if (prev == NULL) head = h->next; \n                     if (prev) prev->next = h->next; \n                     ListNode* tmp = h; \n                     delete h; \n                } \n                 h = h->next; \n     } \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4399683","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"10","title":"Implement Queue using stacks. What's the time complexity of various queue operations for this implementation?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I think we will need two stacks to implement queue :-  stack has operations top(),empty(),pop(),add()  lets take two stacks s1 and s2 keep a variable FRONT  nOw :-"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using two stacks. One for adding, second for removing items. Befor add/remove check where are items and pop them if needed.  O(n) for enqueue, O(n) for dequeue in worst case. Sequential adding - O(1). Sequential dequeue - O(1).  Worst case for switching from/to enqueue/dequeue"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"we can do it using a single stack. supported operations - top(), empty(), pop(), add()  for top() and pop() -  we recursively top or pop the elements until we get the last element. we will still be using two stacks.. one- the given stack and the other recursion stack.. but explicitly its just one stack!  wat say??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"just one stack is fine. insert - O(1) dequeue - O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"All the above solutions are for implementing FIFO queues. In the question, its not mentioned which queue has to be implemented.   The solution needs to take this into account.  In case of a LIFO queue, we just need push() and pop() {can be named add() and remove() }. Both will have time complexity of O(1). We also do not need two queues.  In case of FIFO queue, we need to make a design decision. This can be done either using an extra internal queue, or by using recursion. Adding an element to this stack based queue can be O(1)."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4447673","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"12","title":"Find 2 numbers in an integer array that sum to x. If found return true else false. 1. simple solution is O(n2) 2. Using certain data struct it can be improved to O(n) but you have to check for a special condition. what is that? Hint: if x = 4 and one of the values in the array is 2.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Use a hash map. Suppose array is  arr = {2,8,3,6,4,7,9} Now use a hash map key = arr[i] value = sum - arr[i]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"It can be implemented w/o any additional DS's in O(n Log n) time and with O(1)  storage. The below code and the driver app will find all the valid pairs, also included are the inlined comments:  #include  #include  /*   Given an array of integers in the range INT_MIN to INT_MAX,   find all the pairs of elements that sum up to the given number @sum   Algorithm:   - Sort the input array   - Keep summing up the elements at the lowest and the highest current indices   -     If the sum is > than the result, decrement the upper index   -     If the sum is < than the result, increment the lower index   -     If the sum = result, then   -        found a valid pair; print the numbers   -        converge the lower and upper indices (++lower, --upper)   - Loop until both indices meet   The above algorithm will find all the valid pairs, including positive,    negative and 0. */ bool find_sum(int arr[], int cnt, int sum) {  int l, u, k;  bool bret = false;   /* Sort the input array */  std::sort(&arr[0], &arr[cnt]);  u = cnt - 1;  l = 0;   while (l < u) {   k = arr[l] + arr[u];   if (k == sum) { // found the two elements    printf(\"SUM: %-3d ELEMENTS (%d %d): %d %d\\n\",      sum, l, u,     arr[l], arr[u]);    bret = true;    l++;    u--;   }   else if (k < sum)    ++l;   else    --u;  }  return bret; } int main(int argc, char* argv[]) {  int arr[] = {7, -4, 1, 0, -2, 3, 8, -9, 10, 1, 0, 20, 2};  int cnt = sizeof(arr)/sizeof(arr[0]);   for (int i = -10; i < 20; i++)    find_sum(arr, cnt, i);  return 0;  } }}}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hash the array.  Iterate the array and check if x-a[i] exists in the hash. Corner case is if x=4 and a[i]=2 and no other two is there in the array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@ Gamodg try with input {1,3,5,7,9} sum=10."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Try with Hash table. Put all the array elements in Hash table. Search for first array element in hash table and then x-a[0] value in hash table. If it exists, return true. else do this for other array elements present in hash table.  Complexity - O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public boolean sumExists ( int [ ] array, int sum ) { \n \n if ( array == null ) \n  return false; \n \n HashSet hs = new HashSet ( ); \n \n for ( int i=0; i"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4425679","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"19","title":"\"Count and Say problem\" Write a code to do following: n                 String to print 0                 1 1                 1 1 2                 2 1 3                 1 2 1 1 ... Base case: n = 0 print \"1\" for n = 1, look at previous string and write number of times a digit is seen and the digit itself. In this case, digit 1 is seen 1 time in a row... so print \"1 1\" for n = 2, digit 1 is seen two times in a row, so print \"2 1\" for n = 3, digit 2 is seen 1 time and then digit 1 is seen 1 so print \"1 2 1 1\" for n = 4 you will print \"1 1 1 2 2 1\"  Consider the numbers as integers for simplicity. e.g. if previous string is \"10 1\" then the next will be \"1 10 1 1\" and the next one will be \"1 1 1 10 2 1\"","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"we have N   we can do :-"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* The class name doesn't have to be Main, as long as the class is not public. */ class Main {   public static void main (String[] args) throws java.lang.Exception   {       System.out.println(countAndSay(3));   }      private static String countAndSay(int n)     {         StringBuilder prev = new StringBuilder(\"1\");         StringBuilder curr = new StringBuilder();          while (n-- > 0)         {             curr.delete(0, curr.length());             for (int i = 0; i < prev.length(); i++)             {                 char c = prev.charAt(i);                 int count = 1;                 int j = i + 1;                 for (; j < prev.length() && prev.charAt(j) == c; j++, count++)                     ;                 i = j - 1;                  curr.append(count);                 curr.append(c);             }              StringBuilder t = prev;             prev = curr;             curr = t;         }          return prev.toString();     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void countAndSay(int n) { \n  String current = \"0 1\"; \n  String previous = \"\"; \n  int count=0; \n   \n  do { \n   System.out.println(current); \n   previous = current; \n   ++count; \n   StringBuilder sb = new StringBuilder(); \n   String [] str = previous.split(\" \"); \n   int [] A = new int[str.length]; \n   for (int i=0; i 0); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"function a = test(n)     a = 1;     if (n == 0)         return     end      while (n > 0)         old = a;         len = columns(old);         undercheck = old(1);         count = 0;         pt = 0;         for i=1:len             if (old(i) == undercheck)                 count += 1;             else                 a(pt+1) = undercheck;                 a(pt+2) = count;                 undercheck = old(i);                 count = 1;                 pt += 2;             end         end         a(pt+1) = undercheck;         a(pt+2) = count;          n -= 1;     end end"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"% octave code %   function a = test(n)     a = 1;     if (n == 0)         return     end      while (n > 0)         old = a;         len = columns(old);         undercheck = old(1);         count = 0;         pt = 0;         for i=1:len             if (old(i) == undercheck)                 count += 1;             else                 a(pt+1) = undercheck;                 a(pt+2) = count;                 undercheck = old(i);                 count = 1;                 pt += 2;             end         end         a(pt+1) = undercheck;         a(pt+2) = count;          n -= 1;     end end"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#!/usr/bin/env python  def countSay(n):     code = [1]     if n==0:         return code     while n>0:         old = code         size = len(code)         code = []         undercheck = old[0]         count = 0         for i in range(size):             if old[i]==undercheck:                 count += 1             else:                 code.append(undercheck)                 code.append(count)                 undercheck = old[i]                 count = 1         code.append(undercheck)         code.append(count)         n -= 1     return code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what does the ques say pls any one give some explanation!!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"NA"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about using a queue?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n \nusing namespace std; \n \nint b[100] ;  \nint a[100];  \nint ct ;  \n \nint func() \n{ \n int i = 1 ;  \n int j = 0 ; \n int ctr = 1 ;  \n while(1) \n { \n  if(i == ct) \n   break ;  \n  if(a[i] == a[i-1]) \n   ctr++; \n  else \n  { \n   b[j++] = ctr ;  \n   b[j++] = a[i-1] ;  \n   ctr = 1 ;  \n  } \n  i++; \n } \n b[j++] = ctr ; \n b[j++] = a[i-1] ;  \n ct = j ;  \n} \n \nint main() \n{ \n int n ;  \n int i ; \n int j ; \n cin >> n ; \n \n ct = 1 ;  \n a[0] = 1 ; \n  \n printf(\"0 1\\n\"); \n for(i = 1 ; i < n; i++) \n { \n  printf(\"%d \",i); \n  func(); \n  for(j = 0 ; j < ct ; j++) \n  { \n   printf(\"%d \",b[j]); \n   a[j] = b[j] ;  \n  } \n  printf(\"\\n\"); \n } \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void csp(int n) { \n  ArrayList list = new ArrayList(); \n  list.add(1);   \n  for (int i = 1; i <= n; ++i) { \n   HashMap map = new HashMap();  \n   System.out.println(); \n   for (int j : list) { \n    System.out.print(j + \" \"); \n    int count = 1; \n    if (map.containsKey(j)) { \n     count = map.get(j); \n     count++; \n    } \n    map.put(j, count); \n   } \n   list = new ArrayList(); \n   for (Integer k : map.keySet()) { \n    list.add(map.get(k)); \n    list.add(k); \n   } \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void csp(int n) { \n  ArrayList list = new ArrayList(); \n  list.add(1);   \n  for (int i = 1; i <= n; ++i) { \n   HashMap map = new HashMap();  \n   System.out.println(); \n   for (int j : list) { \n    System.out.print(j + \" \"); \n    int count = 1; \n    if (map.containsKey(j)) { \n     count = map.get(j); \n     count++; \n    } \n    map.put(j, count); \n   } \n   list = new ArrayList(); \n   for (Integer k : map.keySet()) { \n    list.add(map.get(k)); \n    list.add(k); \n   } \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def get_next(num): \n    seq=list(num) \n    n=len(seq) \n \n    i,sz=0,0 \n    p,ans=seq[i],'' \n    while i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Same question was asked to me!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#import \n#import \n \nvoid countAndSay(char* string) \n{ \n        int i = 0; \n        int currentCharCount = 1; \n        char currentChar = string[i]; \n        i++; \n        while(string[i] != '\\0') \n        { \n                if(string[i] == currentChar) \n                { \n                        currentCharCount++; \n                        i++; \n                } \n                else \n                { \n                        printf(\"%d %c \", currentCharCount, currentChar); \n                        currentChar = string[i]; \n                        currentCharCount = 1; \n                        i++; \n                } \n        } \n        printf(\"%d %c \", currentCharCount, currentChar); \n} \n \n \nint main() \n{ \n        char str[] = \"1211\"; \n        countAndSay(str); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include   using namespace std; void str_print(strint str);  int main() {     int N;     string str=\"\";     string temp=\"\";     cin>>N;     int i=0;     int count=0;     while(i<=N)     {              if(i==0)              {cout<<\"0\"<<\" 1\"<                          else              {                  temp=\"\";                  int start=0;                  string te1=\"\";                  while(start                 {                     count=0;                     if(te1==\"\")                     {                                       while(str[start]!=' ' && str[start]!='\\0')                     {                        te1=te1+str[start];                        start++;                     }                     }                     string te2;                     do{                       te2=\"\";                       count++;                       if(str[start]=='\\0')                       break;                       start++;                        while(str[start]!=' ' && str[start]!='\\0')                        {                          te2=te2+str[start];                          start++;                        }                      }while(te2==te1);                    ostringstream convert;                    convert << count;                    if(temp!=\"\")                    temp=temp+\" \"+convert.str()+\" \"+te1;                    else                    temp=convert.str()+\" \"+te1;                    string kl=te1;                    if(te2!=\"\" && te2!=te1)                    te1=te2;                    if(start>=str.size() && kl!=te1)                    temp=temp+\" 1 \"+te1;                  }                  str=temp;                  cout<<<\" \"<<             }                            i++;          }     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Solution { \n    public String countAndSay(int n) { \n        // IMPORTANT: Please reset any member data you declared, as \n        // the same Solution instance will be reused for each test case. \n        StringBuffer prev = new StringBuffer(); \n        StringBuffer curr = new StringBuffer(); \n         \n        int count=1; \n        char temp='1'; \n        if(n==1) \n            return \"1\"; \n        for(int i=0;i"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4476686","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"17","title":"Given a binary tree, compute min depth of a leaf node.  Hint: 1. BFS 2. Recursive implementation Which is better in time complexity?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Asymptotically they will be the same though BFS can be written to stop as soon as a leaf node is found in which case it will not explore any nodes that are at a level below the leaf node with min depth. which even in the worst case will explore half the nodes less... (since a tree with n nodes has atleast n/2 nodes as leaves and BFS can stop at the first leaf itself) whereas you cannot say anything about the performance of a DFS since the leaf with min depth may be explored at the very end."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I think I am wrong regarding the n/2 nodes since that is only the case for a complete binary tree. However I am atleast sure about this, the BFS approach will be better than the DFS approach, since BFS need not explore the entire tree in most cases whereas DFS will have to explore the entire tree in any case..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I would support BFS. Thats because BFS will stop as soon as it sees a node at a level with no children. But DFS would anyway have to traverse until every leaf node and then find which is the smallest path to a leaf node.  Comparing the complexities depends on the way the tree is constructed. So either might win. But on an average, BFS would win."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the recursive implementation."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the BFS approach"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"They are essentially the same complexity-wise. Recursive approach implicitly does DFS building a stack, and the other builds queue."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int depthWithRec(Node * node) {   if(node == null)   return null;  else   return min(depth(node->left), depth(node->right) + 1); }  int depthWithoutRec(Node * node){  if(node != null) {   int lDepth = 0, rDepth = 0;   queue.enqueue(node); while(queue()! = empty()) { node = dequeue();  if(node->left != null) {  lDepth++; queue.enqueue(node);  } if(node->right!= null) {  rDepth++; queue.enqueue(node); } return(min(lDepth,rDepth) +1); } } else   return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int mindepth(struct node* root) \n     { \n           if(root == NULL) \n              return 0; \n          else \n          { \n                int lefttreedepth = mindepth(root->left); \n                int righttreedepth = mindepth(root->right); \n                if(lefttreedepth"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Depth(Node node) \n{ \n  if(node == null) return 0; \n  else return 1 + min(Depth(node->left),Depth(node->right));"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about BFS counting the number of nodes in each layer interatively, until find the layer in depth d has nodes fewer than 2^(d-1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Recursive is better  public int minDepth(Node root)         {             if (root == null) { return 0; }             return 1 + Math.Min(minDepth(root.leftNode), minDepth(root.rightNode));         }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4328688","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"9","title":"So the Problem being this. Given a particular number say 637-8687 (NERVOUS) would be the word. So for the older keypad??s seen on telephone??s I would have to create Mnemonics.   So for doing this, the first part being list out all the Permutations possible for a particular number series.   Ex: ListMnemonics(??723??) would result in PAD PBD PCD QAD QBD QCD RAD RBD RCD SAD SBD SCD PAE PBE PCE QAE QBE QCE RAE RBE RCE SAE SBE SCE PAF PBF PCF QAF QBF QCF RAF RBF RCF SAF SBF SCF  For this my logic is for the above number 723, somehow create all the permutations for 23 and then append for each of those permutations the letters of 7. That would give all the permutations possible for 723. The base case being if there is a single number then I would print its letters.   But please let me know what you guys think","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Could not understand the question properly. Is it like a number will be given, and we need to print all the possible word combinations ? If so, this is a sample code (might not be an efficient sol, but it came to my mind first)  #include   void printMnemonics(int count,char str[]);  /* Codes for 723 */ char A[][5]={{'P','Q','R','S','\\0'},{'A','B','C','\\0'},{'D','E','F','\\0'}}; int level=3;  int main() {    char str[5];     printMnemonics(0,str);     return 0; }  void printMnemonics(int count,char str[]) {     int i;     if(count == level)     {       str[count]='\\0';       printf(\"%s\\n\",str);       return;     }      i=0;     while(A[count][i] != '\\0')     {        str[count]=A[count][i];        printMnemonics(count+1,str);        i++;     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This problem needs to be solved Recursively."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Good one V !"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Phone2Text { \n private static String[] mapping = { \"ABC\", \"DEF\", \"GHI\", \"JKL\", \"MNO\", \n   \"PQR\", \"STU\", \"VW\", \"XY\", \"Z*#\" }; \n \n public static void combinations(int[] number, char[] buf, int numIndex) { \n \n  for (int i = 0; i < mapping[number[numIndex]].length(); i++) { \n   buf[numIndex] = mapping[number[numIndex]].charAt(i); \n   if (numIndex < number.length - 1) { \n    combinations(number, buf, numIndex + 1); \n   } else \n    System.out.println(buf); \n  } \n } \n \n public static void main(String[] args) { \n  int num[] = { 5, 1, 2, 8, 6, 0, 7 }; \n  Phone2Text.combinations(num, new char[num.length], 0); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Recursive solution is the most obvious. Here is an iterative one  The idea is to count for all the possible permutations. E.g. For number '237', the result would be combination of \"abc\", \"def\" and \"pqrs\" i.e. 3*3*4 combinations.  We can count from 000 to 223 (since index start from 0) and output the text based on each digits. The counting should be done carefullly, i.e. after 003, the next number 010 and after that 011, 012, 013, 020 and so on. At each count, we output the corresponding text i.e. for 012, we output/store (\"abc\"[0] + \"def\"[0] + \"pqrs\"[2] = \"adr\"). This ofcourse is exponential but is still better than costlier recursive solution. Here's a python code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi dear posters. First of all, I would like to mention that this is not a problem with permutation, but a problem of combinations with a set of possible values for each position in the number. Below is a complete application that generates all the possible words/word combinations for the given number map and the number. Hope the inline comments are quite self-descriptive."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"JavaScript"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"really?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Use trie that would be easier and simple   where for w \\in Wordset     convert it in number      insert Number(w) in trie"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4079975","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"21","title":"Input a string and a pattern having . and * Output: whether the string fully matches the pattern . match any char, * means matching 0 or more times. Example: input \"a\", \".\" => match input \"abc\", \".*\" => match input \"abcd\", \"a.*d\" => match","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"maybe not the most efficient, but can easily come up with this solution \n \n__int8_t checker(const char *input, const char *mask) \n{ \n while(*input != 0) \n { \n  if (*mask == 0) \n   return -1; \n    \n  if (*mask == '.' ) \n   return checker(++input, ++mask); \n   \n  if (*mask == '*') \n  { \n   const char *input_b = input; \n   mask++; \n   while (*input_b != 0) \n   { \n    if (checker(++input_b, mask)) \n     return 1; \n   } \n   return -1; \n  } \n  if (*mask == *input) \n  { \n   mask++; \n   input++;   \n  } \n  else \n   return -1; \n } \n if (*mask != 0) \n  return -1; \n return 1; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would recommend a recursive procedure. Here is the psudo-code. Let me know if you would like proper Java code, and I'll see if I can work on it.   We'll treat taking substrings as a constant time operation. While this is not completely true (in Java), it simplifies the code. If you like, you can first transform the string into an array of characters to guarantee constant time. We'll use a recursive procedure."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hey .... Ur algo won't work if we have something like  bhopali *ali ==> it will work bhoppali *ali ==> it won't work!!!  Code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@above comment....  input case which will give wrong result: bhopaali *ali"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Exact matches and '.' matches can be skipped normally. When a '*' is encountered at index i, check all the suffixes of the input string for a match with pattern[i+1, n]   Not thoroughly tested. Please leave a comment if it fails on any case."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public boolean match(String s, String pattern) { \n if (s == null || pattern == null) { \n  throw new IllegalArgumentException(); \n } \n if (pattern.isEmpty()) { \n  return s.isEmpty(); \n } \n if (s.isEmpty()) { \n  if (pattern.charAt(0) == '*') { \n   return match(s, pattern.substring(1)); \n  } else { \n   return false; \n  } \n } \n char s_0 = s.charAt(0), p_0 = pattern.charAt(0); \n if (p_0 == '.' || p_0 == s_0 ) { \n  return match(s.substring(1), pattern.substring(1)); \n } \n if (p_0 == '*') { \n  if (!match(s.substring(1), pattern)) { \n   return match(s, pattern.substring(1)); \n  } \n  return true; \n } \n return false; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This should do it :  using System; using System.Collections.Generic; using System.Linq; using System.Text;  namespace ConsoleApplication2 {     class Program     {         static void Main(string[] args)         {             Console.WriteLine(\"aaaaab - a*b - {0}\", Match(\"aaaaab\",0, \"a*b\",0));             Console.WriteLine(\"aaaaabc - a*b - {0}\", Match(\"aaaaabc\", 0, \"a*b\", 0));             Console.WriteLine(\"ab - a.b - {0}\", Match(\"ab\", 0, \"a.b\", 0));             Console.WriteLine(\"acb - a.b - {0}\", Match(\"acb\", 0, \"a.b\", 0));             Console.WriteLine(\"accccccc - a*b - {0}\", Match(\"accccccc\", 0, \"a*b\", 0));         }          static bool Match(string s,int scur, string r, int rcur)         {             if (IsEmpty(r, rcur))                 return IsEmpty(s, scur);              if (r[rcur] == '*')             {                 if (IsEmpty(s, scur) & GetLength(r, rcur) == 1)                     return true;                  return MatchStar(s, scur, r, rcur);             }              if (IsEmpty(s, scur)) return false;              if (r[rcur] != s[scur] && r[rcur] != '.') return false;              return Match(s, scur + 1, r, rcur + 1);         }          static bool MatchStar(string s, int scur, string r, int rcur)         {             if (Match(s, scur, r, rcur + 1))                 return true;              for(int i=scur +1;i            {                 if(Match(s,i,r,rcur))                     return true;             }              return false;         }          static int GetLength(string s, int index)         {             return s.Length - index;         }           static bool IsEmpty(string s, int index)         {             return index == s.Length;         }     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ok , now this should look better:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have a correct solution to it, and probably the most efficient and standard way to solve it, because my method is from KMP. The time complexity is O(n), same as the classic KMP. I just extended it to support '*' and '.' . Write in C++. You need to include  and  at least to compile it. Here is the code, which is very similar to classic KMP except for a few changes. I will point them out later."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a recursive version that may be wrong \npublic boolean compare(byte[] rule, byte[] string, int p_r, int p_s) \n{ \n if(p_s >= string.length) \n { \n  while(p_r= rule.length) \n { \n  return false; \n } \n if(rule[p_r] == '*') \n { \n  return p_r == rule.length - 1 ? true : compare(rule,string,p_r,p_s + 1) || compare(rule,string,p_r + 1,p_s); \n }else if(rule[p_r] == '.' || string[p_s] == rule[p_r]) \n { \n  return compare(rule,string,p_r+1,p_s + 1); \n }else \n { \n  return false; \n } \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4033979","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"15","title":"Input: Either an object array having integer, string and boolean, like {\"abc\", \"ab,c\", 10, true, false} Or a hash table like {\"a1\":\"abc\",\"t\":true,\"e\":123}  Output: If object array, output \"abc\" 10 true  If hash, output \"a1\":\"abc\" \"t\" : true \"e\" : 123","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i don't understand the puzzle"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"chutiye"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"chutiye"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void parseJSON() \n { \n  byte[] input = \"{\\\"a1\\\":\\\"abc\\\",\\\"t\\\":true,\\\"e\\\":123}\".getBytes(); \n  ArrayList array = new ArrayList(); \n  int type = 0;// 0 for array, 1 for object \n  int status = 0; \n  byte[] trues = \"true\".getBytes(); \n  byte[] falses = \"false\".getBytes(); \n  UniType temp = new UniType(); \n   \n  for(int i = 0; status!=-1 && i < input.length  ; i++) \n  { \n   char c = (char) input[i]; \n   switch(status) \n   { \n    case 0: \n     if(c == '{') \n      status = 1; \n     else \n      status = -1; \n     break; \n    case 1: \n     switch(c) \n     { \n      case ' ': \n       break; \n      case '\"': \n       status = 2; \n       temp.type = 1; \n       temp.value.append('\"'); \n       break; \n      case '+': \n      case '-': \n       temp.type = 0; \n       temp.value.append(c); \n       status = 4; \n       break; \n      case '0': \n      case '1': \n      case '2': \n      case '3': \n      case '4': \n      case '5': \n      case '6': \n      case '7': \n      case '8': \n      case '9': \n       temp.type = 0; \n       temp.value.append(c); \n       status = 5; \n       break; \n      case 'f': \n       temp.type = 2; \n       temp.value.append(c); \n       status = 10; \n       break; \n      case 't': \n       temp.type = 2; \n       temp.value.append(c); \n       status = 6; \n       break; \n      default: \n       status = -1; \n     } \n     break; \n    case 2: \n     if(c == '\"') \n     { \n      temp.value.append('\"'); \n      array.add(temp); \n      status = 3; \n      temp = new UniType(); \n     }else \n     { \n      temp.value.append(c); \n     } \n     break; \n    case 3: \n     switch(c) \n     { \n     case ':': \n      type = 1; \n     case ',': \n      status = 1; \n      break; \n     case '}': \n      status = -1; \n     default: \n      status = -1; \n     } \n     break; \n    case 4: \n     if( c >= '0' && c <= '9' ) \n     { \n      status = 5; \n      temp.value.append(c); \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 5: \n     if( c >= '0' && c <= '9' ) \n     { \n      temp.value.append(c); \n     }else if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    case 6: \n    case 7: \n    case 8: \n     if(c == trues[status - 5]) \n     { \n      temp.value.append(c); \n      status++; \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 9: \n     if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    case 10: \n    case 11: \n    case 12: \n    case 13: \n     if(c == falses[status - 9]) \n     { \n      temp.value.append(c); \n      status++; \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 14: \n     if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    default: \n     status = -1; \n   } \n  } \n  System.out.println(type == 1 ? \"object\" : \"array\"); \n   \n  //print out the result \n  status = 0; \n  for(UniType un : array) \n  { \n   if(status < type) \n    System.out.print( un.getValue() + \":\"); \n   else \n    System.out.println(un.value.toString()); \n   status = 1 - status; \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void parseJSON() \n { \n  byte[] input = \"{\\\"a1\\\":\\\"abc\\\",\\\"t\\\":true,\\\"e\\\":123}\".getBytes(); \n  ArrayList array = new ArrayList(); \n  int type = 0;// 0 for array, 1 for object \n  int status = 0; \n  byte[] trues = \"true\".getBytes(); \n  byte[] falses = \"false\".getBytes(); \n  UniType temp = new UniType(); \n   \n  for(int i = 0; status!=-1 && i < input.length  ; i++) \n  { \n   char c = (char) input[i]; \n   switch(status) \n   { \n    case 0: \n     if(c == '{') \n      status = 1; \n     else \n      status = -1; \n     break; \n    case 1: \n     switch(c) \n     { \n      case ' ': \n       break; \n      case '\"': \n       status = 2; \n       temp.type = 1; \n       temp.value.append('\"'); \n       break; \n      case '+': \n      case '-': \n       temp.type = 0; \n       temp.value.append(c); \n       status = 4; \n       break; \n      case '0': \n      case '1': \n      case '2': \n      case '3': \n      case '4': \n      case '5': \n      case '6': \n      case '7': \n      case '8': \n      case '9': \n       temp.type = 0; \n       temp.value.append(c); \n       status = 5; \n       break; \n      case 'f': \n       temp.type = 2; \n       temp.value.append(c); \n       status = 10; \n       break; \n      case 't': \n       temp.type = 2; \n       temp.value.append(c); \n       status = 6; \n       break; \n      default: \n       status = -1; \n     } \n     break; \n    case 2: \n     if(c == '\"') \n     { \n      temp.value.append('\"'); \n      array.add(temp); \n      status = 3; \n      temp = new UniType(); \n     }else \n     { \n      temp.value.append(c); \n     } \n     break; \n    case 3: \n     switch(c) \n     { \n     case ':': \n      type = 1; \n     case ',': \n      status = 1; \n      break; \n     case '}': \n      status = -1; \n     default: \n      status = -1; \n     } \n     break; \n    case 4: \n     if( c >= '0' && c <= '9' ) \n     { \n      status = 5; \n      temp.value.append(c); \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 5: \n     if( c >= '0' && c <= '9' ) \n     { \n      temp.value.append(c); \n     }else if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    case 6: \n    case 7: \n    case 8: \n     if(c == trues[status - 5]) \n     { \n      temp.value.append(c); \n      status++; \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 9: \n     if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    case 10: \n    case 11: \n    case 12: \n    case 13: \n     if(c == falses[status - 9]) \n     { \n      temp.value.append(c); \n      status++; \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 14: \n     if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    default: \n     status = -1; \n   } \n  } \n  System.out.println(type == 1 ? \"object\" : \"array\"); \n   \n  //print out the result \n  status = 0; \n  for(UniType un : array) \n  { \n   if(status < type) \n    System.out.print( un.getValue() + \":\"); \n   else \n    System.out.println(un.value.toString()); \n   status = 1 - status; \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void parseJSON() \n { \n  byte[] input = \"{\\\"a1\\\":\\\"abc\\\",\\\"t\\\":true,\\\"e\\\":123}\".getBytes(); \n  ArrayList array = new ArrayList(); \n  int type = 0;// 0 for array, 1 for object \n  int status = 0; \n  byte[] trues = \"true\".getBytes(); \n  byte[] falses = \"false\".getBytes(); \n  UniType temp = new UniType(); \n   \n  for(int i = 0; status!=-1 && i < input.length  ; i++) \n  { \n   char c = (char) input[i]; \n   switch(status) \n   { \n    case 0: \n     if(c == '{') \n      status = 1; \n     else \n      status = -1; \n     break; \n    case 1: \n     switch(c) \n     { \n      case ' ': \n       break; \n      case '\"': \n       status = 2; \n       temp.type = 1; \n       temp.value.append('\"'); \n       break; \n      case '+': \n      case '-': \n       temp.type = 0; \n       temp.value.append(c); \n       status = 4; \n       break; \n      case '0': \n      case '1': \n      case '2': \n      case '3': \n      case '4': \n      case '5': \n      case '6': \n      case '7': \n      case '8': \n      case '9': \n       temp.type = 0; \n       temp.value.append(c); \n       status = 5; \n       break; \n      case 'f': \n       temp.type = 2; \n       temp.value.append(c); \n       status = 10; \n       break; \n      case 't': \n       temp.type = 2; \n       temp.value.append(c); \n       status = 6; \n       break; \n      default: \n       status = -1; \n     } \n     break; \n    case 2: \n     if(c == '\"') \n     { \n      temp.value.append('\"'); \n      array.add(temp); \n      status = 3; \n      temp = new UniType(); \n     }else \n     { \n      temp.value.append(c); \n     } \n     break; \n    case 3: \n     switch(c) \n     { \n     case ':': \n      type = 1; \n     case ',': \n      status = 1; \n      break; \n     case '}': \n      status = -1; \n     default: \n      status = -1; \n     } \n     break; \n    case 4: \n     if( c >= '0' && c <= '9' ) \n     { \n      status = 5; \n      temp.value.append(c); \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 5: \n     if( c >= '0' && c <= '9' ) \n     { \n      temp.value.append(c); \n     }else if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    case 6: \n    case 7: \n    case 8: \n     if(c == trues[status - 5]) \n     { \n      temp.value.append(c); \n      status++; \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 9: \n     if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    case 10: \n    case 11: \n    case 12: \n    case 13: \n     if(c == falses[status - 9]) \n     { \n      temp.value.append(c); \n      status++; \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 14: \n     if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    default: \n     status = -1; \n   } \n  } \n  System.out.println(type == 1 ? \"object\" : \"array\"); \n   \n  //print out the result \n  status = 0; \n  for(UniType un : array) \n  { \n   if(status < type) \n    System.out.print( un.getValue() + \":\"); \n   else \n    System.out.println(un.value.toString()); \n   status = 1 - status; \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void parseJSON() \n { \n  byte[] input = \"{\\\"a1\\\":\\\"abc\\\",\\\"t\\\":true,\\\"e\\\":123}\".getBytes(); \n  ArrayList array = new ArrayList(); \n  int type = 0;// 0 for array, 1 for object \n  int status = 0; \n  byte[] trues = \"true\".getBytes(); \n  byte[] falses = \"false\".getBytes(); \n  UniType temp = new UniType(); \n   \n  for(int i = 0; status!=-1 && i < input.length  ; i++) \n  { \n   char c = (char) input[i]; \n   switch(status) \n   { \n    case 0: \n     if(c == '{') \n      status = 1; \n     else \n      status = -1; \n     break; \n    case 1: \n     switch(c) \n     { \n      case ' ': \n       break; \n      case '\"': \n       status = 2; \n       temp.type = 1; \n       temp.value.append('\"'); \n       break; \n      case '+': \n      case '-': \n       temp.type = 0; \n       temp.value.append(c); \n       status = 4; \n       break; \n      case '0': \n      case '1': \n      case '2': \n      case '3': \n      case '4': \n      case '5': \n      case '6': \n      case '7': \n      case '8': \n      case '9': \n       temp.type = 0; \n       temp.value.append(c); \n       status = 5; \n       break; \n      case 'f': \n       temp.type = 2; \n       temp.value.append(c); \n       status = 10; \n       break; \n      case 't': \n       temp.type = 2; \n       temp.value.append(c); \n       status = 6; \n       break; \n      default: \n       status = -1; \n     } \n     break; \n    case 2: \n     if(c == '\"') \n     { \n      temp.value.append('\"'); \n      array.add(temp); \n      status = 3; \n      temp = new UniType(); \n     }else \n     { \n      temp.value.append(c); \n     } \n     break; \n    case 3: \n     switch(c) \n     { \n     case ':': \n      type = 1; \n     case ',': \n      status = 1; \n      break; \n     case '}': \n      status = -1; \n     default: \n      status = -1; \n     } \n     break; \n    case 4: \n     if( c >= '0' && c <= '9' ) \n     { \n      status = 5; \n      temp.value.append(c); \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 5: \n     if( c >= '0' && c <= '9' ) \n     { \n      temp.value.append(c); \n     }else if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    case 6: \n    case 7: \n    case 8: \n     if(c == trues[status - 5]) \n     { \n      temp.value.append(c); \n      status++; \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 9: \n     if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    case 10: \n    case 11: \n    case 12: \n    case 13: \n     if(c == falses[status - 9]) \n     { \n      temp.value.append(c); \n      status++; \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 14: \n     if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    default: \n     status = -1; \n   } \n  } \n  System.out.println(type == 1 ? \"object\" : \"array\"); \n   \n  //print out the result \n  status = 0; \n  for(UniType un : array) \n  { \n   if(status < type) \n    System.out.print( un.getValue() + \":\"); \n   else \n    System.out.println(un.value.toString()); \n   status = 1 - status; \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void parseJSON() \n { \n  byte[] input = \"{\\\"a1\\\":\\\"abc\\\",\\\"t\\\":true,\\\"e\\\":123}\".getBytes(); \n  ArrayList array = new ArrayList(); \n  int type = 0;// 0 for array, 1 for object \n  int status = 0; \n  byte[] trues = \"true\".getBytes(); \n  byte[] falses = \"false\".getBytes(); \n  UniType temp = new UniType(); \n   \n  for(int i = 0; status!=-1 && i < input.length  ; i++) \n  { \n   char c = (char) input[i]; \n   switch(status) \n   { \n    case 0: \n     if(c == '{') \n      status = 1; \n     else \n      status = -1; \n     break; \n    case 1: \n     switch(c) \n     { \n      case ' ': \n       break; \n      case '\"': \n       status = 2; \n       temp.type = 1; \n       temp.value.append('\"'); \n       break; \n      case '+': \n      case '-': \n       temp.type = 0; \n       temp.value.append(c); \n       status = 4; \n       break; \n      case '0': \n      case '1': \n      case '2': \n      case '3': \n      case '4': \n      case '5': \n      case '6': \n      case '7': \n      case '8': \n      case '9': \n       temp.type = 0; \n       temp.value.append(c); \n       status = 5; \n       break; \n      case 'f': \n       temp.type = 2; \n       temp.value.append(c); \n       status = 10; \n       break; \n      case 't': \n       temp.type = 2; \n       temp.value.append(c); \n       status = 6; \n       break; \n      default: \n       status = -1; \n     } \n     break; \n    case 2: \n     if(c == '\"') \n     { \n      temp.value.append('\"'); \n      array.add(temp); \n      status = 3; \n      temp = new UniType(); \n     }else \n     { \n      temp.value.append(c); \n     } \n     break; \n    case 3: \n     switch(c) \n     { \n     case ':': \n      type = 1; \n     case ',': \n      status = 1; \n      break; \n     case '}': \n      status = -1; \n     default: \n      status = -1; \n     } \n     break; \n    case 4: \n     if( c >= '0' && c <= '9' ) \n     { \n      status = 5; \n      temp.value.append(c); \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 5: \n     if( c >= '0' && c <= '9' ) \n     { \n      temp.value.append(c); \n     }else if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    case 6: \n    case 7: \n    case 8: \n     if(c == trues[status - 5]) \n     { \n      temp.value.append(c); \n      status++; \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 9: \n     if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    case 10: \n    case 11: \n    case 12: \n    case 13: \n     if(c == falses[status - 9]) \n     { \n      temp.value.append(c); \n      status++; \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 14: \n     if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    default: \n     status = -1; \n   } \n  } \n  System.out.println(type == 1 ? \"object\" : \"array\"); \n   \n  //print out the result \n  status = 0; \n  for(UniType un : array) \n  { \n   if(status < type) \n    System.out.print( un.getValue() + \":\"); \n   else \n    System.out.println(un.value.toString()); \n   status = 1 - status; \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void parseJSON() \n { \n  byte[] input = \"{\\\"a1\\\":\\\"abc\\\",\\\"t\\\":true,\\\"e\\\":123}\".getBytes(); \n  ArrayList array = new ArrayList(); \n  int type = 0;// 0 for array, 1 for object \n  int status = 0; \n  byte[] trues = \"true\".getBytes(); \n  byte[] falses = \"false\".getBytes(); \n  UniType temp = new UniType(); \n   \n  for(int i = 0; status!=-1 && i < input.length  ; i++) \n  { \n   char c = (char) input[i]; \n   switch(status) \n   { \n    case 0: \n     if(c == '{') \n      status = 1; \n     else \n      status = -1; \n     break; \n    case 1: \n     switch(c) \n     { \n      case ' ': \n       break; \n      case '\"': \n       status = 2; \n       temp.type = 1; \n       temp.value.append('\"'); \n       break; \n      case '+': \n      case '-': \n       temp.type = 0; \n       temp.value.append(c); \n       status = 4; \n       break; \n      case '0': \n      case '1': \n      case '2': \n      case '3': \n      case '4': \n      case '5': \n      case '6': \n      case '7': \n      case '8': \n      case '9': \n       temp.type = 0; \n       temp.value.append(c); \n       status = 5; \n       break; \n      case 'f': \n       temp.type = 2; \n       temp.value.append(c); \n       status = 10; \n       break; \n      case 't': \n       temp.type = 2; \n       temp.value.append(c); \n       status = 6; \n       break; \n      default: \n       status = -1; \n     } \n     break; \n    case 2: \n     if(c == '\"') \n     { \n      temp.value.append('\"'); \n      array.add(temp); \n      status = 3; \n      temp = new UniType(); \n     }else \n     { \n      temp.value.append(c); \n     } \n     break; \n    case 3: \n     switch(c) \n     { \n     case ':': \n      type = 1; \n     case ',': \n      status = 1; \n      break; \n     case '}': \n      status = -1; \n     default: \n      status = -1; \n     } \n     break; \n    case 4: \n     if( c >= '0' && c <= '9' ) \n     { \n      status = 5; \n      temp.value.append(c); \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 5: \n     if( c >= '0' && c <= '9' ) \n     { \n      temp.value.append(c); \n     }else if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    case 6: \n    case 7: \n    case 8: \n     if(c == trues[status - 5]) \n     { \n      temp.value.append(c); \n      status++; \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 9: \n     if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    case 10: \n    case 11: \n    case 12: \n    case 13: \n     if(c == falses[status - 9]) \n     { \n      temp.value.append(c); \n      status++; \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 14: \n     if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    default: \n     status = -1; \n   } \n  } \n  System.out.println(type == 1 ? \"object\" : \"array\"); \n   \n  //print out the result \n  status = 0; \n  for(UniType un : array) \n  { \n   if(status < type) \n    System.out.print( un.getValue() + \":\"); \n   else \n    System.out.println(un.value.toString()); \n   status = 1 - status; \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void parseJSON() \n { \n  byte[] input = \"{\\\"a1\\\":\\\"abc\\\",\\\"t\\\":true,\\\"e\\\":123}\".getBytes(); \n  ArrayList array = new ArrayList(); \n  int type = 0;// 0 for array, 1 for object \n  int status = 0; \n  byte[] trues = \"true\".getBytes(); \n  byte[] falses = \"false\".getBytes(); \n  UniType temp = new UniType(); \n   \n  for(int i = 0; status!=-1 && i < input.length  ; i++) \n  { \n   char c = (char) input[i]; \n   switch(status) \n   { \n    case 0: \n     if(c == '{') \n      status = 1; \n     else \n      status = -1; \n     break; \n    case 1: \n     switch(c) \n     { \n      case ' ': \n       break; \n      case '\"': \n       status = 2; \n       temp.type = 1; \n       temp.value.append('\"'); \n       break; \n      case '+': \n      case '-': \n       temp.type = 0; \n       temp.value.append(c); \n       status = 4; \n       break; \n      case '0': \n      case '1': \n      case '2': \n      case '3': \n      case '4': \n      case '5': \n      case '6': \n      case '7': \n      case '8': \n      case '9': \n       temp.type = 0; \n       temp.value.append(c); \n       status = 5; \n       break; \n      case 'f': \n       temp.type = 2; \n       temp.value.append(c); \n       status = 10; \n       break; \n      case 't': \n       temp.type = 2; \n       temp.value.append(c); \n       status = 6; \n       break; \n      default: \n       status = -1; \n     } \n     break; \n    case 2: \n     if(c == '\"') \n     { \n      temp.value.append('\"'); \n      array.add(temp); \n      status = 3; \n      temp = new UniType(); \n     }else \n     { \n      temp.value.append(c); \n     } \n     break; \n    case 3: \n     switch(c) \n     { \n     case ':': \n      type = 1; \n     case ',': \n      status = 1; \n      break; \n     case '}': \n      status = -1; \n     default: \n      status = -1; \n     } \n     break; \n    case 4: \n     if( c >= '0' && c <= '9' ) \n     { \n      status = 5; \n      temp.value.append(c); \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 5: \n     if( c >= '0' && c <= '9' ) \n     { \n      temp.value.append(c); \n     }else if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    case 6: \n    case 7: \n    case 8: \n     if(c == trues[status - 5]) \n     { \n      temp.value.append(c); \n      status++; \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 9: \n     if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    case 10: \n    case 11: \n    case 12: \n    case 13: \n     if(c == falses[status - 9]) \n     { \n      temp.value.append(c); \n      status++; \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 14: \n     if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    default: \n     status = -1; \n   } \n  } \n  System.out.println(type == 1 ? \"object\" : \"array\"); \n   \n  //print out the result \n  status = 0; \n  for(UniType un : array) \n  { \n   if(status < type) \n    System.out.print( un.getValue() + \":\"); \n   else \n    System.out.println(un.value.toString()); \n   status = 1 - status; \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public void parseJSON() \n { \n  byte[] input = \"{\\\"a1\\\":\\\"abc\\\",\\\"t\\\":true,\\\"e\\\":123}\".getBytes(); \n  ArrayList array = new ArrayList(); \n  int type = 0;// 0 for array, 1 for object \n  int status = 0; \n  byte[] trues = \"true\".getBytes(); \n  byte[] falses = \"false\".getBytes(); \n  UniType temp = new UniType(); \n   \n  for(int i = 0; status!=-1 && i < input.length  ; i++) \n  { \n   char c = (char) input[i]; \n   switch(status) \n   { \n    case 0: \n     if(c == '{') \n      status = 1; \n     else \n      status = -1; \n     break; \n    case 1: \n     switch(c) \n     { \n      case ' ': \n       break; \n      case '\"': \n       status = 2; \n       temp.type = 1; \n       temp.value.append('\"'); \n       break; \n      case '+': \n      case '-': \n       temp.type = 0; \n       temp.value.append(c); \n       status = 4; \n       break; \n      case '0': \n      case '1': \n      case '2': \n      case '3': \n      case '4': \n      case '5': \n      case '6': \n      case '7': \n      case '8': \n      case '9': \n       temp.type = 0; \n       temp.value.append(c); \n       status = 5; \n       break; \n      case 'f': \n       temp.type = 2; \n       temp.value.append(c); \n       status = 10; \n       break; \n      case 't': \n       temp.type = 2; \n       temp.value.append(c); \n       status = 6; \n       break; \n      default: \n       status = -1; \n     } \n     break; \n    case 2: \n     if(c == '\"') \n     { \n      temp.value.append('\"'); \n      array.add(temp); \n      status = 3; \n      temp = new UniType(); \n     }else \n     { \n      temp.value.append(c); \n     } \n     break; \n    case 3: \n     switch(c) \n     { \n     case ':': \n      type = 1; \n     case ',': \n      status = 1; \n      break; \n     case '}': \n      status = -1; \n     default: \n      status = -1; \n     } \n     break; \n    case 4: \n     if( c >= '0' && c <= '9' ) \n     { \n      status = 5; \n      temp.value.append(c); \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 5: \n     if( c >= '0' && c <= '9' ) \n     { \n      temp.value.append(c); \n     }else if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    case 6: \n    case 7: \n    case 8: \n     if(c == trues[status - 5]) \n     { \n      temp.value.append(c); \n      status++; \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 9: \n     if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    case 10: \n    case 11: \n    case 12: \n    case 13: \n     if(c == falses[status - 9]) \n     { \n      temp.value.append(c); \n      status++; \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 14: \n     if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    default: \n     status = -1; \n   } \n  } \n  System.out.println(type == 1 ? \"object\" : \"array\"); \n   \n  //print out the result \n  status = 0; \n  for(UniType un : array) \n  { \n   if(status < type) \n    System.out.print( un.getValue() + \":\"); \n   else \n    System.out.println(un.value.toString()); \n   status = 1 - status; \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public void parseJSON() \n { \n  byte[] input = \"{\\\"a1\\\":\\\"abc\\\",\\\"t\\\":true,\\\"e\\\":123}\".getBytes(); \n  ArrayList array = new ArrayList(); \n  int type = 0;// 0 for array, 1 for object \n  int status = 0; \n  byte[] trues = \"true\".getBytes(); \n  byte[] falses = \"false\".getBytes(); \n  UniType temp = new UniType(); \n   \n  for(int i = 0; status!=-1 && i < input.length  ; i++) \n  { \n   char c = (char) input[i]; \n   switch(status) \n   { \n    case 0: \n     if(c == '{') \n      status = 1; \n     else \n      status = -1; \n     break; \n    case 1: \n     switch(c) \n     { \n      case ' ': \n       break; \n      case '\"': \n       status = 2; \n       temp.type = 1; \n       temp.value.append('\"'); \n       break; \n      case '+': \n      case '-': \n       temp.type = 0; \n       temp.value.append(c); \n       status = 4; \n       break; \n      case '0': \n      case '1': \n      case '2': \n      case '3': \n      case '4': \n      case '5': \n      case '6': \n      case '7': \n      case '8': \n      case '9': \n       temp.type = 0; \n       temp.value.append(c); \n       status = 5; \n       break; \n      case 'f': \n       temp.type = 2; \n       temp.value.append(c); \n       status = 10; \n       break; \n      case 't': \n       temp.type = 2; \n       temp.value.append(c); \n       status = 6; \n       break; \n      default: \n       status = -1; \n     } \n     break; \n    case 2: \n     if(c == '\"') \n     { \n      temp.value.append('\"'); \n      array.add(temp); \n      status = 3; \n      temp = new UniType(); \n     }else \n     { \n      temp.value.append(c); \n     } \n     break; \n    case 3: \n     switch(c) \n     { \n     case ':': \n      type = 1; \n     case ',': \n      status = 1; \n      break; \n     case '}': \n      status = -1; \n     default: \n      status = -1; \n     } \n     break; \n    case 4: \n     if( c >= '0' && c <= '9' ) \n     { \n      status = 5; \n      temp.value.append(c); \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 5: \n     if( c >= '0' && c <= '9' ) \n     { \n      temp.value.append(c); \n     }else if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    case 6: \n    case 7: \n    case 8: \n     if(c == trues[status - 5]) \n     { \n      temp.value.append(c); \n      status++; \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 9: \n     if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    case 10: \n    case 11: \n    case 12: \n    case 13: \n     if(c == falses[status - 9]) \n     { \n      temp.value.append(c); \n      status++; \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 14: \n     if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    default: \n     status = -1; \n   } \n  } \n  System.out.println(type == 1 ? \"object\" : \"array\"); \n   \n  //print out the result \n  status = 0; \n  for(UniType un : array) \n  { \n   if(status < type) \n    System.out.print( un.getValue() + \":\"); \n   else \n    System.out.println(un.value.toString()); \n   status = 1 - status; \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public void parseJSON() \n { \n  byte[] input = \"{\\\"a1\\\":\\\"abc\\\",\\\"t\\\":true,\\\"e\\\":123}\".getBytes(); \n  ArrayList array = new ArrayList(); \n  int type = 0;// 0 for array, 1 for object \n  int status = 0; \n  byte[] trues = \"true\".getBytes(); \n  byte[] falses = \"false\".getBytes(); \n  UniType temp = new UniType(); \n   \n  for(int i = 0; status!=-1 && i < input.length  ; i++) \n  { \n   char c = (char) input[i]; \n   switch(status) \n   { \n    case 0: \n     if(c == '{') \n      status = 1; \n     else \n      status = -1; \n     break; \n    case 1: \n     switch(c) \n     { \n      case ' ': \n       break; \n      case '\"': \n       status = 2; \n       temp.type = 1; \n       temp.value.append('\"'); \n       break; \n      case '+': \n      case '-': \n       temp.type = 0; \n       temp.value.append(c); \n       status = 4; \n       break; \n      case '0': \n      case '1': \n      case '2': \n      case '3': \n      case '4': \n      case '5': \n      case '6': \n      case '7': \n      case '8': \n      case '9': \n       temp.type = 0; \n       temp.value.append(c); \n       status = 5; \n       break; \n      case 'f': \n       temp.type = 2; \n       temp.value.append(c); \n       status = 10; \n       break; \n      case 't': \n       temp.type = 2; \n       temp.value.append(c); \n       status = 6; \n       break; \n      default: \n       status = -1; \n     } \n     break; \n    case 2: \n     if(c == '\"') \n     { \n      temp.value.append('\"'); \n      array.add(temp); \n      status = 3; \n      temp = new UniType(); \n     }else \n     { \n      temp.value.append(c); \n     } \n     break; \n    case 3: \n     switch(c) \n     { \n     case ':': \n      type = 1; \n     case ',': \n      status = 1; \n      break; \n     case '}': \n      status = -1; \n     default: \n      status = -1; \n     } \n     break; \n    case 4: \n     if( c >= '0' && c <= '9' ) \n     { \n      status = 5; \n      temp.value.append(c); \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 5: \n     if( c >= '0' && c <= '9' ) \n     { \n      temp.value.append(c); \n     }else if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    case 6: \n    case 7: \n    case 8: \n     if(c == trues[status - 5]) \n     { \n      temp.value.append(c); \n      status++; \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 9: \n     if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    case 10: \n    case 11: \n    case 12: \n    case 13: \n     if(c == falses[status - 9]) \n     { \n      temp.value.append(c); \n      status++; \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 14: \n     if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    default: \n     status = -1; \n   } \n  } \n  System.out.println(type == 1 ? \"object\" : \"array\"); \n   \n  //print out the result \n  status = 0; \n  for(UniType un : array) \n  { \n   if(status < type) \n    System.out.print( un.getValue() + \":\"); \n   else \n    System.out.println(un.value.toString()); \n   status = 1 - status; \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public void parseJSON() \n { \n  byte[] input = \"{\\\"a1\\\":\\\"abc\\\",\\\"t\\\":true,\\\"e\\\":123}\".getBytes(); \n  ArrayList array = new ArrayList(); \n  int type = 0;// 0 for array, 1 for object \n  int status = 0; \n  byte[] trues = \"true\".getBytes(); \n  byte[] falses = \"false\".getBytes(); \n  UniType temp = new UniType(); \n   \n  for(int i = 0; status!=-1 && i < input.length  ; i++) \n  { \n   char c = (char) input[i]; \n   switch(status) \n   { \n    case 0: \n     if(c == '{') \n      status = 1; \n     else \n      status = -1; \n     break; \n    case 1: \n     switch(c) \n     { \n      case ' ': \n       break; \n      case '\"': \n       status = 2; \n       temp.type = 1; \n       temp.value.append('\"'); \n       break; \n      case '+': \n      case '-': \n       temp.type = 0; \n       temp.value.append(c); \n       status = 4; \n       break; \n      case '0': \n      case '1': \n      case '2': \n      case '3': \n      case '4': \n      case '5': \n      case '6': \n      case '7': \n      case '8': \n      case '9': \n       temp.type = 0; \n       temp.value.append(c); \n       status = 5; \n       break; \n      case 'f': \n       temp.type = 2; \n       temp.value.append(c); \n       status = 10; \n       break; \n      case 't': \n       temp.type = 2; \n       temp.value.append(c); \n       status = 6; \n       break; \n      default: \n       status = -1; \n     } \n     break; \n    case 2: \n     if(c == '\"') \n     { \n      temp.value.append('\"'); \n      array.add(temp); \n      status = 3; \n      temp = new UniType(); \n     }else \n     { \n      temp.value.append(c); \n     } \n     break; \n    case 3: \n     switch(c) \n     { \n     case ':': \n      type = 1; \n     case ',': \n      status = 1; \n      break; \n     case '}': \n      status = -1; \n     default: \n      status = -1; \n     } \n     break; \n    case 4: \n     if( c >= '0' && c <= '9' ) \n     { \n      status = 5; \n      temp.value.append(c); \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 5: \n     if( c >= '0' && c <= '9' ) \n     { \n      temp.value.append(c); \n     }else if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    case 6: \n    case 7: \n    case 8: \n     if(c == trues[status - 5]) \n     { \n      temp.value.append(c); \n      status++; \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 9: \n     if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    case 10: \n    case 11: \n    case 12: \n    case 13: \n     if(c == falses[status - 9]) \n     { \n      temp.value.append(c); \n      status++; \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 14: \n     if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    default: \n     status = -1; \n   } \n  } \n  System.out.println(type == 1 ? \"object\" : \"array\"); \n   \n  //print out the result \n  status = 0; \n  for(UniType un : array) \n  { \n   if(status < type) \n    System.out.print( un.getValue() + \":\"); \n   else \n    System.out.println(un.value.toString()); \n   status = 1 - status; \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public void parseJSON() \n { \n  byte[] input = \"{\\\"a1\\\":\\\"abc\\\",\\\"t\\\":true,\\\"e\\\":123}\".getBytes(); \n  ArrayList array = new ArrayList(); \n  int type = 0;// 0 for array, 1 for object \n  int status = 0; \n  byte[] trues = \"true\".getBytes(); \n  byte[] falses = \"false\".getBytes(); \n  UniType temp = new UniType(); \n   \n  for(int i = 0; status!=-1 && i < input.length  ; i++) \n  { \n   char c = (char) input[i]; \n   switch(status) \n   { \n    case 0: \n     if(c == '{') \n      status = 1; \n     else \n      status = -1; \n     break; \n    case 1: \n     switch(c) \n     { \n      case ' ': \n       break; \n      case '\"': \n       status = 2; \n       temp.type = 1; \n       temp.value.append('\"'); \n       break; \n      case '+': \n      case '-': \n       temp.type = 0; \n       temp.value.append(c); \n       status = 4; \n       break; \n      case '0': \n      case '1': \n      case '2': \n      case '3': \n      case '4': \n      case '5': \n      case '6': \n      case '7': \n      case '8': \n      case '9': \n       temp.type = 0; \n       temp.value.append(c); \n       status = 5; \n       break; \n      case 'f': \n       temp.type = 2; \n       temp.value.append(c); \n       status = 10; \n       break; \n      case 't': \n       temp.type = 2; \n       temp.value.append(c); \n       status = 6; \n       break; \n      default: \n       status = -1; \n     } \n     break; \n    case 2: \n     if(c == '\"') \n     { \n      temp.value.append('\"'); \n      array.add(temp); \n      status = 3; \n      temp = new UniType(); \n     }else \n     { \n      temp.value.append(c); \n     } \n     break; \n    case 3: \n     switch(c) \n     { \n     case ':': \n      type = 1; \n     case ',': \n      status = 1; \n      break; \n     case '}': \n      status = -1; \n     default: \n      status = -1; \n     } \n     break; \n    case 4: \n     if( c >= '0' && c <= '9' ) \n     { \n      status = 5; \n      temp.value.append(c); \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 5: \n     if( c >= '0' && c <= '9' ) \n     { \n      temp.value.append(c); \n     }else if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    case 6: \n    case 7: \n    case 8: \n     if(c == trues[status - 5]) \n     { \n      temp.value.append(c); \n      status++; \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 9: \n     if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    case 10: \n    case 11: \n    case 12: \n    case 13: \n     if(c == falses[status - 9]) \n     { \n      temp.value.append(c); \n      status++; \n     }else \n     { \n      status = -1; \n     } \n     break; \n    case 14: \n     if(c == ',') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = 1; \n     }else if(c == '}') \n     { \n      array.add(temp); \n      temp = new UniType(); \n      status = -1; \n     }else \n      status = -1; \n     break; \n    default: \n     status = -1; \n   } \n  } \n  System.out.println(type == 1 ? \"object\" : \"array\"); \n   \n  //print out the result \n  status = 0; \n  for(UniType un : array) \n  { \n   if(status < type) \n    System.out.print( un.getValue() + \":\"); \n   else \n    System.out.println(un.value.toString()); \n   status = 1 - status; \n  } \n }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=3743299","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"7","title":"You bought a carpet of size n*n, and when you got home you found it has white spots, and black spots (You don't know if it's a white carper with black spots, or a black carpet with white spots). A spot is one or more of the n*n 'cells', or the same color, with either a common side or a common corner. The 'original color' is that of which there are more spots. for example: - if the carpet is all white, with a black circle in the middle, it's either black or white (as there is one white spot and one black spot) - if the carpet is all white with a black, side to side, stripe in the middle, the carpet is white (as there are two whites, and one black spot) - if it's a 'chessboard' pattern, it's again 1:1 (as each white has a common corner with another white...)  write a function:   int getOriginalColor(boolean[][])  that would return 0 for white, 1 for black, 2 for tie","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This question is too confusing to understand w/o a diagram :-)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Try region merging algorithm."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This looks like finding connected components in a graph. Make each cell a node, its neighbours (with common side) are connected with edges, only if they have same color. Use DFS/BFS -- O(V+E) -- to find the number of connected components and their color. Count numbers of each type and report."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"just wondering, is this an interview question for UI engineer position? or the front end (grwoth) engineer position?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// Algorithm: For each color find the number of connected components where a connected component includes all cells that can be reached through same color. // Use a variation of flood fill algorithm to find connected components // Map black color to 1 (true) and white to 0 (false)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would use the simple colouring algorithm to find all the components (merging components if they have different marks but same color), and then just sum all components of the given colours considering merged ones.  A bit messy and JS, so sorry  {{ function getOriginalColor(carpet) {   var cell = 0;   var markCell = new checker();   for(var i = 0; i < carpet.length; i++) {     for(var j = 0; j < carpet[i].length; j++) {       markCell.check(i, j, carpet);     }   }   var white = markCell.sum(true);   var black = markCell.sum(false);   if(black == white) {     return 'white';   }   if(black > white) {     return 'black';   } else {     return 'white';   } }  function checker() {   this.cell = 0;   this.coloredComps = []; }  checker.prototype = {    sum: function(color) {     var sum = 0;     for(var i = 1; i < this.coloredComps.length; i++) {       if(this.coloredComps[i].color === color) {         if(!this.coloredComps[i].merged) {           sum++;         } else if(this.coloredComps[i].merged > i) {           sum++;         }       }     }     return sum;   },    mergeable: function(a, b) {     if(a == b) {       return false;     }     return this.coloredComps[a].color === this.coloredComps[b].color ? true : false;   },    merge: function(a, b) {     this.coloredComps[a].merged = b;     this.coloredComps[b].merged = a;   },    check:function(i, j, carpet) {     [[i - 1, j], [i - 1, j - 1], [i - 1, j + 1], [i, j - 1]].forEach(function(cs) {       var ii = cs[0];       var jj = cs[1];       if(ii >= 0 && ii < carpet.length && jj >= 0 && jj < carpet[ii].length) {         if(typeof carpet[i][j] === 'number' && this.mergeable(carpet[ii][jj], carpet[i][j])) {           this.merge(carpet[ii][jj], carpet[i][j]);           return;         }         if(this.coloredComps[carpet[ii][jj]].color === carpet[i][j]) {           carpet[i][j] = carpet[ii][jj];         }       }     }.bind(this))     if(typeof carpet[i][j] !== 'number') {       this.cell++;       this.coloredComps[this.cell] = { color: carpet[i][j] };       carpet[i][j] = this.cell;     }   } } }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"JavaScript"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=3697708","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"9","title":"Say you need to design a web application which needs to support friends of  friends function(like in linked in, when you search a person, it will show  you if this person is linked with you, your connection or your connections'  conection...), we expect to have millions of users and each user may have  thousands of friends, how would you design/implement this function to make  it scalable.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"If we start the search from both source and destination, then search could be minimized.  Assumption is all the friends list are stored in a sorted  order. To find whether A and B are at 2 distance away, get the list of friends of both A and B. Find whether any duplicate elements in the list. Complexity is O(n).   Finding whether A and B is 4 distance away - merge all friends of friends list. And check duplicates in the list. Complexity is O(n^2) {Merging O(n^2) and searching O(n^2)}  Thus complexity will be  1 level depth - O(logn) {Binary search} 2 level depth - O(n) 4 level depth - O(n^2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if user A is logged in an searches for user B, start by searching user A's friends, and friends of friends of user A... the complexity is huge O(n^k) where k is number of levels of friends you want to search. you can make the friend search faster, by having a hash table for each user that returns whether a name is the user's friend. This takes up huge memory, as each of the thousands of users will have a hash table, but complexity of searching at each level is reduced to 1. So search order will be O(k) where k is number of levels you want to search.  any other ideas?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can have a hashMap for friends which will hold the emailid(any unique id) as key and the reference(userid or db key) to user as value. Advantage we can lookup to see whether the target person is the friend of the user or not(null as lookup return value). Thus we can reduce it to something like BFS in a graph. alongwith this we can pass a cutoff value(the maximum level till where it will lookup). this cutoff value will keep on decreasing and at 0 we will stop our search. In this way we can avoid handling loops and will be having valid exit point for the algorithm. We can store the result (friend path from one user to another) whenever we have found the target user. It will also handle multiple friend ways (as we are doing BFS and only exit point is the level cutoff)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"assign a int ID to each user. Each user has a list of sorted IDs as the friend list. To find whether A and B are connected, the worst case will be (n^k)*lgn (where n is the number of friends for one user and k is the levels to search). Compared with the hash table solution, this one has worse time scalability but better space scalability."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=3532731","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"Design Farmville,  Consider only crops and animals for now.   Whats classes will you have? How will you handle interactions between various objects? What design patterns can you use?  How will you handle millions of users?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"As PM for Farmville my first order of business would be to shut the project down and return millions of stay at home mothers to their children."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=3392682","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"3","title":"How will you design the backend for facebook. To handle millions of users. Explain the following transactions 1) Adding/Deleting a friend 2) Friend suggestions  What if you cannot store all users on one server?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Link profiles together forming trees. Or linking nodes in Graph Matrix.  2) Friend suggestions can be made a) If the given node is not already a friend b) has a distance of 2 from the current Node c) Has Maximum distinct routes of length 2 between them compared to other nodes  (Or has maximum common friends between them)   3) Make country specific or geographic servers for users. Since friends tend to be geographically co-located."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For friends using Graphs as data structures seem a better option. hence forth referred to a YY.  1) Adding a friend needs an approval process, hence once someone adds X as a friend; we send an invite to X that you are interested. It means, updating the cache layer (so that you don't end up inviting the same person more than once) plus DB that an invite has been sent.  Deleting on the other hand has to instantaneously make changes to YY. Probably notify the friend that he has been deleted from your friend list.  2) Friend suggestions - is basically recommendations.     -> maybe you are from the same school/college/workplace etc. (distance 2)     -> maybe friends of friends from same school/college/workplace etc. (distance 2)     -> maybe you are a friend of your very popular friend.     -> import email addresses from your Gmail or other mail accounts. As one can see all this recommendation list can be done offline & needs to be accessed when the user logs in.   3) Point mentioned by Akshat seems ok here.   In Facebook's infrastructure ALL (or most of it) exists in cache (i.e. RAM) for faster access. So one of the biggest challenges is to sync data between this cache layer & the actual mysql DB."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"How about just using a database?  Have one table for users and another for user details which will include friends and their details..."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=3171670","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"Given a 2D-grid map with several obstacles such as walls, doors and ones with other shapes, use A* algorithm to give the robot a path from point A to point B with fewest turns. Probability might be used in this problem.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Don't have the faintest idea how probability can be used in an A* problem, but here is an admissible heuristic:  I assume that the robot always goes 1 unit in the direction it's heading, and at each node of the grid we have the options of turning or not turning. I'm assuming the robot can turn only 90 degrees at each time (the heuristic can be modified according to the changes in this assumption):  - If the robot is currently heading on a Manhattan path from its current point to the point B, then check whether there are any obstacles on this Manhattan path. If there isn't, then let the heuristic return 1. If there is, let the heuristic return 2 (obviously, the robot cannot go straightly on the Manhattan path, it will require extra maneuvers). - If the robot is currently NOT heading on a Manhattan path from its current point to the point B, then it means that it's currently getting away from B. It will require at least 2 turns to enter a course approaching B. So a naive heuristic function may give only 2 in this situation (a better one can be designed to take the possible Manhattan paths after turnings into account, but my brain is exhausted by now. Maybe later I can come up with one)."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=413784","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"Implement copy-on-write string class.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Could you give some more details?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how about this implementation?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=405592","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"18","title":"Take a tree (binary or otherwise), write a method in any language that, when given the root node, will print out the tree in level order. With a new line after the end of every level.   Helper methods are ok, big O run time efficiency doesn't matter (though obviously a quicker solution is better). Do not destroy original tree.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Just do a bfs. but put a \"marker\" data in the queue to signal end of level. Pseudo code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"breath-first + a hashtable"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void printNodesByLevel(Node tree) { \nQueue parentQ, childQ; \nparentQ.enqueue(tree); \nwhile(true) { \n if(parentQ.isEmpty() && childQ.isEmpty()){ \n   break; \n } \n if(parentQ.isEmpty() && !childQ.isEmpty()){ \n   System.out.println(\"\\n\"); \n   Queue tmpQ = parentQ; \n   parentQ = childQ; \n   childQ = tmpQ; \n }  \n Node tmp = parentQ.dequeue(); \n System.out.println(tmp.data+\" \"); \n NodeList children = tmp.getChildren(); \n for(int i = 0; i < children.length; i++) { \n  childQ.enqueue(children.get(i)); \n } \n} \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"real c/c++ codes with one queue and marker"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void tree_level_traversal(node *root) {  node *temp = NULL;    if(root == NULL)   return;   /* Need a Q to do BFS */   initilizeQ();  pushQ(root);  pushQ(-1);  while(FALSE == is_Qempty())  {   temp = popQ();   if(temp == -1)   {    printf(\"\\n\");    continue;   }   printf(\"%4d\", temp->data);   if(temp->lchild != NULL)    pushQ(temp->lchild);   if(temp->rchild != NULL)    pushQ(temp->rchild);   pushQ(-1);  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"No need of the marker, just count."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void breadthfirstprint(node *root) {         int prevlevel,nextlevel;         Queue q;         prevlevel=nextlevel=0;         if(root==NULL)                 return;         q.enqueue(root);         prevlevel++;         while(!q.isempty())         {                 node *temp = q.dequeue();                 prevlevel--;                 cout<value<<\"\\t\";                 if(temp->left!=NULL)                 {                         q.enqueue(temp->left);                         nextlevel++;                 }                 if(temp->right!=NULL)                 {                         q.enqueue(temp->right);                         nextlevel++;                 }                 if(prevlevel==0)                 {                         cout<<\"\\n\";                         prevlevel=nextlevel;                         nextlevel=0;                 }         }         return; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"just have a helper class"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think I have a much better solution:  vector  q; long n; btree * node;    q.push_back(bt.troot);    while(q.size())    {      n = q.size();      while(n--)       {         node = q.front();         cout << node->info <<\"\\t\";         if(node->left)q.push_back(node->left);         if(node->right)q.push_back(node->right);         q.erase(q.begin());       }       cout << endl;    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//C# using System; using System.Collections;  class Node {     public int value;     public Node leftNode;     public Node rightNode;     public Node(int _value)     {         value = _value;     } }  class BinarySearchTree {     Node rootNode;     Queue[] printQueue;      public BinarySearchTree(int _value)     {         rootNode = new Node(_value);     }      public void add(int _value)     {         addRec(rootNode, _value);         printQueue = new Queue[maxDepth(rootNode)];         for (int i = 0; i < maxDepth(rootNode); i++)         {             printQueue[i] = new Queue();         }     }      public void addRec(Node _node, int _value)     {         if (_node == null) return;          if (_value < _node.value)         {             addRec(_node.leftNode, _value);             if (_node.leftNode == null)             { _node.leftNode = new Node(_value); }          }         else if (_value >= _node.value)         {             addRec(_node.rightNode, _value);             if (_node.rightNode == null)             {                 _node.rightNode = new Node(_value);             }         }     }      public void print()     {         printQueue[0].Enqueue(rootNode.value);         BreadthFirst(rootNode, 1);          for (int i = 0; i < printQueue.Length; i++)         {             while (printQueue[i].Count != 0)             {                 Console.Write(printQueue[i].Dequeue());             }             Console.WriteLine();         }     }      public void BreadthFirst(Node _node, int _level)     {         if (_node == null) { return; }         if (_node.leftNode != null)         {             printQueue[_level].Enqueue(_node.leftNode.value);         }         if (_node.rightNode != null)         {             printQueue[_level].Enqueue(_node.rightNode.value);         }         ++_level;         BreadthFirst(_node.leftNode, _level);         BreadthFirst(_node.rightNode, _level);     }      public int maxDepth(Node root)     {         if (root == null) { return 0; }          return 1 + Math.Max(maxDepth(root.leftNode), maxDepth(root.rightNode));     }  }  class Program {     static void Main(string[] args)     {         BinarySearchTree myTree = new BinarySearchTree(6);         myTree.add(4);         myTree.add(5);         myTree.add(8);         myTree.add(2);         myTree.add(9);         myTree.add(11);         myTree.add(10);         myTree.print();         Console.Read();     } }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=386151","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"15","title":"Write code for finding length of largest monotonically increasing sequence in an array of integers. Optimize it (not the usual O(n) in worst case, but a better approach in average case).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"As far as i can think i will map it to LCS problem. In order to do so reverse the given sequence and find the longest common subsequence between the duo. Now, since the LCS problem can be solved using DP in O(n*m), one can say this would take O(n*m). But question says \"not the usual O(n) in worst case,\" i dont know whether a O(n) is possible also? If it is can somebody suggest the algo?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if (a[i]{num++; max=num>max ? num: max; } else num=0;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have some hunch on that we can divide and conquer like from the middle element look for the spread on both sides and not the length of longest sequence. Then consider the remaining parts not explored and only when the length of the current maximum is less then the length of the remaining part."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"could potentially skip some of the numbers in the scan. worst case is the same, but on avg will be a little better, but still O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"find first best seq; lets say length is bLen; \ncompare a[2*bLen] with a[2*bLen +1];  \nIf 1st is bigger than 2nd  \n    [Step A] you don't need to look at bLen to 2*bLen -1; again compare a[3*bLen +2] and [3*bLen+3] and so on \nElse  \n    check a[bLen] to a[2*bLen] is monotonically increasing. \n    If it is increasing \n        set new bLen to the next best length we just found \n    Else \n        Goto [step A] with starting index as where the monotonically increasing broke."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Don't know how to get faster than O(n). Please put a working function if you do. Here are two possible solutions:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I doubt it can be O(n). My dynamic programing solution takes O(n^2):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i have a rough idea if the current longest sequence is of length N, then one can skip N/2 ahead, and check subsequence of length N/2 there."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it is O(n) solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A simple implementation"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=220755","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"24","title":"Write a program to find the square root of a given number.   He wanted some kind of binary search.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"http://en.wikipedia.org/wiki/Square_root  \"Babylonian method\" or \"Heron's method\" after the first century Greek philosopher Heron of Alexandria who first described it. It involves a simple algorithm, which results in a number closer to the actual square root each time it is repeated. To find r, the square root of a real number x: 1) Start with an arbitrary positive start value r (the closer to the square root of x, the better). 2) Replace r by the average between r and x/r, that is:  (It is sufficient to take an approximate value of the average in order to ensure convergence.) 3) Repeat step 2 until r and x/r are as close as desired. The time complexity for computing a square root with n digits of precision is equivalent to that of multiplying two n-digit numbers.  I think this is what the interviewer was looking for..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Suppose you have an array of numbers 1 to n/2 (where n is the number that you want to find the square root of). Then start scanning the numbers in the array to see which square will give you n. The search for that number can be done in a binary manner where you start with an item in the middle of the array and if its square is smaller than n, you move \"upward\" and if it is bigger than n, you move \"downard\" in a binary manner. Does that make sense?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"you have to take into consideration that a sq root of 8 will be 2.828427124.  How you going to take decimals into consideration? Some will be forming loops too.  Correct me if i m wrong."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"so basicly we are try to solve equation:  x^2 = A   -->  intersection b/t x axis and the curve of y = x^2 - A   the idea is, starting at any x[i], find y(x[i]) = x[i]^2 - A, then draw a tangent line from the point (x[i], x[i]^2-A), find the intersection b/t this tangent line and axis, the intersection will be x[i+1]...  You work out the simple math, and you'll find this method the identical to the above wiki answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This does a binary search from 0 to n."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"w.r.t the last response, the sub-question to this would probably be about the finer details of floating point comparisons."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think Sameer's answer is simple and that is what interviewer is looking for."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Count the number of bits (O(1) with a predefined array) from the leftmost bit-1 and store in Aprox. now divide Aprox by 2 and store in Aprox. and use the babylonian method. I think that is the binary thing they where looking for, to find an approximation."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is the algorithm in sameer's post some known algorithm to computer sqrt? Why does he use sqrt= n/d as the approximate sqrt in the attempts to find sqrt and does not simply use \"d\" as the approx value - it's binary search either way after all?  Please explain."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think it just depends on how exactly the number you want :D"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"like this:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Right Anonymous, you are using \"mid\" as the approximate sqrt in any given iteration. But, that is not what sameer does in his post (i suspect due to some valid reason) - what he does is use s/d (same as x/mid as the aaproximate sqrt in any iteration).  Can anyone explain this?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"cant u make use of newton raphson method x=n; while((x1-x)==0) { x1=.5*(x+n/x); x=x1; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def binsearch_sqrt(x,t): \n    \"\"\" \n    inputs: \n    x - number to square-root \n    t - tolerance or size of range containing x \n    r - range containing x \n    output: a range containing x and satisfying tolerance t  \n    \"\"\" \n    def recurse(r): \n        s = r[1]-r[0]  \n        if  s < t: \n            return r \n        p = r[0] + s/2 \n        return recurse((p,r[1]) if p**2 < x else (r[0],p)) \n    return recurse((0,x)) \nprint(binsearch_sqrt(13,0.00001)) \n# output: (3.6055493354797363, 3.605555534362793)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"float squareRoot (float dest, float a, float b, float precision) {      float mid = (a+b)/2;      if ((b-a)     if (mid*mid < dest) return squareRoot (dest, mid, b, precision);   else return squareRoot (dest, a, mid, precision);     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"great post as usual!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"yes, newton raphson method is good solution,  double sqrt(double n){  double x1=n;   double x;  do {   x=x1;   x1=.5*(x+n/x);    } while (fabs(x-x1)>1e-10);   return x; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's the simplest/cleanest I could get it to:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Newton's approximation is probably faster."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static double GetSqRoot(int n)         {             double r = n / 2;              while (Math.Abs((n - Math.Pow(r, 2))) > 0.5)             {                 r = (r + (n / r)) / 2;             }             return r;         }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=155663","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"24","title":"Has anyone tried this? http://www.facebook.com/careers/puzzles.php?puzzle_id=11  The brute force way is n! so definitely won't scale. I tried a little bit of pruning (where I keep track of expected time and as soon as I see that it's more than then current minimum expected time, I bail out). But other than that, can't think of any..  So here is I have uptill now: for all permutations of possible paths:  find expected time for that shortest path  if (there is a path) and (expected time < min expected time)    minexpectedtime = expectedtime.  Can someone give me hints on pruning? I think I need a better way than going through all the permutations but am unable to think? Any help on algorithms/pruning/datastructure would be appreciated..","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simple. Find minimal spanning tree for the graph. Then check the expected time. This should do the trick."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"He He my mistake. Agreed LOLer. Loved the statement **(Try thinking about what you write, once in a while).** :D . Actually I thought - but wrongly.  Min span tree still works - come to think about it - in case any vertex with p=0 is removed, unless there is a connectivity issue in the graph.  [Also I said *should*. I never said - \"It did\". :( But yes - u do have a point. I should have said \"MAY\".]    Can you please add the constraint - and give me another example?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This time me, Sidious,Padme and Yoda all sat together and thought about it. No kidding :( Looks like the issue is: 1. \"All the vertex with non zero probability we need to traverse\". 2. \"Also minimize the path weight\" Hence -  \"Find a path with minimal weight so that it goes through the vertex which are having non zero probability\"   @LOLer -->Is the above a proper formulation? Sorry for being a dumb :( for the 1st time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This should do the trick. http://mathworld.wolfram.com/ChinesePostmanProblem.html **A problem asking for the shortest tour of a graph which visits each edge at least once (Kwan 1962; Skiena 1990, p. 194).**  http://www.uclic.ucl.ac.uk/harold/cpp/CPP.java  [Whops - a days end] [Was not simple to find even.]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is what I feels 1. Starts from first node 2. Its a complete graph  lets say we have solution for 2 nodes We can find out quickly which node to start in case of 2 nodes  Now adding a third node means only including it in any of the 3 positions 3-2-1 or 2-3-1 or 2-1-3. Earlier order need not be affected because it is already optimal and new addition wont change the order as the tree is complete  I guess we can keep on adding new nodes n*n*n maximum ........"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would rephrase the problem this way:  Given a graph (V,E) where V = the set of all vertices and E = the set of all edges between them.   To each edge E(v1,v2) assign weight = P(v2) * t(v1->v2).   Now, given a starting vertex V, produce a traversal order of the graph such that the vertices with non-zero probability are visited at least once and the weight of the traversal is minimized."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I've solved this one and DP+DFS will be enough to solve this puzzle. Good luck."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Isn't it a general case of TSP? (If assign same probability for every node). NP-Complete therefore? Did I miss anything here?  Two tricks I will do:  1. Use some heuristic function to get near minimal at the beginning.  2. Run \"All pairs short path\" at the beginning and store the result. So calculating cost for every possible permutation might be improved."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The problem can be simplify as finding a walk of the Graph, that traverse all the nodes while minimize the sum of di*pi, where pi is the possibility and di is the distance of the walk from the source. I do not think it is a P complete problem as it is even more complicate than the mail man problem, which, as far as I can remember, is a NP-complete issue."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"apply greedy algo with probbality/distance as a key at each vertex"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The probem of finding the minimum cost k intermediate nodes between source s and destination d can be solved with following DP formulation        V(k) = Min( V(k-1) + P(k)*DkDk-1)  This simply means if there is path with k-1 length then the path of k  length for any given node exists provided there is path  from that node to end node of k-1 path. Also taking the min cost for k intermediate node to get optimal path.   Now the problem remains is what to choose for source s and destination d. We dont know !  so apply above algorithm for each possible s and d  for(i = n0; i < nn; i++)  for(j = i+1; j < nn; j++ ) //to avoid duplicates like ij, ji start from j=i+1           V(k) = Min( V(k-1) + P(k)*DkDk-1)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=134810","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"18","title":"User Bin Crash  You are on a cargo plane full of commercial goods when the pilot announces that the plane is short on fuel. Unless cargo is ejected from the plane, you will run out of fuel and crash. The pilot provides you with the number of pounds of weight that must be ejected from the plane. Fortunately, the manifest of the plane is both completely accurate, digitized, and you are a programmer of some repute. Unfortunately, your boss is going to be extremely unhappy, and wants you to exactly minimize the losses to the absolute minimum possible without crashing the plane. The manifest does not contain the exact quantities of every type of good, because you have so many on board. You may assume that you will not run out of any good in the course of saving the plane. You also realize this kind of program could be handy to others who find themselves in similar situations.   Write a program that takes a single argument on the command line. This argument must be a file name, which contains the input data. The program should output to standard out the minimum losses your boss will incur from your ejection of goods (see below). Your program will be tested against several manifests of several crashing planes; each with different data. Additionally, your program must be fast, and give the correct answer.    Input specifications  The input file will start with an integer number indicating the minimum number of pounds of weight that must be ejected from the plane to prevent a crash, followed by a new line. Each additional line in the file represents a commercial SKU (stock keeping unit) along with its cost (in dollars) and weight (in pounds). The format of these lines is:      SKUs are represented as a combination of letters (upper and lower case) and numbers. Both costs and weights are integers. Each piece of data in a line is separated by white space. Lines are separated by a single new line character. You are guaranteed your program will run against well formed input files.   Example input file: 1250 LJS93K       1300       10500 J38ZZ9       700        4750 HJ394L      200        3250 O1IE82      75         10250    Output specifications  Your boss is not interested in exactly what you ejected to save the plane, he/she is currently only interested in how much it will cost the company. Your program must find the set of goods that will prevent the plane from crashing, and minimize company losses. It should print out the total value of goods lost as a plain integer, followed by a newline. Do not insert commas or dollar signs.   Example output (newline after integer): 9500","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is one of the best puzzles i had seen uptill date"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Isn't this the unbounded knapsack problem, which is NP Hard?  There are greedy (approximation) algorithms: eg: just use the sku with least cost per unit weight, but that won't give optimal (hence an approximation algorithm).  A lot of literature on these problems exists, just look it up on the web."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Of course, the assumption is that you can pick only an integer numnber of SKUs to be chucked and the input gives the weight and cost of 1 such unit."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Someone has added this to the \"Request for Help\" Section. Why? LOLer post's answer this. How much spoon feeding do you need?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Yes. Bounded knapsack suits this. Do some looking up on the web."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Dynamic programming."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Dynamic programming. I've passed the Facebook robot."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I also think it is NP-Complete. Integer linear programming?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"any hints on approaches to take? Sort the SKUs by cost first? by weight?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"They asked me to discuss about how to solve this problem .."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"All these lengthy description points to knapsack problem I guess :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Dynamic Programming"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Awesome!! This is valid question in linux world :-)   called out of memory problem .. google for it (oom killer)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can we drop partial items or we have to drop the complete item?  Because if we are allowed to drop partial item this problem becomes a variant of fractional knapsack, which can be solved by greedy algorithm."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I had some very similar question at my Amazon on-site interview too."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  #include  #include  #include  #include   using namespace std;  int main(){  int W;  cin>>W;  int n;  cin>>n;  int c[n+1], w[n+1];  int s=0;  for(int i=1;i<=n;++i){   cin>>w[i]>>c[i];   s+=w[i];  }  long long int dp[s+1][n+1];  for(int i=0;i<=n;++i){   dp[0][i]=0;  }  for(int i=1;i<=s;++i){   dp[i][0]=INT_MAX;  }  int f=0;  long long int ans=INT_MAX;  for(int i=1;i<=s;++i){   for(int j=1;j<=n;++j){    dp[i][j]=min(dp[i-w[j]][j]+c[j], dp[i][j-1]);   }   if(i>=W && dp[i][n]!=INT_MAX){    f=1;    ans=min(ans, dp[i][n]);    //break;   }  }  cout<< return 0; }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=100820","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"26","title":"Compute the square root of a function","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Correction: Write a function to compute the square root of an integer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"double squareroot(double num) {     double number;     number =num/2; do  { number=(number+num/nuber)/2 } while (number*number-num >0.00001)  return number; }           }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A simple way to compute the sqrt is by adding the odd numbers till it becomes greater than that number. so, 1 + 3 <= 4. So, we count the number of times we do this operation. likewise, sqrt (9) would be 1 + 3 + 5. So, it would be 3. Here's how this looks."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@Balaji  Awesome solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Balaji's function is too limited. The question was to write a function to compute sqrt of an INTEGER. That means, if input is 2, answer should be 1.4142...  Above function doesnt do that... For 8 it'll compute 3 for example."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The take away is to use the strategy of sum of odd number is a square number. We can easily extend this strategy to right shift the number by two places, and performing the same operation till we achieve recurring / temination decimal number."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* SQUARE ROOT */ \n \n#include \n#include \n \nusing namespace std; \n \ndouble sqrt(int k) \n{ \n       double lo=0,hi=1e10; \n       double mid=(lo+hi)/2; \n        \n       while(abs(mid*mid-k)>1e-9) \n       { \n              \n                                     \n                       if(mid*mid"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"pity on you guys :-( so many crappy posts...we should ask admin people to block these crappy posters once n for all..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"code for square root:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"float sqroot(float m) \n{ \n   float i=0; \n   float x1,x2; \n   while( (i*i) <= m ) \n      i+=0.1; \n   x1=i; \n   for(int j=0;j<10;j++) \n   { \n      x2=m; \n      x2/=x1; \n      x2+=x1; \n      x2/=2; \n      x1=x2; \n   } \n   return x2; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* C implementation of http://en.wikipedia.org /wiki/Methods_of_computing_square_roots#Rough_estimation */  #include  #include    int rough_estimate(int r) {         int     i = 1,d = 0,n,val;          while (r > i) {                 i += i*10;                 d++;         }           if ( (d % 2) == 0) {                 /* d is even */                 n = (d - 2)/2;                 val = 6*pow((float)10,(float)n);         } else {                 /* d is odd */                 n = (d - 1)/2;                 val = 2*pow((float)10,(float)n);         }          return val; }  main() {         int     v,j;         int     arg=30000;         float   v1;          v = rough_estimate(arg);          v1 = (float)v;         for (j = 0; j < 10; j++) {                 v1 = (v1 + arg/v1)/2;         }          printf(\"Square root of %d = %f\\n\",arg,v1);         printf(\"Square root of %d = %f\\n\",arg,sqrt(arg)); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"java implementation.  public class SquareRoot {  public SquareRoot() {}    public double computeSquareRoot(int value) {   double start = 0.0;   double end = value;   double middle = (start+end)/2;   double minError = 0.00001;   double error = middle*middle-value;      while(Math.abs(error) > minError) {    if(error < 0) start = middle;    else if(error > 0) end = middle;    middle = (start+end)/2;    error = middle*middle-value;      }      return middle;  }    public static void main(String[] args) {   SquareRoot sr = new SquareRoot();   double root = sr.computeSquareRoot(12);   System.out.println(root);  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Mr Googler apart from contributing junk to this thread what have you contributed. Shut off from this board."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I see sth here:codinggeeks.blogspot.com/2010/04/computing-square-cube-roots.html  Is this the optimal solution?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hero's Java code is perfect."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"C# version: static double Sqrt(double value) {     const double Threshold = 0.0000001;      if (value < 0)     {         throw new ArgumentOutOfRangeException(\"value\");     }      double min = 0, max = value;     while (true)     {         double mid = (min + max) / 2;         double diff = mid * mid - value;         if (Math.Abs(diff) <= Threshold)             return mid;          if (diff > 0)             max = mid;         else             min = mid;     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This will return the more accurate square root. If we increase round() function precision, output will be tuned better.        double sqrt(double num)         {             double x = num / 2;             while (Math.Round(x, 7) != Math.Round(((x + num / x) / 2), 7))                 x = (x + num / x) / 2;              return x;         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"double Sqrt(double n) \n{ \n double x1=n;  \n double x; \n do \n { \n  x=x1; \n  x1=.5*(x+n/x);  \n }while (fabs(x-x1)>1e-10); \n \n return x; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"double sqrt (double a) {    if (a <= 0) {     return a;   }    double s = a / 2;   double t;   do {     t = s;     s = (s + a / s) / 2;   }   while ( (t - s) > 1e-10 );    return s; }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=102744","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"27","title":"shuffle an array of size n such that each element has 1/n probability to remain in its original spot. The best solution has O(n) complexity.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"// k is a random number between 0, i. Prob = 1/(i+1) // Total Prob = 1/(1 * 2 * ... * N) = 1/(N!)  // this makes the shuffle to be uniformly randomly selected from the possible N! permutations of the array. void knuth_shuffle( int * array, int size ) {  for ( int i = size - 1; i >= 0; i++ )  {   int k = (int)(rand() * i);   swap( &array[i], &array[k] );  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void shuffle(Element* array, int size??{ \n    for (int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why don't people try proving their algorithms?  btw, lookup fischer yates shuffle."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about rotating left by one position with a probability of 1/n?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void shuffle(Element* array, int size??{ \n    for (int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about making the new index as: 1) Generate a random no. 'r' initially once 2) Make new_index = (old_index + r)%n"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think it does. Iterate through all the cards, for every card, swap it with a random card that has not been visited yet. So, random will run from i + 1 to card count - 1 where i is the current position."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Generate a random number k between 1 and n and rotate the array to the left (or right) k times.  This way each element has a 1/n probability of remaining there"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Manish - your solution just wont work. When, k=1,2,3, none of the elements will be in its original position. When k=4, all elements will be in their original position, which is the only case when it works. So, the probability isn't 1/n."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"there are n! of permutations. Let us numbering them from 1 to n! and select 1 random number between 1 and n! (inclusive), and call this k, so kth permutation of this current array will be the result after shuffle."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@emotionalBlind I guess you are referring to the Knuth shuffle, which I believe is correct."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int* shuffle_array(const int* nArray, const int nSize) {  int* p = new int(nSize);  //float a = rand();  for (int i = 0; i < nSize; i ++) {   float a = rand();   int n = a*(i+1);   swap(p[i], p[n]);  }  return p; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Dudes...  The knuth shuffle is not order n. It's n^2."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how about : 1. loop through each number in the given array 2. for each element at index i, generate a random number between 1 and n. if the number is same as i (the probability of this happening is 1/n), the number needs to swapped out. hence save this index using a temp variable (say last_element_to_be_swapped). 3. now continue with the next element and perform step 2. if it needs to swapped out, swap it with last_element_to_be_swapped. save the current index to last_element_to_be_swapped so that we can swap for further iterations.  As long as we find two elements that needs to be swapped, we are good. The only exception is when we only find one element that needs to be swapped, then we will not be able to shuffle with any other element. I am thinking of rerunning the loop again to handle this case. there are really low chances we run into same case again.  btb, this approach take O(n) obviously."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my answer, how about it?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=76785","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"14","title":"Write a function to identify if an integer has the same value when reversed (i.e flipped over. 6 when reversed will be 9).  For ex : the method should return true for the following integers 818 1691 88  but should return false for  8018 212","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"int flip_digit(int d) \n{ \n  switch (d = val%10) { \n    /* flippable numbers */ \n    case 0: \n    case 1: \n    case 5: \n    case 8: \n      return d; \n    /* unflippable numbers */ \n    case 2: \n    case 3: \n    case 4: \n    case 7: \n       return -1; \n    case 6: \n       return 9; \n    case 9: \n       return 6; \n    default: \n       return -1; \n  } \n} \nint flip (int val, int carry) \n{ \n  int d; \n  if (val == 0) return carry; \n  d = flip_digit(val%10); \n  if (d < 0) return d; \n  return flip(val/10, carry*10+d); \n} \n \nint isFlipped(int val) \n{ \n  return (val == flip(val, 0));  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"do something like a palindrome check, but instead of checking if chars are equal, check if they are part of a 'flip pair' (like 6.9 or 8,8 or 1,1 etc)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"const int decDict[] = {0, 1, 5, 3, -1, 2, 9, -1, 8, 6}; \n \nbool chk_rev_same(unsigned int val); \n \nint main(void) { \n \n  unsigned int testVec[5] = {818, 1691, 88, 8018, 212}; \n  unsigned int i = 0; \n \n  for(i = 0; i < 5; i++) { \n    if(chk_rev_same(testVec[i])) { \n      printf(\"%d:true\\n\", testVec[i]); \n    } else { \n      printf(\"%d:false\\n\", testVec[i]); \n    } \n  } \n   \n  return 0; \n} \n \nbool chk_rev_same(unsigned int inVal) \n{ \n  unsigned int tmpVal = 0, outVal = 0, remVal = 0; \n \n  for(tmpVal = inVal; tmpVal != 0; tmpVal /= 10) { \n    remVal = tmpVal % 10; \n \n    if(decDict[remVal] < 0) return false; \n \n    outVal *= 10; \n    outVal += decDict[remVal]; \n  } \n \n  if(outVal == inVal) return true; \n  else return false; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hey can you give some more info about your interview,was this a phone or onsite,and what else did they ask?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Mirror {  public Mirror() {     }    public boolean isCharMirror(char c1, char c2) {   if(c1 == '0' && c2 == '0')    return true;   if(c1 == '1' && c2 == '1')    return true;   if(c1 == '8' && c2 == '8')    return true;   if((c1 == '6' && c2 == '9') || (c1 == '9' && c2 == '6'))    return true;   return false;  }    public boolean isMirror(int value) {   String str = Integer.toString(value);   for(int i = 0, j = str.length()-1; i < j; i++, j--) {    if(! isCharMirror(str.charAt(i), str.charAt(j)))       return false;   }   return true;  }    public static void main(String[] args) {   Mirror mirror = new Mirror();   System.out.println(mirror.isMirror(818));   System.out.println(mirror.isMirror(1691));   System.out.println(mirror.isMirror(88));   System.out.println(mirror.isMirror(8018));   System.out.println(mirror.isMirror(212));     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This should do the job"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def isRev(n):     size = len(n)     loop = int(math.ceil(size/2))     dic = {1:1,6:9,8:8,9:6}     for i in range(loop):         if n[i] in dic:             if n[size-1-i]!=dic[n[i]]:                 return False         else:             return False     return True"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about reverse the number and comparing with the original"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"is it optimal code ??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"reverse the string and then flip each char. Eg: 1691 reverse will be 1961. Then flip each char it will be 1691."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=83752","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"21","title":"write a sql to find all the duplicate email address in a table which contains only one column \"email\"","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"select email, count(email) from table group by email having count(email) > 1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"select distinct email from table"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"select email  \nfrom table \nwhere email NOT IN (select distinct email from table)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it doesn't work if there is email exists more than twice."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"select * \nfrom email_table \ngroup by email \nhaving count(*) > 1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"select email from email_table where email NOT IN (select email from email_table where count(email) = 1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The \"having count\" solution works fine. \n \nHere is another one: \n \nselect  \n ec.email  \nfrom  \n (select  \n  e.email,  \n  count(e.mail) as email_count  \n from  \n  email as e  \n group by e.email) as ec  \nwhere  \n ec.email_cout > 1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"select email_id from email_table where count(email_id)>1;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"SELECT ROWID , EMAIL_ADDRESS FROM EMAIL_TABLE WHERE ROWID NOT IN (SELECT MAX(ROWID) FROM  EMAIL_TABLE GROUP BY EMAIL_ADDRESS)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"select t1.email from t as T1, t as T2 where T1.email == T2.email"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"SELECT EMAIL,COUNT(EMAIL) FROM TABLE GROUP BY EMAIL HAVING COUNT(EMAIL)>1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the table has only one column and this is a relational database, we cannot have duplicates in the table!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"select distinct email from table"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=83753","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"8","title":"Write a program to reverse a string and use it as a subroutine to reverse each word in a line","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void ReverseString(char* src, int beginIndex, int endIndex) {  if (src==NULL || (beginIndex >= endIndex)) {   return;  }  int b = beginIndex; int e = endIndex;  while ( b <= e) {   char tmp = src[b];   src[b] = src[e];   src[e] = tmp;  } }  void ReverseWordsInALine(char* src) {  if (src==NULL || strlen(src) <= 1)     return;  }  int i=0;  int j=i+1;    while (j <= strlen(src)-1) {   while(src[i])==' ') {    i++;   }   while(src[j]!==' '&& src[j]!='\\0') {    j++;   }      ReverseString(src, i, j-1);  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void reverseWords( char str[] ){     int start = 0, end = 0, length;      length = strlen(str);     /* Reverse entire string */     reverseString(str, start, length - 1);      while( end < length ){        if( str[end] != ' ' ){ /* Skip non-word characters */             /* Save position of beginning of word */            start = end;             /* Scan to next non-word character */            while( end < length && str[end] != ' ' )                end++;             /* Back up to end of word */             end--;              /* Reverse word */             reverseString( str, start, end );         }         end++; /* Advance to next token */     } }  void reverseString( char str[], int start, int end ){     char temp;     while( end > start ){         /* Exchange characters */         temp = str[start];         str[start] = str[end];         str[end] = temp;          /* Move indices towards middle */         start++; end--;     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"const char CHAR_SPACE = ' '; const char STR_END = '\\0';  char * reverse_word(char * start, char * end); char * get_wstart(char * linePos); char * get_wend(char * linePos); // first char cannot be space  int main(void)  {    char line[] = \"hello world\";   char * wstart = NULL, * wend = NULL;   char * in = NULL;    printf(\"line: %s\\n\", line);    for(in = line; (wstart = get_wstart(in)) != NULL; in = wend + 1) {     wend = get_wend(wstart);      reverse_word(wstart, wend);   }    printf(\"reversed line: %s.\\n\", line);    return 0; }  char * get_wstart(char * linePos) {    if(linePos == NULL || *linePos == STR_END) return NULL;    // skip over spaces   for(; *linePos == CHAR_SPACE; linePos++) ;    if(*linePos == STR_END) return NULL;   else return linePos; }  char * get_wend(char * linePos) {    if(linePos == NULL) return NULL;    for(; *linePos != CHAR_SPACE && *linePos != STR_END; linePos++) ;    return linePos - 1; }  char * reverse_word(char * start, char * end) {    char * retval = start;   char tmpChar;    while(start < end) {     tmpChar = *start;     *start = *end;     *end = tmpChar;     start++;     end--;   }    return retval; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for reverse function: string reverse(string str) {  string rev;  for(int i =0; i < str.size(); i++) {    rev = str[i] + rev;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Put the chars of a string/line into a \"Stack\" ( Last in first out Structure ) 2. Once all the chars are done ... start poping out of the stack and there you go voila ..it is reversed"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class ReverseWords {  public ReverseWords() {     }    public String reverseString(String str) {   StringBuffer reversedStr = new StringBuffer();   int length = str.length();   for(int i = length-1; i >= 0; i--) {     reversedStr.append(str.charAt(i));   }   return reversedStr.toString();  }    public String reverseWord(String str) {   String word;   StringBuffer reversedStr = new StringBuffer();   int length = str.length();   int i, j;      for(i = 0, j = 0; i < length; i++) {    if(str.charAt(i) == ' ') {     word = str.substring(j, i);     j = i+1;     reversedStr.append(reverseString(word));     reversedStr.append(\" \");    }   }   word = str.substring(j, i);   reversedStr.append(reverseString(word));      return reversedStr.toString();  }    public static void main(String[] args) {   ReverseWords rw = new ReverseWords();   String str = rw.reverseString(\"hello world!\");   System.out.println(str);      str = rw.reverseWord(\"hello world!\");   System.out.println(str);  }     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I tried to make an efficient C version:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def revStr(iStr):     size = len(iStr)     loop = int(math.floor(size/2))     iStr = list(iStr)     for i in range(loop):         tmp = iStr[i]         iStr[i] = iStr[size-1-i]         iStr[size-1-i] = tmp     rStr = ''     for i in iStr:         rStr += i     return rStr  def revLine(line):     wList = line.split()     rLine = ''     for i in wList:         rLine = rLine + revStr(i)+' '     return rLine"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=83757","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"9","title":"Write a program to evaluate a simple mathematical expression like 4 + 2*a/b - 3","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \n#include  \n \n// !! assumption !! \n// The simple calculator, here, can compute only positive integer for its operand. var cannot be used \n// only four operator can be used. no paren is allowed \n \nconst char PLUS = '+'; \nconst char MINUS = '-'; \nconst char DIV = '/'; \nconst char MUL = '*'; \nconst char NUM = '7'; \nconst char ERR = '4'; \n \nconst char STR_END = '\\0'; \nconst char CHAR_SPACE = ' '; \n \nconst unsigned int MAX_STK_SIZE = 100; \n \ntypedef struct { \n  char type; \n  int value; \n} Token; \n \ntypedef struct { \n  Token ** tok; \n  unsigned int top; \n  unsigned int maxSize; \n} Stack; \n \nint calculate(char * equation); \nint calc(Token * lval, Token * rval, Token * op); \nint opPrior(char op1); \n \nchar * get_token(char * equation, Token ** tok); \n \nbool stk_init(Stack ** stk, unsigned int size); \nToken * stk_push(Stack * stk, Token * tok); \nToken * stk_top(Stack * stk); \nToken * stk_pop(Stack * stk); \n \nint main(void) \n{ \n  char equ1[] = \"4  +2*3/1-3\"; \n  char equ2[] = \"1+2-3*2/1\"; \n  char equ3[] = \"3-1-2\"; \n  char equ4[] = \"10/2-23+4*2-3+1*0\"; \n \n  int i, j, k, l; \n \n \n  i = calculate(equ1); \n  printf(\"%s = %d\\n\", equ1, i); \n \n  j = calculate(equ2); \n  printf(\"%s = %d\\n\", equ2, j); \n \n  k = calculate(equ3); \n  printf(\"%s = %d\\n\", equ3, k); \n \n  l = calculate(equ4); \n  printf(\"%s = %d\\n\", equ4, l); \n \n  return 0; \n} \n \nint calculate(char * equation) \n{ \n  Token * tok = NULL, * stkTopTok = NULL; \n  Token * lval = NULL, * rval = NULL; \n  Stack * numStack = NULL, * opStack = NULL; \n \n  if(stk_init(&numStack, strlen(equation)) == false) { \n    printf(\"error in malloc\\n\"); \n    exit(1); // error code should be defined as a macro in the near future \n  } \n  if(stk_init(&opStack, strlen(equation)) == false) { \n    printf(\"error in malloc\\n\"); \n    exit(1); // error code should be defined as a macro in the near future \n  } \n \n  while((equation = get_token(equation, &tok)) != NULL) { \n \n    switch(tok->type) { \n \n    case NUM: \n      stk_push(numStack, tok); \n      break; \n \n    case PLUS: case MINUS: case DIV: case MUL: \n      stkTopTok = stk_top(opStack); \n \n      while(stkTopTok != NULL &&  \n     opPrior(tok->type) >= opPrior(stkTopTok->type)) { \n rval = stk_pop(numStack); \n lval = stk_pop(numStack); \n stkTopTok = stk_pop(opStack); \n assert(lval != NULL && rval != NULL && stkTopTok != NULL); \n \n lval->value = calc(lval, rval, stkTopTok); \n stk_push(numStack, lval); \n stkTopTok = stk_top(opStack); // at this point, possible memory leak due to stack operation \n      } \n \n      stk_push(opStack, tok); \n      break; \n \n    default: \n      printf(\"Error in your equation\\nUnrecognized Token\\n\"); \n      exit(2); \n    } \n  } \n \n  while(stk_top(opStack) != NULL) { \n    rval = stk_pop(numStack); \n    lval = stk_pop(numStack); \n    stkTopTok = stk_pop(opStack); \n    assert(lval != NULL && rval != NULL && stkTopTok != NULL); \n \n    lval->value = calc(lval, rval, stkTopTok); \n    stk_push(numStack, lval); \n  } \n \n  lval = stk_pop(numStack); \n \n  assert(lval != NULL); \n \n  return lval->value; \n} \n \nint calc(Token * lval, Token * rval, Token * op) \n{ \n  switch(op->type) { \n  case PLUS: \n    return lval->value + rval->value; \n  case MINUS: \n    return lval->value - rval->value; \n  case MUL: \n    return lval->value * rval->value; \n  case DIV: \n    return lval->value / rval->value; \n  default: \n    printf(\"Not valid operator:%c\\n\", op->type); \n    exit(3); \n    return 0; \n  } \n} \n \nint opPrior(char op1) \n{ \n  switch (op1) { \n  case PLUS: return 4; \n  case MINUS: return 3; \n  case MUL: return 2; \n  case DIV: return 1; \n  default: return 0; \n  } \n} \n \nchar * get_token(char * equ, Token ** tok)  \n{ \n \n  char * ptrEqu = NULL; \n  int value = 0; \n  Token * tmpTok = NULL; \n \n  if(equ == NULL) return NULL; \n   \n  // skip over space \n  for(ptrEqu = equ; *ptrEqu != STR_END && *ptrEqu == CHAR_SPACE;  ptrEqu++) ; \n  if(*ptrEqu == STR_END) return NULL; \n \n  tmpTok = (Token *) malloc(sizeof(Token)); \n  tmpTok->type = ERR; \n  tmpTok->value = 0; \n \n  switch (*ptrEqu) { \n \n  case MUL: case DIV: case PLUS : case MINUS: \n    tmpTok->type = *ptrEqu; \n    *tok = tmpTok; \n    return ++ptrEqu; \n  default: \n    value = 0; \n    for(ptrEqu = equ; *ptrEqu != STR_END;  ptrEqu++) { \n      if(*ptrEqu >= '0' && *ptrEqu <= '9') { \n value = value * 10; \n value += *ptrEqu - '0'; \n      } else break; \n    } \n    tmpTok->value = value; \n    tmpTok->type = NUM; \n    *tok = tmpTok; \n \n    return ptrEqu; \n  } \n} \n \nbool stk_init(Stack ** stk, unsigned int size) \n{ \n  *stk = (Stack *) malloc(sizeof(Stack)); \n \n  if(*stk == NULL) return false; \n \n  (*stk)->tok = NULL; \n  (*stk)->top = 0; \n  (*stk)->maxSize = size; \n \n  (*stk)->tok = (Token **) malloc(sizeof(Token *) * size); \n \n  if((*stk)->tok == NULL) return false; \n  else return true; \n} \n \nToken * stk_push(Stack * stk, Token * tok) \n{ \n \n  Token * tmpTok = NULL; \n \n  if(stk->top == stk->maxSize) return NULL; \n \n  tmpTok = (Token *) malloc(sizeof(Token)); \n  tmpTok->type = tok->type; \n  tmpTok->value = tok->value; \n  (stk->tok)[++stk->top] = tmpTok; \n \n  return tmpTok; \n} \n \nToken * stk_top(Stack * stk) \n{ \n  return (stk->tok)[stk->top]; \n} \n \nToken * stk_pop(Stack * stk) \n{ \n  if(stk->top == 0) return NULL; \n   \n  return stk->tok[stk->top--]; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hey!  Where is the post about Recursive Descent Parser?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Annon is correct just use the stack for solving these type of questions"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"typical compiler parsing issue......"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/*Write a program to evaluate a simple mathematical expression like 4 + 2*a/b - 3*/  public class bodmasCalc{   public static void main(String[]args){   System.out.println(\"Answer = \"+ evaluate(\"4*11/5+9-6\"));  }    public static double evaluate(String input){  for(int i=0;i   if(input.charAt(i)=='/' && !moreSymbol(input,\"+*-\".toCharArray()))     return evaluate(input.substring(0,i)) / evaluate(input.substring(i+1, input.length()));    if(input.charAt(i)=='-')      return evaluate(input.substring(0,i)) - evaluate(input.substring(i+1, input.length()));    if(input.charAt(i)=='+' && !moreSymbol(input, \"-\".toCharArray()))     return evaluate(input.substring(0,i)) + evaluate(input.substring(i+1, input.length()));    if(input.charAt(i)=='*' && !moreSymbol(input, \"+-\".toCharArray()))     return evaluate(input.substring(0,i)) * evaluate(input.substring(i+1, input.length()));    if(!moreSymbol(input, \"/*+-\".toCharArray()))     return Integer.parseInt(input.trim());   }   return -1;  }    public static boolean moreSymbol(String input, char[] symbols){   for(int i=0;i   for(int j=0;j    if(input.charAt(i)==symbols[j])      return true;    }   }   return false;  }    public static int numberOfSymbols(String input){   int count=0;   for(int i=0;i   if(input.charAt(i)=='/' || input.charAt(i)=='*' || input.charAt(i)=='+' || input.charAt(i)=='-')     count++;   }   return count;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def cal(expr):     obj = list(expr)     hiP = ('*', '/')     opt = []      opd = []     size = len(obj)     do = False     for i in range(size):   # high priority operators are treated here         tmp = obj[i]         if tmp.isdigit():             if do:                  opd.append(str(eval(opd.pop()+opt.pop()+tmp)))             else:                 opd.append(tmp)         else:             do = tmp in hiP             opt.append(tmp)          for i in opt:   # low priority operators are treated here         opd.append(str(eval(opd.pop()+i+opd.pop())))     return opd.pop()"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=83756","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"29","title":"Write a progam to rotate a matrix by 90 degrees.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Suppose rotate clockwise 90 degrees, the transformation is of the form (i, j) => (j, N - 1 - i), where N is the number of rows."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"What an idiot am I! I made A->A' so complicated..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Follow below steps:  Step1. take transpose of matrix  Step2. swap columns of transpose of matrix"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Int** RotateMatrix(int** src, int dims) {     Assert.IsNotNull (src);     // init rtv     int** rtv = (int**)malloc(sizeof(int*));     for (int i=0; i  rtv[i] = (int*)malloc(dims*sizeof(int));     }     // rtv assignment     for (int row=0; row  for(int col=0; col   rtv[row][col] = src[col][dims-row];   }     }          return rtv;      }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"No extra space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) A->A' 2) reverse every row (or column) in A'"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here is the method to rotate a cartesian point by 90% along z axis, i dont know if that answers your question  multiply (x,y,z) vector with the following matrix  0 -1 0 0  1  0 0 0 0  0 1 0 0  0 0 1  or simply the following rotate90CCW(x,y,z){ return(-y,x,z); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void rotate_matrix_cw_90(int **m, int n) \n{ \n    int i, j; \n \n    // first mirror the matrix along the diagnal line. \n    for (i = 0; i < n * 2 -1; i++) \n    { \n        int len = (i >= n) ? 2 * n - i - 1 : i + 1; \n        int start_x = (i >= n) ? i - n + 1 : 0; \n        int start_y = (i >= n) ? n - 1 : i; \n \n        for (j = 0; j < len / 2; j++) \n        { \n            int x = start_x + j; \n            int y = start_y - j; \n \n            int tmp = m[y][x]; \n            m[y][x] = m[x][y]; \n            m[x][y] = tmp; \n        } \n    } \n \n    // mirror the matrix horizontally. \n    for (i = 0; i < n / 2; i++) \n    { \n        for (j = 0; j < n; j++) \n        { \n            int tmp = m[j][i]; \n            m[j][i] = m[j][n - i - 1]; \n            m[j][n - i - 1] = tmp; \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void matrix_90_degree() {  if(x==y)    // x and y are row and coloumn size of given a[][] matrix  {    q = y-1;  // p and q are row and coloumn size of output b[][] matrix     for (i=0; i   {       p = 0;      for (j=0; j     {        b[p][q] = a[i][j];        p++;      }      q--;    }    } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void RotateMatrix(int original[][3], int rows) {  int start = 0;  int end = rows - 1;  while(end > start)  {   for(int index = start; index < end; index++)   {    int offset = index - start;    int tmp = original[start][index];    original[start][index] = original[end - offset][start];    original[end - offset][start] = original[end][end - offset];    original[end][end - offset] = original[index][end];    original[index][end] = tmp;   }    start++;   end--;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this one guys? For rotation in place.  void RotateInPlace(int n,int** matrix) {  int jCount =0;  if( n%2 ==0) jCount=n/2;  else jCount = (n/2)+1;  for( int i =0;i< n/2; i++)  {   for( int j=0 ;j < jCount;  j++)   {    int starti=i;int loopi=j;int startj=j;int loopj=n-i-1;        int temp = matrix[i][j];    while( !(loopi ==starti && loopj == startj))    {     int temp1= matrix[loopi][loopj] ;     matrix[loopi][loopj] = temp;     temp=temp1;     int t= loopi;     loopi =loopj;     loopj= n-t-1;             }    matrix[loopi][loopj] = temp;    // till we make a circle and reach starting point - keep swapping    }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#define M 4 \n#define N 3 \nint main() \n{ \n int array[M][N]; \n int t_array[N][M]; \n int i,j; \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"copied from another forum  O(n^2) time and O(1) space algorithm  Rotate by +90: Transpose Reverse each row  Rotate by -90: Transpose Reverse each column  Rotate by +180: Method 1: Rotate by +90 twice Method 2: Reverse each row and then reverse each column  Rotate by -180: Method 1: Rotate by -90 twice Method 2: Reverse each column and then reverse each row Method 3: Reverse by +180 as they are same"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"One formula for rotation of a rectangular matrix anti-clockwise can be (i,j) = (Nr-j,i)  Where Nr = no. of rows in original matrix.  Although space complexity will be O(Nr*Nc)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's the java program to rotate a matrix by 90 degree (clockwise/anticlockwise)   public class Matrix {    static int[][] getMcrossN(int m, int n){    int[][] a = new int[m][n];    int cnt = 1;    for(int i=0; i    for(int j=0;j     System.out.format(\"%4d\",a[i][j]=cnt++);     }     System.out.println();    }    System.out.println(\"\\n\\n\");    return a;   }      static int[][] rotateMatrix(int[][] x){    int[][] m = new int[x[0].length][x.length];    for(int i=0; i    for(int j=0; j    // System.out.format(\"%4d\",m[i][j]=x[j][x[0].length-1-i]); //rotate by 90 degree anticlockwise.      System.out.format(\"%4d\",m[i][j]=x[x.length-1-j][i]); //rotate by 90 degree clockwise.     }     System.out.println();    }    return m;   }   /**    * @param args    */   public static void main(String[] args) {    rotateMatrix(getMcrossN(3, 4));   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it do not work wit all matrix"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Not sure whether this is efficient or not, but in python you can do:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I guess some info is missing in the question. What is Matrix to 90 degrees  Can u be more clear"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Can the matrix be of any form ? If the matrix is square ... the rotation can be done in-place ... however, since one of the requirements is using no extra space .. then rotating matrices that are rectangle in-place is impossible .. since the memory layout then is going to be different .. can the poster please comment on that"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=65732","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"49","title":"Divide a list of numbers into group of consecutive numbers but their original order should be preserved? e.g. 8,2,4,7,1,0,3,6  2,4,1,0,3 and 8,7,6  obviously in shortest time and space.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"9","title":"There is a O(n) solution: 1. Convert the array to a Linklist and build a Hashtable point to each Linklist nodes. 2. Create an array used to indicate the group number. 3. Take the head of the Linklist and mark its corresponding group number of the array as 1.  4. Assume the value of the Linklist head is n. set MIN= MAX= n.   5. Check if MIN-1 and MAX+1 is in the Hashtable. If yes, remove them from the Hashtable and mark the corresponding element as group 1. MIN = MIN -1 if (MIN-1) is there and MAX = MAX + 1 if MAX +1 is identified. 6. Continue step  until both MIN and MAX cannot be identified.  7. add group number by 1 and go to Step 3, until there is no element in the LinkList. 8. now we have an array of group numbers with the same index as the original array and we can build the group."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"It is easy. You use a technique called \"index sorting\", C#, Java, etc. all have overloads of the sort call which can tandem sort two arrays. So essentially you have two arrays  int[] numbers = {5, 7, 8, 2, 9, 3} or whatever int[] indices = {0, 1, 2, 3, 4, 5}  sort indices and numbers by the elements in numbers.  numbers = {2, 3, 5, 7, 8, 9} indices = {3, 5, 0, 1, 2, 4}  Then divide numbers/indices into consecutive groups, which is easy.  Resort numbers/indices but sort by indices. Then just walk through numbers printing out the values."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use an additional array to sort the numbers, once numbers are sorted,  O(nlogn) linear scan to find the range,   within each range,  re-arrange the sorted array to reflect the original order, O(n2) so it's a O(n2) in time and O(n) in space algorithm,  any better solutions?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"After getting the range, instead of re-arranging the sorted array to its original form, you select each element in the original array and use O(logn) time to identify its position in the sorted array. Use constant time to identify its range. Then, the overall time complexity is O(nlogn). The space needed is bigger, but still O(N)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In the initial eg, where are there 2 groups ? (why not 1 or 3 ?) I don't get the question - its vague."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"above is a neat solution - thx!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for:8 2 4 7 1 0 3 6 ind:0 1 2 3 4 5 6 7  after sorting: nos:0 1 2 3 4 6 7 8 ind:5 4 1 6 2 7 3 0   now how to proceed?????"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Identify range - One pass 2. Identify number of elements within each range - One pass 3. Fill destination array by maintaining starting positions of each range - One pass of source array. O(n) time and O(n) space"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Identify range - One pass, how? We have to use sort"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There is a O(n) solution: 1. Convert the array to a Linklist and build a Hashtable point to each Linklist nodes. 2. Create an array used to indicate the group number. 3. Take the head of the Linklist and mark its corresponding group number of the array as 1.  4. Assume the value of the Linklist head is n. set MIN= MAX= n.   5. Check if MIN-1 and MAX+1 is in the Hashtable. If yes, remove them from the Hashtable and mark the corresponding element as group 1. MIN = MIN -1 if (MIN-1) is there and MAX = MAX + 1 if MAX +1 is identified. 6. Continue step  until both MIN and MAX cannot be identified.  7. add group number by 1 and go to Step 3, until there is no element in the LinkList. 8. now we have an array of group numbers with the same index as the original array and we can build the group."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this question asks partitioning algorithm of quicksort..someone above mentions quicksort is not stable, but being stable means whethe the same key are in the same order as original one...not exactly the question asks. Here's the O(N), inplace partitioning algorithm  int first_larger=0; int pivot = N-1; (assuming pivot is at the end of array);  for(int i=0; i{    if(array[i] < array[pivot])       swap(&array[i], array[first_larger++]; } swap(&array[first_larger], &array[pivot]);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this question can be solved by using 2 priority queues. Create data structure Node(VAL, INDEX). Index is the index value in the original array, VAL is its value for that index.BTW, the first priority queue compares elements by the its VAL value. And the second priority queue compares each other by its index value.   Step 1: Put all the nodes into the 1st priority queue.  Step 2: keep poping the node from 1st priority queue and push this node into 2nd priority queue if their value is consecutive. If not consecutive, pop and print all the elements in the 2nd priority queue.  Step 3: continue step 2 until the 1st priority queue is empty."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution 1: O(n)-time O(n)-space Hashtable Solution 2: O(n^2)-time O(1)-space Brute force"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This problem is not clear: how to seperate the group? There must be a number x, the left group < x, and the right group >= x. If x is given, the solution is: 1. Identify how many elements >= x, and get the first_large position; 2. Iteratively by each element, get the final position, and store to a position array; 3. Swap the elements according to the position array; The complexity is O(N) in both time and space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"find min and max element in the array say min and max find the sum of all consecutive numbers from min to max  expected_sum=max(max+1)/2 - (min-1)(min)/2  Now sum the total elements in the array  Say actual_sum  We know the number of consecutive missing elements in the array by missing= (max-min)- total_size of array  now the starting point of the missing sequence is  expected - total_sum = missing * pivot + (missing+1)*missing/2  we will get pivot by the above approach Take O(n) extra space and use the quicksort technique.  Extra space since quicksort is not the stable sorting algorithm  somplexity O(n)time + o(n)space"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nint sort(const void *x, const void *y) { \n  return (*(int*)x - *(int*)y); \n} \nmain() \n{ \n int N; \n scanf(\"%d\",&N); \n int arr[N]; \n int arrsort[N]; \n int i; \n for(i=0;i=range[d][0]) ++d; \n   else break; \n  } \n  --d; \n  group[d][++group[d][0]]=c; \n }  \n    \n for(i=0;i\",group[i][h]); \n  }   \n } \n  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the hashtable solution in Java. What I am doing is this: 1) put array elements as keys in hashtable with values (group numbers) 0. 2) Initialize group to 0. 3) Incrementing group and going through each array element and finding its key in hashtable. If value is 0 group hasn't been assigned and assign value to current group number. finding all elements arrayelement+-k which exist in hashtable and assign them the current group number too.  4) Separating out groups in O(n) time.  Can someone comment on complexity of step 3? I have a feeling that its more than O(n) because of the while loop but I am not sure."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I don't understand what this question want, why 2,1,0 not grouped?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"An O(lgn) solution. the result is like { 0 0 1 0 1 0 2 2 1 0 0}, means the elements with the same group number are in the same group.  {  public static int[] consecutiveGroup(int[] a)  {   int[] result = new int[a.length];   HashMap hmap = new HashMap();   for (int i=0; i  {    hmap.put(a[i], i);   }   Arrays.sort(a);   int groupNum = 0;   for (int i=0; i  {    result[hmap.get(a[i])] = groupNum;    if (i+1a[i]+1)    {     groupNum++;    }   }     return result;  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static int[] findConsecutiveLists(int[] list) { \n  int [] retList = new int[list.length]; \n  HashMap reqMin = new HashMap(); \n  HashMap reqMax = new HashMap(); \n   \n  for (int index = 0; index < list.length; index++){ \n   if (reqMin.containsKey(list[index])){ \n    Group myGroup = reqMin.get(list[index]); \n    myGroup.addItem(list[index], index); \n    reqMin.remove(list[index]); \n    if (reqMax.containsKey(list[index])){ \n     Group newGroup = reqMax.get(list[index]); \n     reqMax.remove(list[index]); \n     myGroup.merge(newGroup); \n     reqMax.put(myGroup.keyMax +1, myGroup); \n     reqMin.put(myGroup.keyMin - 1, myGroup); \n    } \n    else { \n     myGroup.addItem(list[index],index); \n     reqMin.put(myGroup.keyMin - 1, myGroup); \n    } \n   } else if (reqMax.containsKey(list[index])){ \n    Group myGroup = reqMax.get(list[index]); \n    reqMax.remove(list[index]); \n    myGroup.addItem(list[index],index); \n    reqMax.put(myGroup.keyMax +1, myGroup); \n   } else { \n    Group myGroup = new Group(); \n    myGroup.addItem(list[index],index); \n    reqMax.put(myGroup.keyMax +1, myGroup); \n    reqMin.put(myGroup.keyMin - 1, myGroup); \n   } \n  } \n   \n  int cntr = 0; \n  for (int key : reqMin.keySet()){ \n   while (!reqMin.get(key).content.isEmpty()) \n    retList[cntr++] = list[reqMin.get(key).content.poll()]; \n  } \n  return retList; \n } \n  \n static class Group { \n  \n  PriorityQueue content = new PriorityQueue(); \n  int keyMin = Integer.MAX_VALUE; \n  int keyMax = Integer.MIN_VALUE; \n   \n  void merge(Group newg){ \n   keyMin = Math.min(this.keyMin, newg.keyMin); \n   keyMax = Math.max(this.keyMax, newg.keyMax); \n   content.addAll(newg.content); \n  } \n   \n  void addItem(int item, int index){ \n   keyMin = Math.min(this.keyMin, item); \n   keyMax = Math.max(this.keyMax, item); \n   content.add(index); \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void divide(vector& a) \n{ \n  if (a.size() == 0) \n     return ; \n  radix_sort(a.begin(), a.end()); \n  cout << a[0] << \" \"; \n  for (int i=1; i < a.size(); i++) \n  { \n      if (a[i] != a[i-1]) cout << endl; \n      cout << a[i] << \" \"; \n  } \n   \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can convert this problem as a graph and solve it by bfs."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Step1: Make a pass on the entire array to find the min and max numbers, which is nothing but the range of numbers. Step2: Use count sort to sort the entire range of numbers. Step3: Make another pass on the count sorted array to identify the group of consecutive numbers.  O(1)+O(nK)=O(n) time and  O(number of elements in the input array) space required  comments/optimization are welcome"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"First, the question is too vague! What criteria to use for division into groups? Where should be the output ( i.e. each group in its own file, or in the another buffer, or one should use the same input buffer for output )? How many input rules we may expect? e t.c. In particular, if we are getting groups using a range query, and each group correspond to each range, and we store selections in their own buffers, then we do NOT need sorting at all. We just iterate through the input, determine the group number ( comparing each input against all rules ) and output the input to the corresponding buffer... But this is too silly to consider :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"construct a BST from the given array. Then it becomes easier to construct the tree. Though the space complexity increases a bit but time complexity remains low."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"1. Identify range - One pass 2. Identify number of elements within each range - One pass 3. Fill destination array by maintaining starting positions of each range - One pass of source array. O(n) time and O(n) space"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=65088","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"16","title":"Write a method in C to reverse a linked list.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"void reverseLinklist(Node **head) {  Node *ahead=NULL, *curr=NULL, *behind=NULL;  behind=NULL;  curr=*head;  if(curr)  {    ahead=curr->next;    while(ahead)   {    curr->next=behind;    behind = curr;    curr = ahead;    ahead=ahead->next;   }    curr->next=behind;   *head=curr;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"node *reverseList(node *head) {    node *p1, *p2, *p3;        if(head == NULL || head->next == NULL)       return head;     p1=head; p2=head->next;    while (p2)    (        p3 = p2->next;       p2->next = p1;       p1 = p2;       p2 = p3;    )        head -> next = NULL;    head = p1;    return head; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"void reverseList(node **head) {  node *result=NULL;  while((*head) != NULL)  {    node *tmp=(*head)->next;   *head->next=result;   result=*head;   *head=tmp;    }  head=*result; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"main() {     reverse(head, NULL); }  void reverse(node* current, node* previous) {     if(current->next != NULL)         reverse(current->next, current);     current->next = previous; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node reverseList(node head) {      node p1, p2;      p1 = p2 = head;      p2 = p2->next;   p1->next = NULL;    while( p2 != null) {           node temp = p2; p2= p2 ->next;        temp->next = p1;    p1 = temp;      }    return p1; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I always right it the following way, I think it is more legible  void reverseLinklist(Node **old_list) {    node* new_list = null;    node* element = null;    while (*old_list) {       //Extract top node from old_list       element = *old_list;       *old_list = old_list->next;              //Add to front of new list;       element->next = new_list;       new_list = element;     }     //set old_list to point to correct node (new_list), or return     //new_list depending on function signature     *old_list = new_list; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"typedef struct MyList MyList; struct MyList {   int id;   MyList * next; };  MyList * reverse_list(MyList * list) {    MyList * curNode = NULL, * nextNode = NULL, * tmp = NULL;    curNode = NULL;   nextNode = list;   while(nextNode != NULL) {     tmp = nextNode->next;     nextNode->next = curNode;     curNode = nextNode;     nextNode = tmp;   }    return curNode; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Wow! Everyone knows this one........."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how to do it recursively......"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hi,how to do it recursively......."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Recursive solution. Let me know if there is something better :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"reverse(NODE *ptr){    NODE *tmp=head;    while(!head->next){       head=head->next;       reverse(head);       tmp->next->next=tmp;       tmp->next=NULL;    } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node prev = null; \nNode cur = root; \nwhile(cur != null) \n{ \n Node next = cur.Next; \n cur.Next = prev; \n prev = cur; \n cur = next; \n} \n \n// prev is new root of the list"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=64919","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"33","title":"Given two lists l1,l2, show how to merge them in  O(1) time.  The data structures for the lists depends on how you design it.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"I'm not really sure where people got the assumption that you had to remove duplicates. That doesn't appear specified in the question. I can think of many cases where you'd want to keep duplicates. Think about two list of events, for example, you wouldn't want to remove all events of the same type when merging, you'd want to keep them. If that is the case, then the solution is simply using two linked lists and doing l1->last->next = l2->head.  If, in fact, \"merge\" does imply that duplicates should be removed. Then I'd have to agree with Arpan and Vikram on the solution using bit representation."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":">>Lists data structure design depends on you. As design choice is ours,we can use doubly linked lists data structure."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"How about this? use hash table to represent the list.   h[key]=1 means key is inside the list. so, lookup is O(1), traverse is O(n).  when do the union, just keep them as they are. So, when lookup, when just do OR of h1[key], h2[key]. it's still O(1).  when traverse, traverse in h1 and h2, O(2n)=O(n). meanwhile, eliminating h2.  a bit tricky. donot whether it is acceptable."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what do you mean \"merge them\" are the lists sorted? Or simply appended to the end?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Merging is akin to taking union of the two lists in this case.I mean two say that we have to take the union of the two sets,removing duplicate entries,if any. (Remember how do we take the union of two sets) Given {1,2,3} and {2,5,3}   O/p of theri union is {1,2,3,5}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":">>Lists data structure design depends on you. As design choice is ours,we can use doubly linked lists data structure.  .......But,how do we take care of possible duplicates....we can't simply append them.You need to design some other list data structure"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hmmm Well it seems to me that if we separating random entries in a list in constant time, then we need O(1) lookup, which is not provided by a list. So we will have to use a random access data structure somewhere, if this is still a \"list\" then it is possible."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can use a hash table and hash all the elements into it. We will be left with the Union of the elements which are the keys of the hash table. But this is still O(2n) and not O(1). O(1) does it mean just append one list to another...???"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ya man n u think traversing of list is O(1) lol"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Lol you obviously need a random access data structure. The only thing I can think of is to have a \"pool\" of list elements, store in an array. I.e. node* pool[n];  Then each \"list\" has a bitmap bool bitmap[n], where the ith value in the bitmap is true if the list contains that element.  Then to merge 2 lists we simply OR the two bitmaps. However this only works if we can know ahead of time how many elements there will be, or growing each bitmap as new elements are added to the pool.  Be warned.. This solution sucks."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Prabhav: O(1) is not possible."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Because we have choise to design data structure for the lists, so I use three containers to store data, one std:map (or hash table) to store real data(the data may be the key), and useing two lists (link table or vector or what ever) to store the key for the data which belongs to the list. The Add operation is OK because for map add is automatically unique but in two lists maybe dublicate, for delete operation, only the data don't belong to both list, then delete it from map. now it is easy for merge two list, do nothing just access map."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If we use a bit vector representation (a bit vector is a an long integer or a group of integers, such that if a number n is present in our data, we set the n'th bit in the integer or range of integers to 1), we can do a bitwise OR which is O(1) and we get the union! The space complexity will be high because this depends on the range of the data."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Bit representation is one of the possible solutions I gave once the same and solution was accepted .Because we have a very realistic limit of O(1) time we have to compensate on the space"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Bit representation is one of the possible solutions I gave once the same and solution was accepted .Because we have a very realistic limit of O(1) time we have to compensate on the space"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What if we use doubly circular..we can merge in o(1). hence we need to change 3 pointers only"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"typedef struct node {   struct node* next;   int data; }node;  //we maintain the head and tail of the list //e.g. add will be: //  void add_node(node** head, node** tail, int info);  void merge(node* tail1, node* head2) {   tail->next=head2; //this is O(1)   return; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The case is not about O(1) but about how we design the list to have O(1)... To design the list, we should try to remove duplicates when putting entries into the list. So, for example, if an element is going into list 1, we have to lookup the both lists to check if there is a duplicates. If there are duplicates, then, dont insert, else insert into one."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Maybe I'm missing something here, but if we can choose how to design the lists then we have some information regarding their contents. Looking at the contents we can come up with a condition that would neatly separate them into two groups, L1 would contain group1 and L2 would contain group 2, merging would then simply be appending one to the other.  A more concrete example: Suppose our lists are to contain ints, in that case we can pick something like 16384 and put everything under that number in L1 and the rest in L2 in sorted order. Can use doubly-linked lists for this.  Of course efficiency and and the rest will depend upon what we are storing... but the idea was to get O(1) merge.  Comments?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Implement L1 and L2 as doubly linked lists. Merge them like this :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Skip list is the key..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What if we design the two lists to be circular lists. The tails point to the heads. Then we only have to break the two circles and combine them. What do you think about this?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I believe that should be double circular linked list"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just a circular linked list would do.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A single linked list is OK and we need two structures: one for list another for each element."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Data structure choice is ours hey? So what say we just add a bit \"needsmerge\" with an array of lists that would potentially need to be merge into one on next traversal/other operation. That is a typical tradeoff. If you want merge in O(1) then you expect it to be a common operation. So we just do it via lazy evaluation..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Define the structure as- struct node {   int info;   int listFlag;   struct node *next; }; /*  Flag can be  0 - 1st List,  1 - 2nd List,  2 - both */ So the insertion operation will either modify the flag of a node or add a new node with. We do not need to perform any special operation. And I suppose using this structure we can perform Union, Intersection, Set Difference in O(1) time. The only thing that we need to change is the testing of listFlag while traversing the list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"How about this. since we can define our data structure, let us define the data structure as \"always sorted linked list with a tail pointer.\" Now whether the data structure requires extra time for insertion is not a headache. so at this point just take the tail pointer of one list and make it point to the head of the second.  Does it sound logical?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"assuming we are talking about stl lists, then we can do this using one of the splice functions.  if not using stl lists then since lists are data structs with a pointer to the next element, we just have to do one instruction i.e lst1.end->next = lst2.head. voila both lists are merged !!!"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=56927","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"3","title":"Tell me about a recent bug you tracked down and how you did it.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Interviewer expected to know the identification of the root cause which introduces the bug. Then how you come up with different solution and decide an optimal solution. It also include the impact  of the solution to the project for upcoming scenarios.  Dont forget to mention Refactoring , which is the most usual scenario."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Interviewer expected to know the identification of the root cause which introduces the bug. Then how you come up with different solution and decide an optimal solution. It also include the impact  of the solution to the project for upcoming scenarios.  Dont forget to mention Refactoring , which is the most usual scenario."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I was scheduled to meet with a very fresh employee. I am pretty sure I did all the questions (because I tested all my codes after the interview) but still got rejected. I will never ever consider facebook again~"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=56909","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"17","title":"Code a function 'dedupe' that removes duplicate characters from a string.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"void dedupe(char *str) {  int length = strlen(str);  int i=0,j=0;  char flag[256];  for(i=0; i<256; i++)  {   flag[i] = 0;  }  for(i=0; i {   if(flag[str[i]] == 0)   {    flag[str[i]] = 1;    str[j] = str[i];    j++;   }  }  str[j] = '\\0'; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"//C# \n //O(n) \n        static char[] removeDuplicateChars(char[] _str) \n        { \n            bool[] charset = new bool[256]; \n            for (int i = 0; i < _str.Length; i++) \n            { \n                int val = _str[i]; \n                if (charset[val]) { _str[i] = ' '; } \n                charset[val] = true; \n            } \n            return _str; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"My answer in JavaScript"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"any ans.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do a mergesort, with slight changes to the merge part: when you find two elements equal, add only of them to the list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include   using namespace std;  #define MAX_NUM_CHAR 256  char * dedupe(char * str);  int main(void) {    char str1[5] = {'a', 'b', 'c', 'a', '\\0'};   char str2[8] = {'a', 'b', 'b', 'a', 'a', 'd', 'e', '\\0'};    char * str = NULL;    str = dedupe(str1);   printf(\"%s\\n\", str);   str = dedupe(str2);   printf(\"%s\\n\", str);      return 0; }  char * dedupe(char * str) {    unsigned int i = 0, j = 0;;   unsigned int strLen = 0;   char hasChar[MAX_NUM_CHAR];    if(str == NULL) return NULL;    // init hasChar array   for(i = 0; i < MAX_NUM_CHAR; i++) {     hasChar[i] = 0;   }    strLen = strlen(str);   for(i = 0, j = 0; i < strLen; i++) {     if(hasChar[str[i]] == 0) {       str[j++] = str[i];       hasChar[str[i]] += 1;     } else ;   }   str[j] = '\\0'; // here comes memory leak? in that string has more memory than necessary    return str; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int length = str.size(); bool bitmap[256]; init(); //false for all 256 elements for(int i=0; i   if (bitmap[str[i]]) remove(str[i]);    else         bitmap[str[i]]=true;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this implementation? The algorithm is simple: maintain a dedupped string ended by pointer \"end\", and each time a new charactor pointer by \"p\" will compare to all the dedupped characters.   void RemoveDuplicates(char *str) {   if (str == NULL) return;   int len = strlen(str);   if (len <= 1) return;    char *end = str;   for (char *p = end + 1; *p; ++p) {     bool dup = false;     for (char *t = str; t <= end; ++t) {       if (*t == *p) {         dup = true;         break;       }     }     if (!dup) {       *++end= *p;     }   }   *++end= '\\0'; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static String dedupe(String str) { \n  int [] A = new int[256]; \n  StringBuffer sb = new StringBuffer(); \n   \n  int len = str.length(); \n  for (int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* Given a string *Str of ASCII characters, write the pseudo code to remove the duplicate elements present in them. For example, if the given string is \"Potato\", then, the output has to be \"Pota\". Additional constraint is, the algorithm has to be in-place( no extra data structures allowed) . Extend your algorithm to remove duplicates in the string which consisted of UNICODE characters. */ #include using namespace std; int main() {     char a[20],*p;     p=a;     cin >> a;     while(*p)     {         char *s = (p+1);         while(*s)         {                  if(*s == *p)                  {                        int i=0;                        while(*(s+i))                        {                           if(*(s+i) == *p)                           i++;                           *s = *(s+i);                           s++;                        }                        *s = '\\0';                  }                  else                    s++;         }         p++;     }     cout << a << endl;     system(\"pause\");     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* Given a string *Str of ASCII characters, write the pseudo code to remove the duplicate elements present in them. For example, if the given string is \"Potato\", then, the output has to be \"Pota\". Additional constraint is, the algorithm has to be in-place( no extra data structures allowed) . Extend your algorithm to remove duplicates in the string which consisted of UNICODE characters. */ #include using namespace std; int main() {     char a[20],*p;     p=a;     cin >> a;     while(*p)     {         char *s = (p+1);         while(*s)         {                  if(*s == *p)                  {                        int i=0;                        while(*(s+i))                        {                           if(*(s+i) == *p)                           i++;                           *s = *(s+i);                           s++;                        }                        *s = '\\0';                  }                  else                    s++;         }         p++;     }     cout << a << endl;     system(\"pause\");     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#import \n#import \nvoid  moveZeros(char* a) \n{ \n        size_t len = strlen(a); \n        int index0 = 0; \n        int indexN = 0; \n        for(int i = 0; i < len; i++) \n        { \n                if(a[i] != '@') \n                { \n                        int temp = a[i]; \n                        a[i] = a[index0]; \n                        a[index0] = temp; \n                        index0++; \n                } \n        } \n        a[index0] = '\\0'; \n} \nvoid dupeWithExtraSpace(char* str) \n{ \n int charArray[26] = {0}; \n int i, j; \n i = j = 0; \n  \n for(;i < strlen(str); i++) \n { \n  if(charArray[str[i] - 'a'] == 0) \n  { \n   str[j] = str[i]; \n   charArray[str[i] - 'a'] = 1; \n   j++; \n  } \n } \n str[j] = '\\0'; \n} \n \nvoid dupeWithNoExtraSpace(char* str) \n{ \n char currChar; \n for(int i = 0; i < strlen(str); i++) \n { \n  currChar = str[i]; \n  if(currChar != '@') \n  { \n   for(int j = i + 1; j < strlen(str); j++) \n   { \n    if(currChar == str[j]) \n    { \n     str[j] = '@'; \n    } \n   } \n  } \n } \n moveZeros(str); \n} \n \nint main() \n{ \n char a[] = \"ccbbbcdecdea\"; \n char b[] = \"abcdabcdabcd\"; \n \n dupeWithNoExtraSpace(a); \n dupeWithExtraSpace(b); \n \n printf(\"%s \\t %s \\n\",a , b); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def dedupe(string): \n    result = \"\" \n    for i, letter in enumerate(string): \n        if letter not in result: \n            result += letter \n    return result"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Oops, correction:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I have a phone interview with facebook.Any tips or suggestions?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=56902","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"5","title":"Whats the difference between statically and dynamically typed languages?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"Statically typed languages associate type with variables. Hence, type checking is done during compile time. ( C, C++, Java....) Dynamically typed languages associate type with values. Thus, type checking would be done during run time. ( Python, Perl, Objective-C....)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Statically typed language: each variable is assigned a type; the other: no type information associated with variables;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"VB is also dynamically typed:)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"is PHP also dynamically typed then ???"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"dhur mia"}]}}]"