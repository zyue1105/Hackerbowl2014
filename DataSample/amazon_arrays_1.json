[{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=7528760","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"158","title":"If [a1,a2,a3...,an,b1,b2...bn] is given input change this to [a1,b1,a2,b2.....an,bn] , solution should be in-place","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"12","title":"Algorithm:    First swap elements in the middle pair  Next swap elements in the middle two pairs  Next swap elements in the middle three pairs   iterate n-1 steps.  Ex: with n = 4. a1 a2 a3 a4 b1 b2 b3 b4 a1 a2 a3 b1 a4 b2 b3 b4 a1 a2 b1 a3 b2 a4 b3 b4 a1 b1 a2 b2 a3 b3 a4 b4"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Anony and Adiser I think there is an O(n) sol for this :) I went thro some examples and the new position of an elt can be given mathematically new id=(2*old id)%N...here N is the final index...not the number of elts...or (no of elts-1) Heres the code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Copies from another similar question asked in this forum  Algorithm:  First swap elements in the middle pair Next swap elements in the middle two pairs Next swap elements in the middle three pairs  iterate n-1 steps.  Ex: with n = 4. a1 a2 a3 a4 b1 b2 b3 b4 a1 a2 a3 b1 a4 b2 b3 b4 a1 a2 b1 a3 b2 a4 b3 b4 a1 b1 a2 b2 a3 b3 a4 b4"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"This is in place array transpose."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Use divide and conquer for n log n. This is faster than O(n) in-place transposes on real hardware because of caching effects. (Yes, I've tried it.)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Input: a1,a2,a3,a4,.....an,b1,b2,b3,b4,.....,bn Output: a1,b1,a2,b2,a3,b3,a4,b4,..........an,bn.  If we notice, there is a pattern for all elements while shuffling. For all elements from 1st half portion (a1 to aN) a[i] is moved to a[2*i] where 0<= i <= n [say array name is a] i.e. a[0] is moved to a[0] (for i=0, i = 2*i =0) a[1] is moved to a[2] a[2] is moved to a[4] a[3] is moved to a[6] ...... .... For 2nd half, same is true from opposite (OR if we see array inverted,b1 to bN behaves same as a's) In other words, keeping array as is, 2nd half of the array (b1 to bN) goes like this  a[i] is moved to a[(n+1)-2*(n-i)] where n/2 < i < 2n i.e. (Assuming 2nd half array starting with index i=7, so total array size 12)  a[7] moved to a[1] a[8] moved to a[3] a[9] moved to a[5]  overall as example: Input a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11] Output: a[0], a[6], a[1], a[7], a[2], a[8], a[3], a[9], a[4], a[10], a[5], a[11]  And I believe it's pretty straightforward to implement this. using only few extra variables [not dependent on array size](Based on implementation). So, O(n) time and O(1) space [IN PLACE].  Alg: [assuming all elements are > 0)  Negate all elements (a[i] = -1 * a[i];) current_index = 0; current_element=A[0]; do     if current_index <= n/2 then            to_index = 2*current_index     else            to_index = (size + 1) - 2*(size - current_index)     end if     current_element = A[to_index];     A[to_index] = -1 * A[current_index];     if current_element > 0 then           to_index = index of next negative element.     current_index = to_index; while A[current_index] < 0  Algo can be modified to check in other cases like when elements can be negative also, OR elements are characters, strings. There can be different ways to track if all elements are processed or not, depending on problem. e.g. if negative elements are also in input then, Add some very very negative no to all elements say -50000 and while assigning it to to_index, adding 50000 If element are characters, string then attach some keyword (prefix or suffix) to each element, while assigning it to to_index, remove the attachment."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void reorder(char[] input, int n) { \n  for (int i = 1; i < input.length; i = i+2) { \n   int replaceElem = (2*n + i - 1)/ 2; \n   char swap = input[replaceElem]; \n   for (int j = replaceElem; j > i; j--) { \n    input[j] = input[j-1]; \n   } \n   input[i] = swap; \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@blueskin: Yes, my algorithm has O(n*n) time complexity but O(1) space complexity. Your algorithm will need additional storage to store the corresponding values.   If we are allowed O(n) space complexity, the simplest thing to do would be to just use two queues. Put values a1 to an in Q1 and b1 to bn in Q2. Now, just dequeue one element from each and keep populating the array. O(n) time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void ReOrder(ArrayList a) {     for(int  i=a.size()/2; i                int finalPos=((i-a.size()/2)+1)*2-1;                 String temp=a.get(i).toString();                 for(int j=i; j>finalPos; j--){                         a.set(j, a.get(j-1));                  }                  a.set(finalPos, temp);         } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If [a1,a2,a3...,an,b1,b2...bn] is given input change this to [a1,b1,a2,b2.....an,bn]  The idea is to move index 2 everytime, starting at 1. swap a[i] with a[len/2+i] - a1,b1,a3,a2,b2,b3. swap a[i+1] with a[len/2+i] - a1,b1,a2,a3,b2,b3.  The idea to start with keep every 2 things in order and move forward."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"lets take a0, a1, a2, a3, a4, b0, b1, b2, b3 ,b4, b5. 1) swap a1 with b0  to get  a0, b0, a2, a3, a4, a1, b1, b2, b3 ,b4.  2) shift a1 to arr[2] to get  a0, b0, a1, a2, a3, a4, b1, b2, b3  b4.  now we reduced problem from 10no.arry to 8no. array. two steps take n/2 swaps. decreasing by 1 with each iteration. so order is O(n2).  otherthan this, i did nt see a better solution. Can any one improve this?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I tried a recursive process of starting at pos1, moving it to its correct place, then moving the element there to its correct place in tunr, once you have done len -1 steps you are done. You wont get any cycles because you are always putting something in its correct place - no 2 elements can be in the same place. Only the first element starts off in its correct place. Not sure if stack for recursion violates in-place though"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Anurag,  how many times does the nested for loop run for each iteration? does nt that change order?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"yup that works :) cool soln. thx satya."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Another O(n) solution based on divide-and-conquer. Recursively divides n by 2, and use the result of two halves to merge the final result.   Examples demonstrate for n = 2^k. When n is not 2^k, we can add some dummy elements, and do the same process, and finally discard those that are dummy."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I took anon's code for making the list but a different approach for arranging it - I believe this is O(n) and satisfies the in-space problem"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(N) ..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \nstruct demo{ \n  char c[3]; \n}; \n \nvoid swap(struct demo *a, struct demo *b) \n{ \n  struct demo temp; \n  temp = *a; \n  *a = *b; \n  *b = temp; \n} \n \nint  main() \n{ \n  int size,i,j,p,x,y; \n  static struct demo ab[10] = {{\"a1\"},{\"a2\"},{\"a3\"},{\"a4\"},{\"a5\"},{\"b1\"},{\"b2\"},{\"b3\"},{\"b4\"},{\"b5\"}}; \n \n  size = sizeof(ab)/sizeof(ab[1]); \n \n  for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// extension of swapping problem   j=n; for(i=1;i{ temp=a[i]; a[i]=a[j]; a[j]=temp; j++; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// extension of swapping problem   j=n; for(i=1;i{ temp=a[i]; a[i]=a[j]; a[j]=temp; j++; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// extension of swapping problem   j=n; for(i=1;i{ temp=a[i]; a[i]=a[j]; a[j]=temp; j++; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@ankur  Please run through the code.I don't think it is correct. REsulting order has to be  a1,b1,a2,b2,a3,b3 ...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Though bad in terms of efficiency, it can be done in way of insertion sort, where pick b1 and insert at 2nd position and  copy a2-an one by one till b1 position"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void printArray(char a[][5],int len) {  int i;  for(i=0;i  printf(\"%s  \",a[i]);  }  printf(\"\\n\"); }  void shuttleArray(char a[][5],int len) {  printArray(a,len);  int count=1; int i,j; int pos=0;  char *newbuf=(char *)malloc(5);  char *oldbuf=(char *)malloc(5); char *tmp;  int *mark=(int *)malloc(sizeof(int)*len);  for(i=0;i  mark[i]=0;  i=1;  strcpy(oldbuf,a[i]);  mark[0]=1;  while(count  if(i   pos=(2*i+1)%len-1;   else    pos=(2*i)%len+1;   strcpy(newbuf,a[pos]);   strcpy(a[pos],oldbuf);   mark[i]=1;   tmp=oldbuf;   oldbuf=newbuf;   newbuf=tmp;   i=pos;   if(mark[i]==1) {    for(j=0;j    if(mark[j]==0)      break;    i=j;    strcpy(oldbuf,a[i]);   }   ++count;  }  printArray(a,len); }  int main(void) {  //puts(\"!!!Hello World!!!\"); /* prints !!!Hello World!!! */  //int a[]={1,2,3,3};  //permutation(a,4,0);  char a[10][5];//={\"a0\",\"a1\",\"a2\",\"a3\",\"a4\",\"b0\",\"b1\",\"b2\",\"b3\",\"b4\"};  int i,pos;  for(i=0;i<5;i++) {   sprintf(a[i],\"a%d\",i);  }  for(i=0;i<5;i++) {   sprintf(a[i+5],\"b%d\",i);  }  int len=10;  for(i=0;i  if(i   pos=(2*i+1)%len-1;   else    pos=(2*i)%len+1;   printf(\"%d   \",pos);  }  printf(\"\\n\");  shuttleArray(a,10);  return EXIT_SUCCESS; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for(i=1,j=n ; j<2n||i<2n; i+=2,j++) {  temp = arr[j];  for(k=j;k>=i;k--)   arr[k]=arr[k-1];  arr[i] = temp; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void printArray(char a[][5],int len) {  int i;  for(i=0;i  printf(\"%s  \",a[i]);  }  printf(\"\\n\"); }  void shuttleArray(char a[][5],int len) {  printArray(a,len);  int count=1; int i; int pos=0;  char *newbuf=(char *)malloc(5);  char *oldbuf=(char *)malloc(5); char *tmp;  i=len/2;  strcpy(oldbuf,a[i]);  while(count  if(i   pos=(2*i+1)%len-1;   else    pos=(2*i)%len+1;   strcpy(newbuf,a[pos]);   strcpy(a[pos],oldbuf);   tmp=oldbuf;   oldbuf=newbuf;   newbuf=tmp;   i=pos;   ++count;  }  printArray(a,len); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void cyclicswap(int *arr1, int *arr2) {      int n = arr2-arr1;      int temp = *arr2;    while(arr2!=arr1)    {      *arr2 = *(arr2-1);                     arr2--;                   }              *arr1 = temp;;             }  void rearrange(int *arr,int n) {      if (n==2)         return;      swap(arr+1, arr+(n/2));              cyclicswap(arr+2,arr+(n/2));        rearrange(arr+2,n-2);          }  main() {      rearrange(arr,sizeof(arr)/sizeof(arr[0]));   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the index i is from 1 to 2n.  if i <= n,   j=2*i-1, //the final place else  j=2*(i-n)  use a loop from 2 to n-1 to put each element into the final place.  void rearrange(int *a, int n) {   for(int i = 1; i < 2*n; ++i)   {    } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"+23          int chars_left = n/2;    +24          for(int position = 1; chars_left != 1; chars_left--,position = position+2)    +25          {    +26                  for(int i = n - chars_left; i > position; i--)    +27                  {    +28                          int temp = c[i];    +29                          c[i] = c[i-1];    +30                          c[i-1] = temp;    +31                  }    +32          }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If N is power of 2, swap the second half of a[i] with the first half of b[i] with O(N/2) operations. Then recursively do rearrange of the first N elements and the second N elements. If N is not power of 2, some spacial handling is needed to decide how many elements to swap each time. But it does not change the complexity. The overall complexity is O(NlgN)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ch.v.Suresh:  Under line high lighted are shift elements.  One shift:  a1 a2 a3 a4 a5 a6 a7 a8  ---> Even postions    --    --    --    -- b1 b2 b3 b4 b5 b6 b7 b8  ---> Odd positions --    --    --    --  Two shift:   a1 b1 a3 b3 a5 b5 a7 b7       -----       ----- a2 b2 a4 b4 a6 b6 a8 b8 -----       -----    Four shift:   a1 b1 a2 b2 a5 b5 a6 b6             -----------  a3 b3 a4 b4 a7 b7 a8 b8 -----------  Result:  a1 b1 a2 b2 a3 b3 a4 b4 a5 b5 a6 b6 a7 b7 a8 b8"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ch.v.Suresh:  Under line high lighted are shift elements.  One shift:  a1 a2 a3 a4 a5 a6 a7 a8 ---> Even positions a2,a4,a6,a8     --   --    --    -- b1 b2 b3 b4 b5 b6 b7 b8 ---> Odd positions b1,b3,b5,b7 --    --    --    --  Two shift:  a1 b1 a3 b3 a5 b5 a7 b7 --> Even positions (a3,b3) , (a7,b7)       -----       ----- --> Odd positions (a2,b2) , (a6,b6) a2 b2 a4 b4 a6 b6 a8 b8 -----       -----  Four shift:  a1 b1 a2 b2 a5 b5 a6 b6   --> Shift (a5,b5,a6,b6) with (a3,b3,a4,b4)             ----------- a3 b3 a4 b4 a7 b7 a8 b8 -----------  Result:  a1 b1 a2 b2 a3 b3 a4 b4 a5 b5 a6 b6 a7 b7 a8 b8"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include /*a1b1a2b2a3b3*/ void set(char a[],int m1,int m2); int main() {     char a[7]={'a','c','e','b','d','f','\\0'};     int m1,m2,len,i;     len=strlen(a);     m1=(len-1)/2;     m2=m1+1;     set(a,m1,m2);     for(i=0;i    printf(\"%c\",a[i]);}     getchar();     getchar();     return 0; } void set(char a[],int m1,int m2) {    int len;    char t;    len=strlen(a);    t=a[m1];    a[m1]=a[m2];    a[m2]=t;    while(m1>1 && (m2<(len-1)))    {      t=a[m1];      a[m1]=a[m1-1];      a[m1-1]=t;      t=a[m2];      a[m2]=a[m2+1];      a[m2+1]=t;      --m1;++m2; }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include /*a1b1a2b2a3b3*/ void set(char a[],int m1,int m2); int main() {     char a[7]={'a','c','e','b','d','f','\\0'};     int m1,m2,len,i;     len=strlen(a);     m1=(len-1)/2;     m2=m1+1;     set(a,m1,m2);     for(i=0;i    printf(\"%c\",a[i]);}     getchar();     getchar();     return 0; } void set(char a[],int m1,int m2) {    int len;    char t;    len=strlen(a);    t=a[m1];    a[m1]=a[m2];    a[m2]=t;    while(m1>1 && (m2<(len-1)))    {      t=a[m1];      a[m1]=a[m1-1];      a[m1-1]=t;      t=a[m2];      a[m2]=a[m2+1];      a[m2+1]=t;      --m1;++m2; }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"input: \"0123456789\" output: \"0516273849\""},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void ArrangeIntegers(int[] numbers)         {             if (numbers != null && numbers.Length > 3)             {                 int n = numbers.Length;                 int ps = 1;                 int pe = (n / 2) - 1;                 int qs = (n / 2);                 int qe = n - 2;                 Queue numque = new Queue();                 numque.Enqueue(numbers[ps]);                 numque.Enqueue(numbers[qe]);                 bool fAlt = true;                  while (ps < qe)                 {                     if (fAlt == true)                     {                         int t1 = numbers[ps];                         numbers[ps] = numbers[qs];                         numbers[qe] = (ps == pe)? t1 : numbers[pe];                         fAlt = false;                         pe--;                         qs++;                     }                     else                     {                         numque.Enqueue(numbers[ps]);                         numque.Enqueue(numbers[qe]);                         numbers[ps] = numque.Dequeue();                         numbers[qe] = numque.Dequeue();                         fAlt = true;                     }                     ps++;                     qe--;                 }             }         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ArrangeIntegers function can also written as generic function to handle the different type of data types. This is function has O(log n) time complexity.  One additional check I missed was to check (numbers.Length % 2 == 0) just to make sure 2n condition holds."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have a O(n) method with O(1) space. Since every element is not in its final position except first and last element, we can randomly pick one element at first, for example the second one(a2), record its posision(currentIndex) and do the following loop until a2 in its final position(currentIndex==2): 1. calculate which element should be in this currentIndex position    if currentIndex is even number, the element should be in this position is a1...an. We use currentIndex/2 to calculate the current position of this element(index)    if currentIndex is odd numver, the element should be in this position is b1...bn. we use (currentIndex-1)/2+n  2. swap arr[currentIndex] and arr[index]. 3. record the current position of a2(currentIndex)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//arr = {a1,a2,a3,...,an,b1,b2,b3...,bn} //array index starts from 0 and goes to arr.length - 1   public static void main(String[] args) {   int i;   int [] arr = {11,12,13,14,15,16,17,1,2,3,4,5,6,7};   //int [] arr = {1,2,3,4,5,6,7,11,12,13,14,15,16,17};   boolean isOdd = (((arr.length /2) % 2) != 0)? true:false;      printArr(arr);   //First Loop   for (i = 1; i < (arr.length /2); i+=2) {    swap(arr,i,(arr.length /2) + i - 1);   }   printArr(arr);   //Second Loop   if(isOdd){    for (i = (arr.length/2)-1; i < arr.length-2; i++) {     swap(arr,i,i+1);    }   }   printArr(arr);   final int N = isOdd? (arr.length-2)/2:arr.length/2;   int itr = N;   int x=0;   for (i = 2; i <2*N && itr < 2*N; i+=2)   {    if(arr[i]> arr[itr])    {     if(i     swap(arr,i,itr);      swap(arr,i+1, itr+1);      x++;      if(x==2)      {       itr+=2;       x=0;      }     }    }    else{     if(i>itr) {      swap(arr,i,itr);      swap(arr,i+1, itr+1);     }    }   }   printArr(arr);  }   static void swap(int[] a, int i, int j) {   int t = a[i];   a[i] = a[j];   a[j] = t;  }  static void printArr(int []arr){   for(int i = 0; i < (arr.length);i++){    System.out.print(arr[i]);    if (i!=arr.length-1)     System.out.print(\",\");   }   System.out.println();  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//----------------REFORMATTED ABOVE----------------------- //arr = {a1,a2,a3,...,an,b1,b2,b3...,bn} //array index starts from 0 and goes to arr.length - 1    public static void main(String[] args) {         int i; //     int [] arr = {1,2,3,4,5,6,7,11,12,13,14,15,16,17};         int [] arr = {11,12,13,14,15,16,17,18,1,2,3,4,5,6,7,8};         boolean isOdd = (((arr.length /2) % 2) != 0)? true:false;            printArr(arr);         //First Loop         for (i = 1; i < (arr.length /2); i+=2) {                 swap(arr,i,(arr.length /2) + i - 1);         }         printArr(arr);         //Second Loop         if(isOdd){                 for (i = (arr.length/2)-1; i < arr.length-2; i++) {                         swap(arr,i,i+1);                 }         }         printArr(arr);         final int N = isOdd? (arr.length-2)/2:arr.length/2;         int itr = N;         int x=0;         for (i = 2; i <2*N && itr < 2*N; i+=2)         {                 if(arr[i]> arr[itr])                 {                         if(i                                swap(arr,i,itr);                                 swap(arr,i+1, itr+1);                                 x++;                                 if(x==2)                                 {                                         itr+=2;                                         x=0;                                 }                         }                 }                 else{                         if(i>itr) {                                 swap(arr,i,itr);                                 swap(arr,i+1, itr+1);                         }                 }         }         printArr(arr); }  static void swap(int[] a, int i, int j) {         int t = a[i];         a[i] = a[j];         a[j] = t; } static void printArr(int []arr){         for(int i = 0; i < (arr.length);i++){                 System.out.print(arr[i]);                 if (i!=arr.length-1)                         System.out.print(\",\");         }         System.out.println(); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ideone.com/P5aiI  Please comment on this"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int a[10]={0,1,2,3,4,5,6,7,8,9};  int i,j;  int temp;  for(i=1, j=5;i<10;i+=2,j++)  {    temp=a[j];    for(int k=j-1;k>=i;k--)     a[k+1]=a[k];    a[i]=temp;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int a[10]={0,1,2,3,4,5,6,7,8,9}; \n int i,j; \n int temp; \n for(i=1, j=5;i<10;i+=2,j++) \n { \n   temp=a[j]; \n   for(int k=j-1;k>=i;k--) \n    a[k+1]=a[k]; \n   a[i]=temp; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include   using namespace std;   void rearrange(int a[],int n,int pos) {      if(pos == n/2) { for (int i=0;i     int k=0;      for(int i=pos;i     {       swap(a[i],a[k++ +(n/2)]);                  }         rearrange(a,n,pos+1); } int main() {     int a[]={1,3,5,7,2,4,6,8};            rearrange(a,8,1);     cin.get();     cin.ignore();     return 1; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void Rearrange(int a[],int n) \n{ \n int i,j; \n for(i=0 ; i < (n/2)-1; i++) \n { \n   int k=0; \n   for(j=0; j<=i; j++) \n   { \n    //calculating postion of elements need to be swapped \n    int pos1 = (n/2)-(i+1)+k; \n    int pos2 = (n/2)-(i)+k; \n    //Swapping \n    int temp = a[pos1]; \n    a[pos1] = a[pos2]; \n    a[pos2] = temp; \n    k=k+2; \n   } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we will  use a function which will take three parameter : 1.[Array](char []a)  2.[index Which need to move in rite position] (int i) 3.[value to place at new position](char c)   we will initiate function as : a=arrangeArray(a,1,a[n]); This function is responsible for move index i value to the deserving place.It also copy the value of new place and call another function to place this value to its deserving place.when all places will be arrange i will become 'n' and the recursion will stop.  the function is:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi,  I got the O(n) solution of this problem:  #include int main() {   int n,t,i,j,t1;  int arr[100];   //n: number of elements in array.  //  scanf(\"%d\",&n);   for(i=0;i {   scanf(\"%d\",&arr[i]);  }  int p,distance,count;  int ni; //new index  count=0;   for (i=1,ni=1;i {   //First find the distance   //based on if number is in first half or second half   //based on distance find the new index of this number.   //   if(ni   distance=ni;    p=2*distance;   }   else{    distance=ni-n/2+1;    p=2*distance-1;   }    //swap arr[i] with arr[p].   //    t=arr[p]; arr[p]=arr[i]; arr[i]=t;      if (i==p){    i=i+2;    ni=i;   }   else    ni=p;  }     printf (\"The output array is:\\n\");  for (i=0;i {   printf (\"%d \", arr[i]);  }     return 0;  }   Logic is: Fix i on 1. Find the new index of this number. swap arr[1] with this new index. Record this new index in ni and this number is on 1. Now find the new index based on ni. and swap arr[1] with this new index. Keep doing this till you have swapped n-2 elements.  Just one trick, after some iterations correct element will come to a[1] then increment index by 2[I don't how did it work, it was just based on example of 10 element array and now I tested it works for any number of elements]."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this looks to me as a very simple question, why the solutions are so long??   bool reorder(int *array,int n) {     if(array && n)     {         for(int i=n;i<2*n;++i)         {             int temp=array[i];              for(int e=i;e>(i-n)*2+1;--e)             {                 array[e]=array[e-1];             }              array[(i-n)*2+1]=temp;         }          return true;     }      return false; }  int main(int argc, char *argv[]) {       int array[]={1,2,3,4,5,6,7,8,9,0};     int n=5;      for(int i=0;i<2*n;++i)         printf(\"%d,\",array[i]);     printf(\"\\n\");      reorder(array,5);      for(int i=0;i<2*n;++i)         printf(\"%d,\",array[i]);     printf(\"\\n\"); }  test input: 1,2,3,4,5,6,7,8,9,0, test output: 1,6,2,7,3,8,4,9,5,0,"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@above what is the run time of your code? it should be O(n). Your code is not O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.create two heaps a1----an,b1----bn by index of element 2.Now delete the root of each and insert it at starting  3.repeat the 1st step again till end"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"complexity will be (nlogn) i think"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Easy to understand code which runs in O(n^2) time"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is one recursive solution I propose : \n \nconsider example a1,a2,a3,a4,b1,b2,b3,b4 \n \n1. if n is even \n    swap second Half of first array with first half of second array \n    so it would be a1,a2,b1,b2,a3,a4,b3,b4 \n    and it  can be solved recursively     \n    so rearrange({a1,a2,a3,a4,b1,b2,b3,b4}) = rearrange({a1,a2,b1,b2}), rearrange({a3,a4,b3,b4}); \n2. if n is odd (a1,a2,a3,a4,a5,b1,b2,b3,b4,b5) \n    swap second Half+1 of first array with first half+1 of second array \n    so it would be a1,a2,b1,b2,b3,a3,a4,a5,b4,b5 \n    swap bolded elements( nth and n+1 th) a1,a2,b1,b2,a3,b3,a4,a5,b4,b5 \n    and it  can be solved recursively by dividing in two sub parts \n    rearrange({a1,a2,a3,a4,a5,b1,b2,b3,b4,b5}) = swap(b3,a3), rearrange({a1,a2,b1,b2}), rearrange({a4,a5,b4,b5}); \n \nlimiting case would be \nif n==2 //since the pair is in required order \nreturn; \n \nTime complexity analysis ( n is size of total array a+b): \n \nT(n) = 2*T(n/2) + n/4   ( n/4 is swapping time of second Half of first array with first half of second array) \n \nT(n) = 2^k T(1) + n/4( 1+1/2+1/4+.......+1/(2^k)) \n= 2^k+n/4( 1-1/(2^k))*2                k = log(n) \n=n+ (n-1)/2 \n=O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This will work if element are of int/char/float types  #define SWAP(X,Y) (X=X^Y;Y=X^Y;X=X^Y;)  arrayChange(int a[]){   int size = sizeof(a)/sizoof(a[0]);   int i = 0;    while(i < size/2){     SWAP(a[i++], a[size-- - 1]);   } }      size--; } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include using namespace std; int main(int argc, char*argv[]) {  int a[] = {1,2,3,4,5,6,11,22,33,44,55,66};  int n = 6;  int temp1 = 0;  int temp2 = 0;  int changed = 2;  for(int i =1;(i {   int start = i;   int oldIndex = i;   int newIndex = 0;   temp1 = a[oldIndex];   while(start!=newIndex)   {    if(oldIndex>=n)    {     newIndex = 2*(oldIndex-n)+1;    }    else    {     newIndex = 2*oldIndex;    }        temp2 = a[newIndex];    a[newIndex] = temp1;    changed++;    temp1 = temp2;    oldIndex = newIndex;   }   //a[start] = temp1;  }  for(int i=0;i<2*n;i++)  {   printf(\"%d \",a[i]);  }  printf(\"\\n\"); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package arrays; \n \npublic class Exchange { \n public static void exchange(int[] a){ \n  exchange(a, (a.length/2) - 1, a.length/2); \n } \n  \n private static void exchange(int[] a,int x,int y){ \n  if(x==0 || y==a.length-1){ \n   return; \n  } \n   \n  for(int i=x;i<=y;i=i+2){ \n   int temp = a[i]; \n   a[i] = a[i+1]; \n   a[i+1] = temp; \n  } \n  exchange(a, x-1, y+1); \n } \n  \n public static void main(String[] args){ \n  int[] a = {1,2,3,4,5,6,7,8,9,10}; \n  exchange(a); \n  for(int i : a){ \n   System.out.print(i + \" \"); \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package arrays; \n \npublic class Exchange { \n public static void exchange(int[] a){ \n  exchange(a, (a.length/2) - 1, a.length/2); \n } \n  \n private static void exchange(int[] a,int x,int y){ \n  if(x==0 || y==a.length-1){ \n   return; \n  } \n   \n  for(int i=x;i<=y;i=i+2){ \n   int temp = a[i]; \n   a[i] = a[i+1]; \n   a[i+1] = temp; \n  } \n  exchange(a, x-1, y+1); \n } \n  \n public static void main(String[] args){ \n  int[] a = {1,2,3,4,5,6,7,8,9,10}; \n  exchange(a); \n  for(int i : a){ \n   System.out.print(i + \" \"); \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//given an array [a1,a2,a3...,an,b1,b2...bn], change it to [a1,b1,a2,b2.....an,bn], solution should be in-place     public static void exchange(int[] array, int n) {         int y = array.length - 1;         for (int x = n - 1; x >= 0; x--, y -= 2) {             int temp = array[x];             int j;             for (j = x + 1; j < y; j++) {                 array[j - 1] = array[j];             }             array[j - 1] = temp;         }     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What do you think guys about this solutions.  Put all the a0 to an in two queues Now remove alternately from queue1 and queue1 and place it in the original array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \"stdafx.h\"  int func(int index,int len) {  if(index  return 2*index;  else   return (2*index-len+1); } int main() {  int a[]={1,2,3,4,5,6,7,8,9,10,11,12};  int count =0,hold=a[1],temp,index=1;  int length = 12;  while(count<(length-2))  {   temp = hold;   hold = a[func(index,length)];   a[func(index,length)] = temp;   index = func(index,length);   count++;   if(index == 1)   {    //temp = hold;    //hold = a[func(index,length)];    //a[func(index,length)] = temp;    index +=(length-count-2);    hold = a[index];    //count++;    }   }  for(index=0;index  printf(\"%d\\t\",a[index]);   return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class TestNumber {   public static void main(String[] args) {   String[] strAr = {\"a1\",\"a2\",\"a3\",\"a4\",\"a5\",\"b1\",\"b2\",\"b3\",\"b4\",\"b5\"};   String[] sortAr = new String[strAr.length];   int j =0;   int k=strAr.length/2;   int m=0;   for(int i=0;i   if(i%2 == 0){     sortAr[j++]=strAr[m++];    }else{     sortAr[j++]=strAr[k++];    }   }      for(String str: sortAr){    System.out.println(str);                 }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n#include \n#include \n \nusing namespace std; \n \nchar str[100] ; \nint l ; \nint global ;  \n \nvoid func(int idx , char ch1 ,char ch2) \n{ \n if(idx == l/2) \n  return ; \n ch1 = str[idx] ;  \n ch2 = str[idx + l/2] ;  \n func(idx + 1 , ch1 , ch2); \n str[global] = ch2 ;  \n str[global -1] = ch1 ;  \n global -= 2 ; \n return ; \n} \n \nint main() \n{ \n scanf(\"%s\",str); \n l = strlen(str); \n global = l - 1; \n \n func(0,'\\0','\\0'); \n \n printf(\"%s\\n\",str); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's my implementation with O(n) in time & space"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's my implementation with O(n) in time & space"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's my implementation with O(n) in time & space"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Meh, O(n^2)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package com.aa.array;  public class SortedOutPut {   /**   * @param args   */  public static void main(String[] args) {   String a [] = new String[] {\"a1\",\"a2\",\"a3\",\"a4\",\"a5\",\"a6\",\"b1\",\"b2\",\"b3\",\"b4\",\"b5\",\"b6\"};      int n= a.length;   int j =n/2;   for(int i=0 ; i < n ; i+=2){    String tmp= a[j];    shift(a,i+1,(j));    a[i+1]=tmp;    j++;   }   for(int i=0 ; i < n ; i++){    System.out.println(a[i]);   }  }   private static void shift(String[] a, int i, int j) {   for(int k = j ; k >=i ; k-- ){    a[k]=a[k-1];   }     }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a very simple method. o(n) time and o(1) space.  assume the array 1. scan through n,n+1,...,2*n to move each bi to the right position. 2. scan through 1,3,5,7,...,2*n-1 to move each ai to the right position. step 1 or 2 need swap n elements, total time o(n)  CODE: void cross_swap(vector &a){  if(a.size()<=0)   return;  assert(a.size()%2==0);  int n=a.size()/2;  int ind=-1;  for(int i=0;i  ind+=2;   swap(a[ind],a[i+n]);  }  int i=0;  char buf[10];  int count=1;  while(i!=a.size()-2){   string tmp=a[i];   tmp=tmp.substr(1);   int num=atoi(tmp.c_str());   if(num!=count)    swap(a[i],a[2*(num-1)]);   else    i+=2,count++;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void do_this(int a[], int n) if (n==0) return ;  for (int i=n; i >=2; i--)         swap(a[i], a[i-1]); do_this(a+2, n-1); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int* algo(int *a,int size) \n{ \n int n=size/2; \n int j=n+1; \n int i=2; \n int temp=0; \n int temp2=0; \n while(i<2*n) \n { \n  temp=j-i; \n  temp2=j; \n  while(temp !=0) \n  { \n   swap(a,temp2,temp2-1); \n   temp2--; \n   temp--; \n  } \n  j++; \n  i=i+2; \n } \n retur"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"s = array.length / 2; for( int i =1; i < s; i++)    swap( array[i], array[n+i-1] )"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; import java.util.Arrays;   public class FindSingleDuplicate {     public static void main(String[] args) {       int[] arr = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20};        System.out.println(\"Before shifting the elements::\" +Arrays.toString(arr));    arr = sort(arr);     System.out.println(\"After shifting the elements::\"+Arrays.toString(arr));  }   private static int[] sort(int[] arr) {       int mid = (arr.length-1)/2;   for(int i=1;i<=mid;i++)   {    int count = 1;        for(int j = -(i-1);count <= i; count++)    {     arr = swap(arr,(mid+j),(mid+j+1));    j+=2;    }       }   return arr;  }   private static int[] swap(int[] arr,int i, int j) {      int temp = arr[i];   arr[i] = arr[j];   arr[j] = temp;      return arr;  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Time complexity for the above is O(n*n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is this solution's time complexity O(n)?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The first technique works fine: Successively keep swapping pairs from the middle."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The first technique works fine: Successively keep swapping pairs from the middle."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The first technique works fine: Successively keep swapping pairs from the middle."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"But a better O(n) solution is that new idx = (old idx * 2)/(num_elements - 1)  //working C++ code"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6748824919867392","download_status":"DOWNLOAD_DONE","votes":"4","answersCount":"61","title":"Given a array of size n. Divide the array in to two arrays of size n/2,n/2. such that average of two arrays is equal.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Let S = Sum(all numbers) / 2, the sum of the elements each array shall have. I suppose N is reasonably small, like N <= 40. One approach would be  Work with 2 halves A and B of the array independently: A from indices [0, N/2-1] and B from [N/2, N-1].  Generate all possible sums of elements in array A. Use N/2 hash tables, one for each number of elements of the subsets, and put the sum of a subset in the corresponding hash table. There are 2^(N/2) subsets of A, this takes O(N/2 * 2^(N/2)) time.  Then generate all possible sums of B. For each subset of B, with X elements and sum Z, check if there is a subset of A in the hash table for sizes N/2-X with sum S-Z. There are also 2^(N/2) subsets and each lookup in a hash table takes O(1).  So this takes total time O(N/2 * 2^(N/2)) and O(2^(N/2)) space. For N=40, N/2 = 20 and 2^20 is ~1 million which is usually ok."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I think this can be solved like this: 1) Average of both (n/2) blocks is same=> total is same 2) Total of both blocks = 1/2 * total of n number  => Add up all n numbers = T => find (n/2) numbers which add upto T/2 => the leftover will also add up to T/2 (obvious) we can use a DP for the above solution.. which is like the coin & sum problems"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"No guarantee that such a division is possible but using DP the logic would be something like this: - calculate total sum"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"average equal, means sum equal. 1. iterate the array, calculate the sum of the array: Sigma 2. find a sub array with n/2 elements and the sum is Sigma/2  normally like a recusive solution for step 2, cost O((n/2)!) time.  Anyone can provide better solution?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1 sort the array. 2. Create two groups by picking elements in pairs but in alternate fashion. Assuming after sorting array is a[1]....a[n] gr1:(a[1],a[n]) (a[3], a[n-2]) so on gr2: (a[2], a[n-1])(a[4], a[n-3]) so on"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Asked here before: change the question id in the above url to: 2622"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be done by using the subset sum algorithm where the target sum equals the half of total sum of array elements. In addition, we need to impose a limit on the permissible length of the selected sub-array so that it is equal to the half of the total number of elements in the array. Here's the code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First of all this is not possible for each and every data.  say, array has only 2 elements : 1,1000000  Whatever we do, we'll end up with 2 arrays with average 1 and 1000000 respectively.  If possible for a particular array, I think DP would be best approach"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can you give me solution to thiis array a[] = { 2,3,5,6,8} sum = 24 avg = 12 but no combination will give sum of 12"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.) Calculate sum of the array  requirement can now be broken in to finding sum/2  1.) calculate a recursive approach to the sum with an auxilary array to keep a track of element as a part of the sum 2.) Of all possible combinations print the one with length =n/2 of original array. dirty code for finding sum find sum(int []A , int [] Ix, int sum, int T, int n)  {   if(sum>T)   return;   if(sum==T)   {     if(Ix.length ==A.length /2)     print (A,Ix,n);     return;   }   for(int i = Ix[n] :i   Ix[n+1]=i    findssum(A,IX,sum+A[i],n+1); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think we can use DP. While finding the numbers for n/2 array I can store the indices. Since the array which we need to make is n/2 so the sum of all elements will be S such that 2S is the sum of main array in question.  Pseudocode  FindArray(A,Sum,a) be the function where A is the main array, Sum = Sum at any state, a be n/2 array which we need to fill"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I don't understand why you people are assuming only positive number. Has anyone mentioned this question is valid for only positive numbers ?? What if it contains negative numbers ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"But to divide an array in n/2,n/2 ,we have to have even size array?How about if array is of size 5 which is odd then 5/2,5/2 what ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Stack;  public class Node {     public static void main(String[] args){      int arr[] =  {1,2,3,4,5,6,7,8};   int sum = 0;   int sum1=0;   Stack st = new Stack();   for(int i=0;i       sum += arr[i];       }   out:   for(int i=0;i   sum1 = arr[i];    for(int j=i+1;j         sum1 += arr[j];          if(sum1 == sum/2){      st.push(i);      st.push(j);      break out;     }    }   }   System.out.println(st);  }   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Check out my solution :  \"github.com/amitgoswami/ALGO_TRIALS/blob/dev/CommonAlgoQuestions/SubsetSumEqualNos/src/SubsetSumEqual.java\"   it is a link add https as prefix"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(2^n) is pretty simple. I think this problem is \"NP-complete\".  Model: Solve the following integer equations over binary variables:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package main; \n \nimport java.util.ArrayList; \nimport java.util.List; \n \n/* \n Given a array of size n. Divide the array in to two arrays of size n/2,n/2. such that average of two arrays is equal. \n */ \n \npublic class Main { \n \n    public static void main(String[] args) { \n        System.out.println(\"Begin \"); \n        List input = new ArrayList(); \n        List output = new ArrayList(); \n         \n        input.add(1); \n        input.add(2); \n        input.add(3); \n        input.add(4); \n        input.add(5); \n        /*input.add(10); \n        input.add(7); \n        input.add(8); \n        */ \n        try { \n   fill(input, output, 2, 5); \n  } catch (Exception e) { \n   System.out.println(\"Found\"); \n  } \n        System.out.println(\"End \"); \n    } \n     \n    private static void fill(List left, List solution, int depth, int target) throws Exception \n    { \n     if(depth == 0) \n     { \n      if(sum(solution) == target) \n      { \n       System.out.println(print(solution)); \n       return; \n       //throw new Exception(\"found\"); \n      } \n     } \n     else \n     { \n      int i = 0; \n       \n      while( i < left.size()) \n      { \n       Integer current = left.get(i); \n       left.remove(current); \n       solution.add(current); \n        \n       System.out.println(\"Left: \" + print(left) + \" - Solution: \" + print(solution)); \n     \n       //System.out.println(current); \n        \n       fill(left,solution,depth-1,target); \n        \n       System.out.println(\"-----------------------------------------\"); \n        \n       solution.remove(current); \n       left.add(current); \n        \n       System.out.println(\"Left: \" + print(left) + \" - Solution: \" + print(solution)); \n        \n       i++; \n      } \n     } \n      \n    } \n     \n    private static int sum(List input) \n    { \n     int output = 0; \n      \n     for (int i = 0; i < input.size(); i++) { \n   output += input.get(i); \n  } \n     return output; \n    } \n     \n    private static String print(List input) \n    { \n     String output = \"\"; \n  for (int i = 0; i < input.size(); i++) { \n   output += input.get(i) + \",\"; \n  } \n  return output; \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"DP solution : 1. generate dp matrix upto K such that   a) k has 2 true (means there are two pairs of subset whose sum is K          b) check if two pairs are distinct and covering all elements of main set           c) if false then repeat above two steps till k reaches a optimal sum(like totalsum/tota no of elements)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the above logic picking the elements in alternate fashion works"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Arrays;  public class DevideEquel {    int[] array={4,4,6,7,7,6,3,3};  int n=array.length;      public static void main(String[] args) {    DevideEquel devideEquel=new DevideEquel();  Arrays.sort(devideEquel.array);  int mid=(devideEquel.n-1)/2;      for(int i=0;i<=mid;i++)  {   for(int j=devideEquel.n-1;j>mid;j--)   {        int temp=devideEquel.array[j];    devideEquel.array[j]=devideEquel.array[i];    devideEquel.array[i]=temp;        int left=0;    int right=0;        for(int f=0;f<=mid;f++)    {         left=left+devideEquel.array[f];    right=right+devideEquel.array[devideEquel.n-1-f];         }    if(left==right){    System.out.print(\"left=\"+left);    System.out.println(\" right=\"+right);    for(int y=0;y   {     System.out.print(\" \"+devideEquel.array[y]);    }    return;    }   }  }      }   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The inteviewers took a famous problem (partition into 2 arrays of equal sum) and they modified it to \"average\"  But average of 2 equal sized lists being equal is the same as the sum of 2 equal sized lists being equal.  So this is the PARTITION PROBLEM. Please google it and study the wikipedia page.  This is one of those question where if you didn't know this problem before hand, you would either 1) Only do brute force bad solution 2) [Most keen people] Will get an incorrect greedy algorithm that seems to work  So those folks at Amazon were expecting you to know that average is same as sum and expected you to know the partition problem (not memorized, but know enough that greedy is wrong)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this can be integer knapsack with size of sum/2 and weight of each item equals one"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Why can't we use following algorithm (haven't read comments intentionally) 1. Sort the array, complexity O(N*logN) in asc. order 2. Run through the array once (complexity is O(N)), ultimately it's gonna be O(N*logN)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I think that the sum of all the elements of the input array should be even, Steps: 1. Sort the array (number of elements in input array will always be even) 2. Will get 2 middle numbers. Put one in 1st output array and 2nd one in 2nd out put array. 3. Itrerate the input array from left side till the middle number alternatively put the elements in the out put arrays. like 0th position element  in 1 st output array and 1st position element in 2nd out put array. 4. Irerate the right side of the input array reversly till mid of te inoput array and do the same.  Please let me know if this solution is feasible.  Thanks, ankur"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"int[] val={1,3,8,4,5,6,7,8}; \n  int lsum=val[0]; \n  int rsum=val[val.length-1]; \n  int i=0,j=0; \n  for(i=1,j=val.length-2;;){ \n   if(i==j+1){ \n    break; \n   } \n   if(lsum>rsum){ \n    rsum+=val[j]; \n    j--; \n   }else if(rsum>lsum){ \n    lsum+=val[i]; \n    i++; \n   }else{ \n    rsum+=val[j]; \n    j--; \n    lsum+=val[i]; \n    i++; \n   } \n  } \n   \n  if(lsum==rsum){ \n   System.out.println(\"Found: [1,\"+i+\"][\"+(i+1)+\",\"+val.length+\"]\\tSum:\"+lsum); \n  }else{ \n   System.out.println(\"Not Found\"); \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"int[] val={1,3,8,4,5,6,7,8}; \n  int lsum=val[0]; \n  int rsum=val[val.length-1]; \n  int i=0,j=0; \n  for(i=1,j=val.length-2;;){ \n   if(i==j+1){ \n    break; \n   } \n   if(lsum>rsum){ \n    rsum+=val[j]; \n    j--; \n   }else if(rsum>lsum){ \n    lsum+=val[i]; \n    i++; \n   }else{ \n    rsum+=val[j]; \n    j--; \n    lsum+=val[i]; \n    i++; \n   } \n  } \n   \n  if(lsum==rsum){ \n   System.out.println(\"Found: [1,\"+i+\"][\"+(i+1)+\",\"+val.length+\"]\\tSum:\"+lsum); \n  }else{ \n   System.out.println(\"Not Found\");"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Assuming the number of elements in the array is even and the sum of elements is also even.  1) Sort the array. 2) Use two variables. One to store the sum of elements at indexes  that leave a remainder of 0 or 4 when divided by 4. The other to store the sum of elements at indexes  that leave a remainder of 1 or 2  when divided by 4.  3) If the two variables are equal then the array can be divided into two halfs with equal sum.  TC : O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"1. Sort the array  \n2. Start inserting elements into 2 arrays, while inserting the elements into the array, maintain its sum as well. \n3. If the sum in array1 < array2, insert the element into array1 else into array2. \n \nfor step #1 - O(n log n) \nfor step #2 & 3 - O (n) \n \nso totally its O (n log n) + O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"1 sort the array. 2. Create two groups by picking elements in pairs but in alternate fashion. Assuming after sorting array is a[1]....a[n] gr1:(a[1],a[n]) (a[3], a[n-2]) so on gr2: (a[2], a[n-1])(a[4], a[n-3]) so on"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=12705676","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"118","title":"one unsorted array is given.Find out the index i and j ,j> i for which a[j]  - a[i]  is maximum.perform in linear time complexity","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"19","title":"A Simple and cleaner solution. No need to check for index j > i etc."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"The solution is quite simple, one pass:  Start checking from the beginning of the array. Initially there are no min/max values stored. If the current element is smaller than the stored min, replace the stored min with current element and clear stored max (the stored max is no longer valid for this current min).  If the current item is larger than the current max and larger than the stored min, store it as a max. If this currently stored min/max pair is bigger difference than the previous, overwrite it (this will be the returned value).  To make it visible:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Here is a draft O(N) algo to find max{j-i,A[j]>A[i]}. For a given array of numbers A[N] (zero based), 1) Create array B[N]. Init it the following way: B[0] = A[0]; for(i=1;i2) Create array C[N]. Init it this way: C[N-1] = A[N-1]; for(i=N-2;i>=0;--i) C[i] = max(A[i],C[i+1]); 3) Let max_i_j = 0, i=j=0. Now, do this merge type of calculation on B and C: while(jwhile(B[i] < C[j] && jmax_i_j = max(max_i_j,j-i); i=i+1;j=j+1; } =============== Each step is O(N). I am sure it can be done some more elegant way though..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"A[8] =    {20,30,2,11,12,10,1,4}; 1) B[8] = {20,20,2,2 ,2 ,2 ,1,1}; 2) C[8] = {30,30,12,12,12,10,4,4}; 3) the loop while(j<8) stops with max_i_j = 7-2=5 on i=2,j=7"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Consider the left point of those pair (i, j) first.  Suppose i < k and A[i] <= A[k]. Then for any k < j and A[k] < A[j], i must be better than k, i.e. k is useless as a \"left point\"  Now scan from the left of array A, to find all the left point candidates, they must be: A[i_1] > A[i_2] > A[i_3] > ... > A[i_m], here 1 = i_1 < i_2 < ... < i_m <=n  Keeping a pointer whose initial value is ptr = m,  Second scan from the right side, for every j:  if (i_ptr > j) ptr = ptr - 1; while (ptr > 1) and (A[i_ptr] >= A[j]) ptr = ptr - 1; while (ptr > 1) and (A[i_(ptr-1)] < A[j]) ptr = ptr - 1; checking pair(i_ptr, j)  Finally, we get the maximum (j - i) in O(n) time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/*  How about this solution? Suppose we have an array, A[0 ..... n]  if (A[n] > A[0]) then return n; else return Max(findMax(A[0 ... n-1]), findMax(A[1 ... n]))  So it is a dynamic programming problem. The worst case is time complexity is O(n^2) */  int DPRecord[N][N];     // each cell should be initialized by -1  int findMax(int *A, int i_start, int i_end) {     if (i_end <= i_start) return -1;     if (DPRecord[i_end][i_start] != -1) return DPRecord[i_end][i_start];      if (A[i_end] > A[i_start]) {         DPRecord[i_end][i_start] = A[i_end] - A[i_start];     }     else {         int max1 = findMax(A, i_start+1, i_end);         int max2 = findMax(A, i_start, i_end-1);         DPRecord[i_end][i_start] = max1 > max2 ? max1 : max2;     }      return DPRecord[i_end][i_start]; }  int main (int argc, char *argv[]) {     int answer = findMax(A, 0, length(A));     if (answer == -1) cout << \"NO ANSWER!!\" << endl;    // this array looks like: 5 4 3 2 1 -> no answer!!     else cout << answer<< endl;    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Idea would be to store the positions (not values) in stack as the value is increasing. Any time value decreases, go through the stack and remove all values higher than current.  So at any point of time, we will have only increasing positions in the stack. This idea was used to calculate max area under histogram :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if it were asked to find out minimum j-i such that A[i] < A[j], it could be solved using stack in O(n) time. But, I doubt for max j-i such algorithm ever exists.   Seems all previous CORRECT solutions takes O(n^2) time - which is trivial. Any idea of O(n logn) solution there?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be solved in O(n) time by using dynamic programing. This is similar to the classic when to sell your share problem. You use the iterative solution of  max[n]=max(0, max(n-1)+(A[j]-A[j-1])). This would give you the differences of each particular day for diff choices of i and j. In a single pass of O(n) you can find the maximum, which is the answer we are looking for. coding this should not be difficult"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be done in O(n).. Here's how.. Keep two pointers, left and right. Check values pointed by left and right pointers. If the value pointed by right is greater than that pointed by i, store j-i and increment i. Otherwise, decrement j till such a condition occurs. Now, say i has been incremented. If the value pointed by this new i is greater than the one previously pointed by it, simply increment i as in this case j-i can never exceed previously computed j-i. If the value is smaller, then search from current j to the last element.. If such an element is found, update j-i."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void longestContinuousIncrSeq(int* a, int size) { \n        int maxstart = 0; \n        int max = 1; \n        int start = 0; \n        for (int i = 1; i < size; i++) { \n            if (a[i] > a[i - 1]) { \n                if (i - start + 1 > max) { \n                    max = i - start + 1; \n                   maxstart = start; \n                } \n           } else { \n                start = i; \n            } \n        } \n        cout << \"Longest sequence starts at \" << maxstart << \" and is \" << max << \" numbers long.\" << endl; \n       for (int i = 0; i < max; i++) { \n            cout << a[maxstart + i] << \" \"; \n        } \n        cout << endl; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@celicom The logic given by you seems to be working.  Do you have any mathematical proof or reference site/book for this logic?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can sb explain the question with sample i/p & o/p .."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int main() {  int arr[] = {21, 25, 1, 17, 16, 13}  int start = 0, end = 0;  solve(arr, 6, start, end);   cout << \"The start point is \" << start << \" and the end point is \" << end    << endl;  return 0; }  int solve(int arr[], int len, int& start, int& end) {   int min = 0;  int maxDiff = INT_MIN;   for (int i = 0; i < len; i++) {    if (arr[i] < arr[min])    min = i;    if ((i - min) > maxDiff) {     maxDiff = i - min;    start = min;    end = i;   }  }  return; }by slimboy"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@celicom:this is not a o(n) approach."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the code. Please correct me if any mistake  void FindMaxDiff(int arr[], int arr_size)  {  int i, first, second;  int diff = 0;  /* There should be atleast two elements*/  if(arr_size < 2)  {  printf(\" Invalid Input \");  return;  }  first = second = 0;  for(i = 0; i < arr_size ; i ++)  {  /*If current element is smaller than first then update both first and second */  if(arr[i] > first)  {  second = first;  first = arr[i];  if(diff < (first-second))  diff = (first-second);  }  /* If arr[i] is in between first and second then update second */  else if (arr[i] > second)  {  second = arr[i];  }  }  Printf(?? xxxx ??);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@sidhartha,thanks for quick reply Can you check you above code on input 2,1,4,100,-5 value of max difference,diff should be 99(100-1) but your code after loop iteration will give 96."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* \none unsorted array is given.Find out the index i and j ,j> i for which a[j] - a[i] is maximum.perform in linear time complexity \n*/ \n \nbool findLargestDiff(int data[], int size, int &low, int &high) \n{ \n int tmpLow = 0, tmpHigh = 1; \n  \n if(size < 2) \n  return false; \n \n int low = 0, high = 1; \n  \n if(size == 2) \n { \n  return true; \n } \n  \n while(tmpLow < size - 1 && tmpHigh < size) \n { \n  if(data[tmpLow] > data[tmpLow+1])  //we try to find the lowest point at first \n  { \n   tmpLow++; \n   if(tmpHigh <= tmpLow) tmpHigh = tmpLow + 1;   //j > i is a requrement  \n    \n   if(data[tmpHigh] - data[tmpLow] > data[high] - data[low])  //cover {-10, -5, -3} scenario \n   { \n    low = tmpLow; \n    high = tmpHigh; \n   } \n  } \n  else  //the next is biggest than the tmpLow \n  { \n   while(tmpHigh < size) \n   { \n    if(data[tmpHigh] > data[tmpLow]) \n    { \n     if(data[tmpHigh] - data[tmpLow] > data[high] - data[low]) \n     { \n      low = tmpLow; \n      high = tmpHigh; \n     } \n     tmpHigh++; \n    } \n    else  //find a new low  \n    { \n     tmpLow = tmpHigh; \n     tmpHigh++; \n     break; \n    } \n   } \n  } \n } \n  \n return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Find min and max element in the array. 2. The diff between them is the max diff."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For understanding the solution better i'll the algorithm in two passes at max (still order is O(n)): In the first pass find out the maximum and minimum elements. If the index of maximum is greater than that of minimum then the problem is solved. Otherwise find: let min,max be the found minimum and maximum elements respectively. maximum(diff(minium element that is left to max,max),diff(min,maximum element that is right to min))  If we manage the variables properly we can do it in one pass :)  Eg: 5, 15, 2, 10, 20, 1, 17, 0, 8, 16 Apparently the required indexes are 2,4 (max difference =18)  Now using algo, minimum element  = 0 maximum element = 20 but index of 0 > index of 20 now minimum element left of 20 is 2, difference1 = 18 maximum element right of 0 is 16, difference2 = 16 maximum(difference1, difference2) = 18  Order is O(n) and if we manage variables properly, we can do it in one pass"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"'i' will iterate from 0 to n-2 and 'j' from 1 to n-1. update iLoc and jLoc accordingly. jLoc will contain the largest element in the array and iLoc has smallest. so the difference will be maximum. For the condition i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//A c# version"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be done in 3 pases  1 pass) Find the minimum till that index for each index and store it an array A 2 pass) Find the maximum till that index for each index but traverse the array in reverse order and store it an array B 3 pass) Find the difference  B[i] - A[i] at each index you will get the max difference and from that the indexes   example input : 5  15  3   10  20 1  19   0  8  16  A :       5   5   3   3    3   1   1    0  0    0 B :       20 20 20 20  20 19 19 16 16 16 diff:      -----------17   17  18 18(max) 16 ---------  find indices of 19 and 1 linear solution and simple though there could be better ;)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"isn't it the same problem as having the max profit in share price movements of a given date?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Question says \"perform in linear time complexity\" .. I have a doubt cant we use two for loops?  By the way.. Can some one review  this solution:  int a[4] = {2,3,1,4,5,1,6,2,3,4};    int n=10;     int ti, tj, maxj, mini, i,  j;    i=n-1;j=n-1;      mini=0; maxj=n-1; ti=0;tj=0;    for(int k=0, l=n-1; k   {   if(a[k]>=a[tj])   {    tj=k; ti=mini;    }           else if(a[k]       if(a[l]<=a[i])   {     i=l; j=maxj;   }   else if(a[l]>a[maxj]) maxj=l;    }     if (a[tj]-a[ti] > a[j]-a[i]){ i = ti; j=tj;}       //- -- - -- -- here we re traversing from left to right...  finding the largest a[k] and replacing j=k; if current a[i] > some k which we have already passed through then i== that minimum;  at the same time we are going right to left..  finding smallest a[k] and making i=k; if current a[j] < some k which we have already passed through then j== that max;  then we compare the two differences.. and assign i and j"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"List findhighestdifindex(int a[])  {   int minindex=0,maxindex=0,max=0,min=23456;   List indexlist = new ArrayList();   for (int i = 0; i < a.length; i++) {    if(a[i]   {     min=a[i];     minindex=i;    }   }   if(min  {    for (int i = minindex+1; i < a.length; i++) {     if(a[i]>max)     {      max=a[i];      maxindex=i;     }    }   }   indexlist.add(maxindex);   indexlist.add(minindex);   return indexlist;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void printMax(int []a){   int min,min1,max,x,x1,y;   min=max=min1=a[0];   x=x1=y=0;   for (int i=1;i   if(a[i]>=max){     max=a[i];     y=i;    }    else if(a[i]    min1=a[i];     x1=i;    }    if((a[i]-min1)>(max-min)){     max=a[i];     min=min1;     x=x1;     y=i;    }   }   System.out.println( x);   System.out.println( y);   System.out.println( min);   System.out.println(max);   }       public static void main(String[] args) {   // TODO Auto-generated method stub   //int ar[]=new int[10];   int ar[]={5,15,3,10,20,1,19,0,8,16};   printMax(ar); System.out.write(1);  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void printMax(int []a){   int min,min1,max,x,x1,y;   min=max=min1=a[0];   x=x1=y=0;   for (int i=1;i   if(a[i]>=max){     max=a[i];     y=i;    }    else if(a[i]    min1=a[i];     x1=i;    }    if((a[i]-min1)>(max-min)){     max=a[i];     min=min1;     x=x1;     y=i;    }   }   System.out.println( x);   System.out.println( y);   System.out.println( min);   System.out.println(max);   }       public static void main(String[] args) {   // TODO Auto-generated method stub   //int ar[]=new int[10];   int ar[]={5,15,3,10,20,1,19,0,8,16};   printMax(ar); System.out.write(1);  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{public static void printMax(int []a){   int min,min1,max,x,x1,y;   min=max=min1=a[0];   x=x1=y=0;   for (int i=1;i   if(a[i]>=max){     max=a[i];     y=i;    }    else if(a[i]    min1=a[i];     x1=i;    }    if((a[i]-min1)>(max-min)){     max=a[i];     min=min1;     x=x1;     y=i;    }   }   System.out.println( x);   System.out.println( y);   System.out.println( min);   System.out.println(max);   }       public static void main(String[] args) {   // TODO Auto-generated method stub   //int ar[]=new int[10];   int ar[]={5,15,3,10,20,1,19,0,8,16};   printMax(ar); System.out.write(1);  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{public static void printMax(int []a){   int min,min1,max,x,x1,y;   min=max=min1=a[0];   x=x1=y=0;   for (int i=1;i   if(a[i]>=max){     max=a[i];     y=i;    }    else if(a[i]    min1=a[i];     x1=i;    }    if((a[i]-min1)>(max-min)){     max=a[i];     min=min1;     x=x1;     y=i;    }   }   System.out.println( x);   System.out.println( y);   System.out.println( min);   System.out.println(max);   }       public static void main(String[] args) {   // TODO Auto-generated method stub   //int ar[]=new int[10];   int ar[]={5,15,3,10,20,1,19,0,8,16};   printMax(ar); System.out.write(1);  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{public static void printMax(int []a){   int min,min1,max,x,x1,y;   min=max=min1=a[0];   x=x1=y=0;   for (int i=1;i   if(a[i]>=max){     max=a[i];     y=i;    }    else if(a[i]    min1=a[i];     x1=i;    }    if((a[i]-min1)>(max-min)){     max=a[i];     min=min1;     x=x1;     y=i;    }   }   System.out.println( x);   System.out.println( y);   System.out.println( min);   System.out.println(max);   }       public static void main(String[] args) {   // TODO Auto-generated method stub   //int ar[]=new int[10];   int ar[]={5,15,3,10,20,1,19,0,8,16};   printMax(ar); System.out.write(1);  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the running code enjoy"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The below code is working. Let me know if you see any issues {  public class MaxMin {    public static void main(String[] args) {   int [] arr = {25, 15, 3, 10, 20, 3, 19, 5, 8, 21};   int y=0;   int i=0;   int j = 1;   while(arr[y]>arr[y+1])    y++;   int max = arr[y];   int min = arr[y+1];   int tmpi=y;   int tmpj=y+1;   int tmpMax =arr[y+1];   int tmpMin = arr[y];   boolean findMin=false,findMax=false;   for(int x = y+1; x    if((arr[x] < min && arr[x] < tmpMin) || (findMax && tmpMax - arr[x] > max - min)){     tmpMin = arr[x];     tmpi=x;     findMin = true;     findMax = false;    }    if((arr[x] > max && arr[x] > tmpMax) || (findMin && arr[x] - tmpMin > max - min))    {      tmpMax = arr[x];     tmpj = x;     findMin = false;     findMax = true;         }    if(max - min < tmpMax - tmpMin && tmpj > tmpi){     max = tmpMax;     min = tmpMin;     i=tmpi;     j=tmpj;         }   }  System.out.println(i + \" \" + j);  }   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int maxDiff( int* numbers, int size ) {   int max_diff = 0;   int min_ind = 0;   for( int i = 0 ; i < size; i++ ) {      if( numbers[i] < numbers[min_ind] ) {       min_ind = i;     }     else {       if ( ( numbers[i] - numbers[min_ind] ) > max_diff ) {  max_diff = numbers[i] - numbers[min_ind] ;       }     }   }    return max_diff; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  using namespace std;  int finddiff(int *A, int len) {      int min = A[o];     int max = A[len-1];     int diff = 0;       int i = 0;     int j = len-1;      while( i <=j ) {          if(A[i] < min) { min = A[i]; }          if(A[j] > max) { max = A[j]; }         if( A[i] > A[j]) { j--; continue; }         if( diff < (max - min))                   diff = max - min;          i++; }  return diff; }  int main() {       int A[] = { 2, 5, 10, -2, 27, 13, 24, -1};     int maxdiff = finddiff(A, 8);     cout << \"Max diff = \" << maxdiff << endl;  }         }   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  using namespace std;  int finddiff(int *A, int len) {      int min = A[o];     int max = A[len-1];     int diff = 0;       int i = 0;     int j = len-1;      while( i <=j ) {          if(A[i] < min) { min = A[i]; }          if(A[j] > max) { max = A[j]; }         if( A[i] > A[j]) { j--; continue; }         if( diff < (max - min))                   diff = max - min;          i++; }  return diff; }  int main() {       int A[] = { 2, 5, 10, -2, 27, 13, 24, -1};     int maxdiff = finddiff(A, 8);     cout << \"Max diff = \" << maxdiff << endl;  }         }   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Dynamic programming {  int i,j,index,min,max;  min=max=i=j=0;  for (index=1; index  if (a[index]>a[j]) {    j=index;    if (a[j]-a[i]>a[max]-a[min]) {     max=j;     min=i;    }   }   if (a[index]   i=j=index;   }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. minimumIn[1...i] = min(a[i], minimum[1...i-1]); O(n) time and space, left to right 2. maximumIn[n...i] = max(a[i], maximum[n...i+1]); O(n) time and space, right to left 3. find i, for which maximumIn[n...i] - minimumIn[1...i] is maximum, again O(n) time, no extra space"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Take two variables  min and maxdiff, Keep track of min element found so far and take difference of  current element and the min value found so far. keep storing difference in the maxdiff variable.   at the end it will return the max differnce. and for index keep there track too."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void arrayFindSubMax(int *a,int length,int *i,int *j) \n{ \n int max=0,sub,p,q; \n *i=0; \n *j=0; \n for(p=0,q=1;qmax) \n  { \n   max = sub; \n   *i = p; \n   *j = q; \n  } \n  if(sub>0) q++; \n  else {p=q;q++;} \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include   int main() {   int array[5] = {10,4,2,-7,-1};  int i,j,count,min,max,result;   i=j=0;   min = array[0];  max = array[0];   for(count=1;count<5;count++)  {   if(min > array[count])   {    min = array[count];    i = count;   }    if(max < array[count])   {    max = array[count];    j=count;   }   }   printf(\"Min %d - %d\\n\",i,min);  printf(\"Max %d - %d\\n\",j,max);  result = max-min;  printf(\"Result of max and min -%d\",result); return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Main \n{ \n    /** \n     * @param args the command line arguments \n     */ \n    public static void main(String[] args) \n    { \n        // TODO code application logic here \n//        int values[] = {3, 5, 1, 2}; int expected[] = {0, 1}; \n//        int values[] = {5, 15, 3, 10, 20, 1, 19, 0, 8, 16};  int expected[] = {5, 6}; \n//        int values[] = {7, 5, 4, 3, 1, 6}; int expected[] = {4, 5}; \n//        int values[] = {5, 15, 2, 10, 20, 1, 17, 0, 8, 16}; int expected[] = {2, 4}; \n//        int values[] = {5, 15, 3, 10, 20, 1, 19, 0, 8, 16}; int expected[] = {5, 6}; \n//        int values[] = {5, 15, 3, 10}; int expected[] = {0, 1}; \n//        int values[] = {2, 3, 1, 4, 5, 1, 6, 2, 3, 4}; int expected[] = {2, 6}; \n//        int values[] = {25, 15, 3, 10, 20, 3, 19, 5, 8, 21}; int expected[] = {2, 9}; \n//        int values[] = { 2, 5, 10, -2, 27, 13, 24, -1}; int expected[] = {3, 4}; \n//        int values[] = {10, 4, 2, -7, -1}; int expected[] = {3, 4}; \n//        int values[] = {4, 10, 2, -7, -1}; int expected[] = {0, 1}; \n        indices(values, expected); \n    } \n \n    /** \n     * one unsorted array is given.  Find out the index i and j, j > i for \n     * which a[j] - a[i] is maximum.  perform in linear time complexity. \n     * \n     * @param values \n     * @param expected \n     * @return \n     */ \n    public static final int[] indices(final int[] values, final int[] expected) \n    { \n//        int values[] = {3, 5, 1, 2}; int expected[] = {0, 1}; \n//        int values[] = {5, 15, 3, 10, 20, 1, 19, 0, 8, 16};  int expected[] = {5, 6}; \n//        int values[] = {7, 5, 4, 3, 1, 6}; int expected[] = {4, 5}; \n//        int values[] = {5, 15, 2, 10, 20, 1, 17, 0, 8, 16}; int expected[] = {2, 4}; \n//        int values[] = {5, 15, 3, 10, 20, 1, 19, 0, 8, 16}; int expected[] = {5, 6}; \n//        int values[] = {5, 15, 3, 10}; int expected[] = {0, 1}; \n//        int values[] = {2, 3, 1, 4, 5, 1, 6, 2, 3, 4}; int expected[] = {2, 6}; \n//        int values[] = {25, 15, 3, 10, 20, 3, 19, 5, 8, 21}; int expected[] = {2, 9}; \n//        int values[] = { 2, 5, 10, -2, 27, 13, 24, -1}; int expected[] = {3, 4}; \n//        int values[] = {10, 4, 2, -7, -1}; int expected[] = {3, 4}; \n//        int values[] = {4, 10, 2, -7, -1}; int expected[] = {0, 1}; \n        int max = Integer.MIN_VALUE; \n        int min = Integer.MAX_VALUE; \n        int minIndex = 0; \n        int maxIndex = 0; \n        int retMinIndex = 0; \n        int retMaxIndex = 0; \n        int maxDiff = 0; \n \n        for(int i = 0; values.length > i; ++i) \n        { \n            if(min > values[i]) \n            { \n                min = values[i]; \n                minIndex = i; \n \n                // takes care of j > i constraint \n                max = values[i]; \n                maxIndex = i; \n            } \n            else if(max < values[i]) \n            { \n                max = values[i]; \n                maxIndex = i; \n            } \n             \n            if(max - min > maxDiff) \n            { \n                maxDiff = max - min; \n                retMinIndex = minIndex; \n                retMaxIndex = maxIndex; \n            } \n \n            System.out.println(\"diff: \" + (max - min)); \n        } \n \n        int answer[] = new int[]{retMinIndex, retMaxIndex}; \n \n        System.out.println(\"answer: \" + Arrays.toString(answer)); \n        System.out.println(\"expected: \" + Arrays.toString(expected)); \n \n        return answer; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int findMaxDiffPosition(int element[], int n, int& firstElementPos, int& lastElementPos) {  int diff = element[1] - element[0];  int i,j;   i = 0;  j = 1;   while( i < n && j < n)  {   if (element[i] < element[j])   {    if ( (element[j] - element[i] ) > diff )    {     firstElementPos = i;     lastElementPos = j;     diff = element[j] - element[i];    }    j++;   }   else   {    i = j;    j = i + 1;   }  }  return diff; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n \nvoid find_i_j(int a[], int n) { \n int i, j, k, minval, maxdiff; \n i=j=k=maxdiff=0; \n minval=a[0]; \n \n for (k=1; k a[k]) { \n   minval=a[k]; \n   i=k; \n   continue; \n  } \n  if ((a[k]-minval) > maxdiff) { \n   maxdiff=a[k]-minval; \n   j=k; \n  }  \n } \n printf(\"i %d, val %d\\nj %d, val %d\\n\", i+1, a[i], j+1, a[j]); \n  \n} \n \nint main(void) { \n \n int a[10]; \n int i; \n \n for (i=0;i<10;i++) \n  scanf(\"%d\",&a[i]); \n \n for (i=0;i<10;i++) \n  printf(\"%d, \",a[i]); \n printf(\"\\n\"); \n \n find_i_j(a, 10); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n \nvoid find_i_j(int a[], int n) { \n int i, j, k, minval, maxdiff; \n i=j=k=maxdiff=0; \n minval=a[0]; \n \n for (k=1; k a[k]) { \n   minval=a[k]; \n   i=k; \n   continue; \n  } \n  if ((a[k]-minval) > maxdiff) { \n   maxdiff=a[k]-minval; \n   j=k; \n  }  \n } \n printf(\"i %d, val %d\\nj %d, val %d\\n\", i+1, a[i], j+1, a[j]); \n  \n} \n \nint main(void) { \n \n int a[10]; \n int i; \n \n for (i=0;i<10;i++) \n  scanf(\"%d\",&a[i]); \n \n for (i=0;i<10;i++) \n  printf(\"%d, \",a[i]); \n printf(\"\\n\"); \n \n find_i_j(a, 10); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"have an array which is the same size as original Initialize elements to ZERO    max_so_far = 0;  Start from the end (i = n-1; i >= 0; i--) {  if (max_so_far > a[i])  {   max_so_far = a[i]  }  else  {   scan[i] = max_so_far-a[i];  } }  max_so_far = scan[0]; int idx_min = 0; for (i = 1 -> n-1) {  if (max_so_far < scan[i])  {   max_so_far = scan[i]   idx_min = i;  } }  // idx_min has the value which is an the min in subtraction  int to_find = scan[idx_min] + a[idx_min]; int idx_max = 0; for(i = idx+1 -> n-1) {  if (to_find == a[i])  {   idx_max = i;   break  } }   // now idx_min has the min and idx_max has the max a[idx_max] - a[idx_min]  - should give the max diff"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Pair findMaxDiffIndices(int[] a) { \n    Pair p = new Pair(0, 0); \n    int i = 0; \n    int j = 0; \n    int cmin = 0; \n    for (int k = 1; k < a.length; k++) { \n      if (a[k] < a[i]) { \n        cmin = k; \n      } else if (a[k] - a[cmin] > a[j] - a[i]) { \n        j = k; \n        i = cmin; \n      } \n    } \n    p.fst = i; \n    p.snd = j; \n    return p; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int min, max, contendermin; min = max = contendermin = -1; for( int i=0; i{  if( min == -1 && max == -1 )   min = i;  else  {   if( a[min] > a[i] )    if( max == -1 )     min = i;    if( contendermin == -1 || a[contendermin] > a[i] )     contendermin = i;   else if( max == -1 )    max = i;   else if( a[max] < a[i] )   {    max = i;    if( contendermin != -1 )    {     min = contendermin;     contendermin = -1;    }   }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int min, max, contendermin; \nmin = max = contendermin = -1; \nfor( int i=0; i a[i] ) \n   if( max == -1 ) \n    min = i; \n   if( contendermin == -1 || a[contendermin] > a[i] ) \n    contendermin = i; \n  else if( max == -1 ) \n   max = i; \n  else if( a[max] < a[i] ) \n  { \n   max = i; \n   if( contendermin != -1 ) \n   { \n    min = contendermin; \n    contendermin = -1; \n   } \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int min, max, contendermin; \nmin = max = contendermin = -1; \nfor( int i=0; i a[i] ) \n   if( max == -1 ) \n    min = i; \n   if( contendermin == -1 || a[contendermin] > a[i] ) \n    contendermin = i; \n  else if( max == -1 ) \n   max = i; \n  else if( a[max] < a[i] ) \n  { \n   max = i; \n   if( contendermin != -1 ) \n   { \n    min = contendermin; \n    contendermin = -1; \n   } \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just a thought :- Can we use max-heap and min-heap to do it in linear time.  We can create min or max heap in linear time.  Comments Please."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include   using namespace std; #define NUMBER 10 int main(){          int a[NUMBER] = {5, 15, 3, 10, 20, 1, 19, 0, 8, 16};          int minElement = a[0];     int maxDiff = a[1]-a[0];     int index1 = 0, index2 = 1, currDiff;          for(int i = 1; i            if(a[i] < minElement){                     minElement = a[i];                     currDiff = maxDiff;             }else{                   currDiff = a[i] - minElement;                     }              if(currDiff > maxDiff){                          maxDiff = currDiff;                          index2 = i;              }     }          minElement = a[index2] - maxDiff;          for(int i = 0; i            if(a[i] == minElement){                     index1 = i;                     break;             }     }          cout<<\"Maximum Diff is: \"<<    cout<<\"Index of min element and max element are : \"<<<\" \"<<    system(\"pause\");          return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void main() { int a[]= {3, 5, 1, 2}; int MAX=0, i=0, j=0, m,t=0,b=0; m= sizeof(a)/ sizeof(int);  for(j=1;j{     if(a[j]>a[i])      {          if(a[j]-a[i]> MAX)          {          t=j;          b=i;           MAX= a[j]-a[i];          }      }      else      i=j; }  printf(\"%d,%d,%d\",MAX,b,t); return; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void main() { int a[]= {15,13,11,7,4,0,-1}; int MAX=0, i=0, j=0, m,t=0,b=0; m= sizeof(a)/ sizeof(int);  for(j=1;j{     if(a[j]>a[i])      {          if(a[j]-a[i]> MAX)          {            t=j;            b=i;            MAX= a[j]-a[i];          }      }       else if(a[j]==a[i])      continue;       else      i=j; }  if(MAX==0) {     i=1;     MAX=a[1]-a[0];     b=0;     t=1; for(j=2;j {     if(a[j]-a[i]> MAX)      {        MAX= a[j]-a[i];        b=i;        t=j;      }     else        i=j;  } }  printf(\"%d,%d,%d\",MAX,b,t); return;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \nint main(int argc, char *argv[]) \n{ \n  int size,curr,curr_id,min_id,max_id,diff;   \n  printf(\"Enter the size of array : \"); \n  scanf(\"%d\",&size); \n  int *arr=(int*)malloc(sizeof(int)*size); \n  int i=0; \n  for(i=0;iarr[0]) \n  { \n                   curr=arr[0]; \n                   curr_id=0; \n  } \n  for(i=2;i= diff) \n                  { \n                           diff=arr[i]-curr; \n                           min_id=curr_id; \n                           max_id=i;      \n                  } \n                  if(arr[i]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think taking additional space this problem can be solved in O(n).  1) Pass through the array and create another array which holds the value of the differences of two adjacent elements. b[i]=a[i+1]-a[i]  2) Find the maximum sub array sum for array b, which can be found in O(n) time. For any sub array sum as the answer b[l] to b[r] the value will actually be a[l+1]-a[l]+a[l+2]-a[l+1]...a[r+1]-a[r]. which reduces to a[r+1]-a[l] where r+1>l and this the maximum such value."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import sys \n \nA = [int(n) for n in sys.stdin.read().strip().split()] \ni, j = 0, 1 \nmini = 0 \nminup2n = A[mini] \nn = 2 \nwhile n < len(A): \n  if A[n - 1] < minup2n: \n    mini = n - 1 \n    minup2n = A[mini] \n  if A[n] - minup2n > A[j] - A[i]: \n    i = mini \n    j = n \n  n = n + 1 \n \nprint 'A[%d] = %d, A[%d] = %d' % (i, A[i], j, A[j])"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int minCandidate = 0; \ni = 0; \nj = 0; \nfor (int k = 1; k < a.Length; k++) \n{ \n    if (a[k] > a[j]) \n    { \n        j = k; \n    } \n    else if (a[k] < a[minCandidate]) \n    { \n        minCandidate = k; \n    } \n \n    if (j > minCandidate && a[j] - a[minCandidate] > a[j] - a[i]) \n    { \n        i = minCandidate; \n    } \n    if (a[j] - a[i] < a[k] - a[minCandidate]) \n    { \n        i = minCandidate; \n        j = k; \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static void MaxDifference(int[] a) { \n  if(a.length == 0){ \n   System.out.println(\"Empty Array\"); \n  } \n    \n  int i = 0, minIndex = 0; \n  int j = a.length - 1, maxIndex = a.length - 1; \n  int maxDiff = a[j] - a[i]; \n  int count = 0; \n  while(count < a.length - 1){ \n   if(a[maxIndex] - a[i+1] > maxDiff && a[i+1] < a[minIndex] && maxIndex > i+1){ \n    minIndex = i+1; \n    maxDiff = a[maxIndex] - a[minIndex]; \n   } \n   if(a[j - 1] - a[minIndex] > maxDiff && a[j-1] > a[maxIndex] && minIndex < j-1){ \n    maxIndex = j-1; \n    maxDiff = a[maxIndex] - a[minIndex]; \n   } \n   i++;j--;count++; \n   System.out.println(\"count :\" + (count) + \" difference : \" + maxDiff + \"  min value \" + a[minIndex] + \" max value \" + a[maxIndex]); \n  } \n  System.out.println(\"difference : \" + maxDiff + \"  min value \" + a[minIndex] + \" max value \" + a[maxIndex]); \n   \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Correct me if I am wrong  Algo: i = 0, j = size-1  while(i{ while (a[i]> a[i+1]) i++ while (a[j]if a[j]-a[i] > maxdiff overwrite  maxdiff }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Correct me if I am wrong  Algo: i = 0, j = size-1  while(i{ while (a[i]> a[i+1]) i++ while (a[j]if a[j]-a[i] > maxdiff overwrite  maxdiff }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"int i=0; \nint j=n-1; \n \nwhile(i!=j) \n{ \n if (A[i] < A[j]) \n { \n  cout<<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"is there any trick?i feel this simple enough. Pls correct if wrong"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=18813688","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"60","title":"Consider an array of integers wherein each element is +1 or -1 its preceding element. Given a number, find the first occurence of this number (index) in this array without using linear search.  For example, consider the array : 4 5 6 5 6 7 8 9 10 9 10 (each element in this array is +1 or -1 its preceding element)  Input : 10 (find first occurence of 10 without using linear search) Output : 8","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"26","title":"Pseudocode: 1) Instantiate current pointer to first position in array 2) Calculate absolute difference between current value and expected value 3) If difference is 0, return current value, else, increment current pointer by the difference 4) Repeat steps 2-4 until difference is not zero and current pointer is less than length of array"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Basic idea: Instead of doing a linear search, take advantage of +1/-1 property => Two numbers X & Y need to be at last (X-Y) distance apart in the array.  Algorithm:  1) Runner iterates through the numbers (initialized to begin of array) 2) Calculate absolute difference between current value and lookup value  3) If (difference == 0) return Runner location, else, increment Runner value by the difference -> the optimization part and continue from step 2  C++ code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"int first_occurence(int * a, int n, int key) \n{ \n    if (!n) \n        return -1; \n     \n    int diff = abs(key - a[0]); \n     \n    while(diff < n) { \n      \n        if(a[diff] == key) { \n             \n            return diff; \n \n        } else { \n             \n            int t = abs(a[diff] - key); \n            diff = diff + t; \n        } \n    } \n     \n    return -1; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"int search(int arr[],int low,int high,int key) \n{ \n    if(low"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Given x (the number to be looked for) and array A with the +-1 property.  One algorithm you can do is.  Set guess_index = 0  Compute the difference D = |x - A[guess_index]|  if D == 0, then we have found it. Otherwise we can skip D-1 elements (as we know they can't be be equal to x), so set guess_index += D and repeat.  Pseudo code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Great question here.  So to avoid linear search, you simply employ the absolute value of the difference between your current element, and your guess.  This will put you at the earliest position that could hold the desired value.  If you find your position is outside of the array length, then the element cannot possibly exist inside of the given list.  Here is my solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"for (int i = 0; i < array.Count();) \n            { \n                if (array[i] < valuetofind) \n                    i += (valuetofind - array[i]); \n                else if (array[i] > valuetofind) \n                    i += (array[i] - valuetofind); \n                else \n                { \n                    Console.WriteLine(\"Found at \" + i); \n                    break; \n                } \n            }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"read first value index jump abs(given value - value read) and read value again until end_of_array or abs(given value - new value) is smaller than previous If abs(delta) smaller, then value occurs in that bounded range"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #include int input; int firstOccurence=INT_MAX;   int search(int start,int end,int* array){ // printf(\"start = %d \\n\",start); // printf(\"end = %d \\n\",end);    if(start>end){  return -1;  }    if(start == end && array[start] != input ){   return -1;  }    int midval= start+(end-start)/2;  int diff = (array[midval] - input);  if(diff==0){  printf(\"found\");  firstOccurence = (midval search(0,midval-1,array);  return midval;  }  diff = (diff<0)?-diff:diff;   int low = midval -2*diff;  int high = midval + 2*diff;   low=(low high=(high>end)?end:high;   //printf(\"am here\");   int left = search(low,midval,array);  int right = search(midval+1,high,array);     return (left<0)?right:left; }   void main(){  int N; scanf(\"%d\",&N); int i=0; int *array=(int *)malloc(sizeof(int)*N); for(i=0;i scanf(\"%d\",array+i); } scanf(\"%d\",&input);  int res=search(0,N-1,array); printf(\"%d\",firstOccurence);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class FindANumber { \n \n /** \n  * @param args \n  */ \n static int[] arr = {2, 3, 4, 5, 6, 5, 4, 5, 6, 7, 8, 7, 6, 5, 4, 3, 2}; \n static int value = 3; \n public static void main(String[] args) { \n     \n  getIndex(0,arr.length - 1 ); \n   \n } \n \n private static void getIndex(int i, int j) { \n   \n  if(arr[i] == value) { \n   System.out.println(i);System.exit(0); \n  } \n  else if(i == j) { \n   return; \n  } \n  else{ \n   int newIndexI = i + (j-i)/2; \n   if(isValidBlock(i,newIndexI)){ \n    getIndex(i,newIndexI); \n   } \n    \n   if(isValidBlock(newIndexI+1,j)){ \n    getIndex(newIndexI+1,j); \n   } \n     \n  } \n   \n   \n   \n } \n \n private static boolean isValidBlock(int i, int j) { \n  if ( 1 + (value-arr[i]) + (value-arr[j]) <= ((j-i)+1)) return true; \n  else return false; \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String args[]){         int a[]={4, 3, 2, 3, 2, 1, 0, 1, 2, 3, 4, 5};         int number =0;         int first =a[0];         int location =0;         location =find_first_occur( a,  number,first,location);         System.out.println(\"location =\"+location+\" element =\"+a[location]); }     public  static int  find_first_occur(int array[],int number,int first,int location){          if(first ==number){             System.out.println(\" same number ...and location =\"+location);             return location;         }         else if (number > first){             int diff = number -first;             location = location+diff;             first = array[location];             System.out.println(\"diff =\"+diff+\"  newFirst =\"+first+\"  location =\"+location);             location = find_first_occur(array,number,first,location);                      }         else{             int diff = first -number ;             location = location+diff;             first = array[location];             System.out.println(\"diff =\"+diff+\"  newFirst =\"+first+\"  location =\"+location);             location = find_first_occur(array,number,first,location);         }         return location;     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n \nint main() \n{ \n    int a[50],i,j=0,num,n,count; \n    printf(\"Enter total elements of array:   \\n\"); \n    scanf(\"%d\",&n); \n    for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Stupid question, consider this sequence:  int a[] = {0,1,0,1,0,1,0,1,0,1,0,1,0,1,2,1,0,1,0,1}; //good luck not doing a linear search."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.*; \nimport java.io.*; \nclass Find_No \n{ \n public static void main(String args[]) \n { \n  \n int arr[] = {1,2,1,2,3,4,3,4,5,4}; \n int item; \n System.out.print(\"enter the item to be searched\"); \n Console con  = System.console(); \n item = Integer.parseInt(con.readLine()); \n HashMap map = new HashMap(); \n for(int i=arr.length-1;i>=0;i--) \n { \n  map.put(arr[i],i); \n } \n System.out.println(\"location of item is\"+map.get(item)); \n } \n  \n  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int find(int[]a, int num){ \n int len = a.length; \n int current = 0; \n while(current>=0 || current"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.io.*; \nclass Find_No2 \n{ \n public static void main(String args[]) \n { \n  int arr[] = {0,1,0,1,0,1,2,1,0}; \n  int count,var=0,i=1; \n  System.out.print(\"Enter a item to be searched\"); \n  Console con = System.console(); \n  int item = Integer.parseInt(con.readLine()); \n  count = item-arr[0]; \n  if(count==0) \n  { \n   \n   System.out.println(\"item is at 0 index\"); \n   System.exit(0); \n  } \n  else \n   while(i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Let's say the first element in the array  is 'A', the number to be found is 'Num' . Then ,  Loop until   Sum of(Difference of each element in the array with the next element) = (A - Num)  Let's say : 2, 3, 4, 5, 6, 5, 4, 5, 6, 7, 8  To find 8 :  A- Num = 2 - 8 = -6 (2-3) + (3 -  4) +( 4 - 5 )+ (5 - 6 ) + (6 - 5) + (5 - 4) + (4 - 5) + (5 - 6) + (6 - 7) + (7 - 8) = -6  The number is 8 since the difference -6 is found."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#define Max 10 // Array Size \n \nvoid Search(int A[], int key) \n{int i=0,diff=0; \nwhile(i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#define Max 10 // Array Size \n \nvoid Search(int A[], int key) \n{int i=0,diff=0; \nwhile(i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nusing namespace std; \n \nint main() \n{ \n    int a[10]; \n    for(int i=0;i<10;i++) \n    cin>>a[i]; \n     \n    for(int i=0;i<10;) \n    {                   \n    if(a[i]==10){ \n    cout<<\"Found at: \"<<10) \n    i=a[i]-10; \n     \n    else i=10-a[i]; \n    } \nreturn 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int searchIncDecByOne(int *arr, int size, int Num) {  int i = 0;  if (!arr || size <=0)   return -1;  while (i >= 0 && i < size) {   if (arr[i] == Num)    return i;   if (arr[i] < Num)    i +=Num-arr[i];   else    i -=arr[i]-Num;  }  if (i < 0 || i >= size)   return -1; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Duplicate question: refer /question?id=18136672"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int guesser(int a[],int size,int key){ \n int guessIndex = 0; \n while(a[guessIndex] != key && guessIndex < size){ \n  if(key > a[guessIndex]) \n   guessIndex += key - a[guessIndex]; \n  else \n  { \n   guessIndex += a[guessIndex] - key; \n  } \n                 \n } \n        if(guessIndex >= size)  return -1; \n return guessIndex; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I implemented a recursive function for the solution. The initial guessIndex =0 and each recursive call, i calculate the offset for a possible jump"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) {    int[] a = { 5, 4, 3, 2, 3, 4, 5, 6, 5, 6, 7, 8 };    findPosition(a, 6, 0);   }   /* default */static void findPosition(int[] a, int ele, int i) {    if (i > a.length - 1) {    System.out.println(\"ele not found\");    return;   }    if (a[i] == ele) {    System.out.println(i);    return;   }    // Assumption diff is positive..   int diff = 0;    diff = Math.abs(ele - a[i]);    findPosition(a, ele, diff + i);   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is sort of interpolation search with average/best case complexity of O(lg(lgn)) iff elements are uniformly distributed. but in worst case the complexity meets O(n). I come up with the following code to solve this problem.   Editing it to mention the test-cast where the complexity meets O(n)   in the following array search for 7."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int findFirstPosition(int *a,int length,int num) \n{ \n int i=1; \n if( (num%2==0 && a[0]%2==0) || (num%2!=0 && a[0]%2!=0) ) \n  i=0; \n int diff; \n while(i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My Solution can be, lets take the number series 2 1 2 1 2 3 4 And if we want to find out the position of 3, 1) Start with 2, since 3-2 =1, move 1 position and 2) Find the difference, 3-1 = 2, so move 2 positions. 3) next 3-1  = 2, again move 2 positions 4) Now 3-3 = 0, so we got the solution and its not a linear search.  Hope this should work for all the series"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Sequence { \n \n private int[] content = new int[]{9,10,9,8,7,6,7,8,9,10,9,10,9}; \n  \n public Sequence() \n { \n } \n  \n public void process(int value) \n { \n  int count = 0; \n  int i = 0; \n  while( i< content.length) \n  { \n   if(content[i] == value) \n   { \n    ++count; \n    i = i+2; \n   } \n   else \n   { \n    int diff = Math.abs(value - content[i]); \n    i = i + diff; \n   } \n  } \n   \n  System.out.println(count); \n } \n  \n public static void main(String[] args) { \n   new Sequence().process(6); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hi, this is python example:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(logn) solution.  Sharing it via CodeBunk so you could run the code as well.  codebunk.com/bunk#-Ix38C2CNuBKt-JHK5Hf"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Tweak the merge sort's merge part such that it stores the earliest location. Time O(logN) since merge takes only O(1) and split takes O(logn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static int Search(int[] arr, int value) \n{ \n    for (int i = 0; i < arr.Length; i += Math.Abs(value - arr[i])) \n    { \n        if (arr[i] == value) return i; \n    } \n    return -1; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"sites.google.com/site/spaceofjameschen/home/sort-and-search/find-the-first-occurence-of-this-number-index-in-this-array-without-using-linear-search-amazon"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=245679","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"143","title":"find the longest palindrome in a string?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"detalied explanation can be found at  www.math.tau.ac.il/~haimk/seminar02/suffixtrees.ppt"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"This can be solved using \"Suffix Tree\"."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Actually, the most efficient algorithm is O(n) and is based on dynamic programming.   Let str be the string of length n. Let us define: len[i] = length of the longest palindrome in substring having characters str[0],str[1],...,str[i]. beginIndex[i] = beginning index of the longest palindrome in substring having characters str[0],str[1],...,str[i].  len[0] = 1; beginIndex[0] = 0;   Now, try to find out len[i] in terms of len[i-1] and beginIndex[i] in terms of beginIndex[i-1] - during this we should leglect the special case when all characters in palindromes are same. We should find maximum length palindrome of this type.  We should deal with the special case where all characters in palindromes are same separately and find the maximum length palindrome of such type.   Out of above two, we should pick the longer palindrome. More than enough to solve it.   In any case, full code is below:   public static String longestPalindrome(String str)  {   String result = \"\";      int[] bIndex = new int[str.length()];   int[] len = new int[str.length()];      int i = 0, j = 0, index = 0;   bIndex[0] = 0;   len[0] = 1;   if(str.charAt(0) == str.charAt(1))   {    bIndex[1] = 0;    len[1] = 2;   }   else   {    bIndex[1] = 1;    len[1] = 1;   }      int maxLen = 0, bIndexMax = -1;   char c;      for(i = 0; i < str.length(); i = j)   {    c = str.charAt(i);    for(j = i+1; j < str.length() && str.charAt(j) == c; j++);    if(maxLen < j-i)    {     maxLen = j-i;     bIndexMax = i;    }   }      for(i = 2; i < bIndex.length; i++)   {    index = bIndex[i-1];    if( index == i-1)    {     if(str.charAt(i-2) == str.charAt(i))     { // check for odd length palindrome      bIndex[i] = i-2;      len[i] = 3;     }     else if(str.charAt(i-1) == str.charAt(i))     {      bIndex[i] = i-1;      len[i] = 2;     }     else     {      bIndex[i] = i;      len[i] = 1;     }    }    else    {     if(index-1 < 0)     {      bIndex[i] = i;      len[i] = 1;     }     else if(str.charAt(index-1) == str.charAt(i))     {      bIndex[i] = index-1;      len[i] = len[i-1] + 2;     }     else      bIndex[i] = i;    }   }      for(i = 0; i < len.length; i++)   {    if(maxLen < len[i])    {     maxLen = len[i];     bIndexMax = bIndex[i];    }   }         return str.substring(bIndexMax,bIndexMax + maxLen);     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"This self-contained C program will print out all of the palindrome lengths for all possible centers, and it will do it in O(n) time. It is a port of the algorithm in Haskell authored by Johan Jeuring here: johanjeuring.blogspot.com/2007/08/finding-palindromes.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Yes, LC String does not work. Ex: string:abcdecba    reverse:abcedcba        LCS:abc/cba"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"find palindrome in string A  reverse A as A', so it's equivallent to find longest common substring between A and A'?  if so, we can use prefix array method to do this as the \"pearls\" book suggested?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can use suffix tree or suffix array.  for(i=0;ic[i]=&A[i]; for(i=0;ic'[i]=&A'[i];  for(i=0;i{ get the longest common substring from the head of c[i],c'[n-i-1] c[i+1],c'[n-i-1] }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a problem of finding the LCS(longest common subsequence ) between the string and the its reverse."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is Longest Common Substring (Need to be contiguous)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"01234567890010987654321 will return 123456789"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Original string is A 2. Reverse string is B 3. Find common strings are C, D, E .... 4. Find palindromic strings in step 3, suppose C, D. 5. Find the max length of strings in step 4. Return."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's a solution in C++ (may not be the most effective, though). Basically it checks if the given string \"s\" is a palindrome. If it is, then that's the longest we can find.  If not a palindrome, look in s.substr(0, len - 1) and in s.substr(1, len - 1) and return the longest result."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"http://wiki.answers.com/Q/Is_there_any_way_to_find_the_largest_palindrome_in_a_string"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Naive algorithm finds he solution for the problem in O(n3) time. Select two ends to define a substring and check in linear time whether it is a palindrome.  2)Enhancement can be done to the naive algorithm to make it work in O(n2) time and O(n) space. Consider two strings  S and S(reverse).  for each character in first string: for each subpattern in first string match the pattern in second string by KMP algorithm to find longest common string in both in linear time O(n+n) and O(n) space(this will be the palindrome). overall runtime O(n2) and O(n) space.  3)The optimized version of the algorithm runs in O(n) time with suffix trees."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i think we can solve this using dynamic programing...  n is the length of str if(istr[i]==str[n] i++,n--;store i,n; else call func with i+1,n call func with i,n-1 }  i think u got my sol.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"DP solution:   int F(char* a, int n) {   if(n==1) return 1;      int k = F(a, n-1);   if(IsPalindrom(a, n-2k-2, n))     k++;    return k; }  thoughts?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just have an idea to reduce few calculations .. 1. Maintain a hash table..keep track of all characters which appear more den once .( store their indices ) 2.You can chek for all these indices ..this will possible reduce chekin for all the possibilities ..waitin for a better soln :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Agreed with sameerud, but essential addition: there are 2 types of palindromes: something like 'aba' and 'abba'.  So for every symbol we should test those two possibilities, not only the first one."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Agreed with sameerud, but essential addition: there are 2 types of palindromes: something like 'aba' and 'abba'.  So for every symbol we should test those two possibilities, not only the first one."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Input String is s1, Reverse the string to s2. Use Dynamic Programming to find the longest common substring. That gives u the result!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(size(s1)+size(s2)) it is!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I kind of disagree from sameerud, because take an example of a string abcaba,,, so as i understand his algo. won't be able to find the pallindrome aba,,  So, i there is one another algo  char *lar_pal = NULL;  char *str = /*some string*/ for(int i=0;i    for(int j=i+1;j        }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorry for previous reply,, pressed enter by mistake  I kind of disagree from sameerud, because take an example of a string abcaba,,, so as i understand his algo. won't be able to find the pallindrome aba,,  So, i there is one another algo. (I should write sudo code)  1) Start from the first element i in the string and compare it will all other element j in the     string //for(j=i+1;j   a) if string[i] == string[j]             if(pallindrome(somestr,i,j)){                  //the substring is from i - j index             }     pallindrome(char *someStr, int i, int j) 1) if someStr[i+1] == someStr[j-1]       if(i==j || i+1 == j)                    //aba,,,,abba              return true       aii) else                 i+=1;j-=1;                 pallindrome(someStr,i,j)    else        return false"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"reverse + LCSubstring"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a Longest Common Substring Problem,we basically construct the generalized suffix tree for the give string and its reverse.From the constructed tree it would be possible to find the longest Palindrome by traversing the tree.The construction of the tree would take O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My views:  1. Start with the middle element in the String (len/2).  2. Have two pointers (i and j): i goes back till 0, j goes forward till n. 3. whenever this fails : you have your longest palindrome.   This can be done other way too:  1. Have two pointers i and j at the beginning and at the end.   Like wise. Any takers?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I guess this is one of the best possible solution... But, usually this problem is coupled with another objective to find all the palindromes in a string and also to find the longest palindrome..in this case instead we can use a static variable and find the longest palindrome..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@particularraj: your algorithm works by the assumption that the palindrome starts in the middle of the string. It doesn't consider palindromes that at other places in the string. For example, consider the string ABMOCECXYYZ  Here according to your algorithm, you will start at 'E' moving i backward and j forward. When i reaches 'O' and j reaches 'X', the algorithm stops and concludes that 'CEC' is the longest palindrome. But 'XYYZ' is the longest palindrome in the above mentioned string."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The example string should be 'ABMOCECXYYX'."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Nice comment KB. Then I guess I have no choice but to iterate it 'N' times and update a static variable, so that we access and get the longest palindrome.   What do you think?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Create suffix trees of the original and reversed strings. Sort the suffixes separately. Find max length between suffix array from one string to that of the reversed."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is there any O(n) solution other than suffix tree. I dont think the interviewer would ask you to construct a suffix tree during the interview."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Suffix trees has O(n) time to look."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Suffix tree will give a very good solution, but it is difficult to come up in a interview. I would go with a dynamic programming approach,  Suppose we have the given string as,  InputString = \"abaccabadefg\"  Here there are 4 palindrome strings, aba - length 3 cc - length 2 aba - length 3 abaccaba - length 8  Now the output should be abaccaba  In order to find that, reverse the input string, ReverseString = \"gfedabaccaba\"  Now create a 2 dimensional matrix of NxN and follow a dynamic program approach to get the length on the longest palindrome and display it. Heart of the solution is,  A[i,j] = Max (a[i-1, j], a[i,j-1] if InputString[i] != ReverseString[j]        = a[i-1,j-1] + 1, if InputString[i] == ReverseString[j]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about having two pointers, one at the start and one at the end of the string.  For each character in the string, you will traverse backwards from the tail and try to find the largest possible palindrome matching with the start of the strong, if any.  You keep doing for every character, this until you find one, any palindrome.  Each time you do this loop for a character from the head, your largest palindrom will be s-n, where s is the original string length, and n is the number of iterations you've done this.  When you do find a palindrome, any palindrome, you will know that if the largest palindrome, it will be at between size (curr palindrom size) and (s-n).  Armed with this knowledge, you can then write a function that is optimized to only process the remainder of the array for strings that meet the stringlength described above.  And of course, this could be done elegantly using recursion, and fine tuning it with the logic similar to the above once you have confirmed at least one palindrome.  This of course is going to be a resource hog but the code will be easier to read and manage.    :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Find the reverse string 2. Find longest common substring  Will this work? I think dynamic programming approach that you mentioned is same as this."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My cents:  Building suffix trees is not a bad idea. We can get that in O(nlogn) time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Take a string  1. Reverse the string 2. XOR with the Original String 3. Find the longest sequence of 0s in the XORed result which will be the corresponding  answer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"start with the first character. try to lookup the same character from the bak. on finding the same character from the back check if the substring is palindrome or not. keep on finding the same character until u reach the index of the first character.  keep on doing the same for all the characters. ....O(n^2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just reverse the string and find the largest substring in both the strings. O(n^2)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"finding the longest substring of the string and it's reverse won't work.  Consider abcdefgHELLOWORLDgfedcba  The longest palindrome is actually LL, that method would return abcdefggfedcba"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Keep a current pointer on the second element a(1). place two other pointers at current-1 and current+1. check if curr-1 and curr+1 are equal. then move current pointer ahead. again set curr-1 and curr1 and check for: If curr is at ith position: while(i>0) { if (curr-1 == curr+1)  {    (curr+1)++;    (curr-1)--;     i--; } else break; }  keep tack of the largest one by storing the value of current for which the length of palindrome was max. also keep track of it's length for each i. Then u can print the longest palindrome."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@gagdeep what does the 'i' signify ??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can you show the working code by which you arrived O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think we cannot solve this question in less than O(n^3) complexity........as ideally there are n*n different string that can be created using a string of length n......For example there are 1 string of length n that can be formed from given string and there are 2 string of length n-1 that can be formed using a string of lenght n-1 and there are n string of length 1.  So if you sum it all, there are 1+2+ ........+ n-1 + n strings = O(n*n)........  We know how to check for one string in O(n) time, so I think we can just repeat the loop by checking string of length n to 1 and stop whenever we find any palindrome.....  Seriously, I don't think we can solve this question in less than this time, because we have to check for string of each length and in worst case there might not be any palindrome in string and so we might end up with generating palindrome on length 1 i.e . character itself, if you consider that to be a palindrome.....  Please share your thoughts, I would be happy to hear from anyone....who can help me in improve on this solution..........."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"maxindex = 1; \nmaxlen = 1; \nfor(index = 1 to str.length) { \n  for(cur = 1 to min(index, abs(str.length - index))) { \n    if(str[index + cur] == str[index - cur]) { \n      if(cur < maxlen) continue; \n      maxlen = cur; \n      maxindex = index; \n    } \n  } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am not sure about suffix tree, as I have not read those yet, but I don't think we can solve this question iteratively in less than O(n^3) and I don't think dynamic programming will work too as we cannot use the result that I got in previous iteration because if I have two strings that are palindrome then I cannot say that if I merge both string then those will be palindrome also...  Here is my solution using O(n^3) complexity.  There are n*n different string that can be created using a string of length n......For example there are 1 string of length n that can be formed from given string and there are 2 string of length n-1 that can be formed using a string of lenght n-1 and there are n string of length 1.  So if you sum it all, there are 1+2+ ........+ n-1 + n strings = O(n*n)........  We know how to check for one string in O(n) time, so I think we can just repeat the loop by checking string of length n to 1 and stop whenever we find any palindrome.....  Seriously, I don't think we can solve this question in less than this time, because we have to check for string of each length and in worst case there might not be any palindrome in string and so we might end up with generating palindrome on length 1 i.e . character itself, if you consider that to be a palindrome.....  Please share your thoughts, I would be happy to hear from anyone....who can help me in improve on this solution..........."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A working solution. O(n*n*n) complexity but good for an interview."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Not sure what happened to the white space.  Here is a quick test I used."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this way: 1. define stringbulder variable called sb and an int called numberOfChars and max 2. for each character in the string  3. add the character to sb, and set numberOfChars to 1.      4. for each remaining character in the string 5. append the character to sb and increment numberOfChars by 1.      6. if the character is the same as the character read in step 2, then what we have in sb is a potential palindrom so, call a helper funtion called IsPalindrome with the value in sb as an argument. 7. If step 6 returns true, then add the content of sb to a dictionary with sb as a key and numberOfChars as a value---you can have duplicate checks 8. inner loop ends here 9. if numberOfChars > max then reset max to numberOfChars and clear sb 9. loop to the first loop. 10. Now, all possible palindrome strings are in your dictionary. Return a key with value equal to max.  Note that: The algorithm generates all possible palindroms but, i think there might be a better way of doing it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Longest thread of answers to Longest palindrome finding :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"could not post the link. google for this. the first link has a good solution  finding-the-longest-palindromic-substring-in-linear-time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It's awesome to see people using suffix tree and O(nlogn) at the same time !!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My suggestion is that any approach of O(n^2) time and O(1) space that can be well explained and you can write working code during an interview would suffice!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Reverse the string and find biggest substring."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"No need for such complex algorithms !!!  I was asked this question, I proposed trying all combination (O(n^2) I think) he looked convinced with that approach."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Example: ================ Str1=abcbabcmoms  Str2=abcba   ALGO: ================ 1.a          take A[i]==A[j] , decrement J-- till i                  if A[i]==A[j]                 take paldromeindex=i                 and increment i and decrement j till i=j                 RANGE[k]=J-I                  1.b          sort range and return the longest one  CODE: ================  private string LongestPalindrom(Str S1,int size) { int maxrange =0;                  For(int i=0;i                {                 char ch1=s1[i];                                                                  FOR(INT J=SIZE; J>0;J--)                                                 {                                 char ch2=s1[j];                                                  IF(CH1==CH2 && i!=j)                                                 {                                                  int range= j-i;                                                  i++;                                                  ch1=s1[i];                                                 }                                 }                                  IF(MAXRANGE                                {                                 int maxrange =range;                         int maxindex=i                                 }                 }                  FOR(k=maxindex;k                                {                                  Console.writeline(Str[k]);                                            }  }    TEST HARNESS: ================ using system;  namespace problem {                 class Solution                 {                    static void Main(string[] args)                 {                                  String Pal1 =\"abcbabcmoms\"                                  String Result;                                  Result= Longestpalindrom(Pal1,11); }}}  ORDER: ================ O(N^2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Tarun, Nice try but you need more temp variables to save indexes and values. Try this string and you will find a bunch of bugs in ur code. \"BBABTENETTENEB\".  This is is the code i came up with, can you guys please review it:  void longestPalindrome(char* str, int size, int* begin, int* range){      *begin = 0;      *range = 0;      int i, j, pali, tempRange = 0;      for(i = 0; i < size; i++){            *begin = pali = i;            for(j = size - 1; j >= pali; j--){                  tempRange = j - *begin;                  if(str[pali] == str[j]){                       pali++;                  }else{                       tempRange = 0;                       if(pali != *begin){                           break;                           }                   }                  }            if(*range < tempRange){                *range = tempRange;                            }            } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int main() \n{ \nchar a[]=\"abcdaeeadabb\"; \nchar *p,*q,*r,*found; \nint i=0; \nint max=0; \nfor(p=a;*p!='\\0';p++) \n{ \nq=p; r=a+strlen(a); \n    while(qmax) {max=i; found=p;} \n} \nif(q==r) max=max+1; \nstd::cout<<<*found; \nreturn 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void longestPalindrome(char *str, int n) \n \n{ \n \n    int i=0, j=0, start = 0, end = 0, range = 0, maxstart = 0,maxend = 0; \n \n    while(i < n && j < n) \n \n    { \n \n        start = i; end = j; \n \n        while((str[start] == str[end]) && (start >=0) && (end <= n)) \n \n        { \n \n            if((maxEnd - maxStart) < (end-start)) \n \n            { \n \n                maxEnd = end; \n \n                maxStart = start; \n \n            } \n \n            end++; \n \n            start--; \n \n        } \n \n        start++; \n \n        end++; \n \n    } \n \n \n    for(int i = maxStart; i <= maxEnd; i++) \n \n        printf(\"%c\", str[i]); \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is indeed a Dynamic Programming problem as Gopal Krishna has indicated but I can't think of a a solution that can solve this in less than O(n2).  My O(n2) solution was to take the string and its reverse (i.e. output of strrev(string)) and do a longest sub-string match using dynamic programing. The largest sub-string match is the longest palindrome in the given string."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Collections;  class Program { static void Main(string[] args) { Program p = new Program(); Console.WriteLine(p.LargestPalindrome(\"abbac\"); }    public String LargestPalindrome(String str)         {             int[] ar = new int[str.Length];             for (int i = 0; i < str.Length; i++)             {                 int start = i;                 for (int j = str.Length - 1; j >= i; j--)                 {                     int end = j;                     int cnt = 0;                     while (start <= end)                     {                         if (str[start] == str[end])                         {                             if (start != end)                                 cnt += 2;                             else                                 cnt++;                             start++; end--;                         }                         else                         {                             cnt = 0;                             break;                         }                                             }                     if (ar[i] < cnt)                         ar[i] = cnt;                 }             }             int max = 0;             for (int i = 1; i < ar.Length; i++)             {                 if (ar[i] > ar[max])                     max = i;             }              return str.Substring(max, ar[max]);         } }1 2 10 42 11"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int _tmain(int argc, _TCHAR* argv[]) {  char p[500],*temp;  int i,j,str_len,k;  printf(\"\\n Enter the string \");  gets(p);  if (palendrome(p) == 0) {   printf(\"\\n String is a palendrome\");   return 1;  }  else   printf(\"\\n Not a palendrome\");    str_len = strlen(p);  int largest_palindrome = 0;  char q[100];  for(i=0;i {   temp = p+i;   for(j=2;j<=str_len-i;j++)   {    if(palendrome_substring(temp,j) == 0)    {     if (j > largest_palindrome){      largest_palindrome = j;      memcpy(q,temp,j);      q[j] = '\\0';     }    }   }  }  printf(\"\\n largest palendrome %s\",q);  return 0; } int palendrome(char *p) {  int str_len = 0,i;  if (!p ) return -1;  str_len = strlen(p);  if(str_len < 2)return 1;  for(i=0;i<(str_len/2);i++)  {   if (p[i] != p[str_len - i - 1])    return 1;  }  return 0; }  int palendrome_substring(char *p, int size) {  int str_len = 0,i;  if(!p || !size) return -1;   str_len = size;  for(i=0;i<(str_len/2);i++)  {   if (p[i] != p[str_len - i - 1])    return 1;  }  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"N^2 solution - Dynamic Programming. Should be good for interview. \nisPalindrome[i,j] = isPalindrome[i+1, j-1], if str[i] == str[j] \n                  = false, if str[i]!= str[j] \n                  = true,  if i == j //single character \n \nAfter the matrix is filled, traverse diagonally to find the longest palindrome"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"small change in previous program: \n \nchar * fndlong (char *str) \n{ \n char * pointpal, *longestpal; \n int length, longest=0; \n while(*str) \n {int i=1; \n \n  if(*str==*(str+i)||*(str-i)==*(str+i)) \n  { \n   if (*(str-i)==*(str+i)) \n    pointpal=str-i; \n   else \n    pointpal=str; \n   i++; \n   length=0; \n   while(*(str-(i-1))==*(str+i)||(*str-i)==*(str+i)) \n   { \n    pointpal--; \n    i++; \n    length=+ 2; \n   } \n  } \n  if(longest==0 || length>longest) \n  {  \n   longest=length; \n   longestpal=pointpal; \n  } \n  str++; \n } \n return longestpal; \n} \n \nint main() \n{ \n char * str1=\"ABMABCDDCBAOCECXYYXOPQR\"; \n char * longestpal= fndlong(str1); \n char * point=longestpal; \n int loop=1; \n \n while(loop) \n { \n  cout<<*longestpal; \n  longestpal++; \n  if (point==longestpal) \n  { \n   loop=0; \n  } \n  if(*point==*longestpal) \n   point=longestpal+1; \n } \n cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"program to find longest palindrome: int main() {  int i,j,count=0,check=0,loc=0,pos=0;  string str;  cout<<\"enter string\"< cin>>str;  for(i=1;i {   for(j=i;j  {    if(j-1<0 || j+1>=str.length())     break;    if(str[j-1]==str[j+1])    {     count++;     loc=j;    }    else     break;   }   if (count>check)   {    check=count;    pos=loc;   }  }  for(int k=(pos-check);k<=(pos+check);k++)   cout<}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A very good O(n2) easy to follow code is available in technicalypto.com/2010/02/find-all-possible-palindromes-in-string"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The idea is to go left and right from each element until left will be the beginning, or right will be the end. \nThe initial length of each possible palindrome is 1. \nWe need to distinguish 2 cases: \n \n1). \"Odd\" case, like \"abcdcba\" \n2). \"Even\" case, like \"dcbaabcd\" \n \nIn \"even\" case, we need to shift our \"right\" pointer to one position right and to increasr the current length. \n \nDuring each next move, we increase our current palindrome length on 2, if the left and the right characters are the same. \nWhen palindome stops (we reach the array borders, or our left and right characters are not the same any more), \nwe compare our current palindrome length with the previous maximal length. \n \nvoid FindLongestPalindrome(char Arr[]) \n{ \n char* pCurr; // moving through our string \n char* pBegin; // the beginning of the string \n char* pEnd; // the end of the string \n char* pLeft; // to go left from the current character \n char*pRight; // to go right from the current character \n \n int iMaxIndex=0; \n int iCurIndex=0;  \n int iMaxLength=1; \n int iLength; \n \n pCurr=pBegin=&Arr[0]; \n pEnd=pBegin; \n  \n while(1) \n { \n pEnd++; \n if(*pEnd=='\\0') break; \n } \n    // now pEnd points to the end of our array  \n \n while(1) // go through the array \n { \n  iLength=1; \n \n  //Odd case: \n  pLeft=pRight=pCurr; \n  //even case: \n  if((*pLeft)==(*pRight+1)) \n  { \n   pRight++; \n   iLength++; \n   if(pRight>pEnd) break; \n  } \n \n  while(1) \n  { \n           if((*pRight) != (*pLeft)) break; \n      \n     pLeft--; \n     pRight++; \n     if((pLeftpEnd)) break; \n \n     iLength = iLength+2; // because we add characters from the left and from the right \n  } \n \n  if(iLength > iMaxLength) \n  { \n           iMaxLength = iLength; \n     iMaxIndex = iCurIndex; \n  } \n   \n  pCurr++; \n  if(pCurr>pEnd) break; \n  iCurIndex++; \n } \n \n // Now we have iMaxIndex as the beginning of longest palindrome, and iMaxLength as it's length \n     \n for(int i=iMaxIndex; i<=iMaxIndex+iMaxLength; i++) \n printf(\"%c\", Arr[i]); \n printf(\"\\n\"); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Reverse the string and compare using a shifting window."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def updateMax(palinIndex, palinLen, maxPalinLen, maxPalinIndex, i): \n    if palinLen>maxPalinLen: \n        maxPalinLen=palinLen \n        maxPalinIndex=palinIndex \n    palinLen=0 \n    palinIndex=i \n    return palinIndex, palinLen, maxPalinLen, maxPalinIndex \n         \ndef longestPalindrome(s): \n    pi=0 #Palindrome Index \n    pl=0 #Palindrome Length \n    lpl = -1 #Longest Palindrome Index \n    lpi = -1 #Longest Palindrome Length \n     \n    for i, c in enumerate(s): \n        if i==0: \n            continue \n        if s[pi]==c: \n            if (pi>0): \n                pi-=1 \n                pl+=2 \n            else: \n                pi, pl, lpl, lpi=updateMax(pi, pl, lpl, lpi, i) \n        else: \n            pi, pl, lpl, lpi=updateMax(pi, pl, lpl, lpi, i) \n    pi, pl, lpl, lpi=updateMax(pi, pl, lpl, lpi, i) \n    return s[lpi+1:lpi+lpl+1] \n \ns=\"ldsfkjoeiwrjwelskzdjfsdaasdfgfdfghjkllkjhgfdlkfherqriuthekdfsnvgkjwnoirjsefdq\" \nprint longestPalindrome(s)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Read about Manacher's Algorithm"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Whaqt about below solution, let me know if any bug is there, inputs tested are  LongestPalindrome(\"aabcbcdab\");           LongestPalindrome(\"aaaaa\");            LongestPalindrome(\"abbba\");            LongestPalindrome(\"this is a a uyt this is a a si si\");            LongestPalindrome(\"abeeddddeabe\");    public static void LongestPalindrome(string a)         {              string isPalindrome = \"\";             string largestPalindrome = \"\";             int j, k;             for (int i = 0; i < a.Length - 1;i++)             {                 k = i + 1;                 j = i - 1;                       if (j >= 0 && k < a.Length)                 {                     if (a[i] == a[j] && a[i] == a[k])                     {                         j--; k++;                     }                 }                  if (j > 0 && k < a.Length)                 {                      if (a[i] == a[j])                         j--;                     else if (a[i] == a[j])                     {                         k++;                     }                 }                 while (j >= 0 && k < a.Length)                 {                     if (a[j] != a[k])                         break;                     else                     {                         j--;                         k++;                     }                     isPalindrome = a.Substring(j + 1, k - j - 1);                     if (isPalindrome.Length > largestPalindrome.Length)                     {                         largestPalindrome = isPalindrome;                     }                 }             }             Console.WriteLine(largestPalindrome);            }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int[] getLongest(String str){ \n  char[] data = str.toCharArray(); \n  int[] index = new int[data.length]; \n  int[] buffer = new int[256]; //store pre index \n  int max = 0; \n  int[] span = new int[2]; \n   \n  for(int i = data.length - 1; i >= 0; i--){ \n   index[i] = buffer[data[i]] == 0 ? -1 : buffer[data[i]]; \n   buffer[data[i]] = i; \n  } \n    \n  for(int i = 0; i < index.length && index[i] != -1 ; i++){ \n   int cur = i; \n   int j = index[i]; \n   while(j != -1){ \n    for(; j != -1; j = index[j]){ \n     if(isPaloindromes(data,cur,j) == true){ \n      if(max < j - cur + 1){ \n       max = j - cur + 1; \n       span[0] = cur; \n       span[1] = j; \n      } \n     } \n    } \n    int tmp = cur; \n    index[tmp] = -1; \n    cur = index[cur]; \n    j = cur == -1 ? -1 : index[cur]; \n   } \n  } \n  return span; \n } \n  \n public static boolean isPaloindromes(char[] data, int i, int j){ \n  int mid = (i + j) / 2; \n  for(int k = 0; k < mid; k++){ \n   if(data[i + k] != data[j - k]) \n    return false; \n  } \n  return true; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I choose maintainability over performance until performance testing shows the code to be a bottleneck."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"{{package mic01;  public class LongestPalindrome {   public static void main(String[] args) {      String dummy = \"AAABBGFF ili ollo benmio ooloo eo sadkjansd evbnbve eikdo ooooooooookoooooooooo\";      System.out.println(letsDoThis(dummy));      }   private static String letsDoThis(String dummy) {   String result = null;   int max = 0;   String[] a = dummy.split(\" \");   for(int i=0; i   if(isPalindrome(a[i])){     if(a[i].length() > max)      result = a[i];    }   }   return result;  }   private static boolean isPalindrome(String string) {    int length = string.length();   if(length % 2 == 0)    return false;   else{    for(int i=0; i    if(string.charAt(i) != string.charAt(length-i-1)){      return false;     }    }   }    return true;  }  }  }}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15444944","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"48","title":"Given an array elements, Find the maximum number which can be formed by the array elements Eg input ??C a[ ] = {9,6,8,1] Output -    9861","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"11","title":"This is just sorting algo (descending order ).. the only modification we need to do is .. while comparing 2 integers , we have concat one with other and compare ....  ex: {9,10} --> then while comparing 9 and 10 .. we have concat these two...910 > 109 ... so 9 comes before 10  Ex: {9,900}--> 9900>9009 --> 9 comes before 900.. Ex {10,107} --> 10710 > 10107  --> 107 comes before 10...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Here is the C++ code for this"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"do radix sort and append the digit.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here we have to sort the numbers according to the digit positions...If conflict occurs between any 2 numbers sort according to the next digit. Let me explain with an example:  Array: [9, 18, 3, 28, 173] Step 1: Sort according to 1st digit : [9,3,28,(18,173)] step 2: here 18, 173 have same 1st digit. So sort according to next digit. : [9, 3, 28, 18, 173]  So output: 932818173...  P.S: We can use 'Divide by 10' technique to get first digit each time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This approach is a bit bad, but How about, generate all the n digit (n is size of array) permutation of given array and then picking up the largest number among them  arr[1,2]     2 digit permutations are [1,2]  [2,1]   ....21 is the largest..you need to use some extra space to store the permutation output ...and then sort that.....This can be optimized however"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  #include    int compare(const void *xptr, const void *yptr) {     char *sbuffer=(char *)malloc(sizeof(char)*20),*tmp;     char *lbuffer=(char *)malloc(sizeof(char)*20);     int x=*(int *)xptr;     int y=*(int *)yptr;     int cnt=0,swapped=0;     itoa(x,sbuffer,10);     itoa(y,lbuffer,10);     if(strlen(sbuffer)>strlen(lbuffer))     {         tmp=sbuffer;         sbuffer=lbuffer;         lbuffer=tmp;         swapped=1;     }                                        while(*sbuffer==*lbuffer&&*sbuffer!='\\0')     {          sbuffer++;          lbuffer++;          cnt++;     }     if(*sbuffer=='\\0')        if((*lbuffer-'0')>(*(sbuffer-cnt)-'0'))           return(swapped?-1:1);        else            return(swapped?1:-1);    else        return(swapped?(*sbuffer-*lbuffer):-(*sbuffer-*lbuffer)); }      int main() {     int values[]= {9, 18, 3, 28, 173};     int i;     //int values[]={9,900};     //int values[]={10,107};     //int values[]={3,71,2};     //int values[]={7,76,7,7};     int size=sizeof(values)/sizeof(values[0]);     qsort (values, size, sizeof(int), compare);     for(i=0; i       printf (\"%d \",values[i]);        getchar(); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about simply sorting even and odd positions separately. \nHere is the code.  \n#define ASC  1 \n#define DEC  2 \n \nvoid sort(int *a, int len, int skip, int order) \n{ \n int i,j; \n \n for(i=0; i a[j]) || \n     (order == DEC && a[i] < a[j])) \n    swap(a, i, j); \n  } \n } \n} \n \nint main() \n{ \n        int a[] = {7,1,4,2,18,34,16,12,19,56,3,20, 5}; \n int len = sizeof(a)/sizeof(int); \n        sort(a, len, 2, ASC); \n        sort(a+1, len-1, 2, DEC); \n \n        return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"lexographic sorting will do. Example: 10, 7, 9, 20, 30  compare 10 and 7 : 7 is greater than 1. NUMBER: 710 compare 710 and 9 : 9 is greater than 7. NUMBER: 9710 compare 9710 and 20 : 2 <  9  go forward  check 2 < 7 go forward 2 > 1 Number: 972010. compare 972010 and 30 : 3 < 9 go forward 3 < 7 go forward 3 > 2 Number: 97302010."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"suppose u have some numbers in an array ,then u have to find greatest no.then there must me some no start with either 0-9 .u have to separate those no in different bucket on the basis of starting no.then within each bucket sort the number.sorting is done on the basis of digit,if 2 no is dere then sort it in this manner.example:- suppose i have 2 no in a bucket,(4,48).these 2 goes in 1 bucket.then on the basis of digit sort this(48,4).then ur work is done."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Step 1:- filter base no digits like (single,double...) Step 2:- sort all single, then all double...... step 3:- merge  step 4:- output"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"E.g. {1, 34, 3, 98, 9, 76, 45, 4}  \n   1. Sort on most significant digit of each number first. After this step all numbers starting with 9 will be followed by all numbers starting with 8 and so on. For above example: {9, 98, 76, 45, 4, 3, 34, 1}. There will be 9 groups and a group of zeros if present. \n    2. Sort the numbers within each group with the following special comparison function compare(a,b): \n         2a. Normal integer comparison with a,b have same number of digits.  \n         2b. If a and b do not have equal number of digits, add the digit corresponding to the group as many times as needed to make the two have equal number of digits.  \n      3. The final answer is the concatenation of the sorted numbers in steps 1 and 2."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What about this guys 1. Sort array in descending order 2. build the string by appending each digit 3. cast to int"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assumption: number is an integral 64 bits.  Insertion sort in descending order. With long int of 64 bits, the max positive value possible is 9223372036854775807, which is 19 digits. Insertion sort may do element copies. For example, if all the elements are sorted in descending order except the first element, then insertion sort needs to shift N-1 elements. In contrast, using quicksort, the number of copy operations is logn."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"scala> val a = Array(9,6,8,1).sortWith((x,y) => x.toString > y.toString).mkString.toInt \na: Int = 9861"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about a bucket sort and ordering from reverse???"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Sort the array in descending order -  T(N) = O(NlgN) and S(N) = O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public static void findMaxNumber(Integer[] input){ \n        Arrays.sort(input, new Comparator(){ \n \n            @Override \n            public int compare(Integer o1, Integer o2) { \n                StringBuffer buf = new StringBuffer(); \n                buf.append(o1); \n                buf.append(o2); \n                String s1 = buf.toString(); \n                String s2 = buf.reverse().toString(); \n                return s2.compareTo(s1); \n            } \n        }); \n \n        StringBuffer buf2 = new StringBuffer(); \n        for(int n : input){ \n            buf2.append(n); \n        } \n \n        System.out.println(buf2.toString()); \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"do permutation of number  and keep track of maximum number."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Convert the array into String so that we have all the array as the String of digits and then we can do a sort on the String in descending order to get the largest number."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=23092662","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"48","title":"Given you an array of 100 Elements with one number missing, how will you find the missing number?  Array 1 to 100 with 55 missing.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"9","title":"Really? :)... Just do sum of all the numbers from 1 to 100 : (n * (n+1))/2 and find sum of all the elements from actual array. Just take the difference and you will get missing number."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"9","title":"There is a very elegant solution using bitwise operations with integers. The following solution has O(n) time and O(1) space:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Pretty simple C# solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here another method is used to find any number of missing numbers within a given range: a. Get the min and max of the array. b. Make the count array of size max. c. Store INT_MIN values in the count array till min that is from 0 to min-1 as this is not the range to search for. d. Make the rest of the elements from min to max to 0 e. At last increment the count for every value. f. For those elements for which the count is 0 they are missing. Here is the code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include void missing(int [],int); int main() { int A[]={4,3,5,2,8,9,6,10,13,11,12}; int n=sizeof(A)/sizeof(A[0]); missing(A,n); return 0; }  void missing(int A[],int n) { int i,j; int max,min; max=min=A[0]; for(i=0;i{ if(maxmax=A[i]; if(min>A[i]) min=A[i]; } int c[max]; for(i=0;i{ c[i]=0; }  for(i=0;i{ c[A[i]]=c[A[i]]+1; }  for(j=min;j{ if(c[j]==0) { printf(\"the missing no is= \"); printf(\"%d \",j); } } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include void missing(int [],int); int main() { int A[]={4,3,5,2,8,9,6,10,13,11,12}; int n=sizeof(A)/sizeof(A[0]); missing(A,n); return 0; }  void missing(int A[],int n) { int i,j; int max,min; max=min=A[0]; for(i=0;i{ if(maxmax=A[i]; if(min>A[i]) min=A[i]; } int c[max]; for(i=0;i{ c[i]=0; }  for(i=0;i{ c[A[i]]=c[A[i]]+1; }  for(j=min;j{ if(c[j]==0) { printf(\"the missing no is= \"); printf(\"%d \",j); } } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ruby Code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args)   {   int[] ip = {1,2,3,4,5,6,7,8,9,10}; //5 is Missing   Arrays.sort(ip);      for(int i=0; i  {    if(i==0 && ip[i]    continue;    }else if(ip[i]>ip[i-1] && ip[i]    continue;    }else{     System.out.println(\"Missing Number is : \"+(ip[i]+1));     break;    }   }      System.out.println(\"All the Numbers are present between \"+ip[0]+\" and \"+ip[ip.length-1]);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args)  \n { \n  int[] ip = {1,2,3,4,5,6,7,8,9,10}; //5 is Missing \n  Arrays.sort(ip); \n   \n  for(int i=0; iip[i-1] && ip[i]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args)  \n { \n  int[] ip = {1,2,3,4,5,6,7,8,9,10}; //5 is Missing \n  Arrays.sort(ip); \n   \n  for(int i=0; iip[i-1] && ip[i]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is c# solution in o(n) complexity:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void missingNumber() {    int series[] = { 1, 2, 4, 6, 3, 5, 7, 8, 9, 10, 11, 12, 13, 14,15, 18, 16,17,20};   Arrays.sort(series);   int length = series.length;   int first = series[0];   int last = series[length - 1];   int totalNumbers = length + 1;   int actualSum = 0;   for (int i = 0; i < length; i++) {    actualSum = actualSum + series[i];   }   int sum = totalNumbers * (first + last) / 2;    System.out.println(\"missing number: \" + (sum - actualSum));   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For finding two missing numbers, using @ashot madatyan's solution:  Original procedure to find xor remains same. However, in case of two missing numbers, this value is the difference of the two numbers. E.g if range is { 1,3,4,5,6,8,9,10} the missing numbers are 7 and 2. The final xor value will be 5. This is the difference 7-2 = 5. While running the xor loops , compute OR of all elements. Subtract the sum of all array elements from elements in range. This gives us the sum of the missing numbers. In our example, this will be 9.  Now, we have the sum and difference of the missing numbers. Simply OR these values, and divide by 2 to get 1 number. ( 9 | 5) /2 =  7 XOR the result with difference of numbers to get the second number. ( 5 ^ 7) = 2  This is ofc, assuming summing the array and range does not overflow int value. This approach will fail in that case."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"# include  \n# include  \nint missingval(int a[], int s) \n{ \n int i, min, max, sum,suma; \n min = a[0]; \n max = a[0]; \n for(i=0;i max) \n    max = a[i]; \n } \n printf(\"min = %d, max=%d\\n\",min,max); \nsum=0; \n for(i = 0 ; i < s ; i++) \n { sum += a[i]; \n     // printf(\"sum %d %d %d\\n\",i,sum,a[i]); \n } \n suma=min; \n for(i=min+1 ; i<=max ; i++ ) \n { \n suma +=i; \n printf(\"sum %d %d\\n\",i,suma); \n } \n printf(\"%d\", suma-sum); \n \n return(suma-sum); \n \n} \n \nvoid main () \n{ \nint arr[10]= {11,12,13,14,16,17,18,19,10}; \nint size; \nint res; \nsize = sizeof(arr)/sizeof(arr[0]); \nres=missingval(arr,size); \nprintf(\"\\n%d\",res); \n \ngetch (); \n \nclrscr(); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nint main() \n{ \n \n int a[] = {12,11,13,14,16,17}; \n int i,n,min,sum =0, max,MAX; \n int formula; \n min = a[0]; \n max = a[0]; \n MAX = (sizeof(a)/sizeof(int)); \nfor(i=0;ia[i]) \n   min=a[i]; \n} \n printf(\"min = %d, max=%d\\n\",min,max); \n n = (sizeof(a)/sizeof(int))+1; \n formula = (n*((2*min)+((n-1)*1)))/2; \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#!/usr/bin/perl my @arr = (1,29,30,31,32,33,34,35,36,37,2,13,14,15,16,17,18,19,20,21,22,3,4,5,6,7,8,9,10,11,12,23,24,25,26,27,28,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,83,84,85,86,87,88,89,90,91,56,57,58,59,60,61,62,63,64,65,66,67,80,81,82,92,93,94,95,96,97,98,99,100,68,69,70,71,72,73,74,75,76,77,78,79); $max = -1; $min = 999; $val1 = 0; $val = 0; foreach(@arr){  if($_ > $max){   $max = $_;  }  if($_ < $min){   $min = $_;  }  $val = $val ^ $_; }  my $length = $#arr + 1;  for($i = $min;$i <= $max;$i++){  $val1 = $val1 ^ $i; }  $result = $val1 ^ $val; print \"\\n RESULT = \" , $result;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#!/usr/bin/perl my @arr = (1,29,30,31,32,33,34,35,36,37,2,13,14,15,16,17,18,19,20,21,22,3,4,5,6,7,8,9,10,11,12,23,24,25,26,27,28,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,83,84,85,86,87,88,89,90,91,56,57,58,59,60,61,62,63,64,65,66,67,80,81,82,92,93,94,95,96,97,98,99,100,68,69,70,71,72,73,74,75,76,77,78,79); $max = -1; $min = 999; $val1 = 0; $val = 0; foreach(@arr){  if($_ > $max){   $max = $_;  }  if($_ < $min){   $min = $_;  }  $val = $val ^ $_; }  my $length = $#arr + 1;  for($i = $min;$i <= $max;$i++){  $val1 = $val1 ^ $i; }  $result = $val1 ^ $val; print \"\\n RESULT = \" , $result;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"You could use the divide and conquer method."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"def find_missing(): \n  l=list(x for x in range(1,101)) \n    l.remove(55) \n    print l \n Y=1 \n for x in l: \n     if x==Y: \n         continue \n     else: \n          print  Y,\"tnumber not in list\" \n          break \n     Y+=1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Then it is more simple."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Assuming that the 100 numbers are consecutive, you can sort the array in increasing order and then check for adjacent locations to find the missing number"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Something like this... the first for is just to setup the array with the missing number."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Find the sum of all the element in the array, say it is arraySum Now, sum of n number is n(n+1)/2, say sum So missing number is sum-arraySum"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Sorry, correction to my previous answer -"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"First correction array would conatin 99 elements as one is missing..assuming so  here is the python code"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14569703","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"58","title":"If an array is having integers/Char/special Char... Ex: \"PST456DA85M2A!!23++46\", find out the sum of integers. ****Note: If we find consecutive digits in array we need to treat it as number, let say 456, we need to treat it as [ four hundread and fifty six]. Write a program to get the output by summing 456+85+2+23+46..also this needs to be done in lessnumber of iterations..","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"14","title":"You just need to go though the string by char. 1 keep one String variable prev = 0  and sum = 0 2. Now go through string char by char say ch is the character  3. If ch is a digit -> prev = prev*10 + ch 4. if ch is NOT a digit or end of string -> sum = sum + prev AND set prev to 0  time complexity O(n) :  1 ITERATION"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"void  getTotalSum(char* pString) \n{ \n   if(!pString) \n        printf(\"\\nNot valid\"); \n \n   int finalSum = 0; \n   int Sum = 0; \n  while(pString != '\\0') \n  { \n     Sum = 0; \n     while((*pString <= 57) && (*pString <= 48)) \n     { \n          Sum = Sum*10 + *pString - '0'; \n          pString++; \n     } \n  finalSum = finalSum + Sum ; \n  } \n printf(\"%d\",finalSum ); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"#include \n \nint find_sum(char*s); \n \nmain() \n{ \nchar s[100]; \nscanf(\"%s\",s); \nprintf(\"\\nSum = %d\",find_sum(s)); \n} \n \n \nint find_sum(char* s) \n{ \n int sum=0; \n int temp_sum=0; \n \n while((*s)!='\\0') \n { \n  if((*s)>='0'&&(*s)<='9') \n  {  \n   temp_sum=10*temp_sum+(*s)-'0'; \n  } \n   \n  else \n  { \n   sum=sum+temp_sum; \n   temp_sum=0; \n  } \n  ++s; \n } \n sum=sum+temp_sum; \nreturn sum;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Perl Solution :  #!/usr/bin/perl    $foo = 'PST456DA85M2A!!23++46'; my @fields = $foo =~ /([0-9]+)/g;  foreach(@fields) {     $sum += $_; }  print $sum;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Make a char string to integer converter :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static void countSum() { \n    String s = new String(\"PST456DA85M2A!!23++46\"); \n    String strDigit = \"\"; \n    int sum = 0; \n    for (int i = 0; i < s.length(); i++) { \n      Character charAt = (Character)s.charAt(i); \n      if (Character.isDigit(charAt)) { \n        strDigit +=charAt; \n      } else { \n        if (strDigit.equals(\"\") == false) { \n          sum = sum + new Integer(strDigit); \n          strDigit = \"\"; \n        } \n      } \n    } \n    System.out.println(sum); \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int findSum(char *str){ int sum, num; sum=num=0; while(*str++){ if(*str>='0' && *str<='9'){ num*=10; num+=*str-'0'; } else{ sum+=num; num=0; } } return sum; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java Code by using Pattern and matcher.    static int findSum(String inputStr){   int sum=0;   Pattern p = Pattern.compile(\"[0-9]+\");   Matcher m =p.matcher(inputStr);   while(m.find()){      System.out.print(\"Start index: \" + m.start());         System.out.print(\" End index: \" + m.end() + \" \");      System.out.println(m.group());      sum=sum+ Integer.parseInt(m.group());    }     return sum;    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int calcSum(char* s) \n{ \n    int sum=0,curNo=0,i,flag = 0; \n \n    for(i=0;s[i] != '\\0';i++) \n    { \n        if(isdigit(s[i])) \n        { \n            if(flag) \n            { \n                curNo = (curNo*10); \n            } \n            curNo += s[i]-'0'; \n            flag = 1; \n        } \n        else \n        { \n            sum += curNo; \n            curNo=0; \n            flag = 0; \n        } \n    } \n    return sum;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include int main() {         char str[100000];         int k,i,j,a;         unsigned long long int sum=0,total_sum=0;         gets(str);         k=strlen(str);         for(i=0;i        {                 sum=0;                 a=str[i]-'0';                 if(a>=0&&a<=9)                 {                         sum=a;                                                  for(j=i+1;j                        {                                 a=str[j]-'0';                                                                  if(a>=0&&a<=9){                                         sum=sum*10+a;                                         i=i+1;                                 }                                 else{                                         break;                                 }                         }                                                                   }                 total_sum+=sum;         }         printf(\"%llu\\n\",total_sum);         return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int SumTheNumbers(char *in) \n{ \n int sum = 0; \n int i = 0; \n while(in[i] != '\\0') \n { \n  if(in[i] >= '0' && in[i] <= '9') // it is digit \n  { \n   int num = (int)(in[i] - '0'); \n   i++; \n   while(!(in[i] >= '0' && in[i] <= '9') && in[i] != '\\0') // untill not a digit or not an end \n   { \n    int temp = (int)(in[i] - '0'); \n    num = num*10 + temp; \n    i++; \n   } \n   sum = sum + num; \n  } \n  i++; \n } \n \n return sum; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Python solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this will go like this.  bit flgDigitFound=0; int found=0; int answer=0; int i=0;  while (input != null) {   if (input[i].char >=0 and input[i]<=9 )     {       flgDigitFound=1;       found=found*10+input[i].digit;     }  else    {      if (flgDightFound==1)        {            flgDigitFound=0;            answer=answer+found;            found=0;        }    }  i+=1; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"string inputString = \"PST456DA85M2A!!23++4600\";             char[] inputChars = inputString.ToCharArray();             double sum = 0;             double tempnum = 0;             double powerCounter = 0;             double num;             for (int i = inputChars.Length - 1; i >= 0; i--)             {                 if (inputChars[i] >= 48 && inputChars[i] <= 57)                 {                     num = inputChars[i] - 48;                     tempnum = num * Math.Pow(10, powerCounter) + tempnum;                     powerCounter = powerCounter + 1;                 }                  else                 {                     sum = sum + tempnum;                     powerCounter = 0;                     tempnum = 0;                 }              }             Console.WriteLine();             Console.WriteLine(inputString);             Console.WriteLine(sum);             Console.ReadLine();"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.io.*; public class Add  {  boolean check_int(char a)  {   if(a>='0' && a<='9')   return true;   else   return false;  }  int add(String x)  {   x=x+'!';   double sum=0;   int count=1,mul=0;      for(int i=0;i  {        if(check_int(x.charAt(i)))    {     sum=(double) (sum+Integer.parseInt(String.valueOf((x.charAt(i))))*Math.pow(0.1, count));     count++;    }    else    {     mul+=(int)(sum*Math.pow(10, count-1));     count=1;     sum=0;        }   }   return mul;  }  public static void main(String arg[])  {   Add a=new Add();   int mul1;   String input=\"PST456DA85M2A!!23++46\";   mul1=a.add(input);   System.out.println(mul1);  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int sum(final String str) { \n        int sum = 0; \n        int base = 1; \n \n        for (int startIter = str.length() - 1; startIter >= 0; startIter--) { \n            if ((str.charAt(startIter) >= '0') && \n                    (str.charAt(startIter) <= '9')) { \n                sum += ((str.charAt(startIter) - '0') * base); \n                base *= 10; \n            } else { \n                base = 1; \n            } \n        } \n \n        return sum; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int Case(char a){              int temp=a;              if(temp>=48&&temp<=57)              return 1;             else              return 0;              }      int check(char A[],int n){      int sum=0;     int i=0;     int flag=0;     while(i      int temp=0;      int tempo=Case(A[i]);        while(tempo){         int x=A[i]-48;        temp=x+temp*10;            flag=1;           i++;        tempo=Case(A[i]);       }        sum+=temp;       if(flag!=1)        i++;       flag=0;      }      return sum; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int Case(char a){ \n \n            int temp=a; \n \n            if(temp>=48&&temp<=57) \n             return 1; \n            else \n             return 0; \n \n \n           } \n \n \n   int check(char A[],int n){ \n \n    int sum=0; \n    int i=0; \n    int flag=0; \n    while(i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a working C# code. Runtime O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"amazon-interview-questions 43 Answers  If an array is having integers/Char/special Char... Ex: \"PST456DA85M2A!!23++46\", find out the sum of integers. ****Note: If we find consecutive digits in array we need to treat it as number, let say 456, we need to treat it as [ four hundread and fifty six]. Write a program to get the output by summing 456+85+2+23+46..also this needs to be done in lessnumber of iterations.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int getSum(String input){ \n                //String input = \"PST456DA85M2A!!23AA4600\"; \n  int i = 0; \n  String number = \"\"; \n  int total = 0; \n  while(i < input.length()){ \n   if(input.charAt(i) >= '0' && input.charAt(i) <= '9'){ \n    number += input.charAt(i); \n    i++; \n    continue; \n   } \n   if(!number.equals(\"\")){ \n    total = Integer.parseInt(number) + total; \n   } \n   number = \"\"; \n   i++; \n  } \n  if(!number.equals(\"\")){ \n   total = Integer.parseInt(number) + total; \n  } \n   \nreturn total;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java code that uses Regular Expression to replace non-digit characters with space. The resulting string contains only digits with space as delimitter. we can split the string using space and the resulting array can be iterated over to find the sum. Here s the code."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"C# Code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/**  *   */ package test;  import java.util.HashMap; import java.util.List;  /**  * @author amal  *   */ public class StringTest {     public static void main(String args[]) {   String str = \"PST456DA85M2A!!23++46\";   char str1[] = str.toCharArray();   int count = 0;   StringBuffer str2 = new StringBuffer();   for (char c : str1) {    int ascival = (int) c;    if (57 >= ascival && ascival >= 48 && !(ascival > 57)      && !(ascival < 48)) {     str2.append(c);    }     else {     if (str2 != null && str2.length() > 0) {      count = count + Integer.valueOf(str2.toString());      str2 = new StringBuffer();      }     }    }   // for last number   if (str2 != null && str2.length() > 0) {    count = count + Integer.valueOf(str2.toString());    str2 = null;   }   System.out.println(count);  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/** \n *  \n */ \npackage test; \n \nimport java.util.HashMap; \nimport java.util.List; \n \n/** \n * @author amal \n *  \n */ \npublic class StringTest { \n \n  \n public static void main(String args[]) { \n  String str = \"PST456DA85M2A!!23++46\"; \n  char str1[] = str.toCharArray(); \n  int count = 0; \n  StringBuffer str2 = new StringBuffer(); \n  for (char c : str1) { \n   int ascival = (int) c; \n   if (57 >= ascival && ascival >= 48 && !(ascival > 57) \n     && !(ascival < 48)) { \n    str2.append(c); \n   } \n \n   else { \n    if (str2 != null && str2.length() > 0) { \n     count = count + Integer.valueOf(str2.toString()); \n     str2 = new StringBuffer(); \n \n    } \n \n   } \n \n  } \n  // for last number \n  if (str2 != null && str2.length() > 0) { \n   count = count + Integer.valueOf(str2.toString()); \n   str2 = null; \n  } \n  System.out.println(count); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static int sumCharArray(char[] charArray) { \n   \n  int sum = 0, num = 0; \n   \n  for( int i = 0; i < charArray.length; i++ ) { \n   if( Character.isDigit( charArray[i] ) ) { \n    num = num * 10 + ( charArray[i] - '0' ); \n    if( charArray.length - i == 1 ) { \n     sum += num; \n    } \n   } \n   else { \n    if( num > 0 ) { \n     sum += num; \n     num = 0; \n    } \n   } \n  } \n  return sum; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use regex:  char[] c = new char[]{123dsd5455cf!!56}; String str = c.toString(); String newStr = str.replaceAll(\"[^0-9]\", \" \"); String[] out = newStr.split(\" \"); int sum = 0; for(int i = 0 ; i < out.length() ; i++){    sum += Integer.parseInt(out[i]); } System.Out.println(sum);  Works in O(n) time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class SumOfDigit { \n public static void main(String[] args){ \n  String str=\"PST456DA85M2A!!23++46\"; \n  String temp=\"\"; \n  int pos=0,sum=0; \n  boolean bFlag=false; \n  for(int i=0;i='0' && str.charAt(i)<='9'){ \n    if(bFlag==true){ \n     if((pos+1)==i){ \n      temp=temp+str.charAt(i);  \n      pos=i; \n     } \n    } \n    else{ \n     temp=\"\"; \n     temp=temp+str.charAt(i); \n     bFlag=true; \n     pos=i; \n    } \n   } \n   else{ \n    if(temp !=\"\"){ \n     sum=sum+Integer.valueOf(temp); \n     bFlag=false; \n     temp=\"\"; \n    } \n   } \n  } \n  if(temp !=\"\"){ \n   sum=sum+Integer.valueOf(temp); \n   bFlag=false; \n   temp=\"\"; \n  } \n  System.out.println(\"sum :\"+sum); \n} \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class SumOfDigit { \n public static void main(String[] args){ \n  String str=\"PST456DA85M2A!!23++46\"; \n  String temp=\"\"; \n  int pos=0,sum=0; \n  boolean bFlag=false; \n  for(int i=0;i='0' && str.charAt(i)<='9'){ \n    if(bFlag==true){ \n     if((pos+1)==i){ \n      temp=temp+str.charAt(i);  \n      pos=i; \n     } \n    } \n    else{ \n     temp=\"\"; \n     temp=temp+str.charAt(i); \n     bFlag=true; \n     pos=i; \n    } \n   } \n   else{ \n    if(temp !=\"\"){ \n     sum=sum+Integer.valueOf(temp); \n     bFlag=false; \n     temp=\"\"; \n    } \n   } \n  } \n  if(temp !=\"\"){ \n   sum=sum+Integer.valueOf(temp); \n   bFlag=false; \n   temp=\"\"; \n  } \n  System.out.println(\"sum :\"+sum); \n} \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Traverse right to left. If its first digit, add to sum, if second in a row, multiply by 10 and add to sum, if third in a row, multiply by 100 and add to sum. Well and so on. If not digit proceed until next digit and repeat."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"use regular expression [0-9]* to match the string, add the groups together as int."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"int getTotalSum(char* pString) \n{ \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Here is  a java solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#include #include void sum(char *a) {  int sum=0,i=0,final=0;  while(a[i]!='\\0')   {    while(a[i]-'0'>=0 && a[i]-'0'<=9)    {     sum=sum *10+ (a[i]-'0');     i++;    }    final+=sum;    sum=0;    i++;   }   printf(\"%d\\n\",final);  } int main()  {   //char a[20]=\"1$% 21+-98!!!??>76\";               //Try for this input also   char a[50]=\"PST456DA85M2A!!23++46\";       //Input   sum(a);                                                             //Function call  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"pretty straightforward. only need to maintain two variables: sum =>  sum until last number. num => current num"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#include  \n#include  \n#include  \n#include  \n \nint main() \n{ \n    const char* digits = \"0123456789\"; \n    std::string source = \"PST456DA85M2A!!23++46\"; \n    int sum = 0; \n    for (std::string::size_type offset = 0; offset != std::string::npos;) \n    { \n        offset = source.find_first_of(digits, offset); \n \n        if (offset == std::string::npos) \n        { \n            break; \n        } \n \n        std::string:: size_type end = source.find_first_not_of(digits, offset); \n \n        std::string token = source.substr(offset, end - offset); \n \n        // Convert the string of digites to an integer \n        std::istringstream ist(token); \n        int temp; \n        ist >> temp; \n        sum += temp; \n \n        offset = end; \n    } \n \n    std::cout << sum << std::endl; \n \n    return 0; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4794712","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"43","title":"Write a program to remove duplicate elements from array.(Array contains elements in range 1...N). Algorithm must be O(N) in time and O(1) in space. Come up with as many test cases as you can.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"We will traverse array and will make a[abs(a[i])] negative if its +ve.. if a[a[i]] is already negative .. means no is repeated we will replace it with zero and so on .. o(n) ...  in next traversala we will remove all the zeros from the array and will make all -ve values  +ve .. o(n)  o(n)+o(n) =o(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"you cannot do it in O(1) space with O(N) time if there are more than one duplicated elements in the array. If there was one, i would just sum it up and get the difference from arithmetic series of 1..N"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* The question is find and delete duplicates in an array of size N with a max value N in time complexity O(N), and space O(1) The time complexity of this program is O(2n + n +n ) = O(4n) i.e. O(n). Space complexity = O(1).  Assuming the input array can store an element of value '2n'.  From the problem we know that the elements range 1 to n so we place elements in their corresponding positions."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Bloody hell. I'm not cut out for it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the problem stmt intends to convey that the solution should have linear time complexity. So if the length of the array is m ,m could be >> N (a relatively small number)  Let's define this frequency array F[1...N] that would hold the frequencies of the element k in the original array A. So e.g. if N = 5, and the original array is  [2,1,3,1,1,1,3,5,2,4], the frequency array F would be [4,2,2,1,1]. Observe that regardless of the size of the original array, the size of F would always be the same. So F would actually occupy constant space for any value of m.  The algo now  gets very simple. A single pass over the original array A  initialize the elements of F to zero for (i=1...N){   if( F[a[i]] == 0){       F[a[i]]++;    }else{ // if we have already encountered the *value* a[i] in an earlier iteration       a[i]=NULL;    } }  Run the above algo on [2,1,3,1,1,1,3,5,2,4]. At the end of the pass,the array become [2,1,3,null,null,null,null,5,null,4], which is what's the goal ..enjoy !!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@above wat absurd..!!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"visit cacktheinterview.org for more interview questions"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I don't know what is the problem if the array size is >N. If size of array is m for(i =1 to m){ a[a[i]]=a[i]; } when size of array is smaller than N than  for(i=1 to m){ a[a[i]%m]=a[i]; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If you need to preserve the order of numbers than we need to think more."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Visit coders-stop.blogspot.com/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@chenna laundiya hoshihaar hai ..... machak !!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int countVector = 0;  int length = 0;  for(int i = 0 ; i< 10 ; i++)  {   if((countVector & (1<   continue;   else   {    a[length++] = a[i];    countVector = countVector | 1<  }  }   for(int i = 0 ; i  cout< cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include   int main() {  int a[]={1,2,2,3,3,3,4,5,6,6,9};    int counter, lastIndex;  int length = sizeof(a)/sizeof(int);    // Set 0 for duplicates  for(counter=1,lastIndex=0;counter < length;counter++)  {   if(a[counter] == a[lastIndex])   {    a[counter] = 0;    continue;   }   lastIndex=counter;  }     // Print the whole array  for(counter=0,lastIndex=0;counter  printf(\"%d \", a[counter]);  printf(\"\\n\");    // Move the 0(s) to end of the list.  for(counter=1,lastIndex=0;counter {   printf(\"lastIndex=%d counter=%d\\n\",lastIndex,counter);   if(a[counter] == 0)   {    //Set the lastIndex for the firsttime.    if(lastIndex == 0)  lastIndex = counter;    continue;   }   if(lastIndex == 0) continue;      a[lastIndex]=a[counter];   a[counter]=0;   //For the first time lastIndex will be set above..   lastIndex = lastIndex+1;  }    for(counter=0,lastIndex=0;counter  printf(\"%d \", a[counter]);    getchar();  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void removeDups (int a[], int n) \n{ \n    for (int i = 0; i < n; i++) \n    { \n        if (a[i] != i) \n        { \n            if (a[a[i]] != a[i]) \n                swap (a[i], a[a[i]]); \n        } \n    } \n \n    for (int i = 0, j = 0; j < n; i++, j++) \n    { \n        while (a[j] != j) \n            j++; \n        a[i] = a[j]; \n    } \n    a[i] = '\\0'; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=21263687","download_status":"DOWNLOAD_DONE","votes":"10","answersCount":"59","title":"You are given an array of n integers which can contain integers from 1 to n only . Some elements can be repeated multiple times and some other elements can be absent from the array . Write a running code on paper which takes O(1) space apart from the input array and O(n) time to print which elements are not present in the array and the count of every element which is there in the array along with the element number .  NOTE: The array isn't necessarily  sorted.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"10","title":"First Let's see what all approaches we can take and then we check if it fits our requirement. 1. Brute Force: Select an element from 1 to N and check it frequency of occurrence. But this will be O(n2) and not O(n) . 2. XOR : but this technique won't work as question mentions an element can be repeated multiple times. so if element repeats 2 times or 4 times each time result of xor will be 0 so we cannot get the frequency of occurrences. 3. HashMap : We can create a HashMap in O(n) key will be elements and value will be their frequency of occurrence. But since we have to do it in O(1) space we cannot take this approach.  So we cannot opt for any of the above 3 approach. We have to check for some 4th approach.  Since we have range of numbers given to us we have to think in those lines. Array Index is from 0 to N-1 and range is from 1 to N. Can't we use the array as hash itself? where array \"Index-1\" represents the key (element) and value stored at index will represent the \"frequency of occurrence\".  But how will we take care that an element present at any index is not overwritten as this can cause problem? We can sort the array in that case value present at index i is I+1 itself.  What is the complexity of sorting the array? O(nlogn) if we opt for heap/merge/quick sort.  But since the range of element is given to us we can sort it in O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Alternative approach, encode fields which specify a normal value as positive, those that contain a count as negative, then proceed through the array. If the value we see is smaller than the index, simply decrement the field for the value (since we must already have removed any value there) if it is larger, then swap the value in that field currently with the current value and set the field value to -1, except if the field is already negative, in which case just decrement.  Afterwards, the array is filled with negative values which are the counts, so just pop a minus in front of them and voila.  It's a little hard to follow, so here's the code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"just store value as (val + count * N)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If you can generate a sequence of primes P(1) to P(n) you can create single number that will represent a digest of the data set (there are formulas out there like f(n)=n^2?n+41 that will do that for you). For example, you could use the prime sequence 3,5,7,11,13,17 to represent the set of numbers 1,2,3,4,5,6 where P(1)=3, P(2)=5, P(3)=7, P(4)=11, P(5)=13, P(6)=17.  Start with your digest as equaling 1 (call it D). Every time you see a 1, multiply it be P(1). Every time you see a 2, multiply it by P(2) etc... Thus if your sequence is: 1,2,4,5,1,1 the 'digest' is: D = P(1)*(2)*P(4)*P(5)*P(1)*P(1) or another wards D = 3 * 5 * 11 * 13 * 3 * 3  Then once you're done. Go through D and divide it with each P(n) in sequence and so long as you get a remainder 0 result you know there's another P(n) in there. In this example:  -Start dividing by 3, you will see that D divides by 3 exactly three times (hence the number 1 repeats exactly 3 times, print this information) -Then move onto the next prime 5 and you will see that D divides by 5 exactly once (so there is exactly one instance of 2 in the list, print this information) -Them move onto the next prime 7 and you will see that D divides by 7 zero times (so there are no 3's present in the list, print this information)  Continue doing this until the prime representing P(n) is reached. This entire process will require two passes through the data set, the initial construction of the digest D and the one more to print out the results. This solution will work so long as a number large enough to contain P(1)*(#occurrences of 1) ... * P(n) * P(1)*(#occurrences of n) can be allocated."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simple solution in java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution goes like this....  {8,1,9,2,5,1,1,1,1} can be treated as the test data.....  {58,11,9,2,15,1,1,11,11} would be the processed data....  The process goes as follows.... 8 - > add 10 to location 8 {8,1,9,2,5,1,1,11,1} 1 -> add 10 to location 1  {18,1,9,2,5,1,1,11,1} 9 -> add 10 to location 9 {18,1,9,2,5,1,1,11,11} 2 -> add 10 to location 2 {18,11,9,2,5,1,1,11,11} 5 -> add 10 to location 5 {18,11,9,2,15,1,1,11,11} 1 -> add 10 to location 1 {28,11,9,2,15,1,1,11,11} 1 -> add 10 to location 1 {38,11,9,2,15,1,1,11,11} 11 -> special process ( if element is > 10) compute the modulo and add 10 to that location...11 % 10 = 1 ...so add 10 to location 1 {48,11,9,2,15,1,1,11,11} 11 -> special process ( if element is > 10) compute the modulo and add 10 to that location...11 % 10 = 1 ...so add 10 to location 1 {58,11,9,2,15,1,1,11,11}   {58,11,9,2,15,1,1,11,11}  58 - yields 58 / 10 times 1 and the original value is 58 % 10 and so on for each value....Array values are not lost....  Note :  10 is size of the array + 1...in code we have used 20 as our array size"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void elements(int[] A) { \n        for (int i = 0; i < A.length; i++) { \n            while (A[i] != i + 1) { \n                int temp = A[A[i] - 1]; \n                if (temp == A[i]) { \n                    break; \n                } \n                A[A[i] - 1] = A[i]; \n                A[i] = temp; \n            } \n        } \n        System.out.println(\"Elements that don't exist in array A\"); \n        for (int i = 0; i < A.length; i++) { \n            if (A[i] != i + 1) { \n                System.out.println(i + 1); \n            } else { \n                A[i] = -1; \n            } \n        } \n \n \n        for (int i = 0; i < A.length; i++) { \n            if (A[i] > 0) { \n                A[A[i] - 1]--; \n            } \n        } \n        System.out.println(\"Elements that exist in array A and their frequency\"); \n \n        for (int i = 0; i < A.length; i++) { \n            if (A[i] < 0) { \n                System.out.println((i + 1) + \": \" + (-A[i])); \n            } \n \n        } \n \n \n    } \n \npublic static void main(String[] args) { \n        // TODO code application logic here \n        int[] A = {9,9,9,9,9,9,9,8,7,9,10}; \n        elements(A); \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I suspect this is impossible under strict definitions of O(1) space. There exist no sorting algorithms with worst-case parameters of O(n) time and O(1) space.  Any solution to this problem would allow you to do a linear time, constant space counting sort where the range_of_numbers <= length of array. If you could do that, you should publish a paper.   As noted in comments I've made on other answers (e.g. storing negative numbers or a number larger than len(N) in an element), all solutions thus far provided stretch the definition of O(1) space and in the general sense are O(N)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about that idea. If you encounter element on position i and it is not equal to i. Than you have to place value a[i] to position with index a[i] e.g a[a[i]] = a[i]. But if this position is already captured with right element you go forward. It is preproccessing made by O(n). The next cycle you just scan array, and if value of element with index i isn't equal to i it means that we haven't element with value i. Here is code of my solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is solution on sorted array. Very basic but it is working fine."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is solution on sorted array. Very basic but it is working fine."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution in c++ : we use the input array as a container for the counter. Elements i encoutered in the array is associated with a counter at position i-1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Clever, but I don't think the problem is fully defined. The size of the array is not specified as size N. If you were guaranteed values 1-n and an array specified as size n, then your solution would work. Still pretty clever."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"IS  the array sorted??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#include using namespace std; int main() {     int a[]={3,3,2,1,1};     cout<<\"repeated:\"<    for(int i=0;i<5;i++)     {        if((a[abs(a[i])-1]) > 0)        {          a[abs(a[i])-1]=- a[abs(a[i])-1];                 }        else        {          cout<       } } cout<<\"missing:\"<for(int i=0;i<5;i++) {     if(a[i]>0)     cout<} getchar(); return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"let's consider - 4,3,5,1,2,9,4,2,7,10 n = 10  start iterating the array like count sort with a slight modification that we add  n^i to i-th array entry for each occurrence of i in th array-  since n is 10 we will add 10^i so 4,3,5,1,2,9,4,2,7,10 will end up like - 4+10^1, 3+10^2+10^2, 5+10^3, 1+10^4+10^4, 2+10^5, 9+0, 4+10^7, 2+0, 7+10^9, 10+10^10  Now iterate the array from beginning dividing each entry by n^i, result will be the corresponding counts for integer i (0 will be for absent integers) - for index 1 - 4+10^1 mod 10 ^1 = 1 for index 2 - 3+10^2+10^2 mod 10^2 = 2 and so on  resultant array is - 1,2,1,2,1,0,1,0,1,1 1 is present once, 2 is present twice ...6 and 8 are missing"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"void process(unsigned long long *arr, int n) { \n        unsigned long long   cur, x, y; \n        int i; \n        for (i = 1; i <= n; i++) { \n                cur = *(arr + i -1); \n                y = cur % (unsigned long long)pow(n,i); \n                x = pow(n,y); \n                *(arr + y - 1) += x; \n        }    \n        for (i = 1; i <= n; i++) { \n                cur = *(arr + i - 1);  \n                *(arr + i - 1) = cur/pow(n,i); \n        }    \n        for (i = 1; i <=n ; i++) { \n                printf(\"%d repeated %llu times\\n\", i, *(arr+i-1)); \n        }    \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I used the following algo in my code which the interviewer accepted at once ....  1.Start traversing the array . Let there be n elements and array be a[]. 2.if a[a[i]-1] > 0 and a[i] >0 , then make a[a[i]-1] negative . This will help to keep track of absent nodes . 3.else if a[i]>0 and a[a[i]-1] <0 , subtract n from a[a[i]-1] . This will help to keep the count of multiple visited nodes. 4. else if a[i]<0 and a[i] >= -n , subtract n from a[-a[i]-1]. 5. else if a[i] < -n , find subtract n from a[ (-a[i])%n-1 ] . 6. Now traverse the list and if any a[idx] is positive , that means number idx+1 isn't present in the array . 7. If a[idx] is between -n to -1 , that means idx+1 has occured only one time . 8. else if a[idx] is less than -n , that means idx+1 has occured  ( int ) ( -a[idx]/n ) + 1 times .   P.S. I wasn't selected for the next round after telling this answer within 5 minutes ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Voted up cause the solution is almost correct :) Please see note from , he is pointing out a very important case handling."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Use hash map.  it takes o(n) time and o(1) space.  Correct me if i made mistake"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"A very simple approach :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"I think, here we will have to consider n, the upper limit as a constant and m as the input size. In such a case, we can have an auxiliary array of size n that maintains the count of numbers from 1 to n.  The problem can also be solved in O(n) time if the array is already sorted, but not sure if such an assumption can be made."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"This problem can be solved in O(1) space and O(n) time, iff the given array is sorted, which is not clear from the question."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16047668","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"66","title":"An array contains two sub- sorted arrays. Give an inplace algorithm to sort two sub arrays.  for ex:  I/P:   1 4 5 7 8 9 2 3 6 10 11 O/P:  1 2 3 4 5 6 7 8 9 10 11","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"I think this is a trick question for 2 reasons: 1) Whether the array is sub-sorted or not, an in-place quick sort can be done in O(nlogn) 2) So if we are really looking for a O(n) solution, then why wouldn't that solution be used in the \"merge\" step of a standard merge-sort, making the merge-sort an in-place algorithm (which it is obviously not) ? Therefore, I don't think it can be done in less than O(nlogn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public class sortInPlace { \n \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n  // TODO Auto-generated method stub \n  int arr[] = {1,3,5,6,2,4,7}; \n  sortArray(arr); \n } \n  \n public static void sortArray(int []a) \n { \n  int endOfFirstArray = 0,prevNum = -1; \n  if(a.length < 2) \n  { \n   return ; \n  } \n   \n  if(a.length == 2) \n  { \n   if ( a[0] > a[1]) { \n    int temp = a[1]; \n    a[1] = a[0]; \n    a[0] = temp; \n   } \n  } \n  prevNum = 0; \n  for (int i = 1; i < a.length ; i++ ) \n  { \n   if ( a[prevNum] > a[i]) \n   { \n    break; \n   } \n   prevNum++; \n  } \n   \n  int ptr2 = a.length -1 ,ptr1 = prevNum; \n  for (; ptr2 > ptr1 ; ) \n  { \n   if (a[ptr2] > a[ptr1]) \n   { \n    ptr2--; \n   } \n   else \n   { \n    int temp = a[ptr2]; \n    a[ptr2] = a[ptr1]; \n    a[ptr1] = temp; \n    int tempPtr2 = ptr2; \n    for (int j = tempPtr2 -1 ; j >=0 ; j--) \n    { \n     if (a[tempPtr2] < a[j] ) \n     { \n      temp = a[tempPtr2]; \n      a[tempPtr2] = a[j]; \n      a[j] = temp; \n     } \n     tempPtr2--; \n    } \n   } \n  } \n   \n  for (int i = 0 ; i < a.length ; i++) \n  { \n   System.out.println (a[i]); \n  }     \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"it is possible in O(n) and the idea is like Insertion Sort in case of array of increasing integers: find the first element in array that is smaller than its previous element. (start of the second sorted sub-array) swap this element with its previous one until it becomes bigger than its prev. continue on the next index on the second sub-array until the end."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Merging two sorted lists can be done in O(N) time.  The challenge here is doing it in place, which can be done in close to O(N) time.  Basically, you just need to buffer elements from the first list that aren't ready to be inserted into the final list.  Your intermediate lists will look like this:  FFF1111BBB222  F = element in final position 1 = element in 1st list B = element in buffered head portion of first list 2 = element in 1st list  Keep track of the offsets of the first 1, the first B, and the first 2.  When you do the normal merge step, if there are any Bs, grab them before you grab the 1s.  You can think of this like a circular array for 1s, or it might make more sense to just think of it as a scratch area to save off 1s for later processing.  Either interpretation leads to the same result.  One minor slowdown is that you can get a long run of 1s that are less than 2s, which builds up your buffer of Bs.  Once you get to a B that is less than a 2, you'll need to shift over all the other Bs one to the left to buffer the 1 that is displaced by the new F.  When there are no Bs and the lead 1 sorts ahead of the 2, then you simply turn the 1 into an F.  When there are no Bs and the lead 2 sorts ahead of the 1, then you put the 2 in 1's old place, turning it into an F, then put the 1 in the 2's old place, turning it into a B.  When there ARE Bs and the lead 2 sorts ahead of the lead B, then you replace the lead 1 with the lead 2 (turned into an F) and put the lead 1 in the 2's old place (turned into a B)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"May i know what is inplace algorithm.............?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Arrays;   public class SortSortedArrays {   public static void main(String[] args) {   int[] arr = {1, 4, 5, 7, 8, 9, 2, 3, 6, 10, 11 };      int left = 0;    int right = 0;   int prev = Integer.MIN_VALUE;   System.out.println(Arrays.toString(arr));      //first find the start of the next array.    for(int i = 0; i < arr.length; i++)   {    if( arr[i] < prev )    {     right = i;     break;    }    prev = arr[i];   }      //sort the array   while(left < right && right < arr.length)   {    if( arr[left] >= arr[right] )    {     //shift digits to bring the digit from right      shiftDigits(arr,left,right);     right++;    }    else    {     left++;    }   }   System.out.println(Arrays.toString(arr));  }    public static void shiftDigits(int[] arr, int left, int right)  {   int digit = arr[right];      while(right > left)   {    arr[right] = arr[--right];    }   arr[left] = digit;  }  }  Order is close to N when the original array is completely sorted. Worst case is N^2. This sorts in place no extra space necessary."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Reposting with formatting"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is my try.......... Is this in space algorithm.........?  import java.io.*; class Inplace {  public static void main(String q[])  {   DataInputStream dis=new DataInputStream(System.in);   int n1,n2,n,a[]=new int[20],i,j;   System.out.println(\"Enter the length \");      try   {    n2=Integer.parseInt(dis.readLine());    System.out.println(\"Enter the elements : \");    n1=n2;    for(i=0;i   {     a[i]=Integer.parseInt(dis.readLine());      if((i!=0)&&(a[i]    {      n1=i;           }    }        i=n1-1;j=n2-1;     while((i>=0)&&(j>=n1))    {     if(a[i]    {       j--    ;     }     else     {      int c=a[i],k;      for(k=i;k     a[k]=a[k+1];      a[k]=c;      i--;      j--;      n1--;     }    }     System.out.println(\"Sorted Numbers are\");    for(i=0;i   System.out.println(a[i]);   }   catch(IOException e)   {     System.out.println(e);   }   } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is my try....... Is this inspace algorithm.........? import java.io.*; class Inplace {  public static void main(String q[])  {   DataInputStream dis=new DataInputStream(System.in);   int n1,n2,n,a[]=new int[20],i,j;   System.out.println(\"Enter the length \");      try   {    n2=Integer.parseInt(dis.readLine());    System.out.println(\"Enter the elements : \");    n1=n2;    for(i=0;i   {     a[i]=Integer.parseInt(dis.readLine());      if((i!=0)&&(a[i]    {      n1=i;           }    }        i=n1-1;j=n2-1;     while((i>=0)&&(j>=n1))    {     if(a[i]    {       j--    ;     }     else     {      int c=a[i],k;      for(k=i;k     a[k]=a[k+1];      a[k]=c;      i--;      j--;      n1--;     }    }     System.out.println(\"Sorted Numbers are\");    for(i=0;i   System.out.println(a[i]);   }   catch(IOException e)   {     System.out.println(e);   }   } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i can think only about O(n^2) solution : for each  element   in  second sub array, find its place by binary search and evaluate amount of  elements of second sub array that should be copied there, i  mean  if i have 1 2 5 6 7 3 4, we will find place of 3 and 4 by one binary search, but it is still O(n^2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n \nvoid main(){ \n int arr[] = {1,4,5,7,8,9,2,3,6,10,11}, startIndex2dArray = 0; \n printf(\"Array before sorting: \");  \n for(int i=0; i<10; i++){ \n  printf(\"%d, \",arr[i]); \n } \n //Finding start index of 2nd array. \n for(int i=0; i<10; i++){ \n  if(arr[i] < arr[i+1]){ \n   startIndex2dArray++; \n  }else{ \n   startIndex2dArray++; break; \n  } \n } \n for(int j=0, k=0; j=j){ \n       arr[p] = arr[p-1]; p--; \n      } \n      arr[j] = temoElmnt; j++;k++; \n  } \n } \n printf(\"\\n\\nArray after sorting: \");  \n for(int i=0; i<10; i++){ \n  printf(\"%d, \",arr[i]); \n } \n    getch(); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"find the index where the trend shifts. now perform a merge sort with (0 to x-1) as one set and (x to n) as another set."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void SortTwoMergedArrays(int[] data)         {             int sIndex = 0;              for (int i = 0; i < data.Length; i++)             {                 if (data[i] > data[i + 1])                 {                     sIndex = i + 1;                     break;                 }             }              for (int i = 0; i < sIndex; i++)             {                 if (data[i] > data[sIndex])                 {                     int tmp = data[i];                     data[i] = data[sIndex];                     data[sIndex] = tmp;                      //then replace item in second array                     for (int t = sIndex; t < data.Length-1; t++)                     {                         if (data[t] > data[t + 1])                         {                             tmp = data[t];                             data[t] = data[t + 1];                             data[t + 1] = tmp;                         }                         else                             break;                     }                 }             }         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"doesnt it sound like last step of merge sort?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this is the last step of mergesort..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include using namespace std; int main() {int i; int a[]={1,4,5,7,8,9,2,3,6,10,11}; for(i=1;i<11;i++){ if(a[i-1]else   { int val=a[i];       for(int k=i-1;k>=0;k--)       if(a[k]>val)       {a[k+1]=a[k];}       else      {a[k+1]=val;break;}   } } for(int i=0;i<11;i++) cout<getch(); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class a { public static void main(String[] args) { int k=0; int a[]={1,3,5,7,9,2,4,6,8}; for(int i=1;iif(a[i-1]continue; else  { int v=a[i]; for(;kSystem.arraycopy(a,k,a,k+1,i-k); a[k]=v; k+=1; } for(int i=0;iSystem.out.println(a[i]); } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def msort(array): \n        if len(array) <=1: \n                return \n        left_index = 0 \n        right_index = 1 \n        while right_index < len(array): \n                if array[right_index] < array[right_index-1]: \n                        break \n                right_index += 1 \n        if right_index == len(array): \n                return \n        #merge the left and right part \n        while left_index < right_index and right_index < len(array): \n                if array[left_index] <= array[right_index]: \n                        left_index += 1 \n                else: \n                        tmp = array[right_index] \n                        #move elements [left_index,right_index) one step to right \n                        for i in range(right_index,left_index,-1): \n                                array[i] = array[i-1] \n                        array[left_index] = tmp \n                        left_index += 1 \n                        right_index += 1 \n        return"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void q4(int a[]) \n { int i; \n   \n  for (i=1;ij;k--) \n    {  \n     a[k]=a[k-1]; \n    } \n    a[j]=temp; i++; \n   }    \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Using Binary search approach to find a boundary: log(n) 2. Replace elements accordingly: n Result: n log(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Step1:-use binary search for find where the second sorted arrrey start assume it is kth position then Step2:-merge both arreys one is start from 0 to k-1 and second one start from k to n;  so our solution will take less time  as it take for merging..!!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have an approximately O(n) solution.  What you want to do is find the beginning of the second sub-array by starting at the end, and decrementing the reference index by 1 until either the current element is less than the element previous to it in the array, or if the reference index becomes 0 (in which case, the two sorted sub-arrays are already fully sorted).  We'll call the resulting index \"r\".  Then, set another index at the beginning of the array, we'll call that index \"l\".    Now, iterate the \"l\" pointer through the array.  Compare the value at a[l] with the value at a[r].  If a[l] is less than a[r], increment l.  Otherwise, swap the values at l and r, and then increment r.  When both l and r have incremented past the end of the array, the sorting is finished.  Java code looks like:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Not most efficient way, but a pretty simple one:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my take on the problem.   Logic:  a. We need to know the indexes of the two arrays.  b. Start merging from the end of two arrays.  c. Compare FirstArray[i] and SecondArray[j],"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Find the last element of both sorted sub arrays. 2. Let's say i=index of last element subarray1  j= index of last element subarray2. 3. while(j>=i) {     If(array[i] > array[j]) {         swap(array[i], array[j])         i--;     } else {         j--;     } }  4. Finally array will contain sorted list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Based on the selection sort principle.. we can perform sorting more efficiently & it's in-place too"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"randomized quick sort has expected time O(nlogn) and O(N^N) worst case,  which is also an inplace sort"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be done using heap sort with has the O(nlgn) The key is to build min heap here and keep on shrinking the array size from left which is the sorted in increasing order The condition that the min heap needs to follow is that the value of children is greater or equal to the parent and this can be considered as the loop invariant condition => loop invariant is the condition which needs to be satisfied in every loop inorder to sort the seq  here is the algo  1) create min heap - O(n) 2) for range starting from 0 to n-1; call min_heapify on Array[ i to n] which will push the minimum value to top and we can consider the heap from i+1 index in the next loop  there by building sorted array"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int[] merge_sorted(int a[], int b[]) {          int arr[] = new int[a.length+b.length];          int end_position = a.length+b.length -1;         int first_array = a.length -1;         int second_array = b.length -1;           while (end_position >= 0) {              if (first_array >= 0 && second_array >= 0)  {               arr[end_position--] = a[first_array] > b[second_array] ?                                    a[first_array--] : b[second_array--];     }              if (first_array >= 0 && second_array < 0) {                 arr[end_position--] = a[first_array--];             }              if (second_array >= 0 && first_array < 0) {                 arr[end_position--] = a[second_array--];             }         }          for (int i = 0; i < arr.length; i++) {             System.out.println(arr[i]);         }         return arr;     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n lgm) algo where m is the length of the shorter sorted array. Maintain two pointers beginning at each array. Compare the two current values and insert the out of place value in the other array using binary search."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is O(N) time algorithm. It's kinda hard to explain in words so I wrote a program. It may not seem O(N) because of so many loops but I guarantee that it's O(N). I have tested for given two inputs and some other special cases. You may try more others. If you have counter example then please let me know."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the c Code for above program It forst looks for the starting point of second array and then sorts it"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use second part of the array as min-heap. (second part of the array is min-heap and no need to initiate make_heap(a+n/2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This is how I did it:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"It sounds like it's essentially an in-place merge operation. The code below should do it in O(N^2) time, by doing a normal merge, but inserting the element in the correct position in the second array if it's out of position in the first.   There's a solution here: h2database.googlecode.com/svn/trunk/h2/src/tools/org/h2/dev/sort/InPlaceStableMergeSort.java that is O(N*log(N)) but it's not trivial."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Apply Insertion Sort."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Make one pointer point to the beginning of the 2nd sub-array and another pointer to the beginning of the first sub-array. Keep on comparing the values of these to pointers and change position if required. O(1) space O(n) time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"If the sub arrays are already sorted, just use pointers and iterate through them"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=18536687","download_status":"DOWNLOAD_DONE","votes":"-3","answersCount":"40","title":"You have an array of binary numbers as \"00001101000001010100000...\"... We need to find the First occurrence of 1 in this series.. using binary search.   we need to design an algorithm  of complexity less than O(n).. and we need to use binary search strictly..","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"I sincerely think it's much helpful to explain the algo than posting some code here."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Yes, I think you can use binary search to solve this problem.  let's say you have 100 0/1 in array. then convert binary to decimal, say k. if k > 1.  then convert first 50 to decimal, check if it is >1.  if it is 0, then convert 51~75  and go on....  you will find first 1 in lgn complexity."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"This is a trick question, as it cannot be done in less than O(N).  Proof: Suppose we have an array of all zeros. Obviously we would have to check ALL the elements (and it doesn't matter in which order we do it) to know that there is no \"1\" element.   Now suppose we put \"1\" element in the last item we checked in the previous part, and run the algorithm again. It would still need N steps to find the \"1\" we inserted, since we already know that the item that contains \"1\" is the last one to be checked.  So we just prooved there is a case that takes O(N) to find the first \"1\".  This means I proved that he problem is O(N) in the worst case."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Edit: Here's some explanation for Jack:  As indicated by the question, we are required to find the answer in O(N) or better time. Thus, sorting is not an option since it takes O(nlogn) time for any comparison based sorting algorithm. Finally, the question hinted to use a binary search meaning to cut things in halves and try to find the first occurring \"1\".   Typically, a binary search starts by looking at the middle of an array (or the root if it's a binary search tree), and if the middle (or root) is smaller than the item we are looking for, we go right else we go left. By going either direction, we effectively skipped half of the original array (or tree). This operation is O(logn) which is better than O(N).  However, the input is not sorted and so not all items on the left of the middle is smaller than the middle. This means, not all zeros are on the left side of the middle and not all ones are on the right side. This means, without sorting, the worse case is O(N).  Since the question insist on using \"binary search\", we can try to skip half of the list at a time until we hit a \"1\" that is on the left most side.   Here's my code in Python (now with comments):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"At a high level the code should look like this, ofcourse you need to check the boundary case and overflows."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"#include  \nusing namespace std; \n \nint search(int *list, int start, int end) \n{ \n if(start > end) return -1; \n int middle = (start+end)/2; \n int nRet = -1; \n nRet = search(list, start, middle-1); \n if(nRet != -1) return nRet; \n if(list[middle] == 1) return middle; \n nRet = search(list, middle+1, end); \n if(nRet != -1) return nRet; \n} \n \nvoid main() \n{ \n int list[5]={1,0,1,0,0}; \n int ret = search(list, 0, sizeof(list)/sizeof(int)-1); \n \n if(ret == -1) cout<<\"Element Not Found\"<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"findOne(int arr[], int start, int end) \n { \n   if(start == end) \n   if(arr[start] == 1) \n   return start \n return -1; \n \n  t =   findOne(arr, start, mid); \n    if(t != -1) \n return t; \n \n return findOne(arr, mid+1, end); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can somebody explain it for me ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The above code looks to me is assuming the array is sorted, and it is the general case binary search, it will not work for this case."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int[] a = new int[10] { 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 };             int i;             int length = a.Length-1;             for (i = 0; i < a.Length/2; i++)             {                 if (a[i]==1)                 {                     break;                 }                 else                 {                     if (a[i]!=a[length])                     {                         i = length;                         break;                      }                 }                 length--;             }             Console.WriteLine(i);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Main { \n    public static void main(Strings args[]) { \n        int[] input = {0,0,0,1,0,0,0,01,1,1}; \n        OccurenceOf1.getOccurence(input, 0, input.length - 1); \n    } \n} \n \npublic class OccurenceOf1 { \n    public static boolean getOccurence(int[] inputArray, int start, int end) { \n       int middle = (start + end) /2;  \n       if(inputArray == null  || inputArray.length == 0) { \n            System.err.println(\"Empty Array\"); \n            return false; \n        } \n        else if(middle == 0 && inputArray[middle] != 1) { \n            return false; \n        } \n        else if(middle == input.length - 1 && inputArray[middle] != 1) { \n             return false; \n        } \n        else if(inputArray[middle] == 1 && inputArray[middle - 1] !=  1) { \n            System.out.println(\"First Occurence of 1 is \" + middle); \n            return true; \n        } \n        else if(getOccurence(inputArray, start, middle)) { \n            return true; \n        } \n        else if(getOccurence(inputArray, middle, end)) { \n              return true; \n        } \n        else return false; \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If bit vector represented as"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void bsearch(int item,int *a,int f,int l) {   if(f<=l) {  int k=(f+l)/2;      bsearch(item,a,f,k-1);  if(*(a+k)==item)  {   if(g==-1)   g=k;  }  bsearch(item,a,k+1,l);    } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can apply binary search on this. here is my example  if the given array is \"000011010000\" First step, middle = (start + end)/2 = 6, then we compare \"000001\" with \"000011\" which is the first 6 digits from the given array. \"000011\" is 3 in decimal and > \"000001\" = 1. So, we need to search in the first part, which is start = 0, and end = middle = 6; Second step,  middle = 3, and we get \"000\" from array. \"000\" < \"001\". The target is shorten to digit 3 to 6 Third step, middle =  5, and we get \"00001\" is 1, we are done."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void binarySearch_arr(int a[],int start, int end,int* res) \n{ \n if(start >= end) \n  return; \n \n if(a[start] == 1) \n  *res =  start; \n int mid =  (start+end)/2; \n binarySearch_arr(a,start,mid,res); \n if(a[mid] == 1) \n  *res = mid; \n binarySearch_arr(a,mid+1,end,res); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You guys are morons. How do you do binary search on an array which is not sorted?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"C# solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming bitwise operators can be used, could this not be done easily using a slightly modified binary search? I'm short on time at the moment, so I'll just describe the algorithm.  Implement standard binary search, then modify the branch test as follows:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Wrong question.  Binary search is applicable only for the sorted array.  Nothing better than linear search when array is not sorted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can tweak the merge sort to do binary search"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include int bsearch(char a[],int low,int high) {     int mid,index;     mid=low+(high-low)/2 ;     printf(\"%d%d\\n\",low,high) ;      if(low>high||low==high && a[low]=='0')     return -1 ;      index=bsearch(a,low,mid-1) ;     if(index!=-1)     return index ;      if(a[mid]=='1')     return mid ;      return bsearch(a,mid+1,high) ; }  void main() {     char s[100] ;     int i=0;     printf(\"enter the string\\n\") ;   gets(s) ;     fflush(stdin) ;     while(s[i++]!='\\0') ;      printf(\"%d\\n\",i) ;     printf(\"at %d index first occurance of 1\",bsearch(s,0,i-1)) ; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do a left favored binary search for \"1\" and keep shrinking the window of search till you get you get the same index or you can't find any more ones"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do a left favored binary search for \"1\" and keep shrinking the window of search till you can't find and more 1s or search index of 1 remains same"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"since the numbers are 0s and 1s you can treat them as binary and stuff them into an int (so the first 32 elements form an integer, the next 32 another integer) and at the end you`ll have an array of ints. Now you can do a binary search agains 0. If the first element of the aray is greater than 0 then there's a one there. Split that byte into 16 bit integers and check the first half .. and so on until you find the one. Of course you need to track the displacement in the String."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"1. You can't use binary search here, cause array isn't sorted. 2. If your data is represented as  int[] arr = {0,0,0,0,1,1,0 ...}, you can't do better then O(n) time algorithm."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"// AUTHOR: AMAN JAIN \n#include  \n#include  \n#include  \n#include  \n#include  \n#include  \n#include  \n#include  \n#include  \n#include  \n#include  \n#include  \n#include  \n#include  \n#include  \n#include  \n#include  \n#define sz(s) s.size() \nusing namespace std; \nint search(string& s,int low,int high){ \nif(low>high)return -1; \nint mid=low+(high-low)/2; \nint po=search(s,low,mid-1); \nif(po!=-1)return po; \nif(s[mid]=='1')return mid; \npo=search(s,mid+1,high); \nif(po!=-1)return po; \nreturn -1; \n} \n \nint main(){ \nstring s; \ncin>>s; \nint po=search(s,0,sz(s)-1); \nif(po!=-1)cout<<<\"\\n\"; \nelse printf(\"1 is not in string\\n\"); \n return 0; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=21037663","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"41","title":"Given an array of numbers, arrange it such that all the numbers less than a given key should come before the key and all the numbers greater than the key should come after it. For example: arr = { 0, -1, -2, 2, 0, 3, 5}, given key = 0  answer should be {-1, -2, 0, 0, 2, 3, 5} Order of elements that are smaller or greater than key does not matter i.e. sorting is not expected. So, {-1,-2, 0, 0, 5, 2, 3} is also a correct answer.  Time complexity should not be more than O(n).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Partition function of quick sort"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"It's a variant of classical Dutch National Flag problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This problem can be solved by using an approach of binary search: a. Every time the array is divided into 2 parts and then solve for the left half and the right half as: b. If the current element is less than the key then enter it into one array and if the current element is greater then enter it into second array. If both are equal then enter into the 2nd array. At last combine the or concatenate the two arrays .Thus the solution O(n). You can test it:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \nmain() { \n int a[] = { 0, -1, -2, 2, 0, 3, 5},n=7,i,j,k,temp; \n i = k = 0; \n j = n-1; \n while(i k) { \n   temp = a[i]; \n   a[i] = a[j]; \n   a[j] = temp; \n   j--; \n  } \n  else \n   i++; \n } \n printf(\"Result is : \\n\"); \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int[] returnArray(int[] arr, int key){ \n       \n         int count = 0; \n         int count1 = 0; \n         int[] arr1 = new int[arr.length]; \n       \n         for(int ij = 0 ; ij < arr.length; ij++){ \n            if (arr[ij] < key) \n               count++; \n            else if (arr[ij] == key) \n               count1++; \n         } \n          \n         arr1[(count + count1) - 1] = key; \n        \n         int p = 0, j = (count + count1) - 1, k = j + 1; \n        \n         for(int i = 0; i < arr.length; i++){ \n            if (arr[i] < key){ \n               arr1[p] = arr[i]; \n               p++; \n            } \n            else if (arr[i] > key){ \n               arr1[k] = arr[i]; \n               k++; \n            } \n            else if (arr[i] == key){ \n             if (count1 == 1) \n             { \n             } \n             else{ \n              arr1[j-1] = arr[i]; \n              count1--; \n             } \n               j--; \n            } \n             \n         } \n         return arr1; \n      }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class ArrageNumberByKey { \n  \n  \n public static int[] arrrageNumberByKey(int[] array , int key) \n { \n  int length = array.length; \n  int[] returnArray = new int[array.length]; \n   \n//  if(length%2 == 0) \n//  { \n//    \n//  } \n  int currentKeyIndex = -1; \n   \n  for (int i=0; i= key) \n   { \n    currentKeyIndex++; \n    returnArray[currentKeyIndex] =array[i]; \n   } \n  } \n   \n   \n  return returnArray; \n   \n } \n  \n \n  \n public static void switchPos(int[] arr, int idx1, int idx2) \n { \n  int tmp = arr[idx1]; \n  arr[idx1] = arr[idx2]; \n  arr[idx2] = tmp; \n } \n public static void main(String[] arg) \n { \n  int[] array = {-1,0,0,-3,3,4,5}; \n  int[] returnArray = arrrageNumberByKey(array, 0); \n  for (int i=0; i< returnArray.length ; i++) \n  { \n   System.out.println(\"value \"+returnArray[i]); \n  } \n   \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Arrays; \npublic class MainGeneric { \n  \n public static void main(String[] args) { \n   \n  int[] a = {2, 3, -1, 0, -2 , 1, 8, 10}; \n  int[] tobefilled = new int[a.length]; \n  int right = a.length-1 , left = 0; \n  int key = 8; \n  for(int i = 0 ; i < a.length ; i++) \n   if(a[i] < key){ \n    tobefilled[left] = a[i]; \n    left++; \n   }else if(a[i] > key){ \n    tobefilled[right] = a[i]; \n    right--; \n   } \n  tobefilled[left] = key; \n  System.out.println(Arrays.toString(tobefilled)); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int key = 0; \n arr = { 0, -1, -2, 2, 0, 3, 5}, \n count =0; \n  for(int i = 0 ; i < a.length ; i++) \n   if(a[i] < key){ \n    result[left] = a[i]; \n    left++; \n   }else if(a[i] > key){ \n    result[right] = a[i]; \n    right--; \n   } else  \n                        { \n           Count++; \n   } \n  for(int i = left ; i < count ; i++) \n  result[left] = key; \n  System.out.println(Arrays.toString(result));"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The solution is very simple assuming everyone is using an extra space scan the input array maintain 2 points left and right. Insert into the left index and increment if you find the element is less than the pivot and insert into the right index and decrement the right index."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A simple way may be: 1. In the first scan - Find all positions of given key. And number of elements less than key. Now you know  - (a) first position of the key in the result array (with key in the middle and lesser ones on left etc..)   - (b) last position of the key in the result array 2. Move all key elements to middle [from indexes (a) to (b)] 3. Now keep two pointers one always pointing to lesser ones and other to greater ones and swapping at every contradiction.  Each step is O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void keyArr(int[] arr,int key){ \n  int lowKeyIndex=-1,highKeyIndex=-1;/* LowKey and HighKey used to indicate minimum and maximum key positions in the array*/ \n  int maxIndex=arr.length-1/*Length of array to process*/,temp=0; \n  for(int index=0;(indexkey){  \n    temp=arr[index]; \n    arr[index]=arr[maxIndex]; \n    arr[maxIndex]=temp; \n    maxIndex--; \n   } \n   /* If Current element is equal to Key..Note down the key index in lowKeyIndex for first found key.. \n    * For the consequent keys, place the keys together and increment the highKeyIndex.. \n    * E.g. [-1,-8,0,2,0,3] Key=0 \n    * Current Index is 4..So current element is 0..lowKeyIndex=2 \n    * Output [-1,-8,0,0,2,3] highKeyIndex=3 */ \n   else if(arr[index]==key){ \n    if(lowKeyIndex!=-1){ \n     highKeyIndex=(highKeyIndex!=-1)?(highKeyIndex+1):(lowKeyIndex+1); \n     temp=arr[highKeyIndex]; \n     arr[highKeyIndex]=arr[index]; \n     arr[index]=temp; \n    } \n    else \n     lowKeyIndex=index; \n    index++; \n   } \n   else{ \n    /* If Current element is less than but found after key is found...Place the current element in lowkeyIndex position.. \n     * Place the element next to highKeyIndex to current postion and put key in the highKeyIndex+1 position \n     * Increment lowKeyIndex and highKeyIndex \n     * E.g. [-1,-8,0,0,0,2,4,-3] Key=0 \n     * Current Index is 7..So current element is -3..lowKeyIndex=2 highKeyIndex=4 \n     * Output [-1,-8,-3,0,0,0,2,4] lowKeyIndex=3 highKeyIndex=5 */ \n    if((index>lowKeyIndex)&&(lowKeyIndex!=-1)){ \n     temp=arr[index]; \n     if(maxIndex==-1)maxIndex=lowKeyIndex+1; \n     arr[index]=arr[highKeyIndex+1]; \n     arr[lowKeyIndex]=temp; \n     arr[highKeyIndex+1]=key; \n     lowKeyIndex+=1; \n     highKeyIndex+=1; \n     index++; \n    } \n   } \n \n  } \n  for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what about using a stack?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"quick sort partitioning wont work here....... a different approach is taken.... 1).take two pointers,one to starting(say i)  and other to ending(say j)... 2). just iterate through the array(say k), if you find element equal to key just increment(k++)... 3).if you find element 4).if you find element greater than key swap(a[k],a[j]) and  decrement j(j--). but note that in this case you must not increment k,as u have a new element at position k,which u have not traversed.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Runs in O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void Main(string[] args)         {             int[] a = new int[] { 0, 0, -1, -2, 2, 0, 3, 5, 0, 0, 0, 10, -1 };              ArrangeByKey(a, 0);         }          static void ArrangeByKey(int[] a, int key)         {             if (a == null)                 return;              int i = 0;             int j = a.Length - 1;              int i0 = -1;              while (i <= j)             {                 while (a[i] <= key)                 {                     if (a[i] == key && i0 == -1)                         i0 = i;                     else if (a[i] < key && i0 != -1)                     {                         Swap(a, i0, i);                         i0++;                     }                     i++;                 }                 while (a[j] > key)                 {                     j--;                 }                  if (i <= j)                 {                     Swap(a, i, j);                 }              }         }          static void Swap(int[] a, int i, int j)         {             int tmp = a[i];             a[i] = a[j];             a[j] = tmp;         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void Main(string[] args) \n        { \n            int[] a = new int[] { 0, 0, -1, -2, 2, 0, 3, 5, 0, 0, 0, 10, -1 }; \n \n            ArrangeByKey(a, 0); \n        } \n \n        static void ArrangeByKey(int[] a, int key) \n        { \n            if (a == null) \n                return; \n \n            int i = 0; \n            int j = a.Length - 1; \n \n            int i0 = -1; \n \n            while (i <= j) \n            { \n                while (a[i] <= key) \n                { \n                    if (a[i] == key && i0 == -1) \n                        i0 = i; \n                    else if (a[i] < key && i0 != -1) \n                    { \n                        Swap(a, i0, i); \n                        i0++; \n                    } \n                    i++; \n                } \n                while (a[j] > key) \n                { \n                    j--; \n                } \n \n                if (i <= j) \n                { \n                    Swap(a, i, j); \n                } \n \n            } \n        } \n \n        static void Swap(int[] a, int i, int j) \n        { \n            int tmp = a[i]; \n            a[i] = a[j]; \n            a[j] = tmp; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void Main(string[] args) \n        { \n            int[] a = new int[] { 0, 0, -1, -2, 2, 0, 3, 5, 0, 0, 0, 10, -1 }; \n \n            ArrangeByKey(a, 0); \n        } \n \n        static void ArrangeByKey(int[] a, int key) \n        { \n            if (a == null) \n                return; \n \n            int i = 0; \n            int j = a.Length - 1; \n \n            int i0 = -1; \n \n            while (i <= j) \n            { \n                while (a[i] <= key) \n                { \n                    if (a[i] == key && i0 == -1) \n                        i0 = i; \n                    else if (a[i] < key && i0 != -1) \n                    { \n                        Swap(a, i0, i); \n                        i0++; \n                    } \n                    i++; \n                } \n                while (a[j] > key) \n                { \n                    j--; \n                } \n \n                if (i <= j) \n                { \n                    Swap(a, i, j); \n                } \n \n            } \n        } \n \n        static void Swap(int[] a, int i, int j) \n        { \n            int tmp = a[i]; \n            a[i] = a[j]; \n            a[j] = tmp; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void Main(string[] args) \n        { \n            int[] a = new int[] { 0, 0, -1, -2, 2, 0, 3, 5, 0, 0, 0, 10, -1 }; \n \n            ArrangeByKey(a, 0); \n        } \n \n        static void ArrangeByKey(int[] a, int key) \n        { \n            if (a == null) \n                return; \n \n            int i = 0; \n            int j = a.Length - 1; \n \n            int i0 = -1; \n \n            while (i <= j) \n            { \n                while (a[i] <= key) \n                { \n                    if (a[i] == key && i0 == -1) \n                        i0 = i; \n                    else if (a[i] < key && i0 != -1) \n                    { \n                        Swap(a, i0, i); \n                        i0++; \n                    } \n                    i++; \n                } \n                while (a[j] > key) \n                { \n                    j--; \n                } \n \n                if (i <= j) \n                { \n                    Swap(a, i, j); \n                } \n \n            } \n        } \n \n        static void Swap(int[] a, int i, int j) \n        { \n            int tmp = a[i]; \n            a[i] = a[j]; \n            a[j] = tmp; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i came up this solution it's partially correct someone please help me out to correct the whole solution...   Test case sucess: test case 1: 0 ,-1,-2,2,0,3,5  n=7 key =0 test case 2: 1 ,7,5,8,3,9,5  n=7 key =5 test case 3: 1 ,6,2,4,3,7  n=6 key =3  Test case failure: test case 4: 1 ,7,5,8,3,9,2  n=7 key =5 test case 5: 1 ,6,2,4,3,2  n=6 key =3"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Do a linear scan and count how many items < key. Place the key in the right index in the array (maybe use a separate output array). Maintain 3 pointers - 1 at the 1st position of the array that's less than the key (unless key is the 1st), another index next position after the key and 3rd index on the key.  Do another linear scan and if element is < place at the position of 1st index & increment that index. Same if element > key, use 2nd index. If element equal, place it before or right after the 3rd index.  This will be O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"One line solution, O(nlogn) though. Still funny."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"sorry for a little messy code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"three ways sort"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#include  #include  int a[] = { 0, -1, -2, 2, 0, 3, 5}; int main() {     int key,i;     printf(\"enter the key:\");     scanf(\"%d\",&key);     arrange(key); } void arrange(int key) {     int n = sizeof(a)/sizeof(a[0]);     int i,j,left = 0,right= n-1;     int temp;     for(i=0;i    {         if(a[i]==key)         {             temp = a[right];             a[right] = a[i];             a[i] = temp;             break;         }     }     if(i>=n)     {         printf(\"key not found\\n\");         exit(0);     }     int x = a[right];     i = left - 1;     int k;     for(j=left;j    {         if(a[j]<=x)         {             i++;             k = a[i];             a[i] = a[j];             a[j] = k;         }     }     k = a[i+1];     a[i+1] = a[right];     a[right] = k;     printf(\"after arranging the array is:\\n\");     for(j=0;j    {         printf(\"%d\\t\",a[j]);     }     printf(\"\\n\"); }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15261663","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"42","title":"An array of size N is given. Array is sub divided into sub array of size K. Find maximum value of each sub array.  My ans- While traversing the array keep on adding values to max heap of size K and keeping a virtual window of size K on array. When element leaves the window then remove the leaving element from heap too and reheapify the heap. And max element of that window will be again on top in heap.  Any better approach?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Use doubly ended queue .time complexity - o(n).space complexity - o(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"A simple O(n) solution could be to get the max of first k elements of the array and push this max into an arraylist(call it maxs). Now start a loop from i=k and push max(maxs.last(),a[i]). Thsats it. Code below:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What about using an iterator It to go over the input array.Keep a new array of size k and for each k section in the input store the maximum value in the new new array(of size k). O(n) time; O(k) space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ok this is max element in sliding window  keep an aux array of size k  and copy first k elements of the entire frame into the aux array and find max so it ll be the max of first subarray  now for(i=k to n) include an element  if(arr[i]>max) max=arr[i]  print max  for consecutive subarrays"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Naive solution: find max of each subarray by scanning the subarray - total time O(kN) This can be improved by using the previous max when possible, for example: suppose max of A[0..10] is 100. Now we try to find new max for A[1..11]. So we can check if A[11] is more than 100 and if so then it's the max, otherwise if A[0] was not the max then the max is still 100. But the worst case will still be O(kN).  A different solution using a heap will give O(N log N) time which might be better, if k>lg N. You push the first k items (each item consists of the value and its position) into a max-heap. Now you peek the top of the heap to find the first max. For each subsequent item, push it into the heap, and peek at the top element. If the top is an item in the current window then it's the current max, otherwise pop it and peek at the new top element."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can you sort the array first? Now the max value of each sub array is at the (k-1) location"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"your procedure is also taking O(n^2)..since building a heap takes O(n) and you have to build the heap for O(n) elements of the array.So it will be n2....please correct me if I am wrong..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use a TreeSet to insert element into the Set (addition of element takes O(logn))   then when size of set is equal to K ,use the last() to retrieve the last element(which is the greatest element) and remove the first element in the set using remove(first())...-total complexity is Nlogn"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Would anyone post the code for this problem please."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include   int main() {  int array[12]={1,6,7,8,3,2,4,-6,4,13,1,17};  int K,max_value,temp,i=0;   scanf(\"%d\",&K);  temp = K;  max_value = array[0];  for( i=0; i<12;i++)  {   if(K > 0)   {    if(max_value < array[i+1])    {     max_value = array[i+1];    }        K--;   }   else   {    printf(\"Max value %d\\n\",max_value);    max_value = array[i+1];    K=temp;   }  }  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi cyrus,  wanted to confirm. if the array contains  9,8,7,6,5,4,3,1,0 and k=3 does that mean the sub arrays would be 9,8,7 8,7,6 7,6,5 6,5,4 5,4,3 4,3,2 3,2,1 2,1,0 ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I dont understand..the question read that the array of size n is subdivided in subarrays of size k..does that mean they must be sliding?? please explain... thanx in advance..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n \nusing namespace std; \n \nvoid find_max_in_sub_arrays(int* pIntArray, int nLength, int nLengtOfSubArray) \n{ \n  \n for(int i = 0; i < nLength; i++) \n { \n  int nStartIndexSubArray = i; \n  int nEndIndexSubArray = i + nLengtOfSubArray - 1; \n \n  int nMaxOfSubArray = pIntArray[nStartIndexSubArray];; \n  for(int j = nStartIndexSubArray + 1; j <= nEndIndexSubArray; j++) \n  { \n   if(pIntArray[j] > nMaxOfSubArray) \n   { \n    nMaxOfSubArray = pIntArray[j]; \n   } \n  } \n  for(int k = nStartIndexSubArray; k <= nEndIndexSubArray; k++) \n  { \n   cout << pIntArray[k] << \",\"; \n  } \n  cout << endl; \n  cout << \"max of this sub array = \" << nMaxOfSubArray << endl; \n \n  if(nEndIndexSubArray == nLength - 1) \n  { \n   break; \n  } \n } \n} \n \nint main() \n{ \n //int nArray[] = {8,1,4,9,6,3,5,2,7,0}; \n int nArray[] = {22,11,33,44,66,88,99,10,100}; \n int nLength = sizeof(nArray)/sizeof(int); \n \n for(int i = 0; i < nLength; i++) \n { \n  cout << nArray[i] << \",\"; \n } \n cout << endl; \n int nSizeOFSubArray = 3; \n \n find_max_in_sub_arrays(nArray, nLength, nSizeOFSubArray); \n \n _getch(); \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5698049099694080","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"37","title":"You are given an array with numbers - [11, 3, 11, 11, 3, 2, 0, -2, 2]  You are supposed to write a function that returns the number that appears \"odd\" number of times.   The solution is obviously using HashMap. But that takes O(n) to create the HashMap and O(n) to lookup. How can one eliminate the second O(n) yet keeping the HashMap?  Hint: Do you really need to count frequency of occurrence of each digit?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"You can do this using only one HashSet. Add new element to HashSet if its not already in the HashSet - else, remove it from the HashSet. This will make sure by the end of the iteration - the HashSet will only have the odd* occurring elements. Accessing elements in a HashSet is O(1) complexity. The overall time-complexity is O(n) for the linear traversal of the array elements."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this: (1)use two HashSets instead of one HashMap, one for those numbers occurred odd times so far, let's call it oddSet, while the other for those occurred even times being evenSet. (2)iterate to next number, if it has been in oddSet, we remove it from oddSet and add it to evenSet, otherwise we add it into oddSet and remove it from evenSet. (3)finally, those numbers that occurred odd times are all in oddSet."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"XOR  works when there is exactly one number that occurs odd number of times and also there should not be any 0 in the array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why not doing it like sql?  You can use group by the same number with count. Then return the number that has odd count? of course, if this is an interview, they probably won't let you use the easy and best way to do it unless you interview for microsoft.  Lambdas in C# str.GroupBy(n => n).Select(s => new {num = s.Key, count = s.Count()}).Where(g => (g.count %2) != 0);  you can use Quaere  in Java."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include    int getOddOccurrence(int ar[], int ar_size) {      int i;      int res = 0;       for (i=0; i < ar_size; i++)              res = res ^ ar[i];             return res; }   /* Diver function to test above function */ int main() {      int ar[] = {2, 3, 5, 4, 5, 2, 4, 3, 5, 2, 4, 4, 2};      int n = sizeof(ar)/sizeof(ar[0]);      printf(\"%d\", getOddOccurrence(ar, n));      return 0; }   But it works only for +ve integers"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Find oddnumber in array public Set getListOfOddNumbers(int[] number) {  Set oddNumbersSet = new HashSet (number.length);  if(number.length<0 || number==null)  {   return oddNumbersSet;  }    int i;  //Iterate each element in the array  for(i=0;i     if(oddNumbersSet.contains(number[i]))   {    oddNumbersSet.remove(number[i]);    }   else   {    oddNumbersSet.add(number[i]);   }  }  return oddNumbersSet;   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Find oddnumber in array \npublic Set getListOfOddNumbers(int[] number) \n{ \n Set oddNumbersSet = new HashSet (number.length); \n if(number.length<0 || number==null) \n { \n  return oddNumbersSet; \n } \n  \n int i; \n //Iterate each element in the array \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Find oddnumber in array \npublic Set getListOfOddNumbers(int[] number) \n \n Set oddNumbersSet = new HashSet (number.length); \n if(number.length<0 || number==null) \n  \n  return oddNumbersSet; \n  \n  \n int i; \n //Iterate each element in the array \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Find oddnumber in array \npublic Set getListOfOddNumbers(int[] number) \n \n Set oddNumbersSet = new HashSet (number.length); \n if(number.length<0 || number==null) \n  \n  return oddNumbersSet; \n  \n  \n int i; \n //Iterate each element in the array \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Find oddnumber in array \npublic Set getListOfOddNumbers(int[] number) \n \n Set oddNumbersSet = new HashSet (number.length); \n if(number.length<0 || number==null) \n  \n  return oddNumbersSet; \n  \n  \n int i; \n //Iterate each element in the array \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Find oddnumber in array \npublic Set getListOfOddNumbers(int[] number) \n \n Set oddNumbersSet = new HashSet (number.length); \n if(number.length<0 || number==null) \n  \n  return oddNumbersSet; \n  \n  \n int i; \n //Iterate each element in the array \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Find oddnumber in array \npublic Set getListOfOddNumbers(int[] number) \n \n Set oddNumbersSet = new HashSet (number.length); \n if(number.length<0 || number==null) \n  \n  return oddNumbersSet; \n  \n  \n int i; \n //Iterate each element in the array \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Find oddnumber in array \npublic Set getListOfOddNumbers(int[] number) \n \n Set oddNumbersSet = new HashSet (number.length); \n if(number.length<0 || number==null) \n  \n  return oddNumbersSet; \n  \n  \n int i; \n //Iterate each element in the array \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"when you have a new number, just to search if it's already in the hashmap, 1) if it's in the hash map, delete it. 2) otherwise, add it to the hash map At the end, all the numbers in the hash map should have odd occurrences."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Use radix sort, complexity is O(n). Then scan the list again."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"If there is only one number which appears odd number of times you can  XOR all numbers and at the end you will get the 'odd' number. In you example there are multiple 'odd' numbers 11,0,-2 so you have to count them. To do that you can use HashMap or to save some space sort numbers and keep running counter."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4846025567109120","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"37","title":"Given a number in an array form, Come up with an algorithm to push all the zeros to the end. Expectation : O(n) solution","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"the original order/arrangement of zeroes is not conserved once they have been pushed to the end."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"void movezeros(int arr[],int n) {       int i,end=n-1;      for(i=0;i    {        if(arr[end]==0)  {   end--;   continue;  }  if(arr[i]==0)  {   arr[i]=arr[i]+arr[end];   arr[end]=arr[i]-arr[end];   arr[i]=arr[i]-arr[end];   i++;  }        } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"here my c++ solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void removeZeros(int arr[], int n) \n{ \n    int i, pos = 0; \n    //copy nonzero numbers to the front \n    for(i = 0; i < n; ++i){ \n        if(arr[i] != 0) arr[pos++] = arr[i]; \n    } \n    //fill tail with zeros \n    for(i = pos; i < n; ++i) arr[i] = 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If one of the array element contains say 10 or 300?? int[] arr = {10, 300, 20, 4}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This O(n) solution iterates over the array with two indexes. If an element is not 0, we copy it to the position of the first index (and advance both indexes), if it is a 0 then we only advance the second index, counting the 0s encountered. When the second index gets to the end, we will have filled up the non-zero digits at the beginning, so we just need to make sure to fill the remaining elements at the end with 0s."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args){ \n  int[] noArrayform = {0,2,0,1,4,5,6,7,0,1,2,3,4,5,0,0,1,4,0}; \n  int[] outputArray = new int[noArrayform.length]; \n  int loopCount = 0; \n  int outputLength = 0; \n \n   \n  //copy the non zero values to the new output array \n  while(loopCount"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would use partition idea in the quick sort. A pointer at the beginning and a pointer at the end. Whenever the beginning pointer encounters a zero, swap the first pointers value with the second one. Then while there is an immediate zero before the second pointer move the second pointer back. Do it while (first pointer < second pointer)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class PushZero { public static void main(String...v){   ArrayDeque num = new ArrayDeque<>();      int arr[] = {1,3,5,0,0,4,6,0};   for(int i=0;i   if(arr[i]==0){     num.addLast(arr[i]);    }    else{     num.addFirst(arr[i]);    }   }   System.out.println(num.size());   for(Iterator itr = num.iterator();itr.hasNext();)  {       System.out.println(itr.next());     } } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void pushZero(int *array, int length) { \n    int zerocount = 0; // var to hold the num of Zeros in the given string \n    //Loop through all the elements of the array \n     \n    for (int i = 0; i < length; i++) { \n        // if element = 0, do nothing, just increment the count \n        if (0 == array[i]) { \n         zerocount++; \n      continue; \n     } \n         \n        //if not, then based on the zerocount, swap the elements \n     if (0 != zerocount) { \n      array[i - zerocount] = array[i]; \n      array[i] = 0; \n     } // end if \n    } // end for \n} // end pushZero()"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can use Partition, which uses \"n - 1\" comparisons and at most \"n - 1\" swaps using a customized comparator which assumes \"0\" is the largest number. Comparator code follows:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/** * Manuel. * Assuming there are 13 integers. Btw: I think the complexity reamins O(n) although I  * have outer loop here. */ #include   void inline swap(int *a, int *b); void pushZeros(int (&arr)[13]); void printArr(int (&arr)[13]);  int main() { int size= 13;  int arr[13]={1,2,3,0,0,0,-3,-4,0,0,1,0,0};  printArr(arr);  std::cout<<\"After pushing the zeros\"<<'\\n';  pushZeros(arr); printArr(arr);   return -1;  }  void printArr(int (&arr)[13]) {  for(int i=0; i < 13 ; i++)  {   std::cout<<\" \"< } }   void pushZeros(int (&arr)[13]) {    int *ptr1= arr;  int *ptr2= arr+ 13 -1;       while(ptr1 < ptr2)  {   while(*ptr1!=0 ) ptr1++;   while(*ptr2==0)  ptr2--;   if(ptr1 < ptr2) swap(ptr1, ptr2);   else break;    ptr1++;   ptr2--;   }    }  void inline swap(int *a, int *b) {  int c= *a;  *a= *b;   *b= c;   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args)  {   int[] array={1,2,0,3,4,0,3};   int length = array.length;   int multiplier = (int)Math.pow(10, length-1);   int num = 0;   for(int i=0;i   num = num + multiplier*array[i];    if(array[i]!=0)     multiplier=multiplier/10;   }   System.out.println(num);    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(int[] array)  {    int length = array.length;   int multiplier = (int)Math.pow(10, length-1);   int num = 0;   for(int i=0;i {    num = num + multiplier*array[i];    if(array[i]!=0)   multiplier=multiplier/10;   }  System.out.println(num);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this is a variant of dutch national flag problem. The solution is simple and can be achieved in o(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  //WAP to shift all zeroes to the end of the array using namespace std;  void sift(int a[],int n) {      int i=0,j=n-1,t;      while(i     {                 while(a[j]==0)                 {                            j--;                 }                   while(a[i]!=0)                  {                  i++;                                    }                  if(i                 {                     t=a[i];                     a[i]=a[j];                     a[j]=t;                  }      }      cout<<\"\\nArray is now:\";      for(int k=0;k       cout<}                                                                               int main() {      int a[100],n;      cout<<\"\\nEnter the number of elements:\";      cin>>n;      for(int i=0;i      cin>>a[i];       sift(a,n);       getch();       return 0;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \nusing namespace std; \n \nvoid moveZeroToEnd( int * data,size_t size) \n{ \n    if(!size) return; \n    size_t lastNonZeroPosition=size-1; \n    while(lastNonZeroPosition&&(!data[lastNonZeroPosition])) lastNonZeroPosition-- ; \n \n    for(size_t i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"j = len(a)  for i in range(j):  while (a[j-1] ==0):   j = j-1  if i == j:   break  if a[i] == 0 and a[j-1] !=0:   temp = a[i]   a[i] = a[j-1]   a[j-1] = temp   j = j-1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// Given a number in an array form, Come up with an algorithm to push all the zeros to the end.  \n// Expectation: O(n) solution \n \n#include  \n \nvoid print(int *arr, size_t size) \n{ \n using namespace std; \n \n for (size_t i = 0; i < size; ++i) \n  cout << arr[i] << ' '; \n cout << endl; \n} \n \nvoid pushZeroToEnd(int *arr, size_t size) \n{ \n int *start = arr; \n int *end = arr + size - 1; \n \n while (start < end) \n { \n  // Find first zero \n  while (*start != 0) ++start; \n \n  // Find last not zero \n  while (*end == 0) --end; \n \n  // Swap \n  *start++ = *end; \n  *end-- = 0; \n } \n} \n \nint main() \n{ \n int arr[] = { 1, 3, 0, 0, 0, 2, 0, 5, 4, 0, 3, 9, 0, 8, 0, 0 }; \n \n size_t size = sizeof(arr) / sizeof(int); \n \n print(arr, size); \n pushZeroToEnd(arr, size); \n print(arr, size); \n \n std::cin.get(); \n \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) \n{ \n int[] input = new int[]{ 0,5,6,0,0,2,4,0}; \n int nzpos = 0; //non-zero-position \n        int DigitToPush = 0; \n for(int i = 0 ; i < input.length; i++) \n { \n  if(arr[i] == DigitToPush)  \n   continue; \n  else \n   input[nzpos++] = input[i]; \n } \n // by this time all nonzero are at correct place; now fill-out rest of zeroes \n for(int j = nzpoz; j < input.length() ; j++) \n {  \n  input[j] = DigitToPush; \n } \n \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void swap(int[] a) {  int i = 0;  int j = a.length() - 1;  //[1,2,0,3,0,5,6,0,8,0]  while(j>i) {   if(a[i] == 0) {    while(j>i) {     if(a[j] != 0) {      int temp = a[j];      a[j] = a[i];      a[i] = temp;      break;     }     j--;    }   }   i++;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void swap(int[] a) {  int i = 0;  int j = a.length() - 1;  //[1,2,0,3,0,5,6,0,8,0]  while(j>i) {   if(a[i] == 0) {    while(j>i) {     if(a[j] != 0) {      int temp = a[j];      a[j] = a[i];      a[i] = temp;      break;     }     j--;    }   }   i++;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void swap(int[] a) {  int i = 0;  int j = a.length() - 1;  //[1,2,0,3,0,5,6,0,8,0]  while(j>i) {   if(a[i] == 0) {    while(j>i) {     if(a[j] != 0) {      int temp = a[j];      a[j] = a[i];      a[i] = temp;      break;     }     j--;    }   }   i++;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void swap(int[] a) {  int i = 0;  int j = a.length() - 1;  //[1,2,0,3,0,5,6,0,8,0]  while(j>i) {   if(a[i] == 0) {    while(j>i) {     if(a[j] != 0) {      int temp = a[j];      a[j] = a[i];      a[i] = temp;      break;     }     j--;    }   }   i++;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do a naive quiqsort implementation"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void PushZereosToEnd(int* arr,int len) {  int posZero = -1;   for(int i = 0; i < len; i++)  {   if(arr[i] == 0 && posZero == -1) //this is the zero index fisrt time    posZero = i;    else if(arr[i] != 0 && posZero != -1) //need to swap   {    int temp = arr[i];    arr[i] = arr[posZero];    arr[posZero] = temp;    posZero++;   }  }   for(int i = 0; i < len; i++)   std::cout<}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int size = (sizeof(arr) / sizeof(int) ) - 1;   for(int i = size,  j = size; i >=0 ;  i--){        if(a[i] == 0){            for(int k = i; k != j; k++){                a[k] = a[k+1];            }            a[j] = 0;            j--;        }    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void zeromove(int *a, int len) \n{ \n        int zero_start = 0; \n        int nonzero_pos = 0; \n \n        while(nonzero_pos < len) { \n                if (a[zero_start]) { \n                        zero_start++; \n                        nonzero_pos++; \n                } else if (!a[nonzero_pos]) { \n                        nonzero_pos++; \n                } else { \n                        swap(a[zero_start++], a[nonzero_pos++]); \n                } \n        } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"void moveZero(int a[]) {  int arrSize = sizeof(a)/sizeof(int);  int end = arrSize - 1;   for (int i = 0; i < arrSize; i++)  {   if ( a[i] == 0 )   {    std::swap(a[i], a[end]);    end--;   }   if (i == end)    break;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"void moveZero(int a[]) {  int arrSize = sizeof(a)/sizeof(int);  int end = arrSize - 1;   for (int i = 0; i < arrSize; i++)  {   if ( a[i] == 0 )   {    std::swap(a[i], a[end]);    end--;   }   if (i == end)    break;  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14959975","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"43","title":"Given two arrays, A and B, both containing integers, find values that appear in both arrays and output them.   I knew the fastest answer to this, which is basically adding array A to a hashmap and then checking if that map contains each element of B, which is an O(n) operation, but uses memory in O(n) as well. The interviewer then asked if I could figure a way of doing this with a complexity of O(n) without using any extra memory, basically just O(1) for memory.   Is this possible? I could not think of a simple quick solution for this on the fly, but I imagine it is possible.  Here is the code I wrote during the interview.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"The best solution that is O(1) is the array of max int bits. If int is 32 bit that's 512MiB."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this, add a and b and quicksort and just travel from first to end. that's it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I don't think there is an soln with linear complexity for this question."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What do you mean \"find values that appear in both arrays and output them\"? what exactly \"values\" mean here. In your example,     int[] a = {1,2,3,4};   int[] b = {2,5,6,7,3,2};  What is the expected output? {2, 3} or {2, 2, 3}?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think you can use bit manipulation if the numbers in array is \"close\" to each other.  Build an bitmap for each array and set the bit to 1 if the number is exist.  Then use &. The bit remain 1 is the overlap bit. say I have {0.1,2,3} and {2.5.6,7} We Have bitmap 11110000 and 00100111  After & we get 00100000 which means 2 is overlapped.  This method is not suit for sparse array like{0.100000}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if sizeof(a) +sizeof(b) else use universal hash(linear probing) on to the array itself instead of  creating a temporary array to store the hash.( complexity may vary but avg would be O(n)).  It works even if the numbers are negative in the array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ask whether there is a high/low bound for arrays."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this can be solved by using a bit vector of size 2 power (sizeof(int)-3)   O(2 power (sizeof(int)-3)) = O(constant) = O(1) space"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"you can do it in 2nlogn+2n (assuming each array has n elements) => sorting each array takes 2 nlog n.  iterate through the array  takes 2n (like you would do when you merge two sorted arrays)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hw abt this?  Do radix sort on both the arrays. Then traverse both arrays simultaneously to find out common elements."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This is what i can think of sort both arrays keep two pointers one at start of both the arrays if(a[i]==b[j]) return else if(a[i]i++ else j++  The problem with this method is at sort step since i dont know if there is any sorting method which would sort in O(nlogn) time without using extra space. Quick sort takes O(n^2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-6","title":"In telephonic interview, there is enough time for 3 questions to be answered including code for an above average candidate."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13579663","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"47","title":"Q2. F2F Round-1, Amazon(Bangalore)  Given an array of integers having the property that first that array is strictly increasing then it is strictly decreasing, You have to search for a given number.  Constraint: Minimize the complexity","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"since the array is strictly increasing first then strictly decreasing, therefore for the increasing part of the array if, i+1=j then definitely a[i] we can use modified binary search to search the array.  consider the array int[] arr = new int[] {1,3,5,7,19,221,132,56,8,6,4,2,1,-3,-17};  here we need to find k such that, for three consecutive elements i, k, j, a[i] a[j]  step 1 :   so, first we need to find the ending of increasing part of the array, lets the end index of increasing part as k.  use a modified binary search to find k"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Find the maximum elements in array - O(logn)  Now if element  > max - Not found  Form two sorted array and do binary search.  Total time O(logn)+O(logx)+O(logn-x)~ OLog(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This question is same as searching in a rotated sorted array"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.iterate over array to find the max by comparing arr[i] and arr[i+1] where arr[i] >arr[i+1] 2.if key is greater than arr[i] then search in upper index  of array 3.else search in lower index"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.iterate over array to find the max by comparing arr[i] and arr[i+1] where arr[i] >arr[i+1] 2.if key is greater than arr[i] then search in upper index  of array 3.else search in lower index"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"find out the critical point and then recursively search in both part"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"find out the critical point and apply binary search"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we can reduce the complexity to O(logn) by finding our the highest number also by using binary search..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"two points at a time first and the last  step 1:if(arr[start+i]==k || arr[end-i]==k) found k; else recurse(arr,start+i,end-i)  O(lgn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"two points at a time first and the last  for i 0 to len/2 step 1:if(arr[start+i]==k || arr[end-i]==k) found k; else recurse(arr,start+i,end-i)  O(lgn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int getMaxFromRotatedSortedList(int [] array){   int start = 0;   int end = array.length -1;   while(start<=end){    int mid = (start+end)/2;       if(array[mid]>array[mid+1]&&array[mid]>array[mid-1])     return mid ;     if(array[mid]     start = mid+1;      }else {      end = mid -1;     }    }    return -1 ;  }   public static int orderbinarySearch(int[]array, int start, int end,int key,boolean order){   while(start   int mid =(start+end)/2;    if(array[mid]==key)     return mid;    if(order){       if(key    end = mid;       else     start = mid +1;    }else{       if(key>array[mid])     end = mid;       else     start = mid +1;       }}   return -1;    }   public static void main(String [] args){   int [] newArray ={1,2,3,4,5,6,7,8,43,100,107,111,120,89,78,67,56,34,23,10};   int maxElementIndex = getMaxFromRotatedSortedList(newArray);   System.out.println(\"max element is\"+getMaxFromRotatedSortedList(newArray));   int c = orderbinarySearch(newArray,0,maxElementIndex,23,true);   boolean found = false;   if(c==-1){    c = orderbinarySearch(newArray,maxElementIndex,newArray.length-1,23,false);    if (c!=-1) found = true ;   }else{    found = true;   }     if(found){     System.out.println(\"the index of the key is\"+c);   }else {    System.out.println(\"key is not present \");   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int getMaxFromRotatedSortedList(int [] array){   int start = 0;   int end = array.length -1;   while(start<=end){    int mid = (start+end)/2;       if(array[mid]>array[mid+1]&&array[mid]>array[mid-1])     return mid ;     if(array[mid]     start = mid+1;      }else {      end = mid -1;     }    }    return -1 ;  }   public static int orderbinarySearch(int[]array, int start, int end,int key,boolean order){   while(start   int mid =(start+end)/2;    if(array[mid]==key)     return mid;    if(order){       if(key    end = mid;       else     start = mid +1;    }else{       if(key>array[mid])     end = mid;       else     start = mid +1;       }}   return -1;    }   public static void main(String [] args){   int [] newArray ={1,2,3,4,5,6,7,8,43,100,107,111,120,89,78,67,56,34,23,10};   int maxElementIndex = getMaxFromRotatedSortedList(newArray);   System.out.println(\"max element is\"+getMaxFromRotatedSortedList(newArray));   int c = orderbinarySearch(newArray,0,maxElementIndex,23,true);   boolean found = false;   if(c==-1){    c = orderbinarySearch(newArray,maxElementIndex,newArray.length-1,23,false);    if (c!=-1) found = true ;   }else{    found = true;   }     if(found){     System.out.println(\"the index of the key is\"+c);   }else {    System.out.println(\"key is not present \");   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the problem complexity is o(log n) the problem is divided into 2 parts. 1)finding maximum point 2)applying binary search on each side of maximum index. to find maximum point: divide the array into 3 parts using n/3 and 2n/3 as indexes. if(a[n/3]then maximum present in the a[n/3] to a[n]; else the maximum present in a[1] to a[2n/3] repeat the  process the complexity for this is o(log n) because the array size is decrimented each time by 1/3rd. now apply binary search on both sides of maximum element..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algo to find the point of inflection, once you get it do binary search in individual parts of the array, time complexity is O(log(n))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algo to find the point of inflection, once you get it do binary search in individual parts of the array, time complexity is O(log(n))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can be done in order of logn  first find point of inflection using a method similar to binary search then call binary search on the left list differently and call binary search on the right list differently"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can be done in order of logn  first find point of inflection using a method similar to binary search then call binary search on the left list differently and call binary search on the right list differently"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is a Bitonic Sequence. Let Mid = (start + end)/2, divides the array in two halves. In this case two cases could happen:  1. The Array is Exactly Increasing/Decreasing in first half and Exactly Decreasing/Increasing in the second half.  2. The Array is Decreasing/Increasing in one half and it is again Bitonic in the other half.  So basically we perform Binary search in the Monotonic sequence and perform Sequential search in the  Bitonic sequence.  Best Case Order : O(log n/2)) + O(log (log n/2)) i.e., Binary search in both halves (Case 1) Worst Case :  O(log n/2) + O(n/2) (Case 2: Which again can be checked recursively and search can be minimized)  Now Major part is to check if the Half is Strictly Increasing or decreasing :  isFirstHalfIncreasing = A[start]< A[mid-1] && A[mid-1][mid] isFirstHalfDecreasing = A[start] > A[mid-1] && A[mid-1] > A[mid] isSecondHalfIncreasing = A[mid] < A[mid+1] && A[mid+1] < A[end] isSecondHalfDecreasing = A[mid] > A[mid+1] && A[mid+1] > A[end]   Algorithm is:  Boolean Sequential_Search(A,start,end,element) {                              if(start == end ) return A[start]==element;            mid = (start+end)/2;            if(A[mid == element]) return true;            return ( isFirstHalfIncreasing OR isFirstHalfDecreasing                                            ?  Binary_Search(A,start,mid-1,element)                                            || Sequential_Search(A,start,mid-1,element) )                   OR (isSecondHalfDecreasing || isSecongHalfIncreasing                                           ? Binary_Search(A,mid+1,end,element)                                          || Sequential_Search(A,mid+1,end,element))  } //End of Sequential Search..  Boolean Binary_Search(A,start,end,element) {                if(start == end ) return A[start]==element;               mid = (start+end)/2;               if(A[mid == element]) return true;             return Binary_Search(A,start,mid-1,element)   ||                                                              Binary_Search(A,mid+1,end,element)   } // End of Binary Search..     Please Correct me if I am wrong. Also please if some one could caluclate the average case, that would be great"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Find the maximum elements in array - O(logn)  Now if element  > max - Not found  Form two sorted array and do binary search.  Total time O(logn)+O(logx)+O(logn-x)~ OLog(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it can be done in O(logn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it can be done in O(log n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class ArrayExample1 { \n \n int[] arr=new int[]{1,2,3,4,5,77,88,90,-56,-45,-23}; \n  \n public void showElements(){ \n  int no=0; \n  for(int i=0, j=1;j"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Store the complete array in hashtable..with numbers. By using Contains value check if the given number exists.. Storing elements in hashtable takes o(n).and..hashtable lookup is o(1)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My idea is same as everyone else: (1) Find the position of the maximum with modified binary search. Call this the \"climax\". (2) Perform binary search from beginning to climax (3) Perform binary search from climax to end  Each is O(logn) so altogether still O(logn). Note that I am also accommodating for the case when the climax is at the beginning or end of the array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #include   int main() {      int arr[] = {10,12,14,17,18,16,11,9,8};     int low = 0,         mid ,         high = lengthof(arr),  // length of array         low1,         low2,         high1,         high2;     int k ;      int temp_low = low,         temp_high = high;      int find = 0;      printf(\"please enter the number to search \\n\");     scanf(\"%d\",&k);      mid = (low + high)/2;      while( low < high)      {                  mid = (low + high) /2;         if ((arr[mid -1] < arr[mid]) && (arr[mid] < arr[mid + 1]))         {            low = mid + 1;         }         else         {            if ((arr[mid -1] > arr[mid]) && (arr[mid] > arr[mid + 1]))            {                 high = mid + 1;            }            else            {               if ((arr[mid -1 ] > arr[mid]) && (arr[mid] < arr[mid + 1]))               {                   high1 = mid;                   low1  = temp_low;                    high2 = temp_high;//This is for descedning order                   low2  = mid + 1;                   break;               }               else               {                   high2 = temp_high;                   low2  = mid + 1;                    high1 = mid;                   low1  = temp_low;                   break;               }             }          }      }  printf( \"high1 = %d  low1 = %d high2 = %d  low2 = %d\\n\", high1,low1, high2, low2);     /* check the number in ascending part*/    while( (low1 <= high1) && (find == 0))    {         mid = (low1 + high1)/2;       if(arr[mid] == k)       {         find = 1;         break;       }       else if (arr[mid] > k)       {         high1 = mid - 1;       }       else if(arr[mid] < k)       {         low1 = mid + 1;       }    }   /* check the num in desc part*/    while ((low2 <= high2) && (find == 0))    {        mid = (low2 + high2) / 2;         if (arr[mid] == k)        {          find = 1;          break;        }        else if (arr[mid] > k)        {           low2 = mid + 1;        }        else if (arr[mid] < k)        {           high2 = mid - 1;        }    }      if (find != 0)    {       printf(\"find postion is : %d \\n\", mid);    }    else    {       printf(\"%d is not present in the array\\n\", k);    }     return(0);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"How about this approach:  1. First find the highest element; If there are elements i,j such that a[i]>a[j], obviously 'i' marked the end of the first list. O(n); 2. Do a binary search on these elements. If it is found, return it. [O(logn)].  3. If it is not there, then search in the decreasing part; For this multiply the numbers 'i+1' till last element with -1 and also the key with -1; O(n) 4. Search using binary search for the key; O(log n); 5. If found, return else terminate with a message saying that the key is not found. So, overall complexity is O(n) + O(log n ) + O(n) + O(log n ) ; 6. Final complexity, is O( n );  If you feel that I need to include anything here, do let me know.  thanks, Pavan"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public static int MaxElementPosition(int[] input, int search)         {             int start = 0, end = input.Length - 1;             int maxPosition = 0;             while (true)             {                 int n = end - start + 1;                  // only 2 elements                 if (n <= 2)                 {                     if (input[end] > input[start])                     {                         maxPosition = end;                     }                     else                     {                         maxPosition = start;                     }                     break;                 }                  if (input[start + n / 3] <= input[start + 2 * n / 3])                 {                     start += n / 3;                     end = start + n - 1;                 }                 else                 {                     end = start + 2 * n / 3 - 1;                 }             }              return input[maxPosition];         }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5436643691462656","download_status":"DOWNLOAD_DONE","votes":"6","answersCount":"37","title":"Given an input array  a={1,2,3,6,2,8----}  product of all numbers=p=a[0]*a[1]*---a[n-1] where n is size of array output arrau should be b={p/a[0],p/a[1],p/a[2]-----}. you should not use division operator.Time complexity should be less than o(n2).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"10","title":"this one is simple you will need two array of same size solution as example: {a,b,c,d,e,f} generate {1,a,ab,abc,abcd,abcde} and {bcdef,cdef,def,ef,f,1} now do a dot product of the above two array you are done.. complexity O(3n)= O(n) the above array are easily calculable as they can be generated the first from the front of array and other from back with 1 multiplcation for each element."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Construct 2 arrays F(forward) and B(backward). F[i] = a[0]*a[1]*a[i-1] B[i]=a[i+1]*...a[n-1] F[0]=1; B[n-1]=1; Use dynamic programming to construct F and B b[i]=F[i]*B[i]."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"{a[0]*a[1]*a[2]*...a[n-1] - (a[1]*a[2]...a[n-1] (a[0]-1)), a[0]*a[1]*a[2]*...a[n-1] - (a[0]*a[2]...a[n-1] (a[1]-1)), a[0]*a[1]*a[2]*...a[n-1] - (a[0]*a[1]*a[3]...a[n-1] (a[2]-1)), ...} Complexity O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"static void ProductOfAllButItself() \n        { \n            const int size = 8; \n            var input = InitArray(size); \n \n            var output = new int[size]; \n \n            output[0] = 1; \n            for (int i = 1; i < input.Length; i++) \n            { \n                output[i] = input[i - 1]*output[i - 1]; \n            } \n \n            int product = 1; \n            for (int i = output.Length - 2; i >= 0; i--) \n            { \n                product *= input[i + 1]; \n                output[i] *= product; \n            } \n \n            OutputArray(output); \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"void count(int[] a, int N) \n{ \n int[] l = new int[N]; \n int[] r = new int[N]; \n l[0]=1;r[N-1]=1; \n for (int i = 1; i < N; i++) \n { \n  l[i] = l[i-1]*a[i-1]; \n  r[N-i-1] = r[N-i]*a[N-i]; \n } \n for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This is laziest solution  I am going to explain with an example: {a,b,c,d,e,f} then find this value====> abcdef and then find  { abcdef *(a^-1), abcdef* (b^-1), abcdef * (c^-1),abcdef * (d^-1), abcdef * (e^-1), abcdef * (f^-1)  }  Conclusion:  Time complexity: O(2n)=O(n).  Space complexity=O(1).  Note: i am not using division operator."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Guys I have solved this simple approach.  {a[0]*a[1]*a[2]*...a[n-1] - (a[1]*a[2]...a[n-1] (a[0]-1)), a[0]*a[1]*a[2]*...a[n-1] - (a[0]*a[2]...a[n-1] (a[1]-1)), a[0]*a[1]*a[2]*...a[n-1] - (a[0]*a[1]*a[3]...a[n-1] (a[2]-1)), ...} Complexity O(n)  P/A = P - BCDEF (A-1) P/B = P - ACDEF (B-1) P/C = P - ABDEF (C-1) P/D = P- ABCEF (D-1)   etc  where A = a[0] B = a[1].... P= ABCDEF...  Vote it if you understood it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How is the product 22?  Can you clarify the question further?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sorry product is 576"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"kkr.ashish's approach is correct!  Here is my code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about below approach.  arr[] = { a,b,c,d,e}; create another array res in such a way that res [] = {abcd,acde,abde,abce,abcd };  let me know if i am correct?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int main() {  int arr[]={1,2,3,4};  int size=sizeof(arr)/sizeof(arr[0]);  int *B=(int *)malloc(sizeof(int)*(size-1));  memset(B,0,sizeof(int)*(size-1));  int x=1;  for(int i=0;i {   B[i]=x;   x=x*arr[i];  }  x=1;  for(int i=size-1;i>=0;i--)  {   B[i]=x*B[i];   x=x*arr[i];  }  for(int i=0;i  cout< getchar();  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be done in O(nlogn) using divide and conquer The basic idea of the algorithm is as follows: 1. We recursively  solve two smaller arrays of size n/2 to get F and B 2. Compute f= a[0]*a[1]*??*a[n/2-1];  b = a[n/2]*a[n/2+1]*??*a[n-1] 3. Multiply each element in F by b, and multiply each element in B by f. Time complexity analysis: T(n) = 2T(n/2) + O(n) = O(nlogn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#python \ndef new_array(array, index): \n a = array \n i = index \n f = 1 \n b = 1 \n if i >=0: \n  # O(n) \n  for p in range(i): \n   f *= a[p] \n  for q in range(i+1, len(a)): \n   b *= a[q] \n print f, b \n return f * b \n \narr = [1,2,3,4,5] \nnew_arr = [] \n# O(n) \nfor m in range(len(arr)): \n new_arr.append(new_array(arr, m)) \nprint new_arr"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Time Complexity O(nlogn) #include int f(int *a,int i,int j){    int p=1,leftp=1,rightp=1;    int l;    for(l=i;l<=j;l++)     p*=a[l];    if(j==i){       a[i]=1;       return p;      }    int mid=i+(j-i)/2;    leftp=f(a,i,mid);    rightp=f(a,mid+1,j);    for(l=i;l<=mid;l++)     a[l]*=rightp;    for(l=mid+1;l<=j;l++)     a[l]*=leftp;    return p; } int main(){    int a[]={1,2,3,4,5,6,7,8};    int n=sizeof(a)/sizeof(a[0]),i;    int p=f(a,0,n-1);    printf(\"Product--%d\\n\",p);    for(i=0;i    printf(\"%d \",a[i]); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1 #include  \n  2 #include  \n  3 #include  \n  4 \n  5 int A[] = { 1, 2, 3, 4, 5, 6, 7 }; \n  6 int O[7]; \n  7 \n  8 int OutputArray(int* Array, int Element, int Prev) \n  9 { \n 10         if(Array[Element] == 0) \n 11                 memset(O, 0, sizeof(int)*7); \n 12         int Result = 1; \n 13         if(Element < 6) \n 14         { \n 15                 Result = OutputArray(Array, Element + 1, Prev * Array[Element]); \n 16                 O[Element] = Result * Prev; \n 17                 return Result * Array[Element]; \n 18         } \n 19         else if (Element == 6) \n 20         { \n 21                 O[6] = Prev; \n 22                 return A[6]; \n 23         } \n 24 \n 25         std::cout << \"error\" << std::endl; \n 26         return 1; \n 27 \n 28 \n 29 } \n 30 int main() \n 31 { \n 32         OutputArray(A, 0, 1); \n 33         for(int I = 0; I < 7; I++) \n 34         { \n 35                 std::cout << O[I] << std::endl; \n 36         } \n 37         return 0; \n 38 } \n 39"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package test; \n \npublic class ProductArray { \n \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n  int [] array = {4,2,5,1}; \n  int [] b = getArray(array); \n  for(int i = 0;i=0;i--){ \n   for(int j = array.length-1;j>=0;j--){ \n    if(i!=j){ \n     mult*=array[j]; \n    } \n   } \n  b[i] = mult;   \n  mult =1; \n  } \n   \n return b;  \n } \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13580661","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"39","title":"Q1. F2F Round 1 Amazon(Bangalore)  Given a character array as input. Array contains only three types of characters 'R', 'G' and 'B'. Sort the array such that all 'R's comes before 'G's and all 'G's comes before 'B's.  Constraint :- No extra space allowed(except O(1) space like variables) and minimize the time complexity. You can only traverse the array once.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"13","title":"en.wikipedia.org/wiki/Dutch_national_flag_problem"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"threeWayPartition(char data[], int size) \n{ \n   int p = 0; \n   int q = size-1; \n   int i ; \n \n  char t; \n        for ( i = 0; i <= q;) \n        { \n                if (data[i] == 'R') \n                { \n                      t = data[i]; \n                        data[i] = data[p]; \n                        data[p] = t; \n                        ++p; \n                        ++i; \n                } \n \n                else if (data[i] == 'G') \n                { \n                        t = data[i]; \n                        data[i] = data[q]; \n                        data[q] =t; \n                        --q; \n                } \n                else \n                { \n                        ++i; \n                } \n        } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Just maintain count of R, G, and B. And then overwrite whole array. Some thing like below"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"int main() {     int r,g,b,i; char x[] = {'r','r','g','g','b','r','r','r','g','g','b','b','b','g','g','r'} for (i = 0;r = 0,g=0,b=0; x[i] != '\\0' ;} {    if(x[i] == 'r')            r++;    else if(x[i] == 'g')         g++;    else        b++;                  } memset(x,'r',r); memset(x+r,'g',g); memset(x+r+g,'b',b); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void sortAnArrayInParticularOrder(char [] array){   int indexOfR = 0;   int indexOfB = array.length-1;       for(int i=0;i<=indexOfB;){        if(array[i]=='R'){         swap(i,indexOfR,array);         indexOfR ++;         i++;       } else if (array[i]=='B'){         swap(i,indexOfB,array);         indexOfB --;        }else{         i++;        }       }            for(char c:array){     System.out.println(c);    }       }   private static void swap(int i, int j, char[] array) {   char temp = array[i];   array[i]=array[j];   array[j]=temp;     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int begin=0; int end=n-1; while(begin{  if (A[begin]=='G')  {   temp=begin+1;   while(A[temp]=='G')    temp++;   if(temp==end)    return;   else   {    swap(A[temp], A[begin])   }     }  if(A[begin]=='B')  {   swap(A[begin],A[end])  }  if(A[begin]=='R')  {   begin++;  }   if(A[end]=='G')  {   temp=end-1;   while(A[temp]=='G')    temp--;   if(temp==begin)    return;   else   {    swap(A[temp], A[end])   }  }  if(A[end]=='R')  {   swap(A[end],A[begin])  }  if(A[end]=='B')  {   end--;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int begin=0; int end=n-1; while(begin{  if (A[begin]=='G')  {   temp=begin+1;   while(A[temp]=='G')    temp++;   if(temp==end)    return;   else   {    swap(A[temp], A[begin])   }     }  if(A[begin]=='B')  {   swap(A[begin],A[end])  }  if(A[begin]=='R')  {   begin++;  }   if(A[end]=='G')  {   temp=end-1;   while(A[temp]=='G')    temp--;   if(temp==begin)    return;   else   {    swap(A[temp], A[end])   }  }  if(A[end]=='R')  {   swap(A[end],A[begin])  }  if(A[end]=='B')  {   end--;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"3-way quick sort with G as pivot."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"3-way quick sort with G as pivot."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"That took longer than it should have.  C#  The 'trick' was that you can only traverse once, but you don't necessarily need to increment your enumerator."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void swap(char * to,char *from) {      char t = *to;      *to = *from;      *from = t; }  void arrange(char  str[] ) {     //if(!str) return ;    cout<<\"before :\"<<   int n = strlen(str);    int last[3]= {0,0,n-1};      for(int i=0;i   {       if(str[i] == 'R' )        {          swap(&str[last[0]],&str[i]);          ++last[0] ;       }       else if(str[i] == 'B' && i      {          swap(&str[i],&str[last[2]]);          --last[2];       }       else if(str[i] == 'G' )       {           last[1]=i ;         }       cout<<\"Iteration :\"<<<\" \"<   }         cout<<\"after :\"<<}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nusing namespace std; \n \nvoid swap(char *x, char *y) \n{ \n cout<<\"Entered swap\"; \n char temp; \n temp = *x; \n *x=*y; \n *y=temp; \n cout<<\"Finished swap\"; \n} \n \nint main() \n{ \n char a[]=\"RRRRGGGGBBBB\"; // Desired output RGBRGBRGBRGB \n int size = sizeof(a)/sizeof(a[0]); \n  \n int low =0; \n int mid =0; \n int high = size-2; \n cout<<<<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void rearrange(char *s) \n{ \n    int i; \n    int length = strlen(s); \n    int firstp=0; \n    int lastp=length-1; \n    int flag = 0; \n    if(length>1) \n    { \n        while (firstp = 0 && s[lastp] == 'B') \n            lastp--; \n        i=firstp; \n        while (i<=lastp)  \n        { \n            i = i < firstp? firstp: i; \n            if(s[i] == 'R') \n            { \n                s[i] = s[firstp]; \n                s[firstp] = 'R'; \n            } \n            else if (s[i] == 'B')  \n            { \n                s[i] = s[lastp]; \n                s[lastp] = 'B'; \n            } \n            else \n                i++; \n            while (firstp = 0 && s[lastp] == 'B') \n                lastp--; \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"keep a red pointer from start, and blue pointer from end. Move the red pointer forward until you fing a non R character. Move the blue pointer backwards until you find a non B character. Initialize a green character from the current red position and keep moving until you find R/B. if you find R/B swap them and increase/decrease the corresponding pointer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about an in-place Merge sort?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"low=0; \n    high=n;//size of array; \n    for(i=0;i='G') \n              swap(arr[i],arr[high--]); \n           else i++; \n               \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void threeWayPartition(int data[], int size, int low, int high) {   int p = -1;   int q = size;   for (int i = 0; i < q;) {     if (data[i] < low) {       swap(data[i], data[++p]);       ++i;     } else if (data[i] >= high) {       swap(data[i], data[--q]);     } else {       ++i;     }   } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  int main()  {  char data[] = \"BRBRBRBGRGRGRRGRGRGRBRBRBR\";  int size = sizeof(data)/sizeof(data[0]);  int index= 0;   int gFirstPosition;  int bFirstPosition;   int gVisit= 0;  int bVisit= 0;    printf(\"input:  %s\\n\", data);   while (index < size)  {   if (data[index] == 'R')   {    if (gVisit == 1 && bVisit == 1)    {     data[gFirstPosition]= 'R';     data[bFirstPosition]= 'G';     data[index]= 'B';     gFirstPosition++;     bFirstPosition++;    }    else if (gVisit == 1 && bVisit == 0)    {     data[gFirstPosition]= 'R';     data[index]= 'G';     gFirstPosition++;    }    else if (gVisit == 0 && bVisit == 1)    {     data[bFirstPosition]= 'R';     data[index]= 'B';     bFirstPosition++;    }     }   else if  (data[index] == 'G')   {    if (gVisit == 0)    {     gFirstPosition= index;     gVisit= 1;    }        if (bVisit == 1)    {     data[bFirstPosition]= 'G';     data[index]= 'B';     if (gFirstPosition > bFirstPosition)      gFirstPosition= bFirstPosition;      bFirstPosition++;    }       }   else if  (data[index] == 'B')   {    if (bVisit == 0)    {     bFirstPosition= index;     bVisit= 1;    }   }   index++;  }    printf(\"output: %s\\n\", data);   return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Arrays;   public class SortRGB {      public static void main(String[]args){   char[]arr={'R','G','B','R','B','R','R','B','R','G','B','B','B','R','R','G','B'};      sortRGB(arr,'G','G');   System.out.println(Arrays.toString(arr));  }   private static void sortRGB(char[] arr, char key1, char key2) {   int p=0;   int size=arr.length-1;   int q=size;   for(int i=0;i<=q;){    if(arr[i]>key1){          swap(arr,p,i);     p++;     i++;    }    else if(arr[i]         swap(arr,i,q);     q--;    }    else{     i++;    }   }     }   private static void swap(char[] arr, int p, int q) {   char temp=arr[p];   arr[p]=arr[q];   arr[q]=temp;     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n \nint main() \n{ \n char c[] = {'r','g','b','g','b','g','b','r','r','b','g','r','r','b','b','g','r'},temp; \n int r=0,g=0,b=0,i; \n for(i=0;i<(sizeof(c)/sizeof(c[0]));i++) { \n  if(c[i] == 'r') { \n   temp = c[r]; \n   c[r] = c[i]; \n   c[i] = temp; \n   r++; \n   g++; \n   b++; \n  } \n  else if(c[i] == 'g') { \n   temp = c[g]; \n   c[g] = c[i]; \n   c[i] = temp; \n   g++; \n   b++; \n  } \n  else if(c[i] == 'b') { \n   temp = c[b]; \n   c[b] = c[i]; \n   c[i] = temp; \n   b++; \n  } \n } \n for(i=0;i<(sizeof(c)/sizeof(c[0]));i++)  \n  printf(\"%c\",c[i]); \n printf(\"\\n\"); \n return 0;   \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"yup similar to sort 0,1,2 or dutch national flag algo."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"yup similar to sort 0,1,2 or dutch national flag algo."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"yup similar to sort 0,1,2 or dutch national flag algo."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14594731","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"39","title":"Given an array of integers. Print a pair whose sum is closest to zero?    Eg: Input: arr = {2 5 8 -7 2,9} Output:  => 8, -7","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"Sort the array. Initialize l = 0, r = size-1. In each iteration compare a[l]+a[r] with closest sum to 0 ( min_sum ) found so far and update the min_sum if required. If a[l]+a[r] < 0 => l++ else => r--"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sort the array and add first and last element.depending upon the sum,move from beginning or from end. If sum is less than 0,move from beginning and if sum is greater than 0,move from end.store the minimum difference from 0."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a = map(int,raw_input().split(\" \")) \nres = [None,None] \nlarge = float(\"inf\") \n \nfor i in xrange(len(a)-1): \n    for j in xrange(i+1,len(a)): \n        dist = abs(a[i]+a[j]) \n        if dist < large: \n            large = dist \n            res[0] = a[i] \n            res[1] = a[j] \n \nprint res"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"s = open(\"s.txt\") arr = s.read().split(' ') list = [int(x) for x in arr] sum = 100000; min = 100000 min_sum = 0 le = len(list) index1 = -1 index2 = -1 for i in range(le):      for j in range(i + 1, le):  sum = list[i] + list[j]         min_sum = abs(sum - 0)  if(min_sum < min):      min = min_sum      index1 = i      index2 = j  print list[index1], \" \",list[index2]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package client;  import java.util.ArrayList; import java.util.List;  public class MinimumSumPair {     public MinimumSumPair() {         super();     }      public static void main(String[] args) {         MinimumSumPair minimumSumPair = new MinimumSumPair();         int[]  a = {2,5,-7,8,4,6};         List l = minimumSum(a);         System.out.println(l.toString());     }     public static List minimumSum(int[] a){       int[] arr = a;       int sum = 0,minsum =Integer.MAX_VALUE;       int l=0,r=0;       for(int i = 0; i < a.length; i++){           for(int j = i+1; j < a.length; j++){             sum = a[i] + a[j];                            if(minsum > sum && sum >= 0){                 minsum = sum ;                 l=a[i];                 r=a[j];               }           }       }       List arrList = new ArrayList();       arrList.add(l);       arrList.add(r);       return arrList;     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def findMinAbsSum( array ): \n    best = ( float( \"inf\" ), float( \"inf\" ) ) \n     \n    for i in range( 0, len( array ) ) : \n        for j  in range( i + 1, len( array ) ) : \n            if array[i] + array[j] == 0: \n                return ( array[i], array[j] ) \n            if abs( array[i] + array[j] ) < abs( sum( best ) ) : \n                best = ( array[i], array[j] ) \n                 \n    return best \n     \nif __name__ == \"__main__\" : \n    print( findMinAbsSum( [2,5,8,-7,2,9] ) ) \n    print( findMinAbsSum( [2,5,8,-7,2,9,7] ) ) \n    print( findMinAbsSum( [] ) )"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Best-case: O(n) \npublic static void pair(final int[] array) { \n        int max1st = array[0]; \n        int max2nd = array[0]; \n        int min1st = array[0]; \n        int min2nd = array[0]; \n        boolean isAllNeg = true; \n        boolean isAllNatural = true; \n \n        for (int iter = 1; iter < array.length; iter++) { \n            final int currValue = array[iter]; \n \n            if (currValue < 0) { \n                isAllNatural = false; \n            } else { \n                isAllNeg = false; \n            } \n \n            if (currValue < min1st) { \n                min2nd = min1st; \n                min1st = currValue; \n            } else if ((min2nd == min1st) && (currValue < min2nd)) { \n                min2nd = currValue; \n            } \n \n            if (currValue >= max1st) { \n                max2nd = max1st; \n                max1st = currValue; \n            } else if ((max2nd == max1st) && (currValue > max2nd)) { \n                max2nd = currValue; \n            } \n        } \n \n        if (isAllNatural) { \n            System.out.println(min1st + \" \" + min2nd); \n \n            return; \n        } else if (isAllNeg) { \n            System.out.println(max1st + \" \" + max2nd); \n \n            return; \n        } else { \n            // Java's randomized quicksort, avg nlogn \n            Arrays.sort(array); \n \n            int leftIter = 0; \n            int rightIter = array.length - 1; \n \n            boolean modified = true; \n \n            while ((leftIter < rightIter) && modified) { \n                modified = false; \n \n                if ((array[leftIter] + array[rightIter]) == 0) { \n                    System.out.println(array[leftIter] + \" \" + \n                        array[rightIter]); \n \n                    break; \n                } else if (((array[leftIter] + array[rightIter]) > 0) && \n                        (Math.abs((array[leftIter] + array[rightIter - 1])) < Math.abs((array[leftIter] + \n                            array[rightIter])))) { \n                    rightIter--; \n                    modified = true; \n                } else if (((array[leftIter] + array[rightIter]) < 0) && \n                        (Math.abs((array[leftIter + 1] + array[rightIter])) > Math.abs((array[leftIter] + \n                            array[rightIter])))) { \n                    leftIter++; \n                    modified = true; \n                } \n            } \n \n            System.out.println(array[leftIter] + \" \" + array[rightIter]); \n        } \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  #include   void foo() {  int arr[] = {2,5,8,-7,2,9};  int temp[2];    int len = sizeof(arr)/sizeof(int);  int min_sum = 10000;  int sum = 0;   for (int i = 0; i < len; i++)  {   for (int j = i + 1; j < len ; j++)   {    sum = arr[i] + arr[j];     if (abs(sum) < min_sum)    {     min_sum = abs(sum);     temp[0] = arr[i];     temp[1] = arr[j];    }   }  }   printf(\"%d, %d result = %d\",temp[0], temp[1], min_sum); }  void main() {   foo();  getch(); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We may like to add a condition that if the first element of a sorted array is not negative then the first two numbers of a sorted array will give the lowest possible sum and that will eventually be a answer to this... What's say?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sort the array by Absolute value desc, print the min sum of each adjacent pair. O(nlogn) e.g.  {2 5 8 -7 2,9} sort-> {2,2,5,-7,8,9}  min sum of adjacent pair: {-7, 8} = 1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In one traverse find positive minimum and negative maximum ,in second traverse find sum using both.ex {-17,0,1,2,5,7} pm=0,nm=-17 using these two find min absolute sum using 0 we get sum=1 using -17 we get 10 so (0,1) selected"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If all the numbers are negative or all numbers are positive then the pair (min value, next to min value) will be the unique answer. Below is a sorting based approach to arrive the pairs whose sum is closest to zero. I used merge sort here. Actually any nlogn sort can be used."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If all the numbers are negative or all numbers are positive then the pair (min value, next to min value) will be the unique answer. Below is a sorting based approach to arrive the pairs whose sum is closest to zero. I used merge sort here. Actually any nlogn sort can be used."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution: Sort -- O(nlogn), Find Pair in Sorted Array -- O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sort the arrry ignoring the sign of the integer. lets say the input is {2 5 8 -7 2,9} and it will be sorted as {2,2,5,-7,8,9} and iterate the array as the minimum sum lies with next element. Let me know if there is any bug in the code.  public class FindPairWithSumClosestToZero {    public static void main(String[] args){   int a[] = {2, 5, 8, -7, 2, 9};   qSort(a, a.length);   int l=0,min = abs(a[1]+a[0]);   for(int i = 1; i < a.length - 1; i++ ){    if(abs(a[i]+a[i+1]) < min){     min = abs(a[i]+a[i+1]);     l = i;    }   }   System.out.println(a[l]+\",\"+a[l+1]);  }   private static void qSort(int[] a, int n) {   recQuickSort(a, 0, n-1);  }   private static void recQuickSort(int[] arr, int left, int right) {   if(right - left <= 0)    return;   else{    int pivot = abs(arr[right]);    int partition = partitionIt(arr,left, right, pivot);    recQuickSort(arr, left, partition-1);    recQuickSort(arr, partition+1, right);   }     }   private static int abs(int i) {   return i<0?-i:i;  }   private static int partitionIt(int[] arr, int left, int right, int pivot) {   int leftPtr = left - 1;   int rightPtr = right;   int temp;   while(true){    while(abs(arr[++leftPtr])   while(rightPtr > 0 && abs(arr[--rightPtr])>pivot);    if(leftPtr >= rightPtr)     break;    else{     temp = arr[leftPtr];     arr[leftPtr]= arr[rightPtr];     arr[rightPtr]= temp;    }   }   temp = arr[leftPtr];   arr[leftPtr]= arr[right];   arr[right] = temp;   return leftPtr;     }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int pair(int arr[]) {             int index  = 0;      int current_sum = 0;      int previous_sum = Integer.MAX_VALUE;       for (int i = 0; i < arr.length-1; i++) {       current_sum = arr[i] + arr[i+1];       if (current_sum < previous_sum){        index = i;        previous_sum = current_sum;       }      }      return index;     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the code which worked fine in vs2005...i have printed the indices...  void pairsum_nearzero(int temp[],int n) {  int least,sum,indexi,indexj;  least = 0;  indexi=0;  indexj =0;  for(int i=0;i {   for(int j=i+1;j  {    sum = temp[i] + temp[j];    if(sum >=0)    {     if(sum <= least )       {     least = sum;     indexi = i;     indexj = j;       }    }    else if(sum <0)    {     if(-sum <= least )       {     least = sum;     indexi = i;     indexj = j;       }    }   }  }  cout<<\"the pairs ur looking for are\"<<< }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"here is O(n) solution. challenge accepted :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-4","title":"Sort the array and print the first 2 elements."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14106781","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"40","title":"Write a program  Given an array of N integers . Find the maxproduct of 3 numbers ?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"1. Sort the array 2. If minimum integers is greater than 0, product of maximum 3 integers is the answer. 3. If there exist at least 2 integers less than 0, find the product of mimimum 2 integers and 1 max integers. Compare it with the product of 3 maximum integers. Greater of the two is the answer.  Eg:  Given array :  10, 67, 28, 0, -1, -30, -20  sorted form :  -30, -20. -1, 0, 10, 28, 67  product of 3 max integers : 10*28*67 = 18760  product of 2 min integers and 1 max int = (-30)*(-20)*67 = 40200  Answer : 40200"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"The solution involves in finding three maximum and two minimum numbers. If the minimum numbers are negatives and if their product is greater than the two maximum number's product, then they have to considered for maximum product."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I don't think \"the largest 3 numbers\" is the right solution, the numbers may be negative, right? two negative numbers' product is still positive. Look at the following example: 6 3 2 -100 -101 The first 3 number is 6 3 2, the product = 36. But the largest product here should be 6 * -100 * -101."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Can be done in O(n) time take 4 var x,y,z,p and w; x=arr[0],y=arr[1],z=arr[2] and p=xyz; traverse the array and take elements in w; check if xyw>p or yzw>p or zxw>p  lets say xyw>p...then p=xyw and z=w; so on"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can get the first 3 maximum numbers in O(n), you can do it with 3 if statements"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n log3 = n) time and O(3) space:  use a min heap of length 3. So while traverse the arr check each element if is bigger than the min in the heap and if so remove the min and add the new one. At the end we will have the max elements which you can do the product"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. sort the array say we get a[n] 2. compare (a[0] * a[1]) > (a[n-2] * a[n-1])  ?  a[0] * a[1] * a[n-1] : a [n-1] * a[n-1] * a[n-3]  will it work ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"get the biggest three (may <3) and the smallest three (may <3).  The max product is the max of any of the three numbers taken from these 6 numbers (may <6). There are at most 20 combinations of these (at most) 6 numbers.  This avoids convoluted code to handling different cases."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Creating a max heap using the numbers and if a negative number comes take the mod Then apply heap sort only for first three elements. The product of first three element will be the maximum"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The solution involves in finding three maximum and two minimum numbers. If the minimum numbers are negatives and if their product is greater than the two maximum number's product, then they have to considered for maximum product."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we can do it using dividing the array into three and finding the max and min of each.so that we'll have three max and three min numbers from which the max product can be easily found. that would just take log(N) time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Prod{ \n        public static void main(String[] arg) \n        { \n                int[] arr={4,3,6,2,1,8}; \n                int len_arr=arr.length; \n \n                for(int i=0; iarr[j]) \n                                { \n                                        int temp=arr[j-1]; \n                                        arr[j-1]=arr[j]; \n                                        arr[j]=temp; \n                                } \n                        } \n                } \n \n                int product = arr[arr.length-1]*arr[arr.length-2]*arr[arr.length-3]; \n                System.out.println(product);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if all number are negative then we should take three smallest negative number"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I try to write C++ codes for this question;  #include  using namespace std;  int main() {     int array[] = {10, 60, 40, 0, -1, -60, -50, 200};     int n=sizeof(array)/sizeof(int);     cout<<\"Before sorted: \"<    for (int i=0; i        cout<< array[i] << \"   \";     int tmp;     for (int i=0; i       for (int j=0; j          if (array[j]           {               tmp=array[j];               array[j]=array[j+1];               array[j+1]=tmp;            }     cout<<\"\\n\\nAfter sorted: \"<    for (int i=0; i        cout<< array[i] << \"   \";     cout<    int maxproduct1;     int maxproduct2;     maxproduct1=array[0]*array[n-2]*array[n-1];     maxproduct2=array[0]*array[1]*array[2];     cout<< \"\\nThe maxproduct of 3 numbers\\n\"<<(maxproduct1>maxproduct2?maxproduct1:maxproduct2)<    return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This question seem simple, but is actually tricky.  I think Yoda's answer is the closest here.  What you want to do is breakdown the possible scenarios:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"following cases(assuming atleast 3 elements exist in an array) after sorting in nlog(n) in increasing order, If sign of last three elements are case1)  - - - than answer is product of last three numbers case 2)if sign is - + +  than answer is min{product of last two num; product of first two num}*third max case 3)if sign is - - + product of first two min num*last num of array case 4)if sign is + + + ans is last num*max{product of first two num; product of second and third last num}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class MaxThreeProduct { \n public static void main(String a[]){ \n  System.out.println(\"Enter the array\"); \n  int no[] = {-45,-98, -4, -78, -9, -90, 10}; \n  int largestNo =Integer.MIN_VALUE, largerNo=Integer.MIN_VALUE, largeNo=Integer.MIN_VALUE; \n   \n  for(int i=0; ilargeNo && no[i]largerNo && no[i]largestNo){ \n      \n     largeNo = largerNo; \n     largerNo = largestNo; \n     largestNo = no[i];     \n      \n    } \n  } \n   \n  System.out.println(\"Largest : \"+largestNo); \n  System.out.println(\"Larger : \"+largerNo);   \n  System.out.println(\"Large : \"+largeNo); \n  System.out.println(\"Max Product is : \"+largeNo*largerNo*largestNo); \n  } \n   \n  \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Arrays; \n \n \npublic class MaxProductOfThreeNumberTest { \n  public static void main(String[] args){ \n   int[] Arr={-25,-1,1,2,3,7,20}; \n \n \n   int MaxProduct=0; \n   quickSort(Arr,0,Arr.length-1); \n   System.out.println(Arrays.toString(Arr)); \n   if(Arr.length==3){ \n    MaxProduct=Arr[0]*Arr[1]*Arr[2]; \n   } \n   else if(Arr.length>3){ \n    if((Arr[0]<0)&&(Arr[1]<0) ){ \n     if((Arr[0]*Arr[1])> (Arr[Arr.length-3]*Arr[Arr.length-2])){ \n      MaxProduct=Arr[0]*Arr[1]*Arr[Arr.length-1]; \n     } \n     else{ \n      MaxProduct=Arr[Arr.length-3]*Arr[Arr.length-2]*Arr[Arr.length-1]; \n     } \n    } \n   } \n   if(Arr.length>=3){ \n    System.out.println(\"MaxProduct :\"+MaxProduct); \n   } \n   else{ \n    System.out.println(\"Array lenght should be equal or greater than 3\"); \n   } \n    \n    \n \n  } \n   \n  private static int partition(int[] list, int first, int last) { \n      int pivot = list[first]; \n      int low = first + 1; \n      int high = last; \n \n      while (high > low) { \n \n          while (low < high && list[low] < pivot) { \n              low++; \n          } \n \n \n          while (low < high && list[high] >= pivot) { \n              high--; \n          } \n \n \n          if (high > low) { \n              int temp = list[high]; \n              list[high] = list[low]; \n              list[low] = temp; \n          } \n      } \n      while (high > first && list[high] >= pivot) { \n          high--; \n      } \n \n      if (pivot > list[high]) { \n          list[first] = list[high]; \n          list[high] = pivot; \n          return high; \n      } else { \n          return first; \n      } \n \n  } \n \n  private static void quickSort(int[] list, int first, int last) { \n      if (last > first) { \n          int pivotIndex = partition(list, first, last); \n          quickSort(list, first, pivotIndex - 1); \n          quickSort(list, pivotIndex + 1, last); \n      } \n  } \n   \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"O(n  log n) solution: Sort the array descending order. find product of first 3 numbers."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14944921","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"34","title":"We have n number of sorted array for fixed length. Now we have to merge  these and need to save finaly result array into given array. Note- we can't use extra space except the given array.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"we can use minimum heap of size n with 1st element from every array. 1. pop the minimum element from the heap and push the element from the arrya which contains minimum element and heapify again....this process continues till no  element remain in any array ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"We do not need to use extra space even we wanna use heap. We can make use of the array given to store result. For example, we can make use of the tail of the result array. At the beginning, the tail won't be touched, so we can use last n position in this array, and make it work as a heap."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"May be the expected answer is n-way merge sort. 1> First sort indivisual n arrays (may be using bubble sort) 2> now use n-way merge and save the result in resultant array"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Pick the min of every array till there are no elements in any of the arrays and append the min to the output array. Uses 2-3 temp variables.   Complexity = O(n*m) where m is the total number of elements in the array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can you please explain clearly?, n number of sorted arrays of fixed length?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think that's what Bucket Sort does."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def partition(a, s, e, m): \n  if ( (e - s) == 1 ): \n    if ( a[e/m][e%m] < a[s/m][s%m] ): \n      (a[e/m][e%m], a[s/m][s%m]) = (a[s/m][s%m], a[e/m][e%m]) \n    return e \n  x = (s+e)/2 \n  pv = a[x/m][x%m] \n  (a[e/m][e%m], a[x/m][x%m]) = (a[x/m][x%m], a[e/m][e%m]) \n  x = s \n  for i in range(s, e): \n    if ( a[i/m][i%m] <= pv ): \n      (a[i/m][i%m], a[x/m][x%m]) = (a[x/m][x%m], a[i/m][i%m]) \n      x += 1 \n  (a[x/m][x%m], a[e/m][e%m]) = (a[e/m][e%m], a[x/m][x%m]) \n  return x \n \n \ndef quicksort(a, left, right, m): \n  # If the list has 2 or more items \n  if ( left < right ): \n    pi = partition(a, left, right, m) \n    quicksort(a, left, pi-1, m) \n    quicksort(a, pi + 1, right, m) \n \n \ndef sort_array(a): \n  n = len(a) \n  m = len(a[0]) \n  quicksort(a, 0, n*m-1, m) \n \na = [ \n  [9, 8, 7, 10, 15], \n  [1, 2, 3, 11, 14], \n  [6, 5, 4, 12, 13] \n] \n \nprint(a) \nsort_array(a) \nprint(a)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This question doesn't sound right. Where do you put the result? Can we just pick any one of them to start putting the result and then use the next array and so on? If so, it's just a in-place merge sort."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Its becoming hopehesless..After going through couple of questions today, I feel like people should first try to learn some form of a human comprehendible language properly before attempting to become a machine linguist. Reminds me of my highh school chemistry teacher who used to get pissed off at students who were preparing for the toughest engineering entrance exams but could not even perform a simple math calculations correctly."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what you are trying to depict is the form of external sorting..... u don't have sufficient space in the main memory to sort entire elements..... so u do it by generating runs.... we construct a tournament tree with the help of input buffers and output buffers(by reading a block ) from second memory.... We increase the run number whenever we find a new element that enters into the tree by reading from second memory(and changing the run number if necessary)....."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"well i think this might be a solution: just copy all arrays in the final array and perform any sorting technique now on this big array, this will need O(n) for copying and O(nlogn) for sorting so eventually we end up with a over all O(n log n).   correct it if wrong."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"take first two arrays perform merge sort and put output in the output array  copy it back to the first two arrays, so now all elements in first array are lesser than the elements in the second array.   Now perform merge between 12 and 3   do the same thing"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Take 2 arrays at a time merge them perform quicksort on them  space complexity remains o(n) and worst case time complexity will be o(n^2) avg case time complexity will be O(n log n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Assuming length of all the array is fixed and same i.e. length 2. Here a[k][i] means ith element of kth array among N arrays. Just didn't get in my mind how to represent kth array so used this notation. 3. Starts from the back of the array. Takes the last element of all of the array and insert the maximum in last position of given_array and again inserts less than max in last-1 position. 4. Again for second last element of all the arrays."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"take least element from 1st location of each array,increament the location by 1 index from where least element is taken.  Do the above step till all the arrays are done. Do not take duplicate values in the final array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"take least element from 1st location of each array,increament the location by 1 index from where least element is taken.  Do the above step till all the arrays are done. Do not take duplicate values in the final array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming that you have n arrays in the files...and you can load only 1 of them of size m in memory at a time..n way merge sort (external sort) is the best bet.  1. Open the file stream from (m-1) files out of n and load the first value out of each into memory so total memory taken so far is (m-1)...now take the minimum element of the m-1 values and write it to a file or System outout buffer...so now u have used all of the m memory spaces...Once you have out 1 value, you can load next value from the input file stream just like we do in a typical merge sort.....repeat it untill all of the m files are done.  2. so now, you have 1 file which contains the sorted array for m files out of n.  3. Repeat the step 1 for all of the n files taken in groups of m. 4. Repeat the step 1,2 and 3 untill you get a singe sorted file....and thats what you want.  I hope it helps."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"call find min on each of the n arrays every time, complexity O(n*k). Then find min of mins and place it in current index of result array, complexity O(n). Total time complexity O(n) and constant size (current index)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If you need to sort it in ascending order, simply form a MAX-HEAP and store it in the output array. At this point, the 0th element is guaranteed to be the maximum element. Here's the kicker - remove max and swap it with the last element in the heap. Now perform max-heapify on the root. Keep iterating until all roots have been deleted."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14878847","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"35","title":"You have an array of size n with values ranging from 1 to n. Exactly one number is missed and one number is repeated. Find missing number and Repeated number.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"simple, let the input be 1,4,3,2,4  4 is repeated, 5 is missing, let repeated number be x1 and missing number be x2  arithmetic progression n(n+1)/2 - x2 + x1 = summation of all the numbers  5(5+1)/2 - x2 + x1 = 14 15 - x2 + x1 = 14 x2-x1 = 1 -------> equation 1  find the product (n! * x1)/x2 = product of all the numbers  ((1*2*3*4*5) * x1) / x2 = 1*2*3*4*4 (120 * x1) / x2 = 96 120 * x1 = 96 * x2 x1 = (96 * x2) / 120 -------------> equation 2  substitute x1 in equation 1  x2 - ((96*x2) / 120) = 1  120 * x2 - 96 * x2 = 120  24 * x2 = 120  x2 = 5  substitute x2 in equation 1  5 - x1 = 1  x1 = 4  hence proved :-)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"This is a very simple solution in C# without that math shit."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"#include \nint main() \n{ \n    int n,i; \n    scanf(\"%d\",&n); \n    int arr[n]; \n    for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"int main(){ \n int a[] = {1,3,4,5,4}; \n for(int i=0;i<5;i++){ \n  if(a[i] != i+1){ \n   int temp = a[i]; \n   a[i] = a[a[i] - 1]; \n   a[temp-1] = temp; \n  } \n } \nfor(int i = 0; i < 5; i++) \n if(a[i] != i+1) \n  cout << \"Number missing is\" << i+1 \n    << endl; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"simple solution ..  just to internal hushing ..   2 3 3 6 4 1 1 2 3 4 5 6  swap(1,2)  3 2 3 6 4 1 1 2 3 4 5 6  swap(1,3) , you notice its a cycle u find repeated no. 3 and may be missing no. 1 save it then go further  swap(4,6)  3 2 3 1 4 6 1 2 3 4 5 6  swap(1,4) 1 2 3 3 4 6 1 2 3 4 5 6 now again cycle update missing no. 4 and go further  swap(4,5)  1 2 3 4 3 6 1 2 3 4 5 6  again cycle update missing no. 5 go further   at the end u have missing no. and repeated no."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"C# Solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"another approach can be to sort the nos nd check...(o(nlogn) not efficient ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is this proper?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"another possible solution,  Let the input be 1,4,3,2,4  4 is repeated, 5 is missing.  Sort the array ... after sorting array would be like 1,2,3,4,4  for (int i=0; i{   if (array[i]!=i+1)      print (\" Missing :):  %d\",i+1)    if (i+1!=n)  {     if (array[i]=array[i+1])        print (\" Missing :):  %d\",i+1)  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"According to the question the size of the array is \"n\". And the array starts from 1 and ends with \"n\". This means that the size of the array and the last element of the array must be equal?  Am i right?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"main() {  int a[]={3,2,5,1,4,2};  int miss=1, repeat=1;     int t[6] = {0};  for(int i=0; i<6; i++)  {   if(t[a[i]-1] !=0 ) repeat = a[i];   t[a[i]-1] = 1;  }    for(int i=0; i<6; i++)  {   if(t[i] == 0) miss = i+1;  }    printf(\"miss=%d, repeat=%d\\n\\r\", miss, repeat);   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package test;  public class MissRepeat { public static void main(String args[]) {      int[] a = { 5, 4, 3, 1, 1};     int[] b = new int[a.length];  b[0]=a[0]; int x=0,s=0,s1=0; for (int i = 1; i < a.length; i++) {    b[i]=a[i];        if(b[i-1]==a[i])    {    x=a[i];      System.out.println(\"repeated:\"+a[i]);    }   }   for (int i = 1; i < a.length+1; i++) {  s+=i;  s1+=a[i-1]; }   System.out.println(\"missing:\"+(s-s1+x)); } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package test;  public class MissRepeat { public static void main(String args[]) {      int[] a = { 5, 4, 3, 1, 1};     int[] b = new int[a.length];  b[0]=a[0]; int x=0,s=0,s1=0; for (int i = 1; i < a.length; i++) {    b[i]=a[i];        if(b[i-1]==a[i])    {    x=a[i];      System.out.println(\"repeated:\"+a[i]);    }   }   for (int i = 1; i < a.length+1; i++) {  s+=i;  s1+=a[i-1]; }   System.out.println(\"missing:\"+(s-s1+x)); } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it can be done using xor.  xor of all given elements and number in range(1,n). will give xor of number not present in array(let it be a), number present twise in array (b).  as we get a xor b. now we can use the algo of finding 2 non repeated elements of array and numbers in range(0,n). in order on n"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can prevent overflows using this method. You know the number ranges from 1 to n. So make a[a[i]] = 0-a[a[i]]. Scan through the array to find positive numbers. One of them will be repeated and other will be missing. One more scan will help us to find which one is what and reset all of them to positive values"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package arrays;  public class FingRepeatingAndMissingElement {   public static void main(String[] args) {   int a[] = { 0, 3, 5, 6, 5, 2, 1 };    for (int i = 0; i < a.length; i++) {    if (a[i] != 0) {     int j = Math.abs(a[i]);     a[j] *= -1;    }   }    int repeating_element = -1;   for (int k = 0; k < a.length; k++) {    if (a[k] > 0) {     repeating_element = a[k];     System.out.println(\"Repeating element is \" + a[k]);     break;    }   }    if (repeating_element != -1) {    int sum = 0;    for (int i = 0; i < a.length; i++) {     sum += Math.abs(a[i]);    }    int missing_element = repeating_element - (sum - 21);    System.out.println(\"Missing element is \" + missing_element);   }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package page1;  public class FindTheMissingAndRepeatingElement {   /**   * @param args   */  public static void main(String[] args) {   int a[] = {5,4,4,1,2};   for(int i = 0;i < a.length;i++){    if(a[Math.abs(a[i]) - 1]>0){     a[Math.abs(a[i]) - 1] = - a[Math.abs(a[i]) - 1];    }else     System.out.println(a[i]);   }   for(int i = 0;i< a.length;i++ ){    if(a[i]>0){     System.out.println(i+1);    }   }  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) exor given array and the complete sequence 1..n. this will give the result (x exor y) where x and y are single and the double number 2) find the number repeated by iterating and negating the array values, whenever the number is already negated it means the number occured twice 3) exor the number repeated twice with the result in step one. this will return the number which occured only once"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In a interview,same question asked to me but only for missing number. I have answered as: Sort the array and travers the same and find the missing.  But interviewer asked me that, my solution has 2 traversing 1st sort and than find missing. He asked me to do in single travers.  Someone can suggest... also considering for repeated number also..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void printRepeatedAndMissingNumber(int arr[]){ \n        int i = 0; \n        while(i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since we know the numbers are consecutive , the max difference of sum of all elements in an array and n*(n+1)/2 is 1   Add the given array to hashset, will get the duplicated element let say 'm' . look for m+1 or m-1 in the hashset. one of them will be missing that is the missing element"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=3179669","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"36","title":"There is very long array of ints, and you are given pointer to base addr of this array.. each int is 16bit representation... you need to return the pointer to tht \"bit\" inside array where longest sequence of \"1\"s start","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Do we need to take care of endianness ?  eg no=16704 can be represented as   01000001 01000001 MSB LSB 01000001 01000001 LSB MSB  depending upon endianess"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"int *largestseqone(int * p,int len) {  int *temp=p;  int count=0,maxcount=0;  int i=0,n=0;  for(i=0;i {   n=*(temp+i);   printf(\"\\n %d \\n\",n);   while(n!=0)   {    if(n%2==1)    {     count++;     printf(\"count increment: for %d is %d \",n,count);     if(count>maxcount)     {      maxcount=count;      p=temp+i;     }    }    else    {     if(count>maxcount)     {      maxcount=count;      p=temp+i;     }     count=0;    }    n=n/2;   }   count=0;  }  return p; }   int main() {  int arr[5]={1,13,12,8,7};  int *q=largestseqone(arr,5);  printf(\"\\n the answer is %d\",*q);  getch();   return 0; }  gives the answer as :7 which is correct"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Everybody has written something,but can somebody explain how can one return a pointer to a bit in C ?????????????? I think there should be a correction in the question"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Something take this simple example: Array = {15,7,2,1,0,23} 1111,0111,0010,0001,0000,10111 ^ Result: Pointer should point to 1st bit of number 15."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"anybody has the answer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Longest sequence of 1 implies the highest number in the collection. If we know the highest number in the collection, then we can return the pointer to it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Thought about a method..Let me know if sounds Ok.. 1.)keep incrementing the given integer pointer to access the elements of the array. 2.)for each integer element use the left shift operator to determine the longest sequence of 1's i.e.both \"start\" and \"end\" point..       2 a.)if the \"end\" point of previous element and starting bit of next element are continuous and greater increase the global count of \"Continous 1's\" and their starting position. 3.)For each element maintain the the number of continous 1 bits from the 16th bit.      3 a.)if the \"end\" point of previous element and starting bit of next element are continuous and greater increase the global count of \"Continous 1's\" and their starting position. 4.)finally we will have the global variable with maximum 1's with their start and endpoints.Probably return a type casted character pointer to the starting point..  I know I have written it in a confused manner. But I hope u get the Idea.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I don't think we need to consider endian problem, as long as we compare bit by bit."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I got a method: 1)Define a signature for each int. For example, an integer like 1111,0011,1111,0000 will have a signature in string as \"14021604\". The even char in the signature is either 0 or 1, while the odd char is the # of consecutive 0 or 1, which is represented in hex (since the consecutive # of 0 or 1 may be larger than 10, but we only want represent the # as one char). 2)therefore, we can convert the whole array into a string. 3)Go through the whole string, it is easy to get the longest consecutive sequence of 1 and its bit position. For example, we have an array like: 3, 4, 5, 7, if we represent each int as 4 bits, we will have 0011, 0100, 0101, 0111. Then we have the signature: \"0212\",\"011102\",\"01110111\",\"0113\". Then we go through the string, we can get the longest consecutive sequence is 3."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how about taking two character pointers pointing to beginning of array and move till its size. moving a pointer one by one as soon as u find 1 and simultaneously tracking the sequence count and initial pointer of sequence."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would suggest to have a 16 bit long bitmask with first bit set as 1 and rest set to zero. Do AND of that with a given integer. Check if output is 1 else do left shift of 1 bit on bitmask and check for 1 again. Once you got 1, store it and check for longest sequence in a similar way."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this is problem on bit array(search wiki) ,implement iterator over bitarray ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I don't think that it is important point to return pointer to bit. What is important that the algorithm implementation."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Tested this in VC++, but can't figure out how to return ptr to bit.  void printArrayBits (int *ptr, int arraySize) {   unsigned int i = 0, j = 0;   unsigned char *p = 0;    p = (unsigned char *) ptr;   for (i = 0; i < arraySize * sizeof(int); i++) {     printf (\"%08X: \", i+p);  for (j = 0; j < 8; j++) {   if (*(p+i) & (0x80 >> j))    printf (\"1\");   else    printf (\"0\");  }  printf (\"\\n\");   } }  unsigned char *findLongestContinuousOneBitsInArray (int *ptr, int arraySize) {   unsigned int i = 0, j = 0;   unsigned char *retPtr = 0;   unsigned char *p = 0;   unsigned char *q = 0;   int numOfOnes = 0;   int maxNumOfOnes = 0;      p = (unsigned char *) ptr;   for (i = 0; i < arraySize * sizeof(int); i++) {     for (j = 0; j < 8; j++) {    if (*(p+i) & (0x80 >> j)) {      if (numOfOnes == 0) {     // remember where we started     q = (p+i);   }      numOfOnes++;    } else {      if (numOfOnes > maxNumOfOnes) {     maxNumOfOnes = numOfOnes;     retPtr = q;   }   numOfOnes = 0;    }  }   }      // In case the array is all 1's   if (numOfOnes > 0 && q == 0) {     retPtr = q;   }        return retPtr; }  int main(int argc, char* argv[]) {  int arr[5]={1,13,12,8,7};   printArrayBits (arr, 5);  unsigned char *p = findLongestContinuousOneBitsInArray (arr, 5);   printf(\"\\n the answer is %p\",p);  getchar();   return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"unsigned int index=0; unsigned int max_bits=0; unsigned int temp_bits=0; unsigned int flag=1;  for(i=0;i< ARRAYSIZE;i++) {    flag = 01U; for(j=0;j{ if(a[i]& flag) temp_bits++ flag = flag << 1; } if(temp_bits > max_bits) index=i; } return i;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"unsigned int index=0; unsigned int max_bits=0; unsigned int temp_bits=0; unsigned int flag=1;  for(i=0;i< ARRAYSIZE;i++) {    flag = 01U; for(j=0;j{ if(a[i]& flag) temp_bits++; flag = flag << 1; } if(temp_bits > max_bits) index=i; } return i;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"unsigned int index=0; unsigned int max_bits=0; unsigned int temp_bits=0; unsigned int flag=1;  for(i=0;i< ARRAYSIZE;i++) {    flag = 01U; for(j=0;j{ if(a[i]& flag) temp_bits++; flag = flag << 1; } if(temp_bits > max_bits) index=i; } return i;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"unsigned int index=0; unsigned int max_bits=0; unsigned int temp_bits=0; unsigned int flag=1;  for(i=0;i< ARRAYSIZE;i++) { flag = 01U; for(j=0;j{ if(a[i]& flag) temp_bits++; else { if(temp_bits > no_bits) no_bits=temp_bits; temp_bits=0; } flag = flag << 1; } if(temp_bits > max_bits) index=i; } return i;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"unsigned int index=0; unsigned int max_bits=0; unsigned int temp_bits=0,no_bits=0; unsigned int mask=0;;  for(i=0;i < ARRAYSIZE;i++) {    mask = 1;    no_bits = 0;    for(j=0;j    {       if(a[i] & mask)       temp_bits++;       else       {         if(temp_bits > no_bits)          no_bits=temp_bits;          temp_bits=0;       }       mask = mask << 1;     } if(no_bits > max_bits) index=i; } return i;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void get_indexes(int *array_index,int * bit_index,int *array) {    unsigned int max_bits=0;   unsigned int temp_bits=0,no_bits=0;   unsigned int mask=0;   unsigned int temp_bit_index=0;    for(i=0;i < ARRAYSIZE;i++)   {    mask = 1;    no_bits = 0;    for(j=0;j   {      if(array[i] & mask)      temp_bits++;      else       {         if(temp_bits > no_bits)         {          no_bits=temp_bits;           temp_bit_index =j - temp_bits;          temp_bits=0;         }      mask = mask << 1;    }    if(no_bits > max_bits)    {     array_index=i;     bit_index = temp_bit_index;     }   }    return; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The following function will work  #define ARRAYSIZE some value #define INTSIZE 16  void get_indexes(int *array_index,int *bit_index,int *array) {   unsigned int max_bits=0;   unsigned int temp_bits=0,no_bits=0,temp_bits1=0;   unsigned int mask=0;   unsigned int temp_bit_index=0;    int i=0,j=0;    for(i=0;i < ARRAYSIZE ;i++)   {    mask = 1;    no_bits = 0;    temp_bits=0;    for(j=0;j   {      if(array[i] & mask)      temp_bits++;      else       {         if(temp_bits > no_bits)         {               no_bits=temp_bits;               temp_bit_index = j - no_bits;               temp_bits=0;         }       }      mask = mask << 1;          }    if((no_bits > max_bits) || (temp_bits > max_bits) )    {      max_bits=temp_bits > no_bits ? temp_bits : no_bits;     *array_index=i;     *bit_index = temp_bits > no_bits ? (j - temp_bits) : temp_bit_index;     }    }    return; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this should work, any advice ? ( make a little change, return max length of '1', no start position )"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=10602664","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"36","title":"Given a big unsorted list of 64-bit integers, find an element not in list","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"hey guys, What about using a trie structure to represent those numbers? In which you have each number split in 8 groups of 8 bits (or lower no. of bits). So, for ex. 123456789123456789 (00000000 11011011 01001101 10100101 11010110 01101000 00101111 100010101) will be represented by the path: 00000000 --> 11011011 -->  01001101 --> 10100101 --> 11010110 --> 01101000 --> 00101111 --> 100010101 in the trie structure.  After the entire trie structure was built it will much easier to find a number which is not in the list.  If the list is too big to fit into memory, we can store the trie structure on the disk.  This is how Lucene stores the numeric values in its index for a fast search."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Choose a random 64-bit integer.  Scan through the list to check it's unused.  With very, very small probability, you will need to go for a second choice of number (again random), or third, etc.  Expected runtime is still O(n).  Since the list is unsorted, O(n) is the best you can get."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the list contains all 64-bit numbers except only ONE number then XOR all the numbers will give the missing number."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Programming Pearls by Joe Bentley has a solution where he proposes using a divide and conquer method to find bucket containing the missing number."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question didn't specify missing only 1 specific number, and I think the main point is there may not be enough memory to do sorting of all the data at once.  We need to how much memory we have to perform operations, let's say, if we have 2MB of memory (2^21 Bytes), then we can create an array of 2^16 of type long, and count the occurence of the first 16 bits (using bit-wise & operation) of those 64 bit numbers. O(n)  Then we could pick the number with the least occurrence ( gaurantee to have missing number ), then from those numbers, we pick the 17-32 bits and do the same thing. O(n)  Until the last 16 bits, we could have a 2^16 array of bool, to hash with the last 16 bits of those picked set of numbers, to find some missing bits. O(n) Then we could combine all the 4 16bits segment to get a missing element"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Largest sum of the elements which can be accommodated in 64 bit is missing...   or search for max number.. any sum amount more then that and can be accommodated in 64 bit is missing.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If only one number is missing... it can be easily found... make a structure with  {position, no of occurring of 0,no of occurring of 1) in binary format of number.  for 3 bit number in binary format we have 3 position's  if all elements are present  values will be (1,4,4) (2,4,4) (3,4,4)  suppose from 0 to 7 6 is missing...  the structure will result as (1P,4,3) (2P,4,3) (3P,3,4)  that mean binary digit 1 missing from index 1, 1 missing from index 2 and 0 is missing from index 3  possible missing number will be 110  that is 6.  this might be generalized in case of more than 1 number is missing.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The idea is to use binary search. Rough sketch follows.  1. Start with high as INT64_MAX (the maximum number that can be represented in 64 bits - signed) and low as INT64_MIN. Now, the mid element will be 0.  2. Go through the elements and count which are < mid and > mid.  3. If if the numbers < mid are more than the count of numbers > mid, then low = mid, else high=mid. Progressing like this, we will get a number which does not exist in the list.   This will have O(64*n) = O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"3 variables: find min find max find sum.  missing umber = sum(1->max)- sum(1->min) - actualsum"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi guys, I'm thinking of using a B+ tree that each node in the tree will have two values (call it lowerbound and upperbound) indicating the range that node will cover  when reading an input, insert it to the proper location in a B+ tree, if the difference between the newly inserted node and its neighboring node(s) is one, delete this node, and merge it with its neighbor by updating its neighboring node's lowerbound or upperbound depending on the inserted node's position.   in this way we don't need to store all numbers of the unsorted list. in the case if we only have one number missing, the size of the b+ tree will be increasing at first, but will shrink down eventually to 1 node (if the missing number if 0 or 2^64-1) or 2 nodes (if the missing number is any number between 0 and 2^63-1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"take an array of size 64 to calculate difference in number of 1's and 0's at a particular bit position.(ideally 2^64 numbers have 2^63 1's and same numbers of 0'2 at each bit position).So bring some numbers in memory and calculate difference for each postion. after u are done with all the numbers what u will have is an array of size 64 having either -1 or +1 at each index so let's assume we are taking difference of (numbers of 0s') - (numbers of 1s') then wherever it is -1 put 0 at that position and wherever it is 1 put a 1 at that position and finally u will get binary representation of that missing number."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sum of integers 1..n is n(n+1)/2 let's call it S(n). So S(n) - Sum of List  should give you the missing number"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use a bitset. Let the LONG_MIN be at index 0. For every number, set the bit in the bitset. Any bit one which is not set is the missing number."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"64 bit means its a long type number . we can say set consists of long integers. we can use bit array. take bit array, initiallise with 0 traverse each element once in the set and set 1 in bit array.  traverse the bitarray again and find bitarray index set to 0 that will be required number  i think it is not possible in less than O(N)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"it will have 2^64 numbers means - 18,446,744,073,709,551,616 it requires 18,446,744,073,709,551,616 / 8 bytes to store all 64-bit numbers i.e.. 2,305,843,009 GB space is required. do you think its possible to have such huge memory?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Find max or min number and add or sub 1 from that. Check for overflow or underflow cases"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Guys relax,  If there is only one missing integer then 2^64 - sumOf (givenArray) will solve the problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"The sum of their absolute values is not in the list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Use binary search.  Let say max number is N = 2^64. Then set pivot as p = N/2, Partition the list with first part as number <= p, second part as >=p; if(#number in fist part < p) then do search first part else search second part.   for each partition will be O(n), and will be O(n*lgN), which will be O(n*64)=O(n) in worst case"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"you bunch of idiots, by saying that the list s very big he is implying that the list is not to be traversed...  more importantly it is a behavioral question, the answer can be any number greater then 2^64 that can never reside in a list containing 64 bit integer list..  so the number can be 2^64+1 or 2^64 and so on...."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=20967663","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"33","title":"In an array of unsorted integers (you may assume the array may contain +ve, -ve and 0s), write a function  int returnNthMax(int[] arr, int n)  which will return the nth Max number. For e.g. if this is given array {2, -4, 5, 6, 0, 7, -1, 10, 9} and n=1, it should return the max number, 10 and if n=3, it should return 3rd max number, which is: 7.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Selection search should do. Complexity: O(n) where n is the number of elements in the array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Use min-heap of size \"K\" or, as suggested by subahjit, the quick selection(aka selection search) algo. The min-heap has the advantage that it can also produce the list of all values starting from element N-K up the the N-th element, where the N is the size of the array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Using a min-heap of size n as ashot has mentioned already. I am merely providing Java code to illustrate the idea."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sites.google.com/site/spaceofjameschen/annnocements/find-nth-largest-element-in-an-array-of-m-elements-where-n--0-n-is-much-smaller-than-m-without-sorting"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If there is a reasonable cap to the values (e.g. they are all integers in the range of 0-1000000) you can use a bit vector, toggling the appropriate bit for each value you see, and then simply traverse the bit vector to find the nth toggled bit. That'll work in O(N). Else, the heap approach already mentioned for O(N * log(K))."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use quick select algorithm to find nth largest number. It runs in O(n) average case time and O(n^2) worst case time. If you really want to improve worst case performance to O(n), use median-of-medians algorithm to ensure a good split in quick select algorithm."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why don't we simply sort the array first? That way indexing is o[1]."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my java solution. It is essentially the quick select algorithm used to find the kth largest number in an unsorted array. The algorithm assumes all elements in the array are unique (no duplicates). I also added the code to show the kth smallest element (commented out). I recommend not committing the code itself to memory, but rather working the algorithm out on paper until you understand the way the algorithm works."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"var input = [2, -4, 5, 6, 0, 7, -1, 10, 9]; \nvar maximums = []; \nvar nth = 3; \nfor (var index = 0; index < input.length; index++) { \n if (maximums.length > 0) { \n  for (var maxIndex = 0; maxIndex < maximums.length && maxIndex < nth; maxIndex++) { \n   if (maximums[maxIndex] < input[index]) { \n       maximums.splice(maxIndex, 0, input[index]); \n       maximums.length = nth; \n       break; \n   } \n  } \n } else { \n  maximums.push(input[index]); \n } \n} \nvar result = maximums[nth];"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can't we use median of medians here?complexity O(kn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include int ele;  int returnNthMax(int *p,int k) {  return p[ele-k]; }  int main() {  int *p;  int i,j=0,k=0,temp=0,max=0;   printf(\"\\nHow many elements ?? \");  scanf(\"%d\",&ele);   printf(\"\\nEnter elements : \");  p=(int *)malloc(sizeof(int)*ele);  for(i=0;i {   scanf(\"%d\",&p[i]);  }      for(i=0;i {   for(j=0;j  {    if(p[j] > p[j+1])    {     temp=p[j];     p[j]=p[j+1];     p[j+1]=temp;    }   }  }   printf(\"\\nwhich maximum you want ? \");  scanf(\"%d\",&k);   max=returnNthMax(p,k);  printf(\"\\nkth max is : %d\",max);   getch();  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This solution is same as @braap 's solution. It finds the kth largest number by using divide and conquer technique. This technique is similar to partition technique of quick sort. But we shall follow the partition where the kth largest element is. Hence the time complexity is O(k log n). @braap I have just coded it a bit different way"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"applying a simple bubble sort seems to be more simpler. Here is the code in C#"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static int returnNthMax(int[] arr, int nTh) \n        { \n            int lastmax = int.MaxValue; \n \n            if(arr.Length < nTh) \n                return -1; \n \n            for (int j = nTh - 1; j >= 0; j--) \n            { \n                int localMax = int.MinValue; \n \n                for (int i = 0; i < arr.Length; i++) \n                { \n                    if (arr[i] > localMax && arr[i] < lastmax) \n                    { \n                        localMax = arr[i]; \n                    } \n                } \n                lastmax = localMax; \n            } \n \n            return lastmax; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use randomized selection algorithm.  #include  #include  #include  using namespace std; void swap(int*,int*); int partition(int*,int,int); int rselect(int*,int,int,int); int main() {  int n,i;  ifstream fin(\"input9.txt\");  fin>>n;  int *a=new int[n];  for(int i=0;i  fin>>*(a+i);  cout<<\"Enter the order statistic you want to find\\n\";  cin>>i;  int stat=rselect(a,0,n-1,i-1);  cout<<\"The \"<<<\"th order statistic is = \"<< return 0; } void swap(int* a,int* b) {  int temp=*a;  *a=*b;  *b=temp; } int partition(int* a,int p,int r) {  int j=p+1;  for(int k=p+1;k<=r;k++)  {   if(*(a+k)>*(a+p))    swap(a+k,a+j++);  }  swap(a+j-1,a+p);  return j-1; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"apply a quickSort() or heapSort()"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The Random Select algorithm can lead to the worst-case O(n^2) complexity if the pivot element happens to be the largest in many iteration, but in average it is O(n). In contrast, Median of Medians guarantees the worst-case complexity of o(n). We can still do better by constructing a RB-Tree to achieve O(lg n) complexity. The pseudo code is as follows:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class MaxNumber {    public static void main (String[]args){   System.out.println(\"Enter the array length: \");   Scanner sc = new Scanner(System.in);   int n = sc.nextInt();       ArrayList marks = new ArrayList();        System.out.println(\"Enter the element of the array: \");      for (int i=0; i       marks.add(sc.nextInt());      }            Collections.sort(marks);      System.out.print(\"Original contents of al: \");      Iterator itr = marks.iterator();        while(itr.hasNext()) {           Object element = itr.next();           System.out.print(element + \" \");        }        System.out.println();            System.out.println(\"Enter the number: \");           int num = sc.nextInt();           for (int i =marks.size()-1; i>num; i--){            System.out.println(marks.get(i));           }         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class MaxNumber {  \n \npublic static void main (String[]args){  \nSystem.out.println(\"Enter the array length: \");  \nScanner sc = new Scanner(System.in);  \nint n = sc.nextInt();  \n \n \nArrayList marks = new ArrayList();  \n \n \nSystem.out.println(\"Enter the element of the array: \");  \nfor (int i=0; inum; i--){  \nSystem.out.println(marks.get(i));  \n}  \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"sort the array and return the n-k value"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=1519","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"34","title":"You are given an array of length 99 that contains all the numbers between 1 and 100, except for one number that has been removed.  Find the missing element.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"\"Missing\" word indicates that the array has numbers from 1 to 100 (which may be out of sequence though). Add all the elements in the array and subtract the sum from 5050.(100 * 101)/2 = 5050"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What if an element is missing and instead we have a duplicate value. In that case your sol doesn't work."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Thats Correct ... I assumed missing slot would have 0.Then solution would require detecting duplicate value. Another array of size 100 can be used ... traverse first array and use values as indices for the other array and mark those slots. If we encounter already marked slot, duplicate is found. Using this value and difference above, missing value can be detected.missing value = duplicate value + differenceSolution looks a bit inefficient ... any suggestions?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use an array C of size 100 initialized to all zeros...  Go through original array, for every element x, increment C[x] by 1. In the end, the index in C having value 0 is the missing value, and the index with value greater than 1 is the duplicate value."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how can we assume that the array would have values from 1-100.. cant they be any range of 100 consecutive nos e.g. 321-420 etc?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"yes,  it could be any range of width 100, in which case i guess we would have to take the minimum value in the original array (found in O(n) time), and use it as an offset to subtract from the value to obtain the corresponding index in the array C mentioned above. so for the range 321-420, the value 400 would correspond to index 400-321 = 79."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The above solutions require another array of equal size. Suppose we could modify the array. Just need to perform a sort and find the duplicate value using two pointers.Would turn out to be O(nlog n) though.(Assuming we use quick sort or merge sort."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if the numbers are any 10 consecutive numbers, then just take the remainder of the number/100 as the index to the array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In case say x is the missing element and is in turn replaced by y (for say numbers in the range 1 to N)Let A be the original series from 1 to NLet B be the series as described aboveSummation(A) - Summation(B) = y-xProduct(A) / Product(B) = x/yBased on these 2 equations, you can obtain x and y (the missing and the duplicate element respectively)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i think chaitu's sol is the best one but there can be one optimization-int num = 100(initialization)then after processing,we will get the odd no. directly."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If missing number is not filled as zero and some other number is duplicated then:let the missing number be xlet the duplicated number be yExisting product = P1Actual product of N numbers = P2Both these products have atleast a component common which is the product of the remaining n-1 numbers say that is Ptherefore P1 =  P * xand P2 = P * yhere P is the GCD of P1 and P2.Thus find the GCD of P1 and P2 and divide P1 and p2 by it and get x and y.If the missing number is replaced by zero then P2 would be zero. In that case use the summation method discussed above"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"By GCD I meant Greatest common divisor"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ENJOY!!!Assumption : Array starts from 1 else find the min and work acc.int[] a = {1,2,3,3,5};             int sum = 0;     int prodsum = 0;     int actualsum = 0;     int actualprodsum = 0;          for (int i =0; i< a.length; i++)     {      sum = sum + a[i];      prodsum = prodsum + (a[i] * a[i]);            int j = i+ 1;      actualsum = actualsum + j;        actualprodsum = actualprodsum + (j * j);      }          int repeated = 0;     int missing = 0;     if(sum != actualsum)     {            int m = sum  - actualsum;            repeated= ((prodsum - actualprodsum) + (m * m))/(2*m) ;      missing = actualsum - sum + repeated ;     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use bitvector. 1. insert numbers as indexes of bitvector = O(n)2. read for missing indexes = O(n)O(n) + O(n) = O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the problem explicitly says \"all numbers between 1 and 100 except one missing\" in an array of length 99. How can we have duplicated numbers? How can the numbers be some other consecutive numbers?@_@"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"idealSum = n*(n+1)/2 actualSum = iterate and find sum diff = idealSum - actualSum culprit = n-diff  here culprit is the missing/duplicate or any value that shud not be there in the array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please check my code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"\"all the numbers between 1 and 100, except for one number that has been removed\"  Sort the array then Iterate through, subtracting each element from the previous element, testing the difference. When the difference == 2, return the current minuend-1  This works for arrays of n size.  There are probably more elegant ways to do it, but the problem states a 99-element array which is so small that it renders performance considerations negligible."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Based on chaitu's idea"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"By reading the question, i can assume that there are no duplicate values present , but there is a question whether the array contain the numbers in sequential form (1,2,3,4,5...) or they are arranged in random form (9,8,3,50...) ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int findMissingNum(int[] a)  {   int[] b= new int[100];   int r =0;   for (int i =0;i<99;i++)    r^=a[i];   for (int i=0;i<100;i++)   {    b[i] = i+1;    r^=b[i];   }   return r;    }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=163739","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"34","title":"Given an int array and an int value. Find all pairs in array that add up to value.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sort the array using any O(nlog(n)) algorithm.Then call the below function (O(n)) to find all qualified pairs. The overall complexity is O(nlog(n)) //----------------------------------------------------------// //Input: //a is the sorted array, //v is the target value //n is the length of the array //Output: //ind1 stores the index for the first elment in qualified pairs, //ind2 stores the index for the second elment in qualified pairs, //--------------------------------------------------------------// void PairSum(int a[],int v,int n,int ind1[],int ind2[]) { int l = 0; int r = n-1; int tempv; int i = 0; while (l{ tempv = a[l] + a[r]; if (tempv==v) { ind1[i] = l; ind2[i] = r; ++i; if (a[r-1]==a[r]) --r; else ++l; } elseif (tempv>v) { --r; } else { ++l; } } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Question is not clear, please explain"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Question is not clear, please explain"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Given an Array of n integers, say A, and an integer S, find all pairs (i,j) such that A[i]+ A[j] = S.  clearer?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be done using a hashtable. For each number, check if (value - array[i]) exists in the hash, if not then add array[i] in the hashtable. Keep going through the array, until you find the pair which adds up to the value given. For example: if value = 20 and array is: 2, 15, 8, 10, 18. Start from 2, (20-2)=18, Check is 18 exists in the hashtable, if no, then put(2) into the hashtable. Go to 15, then 8, then 10 and then finally when you come to 18, check (20-18) = 2 exists, it does,return 2 and 18. This can be done in O(n) with extra storage."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1-first sort the array 2-then take two pointers say first and last   while(first  do       if(arr[first]+arr[last]         first++       else if(arr[first]+arr[last]>.sum)          last--       else              print both numbers       done"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For all the sorting guys, remember you need to record the index of each element before you sort the array. Since you have sorted it, check the maximum and minimum against the value first to see if you need to do something else. Hashtable does not make sense if you do define its range or hash function."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Maybe shambu1234 has the best solution provided it is not the indices that is asked. If it's just the numbers whose sum is 'S' fine."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Global(n,m,k,A[n]); void main() {  SORT(A);  for(i=0;i if(A[i]>k)  {   n=i-1;   break;  }  for(i=0;i {   if(A[i]==k)   {    PRINT(A[i]);    break;   }   if(A[i]>k)   break;   if(A[i]  {    sum= A[i];    m=0;    Pair(i+1,sum);    if(m==1)    PRINT(A[i]);   }  } }  void Pair(int p, int add) {  for(int i=p;i {   if(add+A[i]==k)   {    m=1;    PRINT(A[i]);    return;   }   if(add+A[i]  {    Pair(i+1,add+A[i]);    If(m==1)    {     PRINT(A[i]);     return;    }   }   If(add+A[i]>k)   return;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Tom's answer is so far the best. LOLer, it can fine all possible pairs, not just one."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This solution runs in O(N log N)  public static void findPairs(int[] a, int val){   for (int i = 0; i < a.length; i++) {    int diff = Math.abs(val - a[i]);    if(BinarySearch.search(a, a.length, 0, diff) != Integer.MIN_VALUE){     System.out.println(a[i] + \", \" + diff);    }   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"is it in  usa or India? How many years of experience and what is the salary?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Its in USA. 12-18 months of exp. It is rude to ask Salary information."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please write your answers. That would help us. Thanks in advance. -"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Create a hashtable from this array.  foreach x in array N   check (k-x) in the hashtable   if yes, x and k-x are a pair foreach end"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"another way might be... int size = array.size; for(int index = 0; i< size; i++) {      for(int j = i+1; j< size; j++)      {          if(array[i] + array[j] == k)          {             System.out.println(array[i]  + \"+\" + array[j] + \"are equal to \" + k);          }      } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this is an NP-hard problem. google for subset sum problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the Numbers are given DISTINCT, then this'll work  1) sort array a 2) first = 0, last = a.size()-1 3) while ( first < last) 3.0)     sum  = a[first] + a[last] 3.1)     if(sum  == k ) 3.15)              printf a[first],a[last] 3.2)               first++; 3.3)               last--; 3.4)     else 3.5)               if ( sum > k) last--; 3.6)               else first++; 4) end"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it's a NP-Complete problem...... so technically no polynomial time algo for this... so all ya drooling around O(n) or log n or n^2.... take a chill pill... u all are wrong ;) Look for \"Subset sum problem\" on Wikipedia."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  using namespace std;  int main() { int intarray[]={2,4,5,3,7,8}; list mylist; list::iterator it; list::reverse_iterator rit; mylist.assign(intarray,intarray+6);//assiging the numbers from the given array. int first=0; int last=mylist.size()-1; mylist.sort();//sorting the list. cout<<\"Enter the target number\"<int targetsum; cin>>targetsum; it=mylist.begin(); rit=mylist.rbegin(); while(first{ if((*it)+(*rit){ it++; first++; } else if((*it)+(*rit)>targetsum) { rit++; last--; } else { cout<<\"Pair-->\"<<(*it)<<\":\"<<(*rit)<cout<<\"Pair-->\"<<(*rit)<<\":\"<<(*it)<it++; rit++; first++; last--; } } /*for(it=mylist.begin();it!=mylist.end();it++) { cout<<*it<}*/ } ------------------------------------------------------------------------------------------------------------------------------ Output: Enter the target number 7 Pair-->2:5 Pair-->5:2 Pair-->3:4 Pair-->4:3   Sorting in the worst case takes O(nlog n) Printing the pairs of numbers takes O(n) Duplicate values are printed only once."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class Pair{     int a, b;          public pair(int a, int b){         this.a = a;         this.b = b;     } }  public findsum(int[] a, int k){     int left=0, right=a.length-1;     ArrayList set = new ArrayList();          Arrays.sort(a);          while(left < right){         if(a[left] + a[right] > k){             right--;         }else if(a[left] + a[right] < k){             left++;         }else{                        set.add(new Pair(left, right));             left++;             right--;         }     }          for(Pair p : set){         System.out.println(\"(\" + p.a + \", \" + p.b + \")\");     } }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13870747","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"34","title":"Find the nth most frequent number in array","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"I think we can  (i) store the occurence of every element using maps in C++  (ii) build a Max-heap in linear time of the occurences(or frequence) of element and then extract upto the N-th element, Each extraction takes log(n) time to heapify. (iii) we will get the frequency of the N-th most frequent number (iv) then we can linear search through the hash to find the element having this frequency.  Time - O(NlogN) Space - O(N)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What about other elements in the array ?? They may also repeated in the array ??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. add to map with number as the key and its frequency as the value O(n) 2. get the values from the map as list and do kth select algorithm  O(log n);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This comment has been deleted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since we don't know what is size of Array, Hashing will be tedious and space consuming. I think we can create a augumented tree of field key as frequency and Value storing number."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@Vyshanvi : How you are constructing map with frequency as a key ????"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Maintain a HashMap to store the number as key with its count as value. Use two other variables to keep track of the max count and its corresponding key.  For ex:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int a[10]={1,2,3,2,5,6,1,2,3,4}; map mymap; map::iterator itr;  for(int i=0;i<10;i++) {  itr = mymap.find(a[i]);  if(itr != mymap.end()) //already element is saved  {   //increament count for occurence     mymap[a[i]]=itr->second + 1;  }  else   mymap.insert(pair(a[i],1));  // first time inserting in map }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"HashMap solutions looks promising since the complexity is o(n) + o(logn).. if we are using a BST, it is a complex process to fetch the highest frequency element at last.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include int  a[]={1,2,3,3,1,1,1,1,3,2,2,}; void count() {int i,max=INT_MIN; int n=sizeof(a)/sizeof(int); int *b=calloc(sizeof(int),n); for(i=0;i{ b[a[i]]=b[a[i]]++; if(max < b[a[i]] ) {   max=b[a[i]]; }  } printf(\"%d\\n\",max); }  int main() { count(); return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n \nstruct rec \n{ \n int num; \n unsigned int count; \n}; \n \n \nint arr[]={2,4,2,1,0,4,4,5,5,4,4,0,2}; \n \n \nvoid qsortX(int*a,int low,int high) \n{ \n int i,j; \n int key; \n int mid=(low+high)/2; \n \n key=a[mid]; \n i=low;j=high; \n \n do \n { \n  while(a[i]key)j--; \n  if(i<=j) \n  { \n   int tmp=a[i]; \n   a[i]=a[j]; \n   a[j]=tmp; \n   i++;j--; \n  } \n }while(i<=j); \n \n if(ilow) qsortX(a,0,j); \n \n return; \n} \n \nvoid sort(int* a, int l) \n{ \n qsortX(a,0,l-1); \n \n return; \n} \n \nvoid qsortS(struct rec* a,int low,int high) \n{ \n int i,j; \n int key; \n int mid=(low+high)/2; \n \n key=a[mid].count; \n i=low;j=high; \n \n do \n { \n  while(a[i].count>key)i++; \n  while(a[j].countlow) qsortS(a,0,j); \n \n return; \n} \n \nvoid sortS(struct rec* a, int l) \n{ \n qsortS(a,0,l-1); \n \n return; \n} \n \n \n \nvoid printarr(int* a,int l) \n{ \n int i; \n  \n for(i=0;i=n) \n { \n  sortS(rec_arr,j); \n  printf(\"%d occurence is of number %d %d times\\n\",n,rec_arr[n-1].num,rec_arr[n-1].count); \n } \n else \n  printf(\"the number given dosen't exist\\n\"); \n   \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include main() {  int i,j,b,n,count=1;  int a[100];  printf(\"given the array size\\n\");  scanf(\"%d\",&n);    printf(\"given array elements\\n\");  for(i=0;i scanf(\"%d\",&a[i]);        for(i=1;i<=n;i++)       for(j=0;j    {      if(a[j]>a[j+1])      {       b=a[j+1];       a[j+1]=a[j];       a[j]=b;      }     }   for(i=0;i{  if(a[i]==a[i+1])     count++;     else  {   printf(\"frequence of element %d  ==  %d\\n\",a[i],count);           count=1;  } }   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/**    * 1. Stored array of values into TreeMap with key as value and value as count of that occurances    * 2. Get the the list of values from TreeMap and stored them in TreeSet    * 3. All the values will store in desending order    * 4. With the TreeSet , you have the value and get the key from the value using EntryMap.    */            int array[]={12,12,13,14,133,155,166,134,123,123,1234,12345};      SortedMap sMap = new TreeMap();   sMap.put(array[0], 1);   int temp;   for (int i = 1; i < array.length; i++) {        if(sMap.get(array[i])!=null){     temp=sMap.get(array[i]);     sMap.put(array[i],temp+1);    }else{     sMap.put(array[i],1);    }    temp=0;   }   System.out.println(sMap);      TreeSet treeSet=new TreeSet(sMap.values());   System.out.println(treeSet.toArray()[1]);            for (Entry entry : sMap.entrySet()) {            if (entry.getValue().equals(treeSet.toArray()[1])) {             System.out.println(\"1st higest value is\"+ entry.getKey());            }        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int FrequentNumber(int[] a, int frequency) { \n \n  HashMap frequencyMap = new HashMap(); \n  int temp; \n  for (int i = 0; i < a.length; i++) { \n   temp = 1; \n   if (frequencyMap.containsKey(a[i])) { \n    temp = frequencyMap.get(a[i]) + 1; \n    frequencyMap.put(a[i], temp); \n   } else { \n    frequencyMap.put(a[i], temp); \n   } \n  } \n \n  ArrayList values = new ArrayList( \n    frequencyMap.values()); \n  Collections.sort(values); \n \n  int index = values.get(values.size() - frequency); \n  for (Entry e : frequencyMap.entrySet()) { \n   if (e.getValue().equals(index)) \n    return (int) e.getKey(); \n  } \n  return 0; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"count = input(\"Enter the count\") index = 0 numarray = [] for index in range(count):     numarray.append(input()) #number = input(\"Enter the number\") number = 0  def nthOccurence(arr, num):     arrlen = len(arr)     for index in range(arrlen):         index2 = index +1          count  = 1         for index2 in range(index2,arrlen):             if arr[index] == arr[index2]:                 count=count+1                 arr[index2]=' '         if arr[index]!=' ':             print \"occurence (%s,%s)\"  % (arr[index],count)              nthOccurence(numarray,number)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"count = input(\"Enter the count\") \nindex = 0 \nnumarray = [] \nfor index in range(count): \n    numarray.append(input()) \n#number = input(\"Enter the number\") \nnumber = 0 \n \ndef nthOccurence(arr, num): \n    arrlen = len(arr) \n    for index in range(arrlen): \n        index2 = index +1  \n        count  = 1 \n        for index2 in range(index2,arrlen): \n            if arr[index] == arr[index2]: \n                count=count+1 \n                arr[index2]=' ' \n        if arr[index]!=' ': \n            print \"occurence (%s,%s)\"  % (arr[index],count) \n             \nnthOccurence(numarray,number)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"# include  \n# include  \n \nvoid main () \n{ \nint i,j,arr[256],size; \nchar *text; \n \nprintf(\"Enter the text : \"); \nscanf(\"%s\",text); \ni = 0; \n \nfor (i=0;i<255;i++) \n{ \narr[i]=0; \n \n} \ni=0; \n \nwhile(text[i] != '\\0') \n{ \n arr[(int)text[i]]++; \n i++; \n} \n \nfor(i=0;i<255;i++) \n{ \n if( arr[i]>0) \n { \n printf(\"%c : %d\\n\",(char)i,arr[i]); \n } \n} \n \nprintf(\"\\n%s\",text); \n \n \ngetch (); \nclrscr(); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"I agree with Rishi, Since we don't know size of array and range of numbers in array its better to use tree with field Value and frequency. Traverse each element of array and add in BST with frequency 1 if it does not exits already. In case if that number already exist then just increase its frequency by 1. Once all array traversed, we can use Traverse mathod to find the number with hightest frequency."}]}}]