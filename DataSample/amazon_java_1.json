[{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13580661","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"39","title":"Q1. F2F Round 1 Amazon(Bangalore)  Given a character array as input. Array contains only three types of characters 'R', 'G' and 'B'. Sort the array such that all 'R's comes before 'G's and all 'G's comes before 'B's.  Constraint :- No extra space allowed(except O(1) space like variables) and minimize the time complexity. You can only traverse the array once.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"13","title":"en.wikipedia.org/wiki/Dutch_national_flag_problem"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"threeWayPartition(char data[], int size) \n{ \n   int p = 0; \n   int q = size-1; \n   int i ; \n \n  char t; \n        for ( i = 0; i <= q;) \n        { \n                if (data[i] == 'R') \n                { \n                      t = data[i]; \n                        data[i] = data[p]; \n                        data[p] = t; \n                        ++p; \n                        ++i; \n                } \n \n                else if (data[i] == 'G') \n                { \n                        t = data[i]; \n                        data[i] = data[q]; \n                        data[q] =t; \n                        --q; \n                } \n                else \n                { \n                        ++i; \n                } \n        } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Just maintain count of R, G, and B. And then overwrite whole array. Some thing like below"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"int main() {     int r,g,b,i; char x[] = {'r','r','g','g','b','r','r','r','g','g','b','b','b','g','g','r'} for (i = 0;r = 0,g=0,b=0; x[i] != '\\0' ;} {    if(x[i] == 'r')            r++;    else if(x[i] == 'g')         g++;    else        b++;                  } memset(x,'r',r); memset(x+r,'g',g); memset(x+r+g,'b',b); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void sortAnArrayInParticularOrder(char [] array){   int indexOfR = 0;   int indexOfB = array.length-1;       for(int i=0;i<=indexOfB;){        if(array[i]=='R'){         swap(i,indexOfR,array);         indexOfR ++;         i++;       } else if (array[i]=='B'){         swap(i,indexOfB,array);         indexOfB --;        }else{         i++;        }       }            for(char c:array){     System.out.println(c);    }       }   private static void swap(int i, int j, char[] array) {   char temp = array[i];   array[i]=array[j];   array[j]=temp;     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int begin=0; int end=n-1; while(begin{  if (A[begin]=='G')  {   temp=begin+1;   while(A[temp]=='G')    temp++;   if(temp==end)    return;   else   {    swap(A[temp], A[begin])   }     }  if(A[begin]=='B')  {   swap(A[begin],A[end])  }  if(A[begin]=='R')  {   begin++;  }   if(A[end]=='G')  {   temp=end-1;   while(A[temp]=='G')    temp--;   if(temp==begin)    return;   else   {    swap(A[temp], A[end])   }  }  if(A[end]=='R')  {   swap(A[end],A[begin])  }  if(A[end]=='B')  {   end--;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int begin=0; int end=n-1; while(begin{  if (A[begin]=='G')  {   temp=begin+1;   while(A[temp]=='G')    temp++;   if(temp==end)    return;   else   {    swap(A[temp], A[begin])   }     }  if(A[begin]=='B')  {   swap(A[begin],A[end])  }  if(A[begin]=='R')  {   begin++;  }   if(A[end]=='G')  {   temp=end-1;   while(A[temp]=='G')    temp--;   if(temp==begin)    return;   else   {    swap(A[temp], A[end])   }  }  if(A[end]=='R')  {   swap(A[end],A[begin])  }  if(A[end]=='B')  {   end--;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"3-way quick sort with G as pivot."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"3-way quick sort with G as pivot."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"That took longer than it should have.  C#  The 'trick' was that you can only traverse once, but you don't necessarily need to increment your enumerator."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void swap(char * to,char *from) {      char t = *to;      *to = *from;      *from = t; }  void arrange(char  str[] ) {     //if(!str) return ;    cout<<\"before :\"<<   int n = strlen(str);    int last[3]= {0,0,n-1};      for(int i=0;i   {       if(str[i] == 'R' )        {          swap(&str[last[0]],&str[i]);          ++last[0] ;       }       else if(str[i] == 'B' && i      {          swap(&str[i],&str[last[2]]);          --last[2];       }       else if(str[i] == 'G' )       {           last[1]=i ;         }       cout<<\"Iteration :\"<<<\" \"<   }         cout<<\"after :\"<<}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nusing namespace std; \n \nvoid swap(char *x, char *y) \n{ \n cout<<\"Entered swap\"; \n char temp; \n temp = *x; \n *x=*y; \n *y=temp; \n cout<<\"Finished swap\"; \n} \n \nint main() \n{ \n char a[]=\"RRRRGGGGBBBB\"; // Desired output RGBRGBRGBRGB \n int size = sizeof(a)/sizeof(a[0]); \n  \n int low =0; \n int mid =0; \n int high = size-2; \n cout<<<<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void rearrange(char *s) \n{ \n    int i; \n    int length = strlen(s); \n    int firstp=0; \n    int lastp=length-1; \n    int flag = 0; \n    if(length>1) \n    { \n        while (firstp = 0 && s[lastp] == 'B') \n            lastp--; \n        i=firstp; \n        while (i<=lastp)  \n        { \n            i = i < firstp? firstp: i; \n            if(s[i] == 'R') \n            { \n                s[i] = s[firstp]; \n                s[firstp] = 'R'; \n            } \n            else if (s[i] == 'B')  \n            { \n                s[i] = s[lastp]; \n                s[lastp] = 'B'; \n            } \n            else \n                i++; \n            while (firstp = 0 && s[lastp] == 'B') \n                lastp--; \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"keep a red pointer from start, and blue pointer from end. Move the red pointer forward until you fing a non R character. Move the blue pointer backwards until you find a non B character. Initialize a green character from the current red position and keep moving until you find R/B. if you find R/B swap them and increase/decrease the corresponding pointer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about an in-place Merge sort?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"low=0; \n    high=n;//size of array; \n    for(i=0;i='G') \n              swap(arr[i],arr[high--]); \n           else i++; \n               \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void threeWayPartition(int data[], int size, int low, int high) {   int p = -1;   int q = size;   for (int i = 0; i < q;) {     if (data[i] < low) {       swap(data[i], data[++p]);       ++i;     } else if (data[i] >= high) {       swap(data[i], data[--q]);     } else {       ++i;     }   } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  int main()  {  char data[] = \"BRBRBRBGRGRGRRGRGRGRBRBRBR\";  int size = sizeof(data)/sizeof(data[0]);  int index= 0;   int gFirstPosition;  int bFirstPosition;   int gVisit= 0;  int bVisit= 0;    printf(\"input:  %s\\n\", data);   while (index < size)  {   if (data[index] == 'R')   {    if (gVisit == 1 && bVisit == 1)    {     data[gFirstPosition]= 'R';     data[bFirstPosition]= 'G';     data[index]= 'B';     gFirstPosition++;     bFirstPosition++;    }    else if (gVisit == 1 && bVisit == 0)    {     data[gFirstPosition]= 'R';     data[index]= 'G';     gFirstPosition++;    }    else if (gVisit == 0 && bVisit == 1)    {     data[bFirstPosition]= 'R';     data[index]= 'B';     bFirstPosition++;    }     }   else if  (data[index] == 'G')   {    if (gVisit == 0)    {     gFirstPosition= index;     gVisit= 1;    }        if (bVisit == 1)    {     data[bFirstPosition]= 'G';     data[index]= 'B';     if (gFirstPosition > bFirstPosition)      gFirstPosition= bFirstPosition;      bFirstPosition++;    }       }   else if  (data[index] == 'B')   {    if (bVisit == 0)    {     bFirstPosition= index;     bVisit= 1;    }   }   index++;  }    printf(\"output: %s\\n\", data);   return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Arrays;   public class SortRGB {      public static void main(String[]args){   char[]arr={'R','G','B','R','B','R','R','B','R','G','B','B','B','R','R','G','B'};      sortRGB(arr,'G','G');   System.out.println(Arrays.toString(arr));  }   private static void sortRGB(char[] arr, char key1, char key2) {   int p=0;   int size=arr.length-1;   int q=size;   for(int i=0;i<=q;){    if(arr[i]>key1){          swap(arr,p,i);     p++;     i++;    }    else if(arr[i]         swap(arr,i,q);     q--;    }    else{     i++;    }   }     }   private static void swap(char[] arr, int p, int q) {   char temp=arr[p];   arr[p]=arr[q];   arr[q]=temp;     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n \nint main() \n{ \n char c[] = {'r','g','b','g','b','g','b','r','r','b','g','r','r','b','b','g','r'},temp; \n int r=0,g=0,b=0,i; \n for(i=0;i<(sizeof(c)/sizeof(c[0]));i++) { \n  if(c[i] == 'r') { \n   temp = c[r]; \n   c[r] = c[i]; \n   c[i] = temp; \n   r++; \n   g++; \n   b++; \n  } \n  else if(c[i] == 'g') { \n   temp = c[g]; \n   c[g] = c[i]; \n   c[i] = temp; \n   g++; \n   b++; \n  } \n  else if(c[i] == 'b') { \n   temp = c[b]; \n   c[b] = c[i]; \n   c[i] = temp; \n   b++; \n  } \n } \n for(i=0;i<(sizeof(c)/sizeof(c[0]));i++)  \n  printf(\"%c\",c[i]); \n printf(\"\\n\"); \n return 0;   \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"yup similar to sort 0,1,2 or dutch national flag algo."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"yup similar to sort 0,1,2 or dutch national flag algo."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"yup similar to sort 0,1,2 or dutch national flag algo."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15210763","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"37","title":"You have a web server's log that records for each user the URL that he accessed. Example format:","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Traverse the log, put every record into a hashtable, userId is the key, the list of url is the value. For the example Jim updated, the hashtable looks like: 186: A, C, C, B, A 187: B, A, C, C 188: B, A, C 189: A, D, B, A, C  Compare every pair of list, it's the longest common subsequence problem. Use dynamic programming to solve it. Time complexity: build hashtable: n + compare every pair of list: k^2 * (n/k) when k is the number of userId, n/k is the average length of the list. The total running time is nk."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what do you mean by common sequence? can you give the expected result of your example?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Divide the log lines by user (so you have a list of URLs for each user). Find all common subsequence of user-1 and user-2 and sort them by decreasing order. For each common subseuqnce found above, search for it in the list of each user. If it's not found then eliminate it. The first subseuquence that's present in the lists of all the users is the longest common subseuqnece. This would take O(N)* where N is the log length."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Isn't finding longest common subsequence for more than 2 sequences NP hard?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Approach :  Store as HashMap> where key is the url and set is the number of unique user who have visited this site.Maintain another HashSet to get the count of unique user.All of the above work is O(n).  Then traverse through the HashMap and check if the size of the HashSet is equal to the count of the unique user id...if yes then this URL goes to the max subset(assuming the question asks for URL visited by all user)....This also takes O(n) time. So total time complexity is O(n)....  Please comment in case I have understood something wrong....."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"my solution for this"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I have written the code in Java. But this would only find sequences specific to the URL given. For example, it would just store \"abc\" from the below file content in HashMap and would only use that to compare and increase the count. It would ignore whatever is present after abc."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13579663","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"47","title":"Q2. F2F Round-1, Amazon(Bangalore)  Given an array of integers having the property that first that array is strictly increasing then it is strictly decreasing, You have to search for a given number.  Constraint: Minimize the complexity","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"since the array is strictly increasing first then strictly decreasing, therefore for the increasing part of the array if, i+1=j then definitely a[i] we can use modified binary search to search the array.  consider the array int[] arr = new int[] {1,3,5,7,19,221,132,56,8,6,4,2,1,-3,-17};  here we need to find k such that, for three consecutive elements i, k, j, a[i] a[j]  step 1 :   so, first we need to find the ending of increasing part of the array, lets the end index of increasing part as k.  use a modified binary search to find k"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Find the maximum elements in array - O(logn)  Now if element  > max - Not found  Form two sorted array and do binary search.  Total time O(logn)+O(logx)+O(logn-x)~ OLog(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This question is same as searching in a rotated sorted array"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.iterate over array to find the max by comparing arr[i] and arr[i+1] where arr[i] >arr[i+1] 2.if key is greater than arr[i] then search in upper index  of array 3.else search in lower index"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.iterate over array to find the max by comparing arr[i] and arr[i+1] where arr[i] >arr[i+1] 2.if key is greater than arr[i] then search in upper index  of array 3.else search in lower index"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"find out the critical point and then recursively search in both part"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"find out the critical point and apply binary search"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we can reduce the complexity to O(logn) by finding our the highest number also by using binary search..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"two points at a time first and the last  step 1:if(arr[start+i]==k || arr[end-i]==k) found k; else recurse(arr,start+i,end-i)  O(lgn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"two points at a time first and the last  for i 0 to len/2 step 1:if(arr[start+i]==k || arr[end-i]==k) found k; else recurse(arr,start+i,end-i)  O(lgn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int getMaxFromRotatedSortedList(int [] array){   int start = 0;   int end = array.length -1;   while(start<=end){    int mid = (start+end)/2;       if(array[mid]>array[mid+1]&&array[mid]>array[mid-1])     return mid ;     if(array[mid]     start = mid+1;      }else {      end = mid -1;     }    }    return -1 ;  }   public static int orderbinarySearch(int[]array, int start, int end,int key,boolean order){   while(start   int mid =(start+end)/2;    if(array[mid]==key)     return mid;    if(order){       if(key    end = mid;       else     start = mid +1;    }else{       if(key>array[mid])     end = mid;       else     start = mid +1;       }}   return -1;    }   public static void main(String [] args){   int [] newArray ={1,2,3,4,5,6,7,8,43,100,107,111,120,89,78,67,56,34,23,10};   int maxElementIndex = getMaxFromRotatedSortedList(newArray);   System.out.println(\"max element is\"+getMaxFromRotatedSortedList(newArray));   int c = orderbinarySearch(newArray,0,maxElementIndex,23,true);   boolean found = false;   if(c==-1){    c = orderbinarySearch(newArray,maxElementIndex,newArray.length-1,23,false);    if (c!=-1) found = true ;   }else{    found = true;   }     if(found){     System.out.println(\"the index of the key is\"+c);   }else {    System.out.println(\"key is not present \");   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int getMaxFromRotatedSortedList(int [] array){   int start = 0;   int end = array.length -1;   while(start<=end){    int mid = (start+end)/2;       if(array[mid]>array[mid+1]&&array[mid]>array[mid-1])     return mid ;     if(array[mid]     start = mid+1;      }else {      end = mid -1;     }    }    return -1 ;  }   public static int orderbinarySearch(int[]array, int start, int end,int key,boolean order){   while(start   int mid =(start+end)/2;    if(array[mid]==key)     return mid;    if(order){       if(key    end = mid;       else     start = mid +1;    }else{       if(key>array[mid])     end = mid;       else     start = mid +1;       }}   return -1;    }   public static void main(String [] args){   int [] newArray ={1,2,3,4,5,6,7,8,43,100,107,111,120,89,78,67,56,34,23,10};   int maxElementIndex = getMaxFromRotatedSortedList(newArray);   System.out.println(\"max element is\"+getMaxFromRotatedSortedList(newArray));   int c = orderbinarySearch(newArray,0,maxElementIndex,23,true);   boolean found = false;   if(c==-1){    c = orderbinarySearch(newArray,maxElementIndex,newArray.length-1,23,false);    if (c!=-1) found = true ;   }else{    found = true;   }     if(found){     System.out.println(\"the index of the key is\"+c);   }else {    System.out.println(\"key is not present \");   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the problem complexity is o(log n) the problem is divided into 2 parts. 1)finding maximum point 2)applying binary search on each side of maximum index. to find maximum point: divide the array into 3 parts using n/3 and 2n/3 as indexes. if(a[n/3]then maximum present in the a[n/3] to a[n]; else the maximum present in a[1] to a[2n/3] repeat the  process the complexity for this is o(log n) because the array size is decrimented each time by 1/3rd. now apply binary search on both sides of maximum element..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algo to find the point of inflection, once you get it do binary search in individual parts of the array, time complexity is O(log(n))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algo to find the point of inflection, once you get it do binary search in individual parts of the array, time complexity is O(log(n))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can be done in order of logn  first find point of inflection using a method similar to binary search then call binary search on the left list differently and call binary search on the right list differently"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can be done in order of logn  first find point of inflection using a method similar to binary search then call binary search on the left list differently and call binary search on the right list differently"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is a Bitonic Sequence. Let Mid = (start + end)/2, divides the array in two halves. In this case two cases could happen:  1. The Array is Exactly Increasing/Decreasing in first half and Exactly Decreasing/Increasing in the second half.  2. The Array is Decreasing/Increasing in one half and it is again Bitonic in the other half.  So basically we perform Binary search in the Monotonic sequence and perform Sequential search in the  Bitonic sequence.  Best Case Order : O(log n/2)) + O(log (log n/2)) i.e., Binary search in both halves (Case 1) Worst Case :  O(log n/2) + O(n/2) (Case 2: Which again can be checked recursively and search can be minimized)  Now Major part is to check if the Half is Strictly Increasing or decreasing :  isFirstHalfIncreasing = A[start]< A[mid-1] && A[mid-1][mid] isFirstHalfDecreasing = A[start] > A[mid-1] && A[mid-1] > A[mid] isSecondHalfIncreasing = A[mid] < A[mid+1] && A[mid+1] < A[end] isSecondHalfDecreasing = A[mid] > A[mid+1] && A[mid+1] > A[end]   Algorithm is:  Boolean Sequential_Search(A,start,end,element) {                              if(start == end ) return A[start]==element;            mid = (start+end)/2;            if(A[mid == element]) return true;            return ( isFirstHalfIncreasing OR isFirstHalfDecreasing                                            ?  Binary_Search(A,start,mid-1,element)                                            || Sequential_Search(A,start,mid-1,element) )                   OR (isSecondHalfDecreasing || isSecongHalfIncreasing                                           ? Binary_Search(A,mid+1,end,element)                                          || Sequential_Search(A,mid+1,end,element))  } //End of Sequential Search..  Boolean Binary_Search(A,start,end,element) {                if(start == end ) return A[start]==element;               mid = (start+end)/2;               if(A[mid == element]) return true;             return Binary_Search(A,start,mid-1,element)   ||                                                              Binary_Search(A,mid+1,end,element)   } // End of Binary Search..     Please Correct me if I am wrong. Also please if some one could caluclate the average case, that would be great"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Find the maximum elements in array - O(logn)  Now if element  > max - Not found  Form two sorted array and do binary search.  Total time O(logn)+O(logx)+O(logn-x)~ OLog(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it can be done in O(logn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it can be done in O(log n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class ArrayExample1 { \n \n int[] arr=new int[]{1,2,3,4,5,77,88,90,-56,-45,-23}; \n  \n public void showElements(){ \n  int no=0; \n  for(int i=0, j=1;j"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Store the complete array in hashtable..with numbers. By using Contains value check if the given number exists.. Storing elements in hashtable takes o(n).and..hashtable lookup is o(1)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My idea is same as everyone else: (1) Find the position of the maximum with modified binary search. Call this the \"climax\". (2) Perform binary search from beginning to climax (3) Perform binary search from climax to end  Each is O(logn) so altogether still O(logn). Note that I am also accommodating for the case when the climax is at the beginning or end of the array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #include   int main() {      int arr[] = {10,12,14,17,18,16,11,9,8};     int low = 0,         mid ,         high = lengthof(arr),  // length of array         low1,         low2,         high1,         high2;     int k ;      int temp_low = low,         temp_high = high;      int find = 0;      printf(\"please enter the number to search \\n\");     scanf(\"%d\",&k);      mid = (low + high)/2;      while( low < high)      {                  mid = (low + high) /2;         if ((arr[mid -1] < arr[mid]) && (arr[mid] < arr[mid + 1]))         {            low = mid + 1;         }         else         {            if ((arr[mid -1] > arr[mid]) && (arr[mid] > arr[mid + 1]))            {                 high = mid + 1;            }            else            {               if ((arr[mid -1 ] > arr[mid]) && (arr[mid] < arr[mid + 1]))               {                   high1 = mid;                   low1  = temp_low;                    high2 = temp_high;//This is for descedning order                   low2  = mid + 1;                   break;               }               else               {                   high2 = temp_high;                   low2  = mid + 1;                    high1 = mid;                   low1  = temp_low;                   break;               }             }          }      }  printf( \"high1 = %d  low1 = %d high2 = %d  low2 = %d\\n\", high1,low1, high2, low2);     /* check the number in ascending part*/    while( (low1 <= high1) && (find == 0))    {         mid = (low1 + high1)/2;       if(arr[mid] == k)       {         find = 1;         break;       }       else if (arr[mid] > k)       {         high1 = mid - 1;       }       else if(arr[mid] < k)       {         low1 = mid + 1;       }    }   /* check the num in desc part*/    while ((low2 <= high2) && (find == 0))    {        mid = (low2 + high2) / 2;         if (arr[mid] == k)        {          find = 1;          break;        }        else if (arr[mid] > k)        {           low2 = mid + 1;        }        else if (arr[mid] < k)        {           high2 = mid - 1;        }    }      if (find != 0)    {       printf(\"find postion is : %d \\n\", mid);    }    else    {       printf(\"%d is not present in the array\\n\", k);    }     return(0);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"How about this approach:  1. First find the highest element; If there are elements i,j such that a[i]>a[j], obviously 'i' marked the end of the first list. O(n); 2. Do a binary search on these elements. If it is found, return it. [O(logn)].  3. If it is not there, then search in the decreasing part; For this multiply the numbers 'i+1' till last element with -1 and also the key with -1; O(n) 4. Search using binary search for the key; O(log n); 5. If found, return else terminate with a message saying that the key is not found. So, overall complexity is O(n) + O(log n ) + O(n) + O(log n ) ; 6. Final complexity, is O( n );  If you feel that I need to include anything here, do let me know.  thanks, Pavan"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public static int MaxElementPosition(int[] input, int search)         {             int start = 0, end = input.Length - 1;             int maxPosition = 0;             while (true)             {                 int n = end - start + 1;                  // only 2 elements                 if (n <= 2)                 {                     if (input[end] > input[start])                     {                         maxPosition = end;                     }                     else                     {                         maxPosition = start;                     }                     break;                 }                  if (input[start + n / 3] <= input[start + 2 * n / 3])                 {                     start += n / 3;                     end = start + n - 1;                 }                 else                 {                     end = start + 2 * n / 3 - 1;                 }             }              return input[maxPosition];         }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15033852","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"43","title":"Write a program that takes an array of numbers, and then prints out all the possible pairs of numbers that sum up to the value N.   E.g., if the array contains the numbers {0, 1, 2, 2, 3, 4, 5} and the target value N is 4, then the output would be (0, 4), (1, 3), (2, 2).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"By assuming array elements are sorted in ascending order, below is the algorithm(which will take care of duplicate elements as well)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"I think by \"pairs\" he means just 2 nos. summing to the value of N.  Store the values in a HashMap. Iterate over each value \"x\" in the array and find N-x in the HashMap. If found, you got a pair, store it in a HashSet (this will eliminate duplicates). Time: O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Time Complexity - O(n)  2 pointer approach. one starts at the end of the array and other at the end.  1)  if sum ( a[first pointer] , a[second pointer]) > N  move second pointer left 2)  if sum ( a[first pointer] , a[second pointer]) < N  move first pointer right  keep moving untill 2 pointers meet each other."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Solution in Python"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I'm thinking about {1,2,2,2,3} N=4 Let me rewrite the array to {1,2a,2b,2c,3} Shall we return (1, 3) (2a, 2b) (2a, 2c) (2b, 2c) ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This code also takes care of duplicates, unlike most of the solutions given here"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How long do you think that it's appropriate to think about this question ? And how long to write it?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The pairs only contain 2 numbers? Can it have more or less than two numbers?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for(int j=0;j<=num-1;j++) { int val=i[j]; int temp=num2-val; for(j=0;j<=num-1;j++) {  if(temp==i[j]) System.out.println(\"[\"+val+\",\"+temp+\"]\"); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. if you sort the array , then the running time is at least 0(nlogn). 2. Is all the number positive ?     if it was, we could count the appearance of 0,1,...N in O(n) running time, and let p(i) be the frequency of i , since 0+N==N,1+(N-1)==N,...then we have  min(a(i),a(N-i)) pairs of (i,N-i);    if there're negative numbers, in O(n) running time(the first scannning) we can get each of them,and you can store its frequency too, the remaining similar. While you may scan the array twice, you still got the 0(n) running time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #define MX 7 //max no of array //target is value sum value //let assume given array sequence[MX] ={0, 1, 2, 2, 3, 4, 5};//assuming array is not sorted  int main() { int array[MX]; for(count = 0; count{      array[MX] = 0; } for(count = 0; count{     array[sequence[count]] = 1; } for(count = 0; count{   index = target - sequence[count];   if(index > 0)   {        if(array[index] == 1)        {              print(pair(sequence[count],index));               array[index] = 0;               array[sequence[count]] = 0;       } } } return 0; }  complexity : 0(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class PrintPairsThatSumUpToValueInArray {   public static void main(String[] args) {   PrintPairsThatSumUpToValueInArray pps = new PrintPairsThatSumUpToValueInArray();   int[] array = { 8, 0, 1, 2, 2, 3, 3, 3, 4, 5, 1, 4, 6, 4, 4, 4, 5 };   int TARGET_SUM = 10;   Map map = pps.loadMap(array);   pps.printPairsFromMap(TARGET_SUM, map);  }   public Map loadMap(int[] array) {   Map map = new HashMap<>();   for (int val : array) {    if (map.containsKey(val)) {     int count = (Integer) map.get(val);     map.put(val, ++count);    } else {     map.put(val, 1);    }   }   return map;  }   public void printPairsFromMap(int targetSum, Map map) {   Iterator itr = map.keySet().iterator();   while (itr.hasNext()) {    int key = itr.next();    int value = map.get(key);    if (key > targetSum)     continue;    int diff = targetSum - key;     if (!map.containsKey(diff))     continue;    else if (key < diff) {     System.out.println(\"(\" + key + \",\" + diff + \")\");    } else if (key == diff && value > 1) {     System.out.println(\"(\" + key + \",\" + diff + \")\");    }   }  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) {         final Map values = new HashMap();         final Map sumOfPair = new HashMap();          final int targetVal = 4;         int key = 0;         final int[] arrayOfNums = { 0, 1, 2, 2, 3, 4, 5 };         for (int i : arrayOfNums) {             values.put(key, i);             if ((values.containsValue(targetVal - i)) && ((targetVal - i) != i)) {                 sumOfPair.put(i, (targetVal - i));             }             key++;         }         Iterator> entries = sumOfPair.entrySet().iterator();         while (entries.hasNext()) {             Map.Entry entry = entries.next();             System.out.print(\"(\" + entry.getKey() + \",\" + entry.getValue()+\") \");         }     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void printPair(int arr[],int size,int sum) {  map traversed;  map::iterator it;  int i , remain;  for (i = 0 ; i < size ; i++)  {   remain = sum - arr[i];   it = traversed.find(remain);   if (it != traversed.end() && it->second > 0)   {    cout << \"\\n(\" << it->first  << \",\" << arr[i] << \")\" ;    traversed.erase(it);   }   if(it != traversed.end())traversed[arr[i]]=1;                 else (it->second)++  }   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming the array is sorted the following algorithm also works -  N - being the given sum.  1] Find x = sum(first , last)  2] if x = N print elts[first] and elts[last] and continue till u reach half the array.     if x < N then first++     if x > N then last--"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main (String args[]){      int[] num = {0, 1, 2, 2, 3, 4, 5};   int input = 4;   find(num,input);     }    public static void find(int[] num, int input){      for(int i=0;i   for(int j=0;j         if(num[j]+num[i]==input){            System.out.println(num[i]+ \" \" +num[j] + \" \"+ input);     }              }   }        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorting the array will give better time complexity than O(n^2). We can assume thant sorting is O(nlogn) + Iteration of the elements which are less than N (arr[i] + arr[j] < N) -  I can not say how much time it takes, but I believe that it is better than O(n^2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Time Complexity = N^2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here is the best simple solution:  public void findpairs(int ary[], int sum){ mapfind=new hashmap(); int i; for(i=0;ifind.put(ary[i],sum-ary[i]); } for(i=0;iif(find.containsValue(ary[i]){ system.out.println(\"here are the pairs\",+ary[i],sum-ary[i]); } else{ system.out.println(\"sorry no pairs\"); } } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In Python"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Time complexity: Worst case: (n) Space complexity: If we want distinct pairs then Worst case: (n) else its O(1).  External methods used: 1.) void sort(int array[]); //QUICK SORT avg case running time is nlog(n) 2.) int search(int array[], int key, int lowerBound, int upperBound); //BINARY SEARCH. returns the index of the found element.  Additional datastructures: 1.) implementation of Set interface. //This is to check duplicates."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int find(int a[],int start,int end,int num){ \n    while(startnum){ \n                          end--; \n                     } \n                     else{ \n                          start++; \n                     } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; \nimport java.util.List; \n \npublic class Test { \n public static void main(String[] args) { \n   \n  int[] values = {0,1,1,2,3,4,5,6}; \n  int target = 6; \n  outer: for(int i= 0; i sequence = new ArrayList(); \n   sequence.add(sum); \n   inner: for(int j = (values.length -1); j>i;j--){ \n     sum = sum+values[j]; \n    if(sum > target){ \n     sum = sum-values[j]; \n     continue inner; \n    } else if(sum <= target){ \n     sequence.add(values[j]); \n     if(sum == target){ \n      System.out.println(sequence); \n      sum = values[i]; \n      sequence.clear(); \n      sequence.add(values[i]); \n     } \n    } \n   } \n    \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Time Complexity = O(logN), if its sorted Array package careerCupJava;  public class SumWith2Numbers {   /**   * @param args   */  public static void main(String[] args) {   // TODO Auto-generated method stub      int arry[] = {0,1,2,2,3,4,5};   int i=0, j=arry.length - 1;   System.out.println(\"j=\"+j);   int sum=4;   while(i <= j)   {    int k = sum-arry[i];    if(k == arry[j])    {     System.out.println(\"pair pair=\"+arry[i]+arry[j]);     i++;     j--;    }    if( k < arry[j])    {     j--;    }   }   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"# include  \n# include  \n \nvoid all_sum_pair(int a[10],int start, int end, int suma) \n{ \n int tempa=0; \n if(start < end) \n { \n tempa = a[start]+a[end]; \n if(tempa == suma) \n { \n  printf(\"(%d, %d), \",a[start],a[end]); \n  all_sum_pair(a, start+1, end, suma); \n }else{ \n  all_sum_pair(a, start, end-1, suma); \n } \n } \n \n} \n \nvoid main () \n{ \nint arr[10]; \nint i,nn,j,temp,sum; \nnn=10; \nsum=5; \n \nprintf(\"Enter 10 Numbers in a column\\n\"); \n \nfor(i =0; i <10;i++) \n{ \n scanf(\"%d\",&arr[i]); \n} \n \n \n \nfor(i=1;i0 && arr[j]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public class PairNumber { public int[] array =new int[]{0,1,2,3,4,5); public void displayPairNumber(int  value){ array ={0,1,2,3,4,5); for (int i=0;i++;i<=value){   n=value;    if (i+n=value){    System.out.println(array(i)+,+array(n));   }   if (n==i){   break;  }   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Algo goes like this. Assuming array is sorted  1. point 1 reference to start of the array say i, 2nd reference to the end of the array say j 2. if a[i] + a[j] == N print pairs, else if a[i] + a[j] > N j-- else if a[i] + a[j] < N i++ till i < j  Thinking of better approach for un-sorted array"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13556672","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"46","title":"Q3. Written Exam Amazon(Bangalore)  Given a singly linked list which may or may not contain loop and loop may or may not start from the head node. Count the number of elements in the linked list.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"EDIT: The previous algo failed for some input cases. Thanks to @ buckCherry for pointing it out. Below is the fresh algo.  Find the start of the cycle through Floyd cycle detection algorithm.  The total number of nodes is the count of nodes that form cycle and count of nodes that are not part of cycle. If the list doesn't contain cycle, count of nodes that are part of cycle is zero. 1. Maintain two pointers called hare & tortoise. 2. move hare two steps &  tortoise one step until either both become equal or hare reaches NULL. 3. Move tortoise to the start of the list. Move tortoise  and hare step by step until their next node don't point to the same node( in case there is no cycle , hare will point to NULL. Ignore step#4 in this case). This next node is the starting node of the cycle. Meanwhile count the number of nodes that are not part of the cycle.  e.g. A->B->C->D->E->D The number of nodes that don't form cycle is 3.  4. Count the number of nodes in the cycle. Start tortoise from the starting node of the cycle and keep on moving until it doesn't reach its initial position. In the example explained in step#3, the number of nodes in the cycle is 2.  5. The answer is count in step#3 + count in step#4."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Traverse through the linked list. while traversing the linked list insert address(key) of each node into a hashmap.If it already exists in the hashmap then the linked list contains the loop. Maintain a counter to know the number of elements of the list while traversing..  Timecomplexity-O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"you can first find if there is cycle in linklist or not(Using 2 pointer floyd theorm) in O(n) time     (i)If it is present then that node(ie. start node for cycle) will be your check point.    while counting you need to look at.   otherwise it is a normal link list"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"you can first find if there is cycle in linklist or not(Using 2 pointer floyd theorm) in O(n) time     (i)If it is present then that node(ie. start node for cycle) will be your check point.    while counting you need to look at.   otherwise it is a normal link list"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"first check if der is a loop wid o(n) complexity floyds theorem.. if loop is der,mark the starting node of loop wid pointr p.now tak a pointr k pointing to first node of lnkd list.traverse it until u rech p,increment countr til dat.after dis loop,point k to the next sequential node.. again run loop and increment counter untill p is rechd.. counter is the no. of nodes we wanted.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"such looping in list is solved using 2 pointers. one is ptr->next and the other is ptr->next->next. at 1 point they both meet and there your counting ends. when there is no looping you can just go to the end of the list incrementing the count."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"such looping in list is solved using 2 pointers. one is ptr->next and the other is ptr->next->next. at 1 point they both meet and there your counting ends. when there is no looping you can just go to the end of the list incrementing the count."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"such looping in list is solved using 2 pointers. one is ptr->next and the other is ptr->next->next. at 1 point they both meet and there your counting ends. when there is no looping you can just go till the end of the list incrementing the count."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"such looping in list is solved using 2 pointers. one is ptr->next and the other is ptr->next->next. at 1 point they both meet and there your counting ends. when there is no looping you can just go till the end of the list incrementing the count."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"in the question it is specified that we may be given a link list which may or may not have a loop , and it may not start from the head. Now consider that we were given a list which does not cointain loop (singly linked list) and we did not start form the head , then starting from the point or node given to us there might be a possibility that there were nodes behind then how can we count them when finding the no. of elements in the list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"in the question it is specified that we may be given a link list which may or may not have a loop , and it may not start from the head. Now consider that we were given a list which does not cointain loop (singly linked list) and we did not start form the head , then starting from the point or node given to us there might be a possibility that there were nodes behind then how can we count them when finding the no. of elements in the list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"LinkedListNode FindBeginning(LinkedListNode head) {   LinkedListNode n1 = head;   LinkedListNode n2 = head;       // Find meeting point   while (n2.next != null) {     n1 = n1.next;     n2 = n2.next.next;     if (n1 == n2) {      break;     }   }   // Error check - there is no meeting point, and therefore no loop   if (n2.next == null) {    return null;   }   /* Move n1 to Head. Keep n2 at Meeting Point.  Each are k steps   /* from the Loop Start. If they move at the same pace, they must    * meet at Loop Start. */   n1 = head;    while (n1 != n2) {     n1 = n1.next;     n2 = n2.next;    }   // Now n2 points to the start of the loop.   return n2; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is an idea --  maintain three pointers: a) head -- start of the given list b) first -- jumps one step in iteration c) second -- jumps two step in iteration  Start first and second pointers from the head and continue till both become equal (in case of loop) or second traverses the list completely and reaches  the end(in case of linear list).  If the list is linear, number of nodes can be counted by traversing the list starting from head.  If the list contains a loop, notice the node where first and second becomes equal, store this new pointer tempPointer.  At this point, break the loop between tempPointer and tempPointer->next  by using code below:  head2 = tempPointer->next; tempPointer->next = null   Suppose the original list with loop was like:   head - a - b- c- d- e - f - g - h                                  |              |                                 l -k  - j  - i  Suppose the loop is broken between f and g and null pointer is introduced:   then g becomes head2 and f->next is set to null:  head  - a - b- c- d- e - f --> null                                  |                                                 l - k  - j  - i - h - g (head2)  now we can traverse from head to null (first list) and head2 to null (second list)  These two lists are merged at node e.  Count the number of nodes in first list -- count1 Count the number of nodes in second list -- count2  suppose count1 is greater than count2 (take whichever is greater)  then traverse first list by (count1 - count2) starting from head. Then start traversing two lists together till you reach at merging point. Suppose you traverse M nodes together to reach merging point.  Then traverse the merged list.  The sum of nodes in both lists = number of nodes in first list + M"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how cycle is detected using hare & tortouse algo?? can u please explain??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Mark the nodes and then count"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Find the loop using floyd's algo, then clacualte thenumber of nodes in the loop by fixing one pointer inside the loop and shifting another pointer in the loop untill bth of them become equal again, lets the number be m now take a pointer pointing to the head and go to mth node now move the pinter to the head and the pointer pointing to the mth node step by step until the bcome equal and now you the node at which the loop starts"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using double pointers only, will not solve this problem. There two types elements in the list; first are say, X which are not in loop and other say, Y, which belongs to loop. let number of X are x. and number of Y are y. And we need to calculate the x + y.   I will go with this approach: First reverse the linked list and increment a counter, counter will be give you the value of 2x + y. Now, using floyd cycle detection algo to find any Y. Calculate the value of y by just traversing the loop once starting from Y. Calculate x + y, using prior equations.  Reverse again the linked list to give its original shape. Total complexity should be O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What exactly does \"may or may not start from the head mean\" ?? We certainly cannot backtrack in a singly linked list unless its circular. Maybe i am not clear with the question. Please explain."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"'shodnik' and 'Anonymous' have already provided solutions which I'm not fully convinced untill I receive some response against my asks to them. In the mean time here is my solution in O(n) time and with fixed additional memory. The only drawbacks of my algorithm is that it requires changing the structure of the list whereas both of the solutions from them does not. Note that the solution given by 'Anonymous' does a change of list structure but it can be avoided.  Anyway here is mine."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node slow = head; \n Node fast = head; \n while (slow != null && fast != null && slow != fast){ \n  slow = slow.next; \n  if (fast.next== null) \n   break; \n  fast = fast.next.next;  \n } \n int size = 0; \n if (slow == null ||fast == null || fast.next == null){ // there is no loop \n  Node temp = head; \n  \n  while (temp != null) \n   count++; \n  return count; \n } \n //now we want to find the head of the cycle \n slow = head; \n while (slow != fast){ \n  slow = slow.next; \n  fast = fast.next; \n } \n //now fast/slow is the head of the loop \n Node current1 = head; \n Node current2 = slow.next; \n while (current1 != slow){ \n  size++; \n  current1 = current1.next; \n } \n while (current2 != slow){ \n  size++; \n  current2 = current2.next; \n } \n return size + 1; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13271668","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"34","title":"Write a Program  You will create an employee class with the following properties:ID (int), FName(string), LName(string).  (Functionality) to track an employee's manager and subordinates.  Add a method that displays the names of all subordinates for a given employee. Calculate the complexity. Do not use multiple classes.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public class Employee { \nprivate int ID; \nprivate String firstName; \nprivate String lastName; \nprivate Employee manager; \nprivate List subordinates; \n \npublic Employee(int id, String firstName, String lastName, Employee manager) \n{ \n    this.ID = id; \n    this.firstName = firstName; \n    this.lastName = lastName; \n    this.manager = manager; \n    this.subordinates = new ArrayList(); \n} \n/*** \ngettter and setter methods are ommitted  \n***/ \n \npublic void addSubordinate(Employee emp){ \n  if(emp != null){ \n     this.subordinates.add(emp); \n} \n} \n \npublic void printSubordinate(){ \n \nif(subordinates == null || subordinates.isEmpty()){ \nSystem.out.println(\"There are no subordinates\"); \n}else{ \n   \n for(Employee e : subordinates){ \n            System.out.println(e.getFirstName + \" \" + e.getLastName());      \n} \n} \n} \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is more of a database schema question, wherein subordinates of a employee is represented as foreign key in the employee table.  Representing in OOP model, Every employee can have a vector to store references of his subordinates, the only issue with this, to store references of all the subordinates in a vector of employee class it needs all subordinate objects must have been instantiated."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Program should be written in Java/C++ using classes and objects"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it is not good,it is a tree traverse problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it is not good,it is a tree traverse problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package emp; \n \nimport java.util.HashSet; \nimport java.util.Set; \n \npublic class Employee { \n \n    int id; \n    String firstName; \n    String lastName; \n    Employee manager; \n    Set subordinates = new HashSet(); \n \n    Employee(int id, String firstName, String lastName) { \n        this.id = id; \n        this.firstName = firstName; \n        this.lastName = lastName; \n    } \n \n    void addManager(Employee manager) { \n        this.manager = manager; \n        manager.subordinates.add(this); \n    } \n \n    void addSubordinate(Employee subordinate) { \n        this.subordinates.add(subordinate); \n        subordinate.manager = this; \n    } \n \n    void findDetails() { \n        if (this.manager != null) { \n            System.out.println(\"Manager is : \" + this.manager); \n        } else { \n            System.out.println(\"NO manager for \" + this); \n        } \n        if (this.subordinates.size() > 0) { \n            System.out.println(\"***SUB ORDINATES***\"); \n            for (Object subordinate : this.subordinates) { \n                Employee emp = (Employee) subordinate; \n                System.out.println(emp); \n            } \n        } else { \n            System.out.println(\"No subordinates for : \" + this); \n        } \n    } \n \n    @Override \n    public String toString() { \n        return this.id + \" : \" + this.firstName + \".\" + this.lastName; \n    } \n \n    public static void main(String argc[]) { \n        Employee a = new Employee(1, \"a\", \"aa\"); \n        Employee b = new Employee(2, \"b\", \"bb\"); \n        Employee c = new Employee(3, \"c\", \"cc\"); \n        Employee d = new Employee(4, \"d\", \"dd\"); \n        Employee e = new Employee(5, \"e\", \"ee\"); \n        Employee f = new Employee(6, \"f\", \"ff\"); \n        Employee g = new Employee(7, \"g\", \"gg\"); \n \n        a.addSubordinate(b); \n        a.addSubordinate(c); \n        b.addSubordinate(e); \n        b.addSubordinate(f); \n        c.addSubordinate(g); \n \n        a.findDetails(); \n \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.HashSet; \nimport java.util.Set; \n \npublic class Employee { \n \n    int id; \n    String firstName; \n    String lastName; \n    Employee manager; \n    Set subordinates = new HashSet(); \n \n    Employee(int id, String firstName, String lastName) { \n        this.id = id; \n        this.firstName = firstName; \n        this.lastName = lastName; \n    } \n \n    void addManager(Employee manager) { \n        this.manager = manager; \n        manager.subordinates.add(this); \n    } \n \n    void addSubordinate(Employee subordinate) { \n        this.subordinates.add(subordinate); \n        subordinate.manager = this; \n    } \n \n    void findDetails() { \n        if (this.manager != null) { \n            System.out.println(\"Manager is : \" + this.manager); \n        } else { \n            System.out.println(\"NO manager for \" + this); \n        } \n        if (this.subordinates.size() > 0) { \n            System.out.println(\"***SUB ORDINATES***\"); \n            for (Object subordinate : this.subordinates) { \n                Employee emp = (Employee) subordinate; \n                System.out.println(emp); \n            } \n        } else { \n            System.out.println(\"No subordinates for : \" + this); \n        } \n    } \n \n    @Override \n    public String toString() { \n        return this.id + \" : \" + this.firstName + \".\" + this.lastName; \n    } \n \n    public static void main(String argc[]) { \n        Employee a = new Employee(1, \"a\", \"aa\"); \n        Employee b = new Employee(2, \"b\", \"bb\"); \n        Employee c = new Employee(3, \"c\", \"cc\"); \n        Employee d = new Employee(4, \"d\", \"dd\"); \n        Employee e = new Employee(5, \"e\", \"ee\"); \n        Employee f = new Employee(6, \"f\", \"ff\"); \n        Employee g = new Employee(7, \"g\", \"gg\"); \n \n        a.addSubordinate(b); \n        a.addSubordinate(c); \n        b.addSubordinate(e); \n        b.addSubordinate(f); \n        c.addSubordinate(g); \n \n        a.findDetails(); \n \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"its a composite design pattern question - head first java"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this.. any thoughts??????   import java.util.ArrayList;  public class Employee {  static ArrayList al = new ArrayList();  private String id, fname, lname, mgrid;   public String getId() {   return id;  }   public void setId(String id) {   this.id = id;  }   public String getFname() {   return fname;  }   public void setFname(String fname) {   this.fname = fname;  }   public String getLname() {   return lname;  }   public void setLname(String lname) {   this.lname = lname;  }   public String getMgrid() {   return mgrid;  }   public void setMgrid(String mgrid) {   this.mgrid = mgrid;  }   public static void main(String[] args) {   // Loading the employees   Employee vo = new Employee();   vo.setFname(\"EmpFname\");   vo.setLname(\"EmpLname\");   vo.setId(\"1\");   vo.setMgrid(\"100\");   al.add(vo);   Employee vo1 = new Employee();   vo1.setFname(\"EmpFname2\");   vo1.setLname(\"EmpLname2\");   vo1.setId(\"3\");   vo1.setMgrid(\"100\");   al.add(vo1);   Employee vo2 = new Employee();   vo2.setFname(\"EmpLname3\");   vo2.setLname(\"EmpLname3\");   vo2.setId(\"4\");   vo2.setMgrid(\"101\");   al.add(vo2);   Employee vo3 = new Employee();   vo3.setFname(\"EmpLname4\");   vo3.setLname(\"EmpLname4\");   vo3.setId(\"6\");   vo3.setMgrid(\"101\");   al.add(vo3);   Employee vo4 = new Employee();   vo4.setFname(\"EmpLnameMgr\");   vo4.setLname(\"EmpLnameMgr\");   vo4.setId(\"100\");   vo4.setMgrid(\"1000\");   al.add(vo4);    showSubordinates(\"100\");// this method shows the subordinates for Mgr ID         // which is passed.   }   public static void showSubordinates(String EmpID) {   boolean flg = false;   for (int i = 0; i < al.size(); i++) {    Employee vo = al.get(i);    if (vo.getMgrid().equals(EmpID)) {     flg = true;     System.out.println(\"Subordinate for Mgr \" + EmpID + \" is: \"       + vo.getFname() + \", \" + vo.getLname() + \", EmpID: \"       + vo.getId());    }   }   if (!flg) {    System.out.println(\"No Subordinates found\");   }   }  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5931075461185536","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"34","title":"Given a list of ranges as input ((1,2),(3,4),(3,6),(8,10)),the output would be those ranges that don't overlap.For example, the output could be merging the ranges 1) (1,2),(3,4)  2) (1,2) (3,6) etc  The output cannot contain (3,4),(3,6) as 3 is common to both","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"It is 1d interval search problem. Algorithm: Create BST where each node stores an interval (lo,hi). Use left endpoint as BST key. (here lo is BST key) Store max endpoint in subtree rooted at node. (consider hi of all nodes) Now: To search for any one interval that intersects query interval (lo,hi): If interval in node intersects query interval, return it. Else if left subtree is null, go right. Else if max endpoint in left subtree is less than lo, go right. Else go left."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sort the ranges and remove one of the ranges that are overlapping. Time complexity O(nlogn), written in C++.  Output:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Sort pairs by lower range (nlogn) 2) Go through list of pairs checking overlap (merge node) and duplicate (remove node)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here my version:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Brut force:  the function:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"DO we have to ouput always in pairs? For example can answer in example be  {(1,2) (3,6) 8,10)}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have a hard time understanding this question. Are we supposed to print all pairs of ranges that don't overlap? Can someone elaborate and provide more examples? Thanks."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@Sunny:  yes, check if a number within the range overlaps with any other range.  examples:  input: {{1,2}, {3,4}, {3,6}, {8,10}} output: {{1,2}, {8,10}}  explanation: {3,4}, {3,6} ...overlap and will be removed  input: {{1,2}, {3,5}, {4,6}, {8,10}} output: {{1,2}, {8,10}} explanation: {3,5}, {4,6} ...overlap and will be removed  input: {{1,6}, {3,4}, {5,7}, {8,10}} output: {{8,10}} explanation: {1,6}, {3,4}, {5,7} ...overlap and will be removed"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void doItNew(int[][] x) { \n        int[] checker = new int[x.length]; \n        for (int i = 0; i < x.length - 1; i++) { \n            for (int j = i + 1; j < x.length; j++) { \n                if (checkOverLap(x[i], x[j])) { \n                    checker[i] = -1; \n                    checker[j] = -1; \n                } \n            } \n        } \n        for (int i = 0; i < x.length ; i++) { \n            if (checker[i] != -1) { \n                for (int a1 : x[i]) { \n                    System.out.print(a1 + \"\\t\"); \n                } \n            } \n        } \n    } \n \n    public boolean checkOverLap(int[] a, int[] b) { \n        return a[0] - b[1] <= 0 && a[1] - b[0] >= 0; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Its a  very easy question of \"Activity selection problem\", an application of greedy algorithm."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If we assume that the input array comes already sorted (in the problem statement it comes sorted), just traverse this array and eliminate  the overlapping pairs, then it has an O(n) for both time and space complexities."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Jumping directly to code without understanding the problem is just stupid. What to return if the array contains (1,2) (3,4) (1,2,3,4,5)?  (1,2) + (3,4) or (1,2,3,4,5)? Is it asking for the largest coverage?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Create 2 separate sets of tuples, in one set sort the intervals by the first number, in the second set sort the intervals by the second number.  For each tuple in the first set, use binary search to find all tuples in the second set for which the second number in the tuple from the second set is less than equal to the first number in the tuple from the first set.  Sorting takes O(nlogn) time. Forming the set of intervals for each of n tuple takes O(logn) time (binary search). Thus O(nlogn) time complexity and O(n) space complexity."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This problem is like interval scheduling problem in which we have to schedule jobs which are compatible.  We are given here (start,finish) time pair of each job.  Two approach:  Greedy: 1) Sort them based on the range end of each (start,end) pair. 2) Now take first pair which end first and add it to solution. 3) Iterate on sorted job to find  jobs which are compatible with the result. This will be one scan to the input. Note: We are adding job greedily to the solution set.  DP: Sort the based on the end range. Create Array which account for last job compatible with jth jon. Let it be p(j). Now Use this recurrence solution. M[i] = max(1+p(i),M[i-1]).  M[n] will give you number of max set compatible. For printing solution you can iterate over M array one scan."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class MergingRang { \n public static void main(String[] args) { \n  List pointList = new ArrayList(); \n  Point point;   \n  point = new Point(3,4); \n  pointList.add(point); \n  point = new Point(1,2); \n  pointList.add(point); \n  point = new Point(3,6); \n  pointList.add(point); \n  point = new Point(8,10); \n  pointList.add(point); \n  Collections.sort(pointList); \n  for(int i=0;ii;j--){         \n    if((pointList.get(i).y>=pointList.get(j).x) || (pointList.get(i).y>=pointList.get(j).y)) \n     break; \n    else \n     System.out.println(\"(\"+pointList.get(i).x+\",\"+pointList.get(i).y+\")\"+ \n       \"(\"+pointList.get(j).x+\",\"+pointList.get(j).y+\")\"); \n   } \n  } \n   \n } \n \n} \nclass Point implements Comparable{ \n int x; \n int y; \n public Point(int x, int y) { \n  this.x = x; \n  this.y = y; \n } \n @Override \n public int compareTo(Point o) { \n  // TODO Auto-generated method stub \n  return x-o.x; \n } \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=56632","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"34","title":"Had my first and second phone interview with Amazon. I was dropped. This site has been a great help towards my preparation and most questions are based on what you find here. Posting my Questions is a small way of saying Thanks!  Interview 1: 1. What is polymorphism. 2. Design an OO parking lot. What classes and functions will it have. It should say, full, empty and also be able to find spot for Valet parking. The lot has 3 different types of parking: regular, handicapped and compact. 3. Coding: I have an integer array where every number appears even number of times and only one appears odd times. Find the number. (I said hashtable and he asked me to write code with Hashtable) 4. What data structure would you use to look up phone numbers for customer names. (I said Hashtable. Asked why hashtable, why not a tree. I said HT has O(1). Asked is order always 1, when more than O(1) in HT.   Second Interview: 1. Starter: Describe your college projects. 2. OO Design: Design a deck of cards. What classes, data structures will you use? How will you shuffle the cards? How will you divide (deck) among players. What class/function do you need to denote players and where will you add them? What class/function do you need to deck? What if I need to add 2 jokers to the deck of 52 cards.  3. Data Structures: How will you use a hashtable to find data in a tree. (Then he rephrased) suppose I have a hashtable, I want to store the data in a tree instead of a bucket. How will I do it. What complexity to find an element.  4. Bits & Bytes: Find if a binary representation of a number is palindrome. The function should work irrespective of number of bytes for an integer. Suppose if our machine is 4 bytes for an int, how will you use the program for 8 byte machine.  5. Unix: Suppose I have 100's of html files in many directories. I want to find the files having phone numbers.   b) Suppose I have 2 files having phone numbers, find the repeating phone numbers. (I said sort and grep). Then he asked what if the lines cannot be sorted.   All the best guys. I think the second interview was challenging since the interviewer was prodding until he heard a leave me alone. So it means that though they are based on questions in cc, be prepared for extensions. I think this site is all you need to prepare for Amazon interview.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"3. Coding: I have an integer array where every number appears even number of times and only one appears odd times. Find the number.  XOR all the numbers together. The final result of XOR is your answer. O(1) space, O(n) time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Design a deck of cards. What classes, data structures will you use? How will you shuffle the cards? How will you divide (deck) among players. What class/function do you need to denote players and where will you add them? What class/function do you need to deck? What if I need to add 2 jokers to the deck of 52 cards ---------------------------- ANS: Relation: 1 game -- 2 player , 1 deck ( atleast ) 1 deck - 52 cards. so entities are   Cards , Deck , Player , Game: class cards {   int rank;   int suits;   int type;   int name; };  Class Deck {   Cards *deck;   fill();   shuffle(); };  class Player {   int number_of_cards;   string name;   Cards play_card();   void collect_card(Cards C);   string get_name();    };  Class Game {   void play();   Player getWinner();   bool enough_cards };"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hi S... I dont ur name .bt I would like to discuss some about design problem.If u have no problem .can u give me a call as soon as possible..just send me the acknowledgement  on my email Id on jigu4paint@yahoo.com.I will send my number.  I really need ur help.. Thanks"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This Should help us a lot! Thanks for posting al the questions"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Design an OO parking lot. What classes and functions will it have. It should say, full, empty and also be able to find spot for Valet parking. The lot has 3 different types of parking: regular, handicapped and compact. ------------------------------------------------------------- Idea was number of parking car allotment can depend on parking type. User can put diff -2 algo to find the spot for diff parking type, ------------------------------------------------------------- class parking {   virtual bool full() =0;   virtual bool empty()= 0;   virtual bool spot_position()=0; };  class RegularParking:public Parking {   static int number_of_cars;   bool full() ;   bool empty()= 0;   int spot_position()=0; }; class HandicapedParking:public Parking {   static int number_of_cars;   bool full() ;   bool empty()= 0;   int spot_position()=0; }; class CompactParking:public Parking {   static int number_of_cars;   bool full() ;   bool empty()= 0;   int spot_position()=0; };"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"thanks a lot for sharing this!! it gave me a clear picture of how amazon photo interview looks like, very very helpful!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Answer to Interview Qs # 3  package com.badal.HashTable;  import java.util.Hashtable;  public class HashTable3 {    public static void main(String [] args){   Hashtablehashtable=new Hashtable();     for(int i=0;i   if(hashtable.containsKey(Integer.parseInt(args[i]))){     hashtable.put(Integer.parseInt(args[i]), hashtable.get(Integer.parseInt(args[i]))+1);    }else{     hashtable.put(Integer.parseInt(args[i]), 1);    }    }      System.out.println(\"Start printing the hash table\");   for(int key:hashtable.keySet()){    System.out.println(key+\" = \"+hashtable.get(key));   }   System.out.println(\"End printing the hash table\");      for(int key:hashtable.keySet()){    if(hashtable.get(key)%2==1){     System.out.println(\"Odd occurence number is: \"+key);    }       }      }   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"3. Data Structures: How will you use a hashtable to find data in a tree. (Then he rephrased) suppose I have a hashtable, I want to store the data in a tree instead of a bucket. How will I do it. What complexity to find an element. ------------------ Ans: Is it a binary search tree? In that case, it will take O(logN) where N is the isze of the bucket.  5. b) Suppose I have 2 files having phone numbers, find the repeating phone numbers. (I said sort and grep). Then he asked what if the lines cannot be sorted. ---------------  We can use Hashing for this. Hash the phone numbers of the first file. Then take the 2nd file phone number and try to hash, if the element already exists in the Hash table, then print that phone number."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Mr Badal, What exactly are you trying to do ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"4. Bits & Bytes: Find if a binary representation of a number is palindrome. The function should work irrespective of number of bytes for an integer. Suppose if our machine is 4 bytes for an int, how will you use the program for 8 byte machine.  Solution: reverse the bits of the given integer and store it in another variable. Now check both the numbers whether they are equal or not. If equal the given number is palindrome otherwise not.  The code as follows: int input; // given input number - find palindrome or not int reverse_input = 0; // this will contain the no in which the bits are reverse order of the given input  while(input) {  int remainder = input % 2;  reverse_input = (reverse_input << 1) | remainder;  input = input / 2; }  // Now check if they are equal or not if(input == reverse_input) print \"Is Palindrome\" else print \"Not Palindrome\""},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void reverseBits(int n) {  int rev = 0;  int o = n;  while(n)  {   rev = (n & 1) | rev;   n = n >> 1;   if(n)    rev =  rev << 1;  }  decimal_to_anybase(o,2);  decimal_to_anybase(rev, 2);  if(o == rev)   cout<<\"Palindrome\\n\";  else   cout<<\"Not palindrome\\n\"; }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=9951144","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"37","title":"How to find a first non repeating character in a String ?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"First Non Repeating Character:- Stores the sequence in a Queue and hashmap to store the count. If you want the last non repeating character replace the Queue with a Stack :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Use hashmap (key = char, value = index).  Keep adding every character(and its index) of the string to the map only if the char dowsn't already exist in the map.  If the character already exist in the map, remove that entry from the map. Once you are done with the traversal, iterate through the entries in the map and store the least value(index)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Use a structure like this  typedef struct node { char key; int index; } Map; Map a [10];  1. Insert the incoming data in this sorted array using using binary search. 2. Use binary search again to fetch the char that is already stored in the array. (n logn)  Scan the whole input array till the last char and fetch the first element in the array searching for  index 0  .n logn  Overall complexity = nlogn+nlogn =2nlogn.  :THIS IS ONLY IN CASE U DONT WANT TO USE MAP(STL CONTAINERS):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since only characters used here, an int array with size 256 should be sufficient for the map, which can lead to o(n) solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can be easily done in O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"char* Amazon_001(){   char *x = \"wwwamazoncom\";  char *p = x;  char *q = p+1;  while(*q){   int res = *p + *q;   if( res/2 != *p  ){    break;    }   p++;   q++;  }  return q; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static char findNonRepeateChar(String str) { \n Set chSet = new LinkedHashSet(); \n char[] charArray = str.toCharArray(); \n for (int i = 0; i < charArray.length; i++) { \n  if (!chSet.add(charArray[i])) { \n   chSet.remove(charArray[i]); \n  } \n } \n if (chSet.isEmpty()) \n  return '-'; \n else \n  return (Character) (chSet.toArray())[0]; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can be easily done in the O(n) :) just take a array of 256 code : char FirstNotrepeating(char *str) { static int flag[256]; int i; for(i=0;str[i]!='\\0';i++) flag[str[i]]++; for(i=0;i<=255;i++) { if(flag[i]==1) return str[i]; }  puts(\"all characters are repaeated\"); return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"find_non_rep(char string[],length) { char rep_char; rep_char=string[0]; for(i=1;i{ if(rep_char^string[i]!=0) return rep_char; } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think we will need to use  1-Hashmap for storing key-char and value-0 or 1 (0-nonrepeating, 1-repeating) . 2-Queue for maintaing sequence of characters.   import java.util.HashMap; /** Method for getting first non repeating character in a string /*@param String str Input string /*@return char q  */  public char getFirstNonRepeatChar(String str){  Hashmap map = new Hashmap(); Queue q= new Queue();  //put chars in queue and hashmap for(int i=0;i         if(map.containsKey(str.charAt(i))){              map.put(str.charAt(i),1);//set key value to 1(set for dequeue)          }else{              map.put(str.charAt(i),0);//set key value to 0(non repeating value)              q.enqueue(str.charAt(i))//add new char to queue                              }      }//end of for  //loop till queue is empty or we find a first non repeating char while(!q.isEmpty()){      char v=q.seek();//get char value at first pointer      if(map.get(v)==0){//if char is non repeating           return v;//found the first non repeating char      }          q.deqeue(); }          return null; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this. Changed the code by \"geeks\"  a bit?   #include  #include   struct node{   int count;   int pos; };  int FirstNotrepeating(char *str) {   static struct node flag [256];   int i;   int minpos=INT_MAX;   for(i=0;str[i]!='\\0';i++)   {     flag[str[i]].count++;     flag[str[i]].pos = i;   }   for(i=0;i<=255;i++)   {     // if it is seen only once     if(flag[i].count==1)     {       // check the minimum pos       if(flag[i].pos < minpos)       {         minpos=flag[i].pos;       }     }   }      if(minpos < INT_MAX)     printf(\"The first non rep char is %c \",str[minpos]);   else     printf(\"No non-rep chars\");   return 0; }  int main() {   char a[] = \"aabbccddeffgghhijj\";   FirstNotrepeating(a);   return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.take an array of size 256 itialised to 0. 2.traverse the string and increment the value at that position(ASCII value of that character) for each finding of thet character in the string. 3.Finally the array consists of the number of occurences of each character. 4.Traverse the string again and check that position(ASCII value of that character) in the indexed array whether it is one or not,if it is one then it is the first non repeating character otherwise keep traversing till u find such an element."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am assuming that we want to show the first char comin in input string that is not going to be repeated:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"With better time complexity than previous:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String ard[]) {          String name = \"navdeepjain\";          char nameArray[] = name.toCharArray();         Set nameset = new HashSet();         for (int i = 0; i < nameArray.length; i++) {             nameset.add(nameArray[i]);          }         System.out.print(nameset);       Set newSet=new HashSet();         for(int i=0; i            for(int j=i+1; j                if(nameArray[i]==nameArray[j]){                   System.out.print(nameArray[i]);                     newSet.add(nameArray[i]);                 }else{                  //  System.out.println(nameArray[i]);                 }             }         nameset.removeAll(newSet);         System.out.println(nameset);       }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class JavaArrayTest {    public static void main(String[] args)  {   String test=\"avinashavinashavinashakvinashainashmishra\";   char[] ch=test.toCharArray();   Set lSet=new HashSet();   Set delSet=new HashSet();   for (int i=0;i  {    if(!lSet.add(ch[i]))    {     delSet.add(ch[i]);     lSet.remove(ch[i]);         }   }   lSet.removeAll(delSet);   System.out.println(lSet);     }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please comment the lSet.remove(ch[i]); in above code."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please comment the lSet.remove(ch[i]); in above code within the loop."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"char firstNonRepeatChar(string s){  queue Q;  int charArr[255];  for(int p=0;p<255;p++)charArr[p]=0;  for(int i=0;i  charArr[s[i]]++;   Q.push(s[i]);  }   while(!Q.empty()){     if(charArr[Q.front()]==1)return Q.front();   Q.pop();   }  cout<<\"No non-repeat char in the string!\"<}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Q7 {  static public char firstC(String s) {   char[] cs = s.toCharArray();   for (int i = 0; i < cs.length; i++) {    int flag = 0;    for (int j = 0; j < cs.length; j++) {     if (cs[i] == cs[j]) {      flag++;     }     if (flag > 2) {      break;     }    }    if (flag == 1) {     return cs[i];    }   }   return 0;  }   public static void main(String[] args) {   String s = \"sadjkwedfks\";   System.out.println(Q7.firstC(s));  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void FirstNonRepeatChar(string inputStr) \n        { \n            char[] inputCharArray = inputStr.ToCharArray(); \n            Dictionary counters = new Dictionary(); \n \n            for(int i = 0 ; i <= inputCharArray.Length-1; i++) \n            { \n                if(counters.ContainsKey(inputCharArray[i])) \n                { \n                    counters[inputCharArray[i]] += 1; \n                } \n                else \n                { \n                    counters.Add(inputCharArray[i],1); \n                } \n            } \n \n            foreach (char c in inputCharArray) \n            { \n                if (counters[c] == 1) \n                { \n                    Console.WriteLine(\"First Non Repeating Char is {0}\", c.ToString()); \n                    return; \n                } \n            } \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public Character getFirstNonRepeatingChar(String t){ \n         \n            for (int i = 0; i < t.length(); i++) { \n                if (t.lastIndexOf(t.charAt(i)) == i) { \n                    return t.charAt(i); \n                } \n            } \n         \n            return null; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"add each char to set and set only takes unique values."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static Character getFirstNonRepeatingChar() {   String test=\"jitendrajkuitendlkummajlr\";   char[] chArr=test.toCharArray();   Map map = new LinkedHashMap();   for(char ch : chArr){    if(map.containsKey(ch))     map.put(ch, map.get(ch)+1);    else{     map.put(ch,1);    }   }   for(Map.Entry entry : map.entrySet()){    if(entry.getValue() == 1)     return entry.getKey();   }   return null;  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13575664","download_status":"DOWNLOAD_DONE","votes":"3","answersCount":"82","title":"Q1.- Written exam (Amazon, Bangalore)  Given a singly link list and a number 'K', swap the Kth node from the start with the Kth node from the last. Check all the edge cases.  Sample Input: 1->2->3->4->5->6->7->8 and K = 3 Sample Output : 1->2->6->4->5->3->7->8  Sample Input: 1->2->3->4->5->6->7->8 and K = 10 Sample Output: print error \"LIST IS OF LESSER SIZE\".","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"18","title":"This can be done in line without first completely traversing the list to check the size. This can be done with 3 pointers.   One pointer is for the first element which is k from the start the second pointer is for the element which is k from the end the last pointer is to find the end.  Then you traverse the list save the pointers and do the swap at the end, you don't even have to mess with the links when swapping, just swap the values from the pointers you have saved from above."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"We need to handle a few test cases. 1. Both nodes are end nodes. 2. Both nodes are adjacent. 3. Both nodes are somewhere else. 4. Both node are same. 5. kth node doesn't exist.  I prefer swapping the nodes rather than values. It is always advisable to swap the nodes as in general, nodes may contain several data. So, it will be overhead to swap the values.  Steps: Find the kth node[p] from the beginning. If no kth node, return. Take another pointer[q] & move it at head. Move it & the kth node one step at a time until kth node is null.   q is the kth node from the last.  We need to swap p & q.  The part of linked list found is: t1->p->t2   and t3->q->t4 Just swap the nodes based on links & handle the corner cases mentioned above. Here is the code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Take 3 pointers to the starting point of the list - P1, P2 & P3.  Start moving P1 & P3 till you have moved 'K'  nodes. If the list ends before P1 reaches the End, give the error message \"LIST IS OF LESSER SIZE\". Once you have reached the Kth node, move P1 and P2 pointers to the next node one by one till P1 reaches the end.  At this point P2 points to the Kth element from the last. Now simply swap the values of P2 & P3.  Job done."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public static void swap(LinkedList ll,int k){ \n  int size = ll.size(); \n  if(1<=k&&k<=size){ \n   int firstK = ll.get(k-1); \n   int lastK=ll.get(size-k); \n   ll.set(k-1, lastK); \n   ll.set(size-k, firstK); \n   System.out.println(ll); \n  }else{ \n   System.out.println(\"ERROR\"); \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algorithm: 1.Get the linked list lenghth. If it is less than 'K' print the error message. O(N) 2.Traverse to the 'K' the element from the beginning. O(N) 3.Traverse to the N-Kth element from the beginning. O(N) 4. Swap them.O(1) 5.End of Algorithm  Complexity: O(N)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Find Kth Element from Beginning. Store the pointer. 2. Using Kth Element, find kth element from last(two pointers) 3. Swap these pointers. 4. At every step, check for length traversed till is < n, otherwise raise error"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node* SwapList(Node* head, int k) \n{ \n if (head == NULL || head->next == NULL) \n { \n  return head; \n } \n  \n Node* current = head->next; \n Node* prev = head; \n int currentCount = 2; \n  \n Node* kth = NULL; \n Node* kthPrev = NULL; \n Node* kthLast = NULL; \n Node* kthLastPrev = NULL; \n  \n while (current != NULL) \n { \n  if (currentCount == k) \n  { \n   kth = current; \n   kthPrev = prev; \n  } \n   \n  if (kthLast != NULL) \n  { \n   kthLastPrev = kthLast; \n   kthLast = kthLast->next; \n  } \n  else if (kth != NULL) \n  { \n   kthLast = head; \n  } \n   \n  prev = current; \n  current = current -> next; \n } \n  \n if (kth == NULL) return head; // kth node does not exist in list \n if (kth == head) // k == 1 \n { \n  kthLast->next = kth->next \n  kth->next = NULL; \n  kthLastPrev->next = kth; \n  return kthLast; // this becomes new head \n } \n  \n  \n if (kthLast == head) \n { \n  kth->next = kthLast->next; \n  kthprev->next = kthLast; \n  kthLast->next = NULL; \n  return kth; \n } \n  \n Node* temp = kth->next; \n kth->next = kthLast->next; \n kthLast->next = temp; \n kthLastPrev->next = kth; \n kthPrev->next = kthLast; \n return head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node* SwapList(Node* head, int k) \n{ \n if (head == NULL || head->next == NULL) \n { \n  return head; \n } \n  \n Node* current = head->next; \n Node* prev = head; \n int currentCount = 2; \n  \n Node* kth = NULL; \n Node* kthPrev = NULL; \n Node* kthLast = NULL; \n Node* kthLastPrev = NULL; \n  \n while (current != NULL) \n { \n  if (currentCount == k) \n  { \n   kth = current; \n   kthPrev = prev; \n  } \n   \n  if (kthLast != NULL) \n  { \n   kthLastPrev = kthLast; \n   kthLast = kthLast->next; \n  } \n  else if (kth != NULL) \n  { \n   kthLast = head; \n  } \n   \n  prev = current; \n  current = current -> next; \n } \n  \n if (kth == NULL) return head; // kth node does not exist in list \n if (kth == head) // k == 1 \n { \n  kthLast->next = kth->next \n  kth->next = NULL; \n  kthLastPrev->next = kth; \n  return kthLast; // this becomes new head \n } \n  \n  \n if (kthLast == head) \n { \n  kth->next = kthLast->next; \n  kthprev->next = kthLast; \n  kthLast->next = NULL; \n  return kth; \n } \n  \n Node* temp = kth->next; \n kth->next = kthLast->next; \n kthLast->next = temp; \n kthLastPrev->next = kth; \n kthPrev->next = kthLast; \n return head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node* SwapList(Node* head, int k) \n{ \n if (head == NULL || head->next == NULL) \n { \n  return head; \n } \n  \n Node* current = head->next; \n Node* prev = head; \n int currentCount = 2; \n  \n Node* kth = NULL; \n Node* kthPrev = NULL; \n Node* kthLast = NULL; \n Node* kthLastPrev = NULL; \n  \n while (current != NULL) \n { \n  if (currentCount == k) \n  { \n   kth = current; \n   kthPrev = prev; \n  } \n   \n  if (kthLast != NULL) \n  { \n   kthLastPrev = kthLast; \n   kthLast = kthLast->next; \n  } \n  else if (kth != NULL) \n  { \n   kthLast = head; \n  } \n   \n  prev = current; \n  current = current -> next; \n } \n  \n if (kth == NULL) return head; // kth node does not exist in list \n if (kth == head) // k == 1 \n { \n  kthLast->next = kth->next \n  kth->next = NULL; \n  kthLastPrev->next = kth; \n  return kthLast; // this becomes new head \n } \n  \n  \n if (kthLast == head) \n { \n  kth->next = kthLast->next; \n  kthprev->next = kthLast; \n  kthLast->next = NULL; \n  return kth; \n } \n  \n Node* temp = kth->next; \n kth->next = kthLast->next; \n kthLast->next = temp; \n kthLastPrev->next = kth; \n kthPrev->next = kthLast; \n return head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node* SwapList(Node* head, int k) \n{ \n if (head == NULL || head->next == NULL) \n { \n  return head; \n } \n  \n Node* current = head->next; \n Node* prev = head; \n int currentCount = 2; \n  \n Node* kth = NULL; \n Node* kthPrev = NULL; \n Node* kthLast = NULL; \n Node* kthLastPrev = NULL; \n  \n while (current != NULL) \n { \n  if (currentCount == k) \n  { \n   kth = current; \n   kthPrev = prev; \n  } \n   \n  if (kthLast != NULL) \n  { \n   kthLastPrev = kthLast; \n   kthLast = kthLast->next; \n  } \n  else if (kth != NULL) \n  { \n   kthLast = head; \n  } \n   \n  prev = current; \n  current = current -> next; \n } \n  \n if (kth == NULL) return head; // kth node does not exist in list \n if (kth == head) // k == 1 \n { \n  kthLast->next = kth->next \n  kth->next = NULL; \n  kthLastPrev->next = kth; \n  return kthLast; // this becomes new head \n } \n  \n  \n if (kthLast == head) \n { \n  kth->next = kthLast->next; \n  kthprev->next = kthLast; \n  kthLast->next = NULL; \n  return kth; \n } \n  \n Node* temp = kth->next; \n kth->next = kthLast->next; \n kthLast->next = temp; \n kthLastPrev->next = kth; \n kthPrev->next = kthLast; \n return head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void swapElementsInLinkedList(int k){   if(k<0 || k> getSize() ){    throw new InvalifIndexException(\"LIST IS OF LESSER SIZE/LIST SIZE CANT BE NEGATIVE\");   }   temp = head ;   LinkedListNode KthnodeFromRear = null;   int newValueForK = (getSize()-k)+1;   int counter = 1;   int firstStop = 0;   int lastStop = 0;   if(k   firstStop = k;    lastStop = newValueForK;   }   else{    firstStop = newValueForK;    lastStop = k;   }     while(counter != firstStop){         counter ++;         temp=temp.getNext();          }       KthnodeFromRear = temp;     while(counter!=lastStop){         counter ++ ;         KthnodeFromRear = KthnodeFromRear.getNext();         }         swap(temp,KthnodeFromRear);          }      private void swap(LinkedListNode first, LinkedListNode last) {   Integer data = first.getData();   first.setData(last.getData());   last.setData(data);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void replace_node(struct node **head,int pos) \n{ \n        int count = 1; \n        int tmp =0; \n        myNode *curr = *head; \n        myNode *one = curr; \n        myNode *two = curr; \n        while(two != NULL && two->next !=NULL && count next; \n                count++; \n        } \n        curr = two; \n        while(one!=NULL &&one->next!=NULL&& two->next!=NULL) \n        { \n                one = one->next; \n                two = two->next; \n        } \n        tmp = curr->value; \n        curr->value = one->value; \n        curr = one; \n        curr->value = tmp; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void replace_node(struct node **head,int pos) \n{ \n        int count = 1; \n        int tmp =0; \n        myNode *curr = *head; \n        myNode *one = curr; \n        myNode *two = curr; \n        while(two != NULL && two->next !=NULL && count next; \n                count++; \n        } \n        curr = two; \n        while(one!=NULL &&one->next!=NULL&& two->next!=NULL) \n        { \n                one = one->next; \n                two = two->next; \n        } \n        tmp = curr->value; \n        curr->value = one->value; \n        curr = one; \n        curr->value = tmp; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int kthnodeswap (node*& head, int k) \n{ \n \n    if (k<=0) //invalid node given \n        return -1; \n    else \n    { \n        if (k==1) //swap head node and last when index = 1 \n        { \n            node *trav = head; \n \n            //move till the end of the list \n            while (trav->next!=NULL) \n                trav = trav->next; \n \n            //swap head and last node \n            int temp = head->data; \n            head->data = trav->data; \n            trav->data = temp; \n            return 1; \n        } \n        else \n        { \n            node *trav = head; //pointer to traverse the list \n            node *swap1 = trav; //pointer which will point to the kth node from beginning \n            node *swap2 = trav; //pointer which will point to the kth node from end \n \n            //advance both traverse pointer and the beginning pointer till kth node \n            for (int i = 2; i <= k ; i++) //index starts at 2 since 1st node is head \n            { \n                trav = trav->next; \n                if (trav == NULL) return 0; //list is of lesser size \n                swap1 = trav; //advance two pointers to the same location \n            } \n \n            //after reaching the kth node from beginning advance the traverse pointer and end pointer \n            while (trav->next != NULL) \n            { \n                trav = trav->next; \n                swap2 = swap2->next; \n            } \n \n            //swap the data pointed by beginning pointer and end pointer \n            int temp = swap1->data; \n            swap1->data = swap2->data; \n            swap2->data = temp; \n            return 1; \n \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int list_swap(snode *head,int pos) \n{ \n    snode *tmp; \n    int ll=0; \n    int cnt=1; \n    snode *curr    =    NULL; \n \n    for(tmp = head;tmp;tmp=tmp->next)  \n            ll++; \n     \n    for(tmp = head;cnt < pos;cnt++)  \n            tmp=tmp->next; \n \n    /*Found from head node*/ \n     \n    curr    =    tmp; \n    while((ll-cnt) != pos-1) \n    { \n        tmp    =    tmp->next; \n        cnt++; \n    } \n    /*Now swapping the data part*/ \n    cnt    =    tmp->data; \n    tmp->data    =    curr->data; \n    curr->data    =    cnt; \n    return(0);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void swaplist(Node** list,int K) \n{ \n if (K<1)  \n  return; \n int count=1; \n Node* first=*list; \n while (count++next; \n if (first==0) { \n  cout << \"not available\\n\"; \n  return; \n } \n Node* tmp=first; \n first=first->next; \n Node* second=*list; \n while (first) { \n  first=first->next; \n  second=second->next; \n } \n swap(tmp1,second);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is working code and covers almost all the cases and boundries:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Fellas.. this ain't a Big Complex Code.. Its tricky question...  Algo. 1> Get kth Node from last and kth node from beginning. 2> Hold one pointer each to these nodes. 3> Swap their values.. :D   Code               struct Node* Swapkth(struct Node * node,int k)               {                 struct Node *temp1,*temp2,*temp3;                 temp1=node;                   while(k!=0) {                                           node=node->next;                        }                     temp2=node;// this is kth node from first                                         while(node->next!=NULL) {                                node=node->next;                                temp1=temp1->next;                           }                    //Finally when loop exits temp1 will be  pointing to the kth node from the last.                  temp3=temp1;                  temp1->data=temp2->data;                  temp2->data=temp3->data;               free(temp1);               free(temp2);               free(temp3);              }   This is all U need... No Swapping No Complex Code.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Fellas.. this ain't a Big Complex Code.. Its tricky question...  Algo. 1> Get kth Node from last and kth node from beginning. 2> Hold one pointer each to these nodes. 3> Swap their values.. :D   Code               struct Node* Swapkth(struct Node * node,int k)               {                 struct Node *temp1,*temp2,*temp3;                 temp1=node;                   while(k!=0) {                                           node=node->next;                        }                     temp2=node;// this is kth node from first                                         while(node->next!=NULL) {                                node=node->next;                                temp1=temp1->next;                           }                    //Finally when loop exits temp1 will be  pointing to the kth node from the last.                  temp3=temp1;                  temp1->data=temp2->data;                  temp2->data=temp3->data;               free(temp1);               free(temp2);               free(temp3);              }   This is all U need... No Swapping No Complex Code.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/*Q1.- Written exam (Amazon, Bangalore)  Given a singly link list and a number 'K', swap the Kth node from the start with the Kth node from the last. Check all the edge cases.  Sample Input: 1->2->3->4->5->6->7->8 and K = 3 Sample Output : 1->2->6->4->5->3->7->8  Sample Input: 1->2->3->4->5->6->7->8 and K = 10 Sample Output: print error \"LIST IS OF LESSER SIZE\"*/ #include #include struct node *recursion(struct node *,int ); /* void append(struct node **,int ); void display(struct node *);  here is problem is that void  you will get warning warning: ??struct node?? declared inside parameter list [enabled by default] amazon1.c:12:20: warning: its scope is only this definition or declaration, which is probably not what you want [enabled by default] amazon1.c:13:21: warning: ??struct node?? declared inside parameter list [enabled by default] */ struct node  {   int data;   struct node *link; }; int main() {   struct node *start;   start=NULL;   int n,i=0,item,k;   printf(\"Enter the no of node\\n\");   scanf(\"%d\",&n);   while(i++  {    printf(\"Enter node value\\n\");    scanf(\"%d\",&item);    append(&start,item);      }   display(start);   printf(\"Enter the number k for swaping kth from the fast and kth from last\\n\");   scanf(\"%d\",&k);   swap(start,k,n);   printf(\"\\n\");   display(start); }  append(struct node **t,int b) {   struct node *r,*temp;   r=*t;     if(r==NULL)     {         r=(struct node*)malloc(sizeof(struct node));         *t=r;     }   else     {          while(r!=NULL)         {           temp=r;           r=r->link;         }         temp->link=(struct node *)malloc(sizeof(struct node));         r=temp->link;         /*            If you write like this r=(struct node *)malloc(sizeof(struct node)); then you are creating indepent node which are not connected            to it's previous node.r=NULL then r(struct node *)malloc(sizeof(struct node)); it will not link to the previous node .          */     }      r->data=b;     r->link=NULL;      }  display(struct node *q) {     while(q!=NULL)     {      printf(\"%d-> \",q->data);      q=q->link;     } } swap(struct node *fast,int k,int n) {     struct node *Kth_fast,*Kth_last;     int temp;     if(k>n)        printf(\"Swaping is not possible you enter the number greater than number of element of linklist\\n\");     else     {        Kth_fast=recursion(fast,k);        Kth_last=recursion(fast,n-k+1);     }     temp=Kth_last->data;     Kth_last->data=Kth_fast->data;     Kth_fast->data=temp;   } struct node *recursion(struct node *p,int K) {     int i=1;     while(i++    {       p=p->link;     }      return p; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Complexity: O(n) Space: O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Complexity: O(n) Space: O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapKth(Node *head,int k) \n{ \n  int counter=0; \n  Node *kth=head,*kth_end=head; \n  while(kth && counter++next; \n  if(!kth) return false; \n  counter=0; \n  while(counter ++next; \n  while(head) {head=head->next;kth_end=kth_end->next;} \n  swap(kth->data,kth_end->data); \n  return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapKth(Node *head,int k) \n{ \n  int counter=0; \n  Node *kth=head,*kth_end=head; \n  while(kth && counter++next; \n  if(!kth) return false; \n  counter=0; \n  while(counter ++next; \n  while(head) {head=head->next;kth_end=kth_end->next;} \n  swap(kth->data,kth_end->data); \n  return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapKth(Node *head,int k) \n{ \n  int counter=0; \n  Node *kth=head,*kth_end=head; \n  while(kth && counter++next; \n  if(!kth) return false; \n  counter=0; \n  while(counter ++next; \n  while(head) {head=head->next;kth_end=kth_end->next;} \n  swap(kth->data,kth_end->data); \n  return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapKth(Node *head,int k) \n{ \n  int counter=0; \n  Node *kth=head,*kth_end=head; \n  while(kth && counter++next; \n  if(!kth) return false; \n  counter=0; \n  while(counter ++next; \n  while(head) {head=head->next;kth_end=kth_end->next;} \n  swap(kth->data,kth_end->data); \n  return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapKth(Node *head,int k) \n{ \n  int counter=0; \n  Node *kth=head,*kth_end=head; \n  while(kth && counter++next; \n  if(!kth) return false; \n  counter=0; \n  while(counter ++next; \n  while(head) {head=head->next;kth_end=kth_end->next;} \n  swap(kth->data,kth_end->data); \n  return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapKth(Node *head,int k) \n{ \n  int counter=0; \n  Node *kth=head,*kth_end=head; \n  while(kth && counter++next; \n  if(!kth) return false; \n  counter=0; \n  while(counter ++next; \n  while(head) {head=head->next;kth_end=kth_end->next;} \n  swap(kth->data,kth_end->data); \n  return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"you can just reverse the value."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if (indexToBeSwapped < 0 || indexToBeSwapped > inputList.Count - 1)                 return;             int indexFromLast = inputList.Count - indexToBeSwapped;             int temp = inputList[indexToBeSwapped];             inputList[indexToBeSwapped] = inputList[indexFromLast];             inputList[indexFromLast] = temp;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There is no need to swap the node. Just swap the value. That's it,"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapList(Node* head, int k) {     int count = 0;     Node *p1, *p2, *end;     p1 = p2 = end = head;      while (count < k-1)     {         if (0 != end->next)         {             end = end->next;             count++;         }         else         {             return false;         }     }      p1 = end; // fix the first pointer      while (0 != end->next)     {         end = end->next;         p2 = p2->next;     }// fix the position of second pointer      // swap the data values in the two pointer p1 and p2     p1->data = p1->data + p2->data;     p2->data = p1->data - p2->data;     p1->data = p1->data - p2->data;      p1 = p2 = end = 0;     return true; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapList(Node* head, int k) \n{ \n    int count = 0; \n    Node *p1, *p2, *end; \n    p1 = p2 = end = head; \n \n    while (count < k-1) \n    { \n        if (0 != end->next) \n        { \n            end = end->next; \n            count++; \n        } \n        else \n        { \n            return false; \n        } \n    } \n \n    p1 = end; // fix the first pointer \n \n    while (0 != end->next) \n    { \n        end = end->next; \n        p2 = p2->next; \n    }// fix the position of second pointer \n \n    // swap the data values in the two pointer p1 and p2 \n    p1->data = p1->data + p2->data; \n    p2->data = p1->data - p2->data; \n    p1->data = p1->data - p2->data; \n \n    p1 = p2 = end = 0; \n    return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have written and tested the following code ... its working"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hi guys , below is the code with 2 pointers..difference between pointers is k... slow  pointer is behind k positions of fast pointers.  There is a check before getting the k(th) element from the first and k(th) element from the last..which you can see in the following loop:           for( i = 1; i< k; i++){    fast = fast.getNext();    if(fast == null){     System.out.println(\"List is of size:: \" + i + \"  which is lesser then::\" + k);     return;    }   }     Please find the code below , this is a method in a linked list class, which access the head of the list using this.getHead() method.  and swaps the values in the last..  public void replaceKthCharacter(int k){      Node  kthElementFromStart,slow , fast;   slow =  fast = this.getHEAD();      if(slow == null || fast == null){    System.out.println(\"List is empty..\");    return;   }      int i;      for( i = 1; i< k; i++){    fast = fast.getNext();    if(fast == null){     System.out.println(\"List is of size:: \" + i + \"  which is lesser then::\" + k);     return;    }   }       kthElementFromStart = fast ;      while(fast != null && fast.getNext() != null){    fast = fast.getNext();    slow = slow.getNext();   }      String tmpKey = kthElementFromStart.getKey();   kthElementFromStart.setKey(slow.getKey());   slow.setKey(tmpKey);        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Its Easy, please do as explained below.  1.take 2 pinters say ptr1 and ptr2 and assign the root node address. 2.Move the ptr2 for the k times,this the pointer you have to swap keep the address with you. 3.Now move the both the pointer ptr1 and ptr2 both at time, the moment ptr2 reach to null, note down the ptr1. 4.swap the ptr1 and once node which you have restored before.  complexity is O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nstruct node \n{ \n    int info; \n    struct node *link; \n}; \nstruct node *create(struct node *start, int data); \nvoid exchange(struct node *start, int k); \nvoid display(struct node *start); \n \nint main() \n{ \n  int data,ans,k; \n  struct node *start=NULL; \n  do \n  { \n       cout<<\"Enter the value\"<>data; \n         start=create(start,data); \n         cout<<\"do you want to add another node?\"<>ans; \n    }while(ans==1); \n    display(start); \n    cout<<\"enter the position\"; \n    cin>>k; \n    exchange(start,k); \n    display(start); \n  getch(); \n  return 0; \n} \n \nvoid exchange(struct node *start, int k) \n{ \n   int count=0,s,i; \n   struct node *p,*q,*p1,*q1,*temp; \n   p=start; \n   q=p; \n   while(p!=NULL) \n   { \n          count++; \n          p=p->link; \n     } \n     try \n     { \n       if(k>count) \n         throw k; \n     //cout<<<<\" is the count\"<link; \n     } \n     s=count-k; \n     for(i=0;ilink; \n     } \n     if(p==q1) \n     { \n     int swap; \n     swap=p->info; \n     p->info=q->info; \n     q->info=swap; \n     return; \n     } \n     temp=q->link; \n     p1->link=q; \n     q->link=p->link; \n     q1->link=p; \n     p->link=temp; \n      \n     } \n     catch(int) \n     { \n     cout<<\"out of bounds\"<info=data; \n          start->link=NULL; \n          return start; \n  } \n  while(p->link!=NULL) \n  { \n          p=p->link; \n     } \n     temp=new node; \n     temp->info=data; \n     temp->link=NULL; \n     p->link=temp; \n     return start; \n} \n \nvoid display(struct node *start) \n{ \n   struct node *p=start; \n   while(p!=NULL) \n   { \n   cout<info; \n   if(p->link!=NULL) \n     cout<<\"->\"; \n   p=p->link; \n     } \n     cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"swapKthNode(node *head){ \n    temp=head \n    while(k!=1){ \n        if (head == NULL) return \"ERROR\"; \n        head = head->next; \n        k--; \n    } \n    first_node=head; \n    while(head->next!=NULL){ \n        head = head->next; \n        temp = temp->next; \n    } \n    second_node = temp; \n    swap(first_node->data, second_node->data) \n \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// (assuming k=0 means swap root and tail) \nNode* swapK (Node* head, int k) { \n \n Node* p1, p2, temp; \n int n = 1; \n  \n // no list, nothing to swap..  \n if (head == null || head->next = null) \n  return head; \n  \n // count length of list \n // optimized here to save time for k=0 below \n p1 = head; \n while(p1->next != null) { \n  p1 = p1->next; \n  n++; \n } \n  \n // negative values of k and k greater \n // then length of list are not valid \n if (k < 0 || k > n) \n  return NULL; // should actually throw error here \n \n // normalize k \n if (k > n/2) \n  k = n-k; \n   \n // special case if k=0 or k=n \n if (k == 0) { \n  // set p1 = 2nd to last node \n  p1 = head; \n  for (int i = 1; i < n-1; i++) \n   p1 = p1->next; \n  // set p2 = last node \n  p2 = p1->next; \n   \n  // set last node to point to 2nd node \n  p2->next = head->next; \n  // set 2nd to last node to point to head \n  p1->next = head; \n  // set head to point to nothing (it is now the last node) \n  head->next = null; \n   \n  // return the new head (p2) \n  return p2; \n } \n   \n // set p1 to (k-1)th node \n p1 = head; \n for (int i = 1; i < k; i++) { \n  p1 = p1->next; \n } \n // set p2 to (n-k-1)th node \n p2 = p1->next; \n for (int i = k; i < n-2k; i++) { \n  p2 = p2->next; \n } \n  \n // swap p1's next and p2's next \n temp = p1->next; \n p1->next = p2->next; \n p2->next = p1->next; \n // swap p1 next's next and p2 next's next \n temp = p1->next->next; \n p1->next->next = p2->next->next; \n p2->next->next = p1->next->next; \n  \n return head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void fn(node * start) \n  { \n     if(K>N)// if n given else traverse inO(n) to find the length \n       printf(\"ARRAY IS OF LESSER  SIZE\") \n    else \n   { \n        int traverse=0,count=0; \n        if(K>N-K) \n          traverse=N-K; \n       else traverse=K; \n      node * one ,*two; \n      one=start; \n      while(count++!=traverse) \n         one=one->next; \n      two=one; \n     traverse=abs(2*K-N) \n     count=0 \n     while(count++!=traverse)two=two->next \n     swap(one->data,two->data); \n     } \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void move_the_node(struct link_list **node, int mov) {         struct link_list *start_ptr, *end_ptr, *length_ptr;         int i=0,j;         if((*node)->next == NULL)         printf(\"No swapping..since list is empty\\n\");         else         {                 length_ptr = (*node);                 while(length_ptr)                 {                         i++;                         length_ptr = length_ptr->next;                 }                 if(i <= mov)                 printf(\"Cant swap..since no enough nodes\\n\");                 else{                 end_ptr = start_ptr = (*node);                 for(j=0; j                start_ptr = start_ptr->next;                 for(j=0; j<(i-mov-1); j++)                 end_ptr = end_ptr->next;                 i = end_ptr->data;                 end_ptr->data = start_ptr->data;                 start_ptr->data = i;                 }         } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"don't u think the question is too easy.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void swapListNodes(int swapPosition)             {                 Node advPointer = first;                 Node normalPointer = first;                 Node tempNode = first;                 Node iterator = first;                 int tempdata = 0;                 int loop = 1;                  if (swapPosition > count) return;                                while (loop < swapPosition)                 {                     if (iterator.next != null)                     {                         advPointer = iterator.next;                         iterator = iterator.next;                         loop++;                     }                 }                  tempNode = advPointer;  // at 3rd position from start                  while (advPointer.next != null)                 {                     advPointer = advPointer.next;                     normalPointer = normalPointer.next;                 }                                   tempdata = normalPointer.data;                 normalPointer.data = tempNode.data;                 tempNode.data = tempdata;             }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void swapkelement(struct list **l,int k) { struct list *x = *l; struct list *y; struct list *z = *l; int i; for(i=0 ; i < k  ; i++) { if(x == NULL) {  printf(\"LIST IS OF LESSER SIZE\");  return; } if(i == k-1) y = x; x = x->next; }  while(NULL != x) { z = z->next; x = x->next; }  i = y->data; y->data = z->data; z->data = i; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hey guys pls let me know if this is correct solution.....  void swap(nd *start,int val) { nd *temp; int count=0,j,i=0;  temp=start; while(temp->next!=NULL) { temp=temp->next; count++; } if(count>val) { j=0; temp=start; i=count-val; while(j++<=i) { temp=temp->next; } //p(\"from last %d\\n\",temp->data); count=0; while(count++{ start=start->next; } //p(\"from beg %d\\n\",start->data); //if(start->next==temp)                    //if both elements are adjacent to each other.... //{ int var; var=start->data; start->data=temp->data; temp->data=var; //p(\"list changed...\\n\");  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nint k,t1,t2; \nint x; \nvoid insert1(); \nvoid swap1(); \nvoid swap(); \nstruct Node1 \n{ \n int info1; \n Node1 *next1; \n}; \nNode1 *ptr1,*start1=NULL,*rear1,*save1; \nmain() \n{ \n cout<<\"How many nodes in list\\n\"; \n  \n cin>>x; \n for(int i=0;i>k; \n swap1(); \n //swap(); \n} \nvoid insert1() \n{ \n ptr1=new Node1; \n  \n if(start1==NULL) \n { \n  cout<<\"Enter info\\n\"; \n        cin>>ptr1->info1; \n  start1=ptr1; \n  ptr1->next1=NULL; \n  rear1=ptr1; \n } \n else \n { \n  cout<<\"Enter info\\n\"; \n        cin>>ptr1->info1; \n  rear1->next1=ptr1; \n  ptr1->next1=NULL; \n  rear1=ptr1; \n } \n} \nvoid swap1() \n{ \n int cnt=0; \n save1=start1; \n while(save1) \n { \n  cnt=cnt+1; \n  cout<<\"\\n\"<<\"COUNT HERE\\n\"; \n  cout<<\"\\n\"<info1; \n   \n  } \n   //save1=save1->next1; \n  if(cnt==(x-k) ) \n  { \n   t2=save1->info1; \n    \n  } \n  save1=save1->next1; \n   \n } \n int temp; \n temp=t1; \n t1=t2; \n t2=temp; \n cout<<\"VALUES INTERCHANGED\\n\\n\\n\"<<<\"\\t\"<info1; \n while(save1) \n { \n  save1=save1->next1; \n  cout<<\"\\n\"<info1; \n } \n} \nvoid swap() \n{ \n  \n}*/ \n      \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void swapindex(list L,int index){ List lst=new LinkedList(L); swap(lst,lst.get(index),lst.get(lst.size()-index)); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The running time is O(N) and hardly any space complexity .. the only trick here is to maintain the height of the node in the node object and the length of the linked list in the linkedlist instance   Here is the python implementation"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I simply did this by getting the two nodes from the get node function and then swapped the two. i got the answer correctly.   public LinkedListNode getNode(int index){   String str;   LinkedListNode prevnode = first.getNext();   for(int i=0;i   prevnode = prevnode.getNext();  // reaching the index node.   }   return prevnode;  }    // Swapping the Kth node from first and last alike.  public void specialSwap(int index){   LinkedListNode frontnode = first.getNext();   LinkedListNode lastnode = first.getNext();   frontnode = getNode(index);    // obtain the first node   lastnode = getNode(size()-index+1);  // obtain the last node      // Swap the Nodes values. no need  of breaking the nodes.   String temp = frontnode.getName();   frontnode.setName(lastnode.getName());   lastnode.setName(temp);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nusing namespace std; \n \nstruct node{ \n int data; \n node *next; \n}; \n \nint main() \n{ \n  \n node *list,*nptr,*tptr; \n int item,n,i; \n list=NULL; \n  \n cout<<\"PLEASE.......Type how many nodes that you want    \"; \n cin>>n; \n for(i=1;i<=n;i++) \n { \n  cout<<\"Type your \"<<<\" node item  \"; \n  cin>>item; \n  nptr=new(node); \n  nptr->data=item; \n  nptr->next=NULL; \n  if(list==NULL) \n  { \n   list=nptr; \n   tptr=nptr; \n  } \n  else \n  { \n   tptr->next=nptr; \n   tptr=nptr; \n  } \n } \n tptr=list; \n for(i=1;i<=n;i++) \n { \n   \n  cout<data<<\"    \"; \n  tptr=tptr->next; \n   \n } \n cout<<>k; \n tptr=list; \n first=k-1; \n last=(n-k); \n int mid=(n-k+2); \n node *pptr,*sptr,*wptr=NULL,*temp2=NULL,*temp1=NULL; \n int count=1; \n tptr=list; \n for(i=1;i<=n;i++) \n { \n   \n  if(count==first) \n  { \n   pptr=tptr; \n   temp2=pptr->next; \n  } \n  else if(count==last) \n  { \n   sptr=tptr; \n   temp1=sptr->next; \n    \n  } \n  else if(count==mid) \n  { \n   wptr=tptr; \n    \n  } \n  tptr=tptr->next; \n  count++; \n   \n   \n } \n int d; \n d=(n/2); \n if(d!=k) \n { \n   \n  temp1->next=pptr->next->next; \n   \n   \n  pptr->next=temp1; \n   \n   \n   \n  sptr->next=temp2; \n   \n   \n  temp2->next=wptr; \n } \n  \n else  \n { \n  pptr->next=temp1; \n  temp1->next=sptr; \n  sptr->next=wptr; \n } \n  \n  \n int g; \n  \n for(g=1;g<=n;g++) \n { \n  cout<data<<\"   \"; \n  tptr=tptr->next; \n   \n } \n  \n    cout<<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void mainwork() \n { \n//initialise to start. \n//count is the length of link list \n//n is the position at which swap needs to be made. \n temp=p; \n int count=0; \n while(temp!=NULL) \n { \n count++; \n temp=temp->link; \n } \n int n=4; \n prev=p; \n curr=prev->link; \n next=curr->link; \n for(int i=0;ilink; \n  curr=curr->link; \n  next=next->link; \n } \n prev1=p; \n curr1=prev1->link; \n next1=curr1->link; \n for(i=0;ilink; \n  curr1=curr1->link; \n  next1=next1->link; \n } \n //cout<<\"\\n\"<data<<\",\"<data; \n \n if(nlink=curr1; \n curr1->link=next; \n prev1->link=curr; \n curr->link=next1; \n } \nelse \n{ \n \ncout<<\"Cant perform this operation\"; \n \n} \n \n \n \n \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n \nstruct node { \n int data; \n struct node *link; \n}; \n \nint append(struct node **q,int num) { \n struct node *temp, *r; \n temp = *q; \n if(temp == NULL) { \n  temp = (struct node *) malloc(sizeof(struct node)); \n  temp->data = num; \n  temp->link = NULL; \n  *q = temp; \n  return 0; \n } \n while(temp->link != NULL) \n  temp = temp->link; \n r = (struct node *) malloc(sizeof(struct node)); \n r->data = num; \n temp->link = r; \n return 0; \n} \n \nint display(struct node *q) { \n struct node *temp = q; \n while(temp != NULL) { \n  printf(\"data = %d\\n\",temp->data); \n  temp = temp->link; \n } \n return 0; \n} \n \nint sizeofl(struct node *temp) { \n int count = 0; \n struct node *temp1 = temp; \n while(temp1 != NULL) { \n  count++; \n  temp1 = temp1->link; \n } \n return count; \n} \n \nint swap_list(struct node **q,int position) { \n struct node *temp = *q, *ptr1 = *q,*ptr2 = *q; \n int size_list,i,temp_data = 0; \n size_list = sizeofl(temp); \n printf(\"count = %d\\n\",size_list); \n for(i=1; ilink; \n printf(\"ptr1 data = %d\\n\",ptr1->data); \n for(i=0;ilink; \n printf(\"ptr1 data = %d\\n\",ptr2->data); \n temp_data = ptr1->data; \n ptr1->data = ptr2->data; \n ptr2->data = temp_data; \n return 0; \n} \n \nint main() \n{ \n struct node *k = NULL; \n append(&k,1); \n append(&k,2); \n append(&k,3); \n append(&k,4); \n append(&k,5); \n append(&k,6); \n append(&k,7); \n append(&k,8); \n append(&k,9); \n display(k); \n swap_list(&k,3); \n display(k); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void swap(struct node *node1,struct node *node2) {     if(node1 == NULL || node2 == NULL)     {       cout<<\"LIST IS OF LESSER SIZE\"<      return;     }     int temp_data = 0;     temp_data = node1->data;     node1->data = node2->data;     node2->data = temp_data;     struct node *temp = start;     while(temp->next != NULL)     {        cout<data<<\"->\";        temp = temp->next;     }     cout<data<}  void trav_swap(int K) {     int curr = 1;      struct node *temp = start;     struct node * node1 = NULL, *node2 = NULL;     if(K == 0)     {       cout<<\"INVALID INPUT\"<      return;     }     while(temp != NULL && curr != K)     {                temp = temp->next;                curr++;     }     if(curr == K)     {         node1 = temp;         node2 = start;         while(temp->next != NULL)         {            temp = temp->next;            node2 = node2->next;         }     }     swap(node1,node2);      }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void swap(struct node *node1,struct node *node2) \n{ \n    if(node1 == NULL || node2 == NULL) \n    { \n      cout<<\"LIST IS OF LESSER SIZE\"<data; \n    node1->data = node2->data; \n    node2->data = temp_data; \n    struct node *temp = start; \n    while(temp->next != NULL) \n    { \n       cout<data<<\"->\"; \n       temp = temp->next; \n    } \n    cout<data<next; \n               curr++; \n    } \n    if(curr == K) \n    { \n        node1 = temp; \n        node2 = start; \n        while(temp->next != NULL) \n        { \n           temp = temp->next; \n           node2 = node2->next; \n        } \n    } \n    swap(node1,node2); \n     \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use double linked list & two pointers,one from first till our k value and another from last till our k value then exchange the values"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"check skillgun.com for free online tests with java interview questions"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Algorithm: 1.Get the linked list lenghth. If it is less than 'K' print the error message. O(N) 2.Traverse to the 'K' the element from the beginning. O(N) 3.Traverse to the N-Kth element from the beginning. O(N) 4. Swap them.O(1) 5.End of Algorithm  Complexity: O(N)."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13578662","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"27","title":"Q4. Written Exam Amazon(Bangalore)  Given an array of integers A[1....n-1] where 'N' is the length of array A[ ]. Construct an array B such that B[i] = min(A[i], A[i+1], ......., A[i-K+1]), where K will be given. Array B will have N-K+1 elements.  Constraint: Extra space allowed O(K) and time complexity allowed O(N.K) or lower.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"10","title":"Looks like below is not correct B[i] = min(A[i], A[i+1], ......., A[i-K+1]), where K will be given.  here A[i-K+1] should be A[i+k-1]  if i=0, and k=4 then i-K+1 will be negative, which is not correct"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"the algo could go on like this.... 1.scan the array in reverse order and create a min heap of k elements. 2.the element B[i] would be the element at the root of min heap. 3. now delete the element at A[K+i -1] and insert the element A[i-1] 4.reheapify the heap. TC-O(nlogk)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Is it not a sliding window problem ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"yes it should be i+k -1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"segment tree concept will be used"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"segment tree concept will be used"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"segment tree concept will be used"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think question is that k is some given number and length of B is N-k+1,  So can be done in O(n) Time Complexity  Traverse the array from  i=N-k+1 to i=0{ keep one min variable if(a[i]b[i]=min; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the algo could go on like this.... 1.scan the array in reverse order and create a min heap of k elements. 2.the element B[i] would be the element at the root of min heap. 3. now delete the element at A[K+i -1] and insert the element A[i-1] 4.reheapify the heap. TC-O(nlogk)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we can use selection to find the min. number and complexy will be o(n)  and space used will be o(1)....."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution: O(n) time and excluding the result space + O(1) space if there are no duplicates (if there are duplicates we can move them to the end of the array and use extra HashMap to count the duplicates) Here is the java code for nonDuplicate version (can be easyly modified for duplicates) :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can use binary search for it. Step-1: Add 1st k elements to bst tree. Step-2: Print the min element from bst tree Step-3: Print min element and Remove the ith element Step-4: Add the i+k+1 th element..i++ Step-5: Repeat Step-2,3,4 until no more elements"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using queue."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"can be done in O(N)  1.b[0] = the minimum of (0,1,K-1) 2. b[1] = min(b[0], a[k] 3. b[2] = min(b[1], a[k+1]"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15920664","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"33","title":"Write a program to sort an array of strings so that all anagrams are next to each other  ex input {god, dog, abc, cab, man} output {abc, cab, dog, god, man}","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"use a hash table, the key is sorted string, and all the string combined by these character is in one block. for example hashtable[abc]={abc,cab}, hashtable[dgo]={dog,god}. And then sort it by the order of the first character of each key."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Short and Sweet:  import java.util.Arrays; import java.util.Comparator;  public class StrAnaSort {   public static void main(String[] args)   {   String[] strArr =  {\"god\",\"dog\", \"abc\", \"cab\", \"man\"};   Arrays.sort(strArr, new AnagramComparator());   for(String str:strArr)   {    System.out.print(str+\" \");   }  } }  class AnagramComparator implements Comparator {   @Override  public int compare(String str1, String str2)   {   return sumLetters(str1)-sumLetters(str2);  }    private int sumLetters(String str)  {   int sum = 0;   for(int ch:str.toCharArray())   {    sum+=ch;   }   return sum;  }   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"write the sort compare criteria of two strings (str1, str2) as bellow 1> build two arrays p1[256], p2[256], set to zero in the begging. 2> for each character c in str1, let p1[a]++ 3> for each character d in str2, let p2[d]++; 4> check count from 1 to 255,      4.1> if p1[count]>p2[count],           4.1.1>  If there exist one count2 >count that p2[count2]>0 , then str1 < str2,                       for case str1=\"aaaacdefdg\", str2=\"aaab\"           4.1.2> if for all count2 >count, p2[count2]=0 then str1>str2                     for case str1=\"aaaacdefdg\", str2=\"aaa\"     4.2> if p1[count]          4.2.1> if there is count2 >count, p1[count2]>0, then str1>str2                    symmetric as 4.1.1.           4.2.2> if for all count2> count, p1[count2]=0, then str1                   symmetric as 4.1.2. 5> if all p[count]=0, then using strcmp to find which str is bigger.  then people could use the quick sort to perform the sorting, by copying the str address but not the whole string while doing the swapping."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Concatenate sorted string and original string. Then sort god->dgogod dog->dgodog"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just override the comparator.. that should do it.. This works in Java. For other's I don't know."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just need to keep track the min element for each anagrams set in order to compare correctly."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def radixsort(array): \n    maxlen = len(max(array,key = lambda x: len(x))) \n    i = maxlen - 1 \n    while i >= 0: \n        array = sorted(array,key=lambda x:x[i] if i < len(x) else 0) \n        i -= 1 \n    return array"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// first pass insert all strings into a hash table, key = string, value = sorted key  now call bubble sort or any other sort with following a Compare function which compares first the value of the string and then then key if needed."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; \nimport java.util.HashMap; \nimport java.util.List; \nimport java.util.Map; \n \n \npublic class wordSequence { \n /** \n  * @author: Amarkant kumar ,DUCS \n  */ \n public static void main(String[] args) { \n  // TODO Auto-generated method stub \n  String[] data = {\"cat\",\"dog\",\"act\",\"god\",\"tac\"};  \n  processData(data); \n } \n \n private static void processData(String[] data) { \n   \n  Map> obj = new HashMap<>(); \n  for(int i=0;i()); \n    obj.get(a).add(data[i]); \n   } \n   else \n   { \n    if(obj.get(a) == null) \n    { \n     obj.put(a, new ArrayList()); \n     obj.get(a).add(data[i]); \n    } \n    else \n    { \n     obj.get(a).add(data[i]); \n    } \n   }  \n  } \n  System.out.println(obj.values()); \n   \n } \n} \n \n/* \n * Output: [[cat, act, tac], [dog, god]] \n *  \n * */"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Python Solution Using Key Function:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def sort_words(a) \n  swapped = true \n  while swapped \n   swapped = false \n   0.upto(a.size - 2) do |i| \n     if a[i][0] > a[i+1][0] \n      a[i], a[i+1] = a[i+1], a[i] \n      swapped = true \n     end \n   end \n  end \n  a \nend"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.*; \n \npublic class SortAnagramsNext { \n \n   public static List sortWithAnagramsTogether(List elements) { \n      List sortedElements = sort(elements); \n      Map> anagramMap = new LinkedHashMap>(); \n      for (String element : sortedElements) { \n         String sortedElement = sortChars(element); \n         if (anagramMap.get(sortedElement) == null) { \n            anagramMap.put(sortedElement, new ArrayList()); \n         } \n         anagramMap.get(sortedElement).add(element); \n      } \n      Map> tmpMap = new LinkedHashMap>(); \n      for (String key : anagramMap.keySet()) { \n         tmpMap.put(anagramMap.get(key).get(0), anagramMap.get(key)); \n      } \n      anagramMap = tmpMap; \n      List sortedWithAnagrams = new ArrayList(); \n      List mapKeys = new ArrayList(anagramMap.keySet()); \n      Collections.sort(mapKeys); \n      for (String mapKey : mapKeys) { \n         for (String element : anagramMap.get(mapKey)) { \n            sortedWithAnagrams.add(element); \n         } \n      } \n      return sortedWithAnagrams; \n   } \n \n   public static String sortChars(String str) { \n      char[] strChars = str.toCharArray(); \n      Arrays.sort(strChars); \n      return String.valueOf(strChars); \n   } \n \n   public static List sort(List elements) { \n      List sortedElements = new ArrayList(elements); \n      Collections.sort(sortedElements); \n      return sortedElements; \n   } \n \n   public static void main(String[] args) { \n      List elements = Arrays.asList(\"god\", \"dog\", \"abc\", \"cab\", \"man\"); \n      List sortedElements = sortWithAnagramsTogether(elements); \n      System.out.println(sortedElements); \n   } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static String sortString(String x) \n { \n  char[] ar = x.toCharArray(); \n  Arrays.sort(ar); \n  String sorted = String.valueOf(ar); \n   \n  return sorted; \n } \n  \n static String[] q5(String[] x) \n { \n  HashMap> y=new HashMap>(); \n   \n  for(int i=0;i()); \n   y.get(sortString(x[i])).add(x[i]); \n  } \n   \n  int count=0; \n  String[] result=new String[x.length]; \n   \n  for (ArrayList z:y.values()) \n  { \n   for (String a:z) \n   { \n    result[count++]=a; \n   } \n  } \n  return result; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \nusing namespace std; \nbool compare_anagram (string first, string second) \n{ \n  sort(first.begin(), first.end()); \n  sort(second.begin(), second.end()); \n  return (first < second); \n} \nint main() { \n list inputList = {\"agodz\", \"zadog\", \"abc\", \"az\", \"za\",\"cab\", \"man\"}; \n inputList.sort(compare_anagram); \n// inputList.sort(); \n for(list::iterator it = inputList.begin(); it != inputList.end(); ++it) { \n  cout << endl << *it; \n } \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi I'm getting anagrams sorted. But the overall alphabetical sorting isn't happening"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \n#include  \n \ntypedef std::map AnagramStringMap; \ntypedef AnagramStringMap::iterator AnagramStringMapIter; \ntypedef std::vector StringVector; \ntypedef StringVector::iterator StringVectorIter; \n \nvoid AnagramSort(StringVector& vInput) \n{ \n    std::sort(vInput.begin(), vInput.end());                // sort with complexity n * log(n) \n    AnagramStringMap anagramMap; \n    for (StringVectorIter it = vInput.begin(); it != vInput.end(); ++it) \n    { \n        std::string s(it->rbegin(), it->rend());            // anagram of current string \n        AnagramStringMapIter mapIt = anagramMap.find(s);    // find it in map (log(n)) \n        if (mapIt != anagramMap.end()) \n            mapIt->second = *it;                            // if already exists set current string as value \n        else \n            anagramMap.insert(std::make_pair(*it, \"\"));     // else insert it as a new key (log(n)) \n    } \n    AnagramStringMapIter mapIt = anagramMap.begin(); \n    StringVectorIter it = vInput.begin(); \n    for (; mapIt != anagramMap.end(); ++mapIt, ++it) \n    { \n        *it = mapIt->first;                                 // copy value to array \n        if (!mapIt->second.empty())                         // if word has anagram then copy it to the next index \n        { \n            ++it; \n            *it = mapIt->second; \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String args[]) {  String []a = {\"god\", \"dog\", \"abc\", \"cba\", \"man\",\"nam\"};  Map b = new TreeMap();  for (int i=0;i {   b.put(a[i], a[i]);  }     for (Entry e : b.entrySet())  {   System.out.println(e.getValue());  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String args[])  {   String []a = {\"god\", \"dog\", \"abc\", \"cba\", \"man\",\"nam\"};   Map b = new TreeMap();   for (int i=0;i  {    b.put(a[i], a[i]);   }      for (Entry e : b.entrySet())   {    System.out.println(e.getValue());   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \n \nusing namespace std; \n \nvoid anagram_sort(vector& words) { \n    sort(begin(words), end(words), [](const string& x, const string& y) \n    { \n        if (x.length() != y.length()) \n            return x.length() < y.length(); \n        else { \n            string xx(x), yy(y); \n            sort(begin(xx), end(xx)); \n            sort(begin(yy), end(yy)); \n            return xx < yy; \n        } \n    }); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package string; import java.util.*; import java.lang.StringBuffer; import java.util.Arrays;  public class WordSequence {  public HashMap check=new HashMap();  public HashMap store=new HashMap();  public void storeInHashMap(String[] str){   for(String st:str){    check.put(st, 1);    }   for(String st:str){    String reverse=new StringBuffer(st).reverse().toString();    if(check.containsKey(reverse)){     if(st.compareTo(reverse)<0){      store.put(st, st+\",\"+reverse);     }else{      store.put(reverse, reverse+\",\"+st);     }    }else{     store.put(st, st);    }       }   sortWord();  }  public void sortWord(){   String[] str= (String[]) store.keySet().toArray(new String[0]);   Arrays.sort(str);   for(String st:str){    System.out.println(store.get(st));   }  }  public static void main(String[] args){   String[] data = {\"cat\",\"dog\",\"act\",\"god\",\"tac\"};    new WordSequence().storeInHashMap(data);  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First, group the anagrams by sorting the letters of each word, and using the word that these sorted letters form as a key for a dictionary.  For example, groups['abc'] = ['abc', 'cab'] Then, take the first word from each of these lists, sort them, then insert the other anagrams accordingly."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I keep a hash with the sorted word as key.To sort a word i use an array of 26 elements, each representing a letter."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"So the key would essentially be the ascii value of the string  i.e"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"why we are not using"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15903683","download_status":"DOWNLOAD_DONE","votes":"3","answersCount":"27","title":"Coding:","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"To prevent the deadlock, could we define an order for the account ID or the account itself, make sure it is transitive, means, Order(A)>Order(B), Order(B)>Order(C), ==> Order(A)>Order(C), and Order(A)==Order(B) ==> A==B.  Then you can lock each Accounts following their orders."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Reference: Java Concurrency in Practice, pg: 209  The answer to the 3rd part of the question is...inducing a lock ordering to avoid deadlock.  int fromHash = System.identityHashCode(a1) int toHash = System.identityHashCode(a2)  if(fromHash < toHash){  synchronized(a1){      synchronized(a2){         .... swap amounts      }  } }  else if(fromHash > toHash){  synchronized(a2){      synchronized(a1){         .... swap amounts      }  } }  else{  synchronized(tieLock){    synchronized(a1){      synchronized(a2){         .... swap amounts      }  }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In a banking scenario, you often have these conditions:    1) Individual accounts have very little activity.   2) Accessing accounts has very high latency.  A small problem to avoid is the race where the same account is being incremented/decrement at the exact same millisecond.  This can be handled with a simple mutex.  The bigger problem is that additions/subtractions to an account can't actually be committed until the remote account confirms the trade.  From a practical standpoint, the bank wants to err on the side of rejecting transactions prematurely.  In other words, it wants to avoid ever promising funds from an account that has uncommitted credits, but it is also wants to avoid promising funds where provisional debits would lessen the balance upon commit.  So let's say Alice agrees to transfer $100 to Bob's account, and the transaction is initiated from a data center remote to both banks.   The financial soundness of the transaction only hinges on Alice having sufficient funds in her account, so the remote data center notifies Alice's bank of the desired transfer.  If Alice's provisional balance is too low, the transaction is immediately rejected.  Otherwise, her available balance is immediately debited, and you make sure the transaction can be committed on Bob's end (i.e. his account is active, the network is available, etc.).  At this point, the transaction is sound from a financial standpoint, but you can't commit it until Bob eventually gets the money in his bank.  So, then you post the transfer to Bob's account, and if he confirms it, you then commit the transfer on Alice's end.  Remember that I said that individual accounts have very little activity, so for each account, you can inexpensively manage a data structure of all the uncommitted transfers.  In some cases uncommitted transfers will be explicitly rolled back by the other party, but you also have to account for data failures, so you will have expiration logic.  Here, you need to be very careful managing funds availability.  Alice's bank can't release funds for her until it's certain that Bob hasn't been credited.  On the other hand, Bob's bank can roll back his credit after a timeout.  Asking this problem in terms of Java is kind of contrived, because this is really more of a systems engineering question than a coding question.  With a single data center, you would be more likely to using a locking model than a phased commit model, but bank transactions typically involve lots of latency between banks."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void TransferAccount(AccountID  id1, AccountID id2) \n{ \n //The idea is not to use the exclusive lock simultaneously which can cause deadlock.  \n Account a1 = id1.GetAccount(); \n Account a2 = id2.GetAccount(); \n \n //Get an exclusive lock on id1 and not so exclusive(read on id2 - will make sure that id2 value doesnt change and lock can be held by multiple threads.)  \n id1.writeLock().lock(); \n id2.readLock.lock(); \n temp = a1.getBalance(); \n a1.Balance = a2.Balance; \n id2.readLock.unlock(); \n id1.writeLock().unlock(); \n \n //Get exclusive lock on id2 to write to it.  \n id2.writeLock().lock(); \n a2.Balance = temp; \n id2.writeLock().unlock(); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void TransferAccount(AccountID  id1, AccountID id2) \n{ \n //The idea is not to get the exclusve lock which can cause deadlock.  \n Account a1 = id1.GetAccount(); \n Account a2 = id2.GetAccount(); \n \n //Get an exclusive lock on id1 and not so exclusive(read on id2 - will make sure that id2 value doesnt change and lock can be held by multiple threads.)  \n id1.writeLock().lock(); \n id2.readLock.lock(); \n temp = a1.getBalance(); \n a1.Balance = a2.Balance; \n id2.readLock.unlock(); \n id1.writeLock().unlock(); \n \n //Get exclusive lock on id2 to write to it.  \n id2.writeLock().lock(); \n a2.Balance = temp; \n id2.writeLock().unlock(); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ok so you don??t want to lock around the entire method since AccountID.GetAccount() is external code and you have no idea what it is doing. You don??t want to lock on the Ids or the Accounts for the same reason they are coming from elsewhere and may or may not be the same instance every time the method is called. If they are not the same instance every time then your locking does not work and you get straight into the locked code twice if lock on them. We only want to lock around code we have complete control of.  If we keep a collection of accounts that we are currently working on then we can use that to make sure that we do not try the same account twice at the same time. We can also then do our checks for both accounts within one lock."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Thank you for posting this problem!! It pushed me to read about alternatives for using locks.  For situations where you need good scalability with respect to the number of threads and the 'size' of the critical section, using a lock is not the correct way to go.  Using wait-free and lock-free approach may help alleviate the problem here. Use Compare And Swap (CAS) or its variants. Since I am still learning about CAS and it use, here are some pointers to help you guys out. [ibm].com/developerworks/library/j-jtp11234/] [http:][//audidude][.com/?p=363]  Java has a .util.concurrency.atomic package provides support for wait-free and lock-free approaches. I will post out a solution as soon as I get a grip on the CAS idea and its likes."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class Account { \n \n  private Lock balanceLock; \n  private double balance; \n \n  public Account() \n  { \n   balanceLock = new ReentrantLock(); \n  } \n \n \n  public synchronized setAccount(double newBal) \n  { \n   balance = newBal; \n  } \n \n  public synchronized double getBalance() \n  { \n   return balance; \n  } \n \n } \n \n /****************************   ANSWER *************************/ \n \n public void TransferAccount(AccountID  id1, AccountID id2){ \n  Account a1 = id1.GetAccount(); \n  Account a2 = id2.GetAccount(); \n  \n  //Swap amounts. \n  \n  double temp = a1.getBalance(); \n  a1.setBalance(a2.getBalance());  \n  /**  will get a2 balance until synchronization ends, then will run a1.setBalance() **/ \n  double temp2 = a2.getBalance(); // if a2.getBalance() as a parameter causes deadlock, but it shouldn't \n  a2.setBalance(temp); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Are these questions asked during the interview for SDE internship or just SDE full-time job?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think there are anyway two read and write operations in one atomic process, so it is obviously not CAS, and also can't be solved by the way ConcurrentHashMap and AtomicXXX did. If those two accounts have the reference pointing to the same object like user, we may use user object for locking, otherwise I did not figure out a high efficient way to do it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Homework? Multiple questions on threading/synchronization/deadlocks..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Don't synchronize the entire method, just the critical block:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17042664","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"22","title":"Special Property Numbers: Eg--> You have a number 8987656 or 4565676 The difference between consecutive numbers is either 1 or -1.  You are given a range, you need to print the numbers with this special property.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"It is very simple problem. For every start to end first digit, we need to create a tree. For example 500000 to 600000 is given range that we need to create a binary tree where left child is one less than the parent digit and right child is 1 greater the parent digit.  After the tree constructed, take root and do all traversal to all possible leaf at level count ( decimal points of start ) and generate a number for such branch.  Check is this number is in limit, if yes print it. Like this keep doing till the first digit <= last. No need to do traverse like this for(int i=start;i \n   \n    \n   -  \n     Paras Dattani \n     on April 08, 2013 Edit | Flag  \n    \n    \n   Reply"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public class SpecialPropetyNos { \n public static void main(String[] args) { \n  int Limit = 4; \n  for (int nos=0;nos<10;nos++){ \n   generateNos(nos, (Limit-1)); \n  } \n } \n \n private static void generateNos(int nos, int limit) { \n  if (limit == 0){ \n   System.out.println(nos); \n   return; \n  } \n  if ( nos%10 != 9) \n   generateNos( ((nos*10)+ (nos%10+1)), (limit-1) ); \n   \n  if( ((nos%10)-1 ) > -1 ){ \n   generateNos(((nos*10)+(nos%10-1)), (limit-1)); \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"\"You are given a range\", what range, can you explain more?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \nusing namespace std; \n \nint main(int argc, char** argv) \n{ \n //long l=8987656; \n long l=89876564; \n long temp_num = l; \n int prev = -1; \n int cur; \n bool isSpecial=true; \n while(temp_num) \n { \n  cur = temp_num%10; \n  temp_num = temp_num/10; \n  if (prev == -1) \n   prev = cur; \n  else \n  { \n   if(cur != prev+1 && cur != prev-1) \n   { \n    isSpecial = false; \n    break; \n   } \n   prev = cur; \n  } \n } \n cout<<\"Number \"<<<\" is special? \"<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//function to check weather the given number satisfies the property  //i.e 8987656 returns true  //ie.8987657 returns false  //for number 8987656 val1= 5 and val2=6 for first iteration.  bool findProperty(int num) {   int val1=0;  int val2=-1;   while(num>0)  {   val1=num%10;   num=num/10;    if(val2!=-1)   {     int result=val1-val2;     if(result ==1 || result ==-1)     {      }     else      return false;     val2=val1;   }   else    val2=val1;    }  return true; }  findnumbaer() {  for (int i=range_start;i<=range_end;i++)  {   bool flag=findProperty(i);   if(flag)   std::cout<  std::endl;   }  }  Please correct if I am wronge."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class glassdoor2{ \n \npublic boolean check(int i){ \n int prev=i%10; \n int curr; \n i=i/10; \n while (i>0) \n { \n  curr=i%10; \n  if ((prev-curr==1)||(prev-curr==-1)) \n   prev=curr; \n  else  \n   return false;  \n    \n  i=i/10;  \n } \n  \n return true; \n} \n \npublic void compute(int start,int end) \n{ \n for(int i=start;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be quite easily done by recursion. This is an interview question, and not a real life example. So the emphasis is on doing something elegant, not long. Here is a recursive solution that accomplishes this:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package com.trails; \n \npublic class NumberGenerator { \n static int start = 4565676; \n static int end = 8987656; \n  \n static int sDigit; \n static int eDigit; \n  \n public static int getDigit(int number){ \n     int counter = 0; \n     while(number != 0){ \n        counter++; \n  number = number / 10; \n      } \n  return counter; \n } \n  \n public static int getFirstDigit(int number){ \n  while(getDigit(number) != 1){ \n   number = number / 10; \n  } \n   \n  return number; \n } \n  \n public static void main(String[] args) { \n  sDigit = getDigit(start); // Find total number of Digit \n  eDigit = getDigit(end); // Find total number of Digit \n   \n  int firstNode = getFirstDigit(start); // Get first digit of end \n  int lastNode = getFirstDigit(end); // Get first digit of end \n \n  // Till first digit <= last digit \n  while(firstNode <= lastNode){ \n   generateNumbers(firstNode, firstNode, 1); \n   firstNode++; \n  } \n } \n \n      private static void generateNumbers(int number, int currentNode, int digit) { \n       // if current number of digits are more than start digits and number is in range \n      if(digit >= sDigit && number >= start && number <= end){ \n   System.out.print(number+ \",\"); \n   return; \n  } \n   \n  // If number contains more digits than the end stop immediately \n  if(digit > eDigit) \n   return; \n \n //If current digit for processing is 0, stop this branch \n if(currentNode != 0) \n      generateNumbers(10 * number + (currentNode-1), currentNode - 1, digit + 1); \n   \n //If current digit for processing is 9, stop this branch \n if(currentNode != 9) \n     generateNumbers(10 * number + (currentNode + 1), currentNode + 1, digit + 1); \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Given input range limits: low and high (both inclusive).  Assume that you are generating numbers of length, say N.  Have a driver function that sets the value of the first number, first 'low' upto 'high'. then call a recursive function that does +1 and -1 to the previous value. Code here [tested]:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Range can be easily added.  public class SpecialNumber {   static String mainData = \"0123456789\";  public static void main(String[] args) {   printSpecialNo(\"\",\"0123456789\",3);  }   private static void printSpecialNo(String res, String data, int n) {   if(n==0) {    //print    System.out.println(res);    return;   }   for(int i=0;i   printSpecialNo(res+data.charAt(i), getData(data,i), n-1);   }   private static String getData(String data, int i) {   String modifiedData=\"\";   int b = Integer.parseInt(data.charAt(i)+\"\");   for(int j=0;j   int a = Integer.parseInt(mainData.charAt(j)+\"\");        if(Math.abs(a-b)==1)     modifiedData+=Integer.toString(a);   }   return modifiedData;  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The problem becomes much more tractable if the special no. is treated as a string. The recursive logic goes something like this: for every number n  in the given range: spl_no_str = n + spl_no_str(n-1); and spl_no_str = n + spl_no_str(n+1);"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14952424","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"22","title":"Find the union of non-overlapping ranges, e.g; given an array {0,3,1,5,7,9,8,13} where 0 is starting point and 3 is the end point and so on. The output should be {0,5,7,13}","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"hi shaik, is the array given is having ranges in sorted order or not?? unsorted can be {0,3,7,9,1,5,8,13}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"package com.test;  import java.util.*;   public class MyOverLapRange {    public static void main (String args[]){      int a []={0,3,1,5,7,9,8,13};      Map b= new HashMap();   List finalNonOverLapInerval =new ArrayList();     boolean isInterval=true;   //put the integers in pairs   for (int i=0 ;i< a.length;i++)   {    if (i   if ( i==0){    b.put(a[i], a[i+1]);    }    else{          b.put(a[i+i], a[i+i+1]);    }    }       }         //loop over elements of array to see if occur in any of the interval in this style x  //if not  add them to a non-overlapping intervals   for (int i=0 ;i< a.length;i++){        isInterval=true;        //uncomment to trace values     // System.out.println(\"a = \" + i + \", Value = \" + a[i]);        Iterator> entries = b.entrySet().iterator();              while (entries.hasNext()) {          Map.Entry entry = entries.next();            //uncomment to trace values         //   System.out.println(\"Key = \" + entry.getKey() + \", Value = \" + entry.getValue());                if ( entry.getKey()< a[i] && a[i]< entry.getValue()){                isInterval=false;       }       }        if (isInterval){          finalNonOverLapInerval.add(a[i]);     }   }      //printing the  non-overlapping intervals   for (int i=0 ;i< finalNonOverLapInerval.size();i++){        System.out.println(\"result[\"+i+\"]: \"+finalNonOverLapInerval.get(i));       }  }     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The ranges are in sorted order, {0,3,1,5,7,9,8,13}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Thanks Rajkumari, it's working perfectly fine, I'm just trying to understand it now."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I can't understand the question. @shaik can you explain a bit more what is being asked?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Maybe I am not understanding the question correctly, but why can you not do something simple like the code I have below. You can simply iterate over the array once, which and get all of the values you need. Basically it will given you the end points of each non-overlapping arrays of a given range."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can you elaborate what is being asked in the question."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can you explain the question"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int b[]={0,3,1,5,7,9,8,13}; \n int n=sizeof(b)/sizeof(b[0]); \n for(i=0;i<=n/2;i+=2) \n { \n  int j=i+2; \n  while(jb[i] && b[j]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void NonOverlappingRanges(int[] arr) \n        { \n            int min = 0; \n            int max = 1; \n            for (int i = 2; i < arr.Length; i += 2) \n            { \n                if (arr[i] < arr[max]) \n                { \n                    if (arr[i + 1] <= arr[max]) \n                    { \n                        arr[i] = -1; \n                        arr[i + 1] = -1; \n                    } \n                    else \n                    { \n                        arr[max] = arr[i] = -1; \n                        max = i + 1; \n                    } \n                } \n                else \n                { \n                    min = i; \n                    max = i + 1; \n                } \n            } \n            for (int i = 0; i < arr.Length; i++) \n            { \n               if(arr[i]!=-1) \n                Console.WriteLine(arr[i]); \n            } \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.LinkedList; import java.util.List;  public class OverLappingRanges {   public static void main(String[] args) {   int inpranges[] = {0,3,1,5,7,9,8,13};   List listR = new LinkedList();   for(int i=0;i   Range r = new Range(inpranges[i*2], inpranges[i*2+1]);    listR.add(r);   }      List finalRanges = new LinkedList();   Range prev = listR.get(0);   int i =1;   while(i< listR.size()){    Range curr = listR.get(i);    if(prev.low<= curr.low && prev.high >= curr.low){     prev.high = Math.max(prev.high, curr.high);    }else{     finalRanges.add(prev);     prev = curr;    }    i++;   }   finalRanges.add(prev);      for (Range range : finalRanges) {    System.out.print(range.low+\"  \"+range.high+\" \");   }   System.out.println();  }  }  class Range{  int low;  int high;  public Range(int low, int high){   this.low = low;   this.high = high;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think A dynamic connectivity (Quick Union) approach would be a best fit for this problem. the union operation would group two ranges if they overlap else not. The find operation would return the group (root) of the query group."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Scala:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class rengetest \n{ \n    public static void main(String[] args) \n    { \n        int[] A = { 0, 3, 1, 5, 7, 9, 8, 13 }; \n        for (int i = 1; i < A.length; i += 2) \n        { \n            int rangeStart = A[i - 1]; \n            int rangeEnd = A[i]; \n            for (int l = rangeStart; l <= rangeEnd; l++) \n            { \n                boolean isInRange = false; \n                for (int j = 1; j < A.length; j += 2) \n                { \n                    int internalRangeStart = A[j - 1]; \n                    int internalRangeEnd = A[j]; \n                    isInRange = isInRange(l, internalRangeStart, \n                            internalRangeEnd); \n                    if (isInRange) \n                    { \n                        break; \n                    } \n                } \n                if (isInRange == false) \n                { \n                    System.out.println(l); \n                } \n            } \n        } \n \n    } \n \n    public static boolean isInRange(int number, int rangestart, int rangeEnd) \n    { \n        if (number > rangestart && number < rangeEnd) \n        { \n            return true; \n        } \n        return false; \n    } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If input is not sorted,sort it with begin time inc"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.*; public class Overlap {   public Overlap() {   // TODO Auto-generated constructor stub  }   public static Set  fixOverLap(int[]A){      Set newList = new LinkedHashSet();   int pre=0;   for (int i=1;i  {    if (i==(A.length))    {          if (A[i-1]>pre)     {      newList.add(A[i-1]);        }     break;    }         if (A[i-1]<=A[i])    {     newList.add(A[i-1]);      pre=A[i-1];         }    else{     i+=1;      }   }   return newList;  }    public static void main(String[] args) {   // TODO Auto-generated method stub   int []A={0,3,1,5,7,9,8,13};      System.out.println(fixOverLap(A));   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"private int[] NonoverlappingArray(int[] ArrayInput) { int[] ArrayOutput = new int(1000); //suppose the entries are <1000 for(int i=1;i{ if(ArrayInput[i] > ArrayInput[i-1] && ArrayInput[i] < ArrayInput[i+1]) { ArrayOutput[i] = ArrayInput[i]; } else if(ArrayInput[i] < ArrayInput[i-1] && ArrayInput[i] > ArrayInput[i+1]) { ArrayOutput[i] = ArrayInput[i]; } } return ArrayOutput.RemoveNull(); }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=19299666","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"20","title":"Merge the given 2 input sorted arrays of numbers into one . The merged array stays sorted .","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"import java.util.Arrays;  public class MergingArrays {      public static void main(String arg[]) {         int [] a = {1,3,4, 5,6,7,8};         int [] b={4,6,7,8,9,10,11,12,13,14,15};          int [] c= new int[a.length+b.length];         int i=0,j=0,k=0;         while(i            if (a[i] < b[j]) {                 c[k] = a[i];                 i++;                 k++;             } else {                 c[k] = b[j];                 j++;                 k++;             }         }          while (i < a.length)         {             c[k] = a[i];             i++;             k++;         }          while (j < b.length)         {             c[k] = b[j];             j++;             k++;         }          System.out.print(Arrays.toString(c));     }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"The idea is simple:  Since both arrays are sorted, simply loop through until one of the array is finished. Take which ever is smaller (if we are making ascending order. If not, reverse this step and take the larger) and put it at the new larger list. Add remaining items if there is any left.  Code in Java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Isn't the solution the \"merge\" step of the merge sort algorithm?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Merge2SortedArray {   public static void main(String[] args) {      int a [] = { 1, 2, 8, 10, 19, 22, 28, 30 } ;   int b [] = { 1, 2, 3, 7, 11, 18, 25, 40, 45, 50 } ;      int c [] = merge ( a, b ) ;      for ( int i = 0 ; i < c.length ; ++i )   {    System.out.println ( c[i] ) ;   }  }    public static int [] merge ( int a [], int b[] )  {   int lena = a.length ;   int lenb = b.length ;   int res [] = new int [ lena + lenb ] ;   int j = 0 , i = 0, k = 0 ;    for ( k = 0 ; k < lena + lenb ; ++k )   {    if ( i < lena && j < lenb )    {     if ( a[i] <= b[j] )     {      res[k] = a[i++] ;     }     else     {      res[k] = b[j++] ;     }    }    else    {     if ( i == lena )     {      res[k] = b[j++] ;     }     else      {      res[k] = a[i++] ;     }    }   }      return res ;  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void mergeArray(int result[], int arr1[],int size1,int arr2[],int size2) \n{ \n int length=size1+size2; \n int c=0,c1=0,c2=0; \n while (c1!=size1||c2!=size2) \n { \n  if(c1==size1&&c2!=size2) \n  { \n   result[c++]=arr2[c2++]; \n  } \n  if(c2==size2&&c1!=size1) \n  { \n   result[c++]=arr1[c1++]; \n  } \n  if(c1!=size1&&c2!=size2) \n  { \n   if(arr1[c1]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int main(){ \nint n=SI; \nvector a(n); \nFOR(i,0,n)a[i]=SI; \nint m=SI; \nVI b(m); //vector b(m); \nFOR(i,0,m)b[i]=SI; // for(int i=0;ib[p2]){ \nc.pb(b[p2]);p2++; \n} \nelse {c.pb(a[p1]);p1++;} \n} \nFOR(i,p1,n)c.pb(a[i]); \nFOR(i,p2,m)c.pb(b[i]); \nFOR(i,0,sz(c))cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a = new int[c.Length + d.Length];             int i = 0, h = 0, j = 0;             int m = c.Length;             int n = d.Length;             while (n>j ||m>i)             {                 if (m>i&&n>j)                 {                     if (c[i] >= d[j])                     {                         a[h++] = d[j++];                     }                     else                     {                         a[h++] = c[i++];                     }                 }                 else if (m>i)                 {                     a[h++] = c[i++];                                     }                 else                 {                     a[h++] = d[j++];                 }                              }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void Main(string[] args) \n        { \n            int[] arr1 = new int[] { 1, 3, 5, 7 }; \n            int[] arr2 = new int[] { 2, 4, 6, 8, 9, 10, 11, 13, 15 }; \n            int i = 0, j = 0; int m = arr1.Length;             \n            int n = arr2.Length; \n            int[] finalArray = new int[m + n]; \n            while ((i + j) < (m + n)) \n            { \n                if (i != m && arr1[i] < arr2[j]) \n                { \n                    finalArray[i + j] = arr1[i]; \n                    i++; \n                } \n                else \n                { \n                    finalArray[i + j] = arr2[j]; \n                    j++; \n                } \n \n            }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Integer[] a = { 0, 3, 4, 5, 6, 7, 8, 12,19, 51 }; \n  Integer[] b = { 4, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 58 }; \n  List finalArray = new ArrayList(Arrays.asList(b)); \n  finalArray.add(0, Integer.MIN_VALUE); \n  finalArray.add(finalArray.size(), Integer.MAX_VALUE); \n  int progress = 0; \n  for (int i = 0; progress < a.length; i++) { \n   if (a[progress] < finalArray.get(i)) { \n    finalArray.add(i, a[progress++]); \n   } \n  } \n  finalArray.remove(0); \n  finalArray.remove(finalArray.size()-1);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just Do an Merge Sort"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Try Tree sort, its just 2 steps code."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Merge part of the merge sort is the solution O(N)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void mergeArray(int[] arr1, int[] arr2){      int length1 = arr1.length;   int length2 = arr2.length;      System.out.println(\"arr1\" + Arrays.toString(arr1) );   System.out.println(\"arr2\" + Arrays.toString(arr2) );      System.out.println();   int lengthFinal = length2 + length1;      int[] arrMerged = new int[lengthFinal];   int pos = 0, pos1 = 0, pos2 = 0;;     while (pos1 <= length1 -1 && pos2 <= length2 -1){    if(arr1[pos1] <= arr2[pos2]){     arrMerged[pos] = arr1[pos1];     pos1++;    }else{     arrMerged[pos] = arr2[pos2];     pos2++;    }    pos++;   }      while( pos1 <= length1 -1){    arrMerged[pos] = arr1[pos1];    pos1++;    pos++;   }      while( pos2 <= length2 -1){    arrMerged[pos] = arr2[pos2];    pos2++;    pos++;   }      System.out.println(\"Megred Array =\" + Arrays.toString(arrMerged) );  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void mergeArray(int[] arr1, int[] arr2){ \n   \n  int length1 = arr1.length; \n  int length2 = arr2.length; \n   \n  int lengthFinal = length2 + length1; \n   \n  int[] arrMerged = new int[lengthFinal]; \n  int pos = 0, pos1 = 0, pos2 = 0;; \n  \n  while (pos1 < length1 || pos2 < length2){ \n    \n   if( pos1 != length1 && arr1[pos1] <= arr2[pos2] ){ \n     \n    arrMerged[pos] = arr1[pos1]; \n    pos1++; \n     \n   }else{ \n    \n    arrMerged[pos] = arr2[pos2]; \n    pos2++; \n    \n   } \n   pos++; \n  } \n   \n  System.out.println(\"Megred Array =\" + Arrays.toString(arrMerged) ); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int [] a = {1,3,4, 5,6,7,8};    int [] b={4,6,7,8,9,10,11,12,13,14,15};       int c = a.length+b.length;   int num = 0;   int[] d = new int[c];   for(int i=0;i   d[num] = a[i];    num++;   }      for(int j=0;j   d[num] = b[j];    num++;   }      for(int j=0;j   System.out.print(d[j] + \" \");       }      int temp = d[0];      for(int k=0;k   for(int l=0;l    if(d[l+1]     temp = d[l];      d[l] = d[l+1];      d[l+1] = temp;     }    }   }   System.out.println();   for(int m=0;m   System.out.print(d[m]+ \" \");   }   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args){ \n  int[] A={3, 6, 9, 13, 15, 20}; \n  int la=A.length; \n  int [] B={1, 2, 3, 5, 6, 10, 11, 14, 17, 18, 21, 23}; \n  int lb=B.length; \n  mergeArr(A, la, B, lb); \n } \n  \n static void mergeArr(int []A, int la, int[]B, int lb){ \n  int j=0, i=0, k=0; \n  int [] C=new int [la+lb]; \n   \n  while(iB[j]){ \n    C[k]=min(A[i], B[j]); \n    j++; \n   } else { \n    C[k]=A[i]; \n    System.out.print(C[k]+\" \"); \n    C[++k]=B[j]; \n    i++; j++; \n   } \n   System.out.print(C[k]+\" \"); \n   k++; \n    \n  } \n   \n  while(i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.*; public class Sorted_array {     public static void main(String args[])     {         Scanner sc=new Scanner(System.in);         System.out.println(\"Enter the first Array Length\");         int n1,n2;         n1=sc.nextInt();         int[] a1=new int[n1];         System.out.println(\"Enter the second Array Length\");         n2=sc.nextInt();         int[] a2=new int[n2];         System.out.println(\"Enter the first arry elements:\");         for(int i=0;i            a1[i]=sc.nextInt();         for(int i=0;i            for(int j=i+1;j                if(a1[i]                    int temp=a1[i];                     a1[i]=a1[j];                     a1[j]=temp;                 }         System.out.println(\"Enter the second Array Length\");             for(int i=0;i            a2[i]=sc.nextInt();              for(int i=0;i            for(int j=i+1;j                if(a2[i]                    int temp=a2[i];                     a2[i]=a2[j];                     a2[j]=temp;                 }             int[] a3=new int[n1+n2];             for(int i=0;i                a3[i]=a1[i];             for(int i=0;i                a3[n1+i]=a2[i];         for(int i=0;i            for(int j=i+1;j                if(a3[i]                    int temp=a3[i];                     a3[i]=a3[j];                     a3[j]=temp;                 }         System.out.println(\"Sorted array:\");         for(int i=n1+n2-1;i>=0;i--)         {             System.out.print(a3[i]+\",\");         }     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static int[] MergeSortedArrays(int[] destination, int[] left, int[] right) \n        { \n            int leftInd = 0, rightInd = 0, destInd = 0; \n \n            while (leftInd < left.Length && rightInd < right.Length) \n            { \n                if (left[leftInd] <= right[rightInd]) \n                    destination[destInd++] = left[leftInd++]; \n                else \n                    destination[destInd++] = right[rightInd++]; \n            } \n \n            while (leftInd < left.Length) \n                destination[destInd++] = left[leftInd++]; \n \n            while (rightInd < right.Length) \n                destination[destInd++] = right[rightInd++]; \n \n            return destination; \n        }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14959971","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"20","title":"Dictionary d: boolean isWord(String) Input: \"thisisawesome\" Output: this is awesome this is awe some  isWord(\"this\") == true isWord(\"esome\") == false","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Map memoized; \n \nString SegmentString(String input, Set dict) { \n  if (dict.isWord(input)) return input; \n  if (memoized.containsKey(input) { \n    return memoized.get(input); \n  } \n  int len = input.length(); \n  for (int i = 1; i < len; i++) { \n    String prefix = input.substring(0, i); \n    if (dict.isWord(prefix)) { \n      String suffix = input.substring(i, len); \n      String segSuffix = SegmentString(suffix, dict); \n      if (segSuffix != null) { \n        return prefix + \" \" + segSuffix; \n      } \n   } \nmemoized.put(input, null); \nreturn null; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"DFS on the found words, when a solution (or a dead end) is found backtrack to the next alternative."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"this works :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"whats the question?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Given the dictionary function isWord(String) and a input string (without space) such as the one in the question, generate the output as described in the question."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is my solution. Because I cannot test my code, maybe there are some problems."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"please elaborate question more.. cant really understand"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Tested and working fine.... Tree used to get multiple possiblites and to handle ambiguity"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I wrote the following code, hope to help u. it's just a simple dfs"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14101663","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"20","title":"I have given a Long Sentence and some words(to be searched in the sentence), i have to find the smallest part of the sentence which contains all the words to be Searched in that Sentence and print that part.  I have tried it, 1. First get all locations(indexes) of all words from the given sentence. 2. then try to find smallest part from these indexes of words.  But i am having problem implementing 2nd part . So i want some advice for it or if you suggest any other algorithm which can make it fast. Example: If i have a String > \"Hello, my name is undefined. but your name is not undefined.\" and i have to search word [is, undefined] then the answer should be printed is: is undefined //which is taken from the sentence 1st and we can not print from second sentence as it is \" is not undefined\" because it is not shortest.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Isn't this cheating ? Posting questions from a contest running now. :-/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"hey recently same ques was asked in amazon india coding contest at interviewstreet.com  because the contest is over now i will give my approach.  Algorithm:  1.Take 2 pointers head and tail both pointing to start of the sentence now move head ponter untill u get a keyword which is present in our required keyword list and mark it as head 2.now move tail pointer untill all of ur keywords presented in that sentence for at least once now mark it as tail this is a first valid sub segment of the given sentence with given keywords  3.now check word frequency at head if it is greater than our requirement now move head untill it reaches a valid keyword with exactly it's frequency equals to 1 4.now we cannot move head further which results breaking the all keyword condition 5.so now move tail pointer untill frequency of keyword at head is greater than 1 6.now again move head untill keyword frequency becomes 1 whenever this condition met calculate it's length  finally stores the min length with start and end positions"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"THis question was just posted a few days ago...look through the most recent 20 or 30 ques"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use sliding window"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"cool?? man????"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we can do one thing.....  we shall replace all the spaces in the string with null then, 1`:-use strcmp function to find the first matching string..... 2:-mark that index as i... 3:-and then go on taversing all the strings till all the words to be searched is found.. 4:-then the point where all the words to be matched are found is marked as j.. 5:-the lenght i to j gives us the smallest part of the sentence..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// Find the smallest sentence containing a set of words. \n public static String smallestSentence(String input, String output, String... words) { \n  if (input == null || input.isEmpty() || words == null || words.length == 0) \n   return output; \n \n  int startIndex = -1; \n  int endIndex = -1; \n \n  for (String word : words) { \n   int indexOf = input.indexOf(word); \n   if (indexOf == -1) \n    return output; \n \n   startIndex = (startIndex < indexOf && startIndex != -1) ? startIndex : indexOf; \n   endIndex = endIndex > indexOf + word.length() ? endIndex : indexOf + word.length(); \n  } \n \n  output = (output.length() < (endIndex - startIndex) && output.length() != 0) ? output : input.substring(startIndex, endIndex); \n \n  return smallestSentence(input.substring(endIndex), output, words); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"r u ok"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"There is one more possible solution... suppose we have the source string (A) of 1000 words and the sub-string to be searched (B) with 50 words.. give each word in B an ID from 1 to 50 and replace the words in A with their respective id's came from B. Now replace the remaining words in A by -50000. Now search for a max sum sub array with condition that numbers 1-50 exist in it. and to make it perfect, search for the boundary values for duplicates within the resultant array, this will ensure that the words which are already in the array do not occur at boundaries which can happen to maximize the sum while searching with mathematical algorithm."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=12244667","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"17","title":"During my 2nd interview 1. Use 2 stacks to create a queue structure 2. If you have a tree how to verify it a BST A. User the inorder traversal 3. Write a code to implement above question 2.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"It is simple, you can do an in-order traversal of the tree and every time you read the root, put that to an array, then you can go through the array by comparing elements which should be in ascending order.   public void checkBST(Node tree){      if(tree!=null){            checkBST(tree.left);            arrayList.put(tree.data);            checkBST(tree.right);       } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"static boolean isBST(TreeNode root){   if(root == null)    return true;   if(root.left!=null && root.left.data > root.data ||     root.right!=null && root.right.data < root.data)    return false;   return(isBST(root.left) && isBST(root.right));     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If you have a tree how to verify it a BST  static boolean isBST(Node root) {   if(root == null)    return false;   if(root.left != null && root.left.value < root.value) {    return true;   }   if(root.right != null && root.right.value > root.value) {    return true;   }    if((root.left != null && root.left.value > root.value)      || (root.right != null && root.right.value > root.value)) {    return false;   }   isBST(root.left);   isBST(root.right);    return true;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static boolean isBST(TreeNode root){   return isBST(root,Integer.MIN_VALUE,Integer.MAX_VALUE);  }    static boolean isBST(TreeNode root,int min,int max){   if(root == null)    return true;   if(root.datamax)    return false;   if(root.left!=null && root.left.data > root.data ||     root.right!=null && root.right.data < root.data)    return false;   return(isBST(root.left,min,root.data) && isBST(root.right,root.data,max));  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"check every node of tree from its parent node and grandparent nodes too.when do recursive then it would have been check that grandparent node from their grandparent node.finally some point it would be checking from root value."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int isThisABST(struct node* mynode)  {           if (mynode==NULL) return(true);            if (node->left!=NULL && maxValue(mynode->left) > mynode->data) return(false);            if (node->right!=NULL && minValue(mynode->right) <= mynode->data) return(false);           if (!isThisABST(node->left) || !isThisABST(node->right)) return(false);            return(true);  }  Reference nice material"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Use 2 stacks to create a queue structure take 2 stacks...stack1 and stack2 now push the elements one by one into stack1 then pop them one by one and push them onto stack2.now on the whole push onto stack1 and pop fro stack 2,which is a queue,first in first out implemented."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17068664","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"17","title":"You are given a 2-D array with same number of rows and columns. You have to determine the longest snake in the array. The property to find the snake is the difference between the adjacent(left, right, up or down) should be either 1 or -1. If there are more than one snakes with maximum length, the output should print both of them.  Example-->  The given array elements are as follows:  4 7 9 8 5 6 5 4 6 7 8 5 10 9 7 6  The longest snakes are 7->6->5->4->5->6 and 7->6->7->6->5->4","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The answer should be 4->5->6->7->8->7->6->5->4->5->6->7 (0,0)->(1,0)->(2,0)->(2,1)->(2,2)->(3,2)->(3,3)->(2,3)->(1,3)->(1,2)->(1,1)->(0,1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Brute force way: for all [i, j] do a dfs and use backtracking to store all the paths which satisfy the criteria and also the size. After all [i, j] is done, print the path which is longest.  Any other approach which makes uses of previously calculated path?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this is the graph problem.  Create a graph with each matrix element ,graph should be undirected graph ,maintaine visited field for each node.  find the path with property that node data value shoukld not exceed by 1 or -1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"do a dfs, create trees, itll be a forest... a tree for every connected component. Find the diameter of each tree. maximum wins."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"From any point of the graph; Then use dfs to search its neighbours   if it satisfies the condition: the difference of them is 1 or -1      then add the neighbout to some place      recursively, from this point repeat the process   to other neighbour, till search its four direct neighbours if its neighbours are all been visited all don't satisfy the condition, judge its length is larger than the default max length(Initiall, it maybe INT_MIN), if its length is larger than the default one or saved ones, modify the max_length, and push the list to some place. Below is the code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@aka I use mlength to remember the length of current longest snakes, and use map > to remember all snakes whose length are all mlength. Using recursive method as I wrote above, I use vector current to remember the snake contents till this point, when you visited some point and can't find any neighbour of can satisfy the condition, then the snake can't be longer. And use the length of current to compare with mlength, (1) if it's shorter than the mlength snakes, ignore it; (2) if it's longer than the mlength snakes, clear the map > res, push the snake into it; (2) if it's equal to the mlength snakes, then push it to the set."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@aka Yes, I have to admit the algorithm can't avoid the situation that it maybe traverse the sampe path two times, like {1, 2, 3, 4} and {4, 3, 2, 1}. Since if I use the recursive method, the code structure ensure I won't traverse the same path two times, for example, I won't traverse {1, 2, 3, 4} again. Since the loop will turn to the other directions, and won't traverse the same direction of any point. Two different path may share some elements, such as {1, 2, 3, 4} and {1, 2, 3, 2}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@aka And there is another problem, if some point has been pushed into the longest snakes, we can judge, this two paths' start point, we call them p1(x1, y1) and p2(x2, y2), and call the two paths P1={} and P2={}. If p2 belongs to P1 which means the point has been visited and checked, can be ignored. If p2 doesn't belong to P1, the program can be processed continue, even when some points exist in the two paths."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int n = 0; \nint board[MAX][MAX]; \nbool g_visited[MAX][MAX]; \nvector > res; \nvector > g_px; \nvector > g_py; \n \nint mlength = INT_MIN; \nint dx[4] = {1, 0, -1, 0}; \nint dy[4] = {0, 1, 0, -1}; \n \ninline int abs(int x) { return x > 0 ? x : -x; } \n \nvoid dfs(int x, int y, vector current, vector px, vector py, bool visited[][MAX]) \n{ \n    int change = 0, i = 0; \n    for(i = 0; i < 4; i++) \n    { \n        if(x + dx[i] >= 0 && x + dx[i] < n && \n           y + dy[i] >= 0 && y + dy[i] < n && \n           !visited[x + dx[i]][y + dy[i]] && \n           abs(board[x][y] - board[x + dx[i]][y + dy[i]]) == 1) \n        { \n            change = 1; \n            visited[x + dx[i]][y + dy[i]] = true; \n            current.push_back(board[x + dx[i]][y + dy[i]]); \n            px.push_back(x + dx[i]); \n            py.push_back(y + dy[i]); \n \n            dfs(x + dx[i], y + dy[i], current, px, py, visited); \n \n            visited[x + dx[i]][y + dy[i]] = false; \n            current.pop_back(); \n            px.pop_back(); \n            py.pop_back(); \n        } \n    } \n    if(!change && current.size() > 0) \n    { \n        if((int)current.size() >= mlength) \n        { \n            if((int)current.size() > mlength) \n            { \n                res.clear(); \n                g_px.clear(); \n                g_py.clear(); \n                mlength = current.size(); \n            } \n            res.push_back(current); \n            g_px.push_back(px); \n            g_py.push_back(py); \n            for(i = 0; i < (int)current.size(); i++) \n            { \n                printf(\"%d \", current[i]); \n            } \n            printf(\"\\n\"); \n        } \n    } \n} \n \nbool checkpath(int x, int y) \n{ \n    bool ret = false; \n    for(int i = 0; i < (int)g_px.size() && !ret; i++) \n    { \n        for(int j = 0; j < (int)g_px[i].size() && !ret; j++) \n        { \n            if(g_px[i][j] == x && g_py[i][j] == y) \n            { \n                ret = true; \n            } \n        } \n    } \n    return ret; \n} \nint find() \n{ \n    int i = 0, j = 0; \n    vector current; \n    vector px; \n    vector py; \n    bool visited[MAX][MAX]; \n    for(i = 0; i < n; i++) \n    { \n        for(j = 0; j < n; j++) \n        { \n            if(!checkpath(i, j)) \n            { \n                current.clear(); \n    px.clear(); \n    py.clear(); \n    memset(visited, 0, sizeof(visited)); \n \n    visited[i][j] = true; \n \n    current.push_back(board[i][j]); \n    px.push_back(i); \n    py.push_back(j); \n    dfs(i, j, current, px, py, visited); \n            } \n        } \n    } \n    return 0; \n} \n \nint main() \n{ \n    int i = 0, j = 0; \n    memset(board, 0, sizeof(board)); \n \n    scanf(\"%d\", &n); \n    for(i = 0; i < n; i++) \n    { \n        for(j = 0; j < n; j++) \n        { \n            scanf(\"%d\", &board[i][j]); \n        } \n    } \n    find(); \n \n    return 0; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=12903687","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"17","title":"Write a function convert a string to an integer. example convert String \"1750\" to int 1750. Using Java, not allow use the default function","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"public long stringToInt(String s) throws Exception \n{ \n if(s == null)  \n  throw new Exception(\"Null values for entered input\"); \n else \n { \n  int isNegative = 1; \n  if(s.charAt(0) == '-') \n  { \n   s.substring(1); \n   isNegative = -1; \n  } \n  if(s.length() == 0) \n   throw new Exception(\"Unrecognized string\"); \n  else \n  { \n   long result = 0; \n   for(int i = 0; i < s.length(); i++) \n   { \n    int value = s.charAt(i) - '0';     \n    if(value < 0 || value > 9) \n     throw new Exception(\"Unrecognized string\"); \n    result = result * 10; \n                                 \n                                if(result > Integer.MAX_VALUE - value) \n                                        throw new Exception(\"Integer Overflow\");  \n    result += value; \n   }    \n   return isNegative * result; \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"#include  #include #include using namespace std; int main() {     int i,sum=0;     string a=\"5344\";     for(i=0; i            sum+=(a[i]-'0')* pow(10,a.length()-i-1);      cout<    system(\"pause\");     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"function(char s[ ]) {       int i,num=0,sign=1;       if(s[0]==' - ')           sign*=-1;         for(i=0;i       {              num=(num*10)+(s[i]-48);        }        num*=sign;        cout<}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public static int convertStringToInt(String string) throws Exception {   if (string == null) {    throw new Exception(\"cannot convert null to int\");   }      char[] chars = string.toCharArray();   int result = 0;   int j=0;   for (int i=chars.length-1;i>0;i--,j++) {    result += Character.digit(chars[j], 10) * Math.pow(10,i);   }   result += Character.digit(chars[j], 10);      return result;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"long Convert_number(chat *a,int size) { long Number=0;  for(int i=0;inumber= number*10 + (a[i]-'0');  return(number); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int atoiStr(String str) throws Exception {    boolean negative = false;     //is Null   if (str.equals(\"\")) {     throw new Exception(\"null string!\");    }    else     //is Negative    if (str.charAt(0) == '-' || str.charAt(0) == '+') {     if (str.charAt(0) == '-') {       negative = true;     }     }   return processStr(negative, str);  }    public static int processStr(boolean isNeg, String str) throws Exception{   long value = 0;   int begin = isNeg ? 1 : 0;   for (int i = begin; i < str.length(); i++) {     if (str.charAt(i) >= '0' && '9' >= str.charAt(i)) {      value = value * 10 + (str.charAt(i) - '0');      if (value > Integer.MAX_VALUE) {       throw new Exception(\"OUT OF INTEGER RANGE\");      }     }     else {      throw new NumberFormatException(\"not an integer\");     }    }    return (int) (isNeg == true ? value * -1 : value);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int stringToInt(String s) throws Exception {       int val = 0;   int isNegative = 1;   String ss;   if (s.length() == 0) {    throw new Exception(\"Empty is not allowed.\");   }      if (s.charAt(0) == '-') {    ss = s.substring(1);    isNegative = -1;   } else {    ss = s;   }      if (ss.length() == 0) {    throw new Exception(\"Invalid string.\");   } else {    for (int i = 0; i < ss.length(); i++) {     if (ss.charAt(i) - '0' < 0 || ss.charAt(i) - '0'> 9) {      throw new Exception(\"Invalid string\");     } else {      val = val * 10 + (int)ss.charAt(i);     }    }   }   return val * isNegative;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class StringToInt {   static Hashtable map = new Hashtable();  public static void main(String[] args) {      String s = \"12367686\";   buildMap();   System.out.println(convert(s));     }    public static void buildMap(){      map.put('0', 0);   map.put('1', 1);   map.put('2', 2);   map.put('3', 3);   map.put('4', 4);   map.put('5', 5);   map.put('6', 6);   map.put('7', 7);   map.put('8', 8);   map.put('9', 9);     }    public static int convert(String s){      int sum = 0;   for(int i = 0 ; i < s.length() ; i++){    sum *= 10;    sum = sum + map.get(s.charAt(i));   }      return sum;  }      }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int strToInt(String s) throws NullPointerException, NumberFormatException {     if (s == null) {       throw new NullPointerException();     }     s = s.trim();      if (s.length() == 0) {       throw new NumberFormatException(\"too short\");     }      int sign = 1;     if (s.charAt(0) == '-') {       sign = -1;       s = s.substring(1);     } else if (s.charAt(0) == '+') {       sign = 1;       s = s.substring(1);     } else if (s.charAt(0) >= '0' && s.charAt(0) <= '9') {       sign = 1;     } else {       throw new NumberFormatException(\"illegal format at position 0\");     }      if (s.length() == 0) {       throw new NumberFormatException(\"too short\");     }      int len = s.length();     int lastRes = 0;     int currRes = 0;      for (int i = 0; i < len; i++) {       if (s.charAt(i) < '0' || s.charAt(i) > '9') {         throw new NumberFormatException(\"illegal number at postion \" + i);       }       currRes = currRes * 10 + s.charAt(i) - '0';       if (currRes < lastRes) {         if (sign == 1)           throw new NumberFormatException(\"overflow\");         else           throw new NumberFormatException(\"underflow\");       }       lastRes = currRes;     }     return currRes * sign;   }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17213669","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"16","title":"Length is given as input.Print all possible permutations of numbers between 0-9.  Eg: if input length=4  all possible combinations can be 0123, 1234, 5678,9864,...etc all combinations of length from in all numbers between 0-9","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"public void permutations(String prefix, String s, int size) { \n  int len = s.length(); \n  if (prefix.length() == size) { \n   System.out.println(prefix); \n  } \n  for (int i = 0; i < s.length(); i++) \n   permutations(prefix + s.charAt(i), \n     s.substring(0, i) + s.substring(i + 1, len), size); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"In pseudo-code something along the lines of:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"void printPerm(char *num, int len_so_far,int actual_len) { int start,i; if(len_so_far == actual_len)  {  num[actual_len] = '\\0';  printf(\"%s\",num);  } if(len_so_far ==0 )  start = 1; else  start = 0; for(i=start;i<9;i++)  {   num[len_so_far] = itoa(i);   printPerm(num, len_so_far + 1, actual_len);  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void permutation(int [] target, boolean []used,int length, int level,StringBuffer out){   if( level == length ){          System.out.println( out.toString() );          return;      }       for( int i = 0; i < target.length; ++i ){          if( used[i] ) continue;          out.append( target[i] );          used[i] = true;          permutation( target, used, length, level + 1,out );          used[i] = false;          out.setLength( out.length() - 1 );      }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class PrintAllNumberByDigit { \n  \n public static void printSequential(int digit, String base) { \n  for(int j=0; j < 10; j++) { \n   if(base.indexOf(String.valueOf(j)) == -1) { \n    String newBase = base + j; \n    if(digit > 1) { \n     printSequential(digit-1, newBase); \n    } else { \n     System.out.println(newBase); \n    } \n   } \n  } \n } \n  \n public static void printSequential(int digit) { \n  printSequential(digit, \"\"); \n } \n  \n public static void main(String[] args) { \n  printSequential(5); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You used permutations and combinations as synonymous in your question, they are not. Google for  permutations vs combinations."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void anagram(char a[], int i) { \n  if (i == a.length - 1) { \n   System.out.print(new String(a)+\",\"); \n  } else { \n   for(int j=i;j"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a solution (recursive of course - its really awful to do a permutation problem if one does not user recursion) without string manipulation.  It is in C++. I feel that this would be the answer that would score more brownie points in an interview:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void print_permutate(int K){   print_permutate_sub(new boolean[10], 0, K, 0);  }  static void print_permutate_sub(boolean[] used , int num , int K , int d){   if (d > K)     return;   else if (d == K){    System.out.println(num);    return;   }   int base = 0;   if (d == 0)    base = 1;   for (int i = base ; i < 10 ; i++){    if (!used[i]){     used[i] = true;     print_permutate_sub(used , num * 10 + i , K , d+1);     used[i] = false;    }   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void print_permutate(int K){ \n  print_permutate_sub(new boolean[10], 0, K, 0); \n } \n static void print_permutate_sub(boolean[] used , int num , int K , int d){ \n  if (d > K)  \n   return; \n  else if (d == K){ \n   System.out.println(num); \n   return; \n  } \n  int base = 0; \n  if (d == 0) \n   base = 1; \n  for (int i = base ; i < 10 ; i++){ \n   if (!used[i]){ \n    used[i] = true; \n    print_permutate_sub(used , num * 10 + i , K , d+1); \n    used[i] = false; \n   } \n  } \n }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6662636737396736","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"16","title":"Given a list of test results (each with a test date, Student ID, and the student??s Score), return the Final Score for each student. A student??s Final Score is calculated as the average of his/her 5 highest test scores. You can assume each student has at least 5 test scores.  You may use the JDK or the standard template library. The solution will be evaluated on correctness, runtime complexity (big-O), and adherence to coding best practices. A complete answer will include the following:  Document your assumptions Explain your approach and how you intend to solve the problem Provide code comments where applicable Explain the big-O run time complexity of your solution. Justify your answer. Identify any additional data structures you used and justify why you used them. Only provide your best answer to each part of the question.   Use the following skeleton for your solutions.  Java:","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"to me, it seems a Java problem rather than a algo problem"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this is one of online test problems"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"According to my understanding, we  can use Map Map studentScores  = new HashMap(); -> For 1st test, we will add, student id and his first test score -> For second test, we will get the student id and add the second test score to first test.So, it will be O(1). -> we wll repeat this for 2nd,3rd,4th test and for 5th test we will add score and also we will calculate average and score in students id."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Map calculateFinalScores(List results) { \n \n Map res = new TreeMap<>(); \n if (results != null && results.size() > 0) { \n  Map> scoresQueue = new HashMap<>(); \n  for (TestResult result : results) { \n   PriorityQueue scores = scoresQueue \n     .get(result.studentId); \n   if (scores == null) { \n    scores = new PriorityQueue(); \n    scoresQueue.put(result.studentId, scores); \n   } \n   scores.add(result.testScore); \n   if (scores.size() > 5) { \n    scores.poll(); \n   } \n  } \n \n  for (int studentId : scoresQueue.keySet()) { \n   double totalScores = 0; \n   PriorityQueue scores = scoresQueue.get(studentId); \n   for (int score : scores) { \n    totalScores += score; \n   } \n   res.put(studentId, totalScores / 5); \n  } \n } \n return res; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class TestResult { \n  int studentId; \n       String testDate; \n       int testScore; \n \n // setter getter for all attributes \n   } \n \n \npublic class FinalScoreQuestion { \n \n /** \n * Final result to hold student actual result \n */ \n class FinalResult { \n  double finalScore; \n  long scores; \n  int count; \n \n  // getter for finalScore only \n } \n \n /** \n   * Proper java doc \n */ \n Map  calculateFinalScores (List results) { \n  Map  finalResults = new HashMap(); \n \n  // iterate results \n  for(TestResult result : results) { \n   int id = result.getId(); \n   Finalresult finalResult = finalResults.get(id); \n   if(finalResult == null) { \n    // entry not found \n    finalResult = new FinalResult(); \n    finalResult.scores = result.getScore(); \n    finalResult.count++; \n    finalResults.add(finalResult); \n   }  else { \n    // entry found \n    if(finalResult.count == 5) { \n     finalResult.finalScore = finalResult.scores / 5; \n    } else { \n     finalResult.scores += finalResult.scores; \n     finalResult.count++; \n    } \n   } \n  } \n \n  return finalResults; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Instead of calculating average each time from priority queue, it would be better to store it and keep on changing it without browsing whole queue"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class TestResult { \n  \n    int studentId; \n    String testDate; \n    int testScore; \n     \n public TestResult(int studentId, String testDate, int testScore) { \n  super(); \n  this.studentId = studentId; \n  this.testDate = testDate; \n  this.testScore = testScore; \n } \n  \n } \n \npublic class FinalScoreQuestion { \n \n public static void main(String[] args) { \n  List testResults = new ArrayList(0); \n  testResults.add(new TestResult(1, \"02-07-2013\", 60)); \n  testResults.add(new TestResult(1, \"02-07-2013\", 70)); \n  testResults.add(new TestResult(1, \"02-07-2013\", 80)); \n  testResults.add(new TestResult(1, \"02-07-2013\", 90)); \n  testResults.add(new TestResult(1, \"02-07-2013\", 95)); \n   \n  testResults.add(new TestResult(2, \"02-07-2013\", 60)); \n  testResults.add(new TestResult(2, \"02-07-2013\", 65)); \n  testResults.add(new TestResult(2, \"02-07-2013\", 70)); \n  testResults.add(new TestResult(2, \"02-07-2013\", 75)); \n  testResults.add(new TestResult(2, \"02-07-2013\", 80)); \n   \n  FinalScoreQuestion finalScoreQuestion = new FinalScoreQuestion(); \n  finalScoreQuestion.calculateFinalScores(testResults); \n } \n \n /** \n  * @description This method calculates average of top five scores of each student and returns a map of student and average score. \n  * @param results \n  * @return \n  */ \n protected Map calculateFinalScores (List results) { \n  Map finalStudentScore = new HashMap(); \n  Map> studentScoresMap = new HashMap>(); \n  List list = new ArrayList(0); \n  studentScoresMap = partitionStudentScores(results, studentScoresMap, list); \n  for (Map.Entry> entry : studentScoresMap.entrySet()) { \n   List scores = new ArrayList(0); \n   Integer averageScore = 0; \n   int consolidateScore = 0; \n   scores = getAllTheScoresOfStudent(entry, scores); \n   averageScore = sortAndGetTheAverage(scores, consolidateScore); \n   finalStudentScore.put(entry.getKey(), (Double.valueOf(averageScore))); \n  } \n   \n  return finalStudentScore; \n } \n \n /** \n  * @description This method shall sort the List of scores of each student and takes the first five top scores and calculates the  \n  *   average of the scores and returns it. \n  * @param scores \n  * @param consolidateScore \n  * @return \n  */ \n protected Integer sortAndGetTheAverage(List scores, int consolidateScore) { \n  Integer averageScore; \n  Collections.sort(scores, Collections.reverseOrder()); \n  for (int i = 0; i < 5; i++) { \n   consolidateScore = consolidateScore + scores.get(i); \n  } \n  averageScore = Integer.valueOf(consolidateScore) / 5; \n  return averageScore; \n } \n \n /** \n  * @description This method shall return all the scores of a student in the form of a List \n  * @param entry \n  * @param scores \n  * @return \n  */ \n protected List getAllTheScoresOfStudent(Map.Entry> entry, List scores) { \n  for (TestResult studentScore : entry.getValue()) { \n   scores.add(Integer.valueOf(studentScore.testScore)); \n  } \n  return scores; \n } \n \n /** \n  * @description This method shall split the all the list of scores and gives you the map of student and list of student's all scores \n  * @param results \n  * @param studentScoresMap \n  * @param list \n  * @return \n  */ \n protected Map> partitionStudentScores(List results, Map> studentScoresMap, \n   List list) { \n  for (TestResult testResult : results) { \n   if (studentScoresMap.containsKey(testResult.studentId)) { \n    list = studentScoresMap.get(testResult.studentId); \n   } else { \n    list = new ArrayList(0); \n   } \n   list.add(testResult); \n   studentScoresMap.put(Integer.valueOf(testResult.studentId), list); \n  } \n  return studentScoresMap; \n } \n  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public  Map calculateFinalScores(List results) { \n \n  Map> scoreMap = new HashMap<>(); \n  for (TestResult testResult : results) { \n   if (scoreMap.containsKey(testResult.studentId)) { \n    List scoreList = scoreMap.get(testResult.studentId); \n    scoreList.add(testResult.testScore); \n    scoreMap.put(testResult.studentId, scoreList); \n   } else { \n    List scoreList = new ArrayList<>(); \n    scoreMap.put(testResult.studentId, scoreList); \n   } \n \n  } \n  Map finalScores = new HashMap<>(); \n \n   \n  for (Integer id : scoreMap.keySet()) { \n   List scoreList = scoreMap.get(id); \n   Collections.sort(scoreList); // sort the score list because we need \n           // top 5 highest scores \n   ListIterator itr = scoreList.listIterator(scoreList.size() -5); \n   double avg = 0.0; \n   int sum = 0; \n   for (int i = 0 ; i < 5 ;i++) { \n    sum += itr.next(); \n   } \n   avg = sum / 5; \n \n   finalScores.put(id, avg); \n  } \n  return finalScores; \n \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class TestResult { \n int studentId; \n String testDate; \n int testScore; \n \n TestResult() { \n  studentId = 0; \n  testDate = \"\"; \n  testScore = 0; \n } \n \n TestResult(int Id, String date, int score) { \n  this.studentId = Id; \n  this.testDate = date; \n  this.testScore = score; \n } \n \n int getID() { \n  return this.studentId; \n } \n \n int getScore() { \n  return this.testScore; \n } \n} \n \npublic class StudentRanking { \n \n static class PQComparator implements Comparator { \n \n  @Override \n  public int compare(TestResult one, TestResult two) { \n   // TODO Auto-generated method stub \n   return one.testScore - two.testScore; \n  } \n \n } \n \n public static void main(String[] args) { \n  // Create an array List of TestResult \n  List student = new ArrayList(); \n  Map FinalScores = new HashMap(); \n \n  // create a list of test result for a student \n  student.add(new TestResult(1, \"2010\", 90)); \n  student.add(new TestResult(1, \"2010\", 90)); \n  student.add(new TestResult(1, \"2010\", 60)); \n  student.add(new TestResult(1, \"2009\", 75)); \n  student.add(new TestResult(1, \"2010\", 80)); \n  student.add(new TestResult(1, \"2009\", 88)); \n  student.add(new TestResult(1, \"2009\", 98)); \n  student.add(new TestResult(1, \"2009\", 50)); \n  student.add(new TestResult(1, \"2008\", 40)); \n  student.add(new TestResult(1, \"2009\", 100)); \n \n  // create a list of test result for another student \n \n  student.add(new TestResult(2, \"2010\", 90)); \n  student.add(new TestResult(2, \"2010\", 90)); \n  student.add(new TestResult(2, \"2010\", 90)); \n  student.add(new TestResult(2, \"2009\", 90)); \n  student.add(new TestResult(2, \"2010\", 90)); \n  student.add(new TestResult(2, \"2009\", 88)); \n  student.add(new TestResult(2, \"2009\", 78)); \n  student.add(new TestResult(2, \"2009\", 50)); \n  student.add(new TestResult(2, \"2008\", 60)); \n  student.add(new TestResult(2, \"2009\", 100)); \n \n  student.add(new TestResult(3, \"2010\", 85)); \n  student.add(new TestResult(3, \"2010\", 90)); \n  student.add(new TestResult(3, \"2010\", 60)); \n  student.add(new TestResult(3, \"2009\", 75)); \n  student.add(new TestResult(3, \"2010\", 80)); \n  student.add(new TestResult(3, \"2009\", 88)); \n  student.add(new TestResult(3, \"2009\", 98)); \n  student.add(new TestResult(3, \"2009\", 50)); \n  student.add(new TestResult(3, \"2008\", 40)); \n  student.add(new TestResult(3, \"2009\", 100)); \n \n  FinalScores = calculateFinalScores(student); \n \n  for (Map.Entry e : FinalScores.entrySet()) { \n   System.out.println(\"Student ID >> \" + e.getKey() \n     + \" >> Average Score >> \" + e.getValue()); \n  } \n } \n \n static Map calculateFinalScores(List results) { \n  Double avg = 0.0; \n  int sum = 0; \n  int count = 0; \n  HashMap> top5_marks = new HashMap>(); \n  // put the student id and his average in a hashmap \n  HashMap final_scores = new HashMap(); \n \n  PQComparator pqComparator = new PQComparator(); \n  PriorityQueue pq = null; \n \n  for (TestResult r : results) { \n   if (top5_marks.containsKey(r.studentId)) { \n    if (pq.size() == 5) { \n     pq.add(r); \n     pq.poll(); \n    } else { \n     pq.add(r); \n    } \n   } else { \n    pq = new PriorityQueue(5, pqComparator); \n    pq.add(r); \n    top5_marks.put(r.studentId, pq); \n   } \n  } \n \n  for (Map.Entry> e : top5_marks \n    .entrySet()) { \n   PriorityQueue temp = e.getValue(); \n   for (TestResult t : temp) { \n    sum = sum + t.testScore; \n    count = count + 1; \n   } \n   avg = (double) sum / count; \n   final_scores.put(e.getKey(), avg); \n   sum = 0; \n   count = 0; \n  } \n  return final_scores; \n } \n \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5131792298278912","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"15","title":"We have a fictitious multi-level marketing scheme where a member can recruit one or more other members. At the end of the month, member??s payout is calculated at 10% of his direct sales (items the members sells themselves) and 4% of sales generated by his recruits and their recruits. Write a function that calculates the monthly compensation for all members given the original member. You can assume a member can only be recruited by a single existing member.  Given the following interface, please implement the MemberPayoutUtil.calculatePayout function.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"This should work:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static double calculatePayout(Member member)  \n{ \n    double payout = member.getMonthlySales() * .1; \n    double recruitSales = 0; \n    Collection allRecruits = new Collection(); \n    while( !allRecruits.isEmpty() ) \n    { \n         Member recruit = allRecruits.First(); \n         recruitSales += recruit.getMonthlySales(); \n         allRecruits.remove(recruit); \n         allRecruits.AddRange(recruit.getRecruitedMembers()); \n    } \n    return payout + (recruitSales * .04); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Define a variable to keep track of what recruit level you are at. 0 for the member you are calculating the commission for.  public static int level = 0;  public static double calculatePayout(Member member) {      ArrayList members = (ArrayList) member.getRecruitedMembers();   level = level + 1;   if(members!=null){    for(int i=0; i< members.size();){     calculatePayout(members.get(i++));    }   }   level = level - 1;   if(level==0){    return payout + (member.getMonthlySales() * 0.1);   }else{    return payout + (member.getMonthlySales() * 0.04);   }     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static double calculatePayout(Member member) { \n     ArrayList members = (ArrayList) member.getRecruitedMembers(); \n  level = level + 1; \n  if(members!=null){ \n   for(int i=0; i< members.size();){ \n    calculatePayout(members.get(i++)); \n   } \n  } \n  level = level - 1; \n  if(level==0){ \n   return payout + (member.getMonthlySales() * 0.1); \n  }else{ \n   return payout + (member.getMonthlySales() * 0.04); \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"PS :  that is my code above. dint realize I was logged off when posting."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how about this recursive logic?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"One more recursive:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Trying to use recursive logic to get the total sales of one member's recruits"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public double calculatePayout(Member member)  {   double directPayout = member.getMonthlySales()*0.1;   List recruits = member.getRecruitedMembers();   Stack recruitStack = new Stack();   double payOut=0,total=0;   if(recruits.size()>0)   {    for(Member m : recruits)    {     recruitStack.push(m);     payOut = payOut + 0.04 * m.getMonthlySales();     while(!recruitStack.isEmpty())     {      Member m1 = recruitStack.pop();      payOut = payOut + 0.04 * m1.getMonthlySales();      if(!m1.getRecruitedMembers().isEmpty())      {       recruitStack.addAll(m1.getRecruitedMembers());      }     }     }   }    return payOut+directPayout;   }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16233703","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"14","title":"Each time a visitor requests a page from our website, our webserver writes a log entry recoding the visitor's identity and the kind of page requested.  Entries are written in chronological order to a plain-text file, with one entry per line.  The format of each entry is:   user-id      page-type-id    User IDs are arbitrary strings that uniquely represent a given user; if a user visits multiple pages, each log entry will have the same user ID.  Page type IDs are arbitrary strings that uniquely represent a given kind of page on our site, such as the homepage, a product detail pages, or the shopping cart. Tons of users visit our website, but there are only a few dozen types of pages.  We can use our weblogs to answer questions about user behavior.  One interesting question is: what is the most common three page sequence through the site?  E.g., if the most common pattern is to buy items advertised on the home page of the site, we might see the most common three page sequence as \"Homepage -> ProductDetailPage -> ShoppingCart\".  However, if customers spend a lot of time browsing the \"Customers who bought this item also bought\" feature, we might see the most common three page sequence as \"ProductDetailPage -> ProductDetailPage -> ProductDetailPage\".  Attached is a sample log file for your reference.  Within the first 10 lines of the sample, customer \"234\" travels through the sequences \"Listmania -> ProductDetail -> Checkout\" and \"ProductDetail -> Checkout -> HomePage\" once each.  For the sake of this test feel free to assume that everything will fit in memory.  Do keep in mind that given the size of our data sets, performance has to be considered, also, we will be looking at more than just correct output..","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"1. encode each possible sequence of pages in a number. If we have K possible page types, our number will look like nnn where 00, B->1, C->2. So our base would be 3, and B->A->C transition would be encoded as 1*3^2+0*3^1+2*3^0=102(base3) or b(hex).  2. create an array of ints of KKK size, initialize all with 0. So if we have \"several dozen\" of page types (several means 4 for example), we would need (12*4)^3 array elements (~110K).  2'. Or if we don't want to allocate memory for all possible sequences, have a set  ->   3. sequentially scan the log keeping track and updating KKK state per user (i.e. keep it in a set ->kkk). Increment corresponding cell in array (or set) created at [2].  4. select greatest value from the array (or set), decode it's position (id) into page sequence  O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You could download the sample log file at:  db.tt / LobF70Rt"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"put the data in a hash with key as customer id. the value for the hash (chained) since there will be multiple entries will be the pages he visited Let say I number pages  Homepage = 1 Shopping cart = 2 Listmania = 3  then for customer with id let say 1130 hash will have an entry like 1->4->3->2 after creating a hash scan all the customers and build a max heap for the count of seq like for 1->4->3->2 seq will be 1->4->3   i.e 143 4->3->2   i.e 432"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// create arraylist to handle page trios \n \nArrayList mostVisited = new ArrayList(); \n \nclass Trio { \n int counter = 1; \n int p1, p2, p3;   // respective pages visited \n \n setP1(int uniqueID)   // copy for setP2 & setP3 \n { \n  p1 = uniqueID; \n } \n} \n \n// after a trio of pages has been visited and their uniqueID set to p1, p2, p3 \n// check if that trio exists within arraylist \n \nif(mostVisited.contains(t)) // if it exists increment \n{ \n mostVisited.get(t).counter++; \n} \nelse      // or add the trio the arraylist \n{ \n mostVisited.add(t); \n} \n \n// then . . .  \n \n// to query the most visited site you would use a for loop or 0(1) \n \nint mostVis = 0; \nfor(int i = 0; i < mostVisited.size(); i++) \n{ \n if(mostVisited.get(i).counter > mostVis) \n {  \n  mostVis = i; \n } \n} \n \n \n// finally get the Trio from the mostVisited arraylist at the index mostVis \n \nTrio finalTrio = mostVisited.get(mosVis);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Maintain a map user_map[key] key = userid user_map[key] = page sequence queue of max size 3  Additionally maintain a map visit_count_map[key]  key = page sequence queue of size 3 visit_count_map[key] = visit count for page sequence queue denoted by key"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My python code according to charbot:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First solution:  Keep a hash of the most recent pages visited by each customer:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ok my answer goes like this  maintain a hash of  users and pages visited  hash> now lets say user 234 has visited the sequence 1-6-5-3  now we will be adding the pages in the array list as the pages are being visited when the  visitsequence size becomes equal to 3 we take this visit sequence as key and put it in  another hashmap  then remove the first entry (by doing visitsequence.remove(0)) in the original hash map this is to count the other sequences  for ex  user 234 visits  1-5-6-7  as the sequence becomes 156, we put it in second hashmap and increase the sequence count in secound hashmap when we remove first entry in 156 it will become 56 next when user visits 7 we will have sequence 567..so even this can be put in our second hashmap"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"chude dao!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"so this is my say on this,  - find the most visited page - find the next most visited page, condition being that the second page should come next to the 1st page, as the log is chronological. - repeat the second process for the 3rd page.  Repeat  the process for other pages that have the same count but i think it should come up the first time."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=2593","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"15","title":"Write code for the following mode of string comparision. The method should return true if the second string contains all the characters of the first string (order is not important) and you should consider duplicates. For example, first string is aabc, true for kbaac, abac.. false for abc.Dont worry about the complexity. I guess the person just wants to see if I can write code. Also I think I got the correct idea in less than 30 seconds but putting it on the board took around 10 minutes.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"We can also do it using a hashmap. Take the second string and have a hashmap with key being the alphabets and value being the number of occurences for that alphabet. Now take the first string and find if a value exists in the hashmap for each character in the string. For duplicates, we can decrement the value in he hashmap.If for any char, the val in hashmap is zero then the scond string doent contain all the characters of the first."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I said put all the character of the first string a binary tree(hash would have been better?) so that retreival takes only log n time. Then get the characters of the second string one by one and check if the tree contains that element. If true remove that element.Finally if the tree is empty they are equal and vice versa. I guess I have answered this question right because of reading answers to questions(which are more difficult) like this in Career cup."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hey you can just use charAt() method of string class."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"as its said, dont worry about complexity..sort the characters of first string, and then of the second.see if first_sorted is prefix of second_sorted.this assumes, duplicates have to be accounted for ( first cotains two 'a's then second should also have."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Associate prime no.s to each chars from a to z. Now get id for first string => aabc = 2 * 2 * 3 * 5; similarly get the id for second string.  if the remainder(secondString/firstString) == 0    return true; else    return false;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static boolean containsChars(String s1, String s2){      if (s2.length()     int[] charFlag=new int[26];   for(int i=0;i<26;i++)    charFlag[i]=0;      s1=s1.toLowerCase(); s2=s2.toLowerCase();      for(int i=0;i  {    charFlag[s2.charAt(i)-'a']--;    if(i  }      for(int i=0;i<26;i++)    if (charFlag[i]>0) return false;      return true;  }  // this function could only deal with a~z without case sensitive, otherwise use hashtable"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi, This code works fine..  import java.util.*; import java.io.*;  public class stringVerify {     private boolean compareString(String a, String b){   HashMap h=new HashMap();    HashMap h1=new HashMap();   int count=0;   int count1=0;   String com;   boolean flag=true;   //String key=null,key1=null;   int lenA=a.length();   int lenB=b.length();   //System.out.println(\"Im here\");   for(int i=0;i   if(h.isEmpty()){     com=Character.toString(a.charAt(i)).toLowerCase();     h.put(com, count+1);     //System.out.println(h);     continue;    }    else{     com=Character.toString(a.charAt(i)).toLowerCase();     if(h.containsKey(com)){      Integer s1=(Integer)h.get(com);      //System.out.println(\"S2is:\"+s1);      s1++;      h.put(com, s1);     }     else {      h.put(com, count+1);     }    }   }      for(int i=0;i   if(h1.isEmpty()){     com=Character.toString(b.charAt(i)).toLowerCase();     h1.put(com, count1+1);     //System.out.println(h);     continue;    }    else{     com=Character.toString(b.charAt(i)).toLowerCase();     if(h1.containsKey(com)){      Integer s2=(Integer)h1.get(com);      //System.out.println(\"S2is:\"+s2);      s2++;      h1.put(com, s2);     }     else {      h1.put(com, count1+1);     }    }   }   System.out.println(\"String B has:\"+h1);     System.out.println(\"String A has:\"+h);      Iterator it1=h.keySet().iterator();   Iterator it2=h1.keySet().iterator();      //while(it1.hasNext()){   // System.out.println(it1);  // }   //h.getKeys();      int size1=h.size();   int size2=h1.size();    //System.out.println(\"Im here\");    while(size1!=0&& it1.hasNext()&&it2.hasNext()){     //System.out.println(\"Im in while\");     //System.out.println(it1.next().toString());     //System.out.println(it1);     String key=it1.next().toString();     //System.out.println(\"Key-1 is:\"+key);     String key1=it2.next().toString().trim();     //System.out.println(\"Key-2 is:\"+key1);     if(key.equals(key1)){     // System.out.println(\"Im here- Keys\");      size1--;      Integer q=(Integer)h.get(key);      Integer p=(Integer)h1.get(key1);      //System.out.println(\"The Values are:\"+q+p);      if(q==p){      // System.out.println(\"Keys are same\");       flag=true;       continue;      }      else{       flag=false;       break;      }     }     else{      size1--;      continue;     }        }   //Iterator it1 = h.keySet().iterator();   //Iterator it2=h1.keySet().iterator();   System.out.println(flag);   return flag;  }    public static void main(String args[]){   stringVerify s= new stringVerify();   BufferedReader r=new BufferedReader(new InputStreamReader(System.in));   String a=null,b=null;   System.out.println(\"Enter String a:\");   try{   a=r.readLine();   //System.out.println(a);   System.out.println(\"Enter String b:\");   b=r.readLine();   boolean f= s.compareString(a,b);   //System.out.println(b);   }   catch(Exception e){       }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"boolean functionName(String s1,String s2) { \n  // sort both the string....   \n  return s1.equalsIgnoreCase(s2);  \n} \n//"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.*;  public class Test {   /**   * @param args   */  public static void main(String[] args)   {   // TODO Auto-generated method stub   String str1 = new String(\"aabc\"); //$NON-NLS-1$   String str2 = new String(\"aaabc\"); //$NON-NLS-1$   char charArr1[] = str1.toCharArray();   char charArr2[] = str2.toCharArray();   Arrays.sort(charArr1);   Arrays.sort(charArr2);   str1 = \"\";  //$NON-NLS-1$   str2 = \"\"; //$NON-NLS-1$   for(int i=0;i  {    str1 += charArr1[i];   }   for(int i=0;i  {    str2 += charArr2[i];   }   System.out.println(\"str1=\"+str1); //$NON-NLS-1$   System.out.println(\"str2=\"+str2); //$NON-NLS-1$   if(str2.contains(str1))   {    System.out.println(\"Contains\");    //$NON-NLS-1$   }   else    System.out.println(\"Doesn't Contain\"); //$NON-NLS-1$        }  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=3373955","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"16","title":"Given a list of Integers,Find the tuple of 3 adjacent elements in this list that adds up to the maximum sum.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"@Oshin,        The question what I posted is exactly what he asked me.  For Example: If we have { 5 6 7 3 4 5 6 3} list of 8 int numbers we have and   sum of first 3 adjacent numbers (5 +6 +7) =18 sum of next 3 adjacent numbers (6+7+3) =16 sum of next (7+3+4) = 14  like wise we need to find out maximum sum of all these ......Please let me know if you are still not clear......"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"So if the m is given instead of a constant number 3, we just remember the previous sum instead of summing up in every loop.   int maxSum = 0, currentSum = 0, size = a.length; for (int i = 0; i <= (size - m); i++) {   if (i < m - 1) {     currentSum += a[i];   }   else if (i = m - 1) {     maxSum = currentSum;   }    else if (i > m - 1) {     currentSum = currentSum + a[i] - a[i - m];     if (currentSum > maxSum) {       maxSum = currentSum;     }   } }  return maxSum;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/*  * To change this template, choose Tools | Templates  * and open the template in the editor.  */  package subseq;   public class Main {           public static void main(String[] args)  {         int a[] = {1,2,3,4,5,6,7,8};         int bigSum = 0,sum=0,index =0;         for(int i=0;i        {             int j = i;             sum=a[j]+a[j++]+a[j++];             if(sum>bigSum)             {                 bigSum = sum;                 index = i;             }             else             {              }         }         System.out.println(\"sum : \"+bigSum+ \" index: \"+index);     }   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"possible in O(N), any one knows better than this?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Without touching all no. finding MAX sum is not possible....! so O(n)is the best sol... i think...! :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Guys..in the above code..ppl forgot to consider if the loop has -ve numbers in last 3 digits like {5,6,7,2,-1,0,19)...since we run the length-2..there can be a scenario where we can miss the last element."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sort the list in descending order and then pick first m characters."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int getMax(int[] array, int m) { \n  int maxsum=0,oldsum,currsum=0; \n  for(int i=0;imaxsum) { \n    maxsum = currsum; \n   } \n   oldsum = currsum; \n  } \n  return maxsum; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question does not ask for the max sum.. it asks for the tuple that makes the max sum !!    package testPrograms;  import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.Random;  public class MaxSumTuple {  private int[] tuple;   public MaxSumTuple()  {   tuple = new int[3];  }  public int[] findTuple(List listInt)  {   int sumOld = 0,sumNew = 0;   if (listInt.size() <= 3)   {    for (int i = 0; i < listInt.size(); i++)    {     this.tuple[i] = listInt.get(i);     return tuple.clone();    }   }    for(int i=0;i  {    sumNew = listInt.get(i) + listInt.get(i+1) + listInt.get(i+2);    if(sumNew > sumOld)    {     sumOld = sumNew;     updateTuple(i,listInt);    }       }    return tuple.clone();   }    public void updateTuple(int index,List list)  {   for(int i=0;i  {    tuple[i] = list.get(index + i);   }  }  public static void main(String []args)  {   List list = new ArrayList();   Random random = new Random();   for(int i=0;i<10;i++)   {    list.add(random.nextInt(100));   }      MaxSumTuple maxSumTuple = new MaxSumTuple();   int []tuple = maxSumTuple.findTuple(list);   System.out.println(list);   System.out.println(Arrays.toString(tuple));              }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"whattt...I am sure I get the question wrongly OR was he looking for a better solution than O(n) :O"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"better than O(n)?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Try this i think it will work..    int maxsum=0,thissum=0;      for(int i=0;i<(size-2);i++)      {                thissum=a[i]+a[i+1]+a[i+2];         if(thissum<0)  thissum=0;         if(maxsum     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"if m is given instead of 3 , how will we solve this"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=10091800","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"14","title":"round 2: 1.  explain me final, finally and finalized in java.   (on JAVA) 2. 2. you have unsorted array[n] elements. the numbers in the array[n] occurs event times except one number occurs odd time. So, write an algorithm to find that number. Also explain its complexity too. (time and space) both.  (On ALGORITHM) 3. you have html page directory. in each html page u have written name and phone number. now you have to make normal directory from that information. write an algorithm that convert  html directory to normal directory.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"\"you have unsorted array[n] elements. the numbers in the array[n] occurs event times except one number occurs odd time. So, write an algorithm to find that number. Also explain its complexity too. (time and space) both. (On ALGORITHM)\"  Sort and XOR the elements the even elements will cancel out."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"use the last name of the person..   read abt various techniques to avoid collisions..   for such a question u will have to answer with pros and cons.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"3. you have html page directory. in each html page u have written name and phone number. now you have to make normal directory from that information. write an algorithm that convert html directory to normal directory.  how can we do this??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For Q3 i am not getting the question"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"please can you elaborate the question? what do you mean by directory here??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Q2-Ans : Read each element from array and put it in an Hash-table as key-value pairs(key - number, value- no.of times it occurred). Then read the hash-table values and divide each value by 2. which value gets a remainder 1 that is the number which occurred odd time in an array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"html directory means html files container. Then what is mean by normal directory, what it contains text files or MSoffice files."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Q3 : html directory means html files container. Then what is mean by normal directory, what it contains text files or MSoffice files."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"read the array and put the elements in a HashSet.As u keep reading the array, do get for every element and if found ,remove it.Ultimately the only element which is there odd many times will be the item left in hasSet.Reason to use hashSet is the lookup wld be O(1)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"\"you have unsorted array[n] elements. the numbers in the array[n] occurs event times except one number occurs odd time. So, write an algorithm to find that number. Also explain its complexity too. (time and space) both. (On ALGORITHM)\"  You can do it in O(n). The idea is that if you multiply the numbers and divide when it is divisible by the current element, at the end, all even numbers will cancel out, leaving the odd number only:  int number = 1;  For each element i in the array:       if  number is divisible by  i [i.e. if( number mod (a[i] == 0) ]       then number = number / a[i];      else number = number * a[i];  return number;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void findodd(int [] ary){ Multimap map=new multimap(); for(int i=0;imap.put(a[i],a[i]); } for(inti=0;iCollection list=map.get(a[i]); if(list.size()%2!=0){ system.out.println(\"here is the odd one\"+list.get(a[i])); } } }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13032664","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"13","title":"1. There is a web URL which contains %20 in place of space, how will your replace every %20 with space?  2. Let's say we have a file on the disk which contains millions of such URL, how will you replace all %20 with space?  3. Let's say, on the file there are only 5% URL which contains this %20, how will your replace with space in most efficient way?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sed?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Textpad has some options for doing it bulk.  At the end of the day it is through regular expression find and replace the pattern will be faster :-)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1- have  read write pointers on the string to replace space 2- Fill the memory to minimize disk access 3- If block in the memory is not changed dont write it back, keep a clean dirty  bit + location info for %5 and just write that part back instead of whole block"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Dude was this question asked for Freshers?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Shall we use String.replaceAll method for that?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Regular Expression? Here's a Java Snippet"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I believe they will not allow you to use built-in library, for example Replace, Regex. You have to write your own algorithm, you can use KMP to answer this question"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=3377060","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"13","title":"Write a program to find integer equivalent of a string. E.g : for \"121\" input o/p should be integer 121","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we need to parse the string in the reverse order and iterate from all the characters and subtract 48 from each character and build the required number."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"???"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I dont know if you meant we should also avoid the Math and the String library functions -"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int conv(char *a) {int num=0; int ten=1; for(int i=strlen(a)-1;i>=0;i--,ten*=10)//go from last digit { num+=(a[i]-'0')*ten; } return num; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.*; import java.lang.*;  class Main {  public static void main (String[] args) throws java.lang.Exception  {   System.out.print(\"Hello World\");  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"As an interviewer, I would be very happy if the candidate would ask stuff like: - can I be sure the input is valid? - should I handle negative numbers as well?  These are not complicated changes to the algorithm, and they show 'wide' thinking of the candidate"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How do we handle negative numbers?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it is atoi() function implementation."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int y = (int)(x.charAt(i)-'0'); Can some one tell me what is actually going on here?? Why to do char-'0'"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"(int)x.charAt(i) gives the ascii value of the character.  so if you have 1 at charAt(0), the output is 49. ascii value of 0 is 48. So if we do ascii of 1 - ascii of 0, then we are doing 49 - 48 and the end result is saved in int y which will be 1. Applies same on any number."}]}}]