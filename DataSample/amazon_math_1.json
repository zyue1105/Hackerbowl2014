[{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=2113","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"24","title":"Brainteaser: there is a bar with 25 seats in a line. The people there are anti-social so when they walk in the bar, they always try to find a seat farthest away from others. If one person walks in and find there is no seat are adjecent to nobody, that person will walk away. The bar owner wants as many people as possible. The owner can tell the first customer where to sit. all the other customers will pick the farthest possible seat from others. So where should the first customer sit.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I would agree with the above answer: either seat 9 or 17 for the first customer. Here's how I figured it out:The best possible end scenario the owner can expect is persons sitting in every other seat; 13 people in seats 1, 3,5,7,9,11,13,15,17,19,21,23,25. We know that whenever a new customer enters the room, she is going to find the biggest gap between any two old customers, divide it in half and sit right between them. So, to be really efficient about this we need to make sure that when she can easily divide at half at every stage. If you cannot perfectly divide a gap by 2, a seat is going to get wasted. And this needs to be done repeatedly. Therefore, at every point, we need to make sure that the length of the gaps between seats are powers of two. So, how should we start out? Well if we select 9 as the first person's seat: then the first gap is 9-1= 8 seats wide (power of 2). The second gap is 25-9= 16 seats wide (another power of 2). So it works!Similarly, seat 17 for the first patron would also be acceptable."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Very nice question and answer, I guess we can say that for any number of chairs 2^n+2^m+1 we can choose either 2^n+1 either 2^m+1 as an initial chair considering they are numbered from 1,2,... to 2^n+2^m+1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"9 or 17"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why not 5? how are you assuming 9 and 175-1=4(power of 2)this meets our criteria of atleast one seat apart."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"actually any odd number seat will work"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"No 5, will not work. Nor will any odd numbered seat. If you have correct answers apart from 9 and 17, pls prove your point instead of posting trash. Let us assume someone sat in seat 5. Person number 2 will sit in seat 25.Person number 3 will sit in seat 15.Person number 4 will sit in either seat 10 or 20.Thats enough to prove 5 will not work. If anyone sits in an even-numbered seat, thats not optimal."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"well .. 9 and 17 are the only answer .. ppl just don't read question clearly"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if 9 the there are two sets 1-8 and 10-25 which is a power of 2the other case is when it is 17 where the two sets are 1-16 and 18-25 both of which are powers of twopower of tow is important so that it can be divided in two perfect halfs"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Thank you vinay kuruvila."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"9 or 17 are the only solutions"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why don't those that think it is a solution other than 9 or 17 actually test their theory. You will find it to be wrong...e.g. start at 1...next person will sit at 25....third will sit at 13....fourth will sit at either 7 or 19 (already an undesirable result as no further people will sit after these two are taken).Similar argument for any other odd number other than 9 or 17..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"8,9,10,16,17,18, I wrote a program to get theseanswers...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"OOps, my fault, the answer should be 9,17"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Consider a general case. If the number of seats is n = (2^k)+1 for some k, then, the maximum possible seating of (n/2)+1 can be achieved by having the first person sit at position 1 or n or ceil(n/2).This is true since when n=(2^k)+1, then, when someone sits in the first or middle or the last seat then all the other gaps are of length in powers of 2 (as suggested above by Vinay).This implies that for this problem, with n=25, we need to split it into n1 and n2 such that: n1 = (2^k1)+1 and n2 = (2^k2)+1, for some k1, k2. Note that n1+n2 = n+1 = 26 (since they both share a common seat).Thus, the only possible values are 9 or 17."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"9 and 17 are correct answer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"9 & 17  and no more comments plz."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The Answer 9 & 17 are correct. But I couldn't understand the reason explained above.    The solution to this problem can be thought recursively. The stop condition is when there are just 3 seats; that is there??s just 1 seat between the end seats. The series is like ??1,3,7,15,31,63...That is, when the number of seats between the end seats is one of these numbers, the division will be perfect. For 25 seats, when I select 9 as first seat 1...9....25 , the number of 'in between seats' in the first half is 7 and that of second half is 15. Both of these numbers appear in the above series I mentioned. I don't think it is possible to get a general formula for solution. Some numbers for which a perfect division exists is given below  1 2 3  4 5 6 7 : 3/5 1 2 3  4 5 6 7 8 9 10 11 :3/9 1 2 3  4 5 6 7 8 9 10 11 12 13 : 5/9 1..5..17..21  1...9....17...25"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can't it be 13 ?  .............13............ 1...........13...........25 1....7......13...........25 . . . 1 3 5 7 ...........21 23 25"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=184676","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"28","title":"Find a two-line program to output the Nth Fibinacci number","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"int fib(int N) { return (N < 2)? 1 : fib(N-1) + fib(N-2);}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int fib(int n) \n{ \nint sum; \nif(n>0) \n  sum = n + fib(n-1); \nreturn sum;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the question has asked about the nth fibonacci number. the code is written for the sum of n fibonacci numbers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"recursive algorithm, int get_fib(int n) {     if (n==1)||(n==2)          return 1;     else         return get_fib(n-1) + get_fib(n-2);     end; }  iterative algorithm, int get_fib(int n) {     if (n==1)||(n==2)         return 1;     else     {         prev = 1;          curr = 1;         cont = 2;         while (cont != n)         {             next = prev + curr;             prev = curr;             curr = next;             cont ++;         }         return next;     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"stupid question. its a simple Fibonacci Qs and the answer is the Standard answer...I bet even the interviewer can't do it in _2 LINES_ LOL @Gecko : recursive is good enough, no need to go for iterative... here is the python code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"long factorial(int n)    {    if (n<1)        return 1;    else                         return n * factorial(n - 1);    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int fib(int N) {  if(N==0||N==1)return 1;  if(N>1)return (fib(n-1)+fib(n-2)); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"http://en.wikipedia.org/wiki/Golden_ratio#Relationship_to_Fibonacci_sequence"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"lol. I think its not asking about squeezing the same code into two line.   I think its asking about Golden ratio.   http://www.ics.uci.edu/~eppstein/161/960109.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"matrix way:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"To find the nthFibonacci number, use the following recursive definition :  F0 = 0 F1 = 1 When n is an even number :    Fn = Fn / 2(Fn / 2 + 2 F(n??2) / 2) When n, modulo 4, is 1 :    Fn = (2 F(n??1) / 2 + F(n??3) / 2)(2 F(n??1) / 2 ?? F(n??3) / 2) + 2 When n, modulo 4, is 3 :    Fn = (2 F(n??1) / 2 + F(n??3) / 2)(2 F(n??1) / 2 ?? F(n??3) / 2) ?? 2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"fib(int n1,int n2,int n,int sum){   if(n-1 > 1){    fib(n2,n2+n1,n-1,n2+n1);   }                 else{    System.out.println(sum);                 }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"wait to promote your site you jackass"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@Anonymous on October 08, 2009: Guys like you promote our sites, we don't have to bother for that job.  You moron, fucking crap"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@anonymous int fib(int n) {     return (n<3)?1:(fib(n-1) + fib(n-2)); }  it should be n<3 you sucker[:P]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Mastram, I was going to write it this way."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use iterative version or dynamic programming (e.g. memorization). In recursion you are calculating more e.g fib(4) = fib(3) + fib(2) = fib(2) + fib(1) + fib(1) + fib(0) = fib(1) + fib(0) + ........."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for(int first=0,second=1,i=1,temp=0;i<=n;i++,temp=first,first=second,second+=temp)                 if(i==n && printf(\"%d\\n\",second));"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=1462","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"41","title":"You have a basket ball hoop and someone says that you can play 1 of 2 games. You get $1000 and one shot to get the hoop. Or, you get three shots and you have to make 2 of 3 shots. Which one do you choose? If p is the probability of making a particular shot, what value of p makes you switch games?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Expected value of one shot game, E1 = 1000pExpected value of three shot game, E3 = 1000(probabiliy of making 2 or 3 balls)          = 1000(p^3 + 3p^2(1-p))                 = 1000(-2p^3 + 3p2)Looking at these two expected values, E1 = E3 when when p=1,0, and E3 > E1 when p > 1/2.In English, it doesn't matter which game I play if p=1 or 0. If p < 1/2, I'll take game 1. If p > 1/2, I'll take game 2."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If game 1 is throwing the ball once and game 2 is attempting 3 time and getting atleast 2 shots in, then isn't it game 1 if p>1/2 and game 2 if p<1/2 ?This was what I thought, In the case of game 1 the chances of basketing is 1/2In the case of game 2, there are 8 possible outcomes for the event of shooting the ball thrice. Only 4 out of the 8 are successfull cases. Hence the chances of getting the price is 1/2, irrespective of the probability of getting one shoot right."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think it should be game1 if p < 66.66% and game2 if p < 66.66% and makes no difference if p = 0 or 100 or exactly 66.66% (I arrive at 66.66 since 2/3 is the probability reqd to get 2 shots out of 3 in game2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sorry, typo - it is game1 if p < 66.66% and game 2 if p > 66.66%"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If p is the probability of putting a basket:Of the 8 possible outcomes not putting a single basket in 3 attempts is one such outcome. Probability of not making a single basket in 3 attempts is (1-p)^3 If you remove that outcome from the possible outcomes, the remaining probability is 1-(1-p)^3. Now the probability of not putting 2 baskets (where not putting all three baskets is already considered) is (1-p)^2.Removing the probability of not putting 2 baskets we are left with1 - (1-p)^3 - (1-p)^2 equate this with p to find the breakeven pointHence:p = 1 - (1-p)^3 - (1-p)^2Solve this for p to arrive at p = 0.382 (approx)Hence if you can put a basket with a probability greater than 0.382 go for the 2 in 3 option. Else if your probability of putting a basket is below 0.382 stick with just one shot. Cheers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Amol, your soln makes more mathematical sense, I am not sure how you arrived at \"the probability of not putting 2 baskets (where not putting all three baskets is already considered) is (1-p)^2\"I think it is the same value as the probability of getting exactly 1 shot in out of 3,ie 1*(1-p)*(1-p)which is of course(1-p)^2, is thatright?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"btw - interesting to realise that the p ratio is 62:38 instead of ~ 67:33 :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a trick question.  For all values of p, you are better off taking the 2-shot game rather than the the 3-shot game.  In my opinion, this is also a terrible interview question for a software development position (unless, of course, the application domain involves statistics/probabilities).   Intuitively, think of it this way:  Assume you take the 3-shot game.  On your first shot, there are two cases to consider:  you either hit or miss.  In the case where you hit, then you have to make one of your next two shots to win the money.  This is the same odds as the 2-shot game.  In the case where you miss the first shot, you have to make *both* of the next two shots, which is considerably worse than the 2-shot game.  Therefore,  irrespective of p, you are always better off going with the 2-shot game.    Probablisticaly, this is derived as follows:Proabilities in the 2-shot game-----------------------make 2/2:     p^2make 1/2:     2 * (p*(1-p))  make 0/2:    (1-p) * (1-p)Probabilites in the 3-shot game--------------------------------make 3/3:    p^3make 2/3:    3 * (p^2 * (1-p))make 1/3:    3 * (p * (1-p) * (1-p) )make 0/3:    (1-p)^3Note that the outcomes of the 2-shot game & the 3-shot game both sum up to 1, which is what you expect. So, the probability of winning the 2-shot game is the sume of the 2/2 or the 1/2 outcomes, namely:    p^2 + 2((1-p) * p)And the probability of the three shot game is the sum of the 3/3 or the 2/3 outcomes, namely:   p^3 + 3 * (p^2 * (1-p))So, we want to know for what values of p is    p^2 + 2((1-p) * p) >  p^3 + 3 * (p^2 * (1-p))Through algrebraic manipulation, we get the following inequality:    0 < (p-1) ^ 2Which is always true, for all values of p."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if I am not mistaken you are comparing 1 out of 2 shots & 2 out of 3 shots, in such a case the 2 shot game is obviously always better.But I think the question compares a single shot and 2 shots out of 3, right?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for 1 shot game prob of winning = pfor 3 shot game prob of winning = p*p*(1-p) * 3C2 + p*p*p                                = 3pp - 2pppvalue at which both are equal = 0.5So if prob < 0.5, 1 is better else 2 is better."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"assuming your prob of scoring is 50%each game, u hv 2 outcomes, u score or u miss.so in game 1. ur winning is 50% = 1/2and in game 2.ur winning is 1/2 * 1/2 = 25%and that p value represents the prob of scoring.hence, p^2 >1/2 would give u the value of pneedlessly to say, that would be sqrt(1/2).p = 0.7071....i believe this is kinda same as the above explanationbut i just think this is much easier to understand without heavy mathematical proof."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think it should be as followsexpected value of game 1 1000*pexpected value of game 21000*((3choose2)p^2(1-p) + p^3)so if you solve it comes out to be game 1 = 1000*pgame 2 = 1000*(3p^2-2p^3)so 1000*p = 1000 *(2p^2-2p^3)then quad eq s.t. -2000p^2 + 3000p -1000 = 0solve for pp=1 or p=0.5meaning if u r more skilled (i.e. above 50%) then take the first game."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"That's all find and good. But which of these many wildly disparate answers is anything near to the CORRECT one?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The probability that you miss all three: (1-p)^3.  Then 1-(1-p)^3 is the probality that you make at least one out of three (the probability that you don't miss all three).Given two shots the probability that you miss both: (1-p)^2Then 1-(1-p)^3 is the probality that you make at least one out of two (the probability that you don't miss all two).That's all you need to find the probability of winning the second scenario, you just multiply them together:  (1-(1-p)^3) * (1-(1-p)^2)Just graph y = (1-(1-p)^3) * (1-(1-p)^2)versus y = pYou will the intercepts are when p = 0 and when p is around .24 and when p is 1.Look at the graph and you will see the answer, both are equal at 0 and 1, choice 1 is better < .24, choice 2 is better > .24."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Get out your probability textbook, this is a simple problem if you understand Binomial Distribution.The \"crossover\" value for p is 0.5If p < 0.5, you have a better chance at winning the first game.If p > 0.5, you have a better chance at winning the second game.Honestly though, this is an absolutely terrible question for a programming interview.  If a candidate is just out of school and has just taken a probability class, they will answer this easily.  Anyone else will probably get it wrong.  Either way, it doesn't say anything about their ability to program."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If you go through an entire day's worth of interviewing, you'll be asked 10,000 programming questions - atoi, reverse the words in a string, deck of cards, etc. - of which, probably 3 are necessary to understand whether the person can actually write code on a day to day basis.  As it turns out, you need employees to do more than just write code because ultimately -- a candidate's ability to reason, think and problem solve on their own says a great deal about their ability to program.  Truly great candidates are able to do this."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The solution is :           for p=0,     wining change game1=wining change game2           for 0.5>p>0  wining change game1 > wining change game2           for p=0.5,   wining change game1=wining change game2           for 1>p>0.5  wining change game1 < wining change game2           for p=1.0,   wining change game1=wining change game2Amol-B2 used the equation :p = 1 - (1-p)^3 - (1-p)^2            This is wrong coz, left side = chance of wining game1                              right side = chance of loosing game2, and both can't be same           use either (1) p=3p^2 - 2p^3  //equating winning chances               or     (2) 1-p=1 - (1-p)^3 - (1-p)^2  //equating loosing chances           Both equations (1) and (2) has three solutions for p at 0, 1/2 and 1           Logic:      Amol-B2 has posted his logic, which seems to me very reasonable except the equation is faulty and        hence the result.      For those still willing to have my approach see below:      Lets say o denoted failure in one try to basket and x represent success in busketting in one try.            Now in the second game, the number of the possible out come = 2 outcome of first throw X 2 outcome of                                                                     second throw X 2 outcome of third throw                                                                  =2*2*2                                                                  =8       They can be denoted as,      E1> 000      E2> x00      E3> 0x0      E4> 00x      E5> xx0      E6> x0x      E7> oxx      E8> xxx      Pr of winning in game 2 = Pr (E5 or E6 or E7 or E8) //where E denotes event                              = Pr(E5) + Pr(E6) + Pr (E7) + Pr(E8) //since events are mutually exclusive                                                                                                 =pp(1-p)  + p(1-p)p + (1-p)pp + ppp  //each event consists of three independent                                                                    //events(trials) of throwing the ball                              =3p^2 - 2p^3     Of coure the chance of winning first game=p      Now solve p=3p^2 - 2p^3 and remember this is a cubic equation and must have three solutions (real or      imaginary)     Refer to my reply to posting of 'math' above for the solution.Note: Those who are wondering why Pr(E5) != [(no of ways E5 can happen) / (Total Possible E's)] = 1/8      You must remember that this rule is true only when all events E1 thru E8 are equaly likely.      Even though each throw can have either basket or not, still these two outcomes are not equaly likely due      the p associated with each outcome. Thus the probability that one throw will end up as basket is p, not        1/2. Similarly the probability that each throw will end up as not-basket is (1-p) not (1-1/2=1/2).      Since each throw is not equally likely, the events E1, E2..E8 being collection of three successive throws      are not equally likely.       To be even more precise, lets say three throws are denoted bt T1, T2 and T3.      Thus Pr(E5)=Pr( T3=not basket given T1 and T2 are basket)                 =Pr (T3= not basket) . Pr(T1 and T2 are basket) //since each throw is independent events                 =Pr (T3=not basket).[Pr(T2=basket given T1=basket)]                 =Pr(T3=not basket).[Pr(T2=basket). Pr(T1=basket)]                 =(1-p)p.pHope I made sense"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"'"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"and 1="},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"' and 1="},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"\\'"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"'''"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ookjk85h74"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1 OR 1=1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1' OR '1'='1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1'1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"' 1 AND 1=1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1 AND 1=1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1\\'1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":") or ('1'='1--"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"' or 1=1/*"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"' or 1=1--"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"order by 1000/*"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"order by 1000;--"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"' order by 1000/*"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"' order by 1000;--"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"' or 1=1--"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"\" or 1=1--"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"') or ('a'='a"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=1724695","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"21","title":"Find sum of all integers of a given number such that sum is always a single digit(e.g. if given number is 987, then sum = 9+8+7=24=2+4=6). Code","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int Sum(int n){  int count = 0;         int r1 = n%10;         n = n/10;         while (n>9){                 int r = n%10;                 n = n/10;                 r1 = r+r1;                                  if( r1 >10 ){                         count++;                                             r1 = r1-10;                 }                  if(count >9){                         count =1;                 }         }         cout<<        r1 = r1+n;         if( r1 >10 ){                 count++;                 r1 = r1 - 10;         }         if(count >9){                 count =1;         }  return (count+r1); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int FindSum(int num){ \n//If num is single digit \n        int sum = 0; \n if(num / 10 == 0) \n  return num; \n else \n { \n  while(num > 1){ \n      sum = sum + num % 10; \n   num = num / 10; \n   } \n  //If sum is not single digit \n  if( sum / 10 != 0) \n   sum = FindSum(sum); \n } \n  \n return sum; \n} \nint main( ) \n{  \n cout << FindSum(9999) << endl; \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming non-negative numbers --  we can take advantage of the fact that  singleSum(994) = singleSum(9 + singleSum(94))  therefore,"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Modifying Sachinsaner's code to make it work (Just added a >= for num>1)  int FindSum(int num){ //If num is single digit int sum = 0; if(num / 10 == 0) return num; else { while(num > 1){ sum = sum + num % 10; num = num / 10; } //If sum is not single digit if( sum / 10 != 0) sum = FindSum(sum); }  return sum; } int main( ) { cout << FindSum(9999) << endl; return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class SumofDigits { \n \n    public static int sumofdigits(int inputnum) \n    { \n        int quot = inputnum; \n        int rem = 0; \n        while(quot > 0) \n        { \n            rem = rem + (quot % 10); \n            quot = quot/10; \n        } \n        if(rem/10 > 0) \n        { \n            rem = sumofdigits(rem); \n        } \n        return rem; \n    } \n \n    public static void main(String[] args) \n    { \n        int result = 698239623; //input number \n        result = SumofDigits.sumofdigits(result); \n        System.out.println(result); \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int Sum(int n)         {             while (n > 9)             {                 int sum = 0;                 do                 {                     sum += n % 10;                     n /= 10;                 } while (n > 0);                 n = sum;             }              return n;         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static Integer findNumber(Integer sum,Integer i){      if(i == 0 && sum > 10)    return findNumber(0,sum);   else if(sum<10 && i == 0)    return sum;   else    return findNumber(sum+(i%10),(i/10));  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int calculate(int num) {   while (num > 10) {    int curr_num = num;    num=0;    while (curr_num > 0) {     num += curr_num % 10;     curr_num = curr_num /10;            }   }   return num;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int out(int in){ int val; if(int(in/10)==0) return(in); val=in%10+out(int(in/10)); return(int(val/10)==0?val:out(val)); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int FindSum(int num) \n{ \n  int sum = 0 \n  while(num > 9) \n  { \n    sum = sum + n%10; \n    num = num/10; \n    if(num < 10) \n    { \n      num += sum; sum = 0; \n    } \n  }  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"forgot to return number..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You must be kidding around here.  number % 9  987 % 9 = 6 = 9 + 8 + 7 = 2 + 4 = 6"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"9 has a property, when added to a digit ...becomes the digit e.g. 9+7=16 = 1+6=7 when multiplied wid digit, resulting single digit sum is 9 e.g. 9*7 =63 =6+3=9  Moreover if number>9 sum cant be 0  if(num>9) {  if(num%9==0)    return 9;  else     return (num%9); } else return num;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{{ #include int main() { int r=0,n=0,sum=0; scanf(\"%d\",&n); while(n) { r=n%10; sum=sum+r; if(sum>9) sum=sum-9; n=n/10; } printf(\"%d\",sum); return 0; } }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include int main() { int r=0,n=0,sum=0; scanf(\"%d\",&n); while(n) { r=n%10; sum=sum+r; if(sum>9) sum=sum-9; n=n/10; } printf(\"%d\",sum); return 0; } 123"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int findsum(int n) { int sum=0; while(n>9) { while(n) { sum=sum+n%10; n=n/10; } n=sum; sum=0;  } return n; }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5686016069337088","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"21","title":"WAP to sort prime numbers smaller than given N by digits. If N is 40, the output should be 11, 13, 17, 19, 2, 23, 29, 3, 31, 37, 39, 5, 7. Follow-up question: limit memory usage.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Find all primes up to N using any method (e.g. sieve of Erastosthenes), then sort the numbers lexicographically."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{ \n \npublic int[] generatePrime(int n) { \n        int[] prime = new int[n]; \n        Arrays.fill(prime, -1); \n        prime[2] = 1;  \n        int cnt = 1; \n        for (int i = 3; i < n ; i = i+ 2) { \n             if (prime[i] != 0) { \n                 prime[i] = 1; \n                 cnt++; \n             } else { \n                 continue; \n             } \n             for (int j = i + i ; j < n ; j = j + i) { \n                  prime[j] = 0; \n             } \n        } \n        int[] output = new int[cnt]; \n        int i = 0; \n        /*for (int j=2 ; j < prime.length; j++) { \n            if (prime[j] == 1) { \n                output[i++] = j; \n            } \n        }*/ \n        for (int j = 1; j < 10; j++) { \n            if (prime[j] == 1) { \n                output[i++] = j; \n            } \n            int k = j * 10; \n            int ct = 1; \n            while ( k < n) { \n                for ( int kk = k + 1; kk < k + Math.pow(10, ct) && kk < n; kk = kk + 2) { \n                    if (prime[kk] == 1) { \n                        output[i++] = kk; \n                    }     \n                } \n                ct++; \n                k *= 10; \n            } \n        } \n         \n        return output; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"BTW - 39 is not a primenumber. But I guess printed in error:)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool isPrime(int num) {  bool prime = true;  for (int i = 2; i <= num / 2; i ++)   if (num % i == 0)   {    prime = false;    break;   }  return prime; }  int digits(int num) {  int dig = 0;  while (num)  {   num /= 10;   dig ++;  }  return dig; }  void insertMap(int num, int numdigits, map &primeMap) {  int base = numdigits - digits(num);  int baseAmount = 1;  while(base --)   baseAmount *= 10;  primeMap.insert(pair(num * baseAmount, baseAmount));  cout << \"insert: \" << num * baseAmount << \" - \" << baseAmount << endl; }  int restoreNum(int data, int baseAmount) {  return data / baseAmount; }  void primeSortInDigit(int range) {  map primeMap;  int numdigits = digits(range);  cout << \"range is \" << numdigits << \" digits\" << endl;  for (int num = 2; num <= range; num ++)   if (isPrime(num)){    cout << num << \" \";    insertMap(num, numdigits, primeMap);   }  cout << \"primeSortInDigit:\" << endl;  for (map::iterator it = primeMap.begin(); it != primeMap.end(); it ++)   cout << restoreNum(it->first, it->second) << \" \";  cout <}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can generate a prefix tree / trie of the prime numbers and kind of do a inorder traversal on it.  As numbers come in add it to the prefix tree. When inserting a number into trie, start from the last digit. eg. 1 2 3 5 7 11 13 17 19 23 29                                       root              1      2        3         5          7            9           1              1       2              1            2         (11)          (13) (23)          (17)        (29)   If a node represents a number mark the node as isNumber=true and ofcourse all the leafs represent the number.  Print the tree in preorder traversal (if the node has isNumber = true)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Basic thought here is to store the prime numbers in an array so that for determining any subsequent number say n, we need not do the checking for all n-1 integers instead we can check with only the given prime numbers less than n."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am writing first time on this site. Do corrections if required.  package com.core;  import java.util.BitSet;  public class PrimeProg {   /**   * @param args   */  public static void main(String[] args) {   int n = 50;// pass through the command line arguments.   int cnt = getPrimeCount(n);   int[] primeArr = new int[cnt];   int count = 0;      for(int k = 2;k <= n; k++){    if(findPrimes(k)){     primeArr[count++] = k;    }   }   int[] resultArr = swap(primeArr);   for(int i = 0; i < resultArr.length; i++) {    System.out.println(resultArr[i]);   }  }     private static int[] swap(int[] primeArr) {   int start = 0;   int mid = 0;   int end = primeArr.length-1;   boolean b= true;   boolean c= true;      for(int i=0; i   int x = primeArr[i]/10;    switch(x) {    case 1: {     int temp = primeArr[start];     primeArr[start] = primeArr[i];     primeArr[i] = temp;     start++;     mid++;     break;    }    case 2: {     if(b) {      ++mid;     }     int temp = primeArr[mid];     primeArr[mid] = primeArr[i];     primeArr[i] = temp;     mid++;     b=false;     break;         }    case 3:{     if(primeArr[mid] != 3 && primeArr[mid+1] == 3) {      int temp = primeArr[mid];      primeArr[mid] = primeArr[mid+1];      primeArr[mid+1]=temp;      mid++;     }     int temp = primeArr[mid];     primeArr[mid] = primeArr[i];     primeArr[i] = temp;     mid++;     c=false;     break;    }           }         }      /*int temp = primeArr[mid];   primeArr[mid] = primeArr[end];   primeArr[end] = temp;*/      return primeArr;  }    private static boolean findPrimes(int i) {   boolean flag = true;   for(int j=2;j<=Math.sqrt(i);j++) {    if(i%j == 0) {     flag = false;     break;    }    }   return flag;  }    public static int getPrimeCount(int n){   if(n < 2)    return 0;   BitSet candidates = new BitSet(n - 1);   candidates.set(0, false);   candidates.set(1, false);   candidates.set(2, n);   for(int i = 2; i < n; i++)   if(candidates.get(i))   for(int j = i + i; j < n; j += i)   if(candidates.get(j) && j % i == 0)   candidates.set(j, false);    return candidates.cardinality();  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is minor work around in code to reduce space required."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about the following approach for limited memory usage ?   Use an nlogn inplace sort algorithm like heap sort SUCH THAT the numbers should be compared  using the below compare function."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Check this..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a O(1) space and O(n) isprime tests solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can use a list and then use list.sort"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":".net - C#"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"C++ version using Sieve of Eratosthenes. Uses std::vector which in most implementations is equivalent to a bitset in terms of memory consumption."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class LexographicPrintingPrime { \n void printPrime(int n){ \n  ArrayList arr = new ArrayList(); \n  arr.add(2+\"\"); \n  arr.add(3+\"\"); \n  arr.add(5+\"\"); \n  arr.add(7+\"\"); \n   \n  int i = 8, k=0; \n  for(i =8; i<=n ;i++){ \n   if(i%2 == 0) \n    continue; \n   if(i%3 == 0) \n    continue; \n   if(i%5 == 0) \n    continue; \n   if(i%7 == 0) \n    continue; \n   arr.add(i+\"\"); \n  } \n   \n  System.out.println(arr.size()); \n   \n  for(i=4; i< arr.size(); i++){ \n   k = Integer.parseInt(arr.get(i)); \n   for(int j = 2*k; j< n; j= j+k){ \n    arr.remove(j+\"\"); \n   } \n  } \n   \n  Collections.sort(arr); \n  for(i=0; i< arr.size();i++){ \n   System.out.println(arr.get(i)); \n  } \n   \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Convert the numbers to Strings and sort them. This will sort the numbers lexicographically, which is what we want."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"If N is given , then simply use steve Er, method and print all the prime numbers upto N . its done as it will be in sorted order."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"import java.util.*; public class Prime {          static int a[]  = new int[1000];     static int count = 0;     static boolean flag = false;          static void findPrimes(int n){         a[0] = 2;          for(int i = 3; i < n; i++){                         for(int j = 0; j < count; j++){                 if(i%a[j] == 0){                     flag = true;                     break;                 }             }             if(flag==true){                 flag = false;             }             else{                 count++;                 a[count] = i;                             }                      }                  String s[] = new String[count+1];         for(int i=0; i <=count; i++){             s[i]=\"\"+a[i];         }         Arrays.sort(s);         for(int i=0; i<=count; i++)             System.out.print(s[i] +\" \");                       }     public static void main(String arg[]){                  findPrimes(40);     }      }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13204663","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"20","title":"Return all factorials of given integer. Enhance your approach by avoiding linear traversing.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Here is a simple optimization explained using an example.  Lets say we need to find factors of 18  We create a set containing factors. Initially insert 1 to the set  Now we check if 18%2 == 0  If yes, we check if 2 exists in the set. It does not, so we insert 2 in the set. Also, we check if 9 exists in the set (2X9==18) , it does not so we add 9 to the set  Similarly, while checking for 3, we add 3 and 6 to the set.   18%4!=0 and also 18%5!=0, so we dont add 4 and 5 to the set  Now while checking for 6 we notice that 6 already exists in the set. We terminate the process here since the set now contains all the factors.  Finally add n to the set.  Set : 1,2,9,3,6,18"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"void findfactors_rec(int n, int m) \n{ \n    m = m - 1; \n \n    if(m == 0) \n        return; \n    if(n % m == 0) \n        printf(\"%d\\n\", m); \n \n    findfactors_rec(n,m); \n} \n \nvoid findfactors_rec_wrapper(int n) \n{ \n    findfactors_rec(n,n); \n} \n \nint main() \n{ \n    findfactors_rec_wrapper(24); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Again use tail recursion. Linear recursion does not have the stack unwinding phase as large"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"dont get question correctly ?? is it all factor of a given number ??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def prime_factors(n): \n i = 2 \n limit = n**0.5 \n while i <= limit: \n  if n % i == 0: \n    yield i \n    n = n / i \n    limit = n**0.5 \n  else: \n    i += 1 \n if n > 1: \n  yield n \n \ndef all_factors(n): \n from itertools import combinations \n pfs = tuple(prime_factors(n)) \n for i in xrange(1,len(pfs)): \n  for j in combinations(pfs,i): \n   yield reduce(int.__mul__,j)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi oni ,  Can you please explain the logic."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Find all the prime factors 2. Find the all multiplication combinations for all factors using recursion"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void foo(int n,vector& vv) {  int lim=n;  for (int i=1; i<=lim; i++) {   if (n%i==0) {    vv.push_back(i);    if (i!=n/i)      vv.push_back(n/i);   }   lim=n/i;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"factor of 18 = 1,2,9,3,6,18 factorials of 18 = 1*2*3*4*5*6.......*18 why you guys are concentrating on divisors?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=3713811","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"20","title":"if u have a N steps staircase u standing at 1 step now you have options to step up to 2step or you can skip one step and go to 3rd step... so at ith step you have a option to go to i+1 step or i+2 step.. so how many ways you can climb the stairs...??","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I think fib is correct. This is the simple observation: Let f(i) be the number of ways that can be taken to reach step i. f(2) = 1  f(i) = f(i-1) + f(i-2)   That is, if we assume that we are about to take the last step for reaching i, either we are at step i-1 or at step i-2. Coming to step (i-1) we could have taken f(i-1) ways, for coming to i-2, we could have taken f(i-2) different ways."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi Guys, can you please help me understand how were u able to relate this problem to fibanocci series.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Now, the number of ways to reach step 2 from 1 is 1 and to reach every step from 3 to n, there are 2 ways, either from n-2 nd step or n-1st step. Therefore, there are 2^(n-2)ways for steps 3 to n. And there is one way to reach step 2.  Thus, the answer shud be 2^(n-2)+1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Yes Fibonacci no. for the nth step is the right answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If N is Even  x = N/2   If N is odd X = N/2-1  Answer is :   Xc0+Xc1+Xc2....+Xcx Correct me if my answer is wrong."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Guys!!!  who ever not willing to accept fibonacci series as answer, try to use mathematical induction and you'll get the answer as Fibonacci series.....  already at step-1 : hence if n=1 , no.of ways=1 if n=2, already at step-1: hence only 1 way possible hence-> 1 n=3 (1,1) or (2) -> 2 ways  f(3)=f(2)+f(1); ...............n=4,5,6,....please try out"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Fibonacci is the correct solution. But the defination should be as below: f(n) = f(n-1) + f(n-2) +1 f(1) = 0 f(2) = 1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"F(4) should be equal to 3 bt the above formula is giving 4. There are 3 ways 1->2->3->4 1->2->4 1->3->4."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it should be defined as F(1)=1; F(2)=1; F(n)=F(n-1)+F(n-2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"f(0) = 1 [Possible ways of reaching the step on which ur already there] f(1) = 1 (1) f(2) = 2 (1,1) (2) f(3) = 3 (1,1,1) (1,2) (2,1) f(4) = 5 (1,1,1,1) (1,1,2) (1,2,1) (2,1,1) (2,2) ..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it's a kind of dp problem,if ny one thoroughly looks into that then it can be seen easily idea is that initialize an array a[n+1] with a[0]=1,a[1]=1 i=2 loop: if i <=n a[i]=a[i-1]+a[i-2] else break i++ goto loop print a[n+1]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"f(n) = 2 + f(n-1) + f(n-2)   Which is basically the fibonacci series."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"f(n) = f(n-1) + f(n-2) + f(n-3)  F(n) = total number of ways"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=62823","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"18","title":"Implement an algorithm to generate all prime number from 1-100 in fastest and most efficient way","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Sieve of Eratosthenes is a much better solution for a problem where you have to find primes in 1-N. For 1-100, you will only need 8 iterations to find all primes. See: http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.lang; public static void Main(String[] args) {  int [] intArray = new int[101];  for(int i=0;i {    intArray[i]=1;  }  for(int i = 2;i<101;i++)  {    int count =2;    while(count<101)    {     if(count != i)     {       if((count%i)==0)         {            intArray[count] =0;       }// end If       count++;      }// end if    }// end While  }// end for   for(int i = 0; i  {     if(intArray[i] == 1)         System.out.println(\" values which are prime numbers:\" + intArray[i]);   } // end for }// end Main   Order of O(^2).  Please provide a feedback and a better one if possible.  Thanks AB"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.lang; public static void Main(String[] args) {  int [] intArray = new int[101];  for(int i=0;i {    intArray[i]=1;  }  for(int i = 2;i<101;i++)  {    int count =2;    while(count<101)    {     if(count != i)     {       if((count%i)==0)         {            intArray[count] =0;       }// end If       count++;      }// end if    }// end While  }// end for   for(int i = 0; i  {     if(intArray[i] == 1)         System.out.println(\" values which are prime numbers:\" + intArray[i]);   } // end for }// end Main   Order of O(^2).  Please provide a feedback and a better one if possible.  Thanks AB"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The outer for loop need not to iterate for 101 times i.e., Line 9: for(int i = 2;i<101;i++) it is enough to iterate for sqrt of(101)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Good explanation and C# and VB.net implementation http://www.nist.gov/dads/HTML/sieve.html http://blogs.msdn.com/brada/articles/409081.aspx"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Primes are all odd... So check i+2 start with 3...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simple. Just hardcode it! Only upto 100, right?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I quickly came up with this (I feel it is correct, but u never know!)  1. Check only odd numbers. 2. For those numbers, check if the number is divisible by 3, 5 or 7. 3. If the number obeys the above 2 conditions, it is not prime, else prime."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can keep a boolean array range from 0-100 (call it prime). Make all entries in the array as true.  We know that 0,1 are not prime. So prime[0] and prime[1] = false.  Now starting from 2 - cancel out all factors of 2,which means prime[4],prime[6] and so on make it as (false). Once thats done, go to the next entry in prime which is true;i.e 3."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"c# function.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"suppose u have number 'n', to check if it is prime, what if we check if it is divisible by a prime number less than n. if it is divisible, then it is composite, else it is prime. example -> n = 17 so u will check if 7 gives a remainder  with 2,3,5,7,11 or 13. it doesnt hence, it is prime. suppose n = 18. try again with 2,3,5,7,11,13,17. it is divisible by 2 and 3. hence, composite. thus, we need to maintain a  list of all prime numbers encountered below n."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's Python:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Prime {   public static void main(String[] args) {   int flag = 0;      System.out.print(\"2 \");      for (int i = 3; i<101; i = i + 2) {    flag = 0;    for (int j = 2; j <= Math.sqrt(i); j++) {     if (i % j == 0) {      flag = 1;     }    }    if (flag != 1)     System.out.print(i + \" \");   }  }  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6702347652694016","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"17","title":"In a book with N pages, pages are numbered from 1 to N. Find out how many times each digit occurs in that book.   You are expected to complete the function getDigitslnBook, which takes an integer as input and  prints how many times each digits occur, one in a line.  The Nth line in the output denotes how many times the integer N-1 occurs in page numbers.  Constrains:    N will be between 1 and 1,000,000,000, inclusive. The output will fit in an integer.  Sample lnputOO: 7  Sample Outputo : 0          1 0 0   Explanation : The page numbers are 1,2, 3,4, 5, 6 and 7.   Sample lnput01: 11  Sample Output01: 1 4             Explanation: Digit 1occurs 4 times, at 1,10 and 11.Rest of the digits occurs only once.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorry the sample input output did not come properly.  please find it here.   drive.google.com/file/d/0B2MCIfvwfpg2WW1XdjgwS282Q1U"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If I understand you question correctly you want to count all digits from numbers in range <1 - n>. I'm not sure if there is any better approach then brute force:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This problem can be solved very efficiently with recursion. The algorithm below runs in O(log(n))."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include    main() {     int num = 0;  printf(\" ENter a page number\");  scanf(\"%d\" , &num);  int pos =1;  int r;  int count[10], c,i, tpos;  for(c = 0 ; c < 10 ; c++)     count[c] =0;       while(num > 0)  {         r = num%10;         num = num/10;         for(i = 0; i <10 ; i++)         {                 tpos = pos/10;                 while(tpos > 0)                 {                     count[i] +=r* tpos;                     tpos= tpos/10;                 }                 if(i <= r)                     count[i] += 1;         }         pos = pos*10;  }  count[0]-=2;  for(i = 0; i < 10 ; i ++)  {      printf(\"\\n number %d , count % d\", i , count[i]);  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This was an online test and My solution passed only 10 out of 15 cases. remaining 5 cases timed out.  My solution was for i =1 to n , convert i to string and concatenation string. at the end find the number of occurrence in the string."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can be solved depending on the number of digits.  First lets identify the pattern of frequency of usage of each digit  0-9  : 1 10-99 : 10+10 100-999 : 100+100+100  let N be the input number and A be an array to store frequency of digits Scan the number from left to right and extract each digit out of it. Let the digit be k and position be j e.g. N = 4375 for k = 4, j = 3"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"initialize an array of int[10] from 0 .. 9 for each i in N keep getting reminder of i / 10 and increment array for each value found."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Any other efficient code, this is creating millions of strings and destroying."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Best Explantation for this problem stackoverflow.com/questions/20945790/count-the-number-of-ks-between-0-and-n"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a simple and pretty straightforward solution in Java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int[] countOccur(int n){   int[] occurence = new int[10];   int count = getshiftCount(n, occurence, 0, 1);   for (int i = 0; i < 10; i++){    occurence[i] += count;   }   if (n > 10){    occurence[0]--;   }   return occurence;  }   private int getshiftCount(int n, int[] occurence, int last, int power) {   int grade = n / 10;   int remainder = n % 10;   for (int i = 0; i < remainder; i++){    if (grade == 0 && i == 0){     continue;    }    occurence[i] += power;   }   occurence[remainder] += last + 1;   if (grade > 0){    return grade + getshiftCount(grade, occurence, remainder * power + last, power * 10);   } else {    return 0;   }  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=1738702","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"17","title":"Given an array of integers from 1 to N, and given a number X, how many ways are there to pick X elements from the array such that no two elements in the selected X elements are consecutive.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"DP problem. Assume F(N,X) is number of ways to pick X from array[N] without two consecutive number.   1.We pick last one in N, F(N-2,X-1) 2.We don't pick last one in N, F(N-1,X) add these two case we get  F(N,X)=F(N-2,X-1)+F(N-1,X)  initial condition: F(N,1)=N if N>0, F(0,X)=0, F(N,X)=0 if N<=X  Test: N=6, X=2 (1,3) (1,4) (1,5) (1,6) (2,4) (2,5) (2,6) (3,5) (3,6) (4,6) 10 combinations F(N,X)=F(N-2,X-1)+F(N-1,X) F(6,2)=F(4,1)+F(5,2)=4+F(3,1)+F(4,2)=7+F(2,1)+F(3,2)=9+F(1,1)+F(2,2)=10  Test: N=6, X=3 (1,3,5) (1,3,6) (1,4,6) (2,4,6) 4 combinations F(N,X)=F(N-2,X-1)+F(N-1,X) F(6,3)=F(4,2)+F(5,3)=F(2,1)+F(3,2)+F(3,2)+F(4,3)=2+1+1+F(2,2)+F(3,3)=4"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if N is odd the (N/2 +1) non consecutive numbers are there. Else If N is even then (N/2) Non consecutive number are there...  run selection on these non consecutive numbers using combination i.e. (N/2) C (X)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"C(N-(X-1), X)  Suppose a choice is a1, a2, ..., aX.  Let a1' = a1, a2' = a2 - 1, ..., aX' = aX - (X - 1), then, a1', a2', ..., aX' is the X combination out of N - (X - 1) numbers.  On the other hand, given any choice of a1' < a2' < ... < aX' in N - (X - 1) numbers, we can get the solution a1, a2, ..., aX."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use dynamic programming assume c(n,x) is # of ways to select x elements from the first n elements with the last element selected, then c(n,x)=sum{i=1..n-2}c(i,x-1), initial conditions are c(n,1)=1 and c(i,x)=0 for any i<2x-1. At last the total number of ways is sum{i=1..n}c(i,x)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"0              if N < 2x-1 (x+1)^(N-2x+1) if N >= 2x-1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"C(N,X) -N-1+X  is the number of ways one can do..  correct if i am wrong"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1,2,3,4,5,6....N 1. We can pick X elements at a space of 1 ( which are odd or even numbers ) space=1, N/x times 2. We can pick X elements each spaced at 2.. space =2 N/2X times 3. We can continue to pick x lements , each element spaced at X-1. ( as long as X(X-1)space = x-1, N/2(x-1) times  so this is a summations sum(N/px) where p varies from 1 to X-1 provided other conditions are satisfied. if we know the value of N and X, then the solution is a geometric series"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Combination minus consequtive combinations which to me sounds like (N /X) - (N-X+1)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=2871","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"16","title":"Write a program which makes the probablity of getting the even number when a dice is thrown in 72%( some number other than 50%).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"- We can try by throwing the dice two times.  - Now we have 36 events..  How do we divide the events so that the probability of even number is more than that of odd numbers ?      It can be done like this ..       a. When two consequtive even number comes - consider it even.      b. When we get two odd - consider it odd.      c. When we get two even - taken the second even.      d. When we get one even and one odd - take this even ( this is main).        With the above strategy - there are 27 events with even numbers and 9 events with odd numbers..      So this turns out - 3/4 (Probability for even) and  1/4 (Probability for odd).."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think that both results here are a little off. Even here is 2,4,6 while odd is 1,3,5. Here's my answer:  public static int rollDice () {  // Are we going to do even or odd?  int eo; // 0 means we're going to be odd, 1 means even  if ( Math.random() > 0.72 )   eo = 0; else    eo = 1;  // Generate an odd number (1, 3, 5)  int result = ( (int)( Math.random() * 3 ) * 2 + 1 );  // If eo is 1, adding it to the result makes it even (2, 4, 6); otherwise, it remains odd  result = result + eo;   return result; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"make it simplier: 72% probability to get a even number (2, 4, 6), then each even number has a probability of 72%/3 = 24%. Similarily, each odd number has a probability of 28%/3 = 9.3333%"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The simulation program would typically involves generating random number between and 0 and 1 and check in which range it falls in. For equal probability it should be in range of ( 1/6, 2/6, 3/6 ... ) to bias it we can shift the range. i.e for 72 percent we can have ( 0-28/300, 28/300 - 100/300, 100/300 - 128/300 ,...). In this way we can have biased no for even no generator."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"when u generate a random number n between 0 and 1, for equal probability, u assign the following way 0 - 1/6 = 1; 1/6 - 2/6 = 2; 2/6 - 3/6 = 3; 3/6 - 4/6 = 4; 4/6 - 5/6 = 5; 5/6 - 6/6 = 6  now for the even numbers to have 72% prob, we have to divide each 1/3rd into 1/3 * 28/100 and 1/3 * 72/100 i.e 28/300 and 72/300 now the ranges will be  0 - 28/300 = 1; 28/300 - 2/6 = 2; 2/6 - 128/300 = 3; 128/300 - 4/6 = 4; 4/6 - 228/300 = 5; 228/300 - 6/6 = 6  this way u get the biased probability of 72% for even numbers"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"x = rand() * 100;  t = 75; //your bias  return ((x%3)+1)*2 - (x \n   \n    \n   -  \n     BabelFish \n     on April 01, 2010 Edit | Flag  \n    \n    \n   Reply"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can somebody plz explain me the question? I did not get what is he asking for... \"...when a dice is thrown in 72%...\" what do u mean by this sentence?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"x=rand()*100; if(x<=72)    x=(rand()*3)*2; if(x>72)    x=(rand()*3)*2-1;  I think this works fine"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Rinks solution (Ist one) is correct"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6588887669407744","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"15","title":"Given a number N, now find the smallest number K such that product of digits of K is equal to N. If there is no such K then return -1. Suppose N = 100, then K = 455 N=26, K = -1","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Number should be as small as possible (e.g. 40 -> 58, not 85), easily remedied by following the procedure and adding the digit to a priority queue if the next product is >= 10.  However, the above algorithm still doesn't work for 12. The algorithm will follow 2 * 2 * 3 -> 4 * 3 -> 34, but the answer ought to be 26.  Operating on the principle of using fewest digits by combining as many small factors as possible is nice, but instead of an array of single digit primes, consider using all digits from 9 to 2:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int productOfDigitsEqualToNumber(int inputNumber) { \n        if (0 <= inputNumber && inputNumber <= 9) { \n            return inputNumber; \n        } \n        if (inputNumber < 0) { \n            inputNumber = Math.abs(inputNumber); \n        } \n        int smallestNumber = 0; \n        int factor = 1; \n        while (inputNumber > 1) { \n            for (int i = 9; i > 1; i--) { \n                if (inputNumber % i == 0) { \n                    inputNumber = inputNumber / i; \n                    smallestNumber = smallestNumber + i * factor; \n                    factor = factor * 10; \n                    if (inputNumber == 1) { \n                        return smallestNumber; \n                    } \n                    break; \n                } else if (i == 2) { \n                    return -1; \n                } \n            } \n        } \n        return -1;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. To be the smallest number, all the digits have to be in ascending order. 2. To get those digits, keep dividing N with numbers from 2 thru 9 (Lets say this is \"i\" in a for loop of  2 thru 9). 3. If N is divisible by i, divide and store the result of the division back in N. Keep this \"i\" as left most digit of the result. If N is still divisible, repeat this step without incrementing the for loop counter (i). 4. One more last point, to get the lowest number run the loop in reverse, i.e. from 9 thru 2. 5. Finally after all divisions done, we should get N = 1 for a success use case. Else make the result as -1. 6. Break from the loop if you get N = 1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// divide the number from 9 to 2 // if given number is divided by more then once from one digit then divide    record all the divider    and then sort the divider in ascending order"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// divide the number from 9 to 2 // if given number is divided by more then once from one digit then divide    record all the divider    and then sort the divider in ascending order"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the below solution will do.  [1] Find the largest single digit divisor of given number, this digit will form the rightmost digit of K [2] Next repeat [1] to find the next largest single digit divisor of the quotient of [1] which is less than or equal to digit found in [1]. The digit so found is the immediate left digit of K [3] If no digit could be found and quotient is > 9 return -1  Examples:      N        K       Quotient -----------------------------------    40         8         5               58         1 K=58       N        K       Quotient -----------------------------------    26         2         13  As Quotient is > 13, so K =-1      N        K       Quotient -----------------------------------    12         6         2               26         1  K=26"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be done using recursion as below."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Yet another solution: }}}  public static int calculateSmallestK(int N) {    int K = -1;   int buf = N;   int order = 1;    while ( buf > 9) {    if(isPrime(buf)) return -1;    for (int i = 9; i >= 2; i--) {     if (buf % i == 0) {      if (K==-1) K=0;      buf = buf / i;      K += i * order;      order *= 10;      i=9;     }    }   }   return K;  }    static boolean isPrime(int n) {      for(int i=2;i         if(n%i==0)              return false;      }      return true;  } }}}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Yet another solution in plain java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"1) Divide number in multiple of 2,3,5,7 of number. For given number: 2 * 2 * 5 *5 \n2) Backward, keep on multiplying adjacent number as long as multiple is a single digit (< 10) and create new digit and put new digit in place of that number. for given number: 4 * 5* 5 \n3) repeat step 2, u wont have to do it much.concatenate digits in sorted order. Result it: 455 \n4) if number can not be divided into multiple of 2, 3, 5, 7 only, then return -1 \n \nExample: 40 =>  2 * 2 * 2 * 5 = 8 * 5 =  5 * 8 = 40 \nExample: 1260 => 2 * 2 * 3 * 3 * 5 * 7 = 4 * 9 * 5 *  7 = 4 * 5 * 7 * 9 = 4579 \nExample: 12 => 2 * 2 * 3 = 2 * 6 = 26"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"static void Main(string[] args) \n        { \n            int sayi = Convert.ToInt32(Console.ReadLine()); \n            //iteration number \n            int donmeSayisi = sayi / 2; \n            //list of numbers that can divide \"sayi\"  \n            List bolenListesi = new List(); \n            for (int i = 2; i <= donmeSayisi; i++) \n            { \n                if (sayi % i == 0) \n                { \n                    bolenListesi.Add(i); \n                    sayi = sayi / i; \n                    i--; \n                } \n            } \n            //returns -1 \n            if (bolenListesi.Any(a => a > 9) || bolenListesi.Count == 0) \n            { \n                Console.WriteLine(-1); \n            } \n            //returns number \n            else \n            { \n                int donme = bolenListesi.Count - 1; \n                for (int i = donme; i >0 ; i--) \n                { \n                    if (bolenListesi[i] * bolenListesi[i - 1] < 10) \n                    { \n                        bolenListesi[i] = bolenListesi[i] * bolenListesi[i - 1]; \n                        bolenListesi.RemoveAt(i - 1); \n                    } \n                } \n                //Sort it \n                List liste = new List(); \n                for (int i = 0; i < bolenListesi.Count; i++) \n                { \n                    liste.Add(0); \n                } \n                foreach (int item in bolenListesi) \n                { \n                    int c = 0; \n                    foreach (int item1 in bolenListesi) \n                    { \n                        if (item > item1) \n                        { \n                            c++; \n                        } \n                    } \n                    int b = liste.Count(a => a == item); \n                    liste[c + b] = item; \n                } \n                bolenListesi = liste; \n                bolenListesi.RemoveAll(a=>a<1); \n                Console.WriteLine(string.Join(\"\", bolenListesi)); \n            } \n            Console.ReadLine();  \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"How about this?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5308479619203072","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"15","title":"How to represent a number in base -2? (negative -2 base) eg 6 can be 11010 i.e. 16 -8 +0 -2 +0 = 6.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Decimal can convert into base by divide and collecting the remainders,    For example:            Binary value of decimal 12               12 / 2 = 6 with remainder 0               6 / 2  = 3 with remainder 0               3/ 2  = 1 with remainder 1                1 / 2  = 0 with remainder 1   So the Binary value is 1100    Same formula can be applied to find Negative Base, but remember remainders have to be positive.   Like the sample found in wiki     Note, here  -5/-3 = 2 with remainder 1 ,    If a/b = c with remainder d then bc + d = a  , thus the c can be found like c = (a-d) / b    Let??s try to write Java method to calculate this."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"private static void convertBase(int decimalVal,int base){ \n  if(base > 0 && decimalVal < 0){ \n   System.out.println(\"not possible\"); \n   return; \n  }  \n        StringBuffer buffer = new StringBuffer(); \n        while (decimalVal != 0){ \n       \n          int result = decimalVal / base; \n          int remainder = decimalVal % base; \n          if(remainder < 0){ \n           result++; \n           remainder = decimalVal - base * result; \n          } \n          decimalVal = result; \n             buffer.insert(0, remainder); \n        } \n        System.out.println(buffer); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If we simulate 2-3 digits we can see the pattern of generated numbers. The code follows from observing how the range of positive/negative numbers changes. Time O( log n )."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"See Negative_base on wikipedia  Algorithm is same as positive-base conversion(e.g. base 2) but if you get remainder as -ve, you need to add the mod of base(e.g. | -2 | = 2) to remainder to get it to become non-negative and also add 1 to the remaining value after division by base."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public String convert(int number){   StringBuffer str = new StringBuffer();   while(number!=0){    int remainder = number/(-2);    int mod = number%(-2);    if(mod==-1){     remainder+=1;     mod=1;    }    str.insert(0, mod);    number=remainder;   }   return str.toString();  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Compilable and running code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int base_convert(int num, int base) \n{ \n    int rem =   0; \n    int idx = 0; \n    int baseX   =   0; \n \n    while( num ) \n    { \n        rem =   num%10; \n        baseX   +=   rem * pow(base,idx); \n        idx++; \n        num   /=  10; \n    } \n \n    return baseX; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Suppose you have a binary number 1101110.  If we consider this as base -2, the difference is that the odd digits now represent a negative value.  We simply need to convert the odd digits into base -2.  Examples:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"String neg2base(int x){ \n String ret = \"\"; \n int remains = 0; \n while(Math.abs(x) != 0){ \n  remains = x%2 == 0?0:1; \n  x -= remains; \n  x /= -2; \n  ret = remains + ret; \n } \n return remains + ret; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What a headache, but I managed it. It returns an integer where it's bits correspond to the base -2 encoding, it does it in O(log(n)) where n is the position of the highes bit:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"don't you just take the two's complement of the base2 representation? i.e. 00101 (6 in base 2) --> 11010 (6 in base -2)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=1189672","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"13","title":"You have a stream of sentences. you don't know total number of sentences until you exhaust the stream. you have to choose one sentence randomly from the input stream. you don't have space to store all sentences at your end. randomly means probability of choosing any sentence is equal.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it's classic reservoir sampling problem, say space limit is N,  first fill sentences into the space until full, then start from N+1 element in stream, get random number between 1 and N+1, and if the number is smaller than N,  then put this one into space, and we also have to randomly remove one that is already in space by get a random number between 1 and N, then keep doing this till stream exhausted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1st iteration- \ntemp = read 1st sentence; \ni=2; \n \nwhile((sentence =  read i-th sentence from stream) != null) { //keep reading till stream is exhausted \n     if random() > i/(i+1){ \n          temp = sentence; \n     } \n} \n \nreturn temp;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Good question"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what is random() returning here....decimal or whole number?  If whole number how would this logic work?   for instance if random() is returning 7 and if we have 10 lines in stream we expect the logic to return 7th line from the stream. This logic would return 10th line, becos for every iteration always random() > i / (i+1)is true. (  7 > 2/3 , 7 > 3/4, 7 > 4/5 and so on...)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi, Can you  please also mention the amazon location where this question was asked?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we see each sentence in the stream one after the other, as in we first see the 1st then the 2nd .....the i'th and so on.  to get a random sentence, accept the current sentence as sample with probability (1/i)...this will give us a random sentence with constant space requirement."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=1710695","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"11","title":"Given stock values for a share per day for a company for last say 1 year. Find the maximum loss that any share holder could have made?. Assume that share holder can buy and sell only once. Code and mail after interview.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Let A be the input array. Maintain another array AMin such that AMin[i] = min(A[i] ... A[n]), which can be done in linear time working backwards on A.  Now max(A[i] - AMin[i]) will be the maximum loss.  Ex:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Go through the array in order, keeping track of the lowest stock price and the best deal you've seen so far. Whenever the current stock price minus the current lowest stock price is better than the current best deal, update the best deal to this new value."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is not  my solution. A previous Question asked in Bloomberg section some what resembles the Question...... Maximum loss when we will buy at highest price and sell it at lowest price. So Find decreasing intervals..If you couldn't find any such interval then maximum loss is zero....   int MAX_LOSS( int A[]){   int i=0;  int max_loss = 0;   for( i =0 to n){      int local_maxima = A[i];          while( A[i] > A[i+1]){         local_minima = A[i+1];          ++i;      }       temp_max_loss = local_maxima - local_minima;       if(max_loss < temp_max_loss){         max_loss = temp_max_loss;      }    }   return max_loss; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Pretty simple....Imagine it to be a graph chart...Maintain a curr_max which stores the value of the spike above x-axis. A decreasing interval is present until a value higher than this occurs. FInd the min in that interval, the diff of which with curr_max will be our curr_max_loss. Do this for every decreasing interval updating curr_max_loss if necessary."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Did a similar problem with finding the HighestGainPossible."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"go through the list for each value if it is greater than current max, update current max, if it is smaller than current max, find difference and update current max difference"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int[] a = {1,2,3,4,5,6,7,7}; \n  int maxdiff=a[0]-a[1]; \n  int local_maximum= a[0]; \n  int diff =0; \n   \n  for(int i=0; i < a.length -1 ; i++){ \n    \n   for(int j=a[i+1];j< a.length;j++){ \n    if(a[j]>local_maximum){ \n     local_maximum = a[j]; \n     i=j; \n    }else{ \n     diff = a[i] - a[j]; \n     if(diff > maxdiff){ \n      \n      maxdiff = diff; \n     }       \n    } \n   } \n  } \n   \n  return maxdiff; \n }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13573665","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"10","title":"Q2. Written Exam Amazon(Bangalore)  Given a number in the form of string. Output the binary equivalent of that number.  Sample Input: \"8.5\" Sample Output: 1000.1  Sample Input: \"12.34.23\" Sample Output: \"ERROR\"","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"On questions like these, don't forget to handle cases where there is no binary equivalent."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static String printBinary(String n) {  int intPart = Integer.parseInt(n.substring(0, n.indexOf(??.??)));  double decPart = Double.parseDouble( n.substring(n.indexOf(??.??), n.length()));  String int_string = ?????;  while (intPart > 0) {  int r = intPart % 2;  intPart >>= 1;  int_string = r + int_string;  }  StringBuffer dec_string = new StringBuffer();  while (decPart > 0) {  if (dec_string.length() > 32) return ??ERROR???;  if (decPart == 1) {  dec_string.append((int)decPart);  break;  }  double r = decPart * 2;  if (r >= 1) {  dec_string.append(1);  decPart = r - 1;  } else  {dec_string.append(0);  decPart = r;  }  }  return int_string + ??.??? + dec_string.toString();"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//fraction part i have terminated to 10 digits"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Test cases: Negative number. Positive number. Are white spaces allowed: \"    123.45\"."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my approach. Note that i have not handled the case of negative numbers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i// made decimal point limited to 10"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public static void ConvertToBinary(string inputNumber) \n        { \n            string[] inputDigits = inputNumber.Split('.'); \n            List outputBinaryDigits; \n            bool IsValidInput = true; \n            Console.WriteLine(\"The Decimal Number is {0}\", inputNumber); \n            if (inputDigits.Count() > 2) \n            { \n                Console.WriteLine(\"ERROR\"); \n                IsValidInput = false; \n            } \n            else \n            { \n                outputBinaryDigits = new List(); \n                int parseStatus = 0; \n \n                foreach (string digit in inputDigits) \n                { \n                    int.TryParse(digit, out parseStatus); \n                    if (parseStatus == 0) \n                    { \n                        Console.WriteLine(\"ERROR\"); \n                        IsValidInput = false; \n                        break; \n                    } \n                    else \n                    { \n                        outputBinaryDigits.Add(Convert.ToString(parseStatus, 2)); \n                    } \n                } \n                if (IsValidInput) \n                { \n                    Console.WriteLine(\"The Binary Equivalent is {0}\", string.Join(\".\", outputBinaryDigits)); \n                } \n            } \n        }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=320716","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"10","title":"In a clock, calculate the angle between hour and minute handle","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"|5.5m - 30h| If greater than 180, subtract from 360. This accounts for the change in hour hand for every minute (There is 0.5 degree change in the hour hand for each minute)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Hour hand of a normal 12-hour clock turns 360?? = 0.5?? per minute = 30?? per hour Minute hand rotates through 360?? in 60 minutes = 6?? per minute.  SO, hour hand rotates = 4*30?? + 40*0.5?? = 140??. and minute hand rotates = 40*6?? = 240??  So the angle between them = 240-140 = 100??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"theta = 30Y - 6X.  where 30 and 6 are the angles covered in 1 hr and 1 min respectively. thus if time is 1hr 1 min. Then Y = 1, X = 1 so theta = 30-6 = 25deg  If X is 1 min then Y = 30/60 = 0.5 so theta = 30*0.5 - 6 as state above."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assume time to be ( 'a' hours:'b' minutes: 'c' seconds)   a= a%12; theta1 = (a + b/60 +c/3600)*2*pi/12 ; theta2 = (b + c/60)*2*pi/60 ;  dthetaRadian = abs(theta1 - theta2); dthetaDegree = dthetaRadian*180/pi;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"en.wikipedia.org/wiki/Clock_angle_problem"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"let time is X:Y(like 7:15) then angle=60X(1/2)+(1/2)Y-6Y=(30X-(11/2)*Y)%360"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Answer: 100 degrees. Is it correct?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The angle between them (in degrees) for h hours and m minutes is  (h*60 + m)*5.5 modulo 360. (where x mod 360 for an arbitrary real is defined as (x - ([x] mod 360), [x] is integer part of x)  We arrive at this by thinking in terms of relative angular velocities.  Maybe overkill."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Math.abs(6.0 * min - (min / 2.0 + (hour * 30)));"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=320699","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"9","title":"Fibonacci sequence and optimization","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it depends how what kind of optimization you want. If optimization of speed, use caching. If optimization of memory, just try this:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"f=0 s=1 print \"f\"  print \"s\" while (counter>0) {  f=s+f  s=f-s  print \"f\"   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"check this link, it has a log n approach:   ics.uci.edu/~eppstein/161/960109.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A non recursive solution saving current & previous OR us an array to save fib. no. calculated so far. Both solutions are example of dynamic programming but second uses O(n) time"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=320697","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"8","title":"check a number whether is Power of 2","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"return n&(n-1)==0;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"well, i dont think so that 6 is a power of 2!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The first solution perfectly works. 6 & 5 == 4 != 0 hence false. so 6 is not a power of 2."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This assumes that n=0 is considered a power of 2."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if (num & 1) != num     it is a power of 2"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=1749699","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"7","title":"Return a random element from list such that each element has equal probability of selection.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can you please elaborate further. List is a linked list or just a pool of numbers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Search for Reservoir sampling"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Example: N1->N2->N3->N4  Iterate through list from beginning - Start by choosing between N1 and N2 with a 1/2 chance of picking either one. - Then pick between ResultOf(N1,N2) and N3 with a 1/3 chance of picking N3 and 2/3 chance of picking ResultOf(N1,N2) - Then pick between ResultOf(N1,N2,N3) and N4 with a 1/4 chance of picking N4 and 3/4 chance of picking ResultOf(N1,N2,N3)  Solution:  - Keep choosing between previousChoice and NewChoice with a 1/N chance of picking NewChoice and (N-1)/N chance of picking previousChoice where N is the Node number  Proof: If you go thorough the above example, N1 was chosen with a chance of (3/4)(2/3)(1/2)=(1/4)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nint main() \n{ \nint r=0,n=0,sum=0; \nscanf(\"%d\",&n); \nwhile(n) \n{ \nr=n%10; \nsum=sum+r; \nif(sum>9) \nsum=sum-9; \nn=n/10; \n} \nprintf(\"%d\",sum); \nreturn 0; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=2108","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"0","title":"When i wasn't certain whether my random function generated with equal probability all permutations, the interviewer asked me to write a formal proof that it works or not and send it to him (really strange). Proved it with the following and he bought it:Probabilisticlycard 1 has 52 positions it can fit incard 2 has 51card 3 has 50so on and so forthcard 52 has 1 position to fit inhence its 52 x 51 x 50 x ... x 1 = 52! can be generated using this shuffle.Oblivious to me, aparantly this kind of shuffle is used a lot in online card games. Silly me :P"}}]