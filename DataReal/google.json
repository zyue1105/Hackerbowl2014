[{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5329244276129792","download_status":"DOWNLOAD_DONE","votes":"-9","answersCount":"6","title":"An arraylist containing datatype studentsScores are given where studentId, and results are twostates of this datatype. Each student takes more than 10 exams. We need to return the averages score of each student as a Map where the average score is calculated by taking the average of top 5 exams of a student. First we iterate the arraylist and create another Map> where the inner ArrayList has values of test scores. Iterating the arrayList to find avergae score and adding it to the another Map. What is the complexity of this?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"That sounds like homework, not an interview question.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"sivaji8, stop tagging these stupid posts as Google Interview questions. If you want help on your homework, go to stackoverflow.com."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class Student \n{ \n String id; \n ArrayList scores; \n Map> mapScores; \n Map map; \n public Student(String id) \n { \n  this.id = id; \n  scores = new ArrayList(); \n  mapScores = new HashMap>(); \n  map = new HashMap(); \n } \n  \n public void addScore(double score) \n { \n  scores.add(score); \n   \n  setStudentScores(); \n } \n  \n public void setStudentScores() \n { \n  mapScores.put(id, scores); \n } \n  \n public Map> getStudentScores() \n {     \n  return mapScores; \n } \n  \n public void averageScore() \n { \n  //if(!mapScores.containsKey(id)) \n  ArrayList scores = mapScores.get(id);   \n  //System.out.println(scores); \n  Collections.sort(scores); \n  //System.out.println(scores); \n   \n  double sum = 0; \n   \n  for(int i = scores.size() - 1; i >= scores.size() - 5; i--) \n   sum += scores.get(i); \n   \n  double average = sum / 5.0; \n   \n  map.put(id, average); \n } \n  \n public Map getAverageScore() \n { \n  averageScore(); \n  return map; \n } \n} \n \npublic class StudentScores  \n{ \n public static void main(String[] args) \n { \n  Student student1 = new Student(\"1\"); \n   \n  student1.addScore(80); \n  student1.addScore(100); \n  student1.addScore(90); \n  student1.addScore(70); \n  student1.addScore(50); \n  student1.addScore(60); \n  student1.addScore(85); \n  student1.addScore(95); \n  student1.addScore(82); \n  student1.addScore(78); \n  student1.addScore(88); \n  student1.addScore(96); \n   \n  System.out.println(student1.getAverageScore().toString()); \n }   \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I got the exact same question in my amazon interview."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"n*logn + n"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5074387359236096","download_status":"DOWNLOAD_DONE","votes":"5","answersCount":"24","title":"Complete the below function which takes an arraylist and displays the list in the expected output  public class TreePrinter { public static void printTree(Iterable rs) { // your code  } }   public static class Relation {   String parent;   String child;   public Relation(String parent, String child) { ... } } }  Example input: List input = newArrayList();  input.add(new Relation(??£þanimal???, ??£þmammal???)); input.add(new Relation(??£þanimal???, ??£þbird???)); input.add(new Relation(??£þlifeform???, ??£þanimal???)); input.add(new Relation(??£þcat???, ??£þlion???)); input.add(new Relation(??£þmammal???, ??£þcat???)); input.add(new Relation(??£þanimal???, ??£þfish???));  TreePrinter.printTree(input);  Expected output:  line 1: lifeform line 2:   animal line 3:     mammal line 4:       cat line 5:         lion line 6:     bird line 7:     fish","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"public class TreePrinter { \n  \n public static void main(String[] args) { \n  List input = new ArrayList(); \n  input.add(new Relation(\"animal\",\"mammal\")); \n  input.add(new Relation(\"animal\",\"bird\")); \n  input.add(new Relation(\"lifeform\",\"animal\")); \n  input.add(new Relation(\"cat\",\"lion\")); \n  input.add(new Relation(\"mammal\",\"cat\")); \n  input.add(new Relation(\"animal\",\"fish\")); \n   \n  TreePrinter t = new TreePrinter(); \n  t.printTree(input); \n } \n  \n public void printTree(Iterable rs){ \n   \n  //build a tree like below with lifeform as root  \n  //and do a traversal. \n  //lifeform -- animal \n  //animal -- mammal -- cat-- lion \n  //animal -- bird \n  //animal -- fish \n   \n  //use this set to keep track of children to find out  \n  //which one is the root node. \n  Set setOfNotRootElements = new HashSet(); \n   \n  //build a tree using HashMap. You can also build the tree  \n  //put a Map inside a Map, but this seems simpler. \n  HashMap> map = new HashMap>(); \n  for(Relation r: rs){ \n   List children =  new ArrayList(); \n   if(map.containsKey(r.parent)){ \n    children = map.get(r.parent); \n   } \n   children.add(r.child); \n   map.put(r.parent, children ); \n    \n   //keeping track of children.. \n   setOfNotRootElements.add(r.child); \n  } \n   \n  //find the root \n  Set diffSet = new HashSet(map.keySet()); \n  diffSet.removeAll(setOfNotRootElements); \n  String root = diffSet.iterator().next(); \n   \n  //traverse the tree. \n  printNode(root, map); \n   \n  //lifeform \n  //animal \n  //mammal \n  //cat \n  //lion \n  //bird \n  //fish \n } \n  \n public void printNode(String parent, HashMap> map){ \n  System.out.println(parent); \n  List children = map.get(parent); \n  if(children != null){ \n   for(String child: children){ \n    printNode(child, map); \n   } \n  } \n } \n  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package careercup; \n \nimport java.util.*; \n \n/** \n * Date: 08.10.13 \n * Time: 01:14 \n */ \npublic class TreePrinter { \n \n    public static void printTree(Iterable rs) { \n \n        class Tree { \n            String node; \n            List child = new ArrayList(); \n \n            public Tree(String nodeName) { \n                node = nodeName; \n            } \n \n            Tree find(String nodeName) { \n                if (node.equals(nodeName)) { \n                    return this; \n                } else { \n                    for (Tree tree : child) { \n                        Tree result = tree.find(nodeName); \n                        if (result != null) { \n                            return result; \n                        } \n                    } \n                } \n \n                return null; \n            } \n \n        } \n \n \n        Tree root = null; \n        Relation r = null; \n \n        Iterator it = rs.iterator(); \n \n        PriorityQueue queue = new PriorityQueue(); \n \n \n        while( it.hasNext() ) { \n \n            r = it.next(); \n \n            if (root == null) { \n                root = new Tree(r.parent); \n                root.child.add(new Tree(r.child)); \n            } else { \n                Tree parent = root.find(r.parent); \n                if (parent != null) { \n                    parent.child.add(new Tree(r.child)); \n                } else { \n                    parent = root.find(r.child); \n                    if (parent == root) { \n                        Tree newRoot = new Tree(r.parent); \n                        newRoot.child.add(root); \n                        root = newRoot; \n                    } else { \n                        queue.add(r); \n                    } \n                } \n            } \n \n            int size = queue.size(); \n            for (int i = 0; i < size; ++i) { \n                r = queue.poll(); \n \n                Tree parent = root.find(r.parent); \n                if (parent != null) { \n                    parent.child.add(new Tree(r.child)); \n                } else { \n                    parent = root.find(r.child); \n                    if (parent == root) { \n                        Tree newRoot = new Tree(r.parent); \n                        newRoot.child.add(root); \n                        root = newRoot; \n                    } else { \n                        queue.add(r); \n                    } \n                } \n            } \n \n        } \n \n        while (!queue.isEmpty()) { \n            r = queue.poll(); \n \n            Tree parent = root.find(r.parent); \n            if (parent != null) { \n                parent.child.add(new Tree(r.child)); \n            } else { \n                parent = root.find(r.child); \n                if (parent == root) { \n                    Tree newRoot = new Tree(r.parent); \n                    newRoot.child.add(root); \n                    root = newRoot; \n                } else { \n                    queue.add(r); \n                } \n            } \n        } \n \n \n        Stack stack = new Stack(); \n        stack.push(root); \n \n        int i = 1; \n        while(!stack.empty()) { \n            Tree currentTree = stack.pop(); \n            System.out.println(i++ + \". \" + currentTree.node); \n \n            for (int j = currentTree.child.size() - 1; j >= 0; --j) { \n                stack.push(currentTree.child.get(j)); \n            } \n        } \n \n    } \n \n \n    static class Relation implements Comparable{ \n        String parent, child; \n \n        public Relation(String parent, String child) { \n            this.parent = parent; \n            this.child = child; \n        } \n \n        @Override \n        public int compareTo(Relation o) { \n            return 0; \n        } \n    } \n \n \n    public static void main(String[] arg) { \n \n        List input = new ArrayList(); \n \n        input.add(new Relation(\"animal\", \"mammal\")); \n        input.add(new Relation(\"animal\", \"bird\")); \n        input.add(new Relation(\"lifeform\", \"animal\")); \n        input.add(new Relation(\"cat\", \"lion\")); \n        input.add(new Relation(\"mammal\", \"cat\")); \n        input.add(new Relation(\"animal\", \"fish\")); \n \n        TreePrinter.printTree(input); \n \n \n    } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package careercup; \n \nimport java.util.ArrayList; \nimport java.util.HashMap; \nimport java.util.HashSet; \nimport java.util.LinkedList; \nimport java.util.List; \nimport java.util.Map; \nimport java.util.Set; \nimport java.util.Stack; \n \npublic class TreePrinter { \n public static void printTree(Iterable rs) { \n  class Node { \n   final String name; \n   final List children = new LinkedList(); \n \n   public Node(String name) { \n    this.name = name; \n   } \n  } \n \n  Map nodeDictionary = new HashMap(); \n  Set roots = new HashSet(); \n \n  for (Relation r : rs) { \n   if (!nodeDictionary.containsKey(r.parent)) { \n    Node node = new Node(r.parent); \n    nodeDictionary.put(r.parent, node); \n    roots.add(node); \n   } \n   if (!nodeDictionary.containsKey(r.child)) { \n    Node node = new Node(r.child); \n    nodeDictionary.put(r.child, node); \n   } \n   Node parentNode = nodeDictionary.get(r.parent); \n   Node childNode = nodeDictionary.get(r.child); \n \n   // i want to print the fish last \n   parentNode.children.add(0, childNode); \n   roots.remove(childNode); \n  } \n  Stack stack = new Stack(); \n  stack.addAll(roots); \n  int line = 1; \n  while(!stack.isEmpty()){ \n   Node pop = stack.pop(); \n   System.out.println(String.format(\"line %d : %s\", line++, pop.name)); \n    \n   for(Node child : pop.children) { \n    stack.push(child); \n   } \n  } \n } \n \n public static class Relation { \n  String parent; \n  String child; \n \n  public Relation(String parent, String child) { \n   this.parent = parent; \n   this.child = child; \n  } \n } \n \n public static void main(String[] args) { \n  List input = new ArrayList(); \n \n  input.add(new Relation(\"animal\", \"mammal\")); \n  input.add(new Relation(\"animal\", \"bird\")); \n  input.add(new Relation(\"lifeform\", \"animal\")); \n  input.add(new Relation(\"cat\", \"lion\")); \n  input.add(new Relation(\"mammal\", \"cat\")); \n  input.add(new Relation(\"animal\", \"fish\")); \n \n  TreePrinter.printTree(input); \n  // Expected output: \n  // line 1: lifeform \n  // line 2: animal \n  // line 3: mammal \n  // line 4: cat \n  // line 5: lion \n  // line 6: bird \n  // line 7: fish \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do we can use a prefix tree?  Will look like:-      [root]------------------------------------    |   |                     |     lion   |                     |     \\     |                     |    cat  |                     |      |                  |                     |   mammal       bird              fish      \\                    |                   |     animal---------|----------------|        |       lifeform"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do we can use a prefix tree?  Will look like:-   ------------------[root]------ ------|--------------|-------- | -----lion-----------|-------- | ------|--------------|---------| ------cat-----------|-------- | ------|--------------|-------- | ----mammal--- bird----- fish ------|--------------|----------| -----animal-------|----------| ------|   lifeform"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package com.test; \n \nimport java.util.ArrayList; \nimport java.util.HashMap; \nimport java.util.List; \n \npublic class TestDelete { \n \n  public static void main(String[] args) { \n    List input = new ArrayList(); \n \n    input.add(new Relation(\"animal\", \"mammal\")); \n    input.add(new Relation(\"animal\", \"bird\")); \n    input.add(new Relation(\"lifeform\", \"animal\")); \n    input.add(new Relation(\"cat\", \"lion\")); \n    input.add(new Relation(\"mammal\", \"cat\")); \n    input.add(new Relation(\"animal\", \"fish\")); \n \n    TestDelete.printTree(input); \n  } \n \n  public static void printTree(Iterable rs) { \n    HashMap> graph = new HashMap>(); \n \n    for (Relation r : rs) { \n      if (!graph.containsKey(r.parent)) { \n        graph.put(r.parent, new ArrayList()); \n      } \n \n      graph.get(r.parent).add(new Edge(r.parent, r.child)); \n    } \n \n    String start = findRoot(graph); \n    printAll(graph, start); \n  } \n \n  private static void printAll(HashMap> graph, String start) { \n    if (start == null) \n      return; \n    System.out.println(start); \n    List edges = graph.get(start); \n    if (edges == null) \n      return; \n    for (Edge e : edges) { \n      printAll(graph, e.getDestNode()); \n    } \n \n  } \n \n  private static String findRoot(HashMap> graph) { \n    List root = new ArrayList(graph.keySet()); \n    for (List edges : graph.values()) { \n      for (Edge e : edges) \n        root.remove(e.getDestNode()); \n    } \n    return root.get(0); \n  } \n \n  static class Edge { \n    String srcNode; \n    String destNode; \n \n    public Edge(String s, String d) { \n      srcNode = s; \n      destNode = d; \n    } \n \n    public String getSrcNode() { \n      return srcNode; \n    } \n \n    public String getDestNode() { \n      return destNode; \n    } \n  } \n \n  static class Relation { \n    String parent; \n    String child; \n \n    public Relation(String parent, String child) { \n      this.parent = parent; \n      this.child = child; \n    } \n  } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package exam; \n \nimport java.util.ArrayList; \nimport java.util.List; \n \npublic class Main { \n \n public static void main(String[] args) throws java.lang.Exception { \n  List input = new ArrayList(); \n  input.add(new Relation(\"animal\", \"mammal\")); \n  input.add(new Relation(\"animal\", \"bird\")); \n  input.add(new Relation(\"lifeform\", \"animal\")); \n  input.add(new Relation(\"cat\", \"lion\")); \n  input.add(new Relation(\"mammal\", \"cat\")); \n  input.add(new Relation(\"animal\", \"fish\")); \n \n  printTree(input); \n } \n \n public static void printTree(List input) { \n  if (!input.isEmpty()) { \n   Relation head = input.remove(0); \n   List parents = new ArrayList<>(); \n   List children = new ArrayList<>(); \n   List friends = new ArrayList<>(); \n   List rest = new ArrayList<>(); \n   for (Relation relation : input) { \n    if (relation.child.equals(head.parent)) \n     parents.add(relation); \n    else if (relation.parent.equals(head.child)) \n     children.add(relation); \n    else if (relation.parent.equals(head.parent)) \n     friends.add(relation); \n    else \n     rest.add(relation); \n   } \n \n   if (parents.isEmpty()) \n    System.out.println(head.parent); \n   else { \n    parents.addAll(rest); \n    printTree(parents); \n   } \n   for (Relation relation : friends) { \n    System.out.println(relation.child); \n   } \n   if (children.isEmpty()) { \n    System.out.println(head.child); \n   } else { \n    children.addAll(rest); \n    printTree(children); \n   } \n  } \n } \n \n static class Relation { \n  String parent, child; \n \n  public Relation(String parent, String child) { \n   this.parent = parent; \n   this.child = child; \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"C++"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a bit verbose but simple to follow (I hope)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void printTree(Iterable rs) {  \n         ArrayList Nodes = new ArrayList (); \n         ArrayList Parents = new ArrayList (); \n         HashMap > map = new HashMap >(); \n          \n         for(Relation r : rs) { \n             String p = r.parent; \n             String c = r.child; \n             if(!Nodes.contains(p)) { \n                 Parents.add(p); \n                 Nodes.add(p); \n             } \n              \n             if(Nodes.contains(c)) { \n                 Parents.remove(c); \n             } else { \n                 Nodes.add(c); \n             } \n              \n             if(map.containsKey(p)) { \n                 ArrayList childs = map.get(p); \n                 childs.add(c); \n                 map.put(p, childs); \n             } else { \n                 ArrayList childs = new ArrayList(); \n                 childs.add(c); \n                 map.put(p, childs); \n             } \n         } \n \n         String key = Parents.get(0); \n         System.out.println(key); \n         ArrayList que = new ArrayList(); \n         que.add(key); \n         while(que.size() != 0) { \n             String s = que.remove(0); \n             if(map.containsKey(s)) { \n                 ArrayList childs = map.get(s); \n                 int i; \n                 for(i = 0; i < childs.size(); i++) { \n                     System.out.print(childs.get(i) + \" \"); \n                     que.add(childs.get(i)); \n                 } \n                 System.out.println(); \n             } \n         } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{{ import java.util.ArrayList; import java.util.LinkedHashMap; import java.util.LinkedList; import java.util.List; import java.util.Map;  public class TreePrinter {  public static class Relation {   String parent;   String child;    public Relation(String parent, String child) {    this.parent = parent;    this.child = child;   }  }   public static void print(int i, String key) {   System.out.println(\"line \" + i + \": \" + key);  }    public static class Node{   String key;   Node parent;   List childlen;   Node(String key){    this.key = key;    childlen = new LinkedList();   }   public int printOut(int i){    print(i,key);    i++;    for(Node child:childlen){     i = child.printOut(i);    }    return i;   }  }  public static void printTree(Iterable rs) {   // your code   Map map = new LinkedHashMap();   for (Relation r : rs) {    Node parent = map.get(r.parent);    if(parent == null){     parent = new Node(r.parent);     map.put(r.parent, parent);    }    Node child = map.get(r.child);    if(child == null){     child = new Node(r.child);     map.put(r.child, child);    }    parent.childlen.add(child);    child.parent = parent;   }   int index = 1;   for (String key : map.keySet()) {    if (map.get(key).parent == null) {     index = map.get(key).printOut(index);    }   }  }   public static void main(String[] argv) {   List input = new ArrayList();   input.add(new Relation(\"animal\", \"mammal\"));   input.add(new Relation(\"animal\", \"bird\"));   input.add(new Relation(\"lifeform\", \"animal\"));   input.add(new Relation(\"cat\", \"lion\"));   input.add(new Relation(\"mammal\", \"cat\"));   input.add(new Relation(\"animal\", \"fish\"));   printTree(input);  } }  }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void printTree(Iterable rs) { \n         \n        Set roots = new HashSet(); \n        Map> adjMap = new HashMap>(); \n        for(Relation r : rs) { \n            List children = adjMap.get(r.parent); \n            if(children==null) { \n                children = new ArrayList(); \n                adjMap.put(r.parent, children); \n            } \n            children.add(r.child); \n            roots.add(r.parent); \n            roots.remove(r.child); \n        } \n \n        String root = roots.iterator().next(); \n \n        if(root == null) { \n            throw new IllegalStateException(\"No root found\"); \n        } \n \n        System.out.println(\"AdjMap: \" + adjMap); \n \n        Stack queue = new Stack(); \n        String node = null; \n        queue.add(root); \n        while(!queue.isEmpty()) { \n            node = queue.pop(); \n            System.out.println(node); \n            if(!adjMap.containsKey(node)) continue; \n            List list = adjMap.get(node); \n            for(int i = list.size() - 1; i>=0; --i) { \n                queue.push(list.get(i)); \n            } \n        } \n \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I love first solution. Anyway, I have implemented the other option, creating a homemade TreeNode quite simple."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Is it making a tree from list and then doing dfs.?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5007980722388992","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"20","title":"Implement an algorithm to print all possible valid combinations of braces when n pairs of paranthesis are given.  I tried this code executing. I checked with System.out.println statements too. But I couldn't understand how this prints ( ( ) ). I have two questions.   1) If we give count as 2, this code should generate only ( )( ). But how does it go for another execution of whole addParen to generate (( ))  2) The second if block(that is, if(rightRem > leftRem) within the else block of allParen is always after if(leftRem > 0), then how come this is able to generate  ( ( ) )  public static void addParen(ArrayList list, int leftRem, int rightRem, char[] str, int count) {      if (leftRem < 0 || rightRem < leftRem) return; // invalid state            if (leftRem == 0 && rightRem == 0) { /* all out of left and right parentheses */    String s = String.copyValueOf(str);          //    System.out.println(str);    list.add(s);   } else {    if (leftRem > 0) { // try a left paren, if there are some available     str[count] = '(';                     addParen(list, leftRem - 1, rightRem, str, count + 1);    }    if (rightRem > leftRem) { // try a right paren, if there??s a matching left     str[count] = ')';                // System.out.println(str);     addParen(list, leftRem, rightRem - 1, str, count + 1);    }   }  }   public static ArrayList generateParens(int count) {   char[] str = new char[count*2];   ArrayList list = new ArrayList();   addParen(list, count, count, str, 0);         return list;  }  public static void main(String args[]) {  ArrayList list = generateParens(2);         for (String s : list) {             System.out.println(s);         }         System.out.println(list.size());      } }","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Let N be an even number (just double the n from the question), the size of the thing you are building.  Backtracking:  left to right build your thing. Keep track of the number of ( and ) braces already in the filled part of the thing you are building."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"The idea is simple - Recursive Backtracking C++ program to print all valid combinations of 'n' pair of braces"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the combinations of braces should be build in following lexical rules"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void printParen( int n, string pref = \"\", string suff = \"\" ) \n{ \n if ( n == 1 ) \n  cout << pref << \"()\" << suff << \"\\n\"; \n \n if ( n <= 1 ) \n  return; \n \n printParen( n-1, pref+\"(\", \")\"+suff ); \n printParen( n-1, pref+\"()\", suff ); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#!/usr/bin/env python \n \n# Implement an algorithm to print all possible valid combinations of braces \n# when n pairs of parenthesis are given. \n \ndef parenthesis(n, left=0, right=0, s=\"\"): \n    \"\"\" \n \n    >>> parenthesis(2) \n    (()) \n    ()() \n \n    \"\"\" \n    if left > n or right > n or right > left: \n            return \n \n    if left == right and left + right == 2*n: \n        print s \n \n    parenthesis(n, left + 1, right,     s+\"(\") \n    parenthesis(n, left,     right + 1, s+\")\")"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void brackets(int leftCnt, int  rightCnt, int totalCnt, String out) { \n     if(leftCnt == totalCnt && rightCnt == totalCnt) { \n         System.out.println(out); \n         return; \n     } \n      \n     if(leftCnt < totalCnt) { \n          \n         brackets(leftCnt+1, rightCnt, totalCnt, out + \"(\"); \n     } \n      \n     if(rightCnt < leftCnt) { \n   \n         brackets(leftCnt, rightCnt+1, totalCnt, out + \")\"); \n     } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void \nall_forms (int level, int left, char *buf, char *ptr) \n{ \n    /* start a new nesting */ \n    *ptr = '('; \n    ptr++; \n    left--; \n \n    if (left) { \n        // build whatever left as nested \n        all_forms(level+1, left, buf, ptr); \n    } \n    /* close this nesting - over-writing the nested buffer */ \n    *ptr = ')'; \n    ptr++; \n \n    /* if any iterations left, do it without nesting */ \n    if (left) { \n        // build whatever left as un-nested (same level) \n        all_forms(level, left, buf, ptr); \n    } else { \n        // reached the end - close all nesting levels and print it \n        while (level) { \n            *ptr = ')'; \n            ptr++; \n            level--; \n        } \n        *ptr = 0; \n        printf(\"%s\\n\",buf); \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Guys , this looks like finding catalan number problem. we can use the formula for catalan numbers as  for n=1; Cn =1 for N>1; Cn =  ( n(n+1)/(n+2) ) *Cn-1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public static String paranComb(int comb) \n    { \n        if (comb == 1) \n        { \n            return \"()\"; \n        } \n        else \n        { \n            return paranComb(comb - 1) + \"(\" + paranComb(comb-1) + \")\";         \n        } \n    } \n     \n    public static void main(String [] args) \n    { \n        System.out.println(paranComb(1)); \n        System.out.println(paranComb(2)); \n        System.out.println(paranComb(3)); \n        System.out.println(paranComb(4)); \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Updated"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"void braces(int open, int close, string str) { \n        if(open == 0 && close == 0) { \n                 cout << str << endl; \n        } \n        if(open > 0) { \n                 braces(open-1, close+1, str + \"{\"); \n        } \n        if(close > 0) { \n                 braces(open, close-1, str + \"}\"); \n        } \n} \n \nint main() { \n      int n; \n      cout << \"Please enter number of braces : \"; \n      cin >> n; \n      int open = n, close = 0; \n      braces(open, close, \"{\"); \n      return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"/******* Try this one *******/ void Addparen(vector &myvector,int left,int right,char *str,int count) {  if(left<0 ||left>right)   return;  if(left==0 && right==0)  {   int size=myvector.size();   myvector.resize(size+1);   myvector.at(size)=str;  }  else  {   if(left>0)   {    str[count]='(';    Addparen(myvector,left-1,right,str,count+1);   }   if(right>0)   {    str[count]=')';    Addparen(myvector,left,right-1,str,count+1);   }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"import java.util.Iterator; \n \npublic class PrintParComb { \n \n private static int maxLength; \n \n public static void main(String[] args) { \n  \n  Character set[] = { '(', ')' }; \n  int count = 4; \n  PrintParComb p = new PrintParComb(); \n  p.printAllKLength(set, count); \n } \n \n // The method that prints all possible combination of length k. It is \n // mainly a wrapper over recursive function printAllKLengthRec() \n public void printAllKLength(Character set[], int count) { \n  int n = set.length; \n  int k = n * count; \n  maxLength = k; \n  StackImp stack = new StackImp(k+1); \n  printAllKLengthRec(set, stack, n, k); \n } \n \n // The main recursive method to print all possible strings of length k \n public void printAllKLengthRec(Character set[], StackImp stack, int n, int k) { \n \n  // Base case: k is 0, print prefix \n  if (k == 0) { \n    \n    \n   StringBuilder sb = new StringBuilder(); \n   for(Character ch : stack) \n   { \n    sb.append(ch); \n   } \n    \n   System.out.println(sb.toString()); \n   //System.out.println(stk.printStack()); \n   stack.pop(); \n   return; \n  } \n \n  // One by one add all characters from set and recursively \n  // call for k equals to k-1 \n  for (int i = 0; i < n; ++i) { \n \n   // Next character of input added \n   if (stack.isEmpty()) { \n    if (set[i] == ')') { \n     return; \n    } \n    stack.push(set[i]); \n   } else { \n \n    stack.push(set[i]); \n \n    if (stack.getRightCount() > stack.getLeftCount()) { \n     stack.pop(); \n     continue; \n    } \n    if (stack.getLeftCount() > (maxLength / 2)) { \n     stack.pop(); \n     continue; \n    } \n \n   } \n   // k is decreased, because we have added a new character \n   printAllKLengthRec(set, stack, n, k - 1); \n  }   \n  stack.pop(); \n } \n  \n \n public class StackImp implements Iterable{ \n \n  private Character[] arr; \n  private int count = 0; \n  private int leftCount = 0; \n  private int rightCount = 0; \n   \n  public StackImp(int arraySize) \n  { \n   arr = new Character[arraySize]; \n  } \n \n  public void push(char c) { \n   arr[count++] = c; \n   if (c == '(') { \n    leftCount++; \n   } else { \n    rightCount++; \n   } \n  } \n   \n  public void pop() \n  { \n   if(arr[count-1]=='(') \n   { \n    leftCount--; \n   } \n   else \n   { \n    rightCount--; \n   } \n   arr[count-1]=null; \n   count--; \n  } \n \n  public boolean isEmpty() { \n   return count == 0 ? true : false; \n  } \n \n  public int getLeftCount() { \n   return leftCount; \n  } \n \n  public int getRightCount() { \n   return rightCount; \n  } \n \n  public Character[] getArr() { \n   return arr; \n  } \n \n  public int getCount() { \n   return count; \n  } \n \n  public String printStack() { \n   StringBuilder sb = new StringBuilder(); \n   Iterator chIt = iterator(); \n    \n    while(chIt.hasNext()) \n    { \n     sb.append(chIt.next()); \n    }   \n \n   return sb.toString(); \n  } \n   \n \n  public Iterator iterator() { \n   return new Itr(); \n  } \n \n   \n  private class Itr implements Iterator { \n \n   int cursor = 0; \n \n   @Override \n   public boolean hasNext() { \n \n    return StackImp.this.arr[cursor] != null ? true : false; \n \n   } \n \n   @Override \n   public Character next() { \n \n    return StackImp.this.arr[cursor++]; \n \n   } \n \n   @Override \n   public void remove() { \n    throw new UnsupportedOperationException(); \n \n   } \n \n  } \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"import java.util.Iterator; \n \npublic class PrintParComb { \n \n private static int maxLength; \n \n public static void main(String[] args) { \n  \n  Character set[] = { '(', ')' }; \n  int count = 4; \n  PrintParComb p = new PrintParComb(); \n  p.printAllKLength(set, count); \n } \n \n // The method that prints all possible combination of length k. It is \n // mainly a wrapper over recursive function printAllKLengthRec() \n public void printAllKLength(Character set[], int count) { \n  int n = set.length; \n  int k = n * count; \n  maxLength = k; \n  StackImp stack = new StackImp(k+1); \n  printAllKLengthRec(set, stack, n, k); \n } \n \n // The main recursive method to print all possible strings of length k \n public void printAllKLengthRec(Character set[], StackImp stack, int n, int k) { \n \n  // Base case: k is 0, print prefix \n  if (k == 0) { \n    \n    \n   StringBuilder sb = new StringBuilder(); \n   for(Character ch : stack) \n   { \n    sb.append(ch); \n   } \n    \n   System.out.println(sb.toString()); \n   //System.out.println(stk.printStack()); \n   stack.pop(); \n   return; \n  } \n \n  // One by one add all characters from set and recursively \n  // call for k equals to k-1 \n  for (int i = 0; i < n; ++i) { \n \n   // Next character of input added \n   if (stack.isEmpty()) { \n    if (set[i] == ')') { \n     return; \n    } \n    stack.push(set[i]); \n   } else { \n \n    stack.push(set[i]); \n \n    if (stack.getRightCount() > stack.getLeftCount()) { \n     stack.pop(); \n     continue; \n    } \n    if (stack.getLeftCount() > (maxLength / 2)) { \n     stack.pop(); \n     continue; \n    } \n \n   } \n   // k is decreased, because we have added a new character \n   printAllKLengthRec(set, stack, n, k - 1); \n  }   \n  stack.pop(); \n } \n  \n \n public class StackImp implements Iterable{ \n \n  private Character[] arr; \n  private int count = 0; \n  private int leftCount = 0; \n  private int rightCount = 0; \n   \n  public StackImp(int arraySize) \n  { \n   arr = new Character[arraySize]; \n  } \n \n  public void push(char c) { \n   arr[count++] = c; \n   if (c == '(') { \n    leftCount++; \n   } else { \n    rightCount++; \n   } \n  } \n   \n  public void pop() \n  { \n   if(arr[count-1]=='(') \n   { \n    leftCount--; \n   } \n   else \n   { \n    rightCount--; \n   } \n   arr[count-1]=null; \n   count--; \n  } \n \n  public boolean isEmpty() { \n   return count == 0 ? true : false; \n  } \n \n  public int getLeftCount() { \n   return leftCount; \n  } \n \n  public int getRightCount() { \n   return rightCount; \n  } \n \n  public Character[] getArr() { \n   return arr; \n  } \n \n  public int getCount() { \n   return count; \n  } \n \n  public String printStack() { \n   StringBuilder sb = new StringBuilder(); \n   Iterator chIt = iterator(); \n    \n    while(chIt.hasNext()) \n    { \n     sb.append(chIt.next()); \n    }   \n \n   return sb.toString(); \n  } \n   \n \n  public Iterator iterator() { \n   return new Itr(); \n  } \n \n   \n  private class Itr implements Iterator { \n \n   int cursor = 0; \n \n   @Override \n   public boolean hasNext() { \n \n    return StackImp.this.arr[cursor] != null ? true : false; \n \n   } \n \n   @Override \n   public Character next() { \n \n    return StackImp.this.arr[cursor++]; \n \n   } \n \n   @Override \n   public void remove() { \n    throw new UnsupportedOperationException(); \n \n   } \n \n  } \n } \n \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5885777548410880","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"23","title":"You have been given a series of 'n' numbers and the series is in a random order. Write a program to find the median of the series with minimum complexity.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"use Randomize selection algo or median of median Algorithm. Median of median promises a tighter upperbound of O(n) as compare to randomize select O(n2)  But in practise randomize select is faster as compare to median of median as constants in median of median are large.  Edit: In my opinion Median of Medians is slower as compare to QuickSelect with randomly chosen pivot in practice (never tested on large data). Although worst case is O(N2) for Quickselect where as it is O(N) for median of Medians but it is near to impossible to produce worst case scenario for randomly chosen pivot.  I just posted an article on quick select on my blog, too lazy to explain it here as well, interested user can find the code + explanation + linear time complexity analysis (brief) at below link: ms-amazon.blogspot.in/2013/10/quick-select-select-kth-smallest.html  In case I get some time, I'll post Median of Medians as well. Hope it helps. cheers :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Sort the array and find the mid point which will be the median of the series.... complexity : O(nlogn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"We can find median using random selection algorithm  in linear time.  Actually here we are utilizing \"5-random-elements method\" to find a median  in efficient way.  Pick 5 elements at random from A[1..n], and set q to be their median. What it is the probability that q is not a good pivot ? ? Let S be the elements of A[1..n] which are in the 10% smallest. ? The probability that an elements picked at random is in S is 0.1. ? q is in S only if at least 3 of the 5 elements that we pick are in S. ? The probability that this happens is 0.15       +  5?0.14 ?0.9   +      10? 0.13 ?0.92 = all in S     4 in S,one not in S     2 not in S = 0.00001 + 0.00045 + 0.00810=0.00856 ? This is also the probability that q is in the 10% largest elements. ? In other words: with probability ??98%, q is a good pivot.  Putting it together, during partition, each time that we need to find a pivot, we use the ??£þ5 random elements??? method. With probability 98%, we find a good pivot. The overall time that we spend on good partitions is much smaller than the time we spent on bad partitions.  This algo can be apllied on QuickSelect or Selection algorithm."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"_If_ the range of numbers, which are _integers_, is O(n) we can use:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Use randomized quick sort; Whenever an element is fixed ad the middle of the array, return that value; It is guaranteed to median in O(n lg n). Best case O(1). If the randomly picked element is median."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public int findMedian(int[] a) { \n    int len = a.length; \n    if (len % 2 == 1) \n        return quickSelect(a, 0, len, len/2 + 1); \n    else \n        return (quickSelect(a, 0, len, len/2) + quickSelect(a, 0, len, len/2 + 1))/2; \n} \n \npublic int quickSelect(int[] a, int left, int right, int rank) { \n    int pivot = a[rand(left, right)]; \n    int leftEnd = partition(a, left, right, pivot); \n    int leftSize = leftEnd - left + 1; \n     \n    if (leftSize == rank) \n        return max(a, left, leftEnd); \n    else if (leftSize < rank) \n        return quickSelect(a, leftEnd+1, right, rank-leftSize); \n    else \n        return quickSelect(a, left, leftEnd, rank); \n} \n \npublic int partition(int[]a, int left, int right, int pivot) { \n    while (true) { \n        while (left <= right && a[left] <= pivot) \n            left++; \n        while (left <= right && a[right] > pivot) \n            right--; \n         \n        if (left > right) \n            return left-1; \n        swap(a, left, right); \n    } \n} \n \npublic int max(int[] a, int left, int right) { \n    int max = Integer.MIN_VALUE; \n    for (int i = left, i <= right; i++) { \n        if (a[i] > max) \n            max = a[i]; \n    } \n    return max; \n} \n \npublic int rand(int low, int high) { \n    return low + Math.random() * (high-low+1); \n} \n \npublic void swap(int[] a, int left, int right) { \n    int tmp = a[left]; \n    a[left] = a[right]; \n    a[right] = tmp; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Median of medians algorithm or more commonly known as 'quickselect'."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can also do this in O(n) time and O(n) space with two heaps -- a min heap and a max heap.  Push the numbers onto the heaps keeping them equal in size or a max of 1 size difference.  Median will be average of the tops of the two heaps if they are equal in size.  If they are different sizes (max size difference of 1), median will be the top of the larger heap.  This is also a way to continuously determine the median of a stream of integers of indeterminate size."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here are the steps to find in linear ( o(n) time 1. Find the max and min elements of the list.  2. Take the avarage of the min and max element. 3. Now subtract the average element from the list. 4. Find the closest element which is close to 0, this will be the median of the list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"in C++ code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use Quick Select, You have to check in n -> even or n -> odd"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include using namespace std;  int sort(int * arr, int l,int h); void partition(int * arr,int l, int h, int size); void swap(int * arr, int a, int b); void display(int * arr, int size); void main() {  cout<<\"Enter the Size of arry\"< int size=0;  cin>>size;  int * arr=new int [size];  cout< cout<<\"Enter the array to sort\"< for (int i=0;i  cin>>arr[i];  display(arr, size);  partition(arr,0,size-1,size);    system(\"PAUSE\"); }  void partition (int * arr,int l, int h, int size) {      int pivot=0;   if(l>=h) return;          display(arr,size);     pivot=sort(arr,l,h);  partition(arr,l,pivot-1, size);  partition(arr,pivot+1,h, size);      }  int sort(int * arr, int l, int h) {  int pivot=arr[l];  int i=l;  int j=h;    while(i {        while((pivot >= arr[i]) &&  (i<=h) )        i++;      while((pivot < arr[j]) &&   (j>=l) )     j--;      if(i     swap(arr,i,j);  }   swap(arr,l,j);  return j; }  void swap(int * arr, int a, int b) {     int t=arr[a];  arr[a]=arr[b];  arr[b]=t; }  void display(int * arr, int size) {     for(int i=0; i  cout<     cout<}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include using namespace std;  int partition(int * arr, int l, int h,int m); int search(int * arr, int l, int h); void swap(int * arr,int a,int b); void display(int * arr, int size) {  for(int i=0;i  cout<     cout<}  void main() {    int size=0;    cout<<\"Enter The Size of Array:\"<   cin>>size;    int * arr=new int [size];     for(int i=0; i   {     cout<<\"Enter the No::\";     cin>>arr[i];     cout<   }     cout<   cout<   display(arr,size);     system(\"PAUSE\"); }  int partition(int * arr , int l , int h , int m) {  int p=0;                 p=search(arr,l,h);   if(p==m)   {    return arr[p];   }   else if(p  {    partition(arr,p+1,h,m);   }   else   {    partition(arr,l,p-1,m);   }       }  int search(int * arr,int l,int h) {  int p=arr[l];  int i=l;  int j=h;       while(i  {    while(i<=h && p>=arr[i]) i++;   while(j>=l && p < arr[j]) j--;    if(i   swap(arr,i,j);         }     swap(arr,l,j);  return j;  }  void swap(int * arr,int a,int b) {  int t=arr[a];  arr[a]=arr[b];  arr[b]=t; }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6266328830705664","download_status":"DOWNLOAD_DONE","votes":"-18","answersCount":"11","title":"Finding the minimum in a BST.   The known solution is public Node minimum(){  Node current, last;  current = root;  while(current != null){   last = current;   current = current.left;  }   return last; }  The above code doesn't find 0.5 as the minimum.  1 and 3 are children of 2, 0.5 is left child of 3 and 3.5 is right child of 3                                   2                                /    \\                            1          3                                      /    \\                                   0.5   3.5","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"First of all its not from Google.  The left most node of BST is minimum."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"if 0.5 is the left child of 3 then it does not satisy BST property as root of the tree 2 is greater than 0.5.  correct me if I am wrong"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"The case you use is not a BST."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if( node == nil) return nil;    // empty tree, no minimum \nwhile( 1 )  { \n    if(node.left == nil) return node; //has no left child, so we are at min. \n    node = node.left;        //has left child, so min. is recursively in left tree \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can you mark these without company name?  Because you are just practicing, this is not from a Google interview."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void MinValue(struct binraytree *b, struct binarytree **result) //result is initialized to NULL  \n{ \nif(b) \n{ \n  if(*result==NULL || (b->data < (*result)->data)) \n      *result=b; \n  MinValue(b->lc,result); \n  MinValue(b->rc,result); \n} \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"algorithm minBST(node) { if(node.left == null) return node else minBST(node.left) }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6639269430951936","download_status":"DOWNLOAD_DONE","votes":"-12","answersCount":"17","title":"Check if a binary tree is BST.  I know the solution but I want to know will this code work  public boolean IsBST(Node root){                if(root.left <= root && root.right > root){         IsBST(root.left);          IsBST(root.right);     }else{         return false;     }          return true; }","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"You need to maintain global min and global max so that you can compare that any value in left subtree is always less than global minimum and similarly any value in right subtree should be greater than global maximum. Using that concept:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"No it wont work...coz ur  only looking at the immediate childs...what if the down the tree the BST properties are violated?? The solution i had in mind was just do inorder traversal and see if the array result is sorted or not.....  if any body can provide a better solution????"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static boolean isBST(TreeNode root, int min, int max){      if(root==null)    return true;         if(root.key max)    return false;      if((root.leftChild !=null && isBST(root.leftChild, min, root.key)==false) ||      (root.rightChild !=null && isBST(root.rightChild, root.key, max)==false))   {    return false;   }      return true;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool isBST(TreeNode* root, int min_val = INT_MIN, int max_val = INT_MAX) \n{ \n     if (root == NULL) return true; \n     return root >= min_val && root <= max_val && isBST(root->left, min_val, root->val) && isBST(root->right, root->val, max_val);  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is this really a Google question?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int isBST(struct bst *b) \n{ \nstatic struct bst *prev=NULL; \nif(b) \n{ \nif(!isBST(b->lc)) \n  return 0; \nif(prev!=NULL && b->data<=prev->data) \n  return 0; \nprev=b; \nreturn isBST(b->rc); \n} \n} \nreturn 1;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Swapnil's answer runs correct only if the tree is an integer storing bst. here is another solution for generic types. seperated into functions for ease of understanding"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Not sure why max is really needed."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Check if the inorder traversal of the tree is sorted or not..this should give the answer.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#include \n#include \nusing namespace std; \n \nclass TreeNode{ \n  public: \n TreeNode* left; \n TreeNode* right; \n    int val; \n TreeNode(int); \n}; \n \nTreeNode::TreeNode( int value ) { \n left = NULL; \n right = NULL; \n val = value; \n} \n \nvoid createTree(TreeNode* node){ \n TreeNode* h; \n    h = node; \n    h->left = new TreeNode(2); \n h->right = new TreeNode(5); \n    h->left->left = new TreeNode(1); \n h->left->right = new TreeNode(4); \n h->right->left = new TreeNode(6); \n h->right->right = new TreeNode(7); \n} \n \nint customInorderTraversal(TreeNode *rootnode){ \n int maxval; \n \n if(rootnode != NULL){ \n  maxval = rootnode->val; \n  int maxleft = maxval; \n  int maxright = maxval; \n  if(rootnode->left != NULL) \n   maxleft = customInorderTraversal(rootnode->left); \n  if(rootnode->right != NULL) \n   maxright = customInorderTraversal(rootnode->right); \n \n  if(maxleft == INT_MIN || maxright == INT_MIN){ \n   return INT_MIN; \n  }else{ \n   if(maxleft <= maxval && maxval <= maxright){ \n    return maxright; \n   }else{ \n    return INT_MIN;  \n   } \n     } \n }else{ \n  return INT_MAX; \n } \n} \n \n \nint main(){ \n TreeNode* rootnode = (TreeNode*) new TreeNode(3); \n    createTree(rootnode); \n int ret = customInorderTraversal(rootnode); \n if(ret == INT_MIN){ \n  cout<<\"\\n Input Btree is not BST \"; \n }else if(ret == INT_MAX){ \n  cout<<\"\\n Empty Tree\"; \n }else{ \n  cout<<\"\\n Input BTree is BST\"; \n } \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5858156613730304","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"31","title":"Input - array of integers size N, integer Threshold.  Output - the number of pairs (x, y) of distinct elements with condition x + y <= Threshold. Is that possible to implement it with O(n) ?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"// perform radix sort - O(n). now the array is sorted \n// now, remove duplicates if you wish. and now perform the following algorithm \nint i(0), j(n-1), ans(0); \nwhile (i < j) \n{ \n       if (a[i] + a[j] <= threshold ) { \n                ans += (j-i+1); \n                i++;  \n       } \n       else { j--; }  \n} \nreturn ans;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"To count the number of pairs in an efficient way, we need to have some ordering on the numbers.  Besides sorting, i think the most efficient way is to use binary search for each number to count the number of other valid integers such that the sum is <= threshold. So, I think O(n log n) is the best we can do."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int getPairs(int[] integers,int threshold){   //n*(n-1)/2   int result=0;   int[] newIntegers=bucketSort(integers,threshold);   int pro=newIntegers[newIntegers.length-1];   int pre=newIntegers[newIntegers.length-1];   if(2*pro<=threshold){return newIntegers.length*(newIntegers.length-1)/2;}   else{   if(newIntegers.length-2<0){return -1;}   pre=newIntegers[newIntegers.length-2];   }    for(int i=newIntegers.length-2;i>0;i--){   if(pro+pre<=threshold){   return result=pre*(pre-1)/2+(pro-pre)*pre;   }   else{   if(pre==pro-1)   pro=pre;   else{   pre=newIntegers[i-1];   }   }    }   return result;    }    public static int[] bucketSort(int[] integers,int threshold){   int[] max=new int[threshold+1];   for(int i=0;i  max[integers[i]]++;   }   int index=0;   for(int j=0;j  while(max[j]>0){   integers[index]=j;   max[j]--;   index++;   }   }   return integers;   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Yes, it can be done in O(n).  First of all, let's sort our array in O(n) time using radix sort. Then, create two pointers i and j pointing to first and last elements of the sorted array. Let's iterate pointer i over our array, shifting pointer j to the left, maintaining  a[i] + a[j] < threshold  and incrementing result by j at each iteration. It is obvious that both pointers will pass entire array only once, so total complexity is still O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think bucket sort is the right approach. N is size of our array, k is the threshold. Now have 6 buckets -  0<=xk Keep adding elements into each bucket.  Total num of distict pairs would be  sizeof(0-k/4 bucket)   * {  sizeof(k/4-k/2 bucket) +  sizeof(k/2-3k/4 bucket) +    sizeof(3k/4-k bucket) }    + sizeof(k/4-k/2bucket)  * sizeof(k/2-3k/4 bucket)  We need to be very careful about the bucket boundaries. And also, obviously this cannot be applied to floats/doubles or non integers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In case sorted array we can get  \n''''''the number of pairs (x, y) of distinct elements with condition x + y <= Threshold'''''' \nin complexity O(n)  \n \nLets say we have a sorted array as follows: \n1--3--3--4--6--7--8--9--12--13--15--17--70 \n \nThreshold is 12 \n \nStart traversing in array from end side with rightIteratorIndex (1 <= 3 <= 3 <= 4----------17 <= 70) \n-Compare array element with Threshold \n-If ArrayElement > Threshold then move to previous element \n-If ArrayElement < Threshold then  \n--Start traversing ArrayElement from left side with another leftIteratorIndex  \n until Array[leftIteratorIndex] + Array [rightIteratorIndex] < Threshold  \n also have a counter initialized to zero and increase counter. \n        in case repeated element as previous move  leftIteratorIndex to one more left without updating counter \n \n--When ever Array[leftIteratorIndex] + Array [rightIteratorIndex] > Threshold found \n move rightIteratorIndex to left ArrayElement ,  \n update counter = counter + leftIteratorIndex \n and start traversing from 'Array[leftIteratorIndex]' for Array[leftIteratorIndex] + Array [rightIteratorIndex] < Threshold  \n for Array[leftIteratorIndex] + Array [rightIteratorIndex] > Threshold again move 'rightIteratorIndex' to left \n repeat above procedure until rightIteratorIndex != 0 \n \n--At last print counter which has been asked in qus."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is possible that for every pair (x, y) in the array has the property of x + y < threshold. Then the output size is of order n^2. Runtime complexity must be no smaller than that for the worse case."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Given an arrray [1,2,3,4,5] and threshold of 200,  you should be printing out all pairs of numbers the array, that will be o(n^2) no matter if the array is sorted or not."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can we use a form of quickselect here? Your pivot is the minimum number in the array, Put all numbers that your pivot value + vi is less then the threshold on the left of the pivot. Once that is done you can print the pairs of your pivot + all the numbers of the left of it. After, repeat the process with the left hand side of your pivot.  Average case O(N)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"QuickSelect should work here. Your pivot is the minimum number in the array, Put all numbers that your pivot value + vi < threshold on the left of the pivot. Once that is done you can print the pairs of your pivot + all the numbers of the left of it. After, repeat the process with the left hand side of your pivot.   Average case O(N) space O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"How could it be O(n) for the arrays with each element greater than a threshold?  For instance int[] a = new int[]{2, 3, 9, .....} and  threshold = 0.  The number of pairs would be equal to n*(n-1)/2.  You'd spend O(n^2) just iterating over the answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Yup. Create a Hashtable.  Say you have the following array ; [4, 1, 5, 2, 3] and threshold = 4  Now, you get 4 and create a Hashtable entry for it <4 , List<0>>.  Now, do the same for the rest :  <4, [0]> <1, [0,1,2,3]> <5, [-1]> <2, [0,1,2]> <3, [0,1]>  Now, iterate again. For 4, you need to get 0. Is zero present in the Hashtable ? Nope.  For 1, you need 0,1,2,3... you have 2 and 3. Display that or add it to the return List.  And continue like that and you will get the answer. Not exactly O(n) but certainly less than O(n2) or O(log(n))."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"my solution  is log(n) in the question they ask for the number of pairs, i did find the pairs though."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6362892580421632","download_status":"DOWNLOAD_DONE","votes":"5","answersCount":"33","title":"you are given n-strings 1you have to find whether a chain can be termed with all the strings given number n? A chain can be formed b/w strings if last char of the 1st string matches with 1st char of second string. For example you are given  number of strings = 3  first string=sdfg  second string=dfgs  third string=ghjhk  they can be concatenated as ->  second first third  dfgs sdfg ghjhk (characters at concatenation points are same)  so concatenated string is-dfgsdfghjhk","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"1) Consider all ending and initial character as vertices of graph.  2)string as edge. 3) Form a directed graph  4) find \"Euler path\"     i) if path found concatenation all string in path.     ii) else no chain possible  eg: 1) a...d 2) q...b 3) n...f 4) a...q 5) f...a 6) d....n  Nodes will be: a b d n f q   Edged will be: 1) a->d 2) q->b 3) n->f 4)a->q 5)f->a 6)d->n  One possible path will be: a->d->n->f->a->q->b  so chain will be: a...d...n...f...a...q...b"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Consider the resultant string to be    S1...E1 S2...  E2  ................ Sn... En where Si is the starting character of String i and Ei is the ending character of String i. Here, E1 must be equal to S2 and E2 must be equal to S3 and En-1 must be equal to Sn. But S1 and En donot have any relation with any other character.  So consider that the Set of starting characters S = {S1, S2, ...., Sn} and the set of ending characters E = {E1, E2, ..... , En}. We need these sets to differ only by at most one element. This element will be the start of the first String and the end of the last string). But for every other value in Set S, other than the value that differs, there must be a corrsponding value in set E. A way to implement this is to have an array of integers with a cell for each character. First, for every character in set S, we increment its position in the array by one. Then for every character in Set E we decrement its place in the array by one. Afterwards if the array is all zeros (every charcater in the set S had a matching character in set E) or if the array consists of zeros except for one cell having value one and one cell having value negative one (in that case only one character differs between set S and set E) then all strings can be adhered together and there's a solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public static boolean chaintermed(String[] strings){    NodePP[] arr=new NodePP[26];    int count=0;   for(int i=0;i  int pre=strings[i].charAt(0)-'a';   int pro=strings[i].charAt(strings[i].length()-1)-'a';   if(arr[pre]==null){    NodePP nPre=new NodePP();   arr[pre]=nPre;   }   if(arr[pro]==null){    NodePP nPro=new NodePP();   arr[pro]=nPro;   }   arr[pre].pre++;   arr[pro].pro++;   }   for(int j=0;j   int pre=arr[strings[j].charAt(0)-'a'].pro;    int pro=arr[strings[j].charAt(strings[j].length()-1)-'a'].pre;    if(((pre==0)&&(pro==0))){return false;}    if((pre!=pro)){    count++;   }   }   return count==2?true:false;   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"#include  \n#include  \nusing namespace std; \n \n \nint main() { \n \nstring in[] ={\"adsd\", \"qasdasdb\", \"ndasdf\", \"aasddq\", \"fasda\", \"deasdn\", \"oooa\"}; \nint n = 7; \nint a[26] ={}; \n \nfor(int i =0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"THis problem can be solved by using topological sorting. We need to build a directed graph, where each node corresponds to either 1st or last char of string.  Assume 1st char of a string is directed to last char of same string, And in the beginning graph does not have any nodes.  Traverse from 1st string.  1. Take 1st string. Build a graph where 1st and last char will represent two nodes, pointing from 1st to last char. 2. Take 2nd string. If 1st char of this string exists in a graph, then add last char of this string as a node in the graph. Else, build one more graph, the way we built in step 1. Here we have two disconnected graphs. 3. Take 3rd string. If 1st char of this string exists in graphs, then check if last char exists. If it exists, then connect these two nodes. Else, add last char of this string as a node in the graph, else build one more disconnected graph.  Say, we have, first string=sdfg  second string=ydfgfx third string=dfgs  fourth string=nertty fifth string=ghjhn   from 1st string = [s]-->[g] (1st graph) from 2nd string = [y]-->[x] (2nd graph) from 3rd string = [d]-->[s]-->g ( Since, 's' is already in 1st graph, connect 3rd string to 1st string) from 4th string = [n]-->[y]-->x ( Since, 'y' is already in 2nd graph, connect 4th string to 2nd string) from 5th string = d-->s-->[g]-->[n]-->y-->x (Since, 1st char 'g' is in 1st graph, and last char 'n' is in 2nd graph, so connect these two graphs)  Now, we can check if there is more than one connected graphs using DFS. A chain can be formed if there is only one graph. In above scenario, a chain can be formed."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi please let me know if the following is failing for any test case:  #include  #include   struct list{     int v;     int indegree;     struct list *next; };  struct Graph{     int V;     struct list **Adj; };  struct Graph *createG(int n){     int i=0,j=0;     struct Graph *G=(struct Graph*)malloc(sizeof(struct Graph));      G->V=n;      G->Adj=(struct list**)malloc(sizeof(struct list*)*n*2);      for(j=0;j        G->Adj[i]=(struct list*)malloc(sizeof(struct list));          G->Adj[i]->v=i;         G->Adj[i]->indegree=0;            G->Adj[i+1]=(struct list*)malloc(sizeof(struct list));         G->Adj[i+1]->v=i+1;          G->Adj[i+1]->indegree=0;            struct list *temp=(struct list*)malloc(sizeof(struct list));         temp->v=i+1;         temp->next=NULL;         G->Adj[i]->next=temp;          struct list *temp2=(struct list*)malloc(sizeof(struct list));         temp2->v=i;         temp2->next=NULL;         G->Adj[i+1]->next=temp2;            i+=2;     }        return G;  }  void createEdge(struct Graph *G,struct list *u,struct list *v){         int p,q;          p=u->v;         q=v->v;          struct list *temp=(struct list*)malloc(sizeof(struct list));         temp->v=q;         temp->next=G->Adj[p]->next;         G->Adj[p]->next=temp;         G->Adj[p]->indegree+=1;          struct list *temp2=(struct list*)malloc(sizeof(struct list));         temp2->v=p;         temp2->next=G->Adj[q]->next;         G->Adj[q]->next=temp2;         G->Adj[q]->indegree+=1;          return;        }      struct list_t{         char key;         struct list *val;         struct list_t *next;     };   struct hash_table{     int size;     struct list_t **table; };  struct hash_table *createH(int size){     int i;     struct hash_table *t=(struct hash_table*)malloc(sizeof(struct hash_table));      t->size=size;      t->table=(struct list_t**)malloc(sizeof(struct list_t)*size);      for(i=0;i        t->table[i]=NULL;      return t; }   int hash(struct hash_table *t,char key){     unsigned int hashval=0;      hashval=((int)key)<<5 -(int)key;      return hashval%t->size;  }   struct node{     struct list *v;     struct node *next;  };  void Insert(struct node **head,struct list *v){     struct node *temp=(struct node*)malloc(sizeof(struct node));      temp->v=v;      temp->next=*head;     *head=temp;  }   struct list *lookupH(struct hash_table *t,char key){      int hashval=hash(t,key);      struct list_t *list_val=NULL;      struct node *head=NULL;      for(list_val=t->table[hashval];list_val;list_val=list_val->next){         if(list_val->key==key)             Insert(&head,list_val->val);     }      return head; }  void InsertH(struct hash_table *t,char key,struct list *val){       int hashval=hash(t,key);      struct list_t *list_val=(struct list_t*)malloc(sizeof(struct list_t));      list_val->key=key;     list_val->val=val;      list_val->next=t->table[hashval];      t->table[hashval]=list_val;   }   int main() {      int i,j=0,n;     printf(\"Enter # of strings\\n\");      scanf(\"%d\",&n);      char **A=(char**)malloc(sizeof(char*)*n);      for(i=0;i        printf(\"Enter string # %d\\n\",i+1);         A[i]=(char*)malloc(sizeof(char)*20);         scanf(\"%s\",A[i]);     }      struct Graph *G=createG(n);       struct hash_table *t1=createH(n);     struct hash_table *t2=createH(n);      j=0;        for(i=0;i        int len=strlen(A[i]);          InsertH(t1,*(A[i]),G->Adj[j]);          struct node *head=lookupH(t2,*(A[i]));          while(head){             createEdge(G,G->Adj[j],head->v);             head=head->next;         }           InsertH(t2,*(A[i]+len-1),G->Adj[j+1]);           head=lookupH(t1,*(A[i]+len-1));           while(head){             createEdge(G,G->Adj[j+1],head->v);             head=head->next;         }            j+=2;      }      j=0;     int count1=0,count2=0;       for(i=0;i        if(G->Adj[j]->indegree==0)             count1++;         if(G->Adj[j+1]->indegree==0)             count2++;         j+=2;     }        if(count1>1 || count2>1)         printf(\"NO\");     else         printf(\"YES\");      return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Consider the resultant string to be S1...E1 S2... E2 ................ Sn... En where Si is the starting character of String i and Ei is the ending character of String i. Here, E1 must be equal to S2 and E2 must be equal to S3 and En-1 must be equal to Sn. But S1 and En donot have any relation with any other character. So consider that the Set of starting characters S = {S1, S2, ...., Sn} and the set of ending characters E = {E1, E2, ..... , En}. We need these sets to differ only by at most one element. This element will be the start of the first String and the end of the last string). But for every other value in Set S, other than the value that differs, there must be a corrsponding value in set E. A way to implement this is to have an array of integers with a cell for each character. First, for every character in set S, we increment its position in the array by one. Then for every character in Set E we decrement its place in the array by one. Afterwards if the array is all zeros (every charcater in the set S had a matching character in set E) or if the array consists of zeros except for one cell having value one and one cell having value negative one (in that case only one character differs between set S and set E) then all strings can be adhered together and there's a solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can I use bucket sort? Create 1 array each with 26 entries. All strings will first character a in the 0th entry, b in 1st entry and so on. It takes O(n) to create such an array. Now we traverse the array once, pop the just word we encounter in the array, read its last character, pop the first string with that character in corresponding entry of the array. Keep doing it until there are no more string in the array. This procedure also takes O(n) times. Total run time is O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can also use a hash table:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here is my solution which (I believe) works correctly and also prints the sequence"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"in C++ code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The basic idea is keep two list, src and dest. - when you need to check whether to put current Scr in srcList, check if previous any one of destinations is same as that of curSrc then remove that from destList and don't put current scr into srcList. - Similarly for current dest.   At the end you should have only one source."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In the perfect case the posed problem would be resolved with a graph and searching for Hamiltonian path, which is NP-complete, so I avoided graph and did a brute-force solution: build all combinations of strings recursively and return false if it fails to build the combination at any level, here's working code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can we create an array of 26 length?  Initialize all elements to null.  Then iterate through each string, setting the array as follows: first look at string[0].  Compare to string[len(string)-1].  They can be equal or not equal. 1.  If equal: set array[f(string[0])]=MAXINT but only if array[f(string[0])]==NULL, otherwise skip this string.    f(X)=numeric place of X in the alphabet e.g.A=1,B=2, etc.  2.  If not equal:   a. If array[f(string[0])==NULL or MAXINT, set it to 1.  b. Otherwise, increment it.  c. Perform same test on array[f(string[len(string)-1])] but decrement instead of increment. When we are done we iterate through the 26-element array.   -If we see any element with value >1 or <-1, return false.   -Else if we count more than one element with 1 or -1, also return false. -Else return true. This should be O(N) complexity, no?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"To solve this problem, you need to know SCC(strongly connected components) at first. Just build the directed graph as many guys said before, then combinate every circles(SCC) into a node one by one, then check whether the final graph is a single link. Time: O(N) Space: O(N)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Form a Bipartite graph having the starting characters of the strings in one group and ending characters in the other group. Create two hash maps one will contain starting characters and other will contain ending characters. while inserting a starting character or ending character of a string in the hashmap check whether the character is already in the other hashmap. If yes then connect an edge between the corresponding nodes in the Graph. In the graph each source node is connected to its corresponding end node. Now if the graph contains more than one node with in degree 0 then Its NOT POSSIBLE to form the chain. If the graph contains only one node with in degree 0 and if it has only one component then its possible to form a chain."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"1. Create directed graph from strings. dfgs -> sdfg -> ghjhk This graph could be complex with cycles. 2. Check if directed graph has Euler path/cycle.  2.1. A directed graph has an eulerian circuit if and only if it is connected and each vertex has the same in-degree as out-degree. 2.2. A directed graph has an eulerian path if and only if it is connected and each vertex except 2 have the same in-degree as out-degree, and one of those 2 vertices has out-degree with one greater than in-degree (this is the start vertex), and the other vertex has  in-degree with one greater than out-degree (this is the end vertex)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"public static boolean canChain(String[] strs) {     HashMap map = new HashMap();     for (int i = 0; i < strs.length; i++) {       if (strs[i].length() < 2 || strs[i].charAt(0) == strs[i].charAt(strs[i]         .length() - 1))         continue;       if (map.containsKey(strs[i].charAt(0))) {         map.remove(strs[i].charAt(0));       } else {         map.put(strs[i].charAt(0), i);       }       if (map.containsKey(strs[i].charAt(strs[i].length() - 1))) {         map.remove(strs[i].charAt(strs[i].length() - 1));       } else {         map.put(strs[i].charAt(strs[i].length() - 1), i);       }     }      if (map.size() == 0 || map.size() == 2)       return true;     return false;   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"In this program i am populating map and array of strings manually. And considering all N no of strings are unique.   public class Chain {           public static void main(String a[])     {    Map map=new HashMap();  map.put(\"a\",\"abc\");  map.put(\"d\",\"def\");  map.put(\"c\",\"cod\");  map.put(\"g\",\"geb\");  map.put(\"b\",\"bea\");    String[] arr=new String[5];  arr[0]=\"abc\";  arr[1]=\"def\";  arr[2]=\"cod\";  arr[3]=\"geb\";  arr[4]=\"bea\";    int i=0;  String temp;  int count=0;  while((arr.length)!=i)  {      StringBuilder sb=new StringBuilder();     temp=arr[i];     sb.append(temp);     count=0;      while(true)      {   if(map.get(temp.substring(temp.length()-1))!=null)   {       temp=map.get(temp.substring(temp.length()-1));       sb.append(temp);       count++;   }   else   {       if(count!=(arr.length-1))       {    break;       }       else       {    System.out.println(\"Chain Found: \"+sb.toString());    break;       }   }      }            if(count==(arr.length-1))      {   break;      }      i++;            if((arr.length)==i)      {   System.out.println(\"Chain not Found\");      }  }       } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"public boolean isChain(ArrayList p_list){ \n        int index; \n        index = 0; \n        String firstword,secondword; \n         \n        while(index < (p_list.size()-1)){ \n            firstword = p_list.get(index); \n            secondword = p_list.get(index+1); \n            if( (firstword.charAt(firstword.length()-1)) != \n                    secondword.charAt(0)){ \n                return false; \n            } \n            index++; \n             \n        } \n         \n        \n        return true; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"1. First make permutation of three string. 2. Before concatenation check last char of first is same as first char of second. 3. Make 2nd step for all three string(In this case we have three String.) 4. Return appropriate concatenated string if satisfying step 2."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"It seems to me like that giving the full concatenated String is not necessary. What is needed is to answer if a chain is possible given a list of Strings.  Methodology: Iterate over words and store the first and the last chars in two maps Map If the two maps have the same first and last chars count then they can match.  Note that we can tolerate up to 1 difference. (The first/last char of the final String is not connected with any).  Code:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5667482614366208","download_status":"DOWNLOAD_DONE","votes":"-4","answersCount":"22","title":"Rotate a M*N matrix by 90 degree.  Is this answer right?   public void rotateMN(int[][] input){   int i = input.length;  int j = input[0].length;   int m = j;  int n = i;   int[][] newArray = new int[m][n];   for(int j = input[0].length-1, m=0; ;i--, m++ ){  for(int i = input.length-1, n=0; i >= 0 ; i--, n++){   newArray[m][n] = input[i][j];   }  }   }    Will this also work for N*N matrix rotation by 90 degrees?   The time complexity is O(N) since it just traverse the input matrix and copy it to the new matrix. The space complexity is (MN) + (MN) = So MN.   Is it possible to do rotation for M * N matrix in space? If so please provide that answer  Whats this space and time complexity?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"90 degree clockwise rotation of n*m array means  row i of input array should copy to column n-1-i output array and column j of input array should copy to row j of output array"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"// If we rotate the Matrix of nxm by 90* then it will become matrix of mxn \n// We will have to create a new 2-D array , like this rot_arr [row][col] \n \nvoid rotate(int row int col, int arr[][row],int rot_arr[][col]) \n{ \n for(int j = 1; j < row; j++) \n { \n  for (int i = m-1 , k = 0; i >= 0, k < m; i--, k++) \n  { \n   arr_rot[j][k] = arr[j][i]; \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is this answer right?     public void rotateMN(int[][] input){                          int i = input.length;                      int j = input[0].length;                                  int m = j;                    int n = i;                                  int[][] newArray = new int[m][n];                               for(int j = input[0].length-1, m=0;   ;i--, m++ ){                   for(int i = input.length-1, n=0; i >= 0 ; i--, n++){                                             newArray[m][n] = input[i][j];                                   }               }                         }   Will this also work for N*N matrix rotation by 90 degrees?   The time complexity is O(N) since it just traverse the input matrix and copy it to the new matrix. The space complexity is (MN) + (MN) = So MN.   Is it possible to do rotation for M * N matrix in space?  If so please provide that answer Whats this space and time complexity?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"rotate( int *p, int M, int N){ \nfor (i=0; i < M*N; i ++) { \n k =  ( (i*M)+M-1)   %   ((M*N)+1) ; \n printf(\"%d \", p[k]) ; \n if( i % M == 0)  \n printf(\"\\n\"); \n} \n \nThe index into the array(i) is converted into another index into the new array (k) \nusing a mapping."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nusing namespace std; \nclass Matrix{ \n int *mat; \n int row,column; \n    public: \n void readMatrix(); \n void rotateMatrix90DegClockWise(); \n void transposeMatrix(); \n void displayMatrix(); \n void interchangeColumns(); \n}; \n \nvoid Matrix::readMatrix(){ \n    cout<<\"Enter the row size : \"; \n    cin>>row; \n    cout<<\"Enter the column size : \"; \n    cin>>column; \n    mat = new int[row*column]; \n \n    for(int i = 0;i>*(mat+i*column+j); \n    } \n} \n \n \nvoid Matrix::displayMatrix(){ \n    for(int i = 0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#define M 6 \n#define N 7 \n \nint Arr[M*N]; \n \nint main(){ \n        int i,k; \n \n        for(i =0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Below is the efficient code of doing it, Time : O(n2) Space: O(1) Inplace.  complete implementation and logic can be found at : ms-amazon.blogspot.in/2013/05/rotate-matrix-90-degrees-clockwise.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Depending on how you represent your matrices, you can do rotations in O(1) time with O(1) additional space. Further, matrices that you have rotated (and transformed in other ways) can share a single underlying element array with the original. The idea is to think of rotating a matrix not as a rearrangement of elements but as a transformation of coordinates, which can be done in constant time. I give a sample implementation (in Python) in my practice repo on GitHub:  github.com/tmoertel/practice/blob/master/careercup/rot_matrix_90.py  Cheers, Tom"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// no extra memory and less # of swaps compared to other method \nvoid rotate(vector< vector >& a, int n) \n{ \nfor (cn=n, i=0; cn>=2 ; cn-=2; i++) \n{ \nint j = cn-1; \nfor (step=0; step < cn-1; step++) \n{ \nrotate_ele(a[i][i+step], a[i+step][j], a[i+cn-1][j-step], a[i+cn-1-step][i]); \n} \n} \n} \nvoid rotate_ele(int &a, int& b, int& c, int& d) \n{ \nint temp = a; \na = d; \nd = c; \nc = b; \nb = temp; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If your Matrix is Square Matrix then follow this answer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int findHighestBetter(int[] array,int left,int right) {   int mid=(left+right)/2;      if(array[mid] > array[mid+1]) {    return array[mid];   } else if(array[mid] > array[mid-1]) {    left=mid+1;   } else {    right=mid;   }      return findHighestBetter(array, left, right);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"this line  int[][] newArray = new int[m][n];   is not correct.  if m==n, then in-place is possible, just like how you take off cloth, one layer at a time, lol."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4620408242307072","download_status":"DOWNLOAD_DONE","votes":"-4","answersCount":"5","title":"In what situations bubble sort, selection sort, insertion sort, merge sort, quick sort and heap sort will have best time complexity. Provide example for each sort and explain","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"11","title":"Selection Sort : Best Worst Average Case running time all O(n^2). However the number of swaps required is always n-1. Hence it is useful when the amount of satellite data(auxiliary data aside from the key) is large and for some reason pointer based swapping is not feasible.   Insertion Sort : Best case running time is O(n). Hence useful for adding new data to a presorted list. Also this is fast when the number of elements is small/ you need an online algorithm.  Bubble Sort:Where we know the data is very nearly sorted. Say only two elements are out of place. Then in one pass, BS will finish it and in the second pass, it will see everything is sorted and then exit. Only takes 2 passes of the array.   Merge Sort : For external sorting algorithms, it is the choice of sort.   Quicksort : Remember that quicksort is dependent on choice of pivot. So when we have absolutely random data values, and we will need to sort them, we have to use quick sort. Even for very unbalanced split QS produces good results.   Heap Sort: It is an inplace O(n logn) algorithm hence we can use it when we cannot afford the extra space required for merge sort. Also has a O(n logn) worst case time as compared to O(n^2) of quicksort."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is it really a Google question?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Quick sort: When you don't need a stable sort and average case performance matters more than worst case performance. A quick sort is O(N log N) on average, O(N^2) in the worst case. A good implementation uses O(log N) auxiliary storage in the form of stack space for recursion.  Merge sort: When you need a stable, O(N log N) sort, this is about your only option. The only downsides to it are that it uses O(N) auxiliary space and has a slightly larger constant than a quick sort. There are some in-place merge sorts, but AFAIK they are all either not stable or worse than O(N log N). Even the O(N log N) in place sorts have so much larger a constant than the plain old merge sort that they're more theoretical curiosities than useful algorithms.  Heap sort: When you don't need a stable sort and you care more about worst case performance than average case performance. It's guaranteed to be O(N log N), and uses O(1) auxiliary space, meaning that you won't unexpectedly run out of heap or stack space on very large inputs.  Insertion sort: When N is guaranteed to be small, including as the base case of a quick sort or merge sort. While this is O(N^2), it has a very small constant and is a stable sort.  Bubble sort, selection sort: When you're doing something quick and dirty and for some reason you can't just use the standard library's sorting algorithm. The only advantage these have over insertion sort is being slightly easier to implement."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4841145939001344","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"21","title":"1000 elements in one bag and 1 million elements in another. how do you find common elements among them. Also give the complexity of your solution.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"16","title":"First put all the 1000 elements in an hash table. Then take each of the one million elements and look for them in the hash table. If match is found report them as a solution.   Also works if you don't have enough memory to bring all the 1mil elements. Then just drag a chunk to disk, check and then drag the next chunk.   Space Complexity  : O(m) Time Complexity : O(n)  m size of smaller bag n: size of larger bag"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Doesn't it depend on what kind of a data structure is used to store the million elements, so accordingly the search could be carried out?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think could be   1?? mlogm+nlogm  2)  nlogn+mlogn  3)  nlogn+mlogm+m+n"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Bloom filters?! (False positive matches are be possible, but there is no false negative);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. We could use bloom filters for the first bag of elements (1000 elements). Since the number of elements is small it is easy to use bloom filters in this case. For all the elements in Bag2 pass these elements through bloom filter, if they are already set then print the solution that the element is identicaly. In bloom filter if a number is not present => the index of that element will never be set. So bloom filters could be used here.  2, If the range of numbers(in bag1) is known and is very small, we could as well use a BitSet and set the corresponding bit in bitset for all the 1000 elements. In second pass we could use see for each element if a bit is already set in the bitset, if Yes then we print that the element is identical. advantage of bitset is it is much more memory efficient."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"If hashing is not universal (i.e. collisions are possible), then sort m (=1000) and sort n(=1M) and do compare merge sort way. Complexity  O(m log m + n log n + m +n ) = O(m log m +n log n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-5","title":"Construct a bloom filter with the large array (Use a bit vector for storing the large array). Then search the smaller array in the bloom filter by hashing its value. The problem with this approach though is that you can get false positives with bloom filter unless you choose multiple  hash functions and larger input array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-5","title":"create 2 array lists. ArrayList a1 =new Arraylist(); //add100 elements to this array ArrayList a2 =new Arraylist(); //add1 million elements to this array  a2.retainAll(a1);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-5","title":"What do you mean by bloom filter. Could you elaborate more on your answer"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6285749599076352","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"14","title":"Write a class DominoChecker that has a method called addBox(int[]) that takes a box of five dominoes, described as a list of 10 integers (explained after), adds it to a collection, and returns true if a box with the same dominoes was already in the collection and false otherwise. A box of dominoes is encoded as a list of 10 integers from 0 to 9, where a pair of numbers represent a domino. For example: 0,2,9,1,3,3,7,4,5,6 represents a box containing dominoes: (0,2); (9,1); (3,3); (7,4); (5,6).  http://en.wikipedia.org/wiki/Dominoes for more basic info (like pictures)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"The current solutions given here are too complex. You can do something simpler and smarter.  Note that we're given 10 integers, each from 0 to 9. If we concatenate the 10 numbers we'll get at most 9,999,999,999 which fits in a 64 bit integer. Also note that having dominoes (0,2) and (2,0) is the same, as having boxes [(0,2); (9,1); (3,3); (7,4); (5,6)] or [(0,2); (3,3); (5,6); (7,4); (9,1)] is also the same, the order does not matter."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"FUCK. FUCK. FUCK.  I AM TIRED OF PPL JUST POSTING CODE WITHOUT AN EXPLANATION.  ok?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have done the code almost as below. I just explained about the overriding the hashcode method but not coded. Don't know what will be the result :-( Could any one explain how to override the hashcode & compare the contents of Box object in Java?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a solution in CPP. I tested the code and I think it works. The main takeaway of this problem was that the interviewer wanted to see if you understod strict weak ordering and comparator function overloading or not."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java Implementation of DominoChecker...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This solution is pretty simple. It runs in O(n). We create two objects - Domino and DominoBox each of which override hashCode. We use the hashCode of the DominoBox as a key in a Map. Once we have the key we can easily tell if the DominoBox already exists in our vast collection of DominoBoxs."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The simplest solution is use Hash, Convert given box into String of 10. Sort each box so that you will get small number first and then bigger number. Then sort whole set of boxes based on 1st number and then create output string by concatenating all box. if this is already present in hash then return false or else put that in hash and return true."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4786604149309440","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"Given 2 quad-trees find the intersection of black-pixels.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Assumption: While a pairwise intersection of corresponding pixels in the two images....Intersection is white iff both pixels of the pair are white.  Then you can do the recursive intersection as follows: let A and B be to corresponding nodes in the two trees (or their subtrees)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Could you describe this question more specifically."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is a continuation of the previous question. Define a quad-tree for a black and white image. Count the number the of black pixels."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6491225129484288","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"Define a quad-tree for a black and white image. Count the number the of black pixels.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Consider that edge nodes are either black or white in Q tree. If your node edge is at depth d, it corresponds to S/2^(2d) pixels, when S is total number of pixels in image, So you can traverse through tree and find total black pixels"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Could you provide any solution with code please?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A quad tree can have only 3 color of nodes .. black white and gray  The crux is that at each level(depth) if the pixel color is not gray then it represents 4^(k-d) pixels of color same as itself. where k represents the overall size of image of size (2^k X 2^k) and d represents the current depth of node in the tree  Assuming each node has color field: \"black\"/\"white\"/\"gray\" and 4 field for the 4 child nodes of type node: ne , nw, se, sw  Code in Python:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4681660918398976","download_status":"DOWNLOAD_DONE","votes":"12","answersCount":"51","title":"Given a large network of computers, each keeping log files of visited urls, find the top ten of the most visited urls. (i.e. have many large  int (visits)> maps, calculate implicitly  int (sum of visits among all distributed maps), and get the top ten in the combined map)  The result list must be exact, and the maps are too large to transmit over the network (especially sending all of them to a central server or using MapReduce directly, is not allowed)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"11","title":"Presuming a protocol exists that can ask three questions to each server:  * the score of a single url * the top 10 * the top n that satisfy score >= N  We program a two pass solution like so:  We denote the number of servers as S.  [First pass] (1) Ask every server for its own top ten  (2) merge the results. For all URLs in the merged set calculate correct values by asking all servers for their scores for each URL. Calculate a set of top ten from our sample.  (3) pick score of the now tenth URL as the threshold that we try to beat in the second round. We denote the threshold as T.  [Second pass] (4) Ask every server for all its top N that satisfy score >= T/S  (5) Merge these bigger samples again as in step (2)  (6) We now have the correct top ten with correct scores."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"10","title":"The constraints puzzle me a bit, especially the \"using MapReduce directly, is not allowed\" one. I would try to discuss what that means exactly in an interview. I'll give another shot at the question:  Denote N as the number of computers in our network.  1) Pick a good string hash function. This function must take urls as input and produce hash values uniformly in the range [0, MAX_HASH_VALUE]   2) Divide the hash range [0, MAX_HASH_VALUE] into N intervals with equal length MAX_HASH_VALUE / N, and assign each interval to 1 computer in the network, e.g. CPU_1) [0, length-1] CPU_2) [length, 2*length-1] CPU_3) [2*length, 3*length-1] ... CPU_N) [(N-1)*length, MAX_HASH_VALUE]  3) Each computer computes the hash values of its list of urls and sends the url and its visited information to the computer responsible by the hash of that url.  4) Each computer received a list of information url->visits for the urls in its hash interval. Now it must combine the visits of the urls and produce its top 10.  5) Each computer sends its top 10 to a central computer. This central computer will receive 10*N urls and compute the overall top 10.  Due to our good hash function, we expect that each computer will receive roughly the same amount of urls to process in the 4th step. I think this approach is the best we can do to distribute the work among the cluster.  About the constraints, they're not very clear.  a) This is sending all urls over the network but not to a single computer. In order to produce an exact result, I think all approaches end up sending all urls over the network in the worst case. Again, we would need to discuss with the interviewer if this is ok (the \"especially sending all of them to a central server\" part).  b) This is similar to MapReduce. I think that by saying \"using MapReduce directly is not allowed\", the interviewer meant that we have to give a detailed explanation about how the work is distributed among the network of computers, instead of just saying \"the MapReduce framework will distribute and combine the work for us\"."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"I don't think any of the suggested solutions are right. It is possible to imagine a situation where some url is ranked number 11 on every box, and so has very high visits overall, while every url in the top 10 on each individual box is seen nowhere else, so has low visits overall.  That said, I don't have any better ideas. This problem is hard!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I understand that with the given constraints it is not possible to get a trivial solution. but i thik we have to consider the senario where one url in the actual 10 top urls is visited by most of the machines but only a few times that will keep it out of the individual top 10 lists of each machine.  does that sound right?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You could possibly continually request the top urls until you have ten where the smallest value in the top10 list is not more then the highest value in any server using paginated sets. For example,:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would recursively group the servers into sets of two and aggregate the URL's . Suppose there are 6 servers. a) Group s1s2, s3s4, s5s6. b) We know the entire map cannot be transmitted. Find out a safe message size for the network. Supposing n. Break the map in s1 into n size chunks and send over to s2. Similarly from s3-s4, s5-s6. c) This is the tricky part. The ques says we cannot do map-reduce directly. Does that mean map-reduce on the entire set? Is it allowed for individual machines? But it will be silly to solve this without ever getting a count of the URLs. So if map reduce is not allowed, write a procedure to sort the urls and track each one's count. This is done in s2, s4 and s6. d) Now, again group the machines. This time {s2s4}, {s6}. e) Repeat b, c . We will have s4, s6 left. Transmit from s4-s6 and perform a final count."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Lets assume, we can store count of k urls in the central machine. If the corpus is of size n, we get the top n/k elems from each server and send it to our central machine.   So, in our central machine, we have a set of k counters each initialized to 0 to start with. As we get our data from the stream, for every url, if it exists, we increment the counter. If not:  case1: if there is size in our central machine to add the url, we add it and set its count  case 2: if not, we delete the count of every url we have in the central machine. If there is any    url that has a count of 0, we delete it.   Now, the moment we hit case 2 above, we record the max_count_so_far and take a snapshot of the top 10 elements.   We process the next set of top n/k elements from the machines and for every max_count_so_far elements we take a snapshot of the top 10 elements.  At some point, say after we have 10 such snapshots, we find the final top 10 elements from the snapshots we have so far"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"On each server, we sort the urls based on their frequencies.   Say total log file lines across all servers are N.   Number of servers is s.  Capacity of server is k. Now split the ranked urls such that there are k/s elems per group on each server. Label each group , there will be total N/(k/s) ids.   Now, from this set of ids, we randomly select s ids (i.e s groups) such that each id doesnt occur more than threshold times on one machine. (To keep it simple lets say threshold=1).   Now, we employ the following algorithm on the central machine: If there is size in our central machine to add the new group, we add it and set the count of each of the elems in the group.  If not, we delete the count of every group/element in the group. We delete all urls that have a count of 0.   Now, one might argue that we might endup spending too much time on low frequency entries. We could then employ multiple iterations of elimination here.  In the first pass, we can only consider frequencies that are above  a certain threshold: say frequency above the median of the frequencies in each server. And divide those set of urls into groups. And consider random group from each server."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"have a centralized counter. every time a new hit is recorded, recalc the centralized counter for that url with properly synced data structure. then compare it with the top10 hit stack by popping out the ones smaller than the current count result. keep updating the top 10 stack every time the new hit is recorded and you can always query the top 10 stack for the top 10 hits."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Lets say the number of servers is N. I think the solution requires 10 passes among the top ten scorers of each server. In each pass you can only identify one in the top ten. After each pass, the selected URL from the previous pass must be excluded from the evaluation in the subsequent passes, and the top ten scores from each server must be updated.  Think of the first pass. When all the top ten lists are considered, there must be at least one URL among these top tens which will land into the \"real\" top ten list. It is possible to generate scenarios where 9 of the real top ten list do not appear in the \"current\" top ten lists. But, there has to be at least one URL in the real top ten list which also appears in the 10N URLs that are collected from the servers' current top ten lists. Note that this is true only when N>=10. If N<10, all the real top ten list may not appear in the 10N URLs.  Also note that after collecting the 10N URLs, for some of them, you will have to ask the servers their frequencies so that you can sort the 10N URLs properly. Because, you want to sort the sum of visit frequencies of these URLs at each server.   After 10 such passes the real top ten list will emerge. The messaging complexity of each pass could be as bad as N^2 since you may have to collect the frequency values for each one of the 10N URLs. But, the computational complexity of each step is O(N) since you only need to find the max of 10N URLs.  If we were to design an algorithm that can find out not just 10 but the top K list. Then, we would be have to collect the top N scorers from each server .So, rather than 10N, we would bring together the top N^2 list at each pass. If K>N, this design is preferable."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the logic is similar to tetris game algorithm. Or generalize voting algorithm."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We partition the work by using a hash on the url. The hash gives an address to an aggregator who is responsible counting a subset (as defined by the hash) of urls. Then we crawl through the aggregators and fill the top-ten list. As each url is mapped to exactly one aggregator the crawler only has to maintain a map with ten entries.   Step 1) send table with aggregator addresses: say we use 10k aggregators Step 2) on individual machine count all urls Step 3) on individual machine iterate through counted urls, find hash-key, modulo 10k gives you the address of responsible aggregator -> send to aggregator the count of said url. Step 4) aggregators accumulate the counts Step 5) initialize empty top-ten list, iterate through 10k aggregator machines  and maintain the top-ten list"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"The easy solution to solve this kind of problem is MapReduce. Since MapReduce is not allowed, the other alternative is to sort the string (url) ==> int (visits) in each machine independently such that it is the increasing order of visits. Then each server can send their top 10 visited URLs, Visit mapping to one of the server.  This single server would receive data from all the others for the top 10 visited sites and do a merge to decide on the top 10 sites. ( A n-way merge sort of the URL vs visits)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"edit: this is does not guarantee 100% correctness  The question says we can't use MapReduce directly because the amount of data is too large. However, the overall top 10 sites are *expected* to be in the top 10 of at least one of the computers.  Hence, we can sort the logs of each computer and emit the top 10 of each computer in the mapping phase. Then, the reduce phase aggregates the number of visits for each site. The result will be the top 10 of the aggregate."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"What if we manage a MaxHeap of top 10 sites at each node separately, and a heap of size 10 in central unit. The central heap can be updated according to :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"We could use a BFS, visit every node and add sum of the integers to the master map that has all the URL's checking, if the URL is already present, then just add the  integer orelse create a new key and put it into the map. Then traverse through the map to find the top ten values or just sort descending and return the first 10 values."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"There are N number of machines,  Determine top 10 in every machine. Each machine transmits its top 10 to every other machine i.e (n-1)10 urls This Implies each machine also recieves (n-1)10 urls  Process these and determine the top 10 in every machine.  Each machine now sends its Top 10 to a single place,(n*10) The top 10 among these (n*10) will be the most visited URL's  I do not know if there is any way to avoid not replicating the data on each machine. But will N*(N-1)*10 url's be too much traffic for the network to handle, cos that will be the total number of replications required.  Other possible solutions I could think of was using P-S pattern to publish count of URL's periodically."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"1. tag the nodes as n1, n2, n3..... nk 2. First n1 sorts its list of URLs to find top10 3. n1 sends this list to n2. n2 adds this list to the data set, and gets a top 10 4. now n2 sends its top10  (calculated in step 3) to n3 5. keep doing it till we reach nk  nk will have the cumulative top 10"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6193979032862720","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"14","title":"Having an infinite stream of numbers write a function to take an element with equal probability for each.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Check Reservoir Sampling on wiki please. In this case k = 1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"simulate an array shuffle, with a virtual array(only save the length, and the 1st element). When we scan to index n, the 1st element of the virtual array, would be any number in x0...xn with probability 1/n  the shuffle function works like,  when scan to xi, there are i+1 choices to insert it to the virtual array.   randomInt(i+1) if random number is 0,  replace the 1st element.  else do nothing."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The reference to \"an infinite stream of ...\" implies that we cannot simply consider a uniform distribution as in the case of discrete random variables. In other words, we cannot assume 1/n as the probability assigned to each element. One thing we can do, however, is to check if the lower and the upper bound of these numbers are available. Then, we can use something like:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Divide the streams into partitions and each partition contains set of numbers. \nNow, genRand() to the pick the partition and once the partition is picked, then again do genRand() now to pick the number.  \nNow, the prob (number) = 1/(n^2) . \n \nWe can even extend to more complex (distributed). \n1. genRand() to pick a node \n2. Each node has many partitions and now genRand() to pick a partition within a node \n3. Now, once the partition is pick , genRand() to pick the number, \nIn this, prob(num) = 1/(SPN) where S = # of nodes , P = # of partitions with each node (assume same for all nodes) and N = # of elements in each partitions."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Divide the streams into partitions and each partition contains set of numbers. Now, genRand() to the pick the partition and once the partition is picked, then again do genRand() now to pick the number.  Now, the prob (number) = 1/(n^2) .  We can even extend to more complex (distributed). 1. genRand() to pick a node 2. Each node has many partitions and now genRand() to pick a partition within a node 3. Now, once the partition is pick , genRand() to pick the number, In this, prob(num) = 1/(SPN) where S = # of nodes , P = # of partitions with each node (assume same for all nodes) and N = # of elements in each partitions."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Could your provide some code please?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int GetRandom() \n        { \n            var list = new List { 5, 8, 9, 10, 12, 15, 20 }; \n            var currentLocation = 0; \n            var randomNo = list[0]; \n \n            //We don't count the list so it is as good an infinite stream \n            foreach (var item in list) \n            { \n                currentLocation += 1;  \n                if (currentLocation == 1) continue; \n                //Return a no between 1 and the last item in the list. The probability for the new no to be picked get's less and less  \n                //as we go through the list and all no has equal chance. \n                int newRandomLocation = new Random().Next(currentLocation) + 1;                    \n                randomNo = newRandomLocation == currentLocation ? item : randomNo; \n            } \n \n            return randomNo; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming that input is in form of an infinite array A. Generate a random floating point number y between 0 and 1. Let x = 1/y. return A[x-1]."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is reservoir sampling where k == 0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"_//en.wikipedia.org/wiki/Reservoir_sampling"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"_//en.wikipedia.org/wiki/Reservoir_sampling"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"_//en.wikipedia.org/wiki/Reservoir_sampling"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"_//en.wikipedia.org/wiki/Reservoir_sampling"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5365325222641664","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"0","title":"Given a class of block reader, read in unlimited string flow."}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4807138387951616","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"18","title":"You are given a grid, with points on the intersections (think a map of streets, people are standing on random corners). Write code to calculate the point on the grid that is the shortest distance from every point on the grid.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"What is your distance metric ?  euclidean or manhattan ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"As I understand the task, the result must be one or more of the given points on the grid and not any extra point somewhere in between. In my opinion, this is backed by the hint that one should imagine a map of streets.  Given this interpretation is correct, the task is just to sum up all distances that would have to be gone if all people would come together at any of the given points. The distance between two points on a grid is trivial to calculate, just the distance on the x asis plus the distance on the y axis, no graph theory required. The sum must be computed for every point, so the runtime complexity is O(N^2).  Here is my solution written in go. It contains 6 examples that can be verified with a bit of common sense by drawing the points on a grid."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is the center of gravity of these points. It is also known as Weber point, Fermat point, or Fermat-Torricelli point. in general it is : 1/n Sum_{1<= i <= n} w_i p_i  where w_i are the weights associated to each of points p_i on the grid. If several of such points are desirable, then we can use K-clustering algorithm to divide the input points into a number of clusters whose distances to the center of their corresponding cluster is minimized."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class FindMeetingPoint { \n \n static class Point{ \n  double x, y; \n  Point(double x, double y){ \n   this.x = x; \n   this.y = y; \n  } \n  @Override \n  public String toString() { \n   return \"Point [x=\" + x + \", y=\" + y + \"]\"; \n  } \n } \n  \n public static double findPoint(Point points[]){ \n  // Calculate the average point \n  double avgX = 0.0; \n  double avgY = 0.0; \n  for (int index = 0; index < points.length; index++) { \n   avgX += points[index].x; \n   avgY += points[index].y; \n  } \n  avgX = avgX/points.length; \n  avgY = avgY/points.length; \n   \n  // Calculate the distance average point to particular point    \n  int avgPoint = 0; \n  double pointsdiff = Math.sqrt(Math.pow(avgX - points[0].x, 2) + Math.pow(avgY - points[0].y, 2)); \n  for (int index = 1; index < points.length; index++) { \n   double tempdiff = Math.sqrt(Math.pow(avgX - points[index].x, 2) + Math.pow(avgY - points[index].y, 2)); \n   if (pointsdiff > tempdiff) { \n    pointsdiff = tempdiff; \n    avgPoint = index; \n   } \n  } \n  System.out.println(\"Meeting point is: \"+ points[avgPoint]); \n   \n  double totalDistance = 0; \n  for (int index = 0; index < points.length; index++) { \n   double sumx = Math.abs(points[index].x - points[avgPoint].x); \n   double sumy = Math.abs(points[index].y - points[avgPoint].y); \n   totalDistance += Math.max(sumx, sumy); \n  } \n  return totalDistance; \n }  \n  \n public static void main(String[] args) { \n  Point points[] = new Point[6]; \n  points[0] = new Point(0, 0); \n  points[1] = new Point(4, 1); \n  points[2] = new Point(2, 0); \n  points[3] = new Point(1, 5);   \n  points[4] = new Point(3, 2); \n  points[5] = new Point(2, 4); \n  System.out.println(findPoint(points)); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do you have more test cases?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be solve in O(n); given n is the # of intersection points. How? - First find the center of the gravity of all points. Let say C. This takes T1=O(n) - Then find the k points around it (in 1D: k=2, in 2D k=4, in xD k=2x). This can be done by binary search on each dimension. T2=O(2xlog(sqrt(n)). Even if we don't consider binary search it can be done in T2=O(2xn) -Find the min distance between these points and all points T3=O(n) -Choose point with min distance T4=O(2x) And we have: T=O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Suppose the grid is represented by (X,Y) points and each Node has coordinates (x1,y1), X2,y2) .......(Xn,Yn). First find a good starting point (will solve later).  say Xk, Yk. Now calculate the sum of the distance of all the 4 neighbours  of Xk, Yk   from all the points. i.e  D(Xk-1, Yk), D(Xk+1, Yk), D(Xk, Yk+1) D(Xk, Yk-1) Pick the (x y) which is the minimum. Greedy approach. Continue this algorithm till you reach a point,  where all the subsequent D's are larger than the current D. How to select the starting good point?  In case we select a very far away point, it will take very large iterations to reach the global min-sum-distance point. - We need to choose a point from an area where there are large number of cluster of points.  This can be achieved by dividing the X-Range into a reasonable number of bins. (ranges) And Scan all the X points and increment each bin based on the X  coordinate. The bin with maximum number of points is the range in which there are maximum number of X-coordinates.  Similarly Scan all the Y points and repeat the process of Y corrdinate i.e. Y-Bins.  Now the intersection of the Max-X-bin  and Max Y-bin ranges is my cluster of interest. So we can pick the mid point of the Max-Xbin range and Max-Ybin range. Finding the good point to start will be done in linear order. (Bins space can be choosen as per the number  of points 10% will be fine). Calculation of distance of all the points for a grid point is again linear order.  How fast you reach the min-distance point will depend on the distribution of the points on which we do not have no control."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"1. Calculate the distance matrix by Floyd-Warshall algorithm O(V^3) or Johnson algorithm (V(VlgV+E)). 2. find the row in that matrix with the minimum sum."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I think the ideal position will try to best satisfy the condition that:  1) number of points to its left equals number of points to its right 2) number of points to its up equals number of points to its down side  The reasoning behind this is in a one-dimension problem, any point in between 2 points gives shortest sum of distances. Extending it to two-dimension has similar behavior.   So to solve this problem, just sort the x's and y's of the points, and pick the middle-indexed x and y will do. If the total number of points is even, then pick an x in between the middle two x's and a y in between the middle two x's."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5127611667709952","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"66","title":"Given a set top box: a, b, c, d, e, f, g, h, i, j, k, l, m, n, o p, q, r, s, t u, v, w, x, y z  Write code to give the character sequence given a word, For example, if the word is \"CON\", the function will print this: Right//now we're at B Right//now we're at C OK//to select C Down DOwn Right Right OK//to select O Left//now at N OK//to select N  note: Be careful when you're at Z. if you go to the right, you will get stuck. Afterwards, the interviewer adds a space to the right of 'Z' to test the code.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"int _tmain(int argc, _TCHAR* argv[]) \n{ \n \n char myArray[6][5]; \n char findMovie[] = {\"UP\"}; \n char findch; \n int ipos[10][2]; \n int iChar = 65; \n int iCurRow = 0; \n bool bDone = false; \n char AddMoves[10] = \"\"; \n char MoVedirection; \n bool bver = false; \n bool bhor = false; \n \n for (int i =0; i<6;i++) \n { \n  for ( int j =0;j <5;j++) \n  { \n   myArray[i][j] = (char)iChar; \n   iChar++; \n  } \n } \n \n for ( int l=0; l  destC)  \n  { \n    strcat_s(AddMoves,\"L\"); \n    curC--; \n  } \n   \n  while (curR > destR) { \n    strcat_s(AddMoves,\"U\"); \n    curR--; \n   } \n \n  while (curC < destC) { \n    strcat_s(AddMoves,\"R\"); \n    curC++; \n   } \n \n   while (curR < destR) { \n    strcat_s(AddMoves,\"D\"); \n    curR++; \n   } \n  strcat_s(AddMoves,\"!\"); \n } \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"void printSteps(int a, int b, char key) \n{ \n while(a < b) { \n  cout << key; \n  a++; \n } \n} \n \nvoid printMoves(const char *movie, int w) \n{ \n int x = 0, y = 0; \n \n while(*movie) { \n  int tx = (tolower(*movie) - 'a') % w; \n  int ty = (tolower(*movie) - 'a') / w; \n \n  printSteps(tx, x, 'l'); \n  printSteps(ty, y, 'u'); \n  printSteps(x, tx, 'r'); \n  printSteps(y, ty, 'd'); \n  cout << '!'; // select \n  x = tx; y = ty; \n  movie++; \n } \n cout << endl; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def str2moves(cs): \n    \"\"\"Convet string to moves in matrix \n \n    +-----------x \n    | a b c d e \n    | f g h i j \n    | k l m n o \n    | p q r s t \n    | u v w x y \n    | z \n    y \n \n    Returns string of moves encoded as follows: \n        R - right \n        L - left \n        D - down \n        U - up \n        O - ok \n \n    Example: \n        >>> str2moves('con') \n        'RRODDRROLO' \n        >>> str2moves('conz') \n        'RRODDRROLODDLLLDO' \n        >>> str2moves('conza') \n        'RRODDRROLODDLLLDOUUUUUO' \n    \"\"\" \n    def i2xy(i): \n        y, x = divmod(i, 5) \n        return x, y \n \n    char2xy = {chr(ord('a') + i): i2xy(i) \n               for i in range(ord('z') - ord('a') + 1)} \n \n    def move(cx, cy, x, y): \n        \"\"\"Moves required to get from (cx, cy) to (x, y) \n        \"\"\" \n        if y - cy > 0: \n            moves.extend('D' * (y - cy)) \n        elif y - cy < 0: \n            moves.extend('U' * (cy - y)) \n        if x - cx > 0: \n            moves.extend('R' * (x - cx)) \n        elif x - cx < 0: \n            moves.extend('L' * (cx - x)) \n        return x, y \n    moves = [] \n \n    cs = cs.lower() \n    cx, cy, z = 0, 0, False \n    for c in cs: \n        x, y = char2xy.get(c, (None, None)) \n        if x is None: \n            raise ValueError('invalid char: {}'.format(c)) \n        if z == True: \n            moves.append('U') \n        if y == 5: # 'z' \n            cx, cy = move(cx, cy, x, y - 1) \n            moves.append('D') \n            z = True \n        else: \n            cx, cy = move(cx, cy, x, y) \n        moves.append('O') \n    return ''.join(moves) \n \n \nif __name__ == '__main__': \n    import doctest \n    doctest.testmod()"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Nice question   My solution (Scala)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static String getPath(int w, char[] str) { \n  int i = 0; \n  StringBuilder sb = new StringBuilder(); \n  int curR = 0; \n  int curC = 0; \n  while (i < str.length) { \n   int destR = (str[i] - 'a') / w; \n   int destC = (str[i] - 'a') % w; \n \n   while (curC > destC) { \n    sb.append('l'); \n    curC--; \n   } \n \n   while (curR > destR) { \n    sb.append('u'); \n    curR--; \n   } \n \n   while (curC < destC) { \n    sb.append('r'); \n    curC++; \n   } \n \n   while (curR < destR) { \n    sb.append('d'); \n    curR++; \n   } \n \n   sb.append('!'); \n   i++; \n  } \n  return sb.toString(); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n \nint strlen(char *str) \n{ \n int i=0; \n while(str[i++] != '\\0'); \n return i-1; \n} \n \nvoid print_path(int new_x, int new_y, int prev_x, int prev_y) \n{ \n while(new_x != prev_x) \n { \n  if(new_x < prev_x) \n  { \n   printf(\"u\"); \n   prev_x--; \n  } \n  else \n  { \n   printf(\"d\"); \n   prev_x++; \n  } \n } \n while(new_y != prev_y) \n { \n  if(new_y < prev_y) \n  { \n   printf(\"l\"); \n   prev_y--; \n  } \n  else \n  { \n   printf(\"r\"); \n   prev_y++; \n  } \n } \n printf(\"!\"); \n} \n \nvoid lookup_movie(char *movie, int width) \n{ \n int len = strlen(movie); \n int new_x, new_y; \n int prev_x, prev_y; \n int loop=0; \n prev_x = prev_y = 0; \n while(loop < len) \n { \n  new_x = ( movie[loop] - 'a' ) / width; \n  new_y = ( movie[loop] - 'a' ) % width; \n  print_path(new_x, new_y, prev_x, prev_y); \n  prev_x = new_x; \n  prev_y = new_y; \n  loop++; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n \nint strlen(char *str) \n{ \n int i=0; \n while(str[i++] != '\\0'); \n return i-1; \n} \n \nvoid print_path(int new_x, int new_y, int prev_x, int prev_y) \n{ \n while(new_x != prev_x) \n { \n  if(new_x < prev_x) \n  { \n   printf(\"u\"); \n   prev_x--; \n  } \n  else \n  { \n   printf(\"d\"); \n   prev_x++; \n  } \n } \n while(new_y != prev_y) \n { \n  if(new_y < prev_y) \n  { \n   printf(\"l\"); \n   prev_y--; \n  } \n  else \n  { \n   printf(\"r\"); \n   prev_y++; \n  } \n } \n printf(\"!\"); \n} \n \nvoid lookup_movie(char *movie, int width) \n{ \n int len = strlen(movie); \n int new_x, new_y; \n int prev_x, prev_y; \n int loop=0; \n prev_x = prev_y = 0; \n while(loop < len) \n { \n  new_x = ( movie[loop] - 'a' ) / width; \n  new_y = ( movie[loop] - 'a' ) % width; \n  print_path(new_x, new_y, prev_x, prev_y); \n  prev_x = new_x; \n  prev_y = new_y; \n  loop++; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In Java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class DVRAI \n    { \n        public static void Do() \n        { \n            char[,] matrix =  \n            { \n                {'a','b','c','d','e'}, \n                {'f','g','h','i','j'}, \n                {'k','l','m','n','o'}, \n                {'p','q','r','s','t'}, \n                {'u','v','w','x','y'} \n            }; \n \n            SimpleDo(matrix, \"hello\"); \n        } \n \n        public static void SimpleDo(char[,] matrix, string name) \n        { \n            int xStart = 0, yStart = 0, xNext = 0, yNext = 0; \n            StringBuilder sb = new StringBuilder(); \n            foreach (char ch in name) \n            { \n                GetPosition(ch, ref xNext, ref yNext); \n \n                if (xNext > xStart) \n                { \n                    for (int i = xStart; i < xNext; i++) \n                    { \n                        sb.Append(\"D\"); \n                    }                     \n                } \n \n                if (xNext < xStart) \n                { \n                    for (int i = xNext; i < xStart; i++) \n                    { \n                        sb.Append(\"U\"); \n                    }                     \n                } \n \n                if (yNext > yStart) \n                {  \n                    for(int i = yStart; i < yNext; i++) \n                    { \n                        sb.Append(\"R\"); \n                    }                     \n                } \n \n                if (yNext < yStart) \n                { \n                    for (int i = yNext; i < yStart; i++) \n                    { \n                        sb.Append(\"L\"); \n                    }                     \n                } \n \n                sb.Append(\"!\"); \n \n                xStart = xNext; \n                yStart = yNext; \n            } \n \n            Console.WriteLine(sb.ToString()); \n        } \n \n        private static void GetPosition(char ch, ref int x, ref int y) \n        { \n            int i = ch - 'a'; \n            x = i / 5; \n            y = i % 5; \n        } \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If we observe grid carefully, they are in sorted order (rows an columns individually). So, I guess, interviewer is expecting binary search on row wise and/or column wise.  Forgive me, if somebody is already noticed this point and above programs are already have this logic (little lazy to read all programs :))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution would be to give each letter an index like a[0,0] b[0,1] and so on..then for the text entered find the difference between the character indexes and based on that define up  = if row difference is negative down = if row difference is positive left = if column difference is negative right = if column difference is positive"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package ir.ListAlgorithms.com;  public class LetterGrid {  char movieName[];  int maxLetterPerRow = 5;  int currDIV=0;  int currMOD=0;  String allMoves = \"\";    LetterGrid(String movieName){   movieName = movieName.toUpperCase();   this.movieName = movieName.toCharArray();   for(int i=0;i   allMoves += getMove((int)this.movieName[i]-65);   }   System.out.println(allMoves);  }  public String getMove(int x){   int newDIV = x/maxLetterPerRow;    int newMOD = x%maxLetterPerRow;   int dirUD = newDIV - currDIV;   int dirLR = newMOD - currMOD;   char up_down = 'd';   char left_right = 'r';   int mult = 1;   String move =\"\";   if(dirUD <0) { mult = -1;up_down = 'u'; }   for(int i=0;i<(dirUD*mult);i++) move+=up_down;   if(dirLR <0) {mult = -1;left_right='l'; }   for(int i=0;i<(dirLR*mult);i++) move+=left_right;   currDIV = newDIV;   currMOD = newMOD;   return move+\"!\";  }  public static void main(String [] args){   new LetterGrid(\"MEGAMIND\");  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"C#"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java Code,  Logic first try to move vertically up or down then horizontally towards left or right."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why nobody try to solve this with finding the shortest path in the graph?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{package nb;  import java.sql.Array; import java.sql.ResultSet; import java.sql.SQLException; import java.util.ArrayList; import java.util.Map; public class bit {  public static int i = 0;  public static StringBuilder sb = new StringBuilder();  public static int curR = 0;  public static int curC = 0;  public static int destR=0;  public static int destC=0;  public static void main(String[] args) {   char a[]={'a','b','c','d','e'};   getPath(5, a,0);  }  public static void getPath(int w, char[] str,int i) {      if(i   destR = (str[i] - 'a') / w;    destC = (str[i] - 'a') % w;    if (curC > destC) {     sb.append('l');     curC--;     getPath(w, str,i);    }     else if(curR > destR) {     sb.append('u');     curR--;     getPath(w, str, i);    }     else if(curC < destC) {     sb.append('r');     curC++;     getPath(w, str, i);    }     else if(curR < destR) {     sb.append('d');     curR++;     getPath(w, str, i);    }    else{        sb.append('!');        getPath(w, str, i+1);    }     }     if(i==str.length)      System.out.println(sb.toString());  } }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution using BFS. Running time - length of string * O(V+E)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Fully functioning Java-code with correct boundary analysis. Let me know your comments :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simple modular version. Little bit longer then others but very clear."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In Java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In Java,,,"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In Java with results according to the instruction."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void getCode(int m, String str) {      int index = 0;      int i;      int n = str.length();      for(i = 0; i < n; i++) {          int dest = str.charAt(i) - 'a';          while(index != dest) {              if(index + m <= dest) {                  index += m;                  System.out.print(\"d\");              } else if(index - m >= dest) {                  index -= m;                  System.out.print(\"u\");              } else if(index > dest) {                  index -= 1;                  System.out.print(\"l\");              } else {                  index += 1;                  System.out.print(\"r\");              }          }          System.out.print(\"!\");      }     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algorithm: 1.store abcde...in a 2-D array 2.Search for row 3.If row is greater than the previous row value,move down otherwise move up.In case of no changing in row donot move up or down. 4.Now look for column and move right or left correspondingly.... Remember initial position to be (0,0) I have implemented in C using turbo C++ compiler"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.lang.Math; \n \nclass DVRtext{ \n \n \npublic static void main(String[] args){ \n \nString movieName = \"ipz\"; \nint gridSize = 5, numCol = gridSize, numRow = (int) Math.ceil(26.0/numCol); \n \nchar thisChar; \nint m,n,mL,mR,mU,mD,k; \n \nint a_ascii = (int) 'a'; \n \n \nfor(int i=0; i< movieName.length(); i++){ \n \n  thisChar = movieName.charAt(i); \n  m = ((int) thisChar - a_ascii )/numCol; \n  n = ((int) thisChar - a_ascii )%numCol; \n//  System.out.println(thisChar + \" m:\" + m + \" n:\" + n + \" numRow:\" + numRow); \n \n  if(m >numRow/2){ mU = numRow-m;mD =-1;}  else {mU=-1; mD = m;} \n  if(n >numCol/2){ mL = numCol-n;mR =-1;}  else {mL=-1; mR = n;} \n \n \n  //System.out.println(mL + \" \" + mR + \" \" + mU + \" \" + mD); \n \n  for(k=0;k"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution A: Construct graph. Then do the BFS for each word.  Solution B: But there is no need to BFS, if we see z is the special case of u. if the word is z , search path for u and we can add DOWN + OK if the previous word is z , add UP then use u as start point.  Let's work on B"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I can seemany people propose a table/map while that's just an alphabet and is already part of the language, just calculate the offset. To avoid \"z\" trap (z to right) and down to \"z\" empty string you need to rotate clockwise - you'll always have max 2 directions out of 4, and never get stuck if doing that clockwise."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void getCode(int m, String str) { \n     int index = 0; \n     int i; \n     int n = str.length(); \n     for(i = 0; i < n; i++) { \n         int dest = str.charAt(i) - 'a'; \n         while(index != dest) { \n             if(index + m <= dest) { \n                 index += m; \n                 System.out.print(\"d\"); \n             } else if(index - m >= dest) { \n                 index -= m; \n                 System.out.print(\"u\"); \n             } else if(index > dest) { \n              if(index % m < dest % m) { \n               index -= m; \n               System.out.print(\"u\"); \n              } else { \n               index -= 1; \n               System.out.print(\"l\"); \n                 } \n             } else { \n              if(index % m > dest % m) { \n               index += m; \n               System.out.print(\"d\"); \n              } else { \n               index += 1; \n                  System.out.print(\"r\"); \n              } \n                  \n             } \n         } \n         System.out.print(\"!\"); \n     }    \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Another Python implementation. I've focused on clarity & explicitness (in other words, this won't win code golf). Docstrings, PEP 8 & 257, etc."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using System.Collections.Generic; \nusing System.Diagnostics; \n \nnamespace SimplePlays \n{ \n   public class PathFinder \n   { \n       private readonly char[][] m_Board = new char[][] \n       { \n           new char[] {'a', 'b', 'c', 'd', 'e'}, \n           new char[] {'f', 'g', 'h', 'i', 'j'}, \n           new char[] {'k', 'l', 'm', 'n', 'o'}, \n           new char[] {'p', 'q', 'r', 's', 't'}, \n           new char[] {'u', 'v', 'w', 'x', 'y'}, \n           new char[] {'z', ' '} \n       }; \n        \n       Dictionary  m_NavigationBoard = new Dictionary(); \n \n       public PathFinder() \n       { \n           initNavigationBoard(); \n       } \n \n       private void initNavigationBoard() \n       { \n           for (int i = 0; i < m_Board.Length; i++) \n           { \n               for (int j = 0; j < m_Board[i].Length; j++) \n               { \n                   m_NavigationBoard.Add(m_Board[i][j], new Position(i, j, m_Board[i].Length - 1)); \n               } \n           } \n       } \n \n       public void PrintPath(string input) \n       { \n           if (string.IsNullOrEmpty(input)) \n           { \n               return; \n           } \n \n           Position lastKnownPosition = new Position(0,0, 0); \n           foreach (char chr in input) \n           { \n               Position newPosition = m_NavigationBoard[chr]; \n               PrintDirections(lastKnownPosition, newPosition); \n               lastKnownPosition = newPosition; \n           } \n       } \n \n       private void PrintDirections(Position from, Position to) \n       { \n           // for example, from Z to N \n           if (from.ColumnIndex < to.ColumnIndex && (to.ColumnIndex > from.MaxColumnIndex)) \n           { \n               PrintRowsDirections(from, to); \n               PrintColumnDirections(from, to); \n           } \n           else \n           { \n               PrintColumnDirections(from, to); \n               PrintRowsDirections(from, to); \n           } \n \n           PrintStep(Directions.Ok); \n       } \n \n       private void PrintRowsDirections(Position from, Position to) \n       { \n           int tempIndex = from.RowIndex; \n           int tempDirection = from.GetRowDirection(to); \n \n           while (tempIndex != to.RowIndex) \n           { \n               // Do step \n               tempIndex += tempDirection; \n               //Print \n               PrintStep((tempDirection > 0) ? Directions.Down : Directions.Up); \n           } \n       } \n \n       private void PrintColumnDirections(Position from, Position to) \n       { \n           int tempColumnIndex = from.ColumnIndex; \n           int tempColumnDirection = from.GetColumnDirection(to); \n \n           while (tempColumnIndex != to.ColumnIndex) \n           { \n               // Do step \n               tempColumnIndex += tempColumnDirection; \n               //Print \n               PrintStep((tempColumnDirection > 0) ? Directions.Right : Directions.Left); \n           } \n       } \n \n       private void PrintStep(Directions step) \n       { \n          Debug.WriteLine(step); \n       } \n \n       enum Directions \n       { \n           Ok, \n           Up, \n           Down, \n           Left, \n           Right \n       } \n \n       [DebuggerDisplay(\"RI: {RowIndex}, CI: {ColumnIndex}\")] \n       class Position \n       { \n           public Position(int rowIndex, int columnIndex, int maxColumnIndex) \n           { \n               RowIndex = rowIndex; \n               ColumnIndex = columnIndex; \n               MaxColumnIndex = maxColumnIndex; \n           } \n           public int RowIndex { get; set; } \n           public int ColumnIndex { get; set; } \n           public int MaxColumnIndex { get; set; } \n \n           public int GetRowDirection(Position newPosition) \n           { \n               if (newPosition.RowIndex >= this.RowIndex) \n               { \n                   return 1; \n               } \n \n               return -1; \n           } \n \n           public int GetColumnDirection(Position newPosition) \n           { \n               if (newPosition.ColumnIndex >= this.ColumnIndex) \n               { \n                   return 1; \n               } \n \n               return -1; \n           } \n       } \n   } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"No algorithms are involved. Only some coding."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.*; \nimport java.io.*; \nimport java.lang.*; \n \npublic class SetTopBox { \n \n// chars per line \npublic static final int N = 5; \n \npublic static void printDirection(int dx, int dy) { \n String targetXString = \"Right\"; \n if (dx < 0) targetXString = \"Left\"; \n \n String targetYString = \"Down\"; \n if (dy < 0) targetYString = \"Up\"; \n \n for (int i=0; i < Math.abs(dx); ++i) { \n  System.out.println(targetXString); \n } \n   \n for (int i=0; i < Math.abs(dy); ++i) { \n  System.out.println(targetYString); \n } \n  \n System.out.println(\"OK\"); \n} \n \n       public static void printInstructions(String word, char initialCharacter) { \n int initialPosition = initialCharacter - 'a'; \n int currentX = initialPosition % N; \n int currentY = initialPosition / N; \n \n for (char target : word.toCharArray()) { \n  if ((target < 'a') || (target > 'z')) { \n      continue; \n  } \n   \n  int targetPos = target - 'a' ; \n  int tx = targetPos % N; \n  int ty = targetPos / N; \n     \n  int dx = tx - currentX; \n  int dy = ty - currentY; \n \n  printDirection(dx, dy);  \n   \n  currentX = tx; \n  currentY = ty; \n } \n  \n} \n \n public static void main(String[] args) { \n  try { \n    Scanner scanner = new Scanner(new FileInputStream(\"input.txt\")); \n    String word = scanner.nextLine().toLowerCase(); \n    char initialCharacter = scanner.nextLine().charAt(0); \n \n    printInstructions(word, initialCharacter); \n  } \n  catch(IOException e) { \n  } \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void findRoute(char* word, char loc) \n{   \n    if (strlen(word) == 0 ) \n    { \n        return; \n    } \n     \n    char w = word[0]; \n \n    int pr = row(loc); \n    int pc = col(loc); \n        \n    int r = row(w); \n    int c = col(w); \n     \n    if( w == loc ) \n    { \n        printf(\"OK.\\n\"); \n        return findRoute(word+1, loc);         \n    } \n    else if( w == 'z' && pc != 0 ) \n    { \n        printf(\"Left.\\n\"); \n        return findRoute(word, loc - 1); \n    } \n    else if( r > pr ) \n    {         \n        printf(\"Down.\\n\"); \n        return findRoute(word, loc + 5); \n    }     \n    else if( r < pr ) \n    { \n        printf(\"Up.\\n\"); \n        return findRoute(word, loc - 5); \n    }     \n    else if( c > pc ) \n    {         \n        printf(\"Right.\\n\"); \n        return findRoute(word, loc + 1);         \n    } \n     \n    else if( c < pc ) \n    { \n        printf(\"Left.\\n\"); \n        return findRoute(word, loc - 1); \n    } \n}; \n \nint main() \n{     \n    findRoute(\"yzy\", 'a'); \n \n    return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Assign (x, y) coordinates to each character according to its position. For example,  a (0,0) b (0,1)... f (1, 0)... etc.  We can then get to a char from any char, by incrementing/decrementing x (up/down) or y (right/left)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"void NavigateGrid(char *s) \n{ \n if(!*s) \n  return; \n int i,j,val; \n int prev_row=0, prev_col=0; \n int cur_row,cur_col; \n \n for(i=0;iprev_col) \n  { \n   if(a[prev_row][prev_col+1]=='-') \n    printf(\"Moving Up to %c\\n\",a[--prev_row][prev_col]); \n   for(j=prev_col+1;j<=cur_col;j++) \n    printf(\"Moving Right to %c\\n\",a[prev_row][++prev_col]);    \n  } \n  else \n  { \n   for(j=prev_col-1;j>=cur_col;j--) \n    printf(\"Moving Left to %c\\n\",a[prev_row][--prev_col]); \n  }    \n   \n  if(cur_row>prev_row) \n  { \n   for(j=prev_row+1;j<=cur_row;j++) \n    printf(\"Moving Down to %c\\n\",a[++prev_row][prev_col]); \n  } \n  else \n  { \n   for(j=prev_row-1;j>=cur_row;j--) \n    printf(\"Moving Up to %c\\n\",a[--prev_row][prev_col]); \n  } \n  printf(\"\\nOK to pick %c\\n\\n\",a[prev_row][prev_col]); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"It can be solved by using DIRECTIONS : use like,  \"\"up==North\"\"  \"\"down==south\"\" \"\"right==west\"\" \"\"left==east\"\"  a, b, c, d, e,  f, g, h, i, j,  k, l, m, n, o  p, q, r, s, t  u, v, w, x, y  z , #, #, #, #  Base cases: 1)if u ever encounter a word in any directions like,   for(search=='a' to search=='z';search++)//for all letters { return 'a' to return 'z'; }  if(search=='#')//where #=end in any directions { return NULL; }   Concept: If a word is  \"CON\"(given),then u hav to traverse in matrix like following ,  ##starting frm first letter 'a'## 1)if ur word contains 'a' means just return it,Otherwise go next,west++;until u fnd the word..          for(i='a';i<'z';i++)          //first u hav 2 set # a to z # values 1 to 26 in any set..          if(word[i]=='a'&&matrix[i][j]=='a')  {  return 'a';  }   else  {  west++;//until they found  i++;  } i)if 'a' found,look for 'o' in matrix[i][j]; ii)else west++;    i++;//until they found..   2)from the given matrix[i][j],find 'o';this is in far dist from 'o'  i)go down until u reach the char 'o' present row//i thnk it s in 3RD row..  ii)once u reached 3rd row,at 'm' char position,u hav to traverse 2 more to reach 'o';  for(i='o';)//i at curr pos 'm'  { i=0; i=i+2;//traverse 2 more west++;//(right++;)to reach 'o'; }     so on...find 'n' urself..  i hav posted ths concept..if u encnter any err, sorry dude..i tried.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"simple BFS will do it"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Find the difference between rows and columns of characters for example A[0,0] B[0,1] C[0,2] find difference between C-A =[0,2]..that is we need to go two right then O-C = [2,2] = Two Right and two Down then N-O = [-1,0] = One Left"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Letter can be thought of as a=1; b=2;.......z=26. Movie name can be iterated upon character by character. After calculating/finding the value of a letter, move can be made. From the grid width we can find out the row and column of the letter.  For an example, movie id \"vh\". v is 22 and h is 8. Suppose grid width is 13. 22/13 = 1(r1) (second column) and 22%13 = 9(c1)(9th column) so, v is drrrrrrrr!. Now h 8/13 = 0 (r2) and 8%13 = 8(c2)  r2-r1 = 0-1 = -1 means u and c2-c1 = 8-9=-1 means l so ul! and vh is drrrrrrrr!ul!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Here is a full Java implementation. It's a bit long because I added utility methods for clarity."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"C++ code solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#include  \n#include  \n#include  \n \nint main(int argc, char* argv[]) \n{ \n   int width = 0; \n   int row = 0, col = 0; \n   char *film = NULL; \n   char res[200] = {'\\0'}; \n   char *pRes = res; \n   char start = 0; \n    \n   if (argc < 3) { \n      printf(\"enter the grid width and the film name\\n\"); \n      return EXIT_FAILURE;  \n   } \n   sscanf(argv[1], \"%d\", &width ); \n   film = argv[2]; \n    \n   if ((width > 26) || (width < 0)) return -1; \n    \n   while (*film != '\\0')   { \n      if (* film == ' ') {film++; continue; } \n      if (*film < 'a') start = 'A'; \n      else start = 'a'; \n      row = (*film - start) / width; \n      col = (*film - start) % width; \n \n      while (row-- > 0) { \n         *pRes = 'd';  \n         pRes++; \n      } \n      while (col-- > 0) { \n         *pRes = 'r'; \n         pRes++; \n      } \n      *pRes = '!'; \n      pRes++; \n       \n      film++; \n   } \n    \n   printf(\"resulting key buttons sequence: %s\\n\", res); \n    \n    \n    \n   return EXIT_SUCCESS; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Easy enough, you don't even need the matrix for given example  consider a = 0, b=1,....z=25. we have a 5x5 matrix, coordinate of a = 0,0 , b =0,1 and so on.  coordinate of an alphabet is (n/5, n%5) n=> integer value of alphabet, (a=0...z=25).  scan the input string left to right, \"CON\" coordinates of C in given matrix, is (  2/5  ,  2%5) = (0,2). coordinates of O in given matrix, is (14/5 , 14%5) = (2,4). coordinates of N in given matrix, is (13/5,  13%5) = (2,3).  so problem reduces to giving direction for reaching 2,3 from 0,0 and from given path.  (0,0) -> (0,2) -> (2,4) -> (2,3).  first reduce distance vertical distance  0,0 to 0,2 difference on x =0-0 hence print nothing for x. Now reduce distance on horizontal distance 0,0 to 0,2 difference on y=+2 hence print right 2 times, if value is -ve print left difference no. of times.  now we are at (0,2)  have to go to (2,4). again reduce distance on vertical axis first. (2,2) from (0,2) distance = +2 hence print down 2 times, if difference is -ve print up difference no. of times. reduce distance on horizontal axis, (2,4) from (2,2) distance = +2 hence print right 2 times.  (2,3) from (2,4) print distance on horizontal axis = -1 print left one time.   how about scalability of this solution? can we extend it for any configuration of matrix as well? Yes we can, in that case create a hash map, that will store coordiantes of each alphabet. This can be done by scanning the given matrix as part of pre-processing step.  Now, once you get input string, you immediately have coordinates of each alphabet and problem again reduces to printing path from source to destination. This part of above solution remains unchanged."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This code will work ! Let me know if there are any issues.   public static void printDVRPath(String input) {   int start_row = 0;   int start_col = 0;      for(char c : input.toCharArray()) {        if(Character.isLowerCase(c)) {    // assuming input is all small chars       int charPos = (int) c - 96;    int end_row =  charPos / 5;    int end_col = (charPos % 5) - 1 ;        while (start_row!=end_row) {     if(start_row > end_row) {      System.out.print(\"U\");      start_row --;          }     else {      System.out.print(\"D\");      start_row ++;     }              }        while(start_col!=end_col) {     if(start_col > end_col) {      System.out.print(\"L\");      start_col --;     }     else {      System.out.print(\"R\");      start_col ++;     }         }    System.out.print(\"!\");     }  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#include  \n#include  \n \nconst char* direction_table[4] = { \n \"LEFT\", \n \"RIGHT\", \n \"UP\", \n \"DOWN\" \n}; \n \nenum { \n LEFT, \n RIGHT, \n UP, \n DOWN \n}; \n \nvoid echo_direction(int direction) \n{ \n printf(\"%s\\n\", direction_table[direction]); \n} \n \nvoid selected() \n{ \n printf(\"OK\\n\"); \n} \n \nvoid move(char from, char to) \n{ \n int src, tgt, direction, coe; \n \n // same char \n if(from == to) return; \n \n // for x direction \n src = (from-'a')%5; \n tgt = (to -'a')%5; \n if(tgt < src) { \n  direction = LEFT; \n  coe = -1; \n } else if (tgt > src) { \n  direction = RIGHT; \n  coe = 1; \n } \n while(src != tgt) { \n  echo_direction(direction); \n  src += coe; \n } \n \n // for y direction \n src = (from - 'a') / 5; \n tgt = (to - 'a') / 5; \n if(tgt src) { \n  direction = DOWN; \n  coe = 1; \n } \n \n while(src != tgt) { \n  echo_direction(direction); \n  src += coe; \n } \n} \n \nvoid show_sequence(char *text, int len) \n{ \n char from='a', to; \n int i=0; \n \n if(len <2) return; \n \n while(i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"public static void getCode(int m, String str) { \n     int index = 0; \n     int i; \n     int n = str.length(); \n     for(i = 0; i < n; i++) { \n         int dest = str.charAt(i) - 'a'; \n         while(index != dest) { \n             if(index + m <= dest) { \n                 index += m; \n                 System.out.print(\"d\"); \n             } else if(index - m >= dest) { \n                 index -= m; \n                 System.out.print(\"u\"); \n             } else if(index > dest) { \n                 index -= 1; \n                 System.out.print(\"l\"); \n             } else { \n                 index += 1; \n                 System.out.print(\"r\"); \n             } \n         } \n         System.out.print(\"!\"); \n     }    \n }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5848066661810176","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"Design and implement a class, which returns a random string value from a set with an arbitrary probability distribution given by an array of probabilities. Using an existing random number generator with a uniform distribution(e.g., Random.nextFloat()), you return the string for the random float value based on the strings probability distribution.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The term \"arbitrary probability distribution\" over the given string set requires further clarification. It is due to the fact that this distribution determines the way we will be simulating the randomness to pick the next string. For instance, the probability array introduces a uniform distribution over the strings. In such a setting, we can simulate a random variable that gives the next string's index as:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can assume that probs given in the array can be related to frequency and"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It assumes that probs[i] is the probability of getting strings[i], which means probs.size() == strings.size() and sum(probs) = 1.0"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5118665250832384","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"29","title":"design a method which consumes an integer and output the corresponding column number in Microsoft Excel ( ex. A, B, C......Z, AA, AB....ZZ....)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"public class ExcelColumn { \n \npublic static String excelColumnName(int num){ \n        if(num==0) \n         return \"\"; \n  if (num<=26) \n   return Character.toString((char) (num+64)); \n  else { \n   int firstpart=num/26; \n      int end=num%26; \n      end=end==0?26:end; \n      if (firstpart >26) \n       return excelColumnName((num-end)/26)+Character.toString((char) (end+64)); \n      else \n       return Character.toString((char) ((num-end)/26+64))+Character.toString((char) (end+64)); \n  } \n   \n } \n public static void main(String[] args) { \n \n  for (int i=24;i<30;i++){ \n   System.out.println(excelColumnName(i)); \n  } \n  System.out.println(excelColumnName(746)); \n } \n \n} \n \n \n \nX \nY \nZ \nAA \nAB \nAC \nABR"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Excel { \n \n public static char column(int n) { \n  int d, r; \n \n  int A = 'A'; \n  int Z = 'Z'; \n  int numLetters = Z - A + 1; \n  char s = ' '; \n \n  while (n > 0) { \n   d = (n - 1) / numLetters; \n   r = (n - 1) % numLetters; \n   s += A + r; \n   n = d; \n  } \n  return Character.toUpperCase(s); \n } \n \n public static void main(String[] args) { \n \n  for (int i = 1; i <= 26; i++) { \n   System.out.println(column(i)); \n  } \n \n  for (int i = 1; i <= 26; i++)     \n   for (int j = 1; j <= 26; j++) \n    System.out.println(column(i) + \"\" + column(j)); \n \n  for (int i = 1; i <= 26; i++) \n   for (int j = 1; j <= 26; j++) \n    for (int k = 1; k <= 26; k++) \n     System.out.println(column(i) + \"\" + column(j) + \"\" \n       + column(k)); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"oh, any suggestions on how to solve?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void ConvertToExcel(int number,char* formatted){ \n int i = 0, num=number; \n while (num) \n { \n  formatted[i++] = 'A'-1 + num % 26; \n  num = num / 26; \n } \n formatted[i--] = '\\0'; \n for (int p = 0, q = i; p < q; p++, q--){ \n  char temp = formatted[p]; \n  formatted[p] = formatted[q]; \n  formatted[q] = temp; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static String numToColumn(int number){ \n         \n        StringBuilder sb = new StringBuilder(); \n        char c; \n        char s=0; \n        int n = number; \n        while(n > 0){ \n            c = (char) ((n - 1) %26); \n            s = (char) ((c+65)); \n            n = (n-c)/26;       \n            sb.append(s); \n        } \n        return sb.toString(); \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ha, totally right.  sb.reverse().toString() would do. But, I doubt the interviewer would be happy."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"final static char[] alpha = {     'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',     'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z' };    static int LENGTH = alpha.length;    public static String generatevariable(int a) {     int t = a;     StringBuffer s = new StringBuffer(\"\");     if (a == 0)       return \"\";     if (a <= LENGTH)       s.append(alpha[a - 1]);     else {       s.append(generatevariable((a - 1) / LENGTH)); // use recursion       s.append(generatevariable(a - ((a - 1) / LENGTH) * LENGTH));     }     return s.toString();   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def main(): \n  num = int(input()) \n  col = '' \n   \n  while num > 0: \n    c = chr((num-1)%26+65) \n    col = c+col \n    num = (num-1)//26 \n   \n  print(col) \n   \n \nif __name__ == '__main__': \n  main()"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static char [] chars = new char[27]; \n static { \n  char c = 'A'; \n  for(int i=0;i<26; i++) \n   chars[i] = c++; \n } \n static String getExcelValue(int num) { \n  return getExcel(num-1); \n } \n static String getExcel(int num) { \n   \n  int rem = num % 26; \n  int quot = num / 26; \n   \n  if(quot > 0) \n   return getExcel(quot-1) + chars[rem];   \n  return \"\"+chars[rem]; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class ExcelColumn \n{ \n    public static void printColumnName(int n) { \n     if(n/26>0) { // recurse \n   printColumnName(n/26-1); \n  } \n   \n  //print character \n  System.out.print(Character.toString((char)('A'+n%26))); \n } \n  \n    public static void main(String[] args) { \n  printColumnName(Integer.parseInt(args[0])-1); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"python code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void findXLcolumnByNumber(int number){ \n  List lst = new ArrayList(); \n  while (number > 0){    \n   int b = number % 26; \n   number = number / 26; \n   b = b == 0 ? 26 : b; \n   lst.add((char) (b + 64)); \n  } \n   \n  for (int i = lst.size() - 1; i >= 0; i--)System.out.print(lst.get(i)); \n  System.out.println(); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java Implementation: \n \npublic class ReplaceNumberWithExcelLabel { \n public static String convertToExcelLabel (int n) { \n  String result = \"\"; \n  int index = 0; \n     while (n > 0) { \n      index = (n - 1) % 26; \n      result = Character.toChars(index + 65)[0] + result; \n      n = (n - 1) / 26; \n     } \n     return result; \n } \n  \n public static void main(String[] args) { \n  System.out.println(convertToExcelLabel(1)); \n  System.out.println(convertToExcelLabel(55)); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"in c++ code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Did this or something similar some time back, check the below link if you think this help. ms-amazon.blogspot.in/2013/03/there-is-sequence-where-alphabets-are.html"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6273556186923008","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"9","title":"Find largest palindrome in a file without altering the file (like deleting white spaces).  The palindrome def is relaxed - it allows for spaces in between words- do not bother about spaces.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First, we should read the file into a string and find the longest palindrome in this string. The best method is to use Manacher's algorithm which runs in O(N) time with extra O(N) space. I don't think an interviewer can possibly expect this in a 45min interview, i suppose a standard O(N^2) solution is expected by checking all possible centers.  My implementation of Manacher's algorithm is the following:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sample Program In java with manacher's algorithm"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Question is find longest palindrome with ignoring white space in the text. For this, I modify the Manacher's algorithm for ignoring the white space. For example:  This is the book koob eh te is had  Output: the book koob eh t"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Unless I'm missing something, use a Stack datastruction:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"in C++ code, dynamic programming"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is O(n) solution in C++ (manacher's algorithm)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6220229872975872","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"15","title":"Input : A Perl program file We need to modify the file to have a max of 80 characters per line and create a new perl file. Problem is we need to use \"/\" wherever we split the line and also, the split MUST happen at a place with white space. (ASSUMPTION - No is >75 characters)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What if there are multiple words- how will writing a last word help"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is my code. I have a feeling I'm missing something here, coz this is pure programming logic. Nothing specific to Perl."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#!/usr/bin/env python \n \nimport sys \n \n# Input : A Perl program file \n# We need to modify the file to have a max of 80 characters per line and create \n# a new perl file.  Problem is we need to use \"/\" wherever we split the line \n# and also, the split MUST happen at a place with white space. \n \ndef split_line(line, MAX_LIMIT=5): \n    \"\"\" \n    split a line, splitter is \"/\" \n \n    >>> list(split_line(\"ABCD EF\", 5)) \n    ['ABCD/', 'EF'] \n \n    # this one can't be split! \n    >>> list(split_line(\"ABCDEF\", 5)) \n    ['ABCDEF'] \n \n    >>> list(split_line(\"123456789 xyz\", 10)) \n    ['123456789/', 'xyz'] \n    \"\"\" \n \n    while len(line) > MAX_LIMIT: \n \n        # split line into words \n        words = line.split(\" \") \n        count = 0 \n        index = 0 \n \n        # find the maximum \"index\" we can afford \n        for i in range(0, len(words)): \n            count = count + len(words[i]) + 1 \n \n            if count >= MAX_LIMIT: \n                break \n \n            index = index + 1 \n \n        # combines words upto \"index\" back \n        newline = \" \".join(words[:index + 1]) \n \n        # find the leftover line \n        left = words[index + 1:] \n        line = \" \".join(left) \n \n        # is this the last chunk for this line? \n        if left: \n            yield newline + '/' \n        else: \n            yield newline \n \n    if line:  # stop returning empty string \n        yield line \n \n \nif __name__ == \"__main__\": \n \n    for line in sys.stdin: \n        line = line.rstrip() \n \n        for l in split_line(line): \n            print l"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use strict; \nuse warnings; \n \nmy $limit = 80; \nmy $NF; \nopen($NF, \">limit_op.txt\"); \nwhile (<>) { \n my $line = $_;  \n do {       \n     if ($line =~ /^(.{0,$limit})(?:(\\s+)(.*)$|$)/) {   \n  print $NF $1; \n  $line = $3; \n  print $NF \"/\\n$2\" if(length($line) > 0);   \n     }    \n } while (length($line) > 0); \n print $NF \"\\n\"; \n} \nclose($NF);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"github.com/vikhyath/python-runs/tree/master/code-formatter"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"As simple python logic is as follows :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A solution in Python"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is the simple method I could find."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#!/usr/bin/perl -w open(SRCFILE,'src.txt'); open(DESTFILE,'>dest.txt');  #a sub to do the formating if number of characters is greater than xx sub formatLine{         @words = split(' ',$_);         foreach $word(@words){                 $len += length($word)+1;                 if($len > 80){                         print DESTFILE \"\\n\";                         $len = 0;                         }                 print DESTFILE $word,\" \";         }         print DESTFILE \"\\n\"; }  while(){         chomp;         if(length($_) < 80){                 print DESTFILE $_.\"\\n\";         }         else{                 formatLine($_);         }    } close(SRCFILE); close(DESTFILE);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A perfectly working one...modified my previous post"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Algorithm can be following: 1. Read a file line by line & repeat step 2 - 7 2. Get the length of the line 3. If it is greater than 80 then split the line by white space & create array of words 4. Get the last element of the array 5. Write the array from 0 to (length - 1) including white space after every word 6. Write the \"/\" at the end 7. Write the last word of the array in the new line"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6045103118352384","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"10","title":"Explain a load balancer data structure and algorithm.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Load balancer  algorithm is an algorithm where the no of task or jobs to be processed should be less than that of threshold value. Example of some load balancing algorithm are MAX-MAX,MAX-MIN,MIN-MAX,MIN-MIN. And the values are to be consider are execution time and conclusion time. MAX-MAX is stands for maximum execution and maximum conclusion time and so on... ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Load balancing for and in what?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The data structure can have a Queue for input requests. It should also have a Heap data structure with get_min() method that returns the one with min load."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Take a look at Consistent Hashing."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #define MAX 10 main() {  int binary1,binary2;  binary1 =0100;  binary2=0111;  printf(\"%d \\n\",binary1+binary2);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Current load is not the only parameter in consideration. Sometimes a request cannot be assigned to a minimally loaded node.  More information is required to answer this question."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The function of load balancer is to distribute the load on all available backends equally. Assuming load balancer has details of load of all backends, now if new request comes it should be directed to the backend with minimum load and this can be done in O(1) using min Heap data structure.  1. Request arrives at load balancer. 2. Load balancer picks the minimum load backed and route the request to it. 3. Load balancer increases the load on this backend server and performs heapify operation. O(logn)."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4919203211509760","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"Explain a data structure for routing table and matching a route based on longest prefix match.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Wikipedia \"trie\" first.   Try to fit it into a routing data strutures.  Then on top of this, you can cache lookups somewhere (like a hTab) to speed up further lookups."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5762298849263616","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"11","title":"Given a tree (not necessary a Binary Tree) print (draw) the tree in original structure with proper formatting.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"This is a Breadth First Search(BFS) problem where you start from the Root node and print it. Then examine its children. Assuming they exist, print them on the same line and move on to examine children of both the children of the Root node.  Although BFS can be easily implemented by using a Queue to maintain a list of nodes in the order in which we reach them, the challenge lies in trying to print each node on a line on the Console that represents its level in the Binary Tree.  eg: Input is a Binary tree Root ->    1   /     \\        2       3       / \\       /  \\     4   5    6   7 Output on the console is  1 23 4567  Hope this clarifies the question."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"To draw this tree - The formatting should be done for each and every level - which in turn depends on nodes present in the subsequent levels.   Consider a hashmap with levels as keys and list of nodes as values. Add a string variable \"formatTree\"  to each node. Pass each level (BFS). As you do BFS, update the nodes of previous levels with a \"TAB\" for every 2 nodes in the current level. (If odd, one tab. Even two tabs). This will align the previous nodes properly.   In the same way, do for the next level. A print function can concatenate and print the tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What kind of formatting?  It depends entirely on this.  Example?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since it is not a binary tree, is it specified how many children does each node have?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* This can be done as a DFS problem...the recursive solution should be straightforward. \n * This is an iterative solution using stacks (for the lolz) */ \npublic class  \nDrawTree  \n{ \n public static class \n Node \n { \n  Node[] ns; \n  public Node (Node... ns) { this.ns = ns; } \n  Node[] GetChildren() { return this.ns; } \n } \n  \n /* I will try an iterative solution, since I don't do those very often */ \n /* Note: The iterative solution was harder than expected: it takes a little more effort to \n  * visualize. I ended up using multiple stacks, to track the state at each tree level */ \n public static String \n DT \n (Node root) \n { \n  List sbs = new ArrayList(); \n  int offset = 0; \n  Stack s = new Stack<>(); \n  Stack is = new Stack<>(); \n   \n  s.push(root); \n  is.push(s.size()); \n  while (s.size() > 0) { \n   Node n = s.pop();  \n   while (is.peek() == 0) is.pop(); \n   Integer siblings_remaining = is.pop() - 1; \n    \n   if (sbs.size() <= is.size()) sbs.add(is.size(), new StringBuilder()); \n   sbs.get(is.size()).setLength(offset + 1); \n   sbs.get(is.size()).setCharAt(offset, 'N'); \n    \n   is.push(siblings_remaining); \n   if (n.GetChildren().length > 0) { \n    for (int i = n.GetChildren().length - 1; i >= 0; --i)  \n     s.push(n.GetChildren()[i]); \n    is.push(n.GetChildren().length); \n   } else offset++; \n  } \n   \n  StringBuffer ret = new StringBuffer(); \n  for (StringBuilder sb : sbs) \n   ret.append(sb).append(\"\\n\"); \n   \n  return ret.toString(); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"width(Node) = sum( width(ChildNodes))  caqlculate recursively , and save it in a hashMap  widthArr[node] Using this you can calculates the coordinates of each node in a 2D space. Position[Node].x=position[firstNode].x + sum(width[ChildNodesBeforeNode ])+width[Node]/2 //position[firstNode].x =position[ParentNode].x-width[parentNode]/2+width[firstNode]/2  position[Node].y=position[parentNode].y+1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/**           6      /  |  \\     2   10  7     /  \\       \\    1   4       9      / \\   /     / |  \\     3   5 8    12  13  14    */"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's the code for pretty printing a binary tree in Python:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6534368612843520","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"14","title":"Implement a  Boolean vector: T, F, F, T, F, ?? with the following operations: append(boolean b) boolean get(int index) set(int index, boolean b) int length() Restriction: no Java collections classes  What if you knew the vector has 99.99% T and only 0.01% False. How would you change the approach?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"For the case where we don't know in advance that most elements will be T, a good approach would be to keep a growable bitset. This is a growable array of integers, used as a bitset for space efficiency. You could write a simple ArrayList implementation that initially allocates an array of integers of some small size, and every time the array runs out of space, doubles the storage and copies the existing data over to the new storage. The i-th Boolean in the collection would be stored in the (i%32)-th bit of the (i/32)-th integer, if we assume that integers are 32-bit. This data structure has O(1) amortized add, O(1) set, and O(1) get. The space usage is O(total number of values in the collection) + O(1).  If we know that very few values are F and we're interested in saving space, we can keep a number to tell us how many total T and F values we have, and then keep a hash set of all the F values. To determine the value at an index, just return !hashSet.contains(index). To set an index, remove it from the hashset if setting to true; add it to the hash set if setting to false. This data structure has O(1) expected time add, set, and get. The space usage is O(number of F values) + O(1).  In both of the above implementations, the length() operation would return, in O(1) time, a previously-stored count (that is updated in O(1) time as elements are appended)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"maybe we can just keep track of the index of the elements which are false."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use array of (int *) i.e array of array.  int * array[1024]; Use array of 128 byte , i.e 1024 bits....  Whenever 128 byte array get full. create another 128 byte array and store its address in address array.   Initially declare address array of size 1024. when it get full resize it to double and so on...... (here we are creating new address array and transferring only pointers  from old array to new array. not 1024 bits )  For boolean get(int index)   and set(int index, boolean b)  query.  use array[ int(index/1024) ][ index%1024]   for setting or getting index element."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"typedef struct bitvec  {    bool bits[1024];  /// 1024 bits per bitvec.    int count;    struct bitvec *next; } bitvec;  /// globals. bitvec *head = NULL; bitvec *last = NULL; unsigned last_bit_index = 0; unsigned append_count = 0;  bool* get_bit(unsigned index) {   /// trying to get unappended bit.   if (index >= append_count) assert(0);     bitvec *curr = head;   unsigned vpos = index/1024;    unsigned bpos = index%1024;   /// iterate to the node of interest.    while(vpos--) { curr= curr->next; }     return &curr->bits[bpos]; }  void append(bool bit)  {     /// first time appending.     if (head == NULL && last == NULL)      {        head = last =  (bitvec*) malloc(sizeof(struct bitvec));     }     /// need one more records.     if ( last_bit_index == 1023 )      {         last->next = (bitvec*) malloc(sizeof(struct bitvec));         last = last->next;     }     appendcount ++;     last->bits[last_bit_index++] = bit;  } bool get(int index) { return *get_bit(index); } void set(int index, boolean b) { *get_bit(index) =b; } unsigned len() { return appendcount; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can anyone provide a Java implementation please?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Two things here.  Notice that it said BooleanVector.  Vector is synchronized data structure, so you must call sychronized (this) block in your append and set method.   The other way to do it is to use a hashtable (thread safe).  Since the api doesn't have a remove call, so you can assume that it's always growing. You can have the index as the key and increment it as the next key, and the T/F is obviously the value.  The get would be O(1)."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5231103736545280","download_status":"DOWNLOAD_DONE","votes":"3","answersCount":"47","title":"There are n bombs in a big circle,and each bomb has a value and a 'effect range'.If you detonated a bomb,you will get this bomb's value,but a bomb can have effect on the neighbors which the distance(difference between index) between them is smaller than the 'effect range'.It's say that the neighbor bomb will be destoryed and you could not get their values. You will given each bomb's value and the 'effect range',and you need calculate the max value you can get. eg. n=3 index 0's bomb' v is 2,range is 0(will not effect others).and v[1]=1,r[1]=1,v[2]=3,r[2]=1; this case's max value is 5.(detonate the 0's and than the 2's).  HELP ME. ps: It's a interval DP.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Some of the previous solutions are wrong as discussed in the comments. Since the order matters, I'm not seeing a very efficient (polynomial) solution.  However, we can still use dynamic programming. We can pick bombs step by step, marking the bombs that we already used. Before we pick a bomb, we need to check if any of the previous chosen bombs affects it. We can use bitmasks with bit i set to 1 if we already picked bomb i, 0 otherwise.  This leads to 2^N possible states."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Let dp[i][j] be the max value from ith and jth bomb on the circle, forcing i no greater than j. Actually by denoting any kth (i <= k and k <= j) bomb, we got a precisely sub problem with smaller size, such that: dp[i][j] = Max{ dp[i][bkd] + v[i] + dp[fwd][j] } , where bkd and fwd is by denoting kth bomb, the backward and foward range that not get effected.  Note this is a circle, sequence does matter, so dp[i][j] assumes from i to j, there are bombs, but from j to i, no bombs."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"d[i]= the best value you can get at the ith bomb. d[i]=max(when the ith bomb is included, when the ith bomb is excluded) so, d[i]=max(d[j]+v[i], such that j \n   \n    \n   -  \n     alex \n     on September 13, 2013 Edit | Flag  \n    \n    \n   Reply"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Bomb N-1 is neighbor to bomb 0?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Got me puzzled for a few minutes after which I realized this:- Ever seen the MineSweeper Game on Windows OS. This is a popular game in which you find values and make sure that you bypass mines( or bombs :) ) .  Your problem is to find a WIN ( the best WIN actually) in MineSweeper. Ify ou can GOOGLE a little, you should get your answers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First, if Bomb[i] is in effective range of Bomb[j], add a directed edge from j to i. Then we can compute strongly connected components. If we looks these strong connected component as a single node, then the original graph will transform to a DAG. In each node (strongly connected component) we can only get value from one bomb. We can get values from all node (strongly connected component) by detonating bomb start from the node with zero out degree.   This is not a DP, and I am not sure if this is correct."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"will greedy algorithm work? Every time detonate the bomb that has least loss (Loss is the sum of the values of all the affected bombs). This is doable in n^3"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Let bCnt be number of remaining bombs to be detonated Let detList be an efficient datastructure that can store the detonated bombs i-> ith bomb to be exploded  det(i,bCnt,v,r,detList) { if(bCnt<=0)  return 0; else{  if i is in detList  return det(i+1,bCnt,v,r,detList);  else{   int detValue1 = det(i+1,bCnt,v,r,detList);   add i to detList along with all neigbours in range of i's detonation   int detValue2 = det(i+1,bCnt-1-2*(r[i]),v,r,detList) + v[i];   remove i and all its neigbours from detList;   return max(detValue1,detValue2);  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"in C++, dynamic programming"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can it be done this way. We first sort all bombs based on x co-ordinate, is x is same, sort on effect range. Our final solution is going to have some sequence of bombs exploding, let's say a1,a2...ak. We say that dp[i] is the solution when i is the last bomb in the sequence definitely detonated. We just calculate all other bombs from 1 to i-1 which can be detonated before i so that i can be detonated. Calculate the value obtained. That is dp[i]. Ans is max (dp[i] | 1 <=i <= n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"My python solution with memoization."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Algorithm sketch: max_bomb(v, r, denote_nothing) = max { v[i] + max_bomb(v, r, denote_i | i = 0 .. n-1}, where denote_nothing represent the initial state."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#include  \n#include  \n#include  \n \nusing namespace std; \n \nnamespace std{ \n  template \n  struct hash>{ \n    inline size_t operator()(const pair & v) const{ \n      return v.first << 8 + v.second; \n    } \n  }; \n} \n \ntemplate \nTV bomb(const vector> &bombs, const TI &i, const TI &j){ \n \n    static unordered_map, TV> mem; \n     \n    auto el = mem.find(make_pair(i, j)); \n    if (el != mem.end()){ \n        return (*el).second; \n    } \n \n    if (i > j){ \n      return 0; \n    } \n     \n    TV ei_v = bombs[i].second; \n    TR ei_r = bombs[i].first; \n     \n    TV no_ith = bomb(bombs, i+1, j); \n    TV with_ith = bomb(bombs, i+1+ei_r, j) + ei_v; \n     \n    TV local_max = max(no_ith, with_ith); \n     \n    mem.emplace(make_pair(i, j), local_max); \n         \n    return local_max; \n} \n \nint main(){ \n   vector> bombs = {{0, 2}, {1, 1}, {1, 3}}; \n   cout << bomb(bombs, 0, static_cast(bombs.size() - 1)) << endl; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"Matrix chain multiplication.  PS: negative vote people first read this algorithm and then try to relate that. you will find answer. and if you can't. just don't vote -ve"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6111168305299456","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"15","title":"Given a weighted directed graph with n vertices where edge weights are integers (positive, zero, or negative), determining whether there are paths of arbitrarily large weight can be performed in time (a) O(n) (b) O(n ??? log(n)) but not O(n) (c) O(n1.5) but not O(n log n) (d) O(n3) but not O(n1.5) (e) O(2n) but not O(n3)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Assuming that the weight of a path is simply the sum of edge weights , answer should be (d) , by using any shortest path graph algorithm like floyd warshall ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"If we change positive edge weights into negative edge weights, change negative edge weights into positive edge weights, then this problem is equal to find a path with arbitrarily small weight, there is an algorithm called \"BellmanFord\" can do this."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What does arbitrarily large weight mean?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"change the negative edge and positive to integretss"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"please explain algo"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If supremum{weights of edges} has no upper bound, then the graph is an infinite graph...  So it would take infinite amount of time to check this..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If supremum{weights of edges} has no upper bound, then the graph is an infinite graph...  So it would take infinite amount of time to check this..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-4","title":"Why don't you ask your teacher?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6121554609963008","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"How does a search engine perform exact phrase search? i.e. search for the term \"the bees knees\" exactly.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"When a phrase search is done, there could be multiple ways based on how the search engine is implemented. Will explain one way here. Each of the words of the phrases are searched on the inverted index and the posting lists of the corresponding words will all be retrieved. We can do a repeated intersection of the sets of documents in the posting lists.. In the document set where all the words are present, a more detailed search for the specific location of the word in the documents where each of these words occur. The result will have those documents that have them in the consecutive positions  in each of the documents in the specified order. Sometimes the phrases may be stored as they are too.. For instance to search phrases like \"To be or not to be\", which consists of all stopwords.. If the n gram frequencies in words or phrases are stored as in vector space models, phrase searches are simpler."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Check this link en.wikipedia.org/wiki/Inverted_index"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can anyone pls explain the entire process in searching else can anyone provide the link to learn??? because i tooo had this same question in my tech interview which i couldn't satisfy them pls..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Please elaborate the answer in simpler way"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5169800024162304","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"22","title":"design a system to return an unique ID for each request. For most of requests, the ID value should increase as time goes, the system should handle 1000 requests per second at least. timestamps alone is not valid since there might be multiple requests with same timestamps.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"The problem of generating unique IDs has been solved. All modern OS'es have that functionality built in. (And many embedded/mobile OS'es provide API's as well.)  And if asked: UUIDs may be generated from a combination of system time stamp, CPU / system unique ID, NIC MAC addresses, HBA WWNs etc.  The problem is how to serve lots of such IDs however generated. Questions to ask: What's the min length of the ID? The requirement states the system should handle 1000 request/s at least.  What's the average request rate? What's the max. burst rate the system must handle? What's the max. latency (wait time) for a request?  Let's assume the following parameters: What's the min length of the ID? <= 128 bits In that case I'll choose the standard 128 bit UUID format. The requirement states the system should handle 1000 request/s at least.  What's the average request rate? 1000 < avg req. rate < 10,000 What's the max. burst rate the system must handle? < 1,000,000 What's the max. latency (wait time) for a request? 1 ms  It's a classical consumer-producer problem. In this case we have many consumers of UUIDs and one producer. All common server OS'es have API's to create UUIDs. For embedded/mobile systems one may have to build the functions. Let's assume the OS provides an API to generate UUIDs and the max. running time of the API is 1ms. First Pre-allocate 2 Mio UUIDs into an array / stack/ heap (depending on implementation) structure.  2 Mio UUIDs ensures system can handle burst rate.  (If no overhead 2 Mio UUIDs would take ~ 32MB of RAM) Again, not a problem on today's server system with many GB of RAM, but may be a problem on an embedded system.) The solution needs to ensure that its pool of UUIDs doesn't run out as consumers request them and they are replenished."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"This question is quite open-ended.  For starter, how about appending random(N) to the timestamp? N can be large enough to make collisions unlikely. If each server has an ID we can also include it to further reduce collisions.  If IDs must be unique, then I suppose you can design a counter that will return an ID and increment it at the same time. You will then need mutex to access this counter."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I think this question check if you could use thread synchronization. 1. Create thread for each link. 2. Create a variable for record ID, after there is thread read then do self-increasing. And set thread lock for it to avoid access conflict."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"import java.util.concurrent.atomic.AtomicLong; \n \npublic class UniqueIDGenerator { \n \n static final int bufferSize = 100; \n \n AtomicLong base = new AtomicLong(); \n  \n volatile long[] buffer = new long[bufferSize]; \n \n volatile int bufferIndex = 0; \n \n UniqueIDGenerator() { \n  init(); \n } \n \n long getUniqueID() { \n  if (bufferIndex < buffer.length) { \n   return buffer[bufferIndex++]; \n  } \n  return base.getAndIncrement(); \n } \n \n void init() { \n  for (int i = 0; i < buffer.length; i++) { \n   buffer[i] = getUniqueID(); \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Typically a server sends back unique id for initial request (initial session establishment request). it depends on server design how a connection is accepted. typically acceptor is a single thread which then passes an accepted connection to workers. a unique ID can be composed of - source IP, source port, destination IP, destination port and accepted timestamp"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Suppose there are 2^m number of servers. Each request is forwarded to a random server. Each server has a local ID from 0 to 2^n-1. The m bits server ID and n bits local ID is the complete ID of each request."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a unique id can be composed of as {source-ip, source-port, dest-ip, dest-port, protocol}  we can add timestamp also along with this request."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about using good old AtomicInteger (except if you are afraid of ID wrap-arounds)?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what about generating the id with timestamp and id of thread which is handling this request?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"timestamp / n, where n between 1 and the # of requests per second.  n gets reset to 1 when timestamp changes"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Twitter has built a service called 'snowflake' to solve this precise problem. There's a very good explanation in the readme section at - github.com/twitter/snowflake/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the request ID is not required to be consecutive, a easy way can generate the unique request ID with zero collision.  If we have multi threads to generate the ID. we can give every thread a distinct ID. It is easy to implement, but you cannot use the thread id directly.  After the ID is assigned to thread. each thread can give a request a local ID. the global unique request ID is formed by TimeStamp+TheadID+LocalID."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"concatenate(time_stamp+ request_source_specs + request_handler_machine_thread_specs) . We may implement a queuing mechanism which ensures every request goes one after another and use simple counter for unique id generation, however it may become performance bottleneck."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"concatenate(time_stamp+ request_source_specs + request_handler_machine_thread_specs) . We may implement a queuing mechanism which ensures every request goes one after another and use simple counter for unique id generation, however it may become performance bottleneck."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It's just a buffering problem like online streaming. The time required to generate unique ids may be more than per request time. So if we know request rate we can learn what is the gap, and how many unique ids required to fillup that gap. Then we can use a buffer to make generate unique ids ahead, and give ids from that buffer, at the same time we continue generating ids and storing on buffer."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5678435150069760","download_status":"DOWNLOAD_DONE","votes":"4","answersCount":"63","title":"Given the array of digits (0 is also allowed), what is the minimal sum of two integers that are made of the digits contained in the array.  For example, array: 1 2 7 8 9. The min sum (129 + 78) should be 207","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Sort the array. The largest numbers should be in the least significant positions, so build up your two integers by alternating from the two arrays.  E.g. 1 3 5 7 8 9  => 1 and 3, then 15 and 37, then 158 and 379. 0 is a special case, if not allowed to use that as a leading digit then have to use it as the second digit."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"My approach was to create two vectors with alternate elements after sorting the original vector in O(nlogn) time complexity. Then sum each vector's digit. Written in C++.  Output:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"To make sum minimum, both of its operands should also be minimum. For given set of digits, a number will be minimum when smallest unused digit appears at higher positional value. Having sorted array of digits makes it easy, just give next available smallest number to higher position to each number. Code is as follows -"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void findMinSum(int[] x){ \n  Arrays.sort(x); \n  String first = \"\"; \n  String second = \"\"; \n  for(int i=0,l=x.length; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/** \n * Programming Language Used : PHP \n *  \n * This method would return the two numbers which form the minimum sum. \n *  \n * @author Varun Jalandery  \n *  \n * @param array of numbers \n * @return array of two numbers which form the minimum sum \n */ \nfunction getTwoMinimumSumFormingIntegers($array) \n{ \n    $numberOne = ''; \n    $numberTwo = ''; \n \n    sort($array); //sorting the array in ascending order \n \n    $i = 0; \n    while (isset($array[$i])) { \n        $numberOne .= $array[$i++]; \n        $numberTwo .= $array[$i++]; \n    } \n     \n    return array( \n        0 => (int) $numberOne, \n        1 => (int) $numberTwo, \n    );"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is some thing that looks easy but very tough when u check with all possible values. I have got the answer finally.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"algo would be like this: 1. Sort array O(nlogn) 2. Divide the array in two parts and add that two parts , if length of array is not even then take even no. of elements in first part and odd number of elements in second part and then add them up. - O(n) 2.a If array contain 0(zero) then take starting point of array from non zero element.  So total complexity would be O(nlogn) + O(n) = O(nlogn) Please let me know if there is an negative test case."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Sort the numbers using a linear sort (O(n)) 2. int x=0, y=0 3. While(i < n) {  if(i%2 == 0) {    x *= 10 + a[i];          } else {   y *= 10 + a[i];   }     }    min_sum = x + y;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since the sum has to be minimum, implies  1) both the numbers are supposed to in ascending order 2) length of both the numbers should be half the length of array. 3) The minimum number in the array has to be the as the starting(first) number of either of the two numbers to be found. assume 1,2,7,8,9 - then 1 has to be first number in either of the two numbers to be found (127).  Steps a) sort the array in ascending order. b) Take the first element of the array (minimum in the array) as the starting of either of the numbers to be found. c) Now first element of a number to be found is fixed. Have a global variable min initialized to a high value. d) As in the example you have to choose numbers among 2,7,8,9 and in (b) we chose 1 as a part of a number to be found. e) Now as for the (2) point one number will be of length 3, another will be of length 2. f) Get 2 numbers from the array left 2,7,8,9 to be grouped with 1 (already choosen). for instance 27 89, remember both the numbers here should be in ascending order (1). No of ways to choose two numbers here are 6 [4!/(2!*2!)]. g) Now we can have 127 and 89 or 189 or 27 sum and compare both, next 28 is chosen another will be 79 again do sum and comparision, In short this logic is exactly same as Subset sum problem (Dynamic Programming) logic, with a slight modification. Using recursion you can find the two numbers from the array 2,7,8,9 associate each of them with 1 and check whether it's minimum. h) For handling zeros in the array, after the sort neglect all the zeros and start the work with the fresh array with no zeros. 2,7,8,9  27,89 => 127,89 or 27,189 28,79 => 128,79 or 179,28 29,78 => 129,78 or 178,29  Hence the six combinations."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming all the number are position (including zero) 1) Sort the array in ascending order 2) Ignore all the leading zeros and assume that list starts from the first non-zero number 3) For all non-zero numbers, make number at position 1 first digit of first number and number at position 2 first digit of second number. Make number at position 3 the second digit of first number ans number at position 4 the second digit of second number and keep going like this until the end of list reached. Example: sorted list: 1 2 3 4 5 6 First Number: 1 Second Number: 2 First Number: 13 Second Number: 24 First Number:135 Second Number 246 Solution 135 + 246 = 381"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Python code:                                                                             a = [1, 2, 7, 8, 9] a.sort()  n1=n2=''  for i in range(0, len(a)):     if i % 2 == 0:         n1 = n1 + str(a[i])     else:         n2 = n2 + str(a[i])  print 'First number: %s'%n1 print 'Second number: %s'%n2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Python code:                                                                             a = [1, 2, 7, 8, 9] a.sort()  n1=n2=''  for i in range(0, len(a)):     if i % 2 == 0:         n1 = n1 + str(a[i])     else:         n2 = n2 + str(a[i])  print 'First number: %s'%n1 print 'Second number: %s'%n2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Three questions: Can highest magnitude digits be 0? Is the array size constrained? Can digits be duplicated in the array?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here my solution in C++... you all should handle different length for a and b giving the min sum:  int get_front_rm_front(std::vector &vec, int &ten_unit) {  int r = vec.front() * ten_unit;  ten_unit /= 10;  vec.erase(vec.begin());  return r; }  std::pair find_min_sum(std::vector &vec) {  int len_first = (vec.size() / 2) + vec.size() % 2;  int len_second = vec.size() / 2;  int first_ten_unit = pow(10, len_first-1);  int second_ten_unit = pow(10, len_second-1);  int first = 0;  int second = 0;    if(vec.size() < 2) {   return std::pair(0,0);  }    std::sort(vec.begin(), vec.end());    if(len_first > len_second) {   first += get_front_rm_front(vec, first_ten_unit);  }    while(vec.size() > 1) {   if(first > second) {    first += get_front_rm_front(vec, first_ten_unit);    second += get_front_rm_front(vec, second_ten_unit);   }   else {    second += get_front_rm_front(vec, second_ten_unit);    first += get_front_rm_front(vec, first_ten_unit);   }  }   return std::pair(first,second); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Arrays; \n \n \npublic class Minimum { \n \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n  // TODO Auto-generated method stub \n \n  int arr[]={1,2,7,8,9}; \n         \n        Arrays.sort(arr); \n                 \n        int mid=arr.length/2; \n        int remainder=arr.length%2; \n        int power=mid; \n        int sum=0; \n        int count=0; \n        if(remainder==1) \n        { \n         sum+=arr[0]*Math.pow(10, power); \n         //System.out.println(sum); \n         power--; \n         for(int i=1;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"After sorting the array: Basically there are two cases: 1) If the number of digits are even: first two digits are multiplied with 10^(mid-1) each and added second two digits are multiplied with 10^(mid -2) each and added and so on.. 2)odd: first digit is multiplied with 10^mid.. and so on as in 1 above The theory is digit at highest place value should be least for both numbers.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private int minSum(int[] a) { \n //checks on null \n if(a == null || a.length == 0) { \n  return -1; \n } \n int length = a.length; \n if(length == 1) { \n  return a[0]; \n } \n \n Array.sort(a); \n int nonZeroInd = getNonZeroInd(a); \n \n if(nonZeroInd == length - 1) { \n  return  getOneNonZeroSum(a); \n } \n \n if(nonZeroInd > 0) { \n  swapZeros(a, nonZeroInd); \n } \n \n return getSum(a); \n} \n \nprivate int getSum(int[] a) { \nint sum1 = 0; \n int sum2 = 0; \n \n for(int i = 0; i < length; i++) { \n  if(i % 2 == 0) { \n   sum1 = sum1 *10 + a[i]; \n  } else { \n   sum2 = sum2 * 10 + a[i]; \n  } \n } \n return sum1 + sum2; \n \n} \n \nprivate void getNonZeroInd(int[] a) { \n int len = a.length; \n int nonZeroIndex = 0; \n for(int i = 0; i < length; i++) { \n  if(a[i] != 0) { \nnonZeroIndex = i; \nbreak; \n  } \n } \n return nonZeroIndex; \n} \n \nprivate int getOneNonZeroSum(int[] a) { \n int len = a.length; \n int sum = a[len - 1]; \n int zeros = Math.pow(10, len - 2); \n return sum * zeros; \n} \n \nprivate void swapZeros(int[] a, int nonZeroInd) { \n int len = a.length; \n swap(a, 0, nonZeroInd); \n swap(a, 1, nonZeroInd + 1); \n} \n \nprivate void swap(int[] a, int i, int j) { \n int temp = a[i]; \n a[i] = a[j]; \n a[j] = temp; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  #include   #define MAX_SIZE 10  void sort_arr(int arr[], size_t aSize) {     int i, j, temp;      for ( i = 0; i < aSize - 1; i++)     {         for (j = i + 1 ; j < aSize  ; j++)         {             if ( arr [ i ] > arr[j ] )             {                 temp = arr[i];                 arr[i] = arr[j];                 arr[j] = temp;             }         }     } }   int make_min_sum(int arr[], int size) {     int i=0;     int num1=0, num2=0, temp;    while ( i < size )   {       while ( i <= size /2)       {           if ( i == size / 2)           {               num1 = num1 + arr[size -1];               num1 = num1 * 10;               temp = i++;               break;           }           num1 = num1 + arr[i];           num1 = num1 * 10;           i++;       }        if ( i == size -1)       {         num2 = num2 + arr[temp];         num2 = num2 * 10;         break;       }        num2 = num2 + arr[temp];       temp = i;       num2 = num2 * 10;       i++;   }    return (num1 + num2) / 10; }  int main(int argc, char **argv) {      int  arr[MAX_SIZE];     char str[3];     int  sum, size = 0;     int i, i_val, num;      printf(\"Enter number\");     gets(str);     num = atoi(str);      while (num != 0)     {         i_val = num % 10;         arr[size++] = i_val;         num = num /10;     }          sort_arr(arr, size);          printf(\"arr elements are after sort:\\n\");     for ( i = 0; i < size; i++)         printf(\"%d\", arr[i]);      sum = make_min_sum(arr, size);      printf(\"min sum :%d\\n\", sum);      return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Arrange the elements in array in ascending order 2) make two sub arrays with half of the length each ( if total digits are 6, one with 3 and other with 3 and if total is 5 one with 3 and other with 2). 3) Now lowest element to first array and then next lowest to second and so on. 4) Logic is simple, we should have lowest values in most significant bit.    Below program is in java. I just written so casually. but it gives the solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.  If Array Length < 2 return 0 //invalid case \n2.  Sort the array \n3.  Let num1 and num2 be the two required numbers. \n4.  startingIndex = 2 => To adjust for the case where the array may have odd number of elements,  \n  process first two OR three elements as a special case. \n \n5.  if array length is odd:- \n // process first three elements \n 5.a num1 = array[0]*10 + array[1]; \n 5.b num2 = array[2]; \n 5.c startingIndex ++; \n  \n \n6.  else \n // process first two elements \n 6.a num1 = array[0] \n 6.b num2 = array[1] \n \n7. Now the remaining array is of even length, process next two elements at a time, adding first element to num1 and second to num2. \n  for(int i = startingIndex;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's my attempt, done in Java."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int minSum(vector& v) { \n \n sort(v.begin(), v.end()); \n int a[2] = {0}; \n \n for (int i = 0; i < v.size(); ++i) { \n  a[i%2] = (a[i%2]*10)+v[i]; \n } \n \n return a[0] + a[1]; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"only sum is asked no need to generate both the numbers"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"instead of starting from the start of the sorted array we can try from end please find the algo  1) sort the array 2)two numbers A,B(initialize to 0) 3)A=last element of array 4)i=last-1 5)if(i<0) return (A+B) 6)if(A7)A=pow(10,lengthof(A)) + array[i], goto 9 8)B=pow(10, lenghtof(B)) + array[i] 9)i--; goto 5."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I found a simple solution  Array : {1 2 7 8 9}  Assumption : Array is sorted   Output : need to construct the 2numbers from array numbers such that sum is min  Solution :  1)num1=num2=0 2)mul1=mul2=1 3)for(int i=0;i  {     if(i%2 = 0 && arr[i] !=0)      {  num1=arr[i]*mul1 ;  mul1*=10;      }      else if(arr[i]!=0)      {  num2=arr[i]*mul2;  mul2*=10;      }    } 4)Print num1 and num2  5) So min sum is num1+num2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def mini_sum(A): \n    n = len(A) \n    if n == 0: \n        return 0 \n    A.sort() \n    if n % 2 == 1: \n        total = A[0] \n        start = 1 \n    else: \n        total = 0 \n        start = 0 \n    for i in xrange(start, n, 2): \n        total = total * 10 + A[i] + A[i+1] \n    return total \n \nA = [1, 2, 7, 8, 9] \nprint(mini_sum(A))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"- Remove the zeros - Sort the the digits - First number will be number formed with digits with even indices - Second number will be number formed with digits with odd indices  For example, if input is 845101420023  When the zeroes are remove it becomes  845114223 When it is sorted it becomes 112234458 First number: 12348 Second number: 1245"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Suppose this array is sorted. coding as below. #include   #define ARRAY_NULL 1 int main(int argc, char **argv){     if(array = NULL){         return ARRAY_NULL;     }     int first_int = 0;     int second_int = 0;     int length;          length = sizeof(array);     for(int i = 0; i < length; i++){         if(i % 2){             first_int = first_int * 10 + array[i];         }         else{             second_int = second_int * 10 + array[i];         }     }     printf(\"The least sum number is : %d = %d + %d\\n\", first_int+second_int, first_int, second_int);     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Suppose this array is sorted. coding as below. #include   #define ARRAY_NULL 1 int main(int argc, char **argv){     if(array = NULL){         return ARRAY_NULL;     }     int first_int = 0;     int second_int = 0;     int length;          length = sizeof(array);     for(int i = 0; i < length; i++){         if(i % 2){             first_int = first_int * 10 + array[i];         }         else{             second_int = second_int * 10 + array[i];         }     }     printf(\"The least sum number is : %d = %d + %d\\n\", first_int+second_int, first_int, second_int);     return 0; }  If this array not be sorted, we will sort it first."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Sort the array. 2. Use two temporary number for the two integer. Append the next digit to them in turn. 3. Use a temporary variable to remember the leading 0s. When the first non-zero digit is found, add it to the head."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int findMinimum(int[] arr) {   Arrays.sort(arr);   int i = 0;   while (arr[i] == 0) {    i++;   }   if (arr.length - i < 2) {    return -1;   }   swap(arr, 0, i);   swap(arr, 1, i + 1);   int value = 0;   int start = 0;   if (arr.length % 2 == 1) {    value = arr[0];    start++;   }   for (int k = start; k < arr.length; k += 2) {    value = 10 * value + arr[k] + arr[k + 1];   }   return value;  }   private static void swap(int[] arr, int i, int j) {   int temp = arr[i];   arr[i] = arr[j];   arr[j] = temp;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  #include  using namespace std;  int min_sum(int *a, int len) {     int size= len-1, flag=0;     int unit1=0,unit2=0,tens1=0,tens2=0,hundreds1=0,hundreds2=0;     int thousands1=0,thousands2=0,tenthousands1=0,tenthousands2=0;     int num1=0,num2=0;      cout << \"Total number of elements in array =\" << len << \"\\n\";          unit1=a[size]; size--;         //cout << size;         unit2=a[size]; size--;         //cout << size;      if (size>=0)     {         tens1=a[size];         size--;      }      if (size>=0)     {         tens2=a[size];         size--;        }       if (size>=0)         hundreds1=a[size]; size--;      if (size>=0)         hundreds2=a[size--];      if (size>=0)         thousands1=a[size--];      if (size>=0)         thousands2=a[size--];      if (size>=0)         tenthousands1=a[size--];      if (size>=0)         tenthousands2=a[size--];       num1 = unit1 + tens1 * 10 + hundreds1 * 100 + thousands1 * 1000 + tenthousands1 * 10000;     num2 = unit2 + tens2 * 10 + hundreds2 * 100 + thousands2 * 1000 + tenthousands2 * 10000;      for (int i=0;i    {         if (a[i]==0)             flag++;     }  int t1=num1,t2=num2;  while(t1) {     t1=t1/10;     cout << \"\\n t1=\" << t1; }      if(flag--)         num2=num2 * 10;     if(flag--)         num1=num1 * 10;      cout << \"The two numbers which form min sum are:\\n\" << num1 << \"\\t\" << num2 << \"\\n\";     cout << \"Minimum sum required = \" << num1+num2 << \"\\n\";      return 1;  }  int sort_it (int *a, int len) {      int i,j,temp;     for (i=0;i    {         for (j=0;j        {             if (a[j]>a[j+1])             {                 temp=a[j];                 a[j]=a[j+1];                 a[j+1]=temp;             }         }     }      cout<< \"\\n{\\t\";      for (int i=0; i    {       cout << a[i]<< \"\\t\";     }      cout<< \"\\t}\\n\"; }  int main() {     int array[]= {1,9,0,2};     //{9,2,7,5,7,2,1,5,4,6};     //{1,3,5,3};     //{1,2,7,8,9};     //{ 2,7,6,5,3,4,8,9,1};         int len= sizeof(array)/sizeof(array[0]);       cout<< \"{\\t\";      for (int i=0; i    {       cout << array[i]<< \"\\t\";     }      cout<< \"\\t}\";      sort_it(array,len);     min_sum(array,len);      return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \nusing namespace std; \n \nint min_sum(int *a, int len) \n{ \n    int size= len-1, flag=0; \n    int unit1=0,unit2=0,tens1=0,tens2=0,hundreds1=0,hundreds2=0; \n    int thousands1=0,thousands2=0,tenthousands1=0,tenthousands2=0; \n    int num1=0,num2=0; \n \n    cout << \"Total number of elements in array =\" << len << \"\\n\"; \n \n        unit1=a[size]; size--; \n        //cout << size; \n        unit2=a[size]; size--; \n        //cout << size; \n \n    if (size>=0) \n    { \n        tens1=a[size]; \n        size--; \n     } \n \n    if (size>=0) \n    { \n        tens2=a[size]; \n        size--; \n       } \n \n \n    if (size>=0) \n        hundreds1=a[size]; size--; \n \n    if (size>=0) \n        hundreds2=a[size--]; \n \n    if (size>=0) \n        thousands1=a[size--]; \n \n    if (size>=0) \n        thousands2=a[size--]; \n \n    if (size>=0) \n        tenthousands1=a[size--]; \n \n    if (size>=0) \n        tenthousands2=a[size--]; \n \n \n    num1 = unit1 + tens1 * 10 + hundreds1 * 100 + thousands1 * 1000 + tenthousands1 * 10000; \n    num2 = unit2 + tens2 * 10 + hundreds2 * 100 + thousands2 * 1000 + tenthousands2 * 10000; \n \n    for (int i=0;ia[j+1]) \n            { \n                temp=a[j]; \n                a[j]=a[j+1]; \n                a[j+1]=temp; \n            } \n        } \n    } \n \n    cout<< \"\\n{\\t\"; \n \n    for (int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Slightly different approach than much of what has already been posted.  1) Assume that the list is sorted 2) Note that when we do our sum, digits in the same position can exist in either number and provide the same result: eg, 145 + 39 vs 135 + 49.  This solution provides only the sum, not the list of possible ways to get there. 3) backtrack through the numbers to put digits in their right spots right away"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If we assume that numbers starting with 0 (like 017) are invalid, that doesn't mean we should throw out all zeros, as someone previously stated. We could still have 107. In this case after you do your initial sort you should move the zeros so they start at the 3rd index, and move the first 2 integers after the zeros the the first two index.  You can check out the Matlab code at my blog meditationsofmarcus.blogspot.com.  I'll also include it here. I didn't try to make it very clean:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Firstly, the elements in the array can belong to a finite set {0-9}. So, instead of sorting the array, just a class that can handle such frequency distribution will do. Creation of an instance and population of data will take place in linear time Secondly, allowing 0 in the input array makes sense only if leading zeros were not allowed, otherwise, a linear time pre-processing can get rid of all the zeros. So, I have made a separate function to handle such a case which is invoked only if leading zeros are not allowed  Input format :  t //number of test cases {//each test case n//number of elements in array za//=1 if leading zeros are not allowedother wise !=1  ith element of array } test cases that I have tested upon :  6 5 0  1 2 7 8 9 5 1  0 2 7 8 9 5 1  1 8 2 9 7 5 1  0 0 0 6 7 5 0  0 0 0 6 7 10 1  9 2 7 5 7 2 1 5 4 6 Expected output: 207//as given 287//208+79 : leading zero not allowed 207//just another permutation of given test case 670//600+70 : leading zero not allowed 13//006+07 : leading zero allowed 37146//12567+ 24579  Code :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/** \n * Programming Languguage Used : Java \n *  \n * This method will print the two numbers which form the minimum sum. \n *  \n * @author Vincent Sam  \n *  \n * @param array of numbers \n * @return void (prints the two numbers which form the minimum sum). \n *  \n */ \npublic static void getMininalSum(int[] digits) { \n int minSum = 0, i = 0; \n int len = digits.length; \n StringBuilder op1 = new StringBuilder(), op2 = new StringBuilder(); \n   \n Arrays.sort(digits); \n while (i < len) { \n  if (i%2==0)   op1.append(digits[i++]); \n  else   op2.append(digits[i++]); \n } \n minSum = (len > 0) ? Integer.parseInt(op1.toString()) + Integer.parseInt(op2.toString()) : 0; \n System.out.printf(\" The minimal sum of %s, %s = %d \\n\", op1.toString(), op2.toString(), minSum);  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int[] a = { 1, 2, 7, 8, 9 }; \n   \n  Arrays.sort(a); \n \n  int x = 1; \n  int i = a.length - 1; \n  int sum = 0; \n  while (i >= 1) { \n   int digit1 = a[i--]; \n   int digit2 = a[i--]; \n   sum += digit1*x +digit2*x; \n   x*=10; \n  } \n   \n  sum+= a[0]*x; \n   \n  System.out.println(sum);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"int[] arr={1,5,8,2,6,9,2,4,2,0,0,0}; \n Arrays.sort(arr); \n int arrlen=arr.length; \n String fStr=\"\"; \n String lStr=\"\"; \n for(int i=0;i"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6347067874082816","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"46","title":"How will you find if a string is a substring of another string in O(n) complexity. For example, \"tl\" is substring of bottle.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"DO KMP."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You need to use a Trie suffix tree It can be done with O(n) when n is the length of the long string Then we just check if the short string exists in the suffix tree O(m) where m is the length of the short string"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"KMP, RK, BM"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"C++ Rabin-Karp implementation. O(n+m) time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class SubString { \n \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n  // TODO Auto-generated method stub \n \n  String complete=\"botytytle\"; \n  String check=\"tl\"; \n  int flag=0;int j=0; \n  for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This looks like a typical language detection problem for a Turing Machine.  Code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Thanks for correcting."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void checkSubString(String full, String part){ \n  int pos = 0; \n  for(int i=0,l=full.length(); i 0){ \n    i -= pos; \n    pos = 0; \n   } \n  } \n  System.out.println(\"Not Found!\"); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) { \n   \n  String str=\"Writing Code? Surround your code with\"; \n  String s=\"de?\"; \n  boolean res=false; \n  char[] cStr=str.toCharArray(); \n  int len=cStr.length; \n  int slen=s.length(); \n  int h=slen-1; \n  int l=0; \n  int j=0; \n  String st=\"\"; \n  while(h"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here we build the hash with all the suffixes of the longer string. Only the keys are truncated to the size of smaller string. Time Complexity O(N) with a hash ofcourse. Written in Python."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def FindString(String, subString): \n    pLen = len(subString) \n    pString = '' \n    found = False \n    if pLen > 0: \n        for i in range(len(String)): \n            pString = String[i:i+pLen] \n            if pString == subString: \n                return True \n    return found \n \n \ndef PrintMatch(String, subString): \n    if FindString(String, subString):  \n        print \"Found %s inside %s\" %(subString, String) \n    else: \n        print \"No match Found. \" \n         \n \nPrintMatch('bottle', 'tl') \nPrintMatch(\"dceababac\", \"abac\") \n \nFound tl inside bottle \nFound abac inside dceababac"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorry guys, my previous code had a little bug in that .... Here is the updated version ..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) { \n   \n  String str=\"aaabaabaazb\"; \n  String s=\"aabaab\"; \n  boolean res=false; \n  int len=str.length(); \n  int slen=s.length(); \n  int h=slen-1; \n  int l=0; \n  int j=0; \n  int ctr=0; \n  String st=\"\"; \n  while(h"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Doubt Google committee would like this being asked in an interview."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I tested with str = \"aaabbc\", subStr = \"aabc\", and it worked fine (with correction)!  I found that my algorithm fails, and I know why, in these tests: str = \"satatab\", substr= \"atab\" and str = \"dceababac\", substr = \"abac\"."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sorry little better tdtdtdc and search for tdtdc"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There is a different version of KMP that is a little space inefficient, but does the trick in O(n) time anyways. It involves creating a DFA which can be run on the input text in linear time to identify if the given pattern in a substring. I could code it in 5 min...so hopefully doing so in an interview in 20 min should not be a problem.   I have not checked the code very exhaustively, so please let me know if there are any bugs."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ai Diegao!!!!  C++ Implementation of Knuth Morris Pratt algorithm might do the trick. By not going back to the begining of the main sentence whenever we have a partial match that ends up becoming a failure.   This should be O(n+m) -> O(m) to pre-process(failureFunction) the pattern and O(n) to go through the sentence once."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simple Rabin-Karp implementation in Python with a (fairly naive) running hash function..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"String s = \"abxdefgh\"; \n  String sub = \"xdef\"; \n   \n  int matchCount =0; \n  int j = 0; \n  for (int i = 0; i < s.length(); i++) { \n   if(s.charAt(i) == sub.charAt(j)) { \n    matchCount++; \n    j++; \n   }else { \n    j =0; \n    matchCount =0; \n   } \n    \n   if(matchCount == sub.length()) { \n    System.out.println(\"Found a match\"); \n    return; \n   } \n    \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"String pattern = \"abac\"; \n  String text = \"dceababac\"; \n \n  int patternLength = pattern.length(); \n \n  for (int textIndex = 0; textIndex < text.length(); textIndex++) { \n \n   if (textIndex + patternLength <= text.length()) { \n    String subString = text.substring(textIndex, textIndex \n      + patternLength); \n    if (pattern.equalsIgnoreCase(subString)) { \n     System.out.println(textIndex); \n    } \n   } \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I think it ensures O(n) time complexity:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"This will run in O(n) time complexity, please comment if something wrong.  private static boolean checkIfSub(String str, String sub)  {   if(str==null)    return false;      if(sub==null)    return true;      if(sub.trim().length()>str.trim().length())    return false;      int j=0;     boolean isSub = true;   for(int i=0;i  {       if(str.charAt(i) == sub.charAt(j))    {     isSub = true;     j++;    }    else if(j==sub.length()-1)    {     isSub = true;     break;    }    else    {     isSub = false;     j=0;    }   }     return isSub;  } }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6317247647711232","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"10","title":"Everyone knows that finding a loop in the single linked list is using runner and follower method. Could you provide mathematical proof of correctness for it and why it works.  I said something like induction hypothesis. Someone help me with the correct answer.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Here's my attempt. If there's a loop, then we know eventually both pointers would have fallen into the loop. Assume the loop consists of N nodes. Let the current position of the fast-moving pointer (the one that moves 2 steps) be 0, and let that of the slow-moving pointer (the one that moves 1 step) be P. In other words, consider the slow-moving pointer as P nodes ahead of the fast-moving one.  After \"t\" iterations, the positions of the fast & slow pointers will be: (2t) % N (P + t) % N  Note that both values would be the same when t is P, so by having a fast and slow moving pointers we are guaranteed they would eventually meet."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My first question - are such questions asked to college freshers or even to experienced candidates with professional background?  I am not sure what do you mean by 'induction hypothesis' and how can you use induction.  How we detect loop is    Let's say that there're two pointers r (for rabbit) and t (for tortoise)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assume the loop has 'n' nodes. Let the node in the loop that runner first lands at be 'N'. After 'i' iterations, runner would be 2*i % n nodes away from N.  Assume the follower arrived at N, 'k' iterations behind the runner. After 'i' iterations (we are interested only in i >= k), follower would be (i - k) % n nodes away from N.  The question is now reduced to proving that for any 'k' there exists an integer 'i' such that,  2*i % n = (i - k) % n => 2i = i - k + cn (where c is any integer) => i + k = cn  Since we are interested in only non-negative 'k' and i > k, i = cn - k, where c is any integer > k/n"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Let x be the number of iterations. 2x for double case. P be the pth node you are visiting.   Let s be the number of nodes in a linked list that are singled.  Let c be the number of nodes in a linked list that are cyclic. As in going to c+1th node will put you at position c+1 again.   So we are proving equation:  s + ( x -s ) % c = s + ( 2* x - s ) % c  s and c can be any constant.  x is variable.  ( x - s) % c = (2 * x - s ) % c  let x = c ( c - s ) % c = ( 2 * c - s ) % c  if c > s then this will be true as you will get c -s = c - s if s > c then we can still prove this just let x = some multiple * c which is greater than s."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is another mathematical proof.  Imagine two positions are in loop separated by 'z' distance within the loop, where `z < n` where 'n' is number of elements in loop.  We can say that, after 'm' iteration, two positions will be:  m%n (2*m+z)%n  Now, we need to prove that for any 'z' and 'n', there is always a 'm' which can make above two equations equal. Lets find that m:  m%n = (2m+z)%n opening mod  |2m+z - m| = cn where c E [0, inifnity) |m+z| = cn  since z < n m= n - z  So two positions separated by 'z' distance within a loop, will always meet if one proceed 2* of other after n-z iteration."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"you can think like this. the faster step is x. and the slower is y. when the come into the loop. their distance is d(y ahead x, it's a circle). so if we want they meet, we should make this formula stands. (a(x-y))%n = d am%n = d 0 < d < n; a is a variable. so how can it always stands? m and n is must be relatively prime. 1 will be always relatively-prime with any positive number. so (x=2,y=1) would be a not bad choice"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Suppose the link has a loop with length N. Suppose that when the follower enters the loop, the runner needs to walk distance k to catch the follower (or the following is N-k distance after the runner.  If k = 0, the runner and the follower meet. We have a loop.  Otherwise, in each step, the runner moves 2 steps, while the follower moves one step, the distance between the runner and the follower decreases by 1.  After k steps, the runner can eventually catch the follower."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This needs proof?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6411159859101696","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"38","title":"Suppose there were n numbers in an array S1, S2, S3, S4.......SN rearrange them in a such a way that they satisfy bellow property.                                            S1S3......","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"a preliminary solution can be to just sort the array and then push the last (n/2) elements at the even positions in any order and the condition will hold good complexity O(nlogn)  or you can use selection algorithm for median finding and then push the number greater than median at even positions and others at odd position  complexiy O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"sort the array and swap the positions. this'll not work if the elements are repeated.      sort(a, a+n);     cout << endl;     cout << \"numbers entered (sorted) \" << endl;      for(int i = 0; i < n; i++) {         cout << a[i] << \" \";     }          cout << endl;     cout << \"ordering based on < and > ... \" << endl;     for(int i = 1; i < n - 1;) {         swap(a[i], a[i+1]);         i += 2;     }          for(int i = 0; i < n; i++) {         cout << a[i] << \" \";     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":">>One handling could be if a[i] == a[j] then swap a[i] with last element also keep a pointer to it say k. No wrongly wrote this. and the code mentioned also doesn't handle \"==\" case well.  Good solution would be scan till end untill we find a different element and then swap with a[i] and then continue code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sort(a, a+n); \n    cout << endl; \n    cout << \"numbers entered (sorted) \" << endl; \n \n    for(int i = 0; i < n; i++) { \n        cout << a[i] << \" \"; \n    } \n     \n    cout << endl; \n    cout << \"ordering based on < and > ... \" << endl; \n    for(int i = 1; i < n - 1;) { \n        swap(a[i], a[i+1]); \n        i += 2; \n    } \n     \n    for(int i = 0; i < n; i++) { \n        cout << a[i] << \" \"; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we don't need to sort all the array, all the even indexed elements are greater then its odd indexed  neighbor , so we can just split the arrays half half, the right ones are all greater than left ones.   public static void reArrange(int arr[]){   int targetIndex = (arr.length-1)/2;   reArrageArry(arr,0,arr.length-1,targetIndex);   int start = targetIndex + 2;   for(int i=0;i   int tem=arr[i+1];    arr[i+1]=arr[start+i];    arr[start+i]=tem;   }   for(int i = 0 ; i < arr.length; i++){    System.out.print(arr[i]+\" \");   }     }  private static void reArrageArry(int arr[],int start, int end,int targetIndex){   if(start==end)    return;   int part = partition(arr,start,end);   if(part==targetIndex)    return;   if(part>targetIndex){     reArrageArry(arr,start,part-1,targetIndex);   }else{    reArrageArry(arr,part+1,end,targetIndex);   }     }  private static int partition(int arr[],int start, int end){   int pos = arr[end];   int i =  start-1;   int j = start;   while(j   if(arr[j]<=pos){     i++;     int tmp = arr[i];     arr[i]=arr[j];     arr[j]=tmp;    }    j++;   }   arr[end]=arr[i+1];   arr[i+1]=pos;   return i+1;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"have a look it as simple at all ... if any error plz report :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I don't think there is any need to sort the array. This can be done in single pass. Look at the below code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what if the numbers are not sorted already?   I think we need to add all numbers to  binary search tree and recursively print in following order.  Print left, right and then root - for each sub tree in the bst complexity - O(nlogn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"question doesnt look so clear .. 1. does it have duplicate elements ?  2. does it has number of duplicate elements > (n/2) -> n being number of elements in the array ? 3. if above 2 is correct, then we cant satisfy > < , instead we may need >= , <= somewhere ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java Code Complexity: O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how about find the median by partitioning and continue picking one from either side ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If you look at the merge sort algorithm you will see this step. O(nlogn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For simplicity, suppose we have 2N elements and that the array A is indexed from 1 to 2N.  Sort the elements in increasing order then swap A[2*(i+1)] with A[2*N-(2*i+1)] for i=0 to (N-2)/2 when N is even i=0 to (N-3)/2 when N is odd  So the running time is simply O(sort) + O(N), which if they are all integers, should be O(N)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The Algorithm will take O(N) time and O(Constant) space. Python."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int spl_sort(int *a, int len) \n{ \n    int temp; \n    int loop_length=len; \n \n    if (loop_length%2) \n    { \n        for (int i=1;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The below code will work in O(n), but not handle the duplicates.   {{ public static void reOrder(int[] A){    boolean smaller = true;  for (int i = 1; i  if ((smaller && A[i-1] > A[i]) || (!smaller && A[i-1] < A[i])){    int tmp = A[i];    A[i] = A[i-1];    A[i-1] = tmp;   }   smaller = !smaller;     } } }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The following code works in O(n), but does not handle duplicates."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is some working Java code. It works well with all test cases suggested in this thread.  (1) Sort array in ascending order (using Quicksort in this case). O(n log n) (2) Pick one element from begin and one from end. (3) if last added element violates the rule, swap it with element X (for even positions) or X+1 (for odd positions), where X starts from 0 and is incremented with +2 after every swap."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming unique values, sort the entire array. Then place a pointer at the front and the back. S1 will be the first value in the array, S2 will be the last value in the array. Move both pointers forward by one. Then follow the above procedure."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Construct a binary seach tree with the elements and do traverse tree in left-right-parent"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Use median of medians to find the middle, move it to middle, then recursively do same in each half.  Of course we can handle border cases as they are trivial for me also.  Giving more exact steps is beneath me.   I am a codechef topper."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Use median of medians to find the middle, move it to middle, then recursively do same in each half.  Of course we can handle border cases as they are trivial for me also.  Giving more exact steps is beneath me.   I am a codechef topper."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Use median of medians to find the middle, move it to middle, then recursively do same in each half.  Of course we can handle border cases as they are trivial for me also.  Giving more exact steps is beneath me.   I am a codechef topper."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"1.) Sort the array. 2.) Starting from second element, swap 2nd and 3rd element, 4th and 5th element and so on."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6227714491023360","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"54","title":"suppose a string is consists of a, b, and c Now given a integer N, output the amount of all possible strings of length N that don't of have consecutive a,b,c. e.g. given N=5, string bacca is invalid since the first 3 letters have consecutive a,b,c. and bbbbb is valid.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"f1(n) is the number of strings with the last two char same; f2(n) is the number of strings with the last two char different; f1(n)=f1(n-1)+f2(n-1); f2(n)=2*f1(n-1)+f2(n-1); f1(2)=3; f2(2)=6;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"f1(n) is the number of strings with the last two char same; f2(n) is the number of strings with the last two char different; f1(n)=f1(n-1)+f2(n-1);------------------1 f2(n)=2*f1(n-1)+f2(n-1);----------------2 f1(2)=3; f2(2)=6;   Now, f(n)=f1(n)+f2(n) =>f(n-1)=f1(n-1)+f2(n-1)=f1(n)=========from 1------------3  =>f(n)=f(n-1)+f2(n) =>f(n)=f(n-1)+2*f1(n-1)+f2(n-1)=======from 2 =>f(n)=f(n-1)+(f1(n-1)+f2(n-1))+f1(n-1) =>f(n)=f(n-1)+f(n-1)+f1(n-1) =>f(n)=f(n-1)+f(n-1)+f(n-2) =>f(n=)2*f(n-1)+f(n-2)  Also, f(2)=f1(2)+f2(2)=3+6=9 f(1)=f1(2)=3  This final solution is f(n)=2*f(n-1)+f(n-2), f(1)=3, f(2)=9"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the problem can be solved using RabinKarp Algorithm, Here is the code. Please tell me if I have done any error."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can use Dynamic Programming , Let define T[n,'ab'] be the number of valid strings of length n which starts with 'ab', in the same way we can define T[n,'bc'], T[n,'aa'], T[n,'ba'] .... Then T[n,'ab'] = T[n-2,'bc]+T[n-2,'ba']+T[n-2,'bb]+T[n-2,'aa']+T[n-2,'ac']+T[n,'ab'] in the same way we can calculate for the rest for n = 2 and n=3 which are the base cases we can calculate them easily, The running time would be O(n) and the storage space is O(n) too"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question asks to \"output the amount of all possible strings\", so I haven't quite answered that below; rather, I've outputted all possible strings. I believe this solution is essentially what HoneyBall was describing."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"As there are N spaces available and we have 3 unique things to choose from so to print all different combinations we have only one choice 3*3*3*3*3 (no of iterations) But we got no other choice. However if we don't want sequence then we can simply ignore the cases in which we get a sequence.  Here is the code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Considering that all the generated permutations of length N can have repeated characters then here is a simple solution written in Ruby:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"f(0)=0 f(1)=3 f(2)=9 f(n) = f(n-1) + 2*f(n-2) + 2*f(n-3) + ... + 2*f(4) + 24"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void findSolutions(String word, int n) {   char[] letters = word.toCharArray();   int sum = getSum(letters);   findSolutions(letters, n, \"\", sum);  }    private static void findSolutions(char[] letters, int n, String result, int sum) {   if (result.length() > 2 && getSum(result.substring(result.length() - 3, result.length()).toCharArray()) == sum) {    return;   }   if (result.length() == n) {    System.out.println(result);   } else {    for (int i = 0; i < letters.length; i++) {      findSolutions(letters, n, result + letters[i], sum);    }   }  }    private static int getSum(char[] lookUp) {   int sum = 0;   for (int i = 0; i < lookUp.length; i++) {    sum += lookUp[i];   }   return sum;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can use backtracking:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Recursive solution. If the last two characters are distinct we should use only them as the next character."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Let a=0, b=1 and c=2. Let counts[m][i][j] be the number of valid strings with length m+1, and the last 2 characters being what i & j would correspond to. For instance, counts[1][0][2] would be the number of valid strings with length 2, where the last 2 characters are \"a\" and \"c\". In this case, there's only 1 such string so counts[1][0][2] would be 1. We can then use dynamic programming to fill up this multi-dimensional array to compute the number of valid strings of length N.  Below is my Java code for doing so. Note that it can be improved in at least 2 ways: (1) Leverage the symmetry so instead of computing for all \"a\", \"b\" and \"c\", we only compute one of them and multiply result by 3. (2) After calculating the new values for each iteration \"m\", we don't need all the old values at iteration \"m-1\" anymore. So we can reuse that array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static boolean check (String s) {        char ch[]=s.toCharArray();         boolean flag = true;         int clen= ch.length;         if (clen<3) { flag=false; }         // System.out.println(\"String length is \" + clen);          for (int i=0;i         {if (ch[i]!=ch[i+1] && ch[i]!=ch[i+2] && ch[i+1]!=ch[i+2])             { return false; }            }           return true; }   ///is this code right?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This question asks \"the amount of\", so the answer should be some value. In here, I would like to show O(N) answer.  Let's define functions A,B and C  A(N) is  the amount of all possible cases a string is consists of a, b, and c with length N B(N) is  the amount of all possbile cases a string is consists of a, b, and c with length N have consecutive a,b,c C(N) is the amount of all possible strings of length N that don't of have consecutive a,b,c  A(N) = 3^N B(N) = C(N-2) * Combination(N, 3)          = C(N-2) * (N ) * (N  - 1)* (N -  2) / 3 * 2* 1    C(0) = 1 C(1) = 1 C(2) = 1 C(N) = A(N) - B(N)  We can caclurate C using DP."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) {   char[] chars= {'a', 'b', 'c'};   int N = 5;   char[] ret = new char[N];   print(ret, chars, N, 0);  }    private static void print(char[] ret, char[] chars, int size, int idx) {   if (size == 0) {    for (int i = 0; i < ret.length; ++i)     System.out.print(ret[i]);    System.out.println();    return;   }      for (int i = 0; i < size; ++i) {    for (int j = 0; j < chars.length; ++j) {     ret[idx] = chars[j];     if (idx >= 2) {      Map map = new HashMap();      for (int k = idx - 2; k <= idx ; ++k) {       map.put(ret[k], true);      }      if (map.size() == chars.length) {       continue;      }     }     print(ret, chars, size - 1, idx + 1);    }   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First consider only the strings that begin with 'a'.  We can build a tree with the number of valid strings (beginning with 'a') equal to the number of leaves in the tree.  Start a tree with root 'a' and to this we can add 3 children 'a', 'b' and 'c'.  To the child node 'a', we can attach children 'a','b' and 'c'.  However, to the 'b' and 'c' children we can only attach 2 children.  Continuing, this looks something like:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is more of a mathematical problem than a programming one.  The general formula for the solution to this problem: N= String length x=number of unique letters  #valid Strings = x^N - (N-x)*(N-x+1)*x!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#define HAS_A 1 \n#define HAS_B 2 \n#define HAS_C 4 \n \n#define HAS_NONE 0 \n#define HAS_ALL  (HAS_A | HAS_B | HAS_C ) \n \n#define CHAR2BIT(c) ((c) == 'a' ? HAS_A : ((c) == 'b' ? HAS_B : HAS_C)) \n \nstatic void \nprint_non_consec (int len, char *buf, char *ptr) \n{ \n    char prev = HAS_NONE; \n    char ch = 0; \n \n    // check for illegal values (len 0, buf > ptr) \n    assert(len); \n    assert(buf <= ptr); \n    // get the previous char and the previous-previous one \n    // the order does not matter, so keep it in a bitmap \n    if (ptr - buf >= 1) { \n        prev |= CHAR2BIT(*(ptr-1)); \n    } \n    if (ptr - buf >= 2) { \n        prev |= CHAR2BIT(*(ptr-2)); \n    } \n    // try add each char and check for non-consecutive requirement \n    for (ch = 'a'; ch <= 'c'; ch++) { \n        if ( (prev | CHAR2BIT(ch)) != HAS_ALL) { \n        // if allowed, build the rest of the word recursively \n            *ptr = ch; \n            if (len > 1) { \n                print_non_consec(len-1, buf, ptr+1); \n        }    else {  \n        // if reached the word end, print it \n                *(ptr+1) = '\\0'; \n                printf(\"%s\\n\",buf); \n            } \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is an O(N) solution for finding the *count* of acceptable strings. It calculates the count for strings of length up to N. It uses O(N) space, but it is trivial to bring the space to O(1). The way it is below, you can make lookups to countsameA and countdiffA vectors for different values of N."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A recursion works but when you are adding the next character, you have to check for the \"constraints\". In this case, making sure that the last two character of the sequence are either equal or at least one of them equal to the new character you are adding."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a simple resursion will solve this"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This seems like it is just a simple math question... I may  be wrong but I think the way to solve this is to think of it like this:    If you had a string of abc without any constraints you would have 3^N possible strings now with the constraints: You have 3 options for the first spot in the string(abc), and then for each of the remaining slots(N-1) you have 2 options(the two letters you didn't use for the previous spot), so the formula should be 3*2^(N-1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i think the correct formula will be  f(n)=2*f(n-1)+f(n-2) f(1)=3 f(2)=6 here is the source code for displaying all strings"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void GenerateNonConsecutiveABC(int N, std::string &S,int State) \n{ \n    static char ABC[3] = {'a','b','c'}; \n    static int SM[11][3] =  \n    { \n        {1,2,3}, //empty \n        {1,4,5}, //a \n        {6,2,7}, //b \n        {8,9,3}, //c \n        {6,2,10}, //ab \n        {8,10,3}, //ac \n        {1,4,10}, //ba \n        {10,9,3}, //bc \n        {1,10,5}, //ca \n        {10,2,7}, //cb \n        {10,10,10} //garbage \n    }; \n \n    if(S.size() == N) \n    { \n        cout << S.c_str() << endl; \n    } \n    else \n    { \n        for(int i = 0; i < 3; i++) \n        { \n            if(SM[State][i] != 10) \n            { \n                S.push_back(ABC[i]); \n                GenerateNonConsecutiveABC(N,S,SM[State][i]); \n                S.pop_back(); \n            } \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// This is javascript \n \nfunction out1(w,x) { \n var z= { \n  'aa' : 'a', \n  'ab' : 'a', \n  'ac' : 'a', \n  'ba' : 'a', \n  'bb' : 'a', \n  'bc' : 'b', \n  'ca' : 'a', \n  'cb' : 'b', \n  'cc' : 'a' \n }[w+x]; \n \n return z; \n} \n \nfunction out2(w,x) { \n var z = { \n  'aa' : 'c', \n  'ab' : 'b', \n  'ac' : 'c', \n  'ba' : 'b', \n  'bb' : 'c', \n  'bc' : 'c', \n  'ca' : 'c', \n  'cb' : 'c', \n  'cc' : 'c' \n }[w+x]; \n \n return z; \n} \n \nfunction out3(w,x) { \n var z = { \n  'aa' : 'b', \n  'ab' : '', \n  'ac' : '', \n  'ba' : '', \n  'bb' : 'b', \n  'bc' : '', \n  'ca' : '', \n  'cb' : '', \n  'cc' : 'b' \n }[w+x]; \n \n return z; \n} \n \nfunction gen4( n, p1, p2, str ) { \n if ( n == 0 ) { \n  gs.print(str); \n } \n else { \n  var x = out1(p1, p2); \n  var y = out2(p1, p2); \n  var z = out3(p1, p2); \n \n  gen4( n-1, p2, x, str + x); \n  gen4( n-1, p2, y, str + y); \n \n  if ( z ) { \n   gen4( n-1, p2, z, str + z); \n  } \n } \n} \n \nfunction gen3( n, p1, str ) { \n gen4( n-1, p1, 'a', str + 'a'); \n gen4( n-1, p1, 'b', str + 'b'); \n gen4( n-1, p1, 'c', str + 'c'); \n} \n \nfunction gen1( n ) { \n gen3( n-1, 'a', 'a' ); \n gen3( n-1, 'b', 'b' ); \n gen3( n-1, 'c', 'c' ); \n} \n \ngen1( 5 );"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Total Number of Strings possible:  n1= 3^N Strings With consecutive a,b& c :  n2== 3^(N-3)* (3)! *  (N-2)! Strings  without consecutive a,b& c :  n3= n1-n2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void FindStrings(String result, String str, int size) {      if (result.length() >= size) {       System.out.println(result);      }      else {       for (int i = 0; i < str.length(); i++) {        int nlen = result.length();                if (nlen >= 2)        {         if ((result.charAt(nlen - 1)+\"\").equals(str.charAt(i)+\"\") ||             (result.charAt(nlen - 2)+\"\").equals(str.charAt(i)+\"\") ||             (result.charAt(nlen - 1)+\"\").equals(result.charAt(nlen - 2)+\"\"))           FindStrings(result + str.charAt(i), str, size);                 }        else         FindStrings(result + str.charAt(i), str, size);       }      }    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My code below does not have extensibility. When there are four kinds of distinct letters in str, it doesn't work. public static int count( String s, int n ) {   int res = 0;   int start = 0;   Set past = new HashSet();   char prev = ' ';   char[] chars = s.toCharArray();   int i = 0;   for( ; i < chars.length; i++ ) {    char c = chars[i];    if( past.contains(c) && c == prev ) {      past.clear();      past.add( c );    } else if( !past.contains( c ) ){     past.add( c );     if( past.size() == 3 ) {      past.clear();      past.add( prev );      past.add( c );      if( i - n >= start )       res += ( i-n-start+1 );      start = i - 1;     }    }    prev = c;   }   res += ( i - n >= start ) ? ( i - n - start + 1 ) : 0;   return res;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If N is odd, ans = 3 * 7 ^ ((n-1)/2);  If N is even, ans = 51 * 7 ((n-4)/2);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"i am thinking of generating all the strings of length N means generating all the string of length N by putting a ,b,c at various place of string and then when string size becomes N then check if it contains a,b,c consecutive or not......... if not then print it"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4915897630195712","download_status":"DOWNLOAD_DONE","votes":"-4","answersCount":"10","title":"Given two aligned sequences `a` and `b`. Write a function \"findCommon\", that finds the longest substring of the longer sequence that align to the smaller sequence in such a way that the alignment length (matching length) can be maximized. Sequences initially were of different lengths but the smaller one is padded with hyphen ('-') after alignment to make it equal to the longer sequence. The length of longer sequence is known in advance (m, which is same for the smaller padded sequence). The output is always the subsequence of the longer string.  The total number of such operations to be done is in billions.        findCommon(a, b, m)   Example 1:      a = ------bixg--     b = xxxxxxbi-gzz     m = 12      output: big   Example 2:     a = xxxxxxbxigxx     b = ------b-ig--     m = 12      output = bxig   Example 3:     a = bigxxxxxxxxx     b = bi-x--------     m = 12      output = bigx","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i am not clear about the output,"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void findCommon(char[] a, char[] b, int m) {   int startCount = -1;   int endCount =-1;   char[] c = null;   for (int i = 0; i < m; i++) {        if (a[i] == b[i]) {     if (startCount < 0)      startCount = i;         } else if (startCount >= 0) {          if ((a[i] == '-')  && ((int)(b[i]) >=97 &&  (int)(b[i])<=122) )  {            if(!(i+1 < m && a[i+1] == b[i+1]))      {       endCount= i;       break;      }     } else if ((b[i] == '-') && ((int)(a[i]) >=97 &&  (int)(a[i])<=122) )  {            if(!(i+1 < m && a[i+1] == b[i+1]))      {       endCount= i;       break;      }     } else      startCount = -1;    }   }   System.out.println(\"start count = \"+startCount +\" end count = \"+endCount);   if(startCount != -1)   {    if(startCount != 0)     c=a[0]== '-'?b:a;    else     c=a[endCount+1]== '-'?b:a;    if(endCount ==-1)     endCount=m-1;    int i= startCount;    while(i <=endCount-1 )    {     if(c[i] != '-')     System.out.print(\" \"+c[i]);     i++;    }   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Find starting and end index of Longest common subsequence of lcs(a,b) in a. result=a.substring(start,end);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"not clear about the input:  1. shorter string can be padded at will or it has been padded fixedly in input?  2. why in example 1, longer string contains a \"-\" ? it's padded or a trival character?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"m = 12 is the length of the two strings."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"To cope with the 'billions' part you could make a Levenshtein Automaton of the pattern string, with as wide of edit distance as you're willing, convert that to an NFA, run the possible matches in parallel (not OS parallel), add logic (somehow) to keep count of the longest. It's possible that the branches in the NFA would make it exponential, but I'm sure that with good coding you could make it max out at something less (there should be only so many states). On its best day, this would be O(m = length of input string). Given that we're starting with O(n x m) we've got room to play with. The NFA 'threads' would keep track of their history - the longest you'd replay, with the right characters, '-' and so on."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4951409057333248","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"18","title":"given a dictionary of wrods,find the pair of word with following property: 1,the two word don't have same letter. 2,the multiple of the two word's length is maximum. i give a simple O(n*n*k)(k is the average length of word) method.but i think there will be better one .","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Assuming the word is A-Z/a-z only, use a bitmap to set which letters it contains. e.g. ca => 000....101     bb => 000...010 Iterate over the words in decreasing order of length     for each pair of words, AND the bitmaps. Return the first pair that gives a 0 result.   This should be n*k + n*n"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can you clarify on second point? \"2.  the multiple of the two word's length is maximum. \""},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming you have an Dictionary technically a map For 1st case :   a. Take out all the keys.  b. for each key get the value from map. Recursively iterate through the key and value to find the pairs with no common letter.  For 2nd Case:   a. Compute totalLength = key.length * value.length;  b. Maintain one more map with key as totalLength and value as List of keys.  c. at the end dump the values of largest key."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assume all words are stored in a trie tree, otherwise preprocessing all words.   For each word w, search w following the trie tree, if the character is w, return in current branch. Otherwise, keep searching. Return the maximum length word found in the trie tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For the love of god guys, big O notation is often a funny topic. It's cool to talk about, but it sometimes means nothing. For example, if you have a container of size 100 and you need some answer with it that can be done in O(n), it is sometimes fast enough (or even FASTER at times) to do a O(n^2).  This is a dictionary... 200k^2 isn't that big. I coded up a disgusting piece of code. It found an answer in a real dictionary in 0.9 seconds. Here is the answer: Dictionary size: 235882 Words: chromochalcography uniquisitiveness Product: 306  The code (of course): bool valid_words(string const &w1, string const &w2) {     if(w1.find_first_of(w2) == string::npos)         return true;     return false; }   pair find_two_words(vector dict) {     // sort copy of dictionary in order of descending size (biggest first)     sort(begin(dict), end(dict), [](string const &w1, string const &w2)     {         return w1.size() > w2.size();     });      // Find an answer     pair ans;      // indices into dict     int maxProduct = 0;     for(int i = 0; i < dict.size(); ++i)     {         if(dict[i].size()*dict[0].size() <= maxProduct)                 return make_pair(dict[ans.first], dict[ans.second]);          for(int j = 0; j < dict.size(); ++j)         {             unsigned product = dict[i].size()*dict[j].size();              if(product <= maxProduct)                 j = dict.size();             else if(valid_words(dict[i], dict[j]))             {                 ans = make_pair(i, j);                 maxProduct = product;             }         }     }      return make_pair(dict[ans.first], dict[ans.second]); }  int main() {     ifstream fin(\"dict.txt\");     string word;     vector dict;     while(fin >> word)         dict.push_back(word);      cout << \"Dictionary size: \" << dict.size() << endl;     auto biggest = find_two_words(dict);     cout << \"Words: \" << biggest.first << \" \" << biggest.second << endl;     cout << \"Product: \" << biggest.first.size()*biggest.second.size() << endl; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"And by the way, that .9 seconds includes reading in the dictionary. I can only imagine that is the majority of the time used. My first return statement (as I predicted) executes rather quickly. The theory doesn't matter. Even if this were an exponential complexity, you pretty much know from domain knowledge that it won't do more than a few hundred thousand loops."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is the most optimal solution at O(n * k).  The assumption I take into account is that only one word is the longest value without specific characters (If there are two words then technically more than a single pair can be returned)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Create a trie of the dictionary words \n For each word, find the list of letters that is not in the word, find the longest word which contains only these letters traversing the trie. \n3. Output the maximum product out of all the words."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"Learn some fucking english, you idiot."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5731209090957312","download_status":"DOWNLOAD_DONE","votes":"7","answersCount":"38","title":"Q: Design a component that will implement web browser history. the user goes to different site and once he press on history button you should display the last 5 (no duplicates allowed, and 5 can be any N later) if duplicates occur display the most recent one. so if user visit : G,A,B,C,A,Y and than press \"history\" we will display Y,A,C,B,G. and of course he can go later to two other websites and than press \"history\" we will show them than the previous 3.  A: I solved it with stack, list and hash table in O(n) but it was too complicated and I didn't like my solution. please suggest something simpler.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"This problem is the same as LRU cache design, using double linked list and hash table."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"O(1) insert and O(1) history retrieve:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Implementation and unit tests:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I took a similar approach by using a Map and Linked List. In the map, I store a pointer to the linked list object corresponding to the URL. If the same page is visited twice, the address is used to find the object in the list, remove it, and re-insert it at the head.  Also, you can always obtain the last \"N\" pages by traversing through the list from the head down.  Here is the C++ code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Anonymous and multiple personality is angered other win this question before one of his namea can win the upvote.  So of course downvote all over like a mess and make this question useless so the win become diminished.  Today you notice that anonymous did not use Subbu name but use the / name He use Subbu name for post good solution usual these days and other names to mess the questions for others Have names for both construction and destruction."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Its like a LRU cache. It can be solved using Queue,Doubly Linked List, . For each address he enters create a hash key and store it in queue. This browser address and hash key store it in a doubly linked list. Once user again visits same address break the node and bring it to first."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is it true love, or self love? Not sure :("},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is it true love, or self love? Not sure :("},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since the number of elements to keep in the history was 5, I assumed than an array search would be fast enough to prevent any loss of performance."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"C version"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class List { \n Node end; \n \n Node add(String url) { \n  Node node = new Node(url); \n  if (end != null) { \n   end.next = node; \n   node.previous = end; \n  } \n \n  end = node; \n  return node; \n } \n \n void remove(Node node) { \n  Node previousNode = node.previous; \n  Node nextNode = node.next; \n \n  if (previousNode != null) { \n   previousNode.next = nextNode; \n  } \n \n  if (nextNode != null) { \n   nextNode.previous = previousNode; \n  } else { \n   end = previousNode; \n  } \n } \n \n @Override \n public String toString() { \n  Node current = end; \n  StringBuilder buf = new StringBuilder(); \n  while (current != null) { \n   buf.append(current + \"  \"); \n   current = current.previous; \n  } \n \n  return buf.toString(); \n } \n} \n \nclass Node { \n \n Node next; \n Node previous; \n String url; \n \n Node(String url) { \n  this.url = url; \n } \n \n public String toString() { \n  return url; \n } \n} \n \npublic class BrowserHistory { \n \n public static void main(String[] args) { \n  // List l = new List(); \n  // l.add(\"a\"); \n  // l.add(\"b\"); \n  // l.add(\"c\"); \n  // Node n =l.add(\"d\"); \n  // l.remove(n); \n  // System.out.println(l); \n \n  BrowserHistory h = new BrowserHistory(); \n \n  // GABCAY \n  h.addToHistory(\"G\"); \n  h.addToHistory(\"A\"); \n  h.addToHistory(\"B\"); \n  h.addToHistory(\"C\"); \n  h.addToHistory(\"A\"); \n  h.addToHistory(\"Y\"); \n \n  System.out.println(h.getHistory(5)); \n \n } \n \n List history = new List(); \n Hashtable nodes = new Hashtable(); \n \n void addToHistory(String url) { \n  Node node = nodes.get(url); \n  if (node != null) { \n   history.remove(node); \n  } \n \n  Node newNode = history.add(url); \n  nodes.put(url, newNode); \n } \n \n String getHistory(int n) { \n  StringBuilder buf = new StringBuilder(); \n \n  Node current = history.end; \n  for (int i = 0; i < n && current != null; i++) { \n   buf.append(current.url + \"  \"); \n   current = current.previous; \n  } \n  return buf.toString(); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"We can achieve it by using a circular doubly linked list and a HashMap.  \nHashMap will be used to track duplicate elements. \n \nHashMap  storedElements; \n \nAlgorithm: \n1. add() :  \n          check if it already exists(use HashMap) in list. if it is than just remove it from its old  \n          location and add at current\\tail. \n          If does not exists than add it in list at tail and add its reference in hashMap. \n          Complexity =O(1) \n2. getMostRecentNelements() \n          return all elements from tail to head in reverse order. \n          Complexity = (N) \nSpace complexity = O(2N)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"With Java LinkedHashSet, O(1) solution is"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Here is an example of the O(1) hashtable implementation. The idea is that the linked list has an ordering of the last n websites, and the hashtable maps website to iterators into the list for O(1) find time (for removal when needed).  /// class History { public:     History(unsigned sz) : sz(sz) {}     void add_website(string const &website);     list const &get_history(){ return recentlyVisited;} private:     unsigned sz;      unordered_map>::iterator> iterators;     list recentlyVisited; }  add_website(string const &website) {     // If the website is already in there, just erase it and put it on the front.     auto hashLookup = iterators.find(website);     if(hashLookup != end(iterators))     {         recentlyVisited.erase(hashLookup->second);         recentlyVisisted.push_front(website);         hashLookup->second = begin(recentlyVisited);         return;     }       // Otherwise, add it. If space is used, remove the one that has been unused longest.     if(recentlyVisisted.size() == sz)     {         iterators.erase(recentlyVisited.back());         recentlyVisited.pop_back();     }     recentlyVisited.push_front(website);     iterators.insert(make_pair(website, begin(recentlyVisited))); } \\\\\\  But let's do a little bit of real talk. How many websites could there be stored in a website browser? Maybe 4,000. Maybe 6,000. These are all incredibly tiny numbers, and even an O(n) complexity solution will be just fine. In fact, such a solution will outperform a hashtable implementation for n = 5 due to avoiding the overhead. The O(n) complexity is as follows:  Have a list [doubly linked list with stored size] of top n most recently used. called list recentlyVisited. No need for hashtable this time. Find elements in it with a linear search. add function: /// add_website(string const &website) {     // If the website is already in there, just erase it and put it on the front.     auto itr = find(begin(recentlyVisited), end(recentlyVisited), website);     if(itr != end(recentlyVisited))     {         recentlyVisited.erase(itr);         recentlyVisited.push_front(website);         return;     }      // Otherwise, add it. If space is used, remove the one that has been unused longest.     if(recentlyVisited.size() == sz)     {         recentlyVisited.pop_back();     }     recentlyVisited.push_front(website); } \\\\\\"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"And is this a problem from Google or Bloomberg LP?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"priority queue, implemented as a 'max-heap' on access-time. most recently visited page will be available on the top of team (its time will be greater than all others).   if heap is full, replace the end element and move up the heap readjusting it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"circular buffer of size 5"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"I think the interviewer will expect you to come up with/discuss a thread/multi-process safe way.  One solution would be to use a LRU cache. Search this site, there are many solutions which are thread safe.  For multi-process safe, change the locking mechanism. The underlying implementation can still be the same."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5116085787426816","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"20","title":"Given N strings, find the smallest string in lexicographic order which contains all the given strings as subsequences","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"This can be solved most efficiently using n-way merge. The basic idea is that we use a binomial heap and add a character to it one by one from each string. We also need to keep track of what is already added to the heap."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Lets say strings are X = { S1, S2, ... Sn}, sum(|S1|+...+|Sn|) = L and max{ |Si| } = M.  1. Compute longest common sub-sequence between S1 and S2.  O( M^2 )  2. Create a string M2 by merging S1 and S2. Include chars from LCS once. For other letters lexicographically smallest one comes first maintaining their order in the original string. It can be done considering string as a implicit linked list. O( L )  3. Remove S1, S2 from set X, and add M2 to the set.  4. Do the same thing for [S3, S4], [S5, S6]..... We have effectively reduced the set size to n/2. By successively doing this we will get n/4, n/8, ... elements, and finally X = {Mn} which is the answer. O( L^2 log n ).  There could be some other easier way to get rid of the common sub-sequences between strings except using LCS. I can't think of one though."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Imagine you sort the list of N strings, and from the sorting you create a long new string by concatenating the elements of the list. Now the requirement of the task is met. But if you have a concatenation of prefixes abcd and ecd that is abcdecd you may simplify it as abecd - both prefixes appears here as subsequences. This step might be done while concatenation. If we have string L and R, and we need to concatenate them, and R contains a substring of L, then we can remove it from L."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Need more info on this one.  1. Does that smallest string is one of the N strings? (I know that would be dumb, but not clear from question.) 2. If not, does the smallest string need to come from a dictionary? Or just and string with characters in sorted order would do?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hey can we apply this approach to this question.  first we sort the strings by that we can get the ordered string and then using the trie data structure we can find the string which contains the subsequences of all the strings...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am thinking about this approach."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I still don't understand the problem. For example for the following two strings:  ab, xya   would it be abxya or xyab?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this? {{ import java.nio.charset.Charset; import java.util.Arrays; import java.util.Collections;  public class StringCombineLexicographic {  public static void main(String[] arguementList)  {   String[] strArray = {\"pqr\",\"zy\",\"aaaa\",\"pqrs\"};   char[] result = new char[128];   int size = 0;    for(int i=0;i  {    for (int j =0;j   {      int index = (int)strArray[i].charAt(j);      if(result[index] != strArray[i].charAt(j))      {       result[index] = strArray[i].charAt(j);       size++;      }    }    }      Arrays.sort(result);      for(int i = result.length-size;i   System.out.print(result[i]+\"  \");  } } }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There is something wrong with the ques.. lets say u form some string which contains all the strings as its subsequences, bcdf then abcdf is lexicographically smaller than bcdf...aabcdf is smaller than abcdf..and so on.. hence we can keep on adding number of a's to form smaller and smaller(lexicographically) strings."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Well, it's a classic problem which can be solved by dynamic programming(DP). Considering the final patten satisfying the condition, it must be the form \"(B)(A)(D)(C)(E)... etc.\", where (A) means the word A in dictionary. i.e. Just connect them maybe cause overlaps or include. In order to apply this approach, we need some preparation--erase all words which is contained in other word, and also keep the word set unique. Thus, we define our DP equation as dp[i][statu] denoting the smaller string with i-th word be the last word we used, and this string has contained \"statu\" words(\"0100101\" means that three words are contained).  dp[j][statu|(1< In the brackets, an extra suffix means we need a string concentrate with word i to get the word j. i.e. if word i is \"abcdefg\" and word j is \"defghij\", we need an extra \"hij\" to finish the transfer.  The initial DP statu is to define each word as a statu, dp[0][00001] = \"apple\", dp[1][00010] = \"orange\", and so on.  The answer of the question is dp[anyone(0,1,2,..,N-1)][binary statu of all one(1< \n   \n    \n   -  \n     Prowindy \n     on December 22, 2013 Edit | Flag  \n    \n    \n   Reply"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Well, would this algorithm work?  1. Push all those string into a stack. 2. Peek the top value of the stack in each of the strings 3. The most minimum value lexographically is popped out (from more than one stack, if there should be duplicates) and stored into the resultant string. 4. Repeat 2 through 3 till all stacks are empty.  Of course, this takes up space proportional to number of strings (and no. of characters in each of those strings), but space concerns can alleviated, cause this problem would work well with divide and conquer method too (il est, process the strings in pairs, and merge them).  Using stack here, only because it makes the algorithm a bit easier to explain, of course you could just use an array to store the indices (of the yet-to-be-added-to-the-resultant-string characters)."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5649094550749184","download_status":"DOWNLOAD_DONE","votes":"3","answersCount":"26","title":"Given an array of pairs of the form . We have to find a sub-array such that the 1st element in the pairs are in increasing order and the sum of 2nd element of the pairs in the sub-array is maximum possible","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Modified Kadane's algo will be O(N)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Kadane algorithm"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the subarray is contingous then you can go for Kadan's algorithm suggested by mindless monk. If you need to consider subsequence then dynamic programming approach, as the optimal substructure property is met: you may process the task from left to right, as if A is a solution of size N, and A is optimal it has to be also a part of a solution of B, of size N + 1.   So you should build a helper array M, where"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In some cases there is confusion between sub-array and sub-sequence. Here it should be obvious that sub-sequence is intended."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n) Complexity"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"axel.david.velazquez following in Ajeet's footsteps"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First sort the array based on the first element and save them in an other array call c. Then we can reduce the problem to  find the LCS ( longest Common Subsequence ) problem. Let bi, be the weight whether we choose ai or not, instead of length weight is important here. Using dynamic programming the running time is O(N^2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why would you think that the Kadane's Algorithm is the solution?  Read the original question again slowly: \"the 1st element in the pairs are in increasing order and the sum of 2nd element of the pairs in the sub-array is maximum possible\"  The 2nd element of the pairs is the \"maximum possible\"... Given the input pairs:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Additionally, If the \"increasing order\" should rule out the fact that the first element of any two pairs is the same number {2,3}, {2,5}, then you would always take the pair with the larger second element."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"double getMax(vector< pair > v) { \n assert(v.size() > 0); \n int bleft=0, bright=0; \n int tmp_left = 0; \n double bv=v[0].second; \n double cv = bv; \n for (int i = 1; i < v.size(); i++) { \n  if (cv < 0 || v[i].first < v[i-1].first) { \n   cv = v[i].second; \n   tmp_left = i; \n  } else { \n   cv += v[i].second;  \n  } \n  if (bv < cv) { \n   bleft = tmp_left; \n   bright = i; \n   bv = cv; \n  } \n } \n return bv; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Modified Kadane's algorithm"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5072814092582912","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"5","title":"Implement HashTable in java , especially hash function that should take care of any type of keys. The key may be integer or String or Object. But based on that the hash function should find index in the hashArray","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Implement two-level of hashing, two hash functions  h1( typename ) returns a key k1 in table T1 which contains links to a separate table T2(one T2 per entry of T1) h2(k1, object)   returns a key k2 (links to entry within T2)  To hash h2( object.class, object ), first hash gives a key to location of object in an entire arrangement of two hash tables."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why Can't we create Hash map with key and value both of object type and overwrite the methods for specific type"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"What the problem? Implement Map interface"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4914286849687552","download_status":"DOWNLOAD_DONE","votes":"-3","answersCount":"12","title":"Implement Array Class in java.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I think what they mean is a pointer to pointers implementation?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If you cannot use a simple array like  String[] or Object[] or E[] then the question would be more like create an array implementation on the JVM an not in JAVA.  In Java there is a class called Arrays, which is a utility class to deal with regular arrays ( sorting, copying, etc etc etc)  The only thing you can do ( as far as I can think ) is to implement any Data Structure such as Vector, ArrayList, Stack, Queue even a tree using a regular array ( Object[] )  Another thing to point out is that, in java we cannot extends from Object[]  even if arrays are treat like Objects.  This is not allow. so that is not the way to go. The last resource we have instead would be using native methods  and try to implement something in C on a DDL or something.  But I am running out of ideas.  Anybody?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Maybe you should implement linked list based on something like that:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the interviewer wanted you to understand that an array must be contiguous and not a linked list. That is, you must have capacity, which is the amount of memory allocated, and size, which is the actual size of the array. So, when the user resizes the array with size > capacity, you must reallocate memory and copy the values from the old to the new array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Array is incremental index from 0 to n, and gives constant time access by index. Thus implement HashTable with key as index and value as whatever stored in array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Mind your business Anonymous moron"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"Look in ArrayList sources from jdk =)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"Stop getting your homework done. Stop posting \"implement \" under  interview questions here."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6559804516466688","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"4","title":"Suppose I have some (lng, lat) coordinate. I also have a big list of ranges,  [ { northeast: {lng, lat}, southwest: {lng, lat} } ... ]  How can I most efficiently determine which bucket the (lng, lat) point goes into?  Also, on a design perspective. Would it make more sense for the \"list of ranges\" to be on some database like mysql, monodb, or on something like memcached, redis?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"spatial index?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming that buckets are contiguous in space and a rectangle represented by bucket is aligned with X and Y axis.  Question boils down to finding match in a row-wise and column-wise sorted matrix.  For database vs memcached, I think it will depend on the usage. Say we are using this for an gps application. In that case memcached must be used."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Based on sign one can identify which plane that coordinate belongs to."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Build a 2D interval search tree using the list of lat and long."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5072902038749184","download_status":"DOWNLOAD_DONE","votes":"4","answersCount":"40","title":"You visited a list of places recently, but you do not remember the order in which you visited them. You have with you the airplane tickets that you used for travelling. Each ticket contains just the start location and the end location. Can you reconstruct your journey?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"If there's no assumption about the number of times you visited each place then it may not be possible to reconstruct your journey.   For instance, suppose your journey was as follows: a --> b --> c --> a --> d --> f --> a  Tickets: (a,b), (b,c), (c,a), (a,d), (d,f), (f,a)  You know your end point is a, how do you know which one of the following journeys was yours? 1. a --> b --> c --> a --> d --> e --> a 2. a --> d --> e --> a --> b --> c --> a"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Topological sort."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Observation from the info provided in question: 1. If I do not remember the order in which I visited these places, than off course i dont remember the starting location. 2. But I know my current location - end of my journey.  3. End place of one journey is starting place for another journey.   So on the basis of these observation here is my algorithm:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"A sorting problem"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"We can construct possible paths if and only if:  * there is at most one vertex with in-degree != out-degree * if such a vertex exists, then in-degree = out-degree - 1  If the above holds and no vertex has out-degree > 1, then we can construct the path.  Otherwise, to find the exact path from all possible paths, then for any vertex v of out-degree > 1 there must be at most one path from v that contains a cycle.  If any such vertex violates this principle, then we cannot determine which of the possible paths is the correct one."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming that the all the travels was made by airplanes, I think it's possible build the following solution:  -> Build a graph G: where each city visited is a vertex and there a edge between each pair of cities that are in a travel ticket. Obviously G is a directed graph. -> If the graph don't have cycles then is possible reconstruct the trip by a topological sort procedure. -> Otherwise, it's impossible reconstruct the certain path."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for(i=0;i::iterator p; \n  p=journey.find(cur); \n  roadMap=\"->\" + (*p).second + roadMap; \n  cur=(*p).second; \n } \n cout<<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First create hash map having destination as a key, pass current location (trip destination), hashmap and reference to path vector. The total complexity is O(N^2) where N is number of tickets and square time is spent while creating a hashmap, while the method itself has O(N + 1) complexity:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Constructing the graph starting from the final location. Then the problem is of finding the vertex cover. Here we can also consider the possibility that one city is visited twice. But in this case the answer may not be unique."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void reconstructRoute(Ticket[] tickets, Place curLocation){ \n HashMap> map = new HashMap>(); \n for(Ticket t : tickets){ \n  Place begin = t.from; \n  Place end = t.to; \n  ArrayList arr; \n  if(map.hasKey(begin)){ \n   arr = map.get(begin); \n  } \n  else { \n   arr = new ArrayList(); \n  } \n  arr.add(t); \n  map.put(begin, arr); \n  if(map.hasKey(end)){ \n   arr = map.get(end); \n  } \n  else{ \n   arr = new ArrayList(); \n  } \n  arr.add(t); \n  map.put(end, arr); \n } \n ArrayList route = new ArrayList(); \n Place c = curLocation; \n for(int i = 0; i=0; i--){ \n  System.out.println(route.get(i)); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ticket from one city to the other is an edge.  Given a bunch of edges, the question asks you to tell if there exists a path such that you visit each edge exactly once. In other words, a Eulerian Path.  Below is the necessary and sufficient condition for a Eulerian path in directed graphs. (Source: Wikipedia) A directed graph has an Eulerian trail if and only if at most one vertex has (out-degree) ? (in-degree) = 1, at most one vertex has (in-degree) ? (out-degree) = 1, every other vertex has equal in-degree and out-degree, and all of its vertices with nonzero degree belong to a single connected component of the underlying undirected graph.  This however is a necessary condition but not sufficient. Existence of a Eulerian path can actually be deduced from common sense. If you haven't left every city you have been to except for the one you are currently in, you wouldn't end up where you are.  But we are looking for one and only one Eulerian path to exist, which is possible only if every vertex has an indegree and outdegree of at most 2."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You have to do topological sorting for Euler circuit duhhhhhhhhhhhhhh"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming you don't know where you are:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; import java.util.HashMap; import java.util.Map;  public class AirplaneTktProblem {     Map tripMap = new HashMap();      public static void main(String[] args) {  ArrayList tktList = new ArrayList();  AirplaneTktProblem atp = new AirplaneTktProblem();      }      // make a Arraylist of tkt which is a departure and destination pair      // input it     public void inputTrip(ArrayList tktList) {  for (Tkt t : tktList) {      tripMap.put(t.to, t);  }     }      // traverse the first tkt and traverse the end of the trip     public Tkt traverseToTheFirstTkt(ArrayList tktList) {  Tkt firstTkt = tktList.get(1);   while (tripMap.get(firstTkt.from) != null) {      firstTkt = tripMap.get(firstTkt.from);  }  return firstTkt;     }      // traverse the begining of the trip using the last tkt     public void BuildTheTrip(ArrayList tktList) {  inputTrip(tktList);  Tkt Firsttkt = traverseToTheFirstTkt(tktList);  tktList.clear();  tktList.add(Firsttkt);  while (tripMap.get(Firsttkt.from) != null) {      tktList.add(tripMap.get(Firsttkt.from));  }     }      class Tkt {  private final String from;  private final String to;   public Tkt(String departure, String arrival) {      super();      this.from = departure;      this.to = arrival;  }      } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; \nimport java.util.HashMap; \nimport java.util.Map; \n \npublic class AirplaneTktProblem { \n    Map tripMap = new HashMap(); \n \n    public static void main(String[] args) { \n ArrayList tktList = new ArrayList(); \n AirplaneTktProblem atp = new AirplaneTktProblem(); \n \n    } \n \n    // make a Arraylist of tkt which is a departure and destination pair \n \n    // input it \n    public void inputTrip(ArrayList tktList) { \n for (Tkt t : tktList) { \n     tripMap.put(t.to, t); \n } \n    } \n \n    // traverse the first tkt and traverse the end of the trip \n    public Tkt traverseToTheFirstTkt(ArrayList tktList) { \n Tkt firstTkt = tktList.get(1); \n \n while (tripMap.get(firstTkt.from) != null) { \n     firstTkt = tripMap.get(firstTkt.from); \n } \n return firstTkt; \n    } \n \n    // traverse the begining of the trip using the last tkt \n    public void BuildTheTrip(ArrayList tktList) { \n inputTrip(tktList); \n Tkt Firsttkt = traverseToTheFirstTkt(tktList); \n tktList.clear(); \n tktList.add(Firsttkt); \n while (tripMap.get(Firsttkt.from) != null) { \n     tktList.add(tripMap.get(Firsttkt.from)); \n } \n    } \n \n    class Tkt { \n private final String from; \n private final String to; \n \n public Tkt(String departure, String arrival) { \n     super(); \n     this.from = departure; \n     this.to = arrival; \n } \n \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class AirplaneTktProblem { \n    Map tripMap = new HashMap(); \n \n    public static void main(String[] args) { \n ArrayList tktList = new ArrayList(); \n AirplaneTktProblem atp = new AirplaneTktProblem(); \n \n    } \n \n    // make a Arraylist of tkt which is a departure and destination pair \n \n    // input it \n    public void inputTrip(ArrayList tktList) { \n for (Tkt t : tktList) { \n     tripMap.put(t.to, t); \n } \n    } \n \n    // traverse the first tkt and traverse the end of the trip \n    public Tkt traverseToTheFirstTkt(ArrayList tktList) { \n Tkt firstTkt = tktList.get(1); \n \n while (tripMap.get(firstTkt.from) != null) { \n     firstTkt = tripMap.get(firstTkt.from); \n } \n return firstTkt; \n    } \n \n    // traverse the begining of the trip using the last tkt \n    public void BuildTheTrip(ArrayList tktList) { \n inputTrip(tktList); \n Tkt Firsttkt = traverseToTheFirstTkt(tktList); \n tktList.clear(); \n tktList.add(Firsttkt); \n while (tripMap.get(Firsttkt.from) != null) { \n     tktList.add(tripMap.get(Firsttkt.from)); \n } \n    } \n \n    class Tkt { \n private final String from; \n private final String to; \n \n public Tkt(String departure, String arrival) { \n     super(); \n     this.from = departure; \n     this.to = arrival; \n } \n \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"yes... start with the place i am currently...match it with the ticket...and then i get my preceeding location...so on"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I remember this question was once asked in a \"Long Contest\" on codechef.com. Here is how I solved it.  You need an Associative Array (most suitably a HashMap) to solve this problem. Suppose each ticket is of the form \"A->B\" (means the ticket from 'A' to destination 'B'). Example input: F->G B->C E->F C->D D->E A->B Output: A->B->C->D->E->F->G"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Construct directed graph with places as nodes and directed edge between two place v1,v2 if v1 was start loaction in some ticket and v2 was destination in the same ticket.Now use topological sorting algorithm."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Another approach, If beyond source and destination info there are date-time info in tickets: -> Sort the tickets registers by increasing date-time -> Build the trip by sorted tickets."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"If ask me... then: The question is: \"Could you reconstruct your journey?\" So the answer is: If there are no cycles -> yes, otherwise it could be reconstructed but without guarantee that order is the same."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5726815775621120","download_status":"DOWNLOAD_DONE","votes":"-4","answersCount":"12","title":"Given two Btrees. these trees \"may\" have right and left branches swapped. Now compare it","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"BTrees? Or Binary Trees? They are different...   Even if you meant Binary Trees, wtf is the question? Makes no sense."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"bool check(node* r1, node* r2){ \n if(!r1 && !r2) return true; \n if(!r1 || !r2) return false; \n if(r1->data != r2->data) return false; \n bool b = check(r1->left, r2->left) && check(r1->right, r2->right); \n if(b) return true; \n return check(r1->left, r2->right) && check(r1->right, r2->left); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"bool isIsomorphic(tree t, tree s)  \n{ \n return  isSame(t,s) || isMirror(t,s); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There is nothing like left and right in a BTree. The number of branches from a node depend on the order of the tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Search for tree-isomorphism-problem in geekforgeeks . org.  I guess that is what you are looking for."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This question is from glassdoor where someone said it was asked in the on-site interview rounds. It is a very vague description."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The below answer is for lookup for a BT in a list of millions of BT.  We can do it in O(1) time, but it requires preprocessing. 1) Create a string hash for each tree 2) Remember to separate the node values using some separator. for example use left brace & right brace. Also remember to maintain the some sorted order of child's values (either asc, or desc) 3) Insert into a HashMap map;   During lookup operation, convert the input tree into string (as mentioned in step 2), and look for it in the map. Complexity: HashMap addition is O(1) - Amortized. HashMap lookup is O(1) - Amortized."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"jbkjmb kj"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6065702117048320","download_status":"DOWNLOAD_DONE","votes":"4","answersCount":"57","title":"Implement below function. int getRandom(int N, int K[])   Constraints:  ->K is sorted and contains elements in range [0,N) ->Output should be a random number between [0,N) excuding elements from K ->probability of generated number should be 1/(N-K.length) and not 1/N -->int uniform(int N) is given which returns random number [0,N) with 1/N probability for each number. ->No more than O(1) memory ->No more than O(N) time  Below is my solution but it uses O(N) space.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"I'm assuming numbers between 1 and N.  Generate a random number X in the range 1..N-K.length. Then, process the K array while we haven't seen X numbers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"My approach is as follow:  -Transform K such that K[i] = number of integers 0.. K[i] missing before K[i] in K[] -Generate a random number x = uniform(0... N-K.length-1) -Find y = number of numbers equal to or less than x in K[], using binary search. -return x+y  Time = O(K.length) Space = O(1) Working C code below"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"// time O(lg K.size()) & space O(1) \nint getRandom(int N, vector K) { \n    int pos = unique_random(0, N-K.size()) + 1; // [1, N-K.size() + 1) \n    if (pos < K[0]) { \n return pos; \n    } \n    int l = 0, r = K.size(); \n    while (l < r) { \n int mid = (l + r) / 2; \n if (K[mid] - mid < pos) { \n     l = mid + 1; \n } else { \n     r = mid; \n } \n    } \n    return pos + l - 1; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"you might try binary search to identify if the randint(1,N) you flipped was in K[ ], and if it is... you..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I'm assuming numbers between 1 and N. Generate a random number X in the range 1..N-K.length. Then, process the K array while we haven't seen X numbers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I'm assuming numbers between 1 and N.  Generate a random number X in the range 1..N-K.length. Then, process the K array while we haven't seen X numbers.   public int randomNumber(int N, int[] K) { // K is sorted     int x = uniform(N - K.length);  // 1 .. N - K.length     int last = 0 , i;     for (i = 0; i < K.length; i++) {          if (K[i] - last > x)              return x + last;          x -= (K[i] - last - 1);  // we've seen K[i] - last - 1 valid numbers          last = K[i];     }     return x + K[ K.length-1 ];  } runtime O(K), O(1) space"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This problem is an extension of standard reservoir sampling"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the trick is to get random number in range [0, N - K.length()] and if the random number is present in K, then you add random number's position in K to N - K.length()."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int randomNumber(int N, int[] K) { \n    int length = K.length - 1; \n    while(K[length] > N){ //find actual length of K that matters to us (elements <= N) \n length--; \n    } \n    int x = Random.nextInt(length) + 1; //get the xth number between 0 and N that's not in k \n    int place = 0; \n    int count = 0; \n    for (int i = 0; i < N; i++) { \n          if(i == K[place]){ \n  place++; \n   } else { \n  count++; \n   } \n   if(count == x){ \n  return i; \n   }  \n    } \n    return x + K[ K.length-1 ];  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I assume that each number in k is at most once, that size of k < n. The idea is to return the i-th allowed number where i is a random number in the interval 0, n - k.size()."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int getRandom( int n, int K[], int sz) { \n int L = n - sz; \n int c = rand() % L; \n \n if (c < K[0]) \n  return c; \n for (int i = 0; i < sz; i++) { \n  int d = K[i] - K[i - 1]; \n  if (d > 0 && c < d) \n   return K[i-1] + c + 1; \n  c -= d; \n } \n return K[sz - 1] + c + 1; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"consider the following (in pseudo code):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int getRandom(int n, int[] k) { \n  int length = k.length; \n  while (length > 0 && k[length - 1] > n) { \n   length--; \n  } \n \n  if (length >= n) { \n   throw new IllegalArgumentException(\"Sample space of size 0\"); \n  } \n \n  int draw =  new Random().nextInt(n - length); \n \n  System.out.println(\"draw=\" + draw); \n \n  int current = -1; \n  int j = 0; \n  for (int i = 0; i <= draw; i++) { \n   current++; \n   while (j < length && k[j] < current) { \n    j++; \n   } \n   while (j < length && k[j] == current) { \n    current++; \n    j++; \n   } \n  } \n \n  return current; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int num = 20; \n int k[] = {2, 3, 6, 7, 8}; \n \n// long int x = random() % 15; \n long int x = 3; \n \n cout << x << endl; \n \n for (int i = 0; i < sizeof(k)/4 - 1; i++) { \n  if (x < k[i]) \n   break; \n  else \n   x++; \n } \n \n cout << x << endl;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int num = 20; \n int k[] = {2, 3, 6, 7, 8}; \n \n// long int x = random() % 15; \n long int x = 3; \n \n cout << x << endl; \n \n for (int i = 0; i < sizeof(k)/4 - 1; i++) { \n  if (x < k[i]) \n   break; \n  else \n   x++; \n } \n cout << x << endl;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The main idea is to find the Xth number that not appear in the k array:  int getrandom(int N, int k[], int length) {  int x = uniform(N - length), count = k[0] - 1;  for(int i = 0; i < length - 1; i++)  {   if(i == 0 && x <= count)   {    return x;   }   count += (k[i + 1] - k[i] - 1);   if(x <= count)   {    return k[i + 1] - (count - x + 1);   }  }  return k[length - 1] + x - count; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int rand(int N, int[] K){ \n int R = N - K.length; \n Random rand = new Random(); \n int p = rand.nextInt(R); \n int j = 0; \n int ret = 0; \n for(;j"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int transform(int x, int k[], int kLen) { \n    int nExcluded = 0; \n    for(int i=0; i= (k[i] - i)) \n            nExcluded++; \n        else \n            break; \n        } \n        return x + nExcluded;  \n    } \n \nint getRandom(int N, int k[], int kLen) \n    { \n   int x = rand()%(N-kLen); \n \n    return transform(x, k, kLen); \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  #include  #include  #include   using namespace std;  int getRandom(int N, vector  K){          int L = N-K.size();         cout << L << endl;         int random_num = rand()%L;         cout << random_num << endl;         K.push_back(N);         int prv = 0 , i = 0 , sum = 0;         if ( random_num < K[0] ) return random_num;         while ( (i < K.size()) && (sum < random_num) ) {           sum += K[i]-prv-1;           prv = K[i];           i++;         }         i--;         return (K[i]-sum+random_num-1); }  int main() {         int N;         cin >> N;         vector  K;         int M;         cin >> M;         for ( int i = 0 ; i < M ; i++ ) {                 int tmp;                 cin >> tmp;                 K.push_back(tmp);         }         cout << getRandom(N, K) << endl;         return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the simple java solution using binary search:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(logK) time, O(1) space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution:  Generate rnum = uniform(N) and then keep doing binary search till rnum does not belong in K. (python code)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"We should return K[i]. Pr{K[i]} - probability return K[i]. Pr{K[0]} = Pr{K[1]} = ... = Pr{K[K.length - 1]} (from constraints). But Pr{K[0]} + Pr{K[1]} + ... + Pr{K[K.length - 1]} = 1 (from probability theory) So Pr{K[i]} = 1/N for i = 0..K.lenght - 1. So the only valid N = 2*K.length.  Am I right? Or didn't understand the question?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"int RandomNum(int N, int K[]) {      int num = N-K_length;  srand (time(NULL));  int ret = rand() % num;  for(int i=0; i return ret;"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4739759813427200","download_status":"DOWNLOAD_DONE","votes":"-3","answersCount":"12","title":"Tossing a coin ten times resulted in 8 heads and 2 tails. How would you analyze whether a coin is fair? What is the p-value? In addition, more coins are added to this experiment. Now you have 10 coins. You toss each coin 10 times (100 tosses in total) and observe results. Would you modify your approach to the the way you test the fairness of coins?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I will set up a Hypothesis testing. Let theta be the probability that the coin is head, k be the number of times we observed that the coin is head.  H0 (null hypothesis): the coin is fair, i.e. theta=0.5 H1 (alternative): the coin is not fair, i.e. theta!=0.5  And the p value is the probability that the observed results are obtained under H0. Because P(k) follows binomial distribution so P(k) = (C10,k)*theta^(k)*(1-theta)^(10-k) Under H0, theta=0.5, so we compute p value as P(k=8)=C10,8*0.5^(10)=0.044<0.05 If we set the significance level as 0.05 then we can reject the null hypothesis H0, in other words, we select H1, i.e. this is not a fair coin.  If we have more (i.e. 10) coins, because each coin is independent, so I can judge the fairness of each coin use the same method above."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Job title?  Google Research, some sort of machine learning team?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In the first case: p(h)=0.8, p(t)=0.2  For  a fair coin, p(h)=p(t)=0.5 So, in the first case, toss the coin ten times again u get p(h_run2), do couple more times then we are looking at (p(h_run1) + p(h_run2) + p(h_run3)+...p(h_runN)  ) /N   should be close to 0.5 Also, as we increase the runs, the problem should get closer to 0.5 if the coin is really fair.   May be u could do the same for tail and observe the probability getting close to 0.5 as well  Same thing can be extended to the second case...u do p(h_coin1_run1)  + p(h_coin1_run2)+.....p(h_coint1_run10)  /10        + same thing for coin 2 + ....  till coint 10  entire thing divided by 10 should be close to 5"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Clear solution. 1 comment, you are using 1 tail test here. If 2 tailed test, conclusion will be different.  Thanks."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I thought the first part of the question was very straightforward. Calculating the p-value of 56/1024 was easy. But Google was very interested in how you analyzed it. I was asked what else I could do to test the fairness of  thecoin. To answer it, I mentioned chi-squared distribution and its test statistic. Then Google guy asked me that \"is this an approximation?\" He went on and asked me \"if I tossed the coin more than 10 times, say 100 times, would it help?\"  For the second part of the question, I had to pause for about five seconds before I opened my mouth. I though I needed to modify it because if you stick to 5% significant level for each coin, then the probability for failing to detect a biased coin would decrease for 10 coin case. I mean 0.95^10 = 0.6. So you could fail to find a biased coin 4 our of 10. In order to be 95% sure, you need to raise the significance level to 0.05/10 = 0.5% for each coin. I think this is similar to Bonferroni confidence band.   I don't know the answer. Gooogle didn't give me any answer during the interview."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can analyze this several ways. First way is summing up the binomial probabilities like others did. You can also have a chi square test where you are comparing sampled ratios to the expected ratio of 0.5 with 1 degree of freedom. Although the results would not be good due to small number of observations. But for the second part of the question, it could be used.You can also do a students t-test to see if the ratio 0.2 is within the confidence interval around 0.5 (expected) with that many samples."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I don't get the second part, there are 10 coins right?, is it the question how to tell which one is fair and which one is not? I don't see how observations on one coin give information about the others. I would exactly the same hypothesis test as for the single coin case, but, 10 times."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think that the interviewer wanted you to mention the t-test. Its a bit harder to compute the sample standard deviation each time, but it's easy to see how increasing n will affect the p value:  t=(x-u)/(s/sqrt(n))   Check out my blog at meditationsofmarcus.blogspot.com"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4653430970777600","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"20","title":"Find numbers which are palindromic in both their decimal and octal representations","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Any idiot can do a brute force."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Generate palindromes in decimal, then for every one check if they are also palindromes in octal. Here is an example of my method finding all palindromes smaller than int max that fit the criteria. It runs in under 0.01s and is O(n), n being the number of digits of the largest palindrome to be generated."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Question doesn't say what the input to the function, so let's throw out ideas ourselves.  My first idea is to have outter function take a certain \"width\" of octal numbers... 1) Then we create all octal numbers that are of that width from the endpoints (we can backtrack to create all such palindromic octal numbers). 2) We pack the octal 3 bits together to create binary representation (you can do it as part of 1) 3) Convert to BCD (can optimize above to make this part fast as part of shift and add algorithms or whatnot).  Then we scan the BCD numbers from the ends to see if they are palindromic too.  Might try coding it in evening."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Who will find the greatest number??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why it's downvoted? I suppose this solution is quite close of the best one I've know. Because palindromes are quite rare in big numbers, I suppose the best solution is: 1. Implement own class BigNumber with function getNextPalindrome() 2. Create 2 instances for decimal and octal 3. Use algorithm below (pseudo code):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can be generated by partial and full number reflections, here createAll function can be run twice for 10 and 8 base and just retain two lists (or merge it). Also can be changed to more sophisticated step by step approach."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"function f() {     for(i=0;i<10000;i++)     {         var ostr = '' + covertToOctal(i);         var dstr = '' + i;                  var retd = check_palindrome(ostr);         var reto = check_palindrome(dstr);                  if(retd && reto)         {             console.log(ostr + ',' + dstr);         }     } }   function check_palindrome(str) {     return str == str.split('').reverse().join(''); }  function covertToOctal(i) {     if(i ==0)     {         return \"0\";     }          var temp = i;     var str = \"\";     while(temp)     {         str =  str + '' + temp%8;         temp = Math.floor(temp/8);     }          str = str.split('').reverse().join('');          return str; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"If we can convert a number to string, just reverse it to see if they are the same."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Brute force can be made faster if you use a little math: I believe the number must be divisible by 99."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Hi, How about instead of checking all the numbers starting from 1(decimal) to an upper limit, we generate the first 10000 (say) decimal palindromic numbers. Then convert them to octal and check if the octal representation is palindromic or not.  Below is the working C++ code to print the numbers that are palindromic in both decimal and octal representations.  Function descriptions i) next_palindrome - This function takes a palindrome number as argument and returns the next larger palindrome. Initially started with 0 as seed. Ex - next_palindrome(99)=101  next_palindrome(999)=1001  next_palindrome(12321)=12421 This function uses a folding technique to find out the next larger palindrome.  ii) itoa - integer to string  iii) reverse - reverse a string  iv) dec_oct - convert from decimal to octal  v) is_palindrome - to check if a string is a palindrome"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Here's a 2 line brute force -"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6662415412363264","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"23","title":"Engineers at Google have decided to call any integer (+ve, -ve or 0) that is divisible by at least one of the single digit primes (2, 3, 5, 7) as Walprimes. Thus -21, -30, 0, 5, 14 etc are Walprimes, while -121, 1, 143 etc. are not Walprimes. Now, consider a n-digit integer d1d2d3..dn. Between any 2 consecutive digits you can place either a (+) sign, a (-) sign or nothing. So, there are 3n-1 different expressions that can be formed from it. Some of the expressions so formed may evaluate to a Walprime. For example, consider the 6 digit integer 123456: 1 + 234 - 5 + 6 = 236, which is a Walprime, but 123 + 4 - 56 = 71, which is not a Walprime. Your task is to write a program to find the no. of expressions (out of the possible 3n-1 expressions) that evaluate to a Walprime, for a given input. Note that leading zeroes are valid. For example, if the input is 1202004, it can be split as 12 + 020 - 04 etc. Also, the input itself can contain leading zeroes. Input format: (Read from stdin) The first line of input contains a single integer 'T' denoting the no. of test cases. Each of the following 'T' lines contain a single string 's' (of length 'n') denoting an input for which you need to find the no. of valid expressions evaluating to a Walprime. Output format: (Write to stdout) Output exactly 'T' integers (one per line), where the ith line denotes the no. of valid expressions that evaluate to a Walprime for the ith input string. Since the output can be large, print all the quantities modulo 1000000007. Sample testcase: Input: 2 011 12345 Output: 6 64 Explanation: For the first test case, s = \"011\". There are 32 = 9 valid expressions that can be formed from this string, namely {0+11, 0-11, 0+1+1, 0+1-1, 0-1+1, 0-1-1, 01+1, 01-1, 011} . Out of these 9 expressions, only the following 6 of them evaluate to a Walprime: {0+1+1, 0+1-1, 0-1+1, 0-1-1, 01+1, 01-1}. Constraints: There are 3 data sets. For the first data set (5 points) - 1 For the second data set (10 points) - 1 For the third data set (15 points) - 1","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"We could use Inclusion??Cexclusion principle AND dynamic programming. The time complexity can be reduced to polynomial.  Firstly, Inclusion??Cexclusion principle:  Define F(s, p) to be the no. of expressions whose result are divisible by number p. For example, F(\"011\", 2) = 6, F(\"011\", 3) = 3.  Define F(s, {p, q}) to be the no. of expressions whose result are divisible by at least one of the digit prime in {p, q}.  Then, by Inclusion??Cexclusion principle, F(s, {p, q}) = F(s, p) + F(s, q) - F(s, p * q)  We have F(s, {2, 3, 5, 7}) = F(s, 2) + F(s, 3) + F(s, 5) + F(s, 7) - F(s, 2 * 3) - ... + F(s, 2 * 3 * 5) + ... - F(s, 2 * 3 * 5 * 7)  Now, we use dynamic programming to find F(s, p).  let s[i:]be the suffix string start at index i,  let n be the length of string s. let num[i:j] be the number converted from substring s[i:j] inclusive.  Define R[i][j] be the no. of expressions which are formed from substring s[i:] and the remainder is j while mod p. (0 <= i < n, 0 <= j < p)  For example, s = \"011\", p = 2, R[1][0] is the no. of expressions formed from substring \"11\" and the remainder is 0 while they mod 2. R[1][0] = 2, since (1 + 1) % 2 = 0, (1 - 1) % 2 = 0, and R[1][1] = 1, since 11 % 2 = 1.   R[i][j] can be calculated from sub-problems R[k][l], where (num[i:k -1] + l) % p == j or (num[i: k - 1] - l) % p == j, for all k > i and k < n.  Then R[i][j] = Sum(R[k][(j - num[i:k - 1]) % p] +R[k][(num[i:k - 1] - j) % p], k = i + 1, ..., n - 1)  We get F(s, p) from R[0][0]. Here is code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"The optimal solution for this would be to solve by dynamics programming. I will solve it in a non-optimal way - by recursion. You can convert it to dynamic programming.   Start with a given number, split it by first char and rest and apply operator (+/- or none) between numbers and previously calculate sum and store output if wall prime"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Below is my C++ solution. For each string of length n there are 3^(n-1) expressions.  $ c++ wallprimes.cpp -o wallprimes $ ./wallprimes 2 011 12345 6 64"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hey u mentioned that for an n digit number there can be 3N - 1 valid expressions which can be formed. I tried this with a 4 digit number and didn't find it to be working. I found more than 3N - 1 expression that is more than 11 expressions. M i correct or m i missing anything in it. These are the expressions which I found for a 4 digit number 2357 2 + 3 + 5 + 7 2 - 3 - 5 - 7 2 + 3 + 5 - 7 2 + 3 - 5 + 7 2 - 3 + 5 + 7 2 - 3 - 5 + 7 2 + 3 - 5 - 7 23 + 57 23 - 57 2 + 35 + 7 2 - 35 - 7 2 + 35 - 7 2 - 35 + 7 235 + 7 235 - 7 2 + 357 2 - 357 2357"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A typo correction in the original question: There are 3 ^ (n-1) i.e. 3 raise to (n-1) such combinations (instead of 3n-1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Calculate possible set of possible sums, then count walprime  Let??s define dp as follows. dp[i]  is a set of possible number if we use i numbers.(dp[1] uses only input[0]) dp[0] should be only contain 0 because we don??t use any number.  Let??s define k as number of numbers we combine. For example, if k = 3, we comine input[i - 0] and input[i-1] and input[i-2]. Also. let??s define numK as the combined number. For example if k = 3, numK = input[i - 0]*100 + input[i-1]*10 + input[i-2]  We can build dp[i] for possible k using //Calculate numK //then {{ for(int j:dp[i-k]){  dp[i].add(numK + j)  dp[i].add(numK - j) } }}  Then we can count walprimes in the set of dp[N+1]. */"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I did it in php because it's cheap and dirty.  First calculates a possible permutation of the digits, and only at that point does it calculate the permutations of the +/-.  That should save a lot of operations, since other solutions which calculate the permutations along with the +/- at the same time will be calculating the same digit permutation over and over again with different combinations of +/-.  This problem is NP and huge, yes?  it seems like for each of the 2^n digit permutations there are 2^n permutations of +/- on the digits.  At the risk of asking something really stupid, is that O(2^(2n)) bound?    It uses O(n) extra space though.  There's commented code in there to return an answer array which would use much more, but this version just prints.  I'm aware this doesn't fit the output requirements of the problem.  This algorithm works up to the max int, could be made to work for much larger numbers using GMP.  But the universe might end before that completes."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's my (Java) solution.  I didn't include the io part, just a method that calculates the number of walprimes for an array of digits."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here is my java BFS solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I did it for only %5 and %7 .. but you should get the idea."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"is this similar to Karp-Robin algorithm ? this is used to check if the given string is substring of a bigger string and to compare it uses hash. It looks like a integer varient of same problem. it takes O(n) time ."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4860021380743168","download_status":"DOWNLOAD_DONE","votes":"5","answersCount":"70","title":"Given a binary representation of an integer say 15 as 1111, find the  maximum longest continous sequence of 0s. The twist is it needs to be done in log N. I could think of O(N) solution. but couldn't go for log(N).  For example. 10000101 the answer should be 4, because there are 4 continouos zeroes.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"That depends on what 'N' is. If it is the number '15', then the solution is easily found and it will be in log(N). If N is the number of digits, it is not possible to do it. Clearly you need to read the digits first to do anything."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Yes this could be done in O(log n)...you can use right shift operator which is basically dividing the number by 2 which leads to log n solution..here is a sample code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"It is possible. The question is reduced to how you can represent a number as addition of numbers which are power of 2  N  =  133   = 128 + 5  = 128 + 4 +1  Now, for each such number above, you know how many bits you need to represent that number and max diff of bits between two consecutive numbers is your answer. So for N = 128 + 4 +1 , you need bits 8(for 128), 3(for 4) and 1(for 1), so the answer is  Max[ (7-3) and (2-1) ] = 4. Why 7 and 2? Because with 8 bits to represent 128, MSB is set already so max you can have 7 bits 0 and same with 4 where you have MSB set so max 2 remaining bits."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#!/usr/bin/python \ndef longest0s(i): \n    #return a list of 0s and 1s \n    m = {} \n    nxt = i>>1 \n    if i == 0: \n        #return [0] \n        return 1 \n \n    m[-1] = 0 \n    count = 0 \n    while i != 0: \n        bit = i ^ nxt<<1 \n        if bit == 0 : \n            m[count] = m[count-1] + 1 \n        else: \n            m[count] = 0 \n        i = nxt \n        nxt = nxt>>1 \n        count = count + 1 \n \n    max = -1 \n    for key in m: \n        if max < m[key]: \n            max = m[key] \n    return max \n \nif __name__ == '__main__': \n    i = 200 \n    print longest0s(i)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nusing namespace std; \n \nint count_bits(int number) \n{ \n int count=0; \n           while(number) \n     { \n       number=number>>1; \n       count++; \n     } \n return count; \n} \n \nvoid main() \n{ \n \n int number=0; \n int bits=0; \n int max=0; \n int next_no=0; \n int next_bits=0; \n \n cout<<\"Enter Number= \"; \n cin>>number; \n \n while(number) \n { \n       bits=count_bits(number)-1; \n    next_no=number-pow(2.0,bits); \n \n           \n \n     if(next_no==0 && bits>max) \n     { \n      max=bits;  \n      break; \n     } \n \n     next_bits=count_bits(next_no)-1; \n      \n              if(bits-1-next_bits>max) \n     { \n                   max=bits-1-next_bits; \n     } \n \n     number=next_no; \n } \n \n \n  cout<<\"Max\"<<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \nint Find_longest_zeros( int n ){ \n if( n == 0 ){ \n  return 8*sizeof(int); \n } \n int stack[32]; \n int top = 0; \n int max_length = 0; \n //initialized stack??assign -1 to every element \n for( int i = 0 ; i < 32 ; i++){ \n  stack[i] = -1; \n } \n  \n while ( n != 0 ){ \n  if( n%2 != 0 ){ \n                 //if the remains is 1,we should compute the amount of the                     //element in stack \n   if( top > max_length ){ \n    max_length = top; \n   } \n   while( top > 0){ \n    stack[--top] = -1; \n   } \n  }else{ \n   stack[top++] = 0;   \n  } \n  n = n/2; \n } \n  \n if( top > max_length ){ \n  max_length = top; \n } \n printf(\"%d\\n\",max_length); \n return 1; \n} \nint main(){ \n Find_longest_zeros(133); \n return 1; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A method that in some cases can be slightly better than the obvious bit by bit examination"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"These are all great solutions. However, they operate based on an integer value input. I guess the question is how to use the binary representation of a given integer. If that's a valid guess, we can assume that the input to this function is a string of 0-1 values. I find the solution in O(n lg n) but still have problem turning it to an O(lg n). Here's the O(n log n) solution. Let see if we can use this as a starting point to find the O(lg n) solution, thanks!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think I have an O(lg n) solution. It is based on the binary representation of a value in form of a string."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Maybe I'm missed it, but it seems like the above solutions can be done in a much simpler way with bitwise operations:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This isn't possible as log n is smaller than the input size n of the binary string. This problem requires you to look at all the numbers as well."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"An idea is to shift 2 bits at a time instead of 1 bit. Then compares the 2 bits with the four possible situations 00, 01, 10, 11 to determine the maximum contiguous zeros. This is analogous to shifting 1 bit at a time and only compare the single bit to the 2 possible situation 0 and 1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is such a very hard problem, we are doomed! I did some searching someone posted it on stackoverflow and someone else referred to a horrible book (horrible like the Necronomicon or principia mathematica (it??s a heavy read: I am in awe of the author??s mental abilities)) called the Hacker??s Delight. I pieced together the code and got it running but understanding was still slow to come so I added lots of print statements and my own print out as binary function.  In the first step we do sort of a binary search using a shift and ??£þand??? process. When it manages to destroy all the 1s you know where the end of the longest set of 1s is.  Then you do a goto and jump into a set of things that follow a similar binary search sort of logic to get the first one back to the start. This is dependent on the operations you did before so some information is carried forward using your decision where to jump to.  Finally you call nlz which locates that bit using another binary search process.  This book is about writing ultra fast stuff for deep in the OS or in drivers or perhaps control systems. Which is why they worry about such strange stuff and why the loops are expanded. I??m not up to making it into a loop or something recursive. This would probably kill all the efficiency several times over the brute force O(n) solution any way.  Put some numbers into it and single step it for a while and see if you can grasp the idea. I can just barely do it myself.   I think the key here is to try to learn a little bit about how to think like the wizards and logicians of the Hacker??s Delight, and flounder around as gracefully as you can when Google makes a query of you. Good luck"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If i am not missing any boundary condition, I dont think it required any special algorithm to find it in O(logN)...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be done even in less complexity. complexity is number of 1's in a number. O(number of 1's)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int maxZeros(int num) { \n  cnt = 0; \n  maxCnt = 0; \n   \n  while (num > 0) { \n    if (num % 2 == 0) { \n       cnt++; \n    } else { \n       if (maxCnt < cnt) { \n          maxCnt = cnt; \n          cnt = 0; \n       } \n    } \n     \n    num = num/2; \n  } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include   int max (int a, int b) {  return (a>b?a:b);  } int solution(unsigned long int N) {  int flag = 0, count = 0, max_gap = 0;  unsigned long int temp = N;  while (temp>0)  {   if(flag == 1 && temp%2 == 0)   {    count++;    max_gap = max(max_gap,count);   }   else if(flag == 0 && temp%2 == 1)   {    flag = 1;    count = 0;   }   else if(flag == 1 && temp%2 == 1)   {    count = 0;   }   else //flag == 0 && temp%2 == 0   {    count = 0;   }   temp = temp/2;  }  //printf(\"max_gap - %d\\n\",max_gap);  return max_gap; }  int main(void) {  // your code goes here  unsigned long int N;  scanf(\"%u\",&N);  printf(\"%d\\n\",solution(N));  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \nint max (int a, int b) \n{ \n return (a>b?a:b);  \n} \nint solution(unsigned long int N) \n{ \n int flag = 0, count = 0, max_gap = 0; \n unsigned long int temp = N; \n while (temp>0) \n { \n  if(flag == 1 && temp%2 == 0) \n  { \n   count++; \n   max_gap = max(max_gap,count); \n  } \n  else if(flag == 0 && temp%2 == 1) \n  { \n   flag = 1; \n   count = 0; \n  } \n  else if(flag == 1 && temp%2 == 1) \n  { \n   count = 0; \n  } \n  else //flag == 0 && temp%2 == 0 \n  { \n   count = 0; \n  } \n  temp = temp/2; \n } \n //printf(\"max_gap - %d\\n\",max_gap); \n return max_gap; \n} \n \nint main(void) { \n // your code goes here \n unsigned long int N; \n scanf(\"%u\",&N); \n printf(\"%d\\n\",solution(N)); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// Code is based on string operation and it can be applied to any character sequence \npublic static void findMaxZeroSeq(String binNumber) { \n        int curr_state = 1; \n        int curr_max_index = -1, curr_start_index = -1; \n        int curr_max_seq = 0, curr_seq = 0; \n        for (int i = 0; i < binNumber.length(); ++i) { \n            if (curr_state == 1) { \n                if (binNumber.charAt(i) == '1') { \n                    continue; \n                } else if (binNumber.charAt(i) == '0') { \n                    curr_start_index = i; \n                    curr_seq = 1; \n                    curr_state = 0; \n                } \n            } else if (curr_state == 0) { \n                if (binNumber.charAt(i) == '0') { \n                    ++curr_seq; \n                    continue; \n                } else if (binNumber.charAt(i) == '1') { \n                    // Compare current sequence with current max \n                    if (curr_seq > curr_max_seq) { \n                        curr_max_index = curr_start_index; \n                        curr_max_seq = curr_seq; \n                    } \n                    curr_state = 1; \n                } \n            } \n        } \n        // Compare current sequence with current max \n        if (curr_seq > curr_max_seq) { \n            curr_max_index = curr_start_index; \n            curr_max_seq = curr_seq; \n        } \n        System.out.println(\"Max sequence starts at: \" + curr_max_index + \"; with value of: \" + curr_max_seq); \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This solves but it would be o(n) since it's the complexity of string.split..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I agree that the question as stated is ambiguous.  If N is the number of bits of the integer then all the implementation using shift operators won't result in a O(log(n)) solution. As many people have pointed out in the worst case for a 32bit int you still need 32 iterations to find the solution = O(n). I think people who thought of this problem as a \"string\" problem, e.q. a sting of \"0\" and \"1\" chars of non-specified length.  In this case the shortest sequence of contiguous \"0\" is 2.  So, the easy algorithm O(n) is counting the \"0\" in a string of \"0\" and \"1\" characters.  Knowing that we want to find the max. of contiguous  \"0\" a better algorithm is to count contiguous pairs of \"0\". This by definition should lead to a O(logn) algorithm. (Note: Assumption is that we can make the decision of \"00\" -> 1, (\"01\", \"10\") -> in O(1)). A further refinement of the algorithm that leads to parallelization is to divide the counting of the \"0\" pairs\" into subsets. Of course one has to account for the edge cases."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If bsr assembly instruction is available, my solution runs in O(M). M is the count of 1 bit in the integer. M = O(logN)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If n represents the integer, it is clear that we can have a O(lg n) solution.  However, when N represents the number of bits, it is impossible. Note that the bit operation, like bit \"and\", also spend O(n) time.  An adversary mode can prove this lower bound. Let us partition the N bits into two part. If you choose the left part, the adversary can eventually hide longer consecutive 0's in the right part, and vice versa. Therefore, we need to search both parts. Therefore, O(lg n) is impossible."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am beginning to think if these kind of questions are only asked to see how we go about trying to solve it. I don't think there's a solution with the resources available at hand."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"use lookup table? value->max 0s len. Then, lookup for each byte and (exercise for the reader)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Is the input given in binary representation or integer? As I read the question it says \"Given the binary representation....\"  So if the input is binary rep.....then converting it to int and logic using modulo 2??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Solution should be recursive approach. (Divide and Conquer) 1) Divide the given binary into two halves (left and right) 2) Call recursively on left and right 3) calls to each left and right will return with max of continuous zeros that can be concatenated with the other half and one that cannot be concatenated 4) calculate same return values based on the returned values and return"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"int lsZero(int num){    int mx =0, cnt=0;     while(num > 1){           if(num & 1) {mx = max(mx,cnt); cnt = 0;}           else cnt++;           num>>=1;  }    mx = max(mx,cnt); return mx; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public class FindZero {          static int findMaxZero(int n){          int maxCount = 0;         int count = 0;   if(n == 0)   return 1;   while(n != 0){             if(n % 2 == 0){   maxCount++;   if(count < maxCount)                     count = maxCount;   }   else{                     maxCount = 0;   }    n = n / 2;  }   return count;      }          public static void main(String args[]){         System.out.println(findMaxZero(11));     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Easy task. Just think about how you convert a number to binary.  code in java:   int maxNumerOfContinuousZero(int n) {   int result = 0;   int tmp=0;   while(n>1){    if(n%2 ==0){     tmp++ ;     n = n/2;    }    else{     if(tmp> result){      result = tmp;     }     n = (n-1)/2;    }     }      if(tmp>result){    result= tmp;   }      return result;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"The logic would be to recursively do this->  if i is divisible by 2 then add 1 to max number of zeroes of max number of zeroes of i/2;  if i is odd then terminate adding and calculate max number of zeroes for i/2 and compare the max zeroes before i to the max zeroes by i/2  max for 1 is 0   I think this should work fine with log n complexity since we are going on dividing it by 2."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"int longestConsecutiveZeros(int num) \n{ \n int cnt = 0; \n int maxCnt = 0; \n \n while(num > 0) \n { \n  if(num % 2 != 0)  \n{ \n if(cnt > maxCnt) maxCnt = cnt; \ncnt = 0; \n} \nelse \n{ \n ++cnt; \n} \nnum = num / 2; \n} \n \nif(cnt != 0 && cnt > maxCnt) \n{ \n maxCnt = cnt; \n} \n \nreturn maxCnt; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"This simply isn't possible."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6330205329162240","download_status":"DOWNLOAD_DONE","votes":"4","answersCount":"32","title":"You have two integer arrays. Treat these arrays as if they were big numbers, with one digit in each slot. Perform addition on these two arrays and store the results in a new array.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"13","title":"int *AddArrays(int a[], int alen, int b[], int blen) \n{ \n int maxLen = max(alen, blen); \n int *c = new int[maxLen + 1]; \n \n int acur = alen - 1; \n int bcur = blen - 1; \n int ccur = maxLen; \n int carry = 0; \n \n while(ccur >= 0) \n { \n  int cur = carry; \n  if(acur >= 0) \n   cur += a[acur--]; \n  if(bcur >= 0) \n   cur += b[bcur--]; \n \n  c[ccur--] = cur % 10; \n  carry = cur/10; \n} \n \nreturn c; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For fun because I wanted to act on a hunch that a few liner was possible.  Though I expanded a line into multiple to make it clear that 3 possible cases of sum are being calculated.  Call this with b[] being bigger array, r[] having length b.length+1, and last argument 0 (use a wrapper if you like): b stands for bigger, s for smaller, r for result"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  int array_add(int *result, int data_1[], int len_1, int data_2[], int len_2){  if( len_1 < 0 || len_2 < 0 ){   return -1;  }  int i,j,k;  int temp;  // i = (len_1 < len_2 ? len_1-1:len_2-1);  temp = 0;  i = len_1 -1;  j = len_2 -1;  k = (len_1 > len_2 ? len_1:len_2);   for( ; i > -1 && j > -1 ; i--,j--){   temp = data_1[i] + data_2[j] +result[k];   result[k] = temp%10;   result[k-1] = result[k-1] + temp/10;   k--;  }   // j = (len_1 > len_2 ? len_1-len_2-1 : len_2-len_1-1);    if(i > -1){   while( i > -1 ){    temp = result[k] + data_1[i];    result[k] = temp%10;    result[k-1] = result[k-1] + temp/10;    i--;    k--;   }  }else if( j > -1 ){   while( j > -1 ){    temp = result[k]+ data_2[j];    result[k] = temp%10;    result[k-1] = result[k-1] + temp/10;    j--;    k--;   }  }  return 1; } int main(){  int array_1[5] = {2,3,4,6,7};  int array_2[6] = {5,7,2,7,8,3};  int i;  int *result = (int *)malloc(sizeof(int)*7);  for ( i = 0; i < 7 ; i++ ){   result[i] = 0;  }         array_add(result,array_1,5,array_2,6);         for ( i = 0; i < 7 ; i++ ){   printf(\"%d  \",result[i]);  }  printf(\"\\n\");  return 1; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Not sure if I'm missing something or I misunderstood the problem but here is mine. It seems to work."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Well, here's a fun way of doing it, not really any more efficient than the other methods shown here, this one uses a stack."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int[] AddArrays(int[] a, int lengtha, int[] b, int lengthb) \n        { \n            int[] result = new int[Math.Max(lengtha, lengthb) + 1]; \n \n            int indexa = lengtha - 1; \n            int indexb = lengthb - 1; \n \n            int indexResult = result.Length - 1; \n \n            int carryOver = 0; \n \n            while (indexa >= 0 || indexb >= 0) \n            { \n                int valuea = 0; \n                int valueb = 0; \n \n                if (indexa >= 0) \n                { \n                    valuea = a[indexa]; \n                    indexa--; \n                } \n \n                if (indexb >= 0) \n                { \n                    valueb = b[indexb]; \n                    indexb--; \n                } \n \n                if (valuea / 10 > 0) \n                { \n                    throw new ArgumentException(); \n                } \n \n                if (valueb / 10 > 0) \n                { \n                    throw new ArgumentException(); \n                } \n \n                int tmp = valuea + valueb + carryOver; \n                result[indexResult] = tmp % 10; \n                carryOver = tmp / 10; \n \n                indexResult--; \n            } \n \n            if (indexResult != 0 && indexResult != 1) \n            { \n                throw new InvalidOperationException(); \n            } \n \n            return result;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java Solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nusing namespace std; \n \nvoid print(int * added_arr,int size ) \n{ \n    for(int i=0; i=0; i--) \n  { \n   add=first_num[i] + second_num[size_of_2st_no-1]; \n \n   if(add>9) \n   { \n           first_num[i]=add%10;     // store the result   \n     first_num[i-1]=first_num[i-1] + 1;  // in the case of carry adding  \n   } \n   else \n   { \n           first_num[i]=add; \n   } \n \n   size_of_2st_no--; \n \n  } \n \n  if(i>0 &&  first_num[i] > 9 ) \n  { \n   while(i>=0 && first_num[i] > 9) \n   { \n    first_num[i]=0; \n    first_num[i-1]=first_num[i-1]+1; \n    i--; \n   } \n  } \n} \n \nvoid main() \n{ \n   int size_of_1st_no=0; \n   int size_of_2st_no=0; \n   cout<<\"Enter Size of first Array::\"; \n   cin>>size_of_1st_no; \n   cout<<\"Enter Size of second Array::\"; \n   cin>>size_of_2st_no; \n   //---------Create arrys for both numbers. Number arry that is biger used to store the result later  \n   int * first_num; \n   int * second_num; \n   if(size_of_1st_no >= size_of_2st_no) \n   { \n   size_of_1st_no=size_of_1st_no+1;   // one index more in case of over flow \n   first_num=new int [size_of_1st_no]; \n   second_num=new int [size_of_2st_no]; \n   } \n   else \n   { \n   size_of_2st_no=size_of_2st_no+1;   // one index more in case of over flow \n   first_num=new int [size_of_1st_no]; \n   second_num=new int [size_of_2st_no]; \n   } \n \n   int i=0; \n   int j=0; \n \n   if(size_of_1st_no >= size_of_2st_no) \n   { \n   i=1; j=0; \n   first_num[0]=0; \n   } \n   else \n   { \n   i=0; j=1; \n   second_num[0]=0; \n   } \n \n  for( ; i>first_num[i]; \n   } \n \n \n   for( ; j>second_num[j]; \n   } \n \n   if(size_of_1st_no>size_of_2st_no) \n       sum(first_num, second_num,size_of_1st_no,size_of_2st_no); \n   else \n    sum(second_num, first_num,size_of_2st_no,size_of_1st_no); \n \n   if(size_of_2st_no>=size_of_1st_no) \n       print(second_num,size_of_2st_no); \n   else \n    print(first_num,size_of_1st_no); \n \n   //----------------------------------------- \n  system(\"pause\"); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"alist =             [1, 2, 4, 5, 6, 7] \nblist =          [9, 9, 3, 3, 2, 1, 9] \nsumlist = [] \n \nalen = len(alist) - 1 \nblen = len(blist) - 1 \n \ncarry = 0 \nwhile alen >= 0 or blen >= 0: \n    a = 0 \n    b = 0 \n    if alen >= 0: \n        a = alist[alen] \n    if blen >= 0: \n        b = blist[blen] \n    absum = (a + b + carry) % 10 \n    carry = (a + b + carry) / 10 \n    sumlist[:0] = [absum] \n    alen -= 1 \n    blen -= 1 \n \nif carry > 0: \n    sumlist[:0] = [carry] \nprint sumlist"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"github.com/vikhyath/c-runs/tree/master/sum-arrays  github.com/vikhyath/python-runs/tree/master/sum-arrays"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java Solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There's already a simple straightforward solution.  A more performant solutions would use some sort of SIMD, like SSE2. You'd have to do an add operation to add the two arrays, divide by 10 to get the carry, re-align the resultant carry data, then add the carry."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My intuitive algorithm:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// assume the integers are positive // 1-Select the size of the biggest array maxLen // 2-Start the sum from the end of the selected array // carry = 0; // x goes from maxLen-1 to 0 // y = ( 0 or a[x] if x// if y>9 // y = 10-y and carry = 1 // else // carry = 0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I used long instead of int just so it could handle larger values.   public static void main(String arg[]) {  long[] arraySum1 = { 1, 2, 3, 4, 5, 1, 9, 8, 9, 3, 4 };  long[] arraySum2 = { 1, 2, 9, 4, 5, 2, 3, 8, 5 };  long arraySum = arraySum(arraySum1, arraySum2);  System.out.println(arraySum);  } public static long arraySum(long[] x, long[] y) {  int a = x.length - 1, b = y.length - 1;  long sum = 0;  while (a >= 0 || b >= 0) {   if (a >= 0)     {sum += x[a] * Math.pow(10, x.length - a - 1);}   if (b >= 0)     {sum += y[b] * Math.pow(10, y.length - b - 1);}   System.out.println(sum);   a--; b--;  }  return sum; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I used long instead of int just so it could handle larger values.   public static void main(String arg[]) {  long[] arraySum1 = { 1, 2, 3, 4, 5, 1, 9, 8, 9, 3, 4 };  long[] arraySum2 = { 1, 2, 9, 4, 5, 2, 3, 8, 5 };  long arraySum = arraySum(arraySum1, arraySum2);  System.out.println(arraySum);  } public static long arraySum(long[] x, long[] y) {  int a = x.length - 1, b = y.length - 1;  long sum = 0;  while (a >= 0 || b >= 0) {   if (a >= 0)     {sum += x[a] * Math.pow(10, x.length - a - 1);}   if (b >= 0)     {sum += y[b] * Math.pow(10, y.length - b - 1);}   System.out.println(sum);   a--; b--;  }  return sum; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"How's it stored and in what type of array?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public class Sum {          static int a1[] = {1,2,3,4};     static int a2[] = {9,9,9,9};     static int a3[];             static void findSum(int a1[], int a2[]){                int len1 = a1.length-1, len2 = a2.length-1, len3 = a3.length-1;         int carry = 0,sum;         while(len2 != -1){             sum  = a1[len1--] + a2[len2--]+carry;             carry  = sum / 10;             a3[len3--] = sum%10;         }         while(len1 != -1){             sum  = a1[len1--] + carry;             a3[len3--] = sum%10;             carry = sum/10;         }         a3[len3] = carry;         for(int  i = 0; i             System.out.print(a3[i]);         }     }          public static void main(String args[]){         if(a1.length>a2.length){             a3 = new int[a1.length+1];             findSum(a1,a2);         }         else{             a3 = new int[a2.length+1];             findSum(a2,a1);         }     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public static void main(String[] args) {         int[] a = {9,5,7,2,4,8,5,9,1,5};         int[] b = {9,1,1,1,2,3,8,5,9,1};         add(a,b);     }          static void add(int[] x, int[] y){         int xLength = x.length;         int yLength = y.length;         int zLength = Math.max(xLength, yLength)+1;         int[] z = new int[zLength];         int k = 0;         for (int i=1;i<=zLength;i++){             if(xLength-i<0 && yLength-i>=0){                 z[zLength-i] = (y[yLength-i]+k)%10;                 k = (y[yLength-i]+k)/10;             }             else if(yLength-i<0 && xLength-i>=0){                 z[zLength-i] = (x[xLength-i]+k)%10;                 k = (x[xLength-i]+k)/10;             }             else if(yLength-i<0 && xLength-i<0){                 z[zLength-i] = k;             }             else if(yLength-i>=0 && xLength-i>=0){                 z[zLength-i] = (x[xLength-i]+y[yLength-i]+k)%10;                 k = (x[xLength-i]+y[yLength-i]+k)/10;             }         }         for (int i=0;i            System.out.print(z[i]);         }          System.out.println();            }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#!/usr/bin/env python \n \n \n \ndef getVal(tlist, i): \n    if i < len(tlist): \n        return tlist[i] \n    else: \n        return 0 \n \ndef addNum(list1,list2): \n    total = list() \n    carryOn = 0 \n    index1 = len(list1)-1 \n    index2 = len(list2)-1 \n    while index1 >= 0 and index2 >= 0: \n        tsum = list1[index1] + list2[index2] + carryOn \n        total.append(tsum%10) \n        carryOn = int(tsum/10) \n        index1-=1 \n        index2-=1 \n        print total,index1,index2 \n    if index2 < 0: \n        while index1 >=0: \n            tsum = carryOn + list1[index1] \n            total.append(tsum%10) \n            carryOn = int(tsum/10) \n            index1-=1 \n            print total \n    else: \n        while index2 >=0: \n            tsum = carryOn + list2[index2] \n            total.append(tsum%10) \n            carryOn = int(tsum/10) \n            index2-=1 \n    return total[::-1] \n             \nif __name__ == '__main__': \n    list1 = [1,2,3,4,8] \n    list2 = [3,7,8,9,2,3,4] \n     \n    print addNum(list1,list2)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5760472011767808","download_status":"DOWNLOAD_DONE","votes":"-3","answersCount":"18","title":"4 individual numbers which could be permuted in 4 factorial ways. permutation of these 4 integers is an 0indexedarray consisting of 4 digits in some order when integers are different. the best permute of the 4 integers is by the following funciton  func(summ) = abs(summ[0] - summ[1]) + abs(summ[1] - summ[2] + abs(summ[2] - summ[3])) that would give maximum value.  method signature  public int answer(int w, int x, int y, int z){  }  w = 5 x = 3 y = -1 z = 5  the sample permute wiht given numbers in the given function that would give maximum value is as follows.  for the  summ[0] =  5 summ[1] = -1 summ[2] = 5  summ[3] = 3  This should be done in O(1)time ans space complexity. My questions wordings may be confusing, but the function and sample data are perfectly correct.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"summ[0]=first maximum, summ[1]=first minimum, summ[2]=second maximum, summ[3]=second minimum.. .now these could be found using some conditional statements that would run for O(1) time and also since the number of variables are constant the space complexity is O(1)...now u can apply the formula to find the value"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How is the solution to this supposed to run in O(1) ? Are you sure it's not O(n) time and O(1) space?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Let??s say, we have an array that has w,x,y,z by sorted.  a[0] will be smallest element in w,x,y,z. a[3] will be maximun. The answer is  summ[0] = a[3] summ[1] = a[0] summ[2] = a[2] summ[3] = a[1]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"///public class MaxValue {      public static void main(String[] args) {         MaxValue maxValue = new MaxValue();         maxValue.maxValue(7,7,1,4);     }      public int maxValue(int a,int b,int c,int d){          int max = 0;         int min = 0;         //a=2.b=7,c=1,d=4         max = Math.max(Math.max(a,b),Math.max(c,d));//7         min = Math.min(Math.min(a,b),Math.min(c,d));//1          int sum = a+b+c+d;//14          int aPlusB = max+min;         int cPlusD = sum - aPlusB;         int v4 = Math.max(Math.abs(cPlusD - max),Math.abs(cPlusD-aPlusB));         int v3 = sum  - (aPlusB+v4);          System.out.println(\"a \"+max);         System.out.println(\"b \"+min);         System.out.println(\"c \"+v3);         System.out.println(\"d \"+v4);          return 0;      } }\\\\\\"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"summ[0]=second min,  summ[1]=first max,  summ[2]=first min,  summ[3]=second max.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If it's sorted ascending, it should be a[2] a[4] a[1] a[3],  or reverse it. We can compare all the result."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4774716350922752","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"75","title":"In a language, there are only 4 characters ??h??, ??i??,??r??, ??e??. and we have to write a function which takes a string as input and returns whether the given input string is a ??£þvalid word??? or not.  Definition of valid word : 1. A given word is a valid word if it is of the form h^n i^n r^n e^n  where n >=1. (eg: hhiirree) 2. Valid words has concatenation property i.e. if w1 and w2 are valid words w1w2 is also a valid word.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Let's make it an \"ordered\" alphabet array by letting (compile time fixed or get from somewhere at runtime):    alpha[]={ your ordered list of characters in your alphabet } M  be size of your ordered alphabet (i.e., size of alphabet array above)  idea:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This is another problem where using a state machine would be useful.  We have 4 states.  Depending on what??s being read at each state, we can either transition to the next state or we can simply return false (basically we reach an invalid state).  If we have reached the end of the string and our state is the final state, we can simply return true; otherwise, we return false.    Following is the state machine.  We need to consider the input h, i, r, e.  The tricky part is that at each state, we should focus on what we are expecting and whatever we get is NOT what we are expecting, we return fasle.  This corresponds to the invalid state.  For example, in State 0, we expect either ??h?? or ??i'.  If we don??t get either, we return false.  In State 1, we expect either ??i' or ??r??.  If we don??t get either, we return false.   We have the following states: S0: initial state. S1 and S2: intermediate states. S3: state when pattern h^n i^n r^n e^n is achieved.  Here is the SM transition: INPUT   CURRENT_STATE   NEXT_STATE     h    S0        S0     i    S0        S1 (!h && !i)    S0        invalid       i    S1        S1     r    S1        S2 (!i && !r)    S1        invalid        r    S2        S2     e    S2        S3 (!r && !e)    S2        invalid       e    S3        S3     h    S3        S0 (!e && !h)    S3        invalid   Here is the code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"EDIT: I overlooked certain restrictions.  My solution would be to design a simple Automata that handles this (In this case, a simple 5 state DFA can handle this). Here is a code. I think it works."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class Language \n    { \n        public void TestForValidLanguage() \n        { \n            string languageWord = \"HHIIRREEHIREHHHIIIRRREEEE\"; \n            bool isValid = IsValidLanguage(languageWord, \"HIRE\"); \n        } \n \n        public bool IsValidLanguage(string languageWords, string language) \n        { \n            int counter = 0; \n            int languageLength = -1; \n \n            int languageIndex = 0; \n            for (int i = 0; i < languageWords.Length; i++) \n            { \n                if (languageWords[i] == language[languageIndex]){} \n \n                else if (languageWords[i] == language[(languageIndex + 1)%language.Length]) \n                { \n                    if (languageLength == -1) \n                    { \n                        languageLength = counter; \n                    } \n \n                    if (counter != languageLength) \n                    { \n                        return false; \n                    } \n \n                    if ((languageIndex + 1) >= language.Length) \n                    { \n                        if (languageLength != counter) \n                        { \n                            return false; \n                        } \n                        //Reset the language length for the new word. \n                        languageLength = -1; \n                    } \n                    languageIndex = (languageIndex + 1)%language.Length; \n                    counter = 0; \n                } \n                else \n                { \n                    return false; \n                } \n                counter++; \n            } \n \n            return counter == languageLength; \n        } \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"boolean isValid(String str) {   if (str == null || str.length < 4) {  return false;   }    Set set = new HashSet();   for (int i=0; i char c = str.charAt(i);  if (c != 'h' && c != 'i' && c != 'r' && c != 'e') {   return false;  }  set.add(c);   }   return (set.size() == 4); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"# Runs in constant memory space, the check terminates ones it determines that an alien character not present in our language definition is found \n# Runs in O(n) time \nchars = ['h', 'i', 'r', 'e'] \n \ndef check(string, adict = None): \n    if adict is None: \n        adict = {} \n    count = 0 \n    previous = None \n    wordcomplete = 0    \n    for letter in string: \n        if letter not in chars: \n            print 'Invalid for:',string \n            return \n \n        # first word, that is not a part of concatenated sequence, ignore checks \n        if letter == 'h' and wordcomplete == 0: \n            pass \n \n        # found last valid letter, now make the dict eligible for checking when we hit 'h' next time \n        if letter == 'e' and wordcomplete == 0: \n            wordcomplete = 1 \n         \n        if letter == 'h' and wordcomplete > 0: \n            # reset flag \n            wordcomplete = 0 \n            result = verifypass(adict) \n            if result == -1: \n                print 'Invalid for:',string \n            else: \n                adict = {} \n \n        if letter not in adict: \n            adict[letter] = 1 \n        else: \n            adict[letter] += 1 \n \n    # check for last pass \n    result = verifypass(adict) \n    if result == -1: \n        print 'Invalid for:',string \n    else: \n        print 'Valid for:',string \n \ndef verifypass(adict): \n    # some char missing \n    if len(adict) < 4: \n        return -1 \n    previouscount = -1 \n    for key, val in adict.iteritems(): \n        if previouscount != -1 and val != previouscount: \n            return -1 \n        else: \n            previouscount = val \n    # successful pass, return 1 \n    return 1 \n \ndef main(): \n    check('hhiirree') \n    check('hire') \n    check('hhiirreee') \n    check('hired') \n    check('hhiirrree') \n    check('hirehhiirree') \n    check('hiredhiirreeddhiree') \n    check('hie') \n \nif __name__ == '__main__': \n    main()"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A naive approach"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This question was asked in Topcoder SRM 592"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is an O(n) approach:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static boolean isValidWord(final String word){   String alphabetStr = \"hire\";   char []alphabets = alphabetStr.toCharArray();   char []wordChar = word.toCharArray();   int []countArr = new int[4];   for(int i=0;i<4;i++){    countArr[i]=0;   }   boolean isValid = true;   int j=0;   for (int i = 0; i < wordChar.length; i++) {    if(wordChar[i]==alphabets[j=(j>3)?0:j]){     countArr[j]=countArr[j]+1;    }else if(wordChar[i] == alphabets[j=(j>=3)?0:(j+1)]){     countArr[j]=countArr[j]+1;    }else{     isValid=false;     break;    }       }   if(!isValid)   return isValid;     for (int i = 0; i < countArr.length-1; i++) {    if(countArr[i]!=countArr[i+1]){     isValid=false;     break;    }      }     return isValid;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static boolean isvalidWord(String word) { \n \n  char [] wordChar = word.toCharArray(); \n  int hCounter = 0, iCounter = 0, rCounter=0,eCounter=0; \n  boolean hVisitFlag=false,iVisitFlag=false,rVisitFlag=false,eVisitFlag=false ; \n  boolean wordMismatch = false; \n  for (int i=0; i< wordChar.length; i++) { \n     \n    switch (wordChar[i]) { \n    case 'h': \n     if(!hVisitFlag)  \n      if(hCounter != iCounter || hCounter != rCounter || hCounter != eCounter) { \n      wordMismatch = true; break; \n     } \n     hCounter++; \n     hVisitFlag=true; iVisitFlag=false;rVisitFlag=false;eVisitFlag=false; break; \n    case 'i': \n     iCounter++; \n     if(!iVisitFlag && !hVisitFlag) {       \n       wordMismatch = true; break; \n     } \n     iVisitFlag=true; hVisitFlag=false;rVisitFlag=false;eVisitFlag=false; break; \n    case 'r': \n     rCounter++; \n     if(!rVisitFlag && !iVisitFlag) { \n      wordMismatch = true; break; \n     } \n     rVisitFlag=true; iVisitFlag=false;hVisitFlag=false;eVisitFlag=false; break; \n    case 'e': \n     eCounter++; \n     if(!eVisitFlag && !rVisitFlag){ \n      wordMismatch = true; break; \n     } \n     eVisitFlag=true; iVisitFlag=false;rVisitFlag=false;hVisitFlag=false;   break;    \n    } \n     \n    if(wordMismatch) return !wordMismatch;    \n  }   \n  return true; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static boolean isValidWord(char[] word) { \n  if (word == null || word.length == 0 || word.length % 4 != 0) { \n   return false; \n  } \n  if (word[0] != 'h' || word[word.length - 1] != 'e') { \n   return false; \n  } \n \n  int cnta = 1; \n  int cntb = 1; \n  char last_scan = 'h'; \n \n  for (int i = 1; i < word.length; i++) { \n   switch (last_scan) { \n   case 'h': \n \n    if (word[i] == 'h') { \n     cnta++; \n     cntb++; \n    } else if (word[i] == 'i') { \n     cntb--; \n     last_scan = 'i'; \n    } else { \n     return false; \n    } \n    break; \n   case 'i': \n \n    if (word[i] == 'i') { \n     cntb--; \n    } else if (word[i] == 'r' && cntb == 0) { \n     cntb = 1; \n     last_scan = 'r'; \n    } else { \n     return false; \n    } \n    break; \n   case 'r': \n \n    if (word[i] == 'r') { \n     cntb++; \n    } else if (word[i] == 'e' && cntb == cnta) { \n     cntb--; \n     last_scan = 'e'; \n    } else { \n     return false; \n    } \n    break; \n   case 'e': \n \n    if (word[i] == 'e') { \n     cntb--; \n    } else if (word[i] == 'h' && cntb == 0) { \n     cnta = 1; \n     cntb = 1; \n     last_scan = 'h'; \n    } else { \n     return false; \n    } \n    break; \n   } \n  } \n  if (cntb == 0 && last_scan == 'e') \n   return true; \n  return false;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static boolean isValidWord(char[] word) { \n  if (word == null || word.length == 0 || word.length % 4 != 0) { \n   return false; \n  } \n  if (word[0] != 'h' || word[word.length - 1] != 'e') { \n   return false; \n  } \n \n  int cnta = 1; \n  int cntb = 1; \n  char last_scan = 'h'; \n \n  for (int i = 1; i < word.length; i++) { \n   switch (last_scan) { \n   case 'h': \n \n    if (word[i] == 'h') { \n     cnta++; \n     cntb++; \n    } else if (word[i] == 'i') { \n     cntb--; \n     last_scan = 'i'; \n    } else { \n     return false; \n    } \n    break; \n   case 'i': \n \n    if (word[i] == 'i') { \n     cntb--; \n    } else if (word[i] == 'r' && cntb == 0) { \n     cntb = 1; \n     last_scan = 'r'; \n    } else { \n     return false; \n    } \n    break; \n   case 'r': \n \n    if (word[i] == 'r') { \n     cntb++; \n    } else if (word[i] == 'e' && cntb == cnta) { \n     cntb--; \n     last_scan = 'e'; \n    } else { \n     return false; \n    } \n    break; \n   case 'e': \n \n    if (word[i] == 'e') { \n     cntb--; \n    } else if (word[i] == 'h' && cntb == 0) { \n     cnta = 1; \n     cntb = 1; \n     last_scan = 'h'; \n    } else { \n     return false; \n    } \n    break; \n   } \n  } \n  if (cntb == 0 && last_scan == 'e') \n   return true; \n  return false; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class WordValidator \n    { \n        private static char[] OrderedAcceptableCharacters = new char[] { 'h', 'i', 'r', 'e' }; \n \n        public static bool ValidateWord(string word) \n        { \n            int currentIndex = 0; \n            int currentAcceptableCharacterIndex = 0; \n \n            while (currentIndex < word.Length) \n            { \n                if (word[currentIndex] == OrderedAcceptableCharacters[currentAcceptableCharacterIndex]) \n                { \n                    currentIndex++; \n                } \n                else \n                { \n                    currentAcceptableCharacterIndex++; \n                    if (currentAcceptableCharacterIndex >= OrderedAcceptableCharacters.Length) \n                    { \n                        if (word[currentIndex] == OrderedAcceptableCharacters[0]) \n                        { \n                            return ValidateWord(word.Substring(currentIndex)); \n                        } \n                        else \n                        { \n                            return false;    \n                        } \n                    } \n                    else if (word[currentIndex] == OrderedAcceptableCharacters[currentAcceptableCharacterIndex]) \n                    { \n                        currentIndex++; \n                    } \n                    else \n                    { \n                        return false; \n                    } \n                } \n            } \n \n            return true; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"String alphabetStr = \"hire\"; \n  char []alphabets = alphabetStr.toCharArray(); \n  char []wordChar = word.toCharArray(); \n  int []countArr = new int[4]; \n  for(int i=0;i<4;i++){ \n   countArr[i]=0; \n  } \n  boolean isValid = true; \n  int j=0; \n  for (int i = 0; i < wordChar.length; i++) { \n   if(wordChar[i]==alphabets[j=(j>3)?0:j]){ \n    countArr[j]=countArr[j]+1; \n   }else if(wordChar[i] == alphabets[j=(j>=3)?0:(j+1)]){ \n    countArr[j]=countArr[j]+1; \n   }else{ \n    isValid=false; \n    break; \n   } \n    \n  } \n  if(!isValid) \n  return isValid;   \n  for (int i = 0; i < countArr.length-1; i++) { \n   if(countArr[i]!=countArr[i+1]){ \n    isValid=false; \n    break; \n   }    \n  }   \n  return isValid; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have a solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static boolean isValidWord(final String word){ \n  String alphabetStr = \"hire\"; \n  char []alphabets = alphabetStr.toCharArray(); \n  char []wordChar = word.toCharArray(); \n  int []countArr = new int[4]; \n  for(int i=0;i<4;i++){ \n   countArr[i]=0; \n  } \n  boolean isValid = true; \n  int j=0; \n  for (int i = 0; i < wordChar.length; i++) { \n   if(wordChar[i]==alphabets[j=(j>3)?0:j]){ \n    countArr[j]=countArr[j]+1; \n   }else if(wordChar[i] == alphabets[j=(j>=3)?0:(j+1)]){ \n    countArr[j]=countArr[j]+1; \n   }else{ \n    isValid=false; \n    break; \n   } \n    \n  } \n  if(!isValid) \n  return isValid;   \n  for (int i = 0; i < countArr.length-1; i++) { \n   if(countArr[i]!=countArr[i+1]){ \n    isValid=false; \n    break; \n   }    \n  }   \n  return isValid;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool validWord(char st[], char ch[4]){ \n    int stlen = strlen(st); \n    int stindex = 0; \n    int n = 0; \n    for(int i =0; i<4; i++){ \n        if(i==0){ \n            while(stindex < stlen && st[stindex] == ch[i]){ \n                n += 1; \n                stindex += 1; \n            } \n        }else{ \n            int count = 0; \n            while( stindex < stlen && st[stindex] == ch[i]){ \n                stindex += 1; \n                count += 1; \n            } \n            if(count != n) \n                return false; \n        } \n    } \n    if(stindex < stlen) \n        return validWord(&st[stindex],  ch); \n    else \n        return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#!/usr/bin/env python \n \nimport re \nimport sys \n \nindex = 0 \nlist1 = ['h','i','r','e'] \nlength = 0 \ndef checkValid(inputStr, i): \n    #print inputStr,i \n    if inputStr: \n        try: \n            match = re.search(list1[i]+'+',inputStr) \n            matchString = match.group(0) \n            if i == 0: \n                global length \n                length = len(matchString) \n            else: \n                if len(matchString) != length: \n                    return False \n        except AttributeError,e: \n            return False \n        global index \n        if i == len(list1)-1: \n            index = 0 \n        else: \n            index = i+1 \n        return checkValid(inputStr[len(matchString):],index) \n    else: \n        if i == 0: \n            return True \n        else: \n            return False \n     \n     \n     \nif __name__ == '__main__': \n    inputStr = sys.argv[1] \n    if inputStr == \"\": \n        print False \n    else: \n        print checkValid(inputStr,index)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#!/usr/bin/env python \n \nimport re \nimport sys \n \nindex = 0 \nlist1 = ['h','i','r','e'] \nlength = 0 \ndef checkValid(inputStr, i): \n    #print inputStr,i \n    if inputStr: \n        try: \n            match = re.search(list1[i]+'+',inputStr) \n            matchString = match.group(0) \n            if i == 0: \n                global length \n                length = len(matchString) \n            else: \n                if len(matchString) != length: \n                    return False \n        except AttributeError,e: \n            return False \n        global index \n        if i == len(list1)-1: \n            index = 0 \n        else: \n            index = i+1 \n        return checkValid(inputStr[len(matchString):],index) \n    else: \n        if i == 0: \n            return True \n        else: \n            return False \n     \n     \n     \nif __name__ == '__main__': \n    inputStr = sys.argv[1] \n    if inputStr == \"\": \n        print False \n    else: \n        print checkValid(inputStr,index)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assume that n is intended to be the same for every char in the dictionary and n>=1.  Main idea is borrowed from BrAiNleSs ????. Thanks for your \"ordered array\"."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Check for two words. If both words are valid then concatenation is not needed to be checked. Substringing from 0 to N-1 remembering previous index of the substring."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java Solution  Using Regex (Note you should compile the pattern once if possible):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include void main() {   int i,cnt=1,a[10],n=0;   char ch[20];   printf(\"\\n Enter the Valid Word : \");   scanf(\"%s\",ch);   for(i=0;ch[i]!='\\0';i++)     {       if(ch[i]==ch[i+1])  {    cnt++;  }       else  {    a[n]=cnt;    cnt=1;    n=n+1;  }     }   cnt=0;   for(i=0;i    {       if(a[i]==a[i+1])        {          cnt=0;        }       else        {          cnt=1;        }     }   if(cnt==1)     printf(\"\\nNot a Valid Word \");   else     printf(\"\\nIt is a Valid Word \");  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class WordCheck { \n public static boolean check(String input) { \n  if (input == null) \n   return false; \n  char[] chars = new char[] { 'h', 'i', 'r', 'e' }; \n  int index = 0; \n  for (int i = 0; i < input.length(); i++) { \n   if (chars[index] == input.charAt(i)) \n    continue; \n   int next = (index + 1) % 4; \n   if (chars[next] == input.charAt(i)){ \n    index = next; \n    continue; \n   } \n \n   return false; \n  } \n  if (index != 3) { \n   return false; \n  } \n  return true; \n } \n \n public static void main(String[] argv) { \n  assert true == check(\"hire\"); \n  assert true == check(\"hirehire\"); \n  assert true == check(\"hhiiiirrrreeeee\"); \n  assert true == check(\"hhiiiirrrreeeeehirrree\"); \n  assert true == check(\"hhiiiirrrreeeeehirrreehirree\"); \n  assert false == check(\"hhiiiirrrreeeeehirr\"); \n  assert false == check(\"hhiiiirrhirr\"); \n  assert false == check(\"\"); \n  assert false == check(null); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There is a simple non-generic version for this specific case."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I wonder if this would be acceptable:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool isValid(const string& str) { \n  const string alphabet = \"hire\"; \n  int curPos = 0; \n  int count = 0; \n  int tmpcount = 0; \n \n  for (int i = 0; i < str.length(); ++i) { \n    if (str[i] == 'h') ++count; \n    else { \n      // Indicates valid transition from 'h' \n      if (count && (curPos == 0)) { ++curPos; curPos %= alphabet.length(); tmpcount = 0; } \n \n      // Check if current char matches curPOs \n      if (str[i] != alphabet[curPos]) return false; \n \n      ++tmpcount; \n \n      // Indicates (expected) transition from 'cur' to 'next' \n      if (tmpcount == count) { \n        tmpcount = 0;  \n        ++curPos; curPos %= alphabet.length();  \n        if (curPos == 0) count = 0; // reset count if we are going to next cycle of 'h' \n      } \n    } \n  } \n \n  if (curPos != 0) return false; \n  if (str[str.length() - 1] != alphabet[alphabet.length() - 1]) return false; \n  return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's the C++ (11) solution with symbol table storing counts, it successfully validates concatenated words also:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int getCode(char ch) { \n  switch(ch) { \n  case 'h': return(0); \n  case 'i': return(1); \n  case 'r': return(2); \n  case 'e': return(3); \n  default: return(-1); \n  } \n} \n \nint isValidWord(char str[], int n) { \n  int pre = 0; \n  int cur; \n  int i; \n  for(i = 0; i < n; i++) { \n    cur = getCode(str[i]); \n    if(cur == -1) { \n      return -1; \n    } \n    if (pre != 3 && cur < pre) { \n      return -1; \n    } \n    pre = cur; \n  } \n  if(pre == 3) { \n    return(1); \n  } else { \n    return(-1); \n  } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The definition of valid word are: 1. A given word is a valid word if it is of the form h^n i^n r^n e^n where n >=1. (eg: hhiirree) 2. Valid words has concatenation property i.e. if w1 and w2 are valid words w1w2 is also a valid word. Since definition 1 says \"h^n i^n r^n e^n where n >=1\" each character has to appear in the word and the counts of each character have to be the same. No assumption is made about the order of the characters! Let's use some examples: hire: valid ire: not valid ihre: valid hhiirree: valid eeiirrhh: valid  All the function needs to do is count each occurrence of the alphabet characters. An equal count means pass.  Here is my code. Note I am not using 3rd party Java StringUtils lib. - all standard Java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static boolean wordBrute(String word, int index) { \n  if(index>=word.length()) \n   return true; \n  int[] hist = new int[4]; \n  int i; \n  outerLoop: \n  for(i=index;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We know that there are four letters in the language and a correct word would have equal numbers of each character(as per question I am assuming) Then we can just do following:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A solution based on 4-state DFA. Python code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"just keep a count of the first char and compare to the others on the way through, reset the letters index when finish one check"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"How about a recursive dynamic programming approach?  For a word to conform to a language, all sub-words must also conform to the language.  You can cut down on calls by calling isValidWord on substring from 1 - s.length()-1, but you dictionary won't fill as fast."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Use state machine will resolve this easily and quickly. For the parameter N, it will be got when switch from 'h' to 'i'."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Here is the approach 1. First reduce the string to non-repetitive characters like fors hhiirreee -> hire or hhiirreehhii->hirehi 2. Now in final reduced String check if its repettion of \"hire\". E.g. hir or hirehire wil be valid whereas hirehi is NOT"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"private static final int STATE_INITIAL = 0; \n private static final int STATE_H = 1; \n private static final int STATE_I = 2; \n private static final int STATE_R = 3; \n private static final int STATE_E = 4; \n  \n public static boolean isWordValid(char[] word) { \n   \n  int state = STATE_INITIAL; \n   \n  for (int i = 0; i < word.length; i++) { \n   char letter = word[i]; \n    \n   switch (state) { \n   case STATE_INITIAL: \n     if(letter == 'H') state = STATE_H; \n    break; \n     \n   case STATE_H: \n    if(letter == 'H') state = STATE_H; \n    else if(letter == 'I') state = STATE_I; \n   break; \n    \n   case STATE_I: \n    if(letter == 'I') state = STATE_I; \n    else if(letter == 'R') state = STATE_R; \n   break; \n    \n   case STATE_R: \n    if(letter == 'R') state = STATE_R; \n    else if(letter == 'E') state = STATE_E; \n   break; \n    \n   case STATE_E: \n    if(letter == 'E') state = STATE_E; \n    else if(letter == 'H') state = STATE_H; \n   break; \n \n   default: \n    return false; \n   } \n    \n  } \n   \n  if(state == STATE_E || state== STATE_INITIAL) return true; \n   \n  else return false; \n   \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"private static final int STATE_INITIAL = 0; \n private static final int STATE_H = 1; \n private static final int STATE_I = 2; \n private static final int STATE_R = 3; \n private static final int STATE_E = 4; \n  \n public static boolean isWordValid(char[] word) { \n   \n  int state = STATE_INITIAL; \n   \n  for (int i = 0; i < word.length; i++) { \n   char letter = word[i]; \n    \n   switch (state) { \n   case STATE_INITIAL: \n     if(letter == 'H') state = STATE_H; \n    break; \n     \n   case STATE_H: \n    if(letter == 'H') state = STATE_H; \n    else if(letter == 'I') state = STATE_I; \n   break; \n    \n   case STATE_I: \n    if(letter == 'I') state = STATE_I; \n    else if(letter == 'R') state = STATE_R; \n   break; \n    \n   case STATE_R: \n    if(letter == 'R') state = STATE_R; \n    else if(letter == 'E') state = STATE_E; \n   break; \n    \n   case STATE_E: \n    if(letter == 'E') state = STATE_E; \n    else if(letter == 'H') state = STATE_H; \n   break; \n \n   default: \n    return false; \n   } \n    \n  } \n   \n  if(state == STATE_E || state== STATE_INITIAL) return true; \n   \n  else return false; \n   \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Small and simple (if regexp were allowed)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-6","title":"Seems like a simple regular expression.  /(h+i+r+e)+/ should match it.  For more explanation you can explain the state machine behind the regex."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5493302631596032","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"20","title":"How many times ??£þHello World??? is printed by following program? int main() {   if(fork() && fork())  {    fork()?  }   if(fork() || fork())  {    fork()?  }   printf(??£þHello world???)?  return 0? }  a. 16 b. 20 c. 24 d. 64","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"// 1 process  if(fork() && fork())  // creates 2 more { fork()?  //very first process will get here and create 1 more } //4 processes reach here  === assume 1 process reached here though === if(fork() || fork())  //creates 3 more (even first child will try second fork) { fork()?  // 2 processes reach here (original plus 1st child that tried 2nd fork above) }  // Thus above sequence will create 5 more processes  4 x 5 = 20 ?????"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"24  You have to take into account two things:  - fork() returned value: If you take into account that fork() returns the pid of the child to the parent and 0 to the child.  - The order of evaluation of operands:   + In case of AND (&&), after evaluation of left operand, right operand will be evaluated only if left operand evaluates to non-zero.   + In case of OR (||), after evaluation of left operand, right operand will be evaluated only if left operand evaluates to zero."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"For me answer is coming out to be \"20\". Number of processes spawned by original process (P) is actually number of times hello world is printed.    Let each \"fork\" be labeled by its position in the program (first fork - 1, second fork - 2),   Let each process be labeled by sequence of forks that gave birth to that process (original invokation labeled P0).  fork returns pid of a child in a parent and 0 in a child process. Also remember \"short circuiting\" in evaluation of condition (if first value is false in AND condition then condition is false, if its true in OR condition then condition is true, no need to evaluate second value in condition).  Here is how forking will work -  P0 (parent of all, invocation by user)  P1, P2, P3, P4, P6 (no P5 because condition will be true after fork#4 returns)  P14, P16,P24,P26, P34, P36, P45, P46  P145, P146, P245, P246, P345, P346  That's it. Counting it , 20 is answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"64 :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can somebody explain semantics of fork? How does it fork current thread?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I compile and run it. the result is 20"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"- First part: parent(FF), child(TF), child(TT), child (this effectively multiplies next part by 4) - Second part: parent(FF), child(TF), child, child(FT), child -> 5 processes  4*5 = 20"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"did anyone try executing? comes out to be 19 on a Linux box running Ubuntu. I don't know how so you may try justifying that."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Definitely not a Google question , this totally depends on the state of the scheduler i dont think they are this stupid"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"consider first if block,  parent->child1 [ if(fork() ] . | . v parent->child2 [ if(fork() && fork()) ] . | . v parent->child3 [ { fork(); } ]  so at this point, there are 4 processes: 3 children + 1 parent  consider next if block for one process,  parent->child1 [ if(fork() ] . | . . . . . . | . | . . . . . . v . | . . . . . child1->child2 [ if(fork() || fork()) ] . | . . . . . . | . | . . . . . . v . | . . . . . child1->child3 [ { fork(); } ] . | . v parent->child4 [ { fork(); } ]  so here you'll get 5 processes: 4 children + 1 parent  hence total processes 4x5=20, hence 20 prints!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Stop posting homework questions. Fork off."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5772030439849984","download_status":"DOWNLOAD_DONE","votes":"-5","answersCount":"19","title":"What is the in order successor of 6 in the given BST? (Ah! This is not an assignment. I am a working professional).           4     2         6  1    3  5          4.5  5.5  2 is left child of 4 and 6 is right child of 4. 1 is left child of 2 and 3 is right child of 3. 5 is left child of 6. 4.5 is left child of 5 and 5.5 is right child of 5.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"There is no in-order successor for the node with value 6."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"there is no inorder successor"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@algos interpretation of the problem is very smart. However, if this question is concern with the actual structure of the given BST, then we can use something like the code below:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"inorder travesal always results in sorted values and there is no vlaue grt than 6 . means no successer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"No in order successor to 6, and here is my solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The logic that I would put into this question would be sth like this:  if(root) {  InOrderSuccessor(r->left)  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why don't we just do in order traversal of the tree and store it into an array, then we just simply find the next item after the node we are interested. If null then means it doesn't have an in order successor. time O(n), space O(n). I guess the only penalty here is the extra memory space used."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the is the Inorder sequence: 1,2,3,4,4.5,5,5.5,6"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In order successor in a BST will be the smallest number greater than the given number. Which would be the left most node in its right subtree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"as per the sequence the possible in-order successor could be 7. if you need to find the in-order successor with the existing data then return -1 as that doesn't exist  ---------------4 -------2--------------6  ----1----3-------5-------7 --------------4.5--5.5    4 is average of 2&6 2 is average of 1&3 5 is average of 4.5&5.5 6 is average of 5&7"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5771816765227008","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"Suppose the sub-requests can be queued at each server, and the servers are running all the time. Discuss feasible on-line algorithms that can achieve sub-optimal solutions with N ~ 10000.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Here interviewer is expecting you to ask different questions 1) Is those request are entirely different? --> If yes, then you just need to do load balancing, Use weighted round robin  2) If those N request are any one of 'M' request where M << N --> Then take advantage of cache contents. Use Locality Aware Request distribution   3) If you want to take care of faulty machines as well  --> Use Consistent hashing   So there is no definite answer, Interviewer is expecting questions from you in this case."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Its the k-server problem. A feasible sub-optimal online algorithm is to assign the closest server to the job."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6314497157365760","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"9","title":"Find if 2 lists of rectangle are exactly equal. How would you sort the lists?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Imagine a rectangle represented as a ordered pair of 2 points. One on the upper left and the other on the lower right. Define a weak ordering comparator function first on the point (check if p1.x < p2.x and then p1.y < p2.y), then on the rectangle overall.  Now you can sort the two lists and check if they are the same.  Complexity O(n log n).   (Based on the assumption from the second part of your question, that is there is some well defined ordering on the rectangles : That is rectangles that start on a smaller x coordinate is \"smaller\")"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Code you requested:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can you please explain a little bit more clear? how many rectangles for each list? and if all the rectangle in list a have a same rectangle in list b, is this meaning equal?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"maybe we can apply radix sort? Sort both list by second point, then by first and compare them."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"there are n rectangles in one list and m in the other. No idea how to proceed with this. Any suggestions with code?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"assume rectangles are stored as (x,y) where x and y are two length and width of a rectangle.   A wild guess: calculate (x/y+y/x) as the unique attribute for each triangle. Then sort two list. We can compare them after the sort by simply traverse through two lists. time: O(nlogn) space: O(ListA.lenth + ListB.length)  My algo based on the assumption that (x/y+y/x) is always different for different rectangles and all x and y are integers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Could you please provide some code?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I guess we can assume that each rectangle is represented by two points (x1,y1) and (x2,y2). Then, we can calculate the area of each rectangle by (y1-y2)*(x2-x1), and then store them in a HashMap.  Please correct me if I am wrong"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think none of the above idea could work perfectly cover every possible edge condition. Let me clarify this a little bit: The key problem is how we could find some presentation of a rectangle in a unique way. In other words, if the two rectangles are equal, the presentation are the same. It is a bijection relation ship. Step1: A rectangle could be represented in multiple ways, a intuitive way is by its left upper point and its lower right point. Say A(1,1) B(2,2). These two points are enough to represent this rectangle. Step2: Serialize this information. Although there definitely mathmatical way to represent it, I came up a more intuitive ways which is directly insert them into a String. (e.g 1,1,2,2). Then we write comparator on this String."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6668639759499264","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"23","title":"How to find if a  number is power of 4 in O(loglogn).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"12","title":"Here."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"First check whether number is power of 2:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Similar to joe_kidd's solution, the pattern we want to find is that there is exactly only one '1' in an odd position of the bit representation of the number.  Instead of looping and checking all possible numbers, which gives O(log n) runtime, we can do binary selection to further optimize it to O(log log n).  The idea is to break the number into 2 parts, and do zero-check on both parts. go to the part that is non-zero, until you find a '1' and check if its position is on an odd index. Go to the original number, flip the 1 on the index you found, and do zero-check of the flipped number.  PS: 1 is also counted as power of 4, I assume"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Oh this one looked cool. Write a multibyte example on paper, then you get the idea to use a lookup table:  Note:  4^i  = (2^2)^i = 2^(2i)   Also, on paper you see that any integer is a power of 4 precisely when: 1) One of it's bytes is a power of 4 2) All other bytes are fully 0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We list the following sequence:  a_0 = 4 a_1 = 4^{a_1} a_2=4^{a_2} ... a_n=4^{a_{n-1}}  We can find the range the integer N belongs to. say a_i, and a_{i+1}.  Now, do the previous calculation, and multiply a_i each time.  We recursively do the previous steps. Until we n=a^k or n is between a^k and a^k+1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If it is important to do it in exactly O(lglgn):  Let's present x = y ^ k;   We can search this power k using binary search and use binary exponentiation for checking"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-4","title":"----------------------------------------------------------------------- The solution below fails for the case when the number is 12. Please take a look at Zoro post, as you get a correct solution there!!! -----------------------------------------------------------------------  Take a look at the bit represantation of number that is power of 4 you get:    1 =   000000001    4 =   000000100 16 =   000010000 64 =   001000000 256 = 100000000 ... So the sum off all above gives us a mask mask = (...)101010100 = 0x55554  So now we can write a function"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5678547255427072","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"97","title":"Q: Given a sorted 2D N x N array (where array[i][j] < array[i][j+1] and array[i][j] < array[i+1][j]), can you write a function that converts this to a sorted 1D array?  The obvious and naive way that I thought of was to convert the entire array into a 1D and do a mergesort on it, but there must be a better way than that.  I'm wondering what the better and more efficient way is.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"I think this is the most suitable scenario for K-Way merge. K represents the number of sorted one dimensional arrays.  Because it is NxN array, and it is row wise and column wise sorted.  Here number of sorted arrays =  number of row (or we can use columns)= N So here K will be equal to N.  Here is algorithm: Put the minimum element of each array (each row will be treated as a array) into a min-heap.  Then, repeatedly extract the minimum element from the heap, and replacing it by inserting the next element from the same array. The heap will never be bigger than N elements, so each operation (either extract-min or insert) takes O(lg N) time.  There are O(n) operations (one insert and one extract-min for each element), so the running time is   O(MlogN): where M = total number of elements = N^2.  Reference:   CLRS (2nd Ed) problem 6.5-8"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"github.com/vikhyath/c-runs/tree/master/n-way-merge  /* Program to do to n-way merge, where n is the SIZE of n*n array Emulating n-way merge from file through arrays, where each array row corresponds to a sorted file  Running time: O(n^2 logn), will be O(n^3) if min heap is not used  1) Get sizeof(min-heap) elements from n*n array 2) Put in min heap, remove the root element O(log n) 3) Fill min heap with a new element from array O(#elements) = O(n^2) 4) Do steps 2-3 till n*n array is exhausted 5) Now remove the root from min heap as many times as there are elements left in heap */"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I dont think we can do better than O(n^2). The total number of elements in the matrix is n*n and we have to visit them at least once."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It seemed Collection Algorithm could be applicable theoretically, but using this method became more complicated in my case as there were also many internal calculation to be reordered and mapped, so firstly implemented by a general merge method with the results in Java. I only skipped minimum numbers. Can anyone try this by more efficient way of collection algorithm?? Making strategy of partial set of collection was not so difficult, but implementation by a stupid computer was not efficient even though I used iterators of Java, there could be more complicated computation than simple general merge algorithm as I failed..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think Merge sort would be good way in the given condition of (array[i][j] < array[i][j+1] and array[i][j] < array[i+1][j]). Implemented in Java with the results."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"On a 3x3 array (n=9), this solution does 27 comparisons if I'm not missing something. Anyway, I believe this should be O(n x sqrt(n)) complexity."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"one way i could think of is having N iterators for N rows,  Take the min val from N iterators, add to your 1D array.. then Move the Iterator having Min val to Next.. if iterator.hasNext is None.. then remove that iterator from comparing List of N iterators"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In this code, I just use the merge part of merge sort to achieve a O(n) time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use dynamic programming.  Split N*N array to 4 2D array A1 A2 B1 B2  all the elements in A1 is smaller than the elements in B2 So we have concatenate A1 and B2 to C then we need to merge A2 and B1 to C the time complexity is N^2 * log4 N"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The faster solution is merge sort by all rows (or columns) at the same time. To do this, we need min-heap.  Here is how to *use* MinHeap for sorting. MinHeap does not implemented is this code. You can find the implamantation in google if you need."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This was my first idea, re-posted from the other thread:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"priority_queue,greater>heap; \n int id=(MAXLength*MAXLength)-1; \n int index=0; \n int *result=new int[id]; \n memset(result,-1,sizeof(int)*id); \n  \n for(i=MAXLength-1;i>=0;i--) \n { \n  for(j=MAXLength-1;j>=0;j--) \n   heap.push(a[i][j]); \n } \n while(!heap.empty()) \n { \n  result[index++]=heap.top(); \n//  cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The best algorithm here will use a Min heap as follows."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void Sorted_Matrix_2_Array(int a[MAXLength][MAXLength], vector &result) \n{ \n int i; \n priority_queue>>,greater>>>heap; \n  \n for(i=0;i>p=heap.top(); \n  heap.pop(); \n  result.push_back(p.first); \n  pairq=p.second; \n  q.second++; \n  if(q.second < MAXLength) \n   heap.push(make_pair(a[q.first][q.second],make_pair(q.first,q.second))); \n }  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You could flatten the 2D array down to a 1D array then bubble sort it since it is mostly sorted.  With a a mostly sorted list you have a best case O(n) operation.  If you want you can also use Insertion Sort since the 2D array means the array is mostly sorted.  That would also give you a best case of O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can view the lower diagonal part of the matrix as a max heap and the upper diagonal part as min heap. The parent-left-right relationship established by the adjacent cells, i.e. (i,j) is a parent, (i+1, j) is the left child and (i, j+1) the right child. So you just need to do a heapsort with the relation established and it seems you can't really beat O(n^2 log(n)) as otherwise heapsort would sort faster than O(n log(n)) an array of n elements. You'd then have to merge the results of 2 heaps."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"mergesort is NMlog(NM) my answer is  log(N)*NM on worst case  {{import java.util.Arrays; import java.util.Set; import java.util.TreeSet;  class Converter{ int[][] array;  class Point implements Comparable{     int r,c;     Point(int r, int c){         this.r = r;         this.c = c;     }     int get(){         return array[r][c];     }     int compaireTo(Point b){         return new Integer(get()).compareTo(b.get());     }  @Override  public int compareTo(Object b) {   // TODO Auto-generated method stub   Point pb = (Point) b;   return new Integer(get()).compareTo(pb.get());  } }  int[] convert2Dto1D(int[][] array){     this.array = array;     TreeSet candidates = new TreeSet();     int L = array.length * array[0].length;     int[] answer = new int[L];     candidates.add(new Point(1, 0));     candidates.add(new Point(0, 1));     answer[0] = array[0][0];     for(int i = 1; i < L; i++){         Point p = candidates.pollFirst();         if(p == null){          continue;         }         answer[i] = p.get();         if(p.r + 1 < array.length){             candidates.add(new Point(p.r + 1,  p.c));         }         if(p.c + 1 < array[0].length){             candidates.add(new Point(p.r,  p.c + 1));         }     }     return answer; }  public static void main(String[] argv){     int[][] array = {{0, 1, 5}, {2, 4, 6}, {3, 7, 8}};     Converter c = new Converter();     System.out.println(Arrays.toString(c.convert2Dto1D(array))); }  } }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Time complexity for the following algorithm is N^2*lg(PriorityQueue.size). It is similar to the general k-way merge. But it only puts an item into the priority queue if there are no items adjacent to it from left or up. Since PriorityQueue.size is less than or equal to N,  this algorithm is faster than the general k-way merge."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You dont actually need a heap - can do in O(N^2). Idea is very similar to k-way merge on rows, but uses additional property that cols are sorted as well.  First merge row 0, col 0 Then move to [1][1], merge row 1, col1 Then move to [2][2], merge row 2, col2 O(N^2). Pseudo code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi guys,  Here's my take on the exercise in Scala. It seems to me it has O(M * N * lg N) complexity. Although I'm having a hard time justifying it in the lg N part. Maybe you can give me a hand!   At any given point in the algorithm, the number of elements in the priority queue is <= N. The number of comparisons we do between elements is at most lg N. Will there ever be repeated comparisons to make the lg N actually be lg N^2?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"one way i could think of is having N iterators for N rows,  Take the min val from N iterators, add to your 1D array.. then Move the Iterator having Min val to Next.. if iterator.hasNext is None.. then remove that iterator from comparing List of N iterators"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I got the solution in O(n). Do verify and reply"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I got the solution in O(n). Do verify and reply"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"So it seems no better solution than simply converting to 2D and then sorting it? Since all are N^2*lg(N) ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"So it seems no better solution than simply converting to 2D and then sorting it? Since all are N^2*lg(N) ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"What about the following recursive algorithm? It looks a bit complex and it's readability could be improved though :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"import java.util.HashMap; import java.util.Map; import java.util.Map.Entry;   public class MatrixToOneDim {  class Indices {   int i;   int j;   public Indices(int i, int j) {    // TODO Auto-generated constructor stub    this.i = i;    this.j = j;   }   @Override   public boolean equals(Object arg0) {    // TODO Auto-generated method stub    if(! (arg0 instanceof Indices)) {     return false;    }    Indices point = (Indices)arg0;    return this.i == point.i && this.j == point.j;   }   @Override   public int hashCode() {    // TODO Auto-generated method stub    return Integer.parseInt(\"\" + this.i + this.j + \"\");   }  }  int output[];  int count;  int arr[][];  int n;  public MatrixToOneDim (int arr[][], int n) {   this.arr = arr;   this.n = n;   this.count = 0;   this.output = new int[n*n];  }    public void convert() {   output[count++] = arr[0][0];   Map threePoints = new HashMap();   threePoints.put(new Indices(1, 0), true);   threePoints.put(new Indices(0, 1), true);   this.convertRecur(threePoints);  }    public void convertRecur(Map threePoints) {   if(threePoints.size() == 0) {    return;   }   Indices ind = findMin(threePoints);   threePoints.remove(ind);   output[count++] = arr[ind.i][ind.j];   boolean firstPresent = threePoints.containsKey(new Indices(ind.i+1, ind.j));   boolean secondPresent =  threePoints.containsKey(new Indices(ind.i, ind.j+1));     if(ind.i+1 < n && ind.j+1 < n) {    if(! firstPresent && ! secondPresent && threePoints.size() < n - 1) {     threePoints.put(new Indices(ind.i+1, ind.j), true);     threePoints.put(new Indices(ind.i, ind.j+1), true);    } else if(! firstPresent && ! secondPresent) {     threePoints.put(arr[ind.i+1][ind.j] < arr[ind.i][ind.j+1] ? new Indices(ind.i+1, ind.j) : new Indices(ind.i, ind.j+1), true);    } else {     if(firstPresent)      threePoints.put(new Indices(ind.i, ind.j+1), true);     else {      threePoints.put(new Indices(ind.i+1, ind.j), true);     }    }   } else if(ind.i+1 < n && !firstPresent) {    threePoints.put(new Indices(ind.i+1, ind.j), true);   } else if(ind.j+1 < n && !secondPresent) {    threePoints.put(new Indices(ind.i, ind.j+1), true);   }     convertRecur(threePoints);  }    private Indices findMin(Map threePoints) {   int min = Integer.MAX_VALUE;   Indices indMin = null;   for(Entry entry : threePoints.entrySet()) {    Indices ind = entry.getKey();    if(min > arr[ind.i][ind.j]) {     min = arr[ind.i][ind.j];     indMin = ind;    }   }   return indMin;  }  public static void main(String[] args) {   int arr[][] = {{2, 39, 65, 101, 125},     {12, 42, 74, 110, 142},     {26, 59, 88, 122, 154},     {40, 72, 95, 133, 161},     {46, 81, 107, 145, 173}}; //{{1, 3, 6, 10, 15}, {2, 5, 9, 14, 19}, {4, 8, 13, 18, 22}, {7, 12, 17, 21, 24}, {11, 16, 20, 23, 25}};   MatrixToOneDim mat = new MatrixToOneDim(arr, 5);   mat.convert();   for (int i = 0; i < mat.output.length; i++) {    System.err.print(mat.output[i] + \" \");   }     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I was just thinking of an approach which is O(n) just consider an array like"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"The updates on the right show this activity:  ender said Hi Urik, yes, I have rephrased some sentences to make ... ender up-voted EOF's comment: Since the matrix has ... ender up-voted URIK LAGNES's comment: 1) O(N ..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"We can use tree map for the same, since tree map use BST for sorting the elements and on the top of that red black tree balancing act. Hence it will be done maximum in O(logN), please find the code below."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"I got the solution in O(n). Do verify and let me know"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"// use min_heap ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5389078581215232","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"Given two strings a and b, find whether any anagram of string a is a sub-string of string b. For eg:  if a = xyz and b = afdgzyxksldfm then the program should return true.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We check whether there's a substring of b, which has same size and same characters with a."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// 1. get all anagram strings of a // 2. for each string in the anagram list, check if it is a substring of b  bool AnagramIsSubString(string a, string b) {     string[] anagrams = GetAllAnagram(a);     bool found = false;          foreach (string anagram in anagrams)     {         if (b.IndexOf(anagram) != -1)         {             found = true;             break;         }     }     return found; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Will this one work...  Search for the occurrence of any character of string a in string b. Let this character be x.  If found, generate all anagrams of string a starting with x and check whether the same pattern is found in string b.  If found return true, else continue finding the next character"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Initialize an array of 26 slots each with the number of times every character appears on string a and then create a copy for such array.  For each character in string b, check if the count on the previously copied array is zero, if so reset the copied array to its original status. Otherwise, decrement the counter and check if all items in the array are now zero, if so, you've found a valid sub-string.  After the for-loop has ended, is safely to assume that no sub-string exists in b.  Time complexity: O(|b|) Space complexity: O(1)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5837582990573568","download_status":"DOWNLOAD_DONE","votes":"-3","answersCount":"16","title":"given a board with black (1) and white (0), black are all connected. find the min rectangle that contains all black.  example: 0 0 0 0 0 0 1 1 1 0 0 1 1 0 0 0 1 0 0 0 0 0 0 0 0  the min rectangle contains all black (1) is the rectangle from (1,1) - (3, 3)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"hi Obiwana/GZPenny"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"How many google interviews are you having the last few weeks? WOAH."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Scan through the array and store the (min_i, min_j) and (max_i, max_j) where a[i][j] == 1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int min_i = w; \nint min_j = h; \nint max_i = 0; \nint max_j = 0;  \n \nfor ( int i = 0; i < min_i; ++i ) \n{ \n    int j = 0; \n    while ( j < min_j && a[i][j] == 0 ) \n    { \n        j++; \n    } \n    min_j = j; \n \n    int j2 = w; \n    while ( j2 > max_j && a[i][j2 - 1] == 0 ) \n    { \n        j2--; \n    } \n    max_j = j2; \n} \n \nmax_i--; \nmax_j--;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int min_i = w; int min_j = h; int max_i = 0; int max_j = 0;   for ( int i = 0; i < h; ++i ) {     int j = 0;     while ( j < min_j && a[i][j] == 0 )     {         j++;     }     min_j = j;      int j2 = w;     while ( j2 > max_j && a[i][j2 - 1] == 0 )     {         j2--;     }     max_j = j2;      if ( j < min_j)     {           min_i = min(i, min_i);           max_i = max(i+1, max_i);     } }  max_i--; max_j--;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int min_i = w;  \n  int min_j = h;  \n  int max_i = 0;  \n  int max_j = 0;  \n \n  for ( int i = 0; i < h; ++i )  \n  {  \n    int j = 0;  \n    while ( j < min_j && a[i][j] == 0 )  \n    {  \n      j++;  \n    }  \n    min_j = j;  \n \n    int j2 = w;  \n    while ( j2 > max_j && a[i][j2 - 1] == 0 )  \n    {  \n      j2--;  \n    }  \n    max_j = j2;  \n \n    if ( j < min_j)  \n    {  \n      min_i = min(i, min_i);  \n      max_i = max(i+1, max_i);  \n    }  \n  }  \n \n  max_i--;  \n  max_j--;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is this question correct Min rectangle? If you go for min rectangle then it should be of 1x1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I guess the problem is to find out the max rectangle. It can be done with Dynamic Programming. 1) Create an array with size of the given array i.e. Sol[m][n] which is an array of tuple(left, right) and let input array by A[m][n] 2) Outer loop (i) from left to right and inner loop (j) from top to bottom 3) if A[j,i] = 0 then Sol[j,i] = (0,0) else Sol[j,i] = (Sol[j,i-1].right+1, Sol[j-1,i].left + 1) The max rectangle will be where the product of the tuple is max. Here is how the solution array looks like"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the idea is use DP to find the height, left, right for each element.  if(matrix[i][j] == '0'){  height[i][j] = 0; left[i][j] = 0; right[i][j] = 0; //because it's an obstacle  } else{  height[i][j] = 1 ---  if matrix[i-1][j] == '0';  height[i][j] = matrix[i-1][j] + 1 --- otherwise   left[i][j] = max(left[i-1][j], the index of the first obstacle on the element's left);         right[i][j] = min(right[i-1][j], the index of the first obstacle on the element's right) }  then we just go through the elements and find the max area, which is height*(right-left).   idea from: hi.baidu.com/mzry1992/item/030f9740e0475ef7dc0f6cba"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5644198027984896","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"20","title":"Given an array of Integers, and a range (low, high), find all continuous subsequences in the array which have sum in the range. Is there a solution better than O(n^2)?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Find all continuous sequences? Better than O(n^2) is not possible. Why do you ask? Was the problem different? Perhaps a count instead of a list?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There are O(n^2) continue subsequences in an array.  So finding them all is at minimum n^2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Does the array contain also negative numbers?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void printAllSeqSumInRange(int *arr, int size, int low, int high) \n{ \n std::queue q1; \n int item; \n printf(\"\\nAll Continuous Subsequence in the array coming in Range %d--%d are:\", low, high); \n for(int i=0; i< size; i++) \n { \n  if (sumInRange(q1, arr[i], low, high)) \n   q1.push(arr[i]); \n  else \n  { \n   printf(\"\\nRange is:\");; \n   printQueue(q1); \n   while(! q1.empty()) \n   { \n    q1.pop(); \n    if(sumInRange(q1, arr[i], low, high)) \n    { \n     q1.push(arr[i]); \n     break; \n    } \n    else \n     continue; \n   } \n  } \n } \n printf(\"\\nRange is:\");; \n printQueue(q1); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"OBIWANA! Did the google interviewer ask you for a certain time complexity???????????"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@All : I am a bit confused with the question you have mentioned   \" find all continuous subsequences in the array which have sum in the range \"   For a array : 4, 9,12,16,5,2,1,3,11  for this array : min, max  is 1,16  so the output what i think is : \" l the continuous subsequences whose sum in range\"  are : {4,9}, {12},{16},{5,2,1,3} ,{11}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"is it a sorted array?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"easy job. use integration of the arrays from a[0] to a[i] ->b[i] e.g. b[0] = a0 b[1] = a0 + a1 ...  the sum from a[i] to a[j] is b[j] - b[i]  search sum in range from 0 to n record i = min position, j = max position that fits the sum range  note i and j only increase,  then search should be done in O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"easy job. use integration of the arrays from a[0] to a[i] ->b[i] e.g. b[0] = a0 b[1] = a0 + a1 ...  the sum from a[i] to a[j] is b[j] - b[i]  search sum in range from 0 to n record i = min position, j = max position that fits the sum range  note i and j only increase,  then search should be done in O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If you need to print every result, then No.  This is because in worst case, all number pairs needs to be printed. To print all subsquence, you need O(n^2).  However, if you just want to print a (from, to_rang), then it's possible in O(n)  e.g. from = a[0] to_range = (3,5) which means a[3]...a[5] are all fit."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a solution, with print format like i -> (from, to) indicating i to from, i to from + 1, i to ... to are all possible squences. This runs in O(n) time. If you need to print all sequence individually, then it can't be done in less than O(n^2), suppose in worst case, all kinds of sequences are within the defined range, you need to print that number of times."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If we have to find all the subsequences then a soluction cannot be less than O(n^2). However if we only have to find out how many such subsequences are there then there is an O(nlogn) solultion for it."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5171150330003456","download_status":"DOWNLOAD_DONE","votes":"-2","answersCount":"3","title":"Given k integers i_0, i_1, i_2, i_3,...i_k, find all possible expressions which uses + - * / and () to generate a result equals to target X. () has the highest priority.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Ok. Now you are just posting random shit."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Obiwana, hi friend."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I decided for convenience to collect all possible expressions with the post-fix notations. This has solved out the problem of parenthesis and the problem to execute the expressions. An expression is represented here as a queue of operations.  Funny puzzle ;-)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5841660122497024","download_status":"DOWNLOAD_DONE","votes":"-3","answersCount":"22","title":"Given a dictionary of words, and a set of characters, judge if all the characters can form the words from the dictionary, without any characters left. For example, given the dictionary {hello, world, is, my, first, program}, if the characters set is \"iiifrssst\", you should return 'true' because you can form {is, is, first} from the set; if the character set is \"eiifrsst\", you should return 'false' because you cannot use all the characters from the set.  P.S. there may be tens of thousands of words in the dictionary, and the chars set length could be up to hundreds, so I really need some efficient algorithm.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Express each word in a[26], with a[i] = number of (c - 'a') in that word. The input string is also processed in the above way.  Now search:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think we can compare it with subset sum , in subset sum array and a key value is given,  now in this problem, let us consider array as dictionary,and each word represents the count of each letter present in the word,  and the given set of characters will be the key we have to find,  we can do t through backtracking(similar to subset sum)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Approach: Count the number of each character in the character set and store in a char array. Look for the start of every dictionary word in char array. If not present ignore the dictionary word. If present traverse the through the char array and subtracting the count for every character in the dictionary word in the char array.   If end of dictionary word is reached then switch to the next dictionary word, if not then traverse the dictionary word from the last not-found character and increment the character in the char array for every character in the dictionary word."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What is the question? Someone explain it more clearly please?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First process the dictionary according to the length of the words and convert it into an array of list such that array[1] contains words of length 1 , array[2] contains words of length 2 and so on.Store the length of the longest word is a variable say max_length. Going by the example value of max_length will be 7.  Now get the length of the character set. Let's say the character set is {iiifrssst} , it's length is 9. It's more than max_lenght so we go to array[7] , which is program , we start by first character which is 'p' which is not present in the character set so we discard it , next we go to array[6]  , nothing is there so we go to array[5] , and start with 'hello' again 'h' is not present in character set so we discard it , next we go to 'world' , discard it , next we go to 'first' , this fits so remove the characters constituting 'first' from the given character set {iiifrssst} , now we are left with {iiss} whose lenght is 4. So we go to array[4] , nothing is there , we go to array[3] , nothing there , we go to array[2] ,and 'is' is  a match. We remove the 'i' and 's' characters from character set which is now reduced to {is} . Again following the same procedure makes the character set empty. Thus we return true."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this is np-hard since subset sum can be easily reduced to this problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sort the string and remove duplicate \"iiifrssst\"  becomes \"ifrst\".   For each word in dictionary       Sort it and remove duplicate and compare with \"ifrst\" for a match  Cost is N.W.Log(W) + K.Log(K) where N is total number of words in dictionary and W is average length of word and K is length of pattern string."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is the semi-naive first solution that just sorts the chars set and each word before processing. This give a complexity of dic_size * set_size."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a better solution in case of huge dictionaries and character set. Uses counters on arrays of MAX_CHAR size (256).  bool is_dictionary_valid( const vector& dictionary, const string& charset ) {  const int NUM_CHARS = CHAR_MAX + 1;    int charset_counters[ NUM_CHARS ];  for ( int& val: charset_counters )  {   val = 0; // Resets all counters.  }  for ( char ch: charset )  {   charset_counters[ch]++;  }   bool charset_matches[ NUM_CHARS ];  for ( bool& val: charset_matches )  {   val = false; // Resets all match flags.  }   // For each word into the dictionary:  for ( const string& word : dictionary )  {   // Checks is the word is made only of available characters:   for ( char ch: word )   {    if ( charset_counters[ch] == 0 )    {     return false;    }     charset_matches[ch] = true;    charset_counters[ch]--;   }    for ( char ch: word )   {    charset_counters[ch]++; // Restores the counters.   }  }    // Tests if there was one character of the charset that have never been used inside  // the dictionary:  for ( int  i = 0; i < NUM_CHARS; ++i )  {   if ( charset_counters[i] > 0 && !charset_matches[i] )   {    return false;   }  }   return true; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a better solution in case of huge dictionaries and character set.  Uses counters on arrays of MAX_CHAR size (256)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"form trie out of words in the dictionary and do backtracking using characters in the given set"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"dynamic programming approach : transform all words in dictionary and chars in the set to dictionaries of the form dict . at each stage, consider each word against char dict (subtract count of intersecting chars in the char dict); if char dict reduces to all zeroes, return true. return false when total count in chars dict is below count in all word dicts"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I think we can compare it with subset sum , in subset sum array and a key value is given,  now in this problem, let us consider array as dictionary,and each word represents the count of each letter present in the word,  and the given set of characters will be the key we have to find,  we can do t through backtracking(similar to subset sum)."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4557716425015296","download_status":"DOWNLOAD_DONE","votes":"-2","answersCount":"36","title":"Many sticks with length, every time combine two, the cost is the sum of two sticks' length. Finally, it will become a stick, what's the minimum cost?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Each time, you combine two sticks of min length, you have (N-2) + 1 (the new stick) = N-1 left in system.  So now you re-calculate and choose 2 min sticks and combine those and continue.  Implementation:  Use a min-heap, remove min and next min = combine, insert the new length into the heap.         worst case Per operation runtime:  2*log (N) (remove 2 mins) + log (N) (insert new value)  Operation repeated N times = 3N*log(N) = O(N log(N))  However, if you notice, the height of min-heap goes on decreasing in each step and a more tighter analysis would yield a log(N!) worst case complexity (which ofcourse is O(N*log(N))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"EDITED: there is flaw in my post! The order of sticks matters!  Re-formulate the problem:  Given n sticks of length L_1, L_2, ..., L_n, with total length of L. Only combination of two sticks into one is allowed each time. Every combination costs the sum of the two sticks.  Calculate the minimum cost to combine all n sticks into a stick of length L.  This can be solved by recursive/DP as following.  Let C(u,v) be the minimum cost to join sticks from number u to number v. The recursive formula will be:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I don't get it? The answer is always sum of overall stick It's independent of choices leading to the final sum. It's not even a minimization problem.  for loop in any order over the sticks, and return the accumulated sum."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"People, I got this from glassdoor.  It is not from an interview I did!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the problem can be better explained with an example as many people are thinking that the total cost will be sum of all the lengths. Suppose there are 3 sticks of length 1, 2, 4  You can do the combination in this way,  Step 1: 1+2 (cost=3) Now we have two sticks of length 3 and 4 Step 2: 3+4(cost=7) Now we have one stick of length 7 Total cost 7+3=10  But if you do it in this way, Step 1: 4+2 (cost=6) Now we have two sticks of length 6 and 1 Step 2: 6+1 (cost=7) Now we have one stick of length 7 Total cost 6+7=13   So we can see that if we add the smaller ones first, we will minimize the cost. We can solve it with a min heap. We will add all the lengths in the min heap. We will pop two from the min heap and add them and put them back in the heap. We will continue this process till there is no more stick."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sort the array and then calculate the cost adding element starting from the lowest length."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You have an array of stick lengths, sLen = {1, 4, 6, 10, 11 }. If you remember your math, Addition is Commutative and Associative, i.e.  ((1 + 4) + (6 + 10) + 11) == ((1 + 4) + (6 + (10 + 11)). The minimum cost is the same no matter how you do it. Unless you multiply two lengths that make up one piece and add the cost of each piece. Only in the latter case the answer will be different."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Recursively pick the two sticks of minimum length, merge it (e.g. sum value) and add it back to the collection.  The reason why you should always pick the minimum 2 length is:  1, suppose you have two sticks, a1 and a2 the cost is a1 + a2  2, suppose you have three sticks, a1 < a2 < a3 the answer is you pick a1, a2 first, the cost is 2*(a1 + a2) + a3 why if you choose a3 first? the cost would be higher than above by: 2 * (a3 - a2) - (a3 - a2) = a3 - a2, which is a positive value.  So you should always pick the minimum 2 sticks.  1, Sort the array 2, pick the first two 3, insert the sum of first two to the sorted array (log n)  repeat that steps until done total cost is nlogn"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the key is: 1. sort the sticks in ascent  order, L1 <= L2 <= L3 <=...Ln 2. each time when combined 2 sticks, then put it back to the pool, and sort it again as 1) 3. we can see if the each time combination is smallest, the summary of all costs number is smallest."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Solve it with a greedy algorithm similar to algorithm for Huffman tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Suppose there are n(>0) sticks of length {L1, L2, ... , Ln}, where L1<=L2<=...<=Ln, I think the answer is: cost =  (1) 0, if n=1; (2) L1+L2, if n=2; (3) L1 + 2 * (L2 + L3 +...+Ln-1) + Ln, if n>2; Prove: Each time we combine 2 sticks to 1, there remains n-1 sticks, until there is only 1 stick. So we need to combine n-1 times. To minimize each combine cost, we should choose the shortest 2 sticks all the time. So, the 1st combine cost is L1+L2, left n-1 sticks of lenght {L2, L3, ... , Ln}; the 2nd combine cost is L2+L3, left {L3, L4, ..., Ln}; the 3rd combine cost is L3+L4, left {L4, L5, ..., Ln}; ... the total cost is L1+2*(L2 + L3 +...+Ln-1)+Ln."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"If you take the long stick and start to devide it to parts and pay every time the stick length,  the best way to do it, it to devide to two equal parts every time.  Do reverse of it and i think you would get the best solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Dupe: 14485666"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"I think,  finally for it to become a stick we have to combine all of them, hence there is no minimum/maximum, the cost will be the sum of all the elements(length of sticks)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Suppose L1,L2,...Ln are length of the sticks with L1 <= L2 <= L3 <= ... <=Ln. No matter how you form the final stick, each stick is used twice except for the outer ones, which are used only once. Hence, any combination which puts the largest two sticks at the left & right ends will be an optimal one.  Minimal cost = 2*[ L1 + L2 + ... + L(n-2)] + L(n-1) + Ln  An arrangement having this cost: Ln,L1,L2,L3,...L(n-1)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5675246111686656","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"20","title":"Consider N coins aligned in a row. Each coin is showing either heads or tails. The adjacency of these coins is the number of adjacent pairs of coins showing the same face.  You are given an implementation of a function:  function solution(A);  that, given a non-empty zero-indexed array A consisting of N integers representing the coins, returns the maximum possible adjacency that can be obtained by reversing exactly one coin (that is, one of the coins must be reversed). Consecutive elements of array A represent consecutive coins in the row. Array A contains only 0s and/or 1s:  0 represents a coin with heads facing up; 1 represents a coin with tails facing up. For example, given array A consisting of six numbers, such that:    A[0] = 1     A[1] = 1     A[2] = 0   A[3] = 1     A[4] = 0     A[5] = 0 the function returns 4. The initial adjacency is 2, as there are two pairs of adjacent coins showing the same face, namely (0, 1) and (4, 5). After reversing the coin represented by A[2] the adjacency equals 4, as there are four pairs of adjacent coins showing the same face, namely (0, 1), (1, 2), (2, 3) and (4, 5), and it is not possible to obtain a higher adjacency.  Unfortunately, there is a bug in the implementation. Find it and correct it. You should modify at most two lines of code.  Assume that:  N is an integer within the range [1..100,000]; each element of array A is an integer within the range [0..1]. Complexity:  expected worst-case time complexity is O(N); expected worst-case space complexity is O(1), beyond input storage (not counting the storage required for input arguments). Elements of input arrays can be modified.  function solution(A) {     var n = A.length;     var result = 0;     for (var i = 0; i < n - 1; i++) {         if (A[i] == A[i + 1])             result = result + 1;     }     var r = 0;     for (var i = 0; i < n; i++) {         var count = 0;         if (i > 0) {             if (A[i - 1] != A[i])                 count = count + 1;             else                 count = count - 1;         }         if (i < n - 1) {             if (A[i + 1] != A[i])                 count = count + 1;             else                 count = count - 1;         }         r = Math.max(r, count);     }     return result + r; }","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"The issue is: \"one of the coins must be reversed\". Hence, sometimes we will get worse result if we flip any coin compared to the situation when no coins are flipped. Thus, one should add negative original expectation for \"r\" if \"n\" is larger than 2."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"The original problem is quite straightforward if what needed is the number of *adjacent pairs* of coins. The solution below is to get the *consecutive* number of coins showing the same face after reversing."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int count_current_adj(arr[], int arr.length(), int one_OR_zero) \n{ \n int counter=0; \n int it; \n for(it=1;it0) \n { \n  return 2; \n }else if(oneInc>0){ \n  return 1; \n }else{ \n  return 0; \n } \n} \n \nint count_updated_adj(arr[], int arr.length()) \n{ \n int one_c=0, zero_c=0; \n one_c = count_current_adj(arr, arr.lenght(), 1); \n zero_c = count_current_adj(arr, arr.lenght(), 0); \n if(one_c >= zero_c+2) \n { \n  one_c =  one_c + checkUpdate(arr, arr.lenght(), 1); \n  return one_c; \n }else if(zero_c >= one_c+2){ \n  zero_c =  zero_c + checkUpdate(arr, arr.lenght(), 0); \n  return zero_c; \n else{ \n  one_c =  one_c + checkUpdate(arr, arr.lenght(), 1);  \n  zero_c =  zero_c + checkUpdate(arr, arr.lenght(), 0); \n  return one_c>=zero_c?one_c:zero_c; \n }  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For discussion I'll take the problem of counting only maximum number of consecutive ones after changing a zero to one Whenever you see a zero count the number of ones to the left of zero(LeftCount) and count the number of ones to the right of zero(RightCount), the answer will be the maximum of 1+LeftCount+RightCount.  We can find LeftCount in O(1) time by just increment LeftCount,  if current element is one and LeftCount = LeftCount+1, when current element is zero LeftCount = 0. RightCount can also be found in O(1) time by following logic: If current element is zero, find the no of consecutive ones to the right with a linear sweep. If the current element is one RightCount = RightCount - 1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I prefer Look on the change of the var r value. when r changes from 0 to another value the i-th element on that moment has to be changed.  so:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Add the following after result is calculated If(result == n-1) return result-1;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if (N == 1) \n   return 0;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"All the above answers are not satisfying the conditions, READ the QUESTION CAREFULLY,  Condition  :  At most two lines of code can be changed, NOT asked to write your own version."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"var r =-2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"basically replace the line var r = 0 with the line var r = -2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int countSeqOnes(vector &v, int n) { \n if (v.empty() || n < 0 || n>= v.size()) { \n  return 0; \n } \n int c = 0; \n for (int i=n; i &v, int n) { \n if (v.empty() || n < 0 || n>= v.size()) { \n  return 0; \n } \n int c = 0; \n for (int i=n; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"u can add one line result=result+1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Initialize r as the first count; add this :"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5732809947742208","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"33","title":"Given a dictionary, and a list of letters ( or consider as a string), find the longest word that only uses letters from the string. [I didn't meet this question, what's the best solution?]","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Algo:  1. Put all chars of string in a hashmap 2. traverse word by word from dictionary and for each word check all letter presents in hastable. 3. keep track of longest string traversed."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"If the dictionary is given as a set of Strings, then we can just iterate over the dictionary and check whether that particular word can be formed with the given letters. If it is longer than the currently longest such word, then we store the word. At the end we can then return the longest such word.  Runtime is O(n + m*l) where n is the length of the whole dictionary (as if it were one string), m is the number of words in the dictionary and l is the length of the letters string. Space complexity is O(w) where w is the length of the longest word in the dictionary."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Post study questions in the forum, not here."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please let me know if this approach is possible:  Let's say the dictionary is a hashmap. Permute all the combinations of words possible using the characters in the string. Sort by length and start checking if the word exists in the dictionary."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming #letters in the given string is n  Approach 1: 1. Find and put all sustrings of string in array A. Run time : O(n^2)  2. Sort this array. Run time O(n^2 * log(n^2) 3. Starting from longest entry in this array, check if present in dictionary. A match will give the ans. Run time O(n^2) assuming lookup time is O(1)  so total run time = O(n^2 * log n^2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"dude, sort the string ,and do backtracking"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I assume the dictionary is given with trie data structure.  Backtrack/BFS/DFS would give you the best result. You go from one state to another state if there is a letter that can be appended to the current string."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we take 2-stage method: 1) break the input long string into substring by removing all letters not in the given letters. O(n) time complexity 2) now the task become: for each one of substrings, what's the longest valid word inside it. this step should o(n^2) time complexity, any better way?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Initially we need to preprocess the dictionary. For every string in dictionary we need to sort it and store it as a key and value as original string in Hash Table.  Sort the given characters. And generate power set of given characters(We get 2 power n strings). Check each string in power set is available in hash table. if it available note it down string and it's length.  Finally return longest string.  Time complexity  2 power n"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You should have asked for dictionary API.  1) If it is a HashMap, then there is not much to do except for checking all pairs. 2) If it is a Binary Search Tree, and it supports ceil and floor, OR, it is a more sophisticated structure that can tell you given a string \"abc\" if there are any words having \"abc\" as prefix,  then you could do a backtracking and search through the words which exactly contain your letters.  Rough idea:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have a linear algorithm.  Let's say we have a set of letter, S, and a list of dictionary, dict.   step 1                          define a type freq, which is a array of 26 letters; counting the frequency of each letters in S and store them into S_freq; counting the frequency of each letter of each word in dict(i.e. store in dicct_Freq);   2                          compare function: bool compare(freq a, freq b); return true if b is in a; this algorithm is constant with worse case 26 comparisons.     3                           compare every freq in dict_freq with S_freq and stop when compare(S_freq, dict_freq[i]) returns true; then max = dict[i].size();  store the index in max_index;  4                           go over the rest of list and compare when dict.size() > max; track the index of max;  5                          return dict[max_index]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be done in O(nlogn) where n is the length of the search string ( or the characters to use)  The key is to store the dictionary that makes it amenable to do O(1) lookups. Dictionary should be stores as a HashMap where key is sorted unique set of characters and the value is a linked list of all words in the dictionary that uses all those characters. The linked list must always be in descending order of word lengths.  Lookup:  Just sort input characters, lookup in the HashMap and return the 1st word in the linkedlist  - O( time to sort chars )  Inserting a new word in the dictionary: Sort chars of the word, remove redundant chars, lookup the linked list in the HashMap and insert the new word at the right spot in the LinkedList (so that we preserve the descending world length criteria) - O (time to sort chars) + O(number of words in that bucket)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5735304249999360","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"8","title":"Insert a element in a sorted circular linked list","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Algorithm: Allocate memory for the newly inserted node and put data in the newly allocated node. Let the pointer to the new node be new_node. After memory allocation, following are the three cases that need to be handled.  1) Linked List is empty:       a)  since new_node is the only node in CLL, make a self loop.                 new_node->next = new_node;       b) change the head pointer to point to new node.           *head_ref = new_node; 2) New node is to be inserted just before the head node:       (a) Find out the last node using a loop.          while(current->next != *head_ref)             current = current->next;   (b) Change the next of last node.           current->next = new_node;   (c) Change next of new node to point to head.          new_node->next = *head_ref;   (d) change the head pointer to point to new node.          *head_ref = new_node; 3) New node is to be  inserted somewhere after the head:     (a) Locate the node after which new node is to be inserted.          while ( current->next!= *head_ref &&               current->next->data < new_node->data)          {   current = current->next;   }    (b) Make next of new_node as next of the located pointer          new_node->next = current->next;    (c) Change the next of the located pointer          current->next = new_node;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void insert(Node node, int x) { \n  if (node == null) { \n    node = new Node(x); \n    node.next = node; \n    return; \n  } \n  Node nextP = node; // To move forward \n  Node prevP = NULL; // To hold pointer on previous node \n  do { \n    prev = nextP; \n    nextP = nextP.next; \n    if (x <= nextP.data && x >= prevP->data){ \n  //If value resides between two values of nextP & prevP, add here \n  break; \n } \n    if ((prevP.data > nextP.data) && (x < nextP.data || x > prevP.data)) { \n //If node x is largest (larger than all elements in the list)  \n //or smallest (smaller than all elements in the list) \n  break; \n } \n  } while (nextP != node); \n \n  Node newNode = new Node(x); \n  newNode.next = nextP; \n  prevP.next = newNode; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \nstruct node { \n                int data; \n                struct node *next; \n                }; \nstruct node *start; \n \nint insert(int element) \n{ \n        struct node *temp,*prev,*new; \n \n        new = malloc(sizeof(struct node)); \n \n        new->data = element; \n        new->next = NULL; \n        if(!start) \n        { \n                start = new; \n                new->next = start; \n                return 0; \n        } \n \n        if(start->data > new->data) \n        { \n                new->next = start; \n                temp = start; \n                while(temp->next != start) \n                { \n                        temp = temp->next; \n                } \n                temp->next = new; \n                start = new; \n                return 0; \n        } \n        temp = start; \n        prev = start; \n        do{ \n                prev = temp; \n                temp = temp->next; \n                }while((temp->next!=start)&&(temp->data < new->data)); \n \n        if(temp!= start && temp->data > new->data) \n        { \n                new->next = temp; \n                prev->next = new; \n                return 0; \n        } \n        else if(temp->next == start) \n        { \n                temp->next = new; \n                new->next = start; \n                return 0; \n        } \n} \n \nvoid print() \n{ \n        struct node *temp; \n \n        printf(\"%d \",start->data); \n        temp = start->next; \n        while(temp != start) \n        { \n                printf(\"%d \",temp->data); \n                temp = temp->next; \n        } \n        printf(\"\\n\"); \n        return; \n} \n \nmain() \n{ \n        insert(200); \n        insert(100); \n        insert(250); \n        insert(3250); \n        insert(2250); \n        print(); \n} \n \noutput : 100 200 250 2250 3250"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.*; \n \nclass CircularLinkedList \n{ \n     \n    public Node root = null; \n    public class Node \n    { \n Node next = null; \n int item; \n public Node(int data) \n { \n     item = data; \n } \n    } \n \n    public Node sortedInsert(Node root, int data) \n    { \n  \n Node current = root; \n Node newItem = new Node(data); \n // Case1: LinkedList is none \n if( current == null) { current = newItem; current.next = current; root = current;} // self loop, since its the only item \n  \n // Case2: inserting before the head node \n if( current.item > data ){ newItem.next = current; current.next = newItem; root = newItem;} \n \n // Case 3: inbetween  \n if(newItem.item > current.item) \n     { \n  while(current !=null){ \n      if(current.next != null && current.next.item > newItem.item) \n   { \n       Node temp = current.next; \n       current.next = newItem; \n       current.next.next = temp; \n       break; \n   } \n       if(newItem.item > current.item && current.next.item == root.item) // is the last element \n   { \n       current.next = newItem; \n       current.next.next = root; \n       break; \n       \n   } \n      current = current.next; \n  } \n     } \n return root; \n    } \n \n    public void display(Node n) \n    { \n Node current = n; \n while(current != null)  \n     { \n \n  System.out.println(current.item); \n  current = current.next; \n  if( current.item == n.item) break; \n   \n     } \n    } \n \n    public static void main(String[] args) \n    { \n CircularLinkedList cr = new CircularLinkedList(); \n System.out.println(\"After inserting 2\"); \n cr.root = cr.sortedInsert(cr.root, 2); \n cr.display(cr.root); \n System.out.println(\"After inserting 1\"); \n cr.root = cr.sortedInsert(cr.root, 1); \n cr.display(cr.root); \n System.out.println(\"After inserting 4\"); \n cr.root = cr.sortedInsert(cr.root, 4); \n cr.display(cr.root); \n System.out.println(\"After inserting 3\"); \n cr.root = cr.sortedInsert(cr.root, 3); \n cr.display(cr.root); \n System.out.println(\"After inserting 5\"); \n cr.root = cr.sortedInsert(cr.root, 5); \n cr.display(cr.root); \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think we cannot get anything better than O(n), because in case of inserting the largest element, we will have to traverse through all the list anyway. Correct me if I am wrong, but the answer here is trivial. This would require O(1) memory and O(n) operations.  The special case: all the items are the same, we have to insert an item larger than that. This leads us to another interesting task: finding out the length of the structure. This is still O(1) memory and O(n) operations."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void insertNode(Node* &head, Node *node) { \n  // empty list \n  if (!head) { \n    head = node; \n    node->next = node; \n    return; \n  } \n   \n  // insert before head \n  if (node->value <= head->value) { \n    Node *tail = head; \n    while (tail->next != head) tail = tail->next; \n    tail->next = node; \n    node->next = head; \n    head = node; \n  } else { \n    Node* it = head; \n    while (it->next != head) { \n      if (node->value > it->next->value) { \n        it = it->next; \n        continue; \n      } \n      // insert in the middle. \n      node->next = it->next; \n      it->next = node; \n      return; \n    } \n    // insert tail. \n    node->next = head; \n    it->next = node; \n  } \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5205167846719488","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"15","title":"For a given node in binary search tree find a next largest number in search tree.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This problem is similar to finding the next inorder successor of the given node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"The question is basically find the in order successor of the given node.  If the node has a right child, then the successor will be the leftmost element of the right child. If it does not, then we go up through the parents until we \"do a right turn\". That is, we stop when the current node is the left child of the parent. That's when we have encountered the in order successor.  Here is the code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It depends. 1) Are you given a key or a node(address/reference)? 2) Are there parent pointers? 3) Do you mind O(n) or do you insist on O(lg n)?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class Node{  \n int data; \n Node left; \n Node right; \n} \npublic class BST_FindNextLrgstMin { \n public static void main(String arg[]) \n { \n  BST_FindNextLrgstMin bstfm=new BST_FindNextLrgstMin (); \n  Node root=bstfm.CreateBST(); \n   \n  //givenn values in bst are 4,5,6,7,8,9,10  \n  //then first largest is 10,  \n  //second largest is 9 and so on \n  Node nxtlrgst=bstfm.FindNextLargest(root, 15, root); \n  System.out.println(\"\\nNext Largest of 15:\"+nxtlrgst.data); \n } \n  \n Node FindNextLargest(Node root, int val,Node current){ \n  //first find node with given value \n  Node nxtlrgst=null; \n  if (root==null){ \n   nxtlrgst=current; \n  } \n   \n  if (root.dataval){ \n   nxtlrgst=FindNextLargest(root.left,val,current); \n  }else if(root.data==val){ \n   if(root.right==null) \n   { \n    nxtlrgst=current; \n   }else{ \n    BST_FindNextLrgstMin temp=new BST_FindNextLrgstMin (); \n    nxtlrgst=temp.FindMax(root.left); \n   } \n  } \n  return nxtlrgst; \n } \n  \n Node FindMax(Node root) \n { \n  //In BST rightmost Node will max ,  \n  //hence just traverse right path from root to get Max number \n  Node max; \n  try{ \n   if (root.right!=null){ \n    max=FindMax(root.right); \n   }else{ \n    System.out.println(\"\\nFrom If Block...\"); \n    return root; \n   } \n  }catch(NullPointerException e){ \n   System.out.println(\"\\nFrom Catch Block...\"); \n   return root; \n  } \n  return max; \n } \n Node CreateBST() \n { \n  Node root=new Node(); \n  root.data=11; \n  Node n1=new Node();  n1.data=7;  root.left=n1; \n  Node n2=new Node();  n2.data=15;  root.right=n2; \n  \n  Node n3=new Node();  n3.data=5;  n1.left=n3; \n  Node n4=new Node();  n4.data=9;  n1.right=n4; \n  Node n5=new Node();  n5.data=13;  n2.left=n5; \n  Node n6=new Node();  n6.data=17;  n2.right=n6; \n   \n  Node n7=new Node();  n7.data=4;  n3.left=n7; \n  Node n8=new Node();  n8.data=6;   n3.right=n8; \n  Node n9=new Node();     n9.data=8;   n4.left=n9; \n  Node n10=new Node(); n10.data=10;  n4.right=n10;  \n  Node n11=new Node(); n11.data=12;  n5.left=n11; \n  Node n12=new Node(); n12.data=14;  n5.right=n12; \n  Node n13=new Node(); n13.data=16;  n6.left=n13; \n  Node n14=new Node(); n14.data=18;  n6.right=n14; \n   \n  return (root); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Even though this question has been beaten to death, here is my two cents on it : We need to find in-order successor to the a node in BST In addition to std BST, we'll need a pointer to the parent  Algorithm:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For anyone interested I'm putting a small visual presentation at my blog: ptechpedia (dot) blogspot (dot) com"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if(ptr->right==NULL) \n              cout<<\"No next largest elemnt\"; \n       else \n       { \n             node *p=ptr->right; \n             while(p->left!=NULL) \n                  p=p->left; \n       } \n       return p->key;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool found = false; \nNode* findNext(Node* root, Node* node) \n{ \n \n  if (root->left) \n  { \n    Node* n = findNext(root->left, node); \n    if (n != NULL) return n; \n  } \n \n  if (found) \n  { \n    std::cout << \"found: \" << root->data << \"\\n\"; \n    return root; \n  } \n  else if (root == node) \n  { \n    found = true; \n  } \n \n  if (root->right) \n  { \n    Node* n = findNext(root->right, node); \n    if (n != NULL) return n; \n  } \n \n  return NULL; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I found this very easy"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4857362737266688","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"22","title":"Write a function return an integer that satisfies the following conditions: 1) positive integer 2) no repeated digits, eg., 123 (valid), 122 (invalid) 3) incremental digit sequence, eg., 1234 (valid) 1243(invalid) 4) the returned integer MUST be the smallest one that greater than the input. eg., input=987, return=1023  function signature could be like this: String nextInteger(String input)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Can you explain why your example \"987\"->\"1023\" violate the rule 3?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is an example with a unit test included. Basically, if the input is n, we check if (n+1) satisfies the three conditions.  If it does, we return it. If it does not we increment it again and check. We keep incrementing till the result meets all requirements.  And, I assume the OP's example is incorrect. 987's output should be 1234 according to the requirements."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static int getInteger(int input)  {   int rem1;   int rem2;   boolean found = false;   HashSet set;      if(input < 0)   {    return 0;   }   else if(input/10 == 0)   {    return input+1;   }   else   {    while(!found)    {     found = true;     int temp = input;     set = new HashSet();     rem1 = -1;     rem2 = -1;     System.out.println(\"INPUT: \"+temp);     while(temp != 0)     {      rem1 = temp % 10;      temp = temp / 10;            if(!set.add(rem1) || (rem2 != -1 && rem2 < rem1))      {       found = false;       break;      }      rem2 = rem1;     }          if(found)     {      break;     }     else     {      input++;      }    }        return input;   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The following code works fine, tested:  private static int getInteger(int input)  {   int rem1;   int rem2;   boolean found = false;   HashSet set;      if(input < 0)   {    return 0;   }   else if(input/10 == 0)   {    return input+1;   }   else   {    while(!found)    {     found = true;     int temp = input;     set = new HashSet();     rem1 = -1;     rem2 = -1;     System.out.println(\"INPUT: \"+temp);     while(temp != 0)     {      rem1 = temp % 10;      temp = temp / 10;            if(!set.add(rem1) || (rem2 != -1 && rem2 < rem1))      {       found = false;       break;      }      rem2 = rem1;     }          if(found)     {      break;     }     else     {      input++;      }    }        return input;   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming input is a positive integer, following is code in C++:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Any input with > 10 characters will definitely have a repeated character - why? (pigeon hole principle)  Any input with 10 characters also will not have a valid solution - why? because for 10 characters we need to include 0-9, in increasing order which means 0 has to be at the beginning which makes it a 9 digit integer. Any input with 9 digits can have 2 different solutions: if input is < 123456789 then answer is 123456789 else no solution similarly we can solve other cases - should be trivial."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class IncrementString { \n \n public static String nextString(String num) { \n  char[] numArr = num.toCharArray(); \n \n  boolean canBeIncrementedWithinTheSameNumberOfDigit = true; \n \n  for (int i = 0; i < numArr.length; i++) { \n \n   if ((10 - (numArr[i] - '0')) < (numArr.length - 1 - i)) { \n    canBeIncrementedWithinTheSameNumberOfDigit = false; \n    break; \n   } \n \n  } \n \n  if (canBeIncrementedWithinTheSameNumberOfDigit) { \n \n   for (int i = 0; i < numArr.length; i++) { \n    numArr[i] = ++numArr[i]; \n   } \n   return new String(numArr); \n \n  } else { \n   char[] newNumArr = new char[numArr.length + 1]; \n   for (int i = 0; i <= numArr.length; i++) { \n    newNumArr[i] = (char) ('0' + (i + 1)); \n   } \n \n   return new String(newNumArr); \n  } \n \n } \n \n public static void main(String[] args) { \n  System.out.println(nextString(\"978\")); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Unless I'm missing something, I also agree that 1023 seems to violate the rule requiring an incremental sequence of numbers.  If that's true, then it seems to me that the entire set of valid numbers would be (in their string representation) sub-strings of either of the following:  \"9876543210\" \"123456789\"  That means there are only 100 valid numbers: sum(i=1...9: i) + sum(j=1...10: j) = (9*9 + 9)/2 + (10*10 + 10)/2 = 45 + 55 = 100.  That means they can all easily fit into memory of any reasonable device today and calculating them all should be fast as well.  Store the calculated values in a map of seq_i -> seq_(i+1) and lookup will be trivial.  Brute force, I know, but it seems like a reasonable trade off for O(1) evaluation.  If something more general is required, it is still possible to generate the subset of possible numbers based off of the position in the string.  However, as I was trying that approach, it just seemed like there was way too many logic forks."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Best approach in my opinion is (assuming the number can't be more than 10^10):  Add the following numbers into a sorted list, prefixing a particular sequence, 1 12 123 ... 123456789  Then start with 2: 2 23 234 2345 ... 2345678901  so on  Finally, do a binary search on the sorted array and find the next biggest element."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \nbool nodup_digit(int x) \n{ \n  int a[10] = {0}; \n \n  while (x > 0) \n  { \n    int d = x % 10; \n    a[d] = a[d] + 1; \n    if (a[d] > 1) \n      return false; \n    x /= 10; \n  } \n \n  return true; \n} \n \nbool increment(int x) \n{ \n  int max = 9; \n \n  while (x > 0) \n  { \n    int d = x % 10; \n    if (d > max) \n      return false; \n \n    max = d; \n    x /= 10; \n  } \n \n  return true; \n} \n \nint next(int n) \n{ \n  if (n < 0) \n    return 1; \n \n  ++n; \n \n  while (!nodup_digit(n) || !increment(n)) \n  { \n    ++n; \n  } \n \n  return n; \n} \n \nint main(int argc, char* argv[]) \n{ \n  int x = atoi(argv[1]); \n  std::cout << next(x) << \"\\n\"; \n  return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"assuming the maximum we can get is '123456789', so it's invalid for input bigger than '123456788' then we plus the input by 1, so we can check our generated result by greater or equal function. first we generate the biggest valid number we could have for the length of input, e.g 899 as input, the biggest is 789 if it's smaller than input+1, simply return 1234, as we know it's the smallest valid result. if for input 688, the maximum 789 is bigger than it, so we scrimp it from the highest bit.  time complexity is (n^2) which n is the length of input string, space complexity is n."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Here is my solution: Running java code can be found at ideone.com/cTExme  I have taken the liberty of assuming that the example given by the author is wrong and for input 987, the next large value should be 1234.  The basic idea is as follows:   Step1:  First normalize the input number for 9. That is, If the input number has 9 in it then the next larger number is always going to spill into the next significant digit position.  If input has 9 in it, next number larger than current input not having 9 in it can be found using input + amount remaining to reach next significant digit change.  for example  for 192 --> we ned 8 to reach 200.  for 1922 --> we need 88 to reach 2000 etc.  The formula for this is 192+(10-92%10) So depending upon position of 9, 10 changes to 100 or 1000 etc.    Step2:  Now we have the number which does not have 9. So to satisfy requirement 1,2 and 3, get the first digit of that number say that digit is 3 and depending upon the size of the number   (for 20 size is 2, for 1111 size is 4), add next digits (4,5,6 etc) to this number forming next larger positive digit without repetition, incrementing digits and smallest one greater than input.    Edge case:  In Step2, if the first digit happens to be say 8 and the size of the input is 3, then while forming new integer, the value will reach 10. like first digit 8, next digit 9 and 3rd digit 10.  So 8910 wont be a valid 3 digit number. In that case, we have to get the number larger than currently generated number which wont have digits spilling over to 10 when formed a new number."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"/*assuming i/p of 987 should not return 1023 as digits in \n * 1023 aren't in incremental sequence \n */ \n \nint \nnum_check(char *num_strP) { \n  int *num_arr=(int*)malloc(strlen(num_strP)*sizeof(int)); \n  int i=0, _ret=1; \n  for(i=0; i=num_arr[i+1])  _ret =0;  \n  } \n \n  free(num_arr); \n  return _ret; \n} \n \nint \nnum_checker(int numP) { \n  int i=numP; \n  char num_str[12]={0}; \n  while(1) { \n    sprintf(num_str, \"%d\", ++i); \n    if(num_check(num_str)){ \n      break; \n    }    \n    memset(num_str, 0, 12); \n  } \n  return i; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4716965625069568","download_status":"DOWNLOAD_DONE","votes":"8","answersCount":"34","title":"Given a 2-D matrix represents the room, obstacle and guard like the following (0 is room, B->obstacle, G-> Guard): 0  0  0 B G  G B  0  0  calculate the steps from a room to nearest Guard and set the matrix, like this 2  1   1 B  G  G B  1   1 Write the algorithm, with optimal solution.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"Typed it in directly... so expect bugs (or plain incorrectness :P ) BFS initiated from all guard positions and +1 for reaching a naked position (a '0') and add it to queue to keep the BFS search going."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Below is my code, I did some test. -2 for block, -1 for gurad."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bfs..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Could there be anything possibly wrong with using BFS and putting G nodes into the priority queue?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's another approach, Find the coordinate of the G nodes. For each node, find the Manhattan distance between the Coordinates and the G nodes, assign the value as the smallest manhattan distance. This takes O(n^3) though. The BFS technique with all G nodes in the Priority queue should be the fastest (as someone else suggested)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include                                                                                                       \n \nint array[][3] = {{0,0,0},{-2,-1,-1},{-2,0,0}}; \n \ntemplate  \nT min(T a, T b)       \n{                     \n  if (a < b) return a; \n  return b;            \n}                      \n \nvoid print() \n{            \n  for (int i = 0; i < 3; ++i) \n  {                           \n    for (int j = 0; j < 3; ++j) \n    {                           \n      std::cout << array[i][j] << \",\"; \n    }                                  \n    std::cout << \"\\n\";                 \n  }                                    \n}                                      \n \nvoid markhere(int i, int j, int mark) \n{ \n  if (array[i][j] > 0) \n  { \n    array[i][j] = min(array[i][j], mark); \n  } \n  else if (array[i][j] == 0) \n  { \n    array[i][j] = mark; \n  } \n} \n \nvoid mark() \n{ \n  bool done = false; \n  int current =  -1; \n  int mark = 1; \n  while (!done) \n  { \n    done = true; \n    for (int i = 0; i < 3; ++i) \n    { \n      for (int j  = 0 ; j < 3; ++j) \n      { \n        if (array[i][j] == current) \n        { \n          if (j > 0) \n          { \n            done = false; \n            markhere(i, j - 1, mark); \n          } \n          if (j < 2) \n          { \n            done = false; \n            markhere(i, j + 1, mark); \n          } \n          if (i < 2) \n          { \n            done = false; \n            markhere(i + 1, j, mark); \n          } \n          if (i > 0) \n          { \n            done = false; \n            markhere(i - 1, j, mark); \n          } \n        } \n      } \n    } \n    current = mark; \n    mark++; \n  } \n} \n \nint main() \n{ \n  print(); \n  mark(); \n  print(); \n  return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"time o(n) space o(n), get all the guard nodes to a min-heap and expand them to adjacent nodes, keep adding them to the min-heap if reachable. assuming obstacle is -2, guard is -1 for easy processing."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Dijkstra's algorithm should be better. And it has O(n^2) complexity."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"What about find shortest path from all guards? Just put them into one queue initially."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public static int guards(String [][]a, int i, int j, int N, int [][]visited){ \n  int c; \n   \n  // Returns if you encounter a \"B\" or Index is out of bound \n  if (i < 0 || j < 0 || i >= N || j >= N || a[i][j] == \"B\") \n   return 0; \n \n  // If the code encounters a numeric value (minimum value) it returns (numeric value + 1). The numeric value is minimum value to reach \"G\" \n  // Using this principle you need not check the shortest distance to G for every index in the Array.  \n  // You can simply return if you encounter B, G, Numeric value. \n   \n  // Consider  2 1 B \n  //   1 G B \n  //   0 1 G \n  // Array[2][0] need not check for G, its neighbor Array[1][0] or Array[2][1] (depending on the recursive call) has the minimum value of 1. \n  // Thus Array[2][0] minimum value is 1 + min step for Array[1][0] = 2. \n  // This may or may not be Array[2][0] minimum value depending on the number of recursive calls left. \n   \n  if (isNumeric(a[i][j]) && Integer.parseInt(a[i][j]) > 0) \n   return 1+Integer.parseInt(a[i][j]); \n \n  if (a[i][j] == \"G\") \n   return 1; \n   \n  if (visited[i][j]==0){ \n   \n   visited[i][j]=1; \n  \n   // Consider the minimum value \n   if ((c=guards(a,i-1,j,N,visited))>0) \n    a[i][j]= (Integer.parseInt(a[i][j])>0?Math.min(c,Integer.parseInt(a[i][j])):c)+\"\"; \n  \n   if ((c = guards(a,i,j+1,N,visited))>0) \n    a[i][j]= (Integer.parseInt(a[i][j])>0?Math.min(c,Integer.parseInt(a[i][j])):c)+\"\"; \n  \n   if ((c = guards(a,i+1,j,N,visited))>0) \n    a[i][j]= (Integer.parseInt(a[i][j])>0?Math.min(c,Integer.parseInt(a[i][j])):c)+\"\"; \n  \n   if ((c = guards(a,i,j-1,N,visited))>0) \n    a[i][j]= (Integer.parseInt(a[i][j])>0?Math.min(c,Integer.parseInt(a[i][j])):c)+\"\"; \n    \n   visited[i][j]=0; \n    \n   // Consider that an index's neighbor has found a G.  \n   // Since the numeric value determined be the neighbor is the minimum, minimum value for index will be 1 + neighbor's numeric value.  \n   return 1+Integer.parseInt(a[i][j]); \n    \n  } \n   \n  return 0; \n \n } \n \n public static boolean isNumeric(String s){ \n \n  for(char c: s.toCharArray()){ \n   if(!Character.isDigit(c)) \n    return false; \n  } \n  return true; \n } \n \n public static void guard(String a[][]){ \n  int N=a.length; \n  int visited[][]=new int[N][N]; \n   \n  for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I have hard coded the dimension as 3.  -1 will represent block, -2 will represent guard."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5766198755065856","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"35","title":"You are given a string which has numbers and letters. Numbers occupy all odd positions and letters even positions. You need to transform this string such that all letters move to front of array, and all numbers at the end.  The relative order of the letters and numbers needs to be preserved  I need to do this in O(n) time and O(1) space.  eg: a1b2c3d4 -> abcd1234 , x3y4z6 -> xyz346  Please don't submit your answers if it is not fulfilling the time-space complexity requirements.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"This question is carefully described at geeksforgeeks org  Search for an-in-place-algorithm-for-string-transformation there.  Base64 encoded url: aHR0cDovL3d3dy5nZWVrc2ZvcmdlZWtzLm9yZy9hbi1pbi1wbGFjZS1hbGdvcml0aG0tZm9yLXN0cmluZy10cmFuc2Zvcm1hdGlvbi8="},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Who asked you this at Google?  We need to notify the hiring committee of this interviewer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Since the input to be segregated is a String like \"a5b6c7d8\" we can use String's substring method to hand pick numbers from the string and append them at the end of the string in a single for loop.    Time complexity: O(n)  space complexity: O(1)    Example:    i here denotes the index of the character in the string    i=1 -- input: a5b6c7d8 (Append 5 to the end of string) output: ab6c7d85  i=2 -- input: ab6c7d85 (Append 6 to the end of string) output: abc7d856  i=3 -- input: abc7d856 (Append 7 to the end of string) output: abcd8567  i=4 -- input: abcd8567 (Append 8 to the end of string) output: abcd5678"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Are the letters and numbers relatively ordered as in the examples you gave?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There is something called cycle leader iteration which can be used for this. The pre-requisite for this is that the size array should be in 3^k+1 format. If the input array is not of that length then the array need to be broken in multiple subarrays to get this format for all arrays. Once that is done cycle leader iteration can be applied on each array individually and then merge them to get final output."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \nusing namespace std; \n \nstring str=\"zzzzzzzzzzzzz999999999999999999\"; \n \nint main() \n{ \n    cout << str << endl; \n    int siz=str.size(); \n    int i, char_pos=-1, num_pos=-1; \n    long long int int_val=0; \n    long long int char_val=0; \n    for(i=siz-1;i>=0;i--) \n    { \n        //cout << int(str[i]) << endl; \n        if(str[i]>47&&str[i]<58) \n        { \n            if(num_pos==-1) \n            { \n                int_val=str[i]-48; \n                num_pos=i; \n            } \n            else \n                int_val=int_val*10+(str[i]-48); \n            //cout << num_pos << endl; \n        } \n        else \n        { \n            if(char_pos==-1) \n            { \n                char_val=str[i]-97; \n                char_pos=i; \n            } \n            else \n                char_val=char_val*26+(str[i]-97); \n        } \n        //cout << str << endl; \n    } \n    cout << int_val << endl; \n    cout << char_val << endl; \n    i=0; \n    while(char_val!=0) \n    { \n        str[i]=char_val%26+97; \n        char_val=char_val/26; \n        cout << str[i] << endl; \n        i++; \n    } \n    while(int_val!=0) \n    { \n        str[i]=int_val%10+48; \n        int_val=int_val/10; \n        cout << str[i] << endl; \n        i++; \n    } \n    cout << str << endl; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"dude,  in-place-algorithm-for-string-transformation, it is there in geeksforgeeks."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For example say array is:  a 2 3 b c 5 d e 4 6  Start traversing from left side of array (0th index) find the next sequence of numbers and sequence of char and exchange those in case numeric sequence is before char sequence  [Exchange the place of '2 3' to 'b c'] a b c 2 3 5 d e 4 6  apply same logic  [Exchange the place of '2 3' 5 to 'd e'] a b c d e 2 3 5 4 6"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution written in C++, both recursive and iterative versions. The recursive version also allows tail-call optimization by the compiler.  Output:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class NumAlpha implements Comparator { \n \n  @Override \n  public int compare(String o1, String o2) { \n    \n   if(o1.matches(\"\\\\d\") && o2.matches(\"[a-zA-Z]\")) { \n    System.out.println(\"o1\" + o1); \n    System.out.println(\"o1\" + o2); \n    return 1; \n   } else if (o2.matches(\"\\\\d\") && o1.matches(\"[a-zA-Z]\")) { \n    return -1; \n   } \n   else  \n    return o1.compareTo(o2); \n     \n   } \n   \n   \n } \nTest t = new Test(); \n  NumAlpha na = t.new NumAlpha(); \n  TreeSet set = new TreeSet(na); \n   \n  set.add(\"a\"); \n  set.add(\"1\"); \n  set.add(\"b\"); \n  set.add(\"2\"); \n  set.add(\"c\"); \n  set.add(\"3\"); \n  set.add(\"d\"); \n  set.add(\"4\"); \n  System.out.println(set.toString());"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I'm making use of the fact that two digits can be stored in a single character using 10*d1 + d2."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \nvoid trans(char* a, int size) \n{ \n  if (size <= 2) return; \n \n  for (int i = 1; i <= size - 3; i += 2) \n  { \n    // swap a[i] and a[i + 1] \n    a[i] ^= a[i + 1]; \n    a[i + 1] ^= a[i]; \n    a[i] ^= a[i + 1]; \n  } \n \n  trans(a + 1, size - 2); \n} \n \nint main(int argc, char* argv[]) \n{ \n  int length = strlen(argv[1]); \n \n  trans(argv[1], length); \n \n  std::cout << argv[1] << \"\\n\"; \n \n  return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static String inPlaceSeparation(String str) { \n  if (str == null || str.length() <= 2) { \n   return str; \n  } \n \n  char[] arr = str.toCharArray(); \n  BitSet bs = new BitSet(arr.length); \n  for (int head = 1; head < arr.length - 1; ++head) { \n   if (bs.get(head)) { \n    continue; \n   } \n   char hValue = arr[head]; \n   int to = head; \n   while (true) { \n    int from = to < arr.length / 2 ? to * 2 : 1 + 2 * (to - arr.length / 2); \n    if (from == head) { \n     arr[to] = hValue; \n     bs.set(to); \n     break; \n    } \n    arr[to] = arr[from]; \n    bs.set(to); \n    to = from; \n   } \n  } \n  return new String(arr); \n } \n \n public static void main(String[] args) { \n  String str = \"aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ\"; \n  System.out.println(str); \n  System.out.println(inPlaceSeparation(str)); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"A Simple In-Place Algorithm for In-Shu?e"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"char *hopFlipSttring(char *input) \n{ \n    int i, s1 = 0, s2 = 0; \n    char *result; \n     \n    result = malloc(strlen(input)+1); \n    s1 = 0; \n    s2 = (int)strlen(input)/2; \n     \n    for( i = 0; i < strlen(input); i += 2 ) { \n        result[s1++] = input[i]; \n        result[s2++] = input[i+1]; \n    } \n    result[i] = '\\n'; \n     \n    return result; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"import java.util.Scanner;   public class Test {     Scanner x=new Scanner(System.in);     String s;     public static void main(String[] args) {         Test t=new Test();         t.get();        }     private void get()     {         StringBuilder builder1 = new StringBuilder();         StringBuilder builder2 = new StringBuilder();         s=x.next();         String tempChar[]=s.split(\"[0-9]\");         String tempNum[]=s.split(\"[a-z]\");         int i=0,j=0;         while(i        {             if(i            {              builder1.append(tempChar[i++]);             }                          else if(j            {                 builder2.append(tempNum[j++]);             }                  }                  System.out.println(String.valueOf(builder1)+String.valueOf(builder2));     } }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4807591515389952","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"6","title":"What would happen if you have only one server for a web cache (a web browser cache whose key is url and value is the loaded content of the webpage) but huge numbers of clients? And how would you solve it? Assume the cache is implemented with a hashmap and a linkedlist.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Caches are present in server side as well. For example a DB cache that chaches frequent SQL query results. This will prevent frequently run queries from hitting the DB server very often. Example, if you have a dropbox for the list of states and if the list is maintained in DB you dont have to always fetch from the DB. THe webserver will fetch that only once and then caches at the server side."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Lot of clients and only one server implies that the data in the cache will be flushed out soon as you cannot store data of all the urls data in cache. So, cache will not help in reducing the response time"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Im thinking hashmap had so many hash collisions... collisions are implemented in linkedlist format"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"In my understanding, cache remains on the client side not on the server. Also what do you mean by \"cache is implemented with a hashmap and a linkedlist? does it mean each value is a linkedlist? can you please explain your question"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6004821970649088","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"Consider a scenario where you open a file with your favorite editor (emacs on Linux or Microsoft Word on Windows).  You notice that the application has a performance hit due to a recent fix made to the Editor application.  What will your testing Matrix look like that will convey the information that the performance of the application has degraded (or improved after bug fixes and re-design)?    In other words, the interviewer was saying that, if we had a graph showing values obtained from tests run over time for:  File I/O, hardware configuration, software configuration, graphics system, GPU, CPU etc.   then at the End Of the Day, looking at the reports, which parameters will instantly tell you that the performance has definitely increased?  (Also in other words he was asking the Matrix that will portray those parameters).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"File I/O Note the time and cpu utilization taken for Reading (load in memory and opening) and writing the file to the disk.  Every time data is written and saved in the file, the changes are sent from memory to disk and the file is reloaded in the memory and set in view/edit mode.  Note time and cpu utilization it takes to send the changes to the disk from the memory and time taken to reload the file into disk.  Note time and cpu utilization taken to search for a single non-duplicate word and duplicate words. Also note time taken to search for non-duplicate sentence and duplicate sentences  Note time and cpu utilization it takes to edit the file such as make changes to a single word and/or multiple duplicate words (such as search and replace). Perform same observation to changes made to sentences and/or duplicate sentences  Note the gpu utilization for changes in text versus graphics . Also note the time it takes to make these changes."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5661939564806144","download_status":"DOWNLOAD_DONE","votes":"6","answersCount":"31","title":"Give a N*N matrix, print it out diagonally. Follow up, if it is a M*N matrix, how to print it out. Example: 1 2 3 4 5 6 7 8 9 print: 1 2 4 3 5 7 6 8 9  This is the question in the phone interview. Please share more questions.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"let i be row number (0 to N-1), and j be col number (O to N-1)  diagonal 1 has i+j =0 diagonal 2 has i+j =1 ...   So define D = i+j  Loop with D from 0 to 2*(N-1)   Now if D = i+j then j=D-i So we have reduced the problem to two variables: D and i  (two loops)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public static void main(String args[]) throws Exception  \n { \n int[][] a = {{1,2,3},{4,5,6},{7,8,9}}; \n print(a,3,3); \n } \n  \n  \n static void print(int[][] a,int rowmax,int colmax){ \n  int row=0; \n  for(int i=0;i< colmax;i++) \n   printdiag(a,row,i,rowmax,colmax); \n  int col=colmax-1; \n  for(int i=1;i< rowmax;i++) \n   printdiag(a,i,col,rowmax,colmax); \n   \n } \n  \n static void printdiag(int[][] a,int row,int col,int rowmax,int colmax) \n { \n  System.out.println(); \n  while(row=0) \n  { \n   System.out.print(a[row][col]); \n   row++; \n   col--; \n  } \n  return; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public void printDiagonally(int[][] a) { \n int n = a.length; \n for (int k = 0; k < 2*n - 1; ++k) { \n  for (int i = k - n + 1; i <= Math.min(k, n - 1); ++i) { \n   System.out.print(a[i][k - i] + \" \"); \n  } \n  System.out.println(); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \nusing namespace std; \n \nconst int N = 4; \n \nint main() \n{ \n    int A[N][N]; \n    int n = 0; \n     \n    for (int i = 0; i < N; i++) { \n        for (int j = 0; j < N; j++) { \n            A[i][j] = n++; \n            cout << A[i][j] << \" \"; \n        } \n        cout << endl; \n    } \n     \n    for (int k = 0; k < 2 * N; k++) { \n        int i = k < N ? 0 : k - N + 1; \n        int j = k < N ? k : N - 1; \n         \n        while (i < N && j >= 0) \n            cout << A[i++][j--] << \" \"; \n        cout << endl; \n    } \n    return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We may print from right up to right left down, following is C++ code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class PrintMatrixDiagonally { \n \n public static void main(String[] args) { \n  int m=4, n=4; \n  int arr[][]={{1,2,3,4},{5,6,7,8},{9,3,6,2},{4,7,9,0}}; \n  int diagonals=n+m-1; \n  int i=0,j=0; \n  while(diagonals>0) \n  { \n   int k=i,l=j; \n   while(l>=0 && k"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Test{ \n \n public static void main(String[] args){ \n  int n = 2; \n  int m = 5; \n  int[][] matrix  = new int[n][m]; \n  fillMatrix(matrix,n,m); \n  printDiagonal(matrix,n,m); \n} \n  \n public static void fillMatrix(int[][] matrix,int n,int m){ \n  int i = 1; \n  for(int l = 0; l < n; l++){ \n   for(int k = 0; k < m; k++){ \n    matrix[l][k] = i++; \n   } \n  } \n } \n \n \n  \n public static void printDiagonal(int[][] matrix,int n,int m){ \n  StringBuilder sb = new StringBuilder(); \n  int dMax = n+m-1; \n  int d = 0; \n  for(d = 0; d < m; d++){ \n   for(int l = 0; l <= d && l < n; l++){ \n    sb.append(matrix[l][d-l]); \n    sb.append(\" \"); \n   } \n   sb.append(\"\\n\"); \n  } \n  //pos diagonal \n  while(d <= dMax){ \n   for(int l = d-m+1; l <= d && l < n ; l++){ \n    sb.append(matrix[l][d-l]); \n    sb.append(\" \"); \n   } \n   sb.append(\"\\n\"); \n   d++; \n  } \n  System.out.println(sb.toString()); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"function getDiagnols(array) {  \n  var result = []; \n  var num_rows = array.length; \n  var num_columns = array[0].length; \n   \n  for (var col_diagnol=0; col_diagnol < num_columns; col_diagnol+=1) \n  { \n    var diagnol =[]; \n    for( var row =0, col=col_diagnol; row < num_rows && col >=0 ;row+=1, col-=1) \n    { \n      diagnol.push(array[row][col]); \n    } \n    result.push(diagnol); \n  } \n   \n  for (var row_diagnol=1; row_diagnol < num_rows; row_diagnol+=1) \n  { \n    var diagnol =[]; \n    for( var row = row_diagnol,col = num_columns-1; row < num_rows && col >= 0; row+=1,col-=1) \n    { \n      diagnol.push(array[row][col]); \n    } \n    result.push(diagnol); \n  } \n  return result;      \n} \n    \nvar input = [[1,2,3],[4,5,6],[7,8,9]]; \nvar input2 = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]] \nvar input3 = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] \nvar input4 = [[1,2,3],[4,5,6],[7,8,9],[10,11,12]]; \ngetDiagnols(input4);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class DiagonalPrint { \n \n public static void printAll(int[][] arr) { \n  for (int x = 0; x < arr[0].length; ++x) { \n   printOne(arr, x, 0); \n  } \n  for (int y = 1; y < arr.length; ++y) { \n   printOne(arr, arr[0].length - 1, y); \n  } \n } \n \n public static void printOne(int[][] arr, int x, int y) { \n  while (x >= 0 && y < arr.length) { \n   System.out.print(arr[y++][x--] + \" \"); \n  } \n  System.out.println(); \n } \n \n public static void main(String[] args) { \n  int[][] arr = { { 1, 2, 4 }, { 3, 5, 7 }, { 6, 8, 9 } }; \n  printAll(arr); \n  System.out.println(); \n  int[][] arr1 = { { 1, 2, 4 }, { 3, 5, 7 }, { 6, 8, 10 }, { 9, 11, 12 } }; \n  printAll(arr1); \n  System.out.println(); \n  int[][] arr2 = { { 1, 2, 4, 7 }, { 3, 5, 8, 10 }, { 6, 9, 11, 12 } }; \n  printAll(arr2); \n  System.out.println(); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.io.*; \nimport java.util.*; \n \npublic class PrintDiagonalElements { \n    public static void main(String[] args) throws IOException { \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); \n        PrintWriter out = new PrintWriter(System.out); \n \n        int N = Integer.parseInt(br.readLine()); \n \n        int[][] mat = new int[N][N]; \n \n        StringTokenizer st = null; \n \n        for (int i = 0; i < N; ++i) { \n            st = new StringTokenizer(br.readLine()); \n             \n            for (int j = 0; j < N; ++j) { \n                mat[i][j] = Integer.parseInt(st.nextToken()); \n            } \n        } \n \n        for (int sum = 0; sum < N; ++sum) { \n            String prefix = \"\"; \n            for (int i = 0; i <= sum; ++i) { \n                int j = sum-i; \n                out.print(prefix); \n                out.print(mat[i][j]); \n                prefix = \" \"; \n            } \n            out.println(); \n        } \n \n        for (int sum = N; sum <= 2*N-2; ++sum) { \n            String prefix = \"\"; \n            for (int i = sum-N+1; i < N; ++i) { \n                int j = sum-i; \n                out.print(prefix); \n                out.print(mat[i][j]); \n                prefix = \" \"; \n            } \n            out.println(); \n        } \n \n        out.flush(); \n        out.close(); \n               \n        System.exit(0); \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def print_d(mat, n, m): \n  for d in range(n + m - 1): \n    for i in range(max(0, d - m + 1), min(n, d + 1)): \n      print mat[i][d - i], \n    print"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void printMatrix(int [][] a) \n    { \n        int m = a.length -1; \n        int n = a[0].length -1; \n     \n        for (int i = 0; i <= m; i++) \n        { \n            printDiagonal(a, i, 0, n); \n        } \n     \n        for (int j = 1; j <= n; j++) \n        { \n            printDiagonal(a, m, j, n); \n        } \n    } \n    public static void printDiagonal(int[][] a, int m, int n, int maxN) \n    { \n        int pm = m; \n        int pn = n; \n        while(!(pn > maxN)) \n        { \n            //System.out.print(pm + \".\" + pn + \" \"); \n            System.out.print(a[pm][pn] + \" \"); \n            if(pm == n && pn ==m) \n            { \n                break; \n            } \n            pm--; \n            pn++; \n        } \n        System.out.println(); \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include /* Give a N*N matrix, print it out diagonally.  Follow up, if it is a M*N matrix, how to print it out.  Example:  1 2 3  4 5 6  7 8 9  print:  1  2 4  3 5 7  6 8  9  */  using namespace std; int a[100][100];  void printdiagonal(int a[][100],int m,int n) {      int x=0;      while(x<=n+1)      {                   for(int i=0;i                  {                         for(int j=0;j                         {                                 if(i+j==x)                                 cout<                                               }                   }                       cout<<\"\\n\";                x++;                      }      }  int main() {      int m,n;      cout<<\"\\nEnter the number of rows:\";      cin>>m;                                    cout<<\"\\nEnter the number of columns:\";      cin>>n;      for(int i=0;i      {              for(int j=0;j               cin>>a[i][j];       }                printdiagonal(a,m,n);       getch();       return 0;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This print for both N * N and M * N"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here the solution for MxN"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void printDiag(int[][] A; int M; int N) \n{ \n int T = (M-1) + (N-1); \n for(int p = 0; p <= T; p++) \n { \n  int i = 0, j = p; \n \n  // we add this to check p>=N, if yes it will go out of bound for j \n  if (p >= N) \n  { \n   int x = p-N+1; \n   i = i + x; \n   j = j - x; \n  } \n \n  while ((i < N) && (j >= 0)) \n  { \n   system.out.print(A[i][j]); \n \n   i = i + 1; \n   j = j - 1; \n  } \n \n  system.out.println(); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be problem can be treated in different way. If the top-left element is considered as root of the tree , then this problem boils down to level order traversal of the tree.  Only one special handling is required  1. If it's the right most element in the considered tree or the top row in the current diagonal, just push its right and then bottom element. 2. For other elements in the current diagonal, just push the bottom element.  Do this until any element left in the queue."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//visual studio 2010"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void do_prt_diag() {      int a[][] = { {1,2,3}, {4,5,6}, {7,8,9} }; //  int a[][] = { {1,2,3,4,22}, {5,6,7,8,33}, {9,10,11,12,44} };      int j = 0;   int k = 0;   printDiagonally(a); } // start row then column // start at a[y][x], where y=0..n-1 and x=0...m-1 go down and left till out of bound. // start at a[y][x], where y=1..n-1 and x=m-1..0 go down and left till out of bound. private void printDiagonally(int[][] a) {   int n = a.length; // col   int m = a[0].length; // row   int x = 0;   int y = 0;      // do row   for (int i = 0; i   x=i;    while(x >= 0 && y <= n-1) {     System.out.print(a[y][x] + \" \");     x--;     y++;    }    y=0;  //reset column    System.out.println();   }   //do column   x=m-1;   for(int i=1; i   y=i;    while(x>=0 && y<=n-1) {     System.out.print(a[y][x] + \" \");     y++;     x--;    }    x=m-1; //rest row    System.out.println();   } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for a matrix of MxN, we will have a total of M+N-1 diagonals  at diagonal no. 0 - > we preint 0,0 at 1 -> 1,0 and 0,1 at 2 -> 2,0   1,1 and 0,2  See the pattern? for diagonal i, we print [ i-j ][ j ] for each j from 0 to i inclusive"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \nmain() \n{ \n        int a[4][2] = {{1,2},{5,6},{9,10},{13,14}}; \n        int sum = 0,i,j,m=4,n=2; \n \n        do{ \n                for(i = 0;i<=m-1;i++) \n                { \n                        for(j=0;j<=n-1;j++) \n                        { \n                                if(i+j == sum) \n                                { \n                                        printf(\"%d \",a[i][j]); \n                                } \n                        } \n                } \n                printf(\"\\n\"); \n                sum++; \n        }while(sum<=(m-1+n-1)); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I just took a generic nxm matrix. It should work for square matrices as well... You can pass the matrix as an argument too"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Heres solution in c#:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Outer loop runs for the diagonals.  D=0,i=0,j=0;while(D<2*n-1) {  if(D     i=0;  else      i++;  k=i;     p=j;  while(p>=0 && k {   cout << arr[k][p];          p--;   k++;  }  D++;  if(D     j++;  cout << endl;  } //Where p and k are used to print the numbers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.List; \n \npublic DiagonalMatrix(List> matrix) { \n  for(int i = 0; i < 2*matrix.size()-1; i++) { \n   printLine(matrix, i); \n  } \n } \n \n private void printLine(List> matrix, int i) { \n  if(i < matrix.size()) { \n   printDiagonal(matrix, i, 0); \n  } else { \n   printDiagonal(matrix, matrix.size()-1, i - matrix.size()+1); \n  } \n   \n } \n \n private void printDiagonal(List> matrix, int x, int y) { \n  while(x >= 0 && y < matrix.size()) { \n   System.out.print(matrix.get(y).get(x) + \" \"); \n   x--; \n   y++; \n  } \n  System.out.println(); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class printMatrixDiagonally {     public static void main(String[] args){         int row = 2 , col =3;         int[][] input = new int[row][col];         for(int i =0 ; i< row ; i++){             for(int j= 0 ; j                input[i][j] = i+j;             }         }         printStack(input);                  //Here is to print it out diagonally.         printStackDiag(input);     }          //this method is to print out the matrix.     public static void printStack(int[][] input){         int row = input.length, col = input[0].length;         for(int i =0 ;i             for(int j=0 ; j                System.out.print(\" \"+input[i][j]);             }             System.out.println();         }                }          public static void printStackDiag(int[][] input){         //. We need to print one line where their sum of i, j index is the same.         //total is the max of i, j sum.         int row = input.length , col = input[0].length, total = row+col -2 , sum = 0;                 while(sum>=0 && sum <= total){                                     for(int i = 0 ; i< row ; i++){                     int j= sum -i;                     if(j>=0 && j< col){                         System.out.print(\" \"+input[i][j]);                     }                 }                      sum++;             System.out.println();                                 }              } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"C# Code  using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks;  namespace Test {     class Program     {         static void Main(string[] args)         {             var n = 3;             var ip = new int[n,n];             ip[0, 0] = 1;             ip[1, 0] = 2;             ip[2, 0] = 3;             ip[1, 0] = 4;             ip[1, 1] = 5;             ip[1, 2] = 6;             ip[2, 0] = 7;             ip[2, 1] = 8;             ip[2, 2] = 9;             MyMethod(ip,n);             Console.ReadKey();         }          static IEnumerable MyMethod(int[,] ip, int n)         {             var output = new List();             for (var i = 0; i <= 2 * (n - 1); i++)             {                 var iTemp = i;                 for (var j = 0; j <= i; j++)                 {                     if (iTemp >= 0 && iTemp < n && j >= 0 && j < n)                     {                         Console.WriteLine(iTemp + \" \" + j);                     }                     iTemp = iTemp - 1;                 }                 Console.WriteLine(\"inner loop ends\");             }             return output;         }     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include   int main() {   int mat[5][5],i,j,k,m;   scanf(\"%d\",&m);   for(i=0;i    for(j=0;j      scanf(\"%d\",&mat[i][j]);   for(i=0;i    {       for(k=0,j=i;j>=0;j--,k++)  printf(\"%d \",mat[k][j]);       printf(\"\\n\");     }     for(i=1;i      {  for(j=m-1,k=i;k   printf(\"%d \",mat[k][j]);  printf(\"\\n\");       }   return 0; }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6253551042953216","download_status":"DOWNLOAD_DONE","votes":"-4","answersCount":"11","title":"Modify the following code to add a row number for each line is printed","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"public class Test { \n  //add this line \n  public static int count = 0; \n  public static void main(String [] args){ \n   printParenthesis(3); \n  } \n  public static void printParenthesis(int n){ \n   char buffer[] = new char[n*2]; \n   printP(buffer,0,n,0,0); \n  } \n  public static void printP(char buffer[], int index, int n, int open, int close){ \n   if(close == n){ \n    // change System.out.println(new String(buffer)); to the following line \n    System.out.println(++count+\".\" + new String(buffer)); \n   }else{ \n    if(open > close){ \n     buffer[index] = ']'; \n     printP(buffer, index+1, n, open, close+1); \n    } \n    if(open < n ){ \n     buffer[index] = '['; \n     printP(buffer,index+1,n,open+1,close); \n    } \n   } \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"How about using a static int variable to count everytime that \"count == n\" and then print the number before you print buffer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void printParenthesis(int n){ \n  char buffer[] = new char[n*2 + 2]; \n                buffer[0] = 1; \n                buffer[1] = '.'; \n  printP(buffer,2,n,0,0); \n } \n.............. \n  if(close == n){ \n   System.out.println((int)buffer[0]++ + new String(buffer, 1, buffer.length - 1)); \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"is someone trolling me? you're supposed to just add a syso.println() at the end of he printParanthesis method. Or am I missing something here?..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If two people test this code running at the same time running on the same JVM there might be interference with the static variable (not thread safe). We can create a new instance of the line counter every time the printParenthesis method is being executed."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5724823657381888","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"25","title":"Given an array of (unsorted) integers, arrange them such that a < b > c < d > e... etc.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"Swapping alternate elements solves the problem"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"sort the array, then swap two neighbor elements from the second item"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Guys, you all missed the duplicates...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Question is ambiguous (as usualy for CC).  a < b > c < d  <-expressions like this are not well defined nor used in math.  a < b < c is an idiom that has come to mean a < b && b < c But since it's the same inequality < used in both places, it matters not whether we explicitly state that a < c also (because this is true by transitivity automatically).  We can extend this to a < b < c < d < e < f  safely. Note above implies 5 inequalities directly, and 6choose2 inequalities in total.  Now if you have something like  a < b > c < d > e  What does this say about the relative ordering of a vs. d  or b vs. e ?  Or does it say nothing about these?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"First, find the midpoint of the set. A great way to do this is to use a modified quicksort where you only drill into the partition on either side of your pivot that you know contains the midpoint. Return the midpoint as soon as the number of items to the left is equal to half the size of the list.  Then, just create a left and right list populated by taking every element from the original list except the midpoint and putting it in left if it's lower, right if it's higher. Merge the lists together by interleaving them, and put the midpoint at the end. The final ordering will match the required parameters, and except in worst case (an ordered list) the whole function is O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Sort the list first   (5, 7, 1, 8, 3, 2, 9, 4, 2, 6 becomes 1, 2, 3, 4, 5, 6, 7, 8, 9) 2) Start filling the the odd indices. Keep track of remaining numbers and the number even slots (even slots are empty). The new array is like 1, _, 2, _, 3, _, 4 etc. 3) When the # of empty slots equals remaining numbers (there could be a boundary condition here +/- 1), start filling the even slots. That is when the array becomes 1, _, 2, _, 3, _, 4, _, 5 we have 4 dashes and 4 remaining numbers {6, 7, 8, 9} So start filling the dashes. that is 1, 6, 2, 7, 3, _, 4, _, 5 and like that. 4) The end result will be 1, 6, 2, 7, 3, 8, 4, 9, 5 which is a solution.  Complexity = Sort + 2 pass O ( n log n + 2*n)  = O (n log n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Heres a full solution in C#: 1. Sort the array in incrementing order 2. Check each value of the array (starting at 0), and determine if it withholds the stated rules (if even index, should be less than right, if odd should be greater than) 3. If not, continue moving right along indices and find element that withholds rules 4. Continue till exhausted all indices"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#define MAX_SIZE_ARRAY 10 \n \nvoid sortarray(int a[]); \nvoid swap(int *a, int *b); \n \nvoid sequence_swap(int * a); \n \nint main(void) \n{ \n int a[MAX_SIZE_ARRAY], index; \n \n printf(\"Enter array elements\\n\"); \n for(index = 0;  index < MAX_SIZE_ARRAY; ++index) \n  scanf(\"%d\",&a[index]); \n \n printf(\"Entered array elements is:\\n\\n\"); \n for(index = 0;  index < MAX_SIZE_ARRAY; ++index) \n  printf(\"%d \",a[index]); \n \n printf(\"\\n\"); \n \n sortarray(a); \n \n printf(\"sorted array is:\\n\"); \n for(index = 0; index< MAX_SIZE_ARRAY; ++index) \n  printf(\"%d \", a[index]); \n  \n printf(\"\\n\"); \n \n sequence_swap(a); \n \n printf(\"ace etc sequence is:\\n\"); \n for(index = 0; index< MAX_SIZE_ARRAY; ++index) \n  printf(\"%d \", a[index]); \n \nreturn 0; \n} \n \nvoid sortarray(int *a) \n{ \n int i , j, n; \n n = MAX_SIZE_ARRAY; \n for(i = 0; i < n; ++i) \n  for (j = n - 1; j > i; --j) \n   if(a[j-1] > a[j]) \n    swap(&a[j],&a[j-1]);  \n} \n \nvoid swap(int *a, int *b) \n{ \nint temp; \ntemp = *a; \n*a = *b; \n*b = temp; \n} \n \nvoid sequence_swap(int *a) \n{ \n int i; \n int temp; \n for (i =1; i < MAX_SIZE_ARRAY-1 ; i +=2 ) \n { \n temp = a[i]; \n a[i] = a[i+1]; \n a[i+1] = temp; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Post-order travel of a BST?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my solution in Java. Let me know what you think."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think there is no need to sort complete array, we can make use of min-heap here. Complete algorithm can complete in O(n/2 * log n) Steps: 1. Transform array into min-heap, in O(n) 2. Swap root with second last element in array 3. Reduce heap size by 2 (which means last 2 elements are already in required form) 4. Heapify root element. 5. Repeat steps 3 and 4 until heap size becomes 0 (this operation completes in O(n/2 * log n))  Please refer below source code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void arrange(int[] array) { \n for(int i = 0; i < array.length - 1; i++) { \n  if(i % 2 == 0) { \n   if(array[i] > array[i + 1]) { \n    swap(array, i, i + 1); \n   } \n  } \n  else { \n   if(array[i] < array[i + 1]) { \n    swap(array, i, i + 1); \n   } \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a brute force solution which lists all combinations of possible solutions given an unordered array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"std::list L ={16,2,9,7,1,8,5,3,6,2,8,2}; \n    L.sort(); \n    L.unique(); \n    std::vector V {std::make_move_iterator(std::begin(L)), \n        std::make_move_iterator(std::end(L)) }; \n     \n    for (int i = 0; i c < d > e, etc \n            std::iter_swap(V.begin()+i, V.begin()+i+V.size()/2-1); \n        } \n         \n    } \n        for (int i = 0; i"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5634470967246848","download_status":"DOWNLOAD_DONE","votes":"-2","answersCount":"10","title":"Find a shortest path in a N*N matrix maze from (0,0) to (N,N), assume 1 is passable, 0 is not, 3 is destination, use memorization to cache the result. Here is my code. I am not sure if I am caching it right.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Paint fill +  cache of the path + backtracking, keep min path in a global list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I feel DFS approach will solve the problem here as the intermediate results (ex: a string indicating the path) get stored on the system memory through recursive calls. And when we hit the destination, we return boolean (true else false) value based on which we get back with status whether the destination is reached or not and the result will contain the path.  Correct me i interpreted the question wrong!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since we do not know the location of 3 and there is no weight on route, I used Breath Search First. Otherwise, Dijkstra or Bellman-Ford as we learned on communication networks... I used a matrix to track the parent of each node. I thought on using a list associated with each pendent to visit node and mark the visited in the same matrix (e.g. 4). Actually I think it use less memory with the \"parent\" list instead of matrix...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* \nThought: \n1) Using BFS \n2) Find dest first, using A* \n*/ \n \nimport java.util.LinkedList; \nimport java.util.HashSet; \nimport java.util.ArrayList; \nimport java.util.Collections; \n \nclass PathStep { \n int i, j; \n PathStep prev; \n \n public PathStep(int i, int j, PathStep prev) { \n  this.i = i; \n  this.j = j; \n  this.prev = prev; \n } \n \n public String toString() { \n  return \"[\" + i + \", \" + j + \"]\"; \n } \n} \n \nclass Main { \n // BFS \n public static void shortestPath(int[][] matrix) { \n  int N = matrix.length; \n  // initial \n  PathStep step = new PathStep(0, 0, null); \n  LinkedList queue = new LinkedList(); \n  queue.add(step); \n  // using set to check if already traversed \n  HashSet set = new HashSet(); \n  boolean findDest = false; \n  while(!queue.isEmpty() && !findDest) { \n   LinkedList tmpQueue = new LinkedList(); \n   while(!queue.isEmpty()) { \n    step = queue.remove(); \n    int i = step.i, j = step.j, id; \n    if(matrix[i][j] == 3) { // find dest \n     findDest = true; \n     break; \n    } \n    PathStep next; \n    // move left \n    if(j > 0 && matrix[i][j - 1] != 0) { \n     id = N * i + (j - 1); \n     if(!set.contains(id)) { \n      set.add(id); \n      next = new PathStep(i, j - 1, step); \n      tmpQueue.add(next); \n     } \n    } \n    // move right \n    if(j < N - 1 && matrix[i][j + 1] != 0) { \n     id = N * i + (j + 1); \n     if(!set.contains(id)) { \n      set.add(id); \n      next = new PathStep(i, j + 1, step); \n      tmpQueue.add(next); \n     } \n    } \n    // move up \n    if(i > 0 && matrix[i - 1][j] != 0) { \n     id = N * (i - 1) + j; \n     if(!set.contains(id)) { \n      set.add(id); \n      next = new PathStep(i - 1, j, step); \n      tmpQueue.add(next); \n     } \n    } \n    // move down \n    if(i < N - 1 && matrix[i + 1][j] != 0) { \n     id = N * (i + 1) + j; \n     if(!set.contains(id)) { \n      set.add(id); \n      next = new PathStep(i + 1, j, step); \n      tmpQueue.add(next); \n     } \n    } \n   } \n   queue = tmpQueue; \n  } \n  if(findDest) { \n   // build path \n   ArrayList path = new ArrayList(); \n   while(step != null) { \n    path.add(step); \n    step = step.prev; \n   } \n   Collections.reverse(path); \n   // print path \n   for(int i = 0; i < path.size(); i++) { \n    if(i == path.size() - 1) { \n     System.out.println(path.get(i)); \n    } \n    else { \n     System.out.print(path.get(i) + \" -> \"); \n    } \n   } \n  } \n } \n \n public static void main(String[] args) { \n  int[][] matrix = { \n   {1,1,1,1,1,1,1,1}, \n   {1,0,0,0,0,0,0,1}, \n   {1,1,0,0,0,0,0,1}, \n   {0,1,1,1,0,0,0,1}, \n   {0,0,0,1,0,0,0,1}, \n   {1,1,1,1,0,0,0,1}, \n   {1,0,0,0,0,0,0,1}, \n   {3,1,1,1,1,1,1,1} \n  }; \n  shortestPath(matrix); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \n \nusing namespace std; \n \nvoid printPath(int prev[], int dest, int dist, int n) { \n  stack st; \n \n  while (dest != 0) { \n    st.push(dest); \n    dest = prev[dest]; \n  } \n   \n  cout<< \"Shortest distance to destination is: \" << dist << \" steps.\"< \"; \n  while (!st.empty()) { \n    dest = st.top(); \n    st.pop(); \n    cout << dest/n<<\",\"< \"; \n  } \n  cout << endl; \n} \n \nvoid shortestPath(int mat[100][100], int n) { \n  int d[n*n]; \n  int prev[n*n]; \n  for(int i=0; i< n*n; ++i) { \n    d[i] = n*n+1; \n    prev[i] = -1; \n  } \n  d[0] = 0; \n  queue q; \n  q.push(0); \n  bool reached = false; \n  while(!q.empty() && !reached) { \n    int curr = q.front(); \n    int row = curr/n; \n    int col = curr%n; \n    if(mat[row][col] == 3){ \n      // reached destination \n      reached = true; \n      break; \n    } \n    q.pop(); \n    int next; \n    // go UP \n    if(row>0 && mat[row-1][col] != 0){ \n      next = (row-1)*n + col; \n      if(d[next] > d[curr]+1){ \n        d[next] = d[curr]+1; \n        prev[next] = curr; \n        q.push(next); \n      } \n    } \n    //go DOWN \n    if(row < n-1 && mat[row+1][col] != 0){ \n      next = (row+1)*n + col; \n      if(d[next] > d[curr]+1){ \n        d[next] = d[curr]+1; \n        prev[next] = curr; \n        q.push(next); \n      } \n    } \n    //go LEFT \n    if(col > 0 && mat[row][col-1] != 0){ \n      next = row*n + col-1; \n      if(d[next] > d[curr]+1){ \n        d[next] = d[curr]+1; \n        prev[next] = curr; \n        q.push(next); \n      } \n    } \n    //go RIGHT \n    if(col < n-1 && mat[row][col+1] != 0){ \n      next = row*n + col+1; \n      if(d[next] > d[curr]+1){ \n        d[next] = d[curr]+1; \n        prev[next] = curr; \n        q.push(next); \n      } \n    } \n  } \n \n  if(reached){ \n    printPath(prev, q.front(), d[q.front()], n); \n  } \n} \n \nint main() { \n  int mat[100][100] = {{1,1,1,1,1,0}, \n                       {1,1,0,0,1,0}, \n                       {0,1,1,1,1,0}, \n                       {1,1,0,3,1,0}, \n                       {1,1,1,1,1,1}, \n                       {0,0,0,0,0,0}}; \n \n  shortestPath(mat, 6); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"In fact, I just tested my code. Turned out the cache is not working. It only stores the first path it has found. How should I fix this cache? If I took out the cache, the code works fine and is able to find the shortest path."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5898529851572224","download_status":"DOWNLOAD_DONE","votes":"-4","answersCount":"5","title":"Flatten an iterator of iterators in Java. If the input is [ [1,2], [3,[4,5]], 6], it should return [1,2,3,4,5,6]. Implement hasNext() and next(). Note that the inner iterator or list might be empty.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; \nimport java.util.Collection; \nimport java.util.Iterator; \n \npublic class MyIterator implements Iterator { \n  \n Collection c; \n ArrayList objs = new ArrayList(); \n Iterator itr = null; \n  \n public MyIterator(Collection obj) { \n  c = obj; \n  if(!c.isEmpty()) { \n   extractAll(c); \n   itr = objs.iterator(); \n  } \n } \n  \n private void extractAll(Collection obj) { \n  Iterator itr = obj.iterator(); \n  while(itr.hasNext()) { \n   Object o = itr.next(); \n   if(o != null) { \n    if(o instanceof Collection) { \n     extractAll((Collection)o); \n    } else { \n     objs.add(o); \n    }     \n   } \n  } \n } \n \n public static void main(String[] args) { \n  ArrayList vals = new ArrayList(); \n  vals.add(0, new ArrayList()); \n  vals.add(1, new ArrayList()); \n  vals.add(2, new ArrayList()); \n  vals.add(3, new ArrayList()); \n  int count = 0; \n  for(ArrayList v : vals) { \n   int temp = count; \n   for(int i=temp; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; \nimport java.util.Iterator; \n \n \npublic class Problem { \n public static void main(String[] args) { \n  ArrayList> integers = new ArrayList>(); \n  for (int i = 0; i < 10; i++) { \n   ArrayList temp = new ArrayList(); \n   for (int j = 0; j < i; j++) { \n    temp.add(i); \n   } \n   integers.add(temp); \n  } \n  ArrayList> iter = new ArrayList>(); \n  for (int i = 0; i < integers.size(); i++) { \n   iter.add(integers.get(i).iterator()); \n  } \n  Iterator> iterator = iter.iterator(); \n   \n  ArrayList arrInts = new ArrayList(); \n   \n   \n  while(iterator.hasNext()){ \n   Iterator i = iterator.next(); \n   while(i.hasNext()){ \n    int j = i.next(); \n    arrInts.add(j); \n   } \n  } \n   \n   \n  for (int i = 0; i < arrInts.size(); i++) { \n   System.out.println(arrInts.get(i)); \n  } \n   \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class FlatIterator implements Iterator{ \n List list; \n Stack stack; \n Iterator currIterator; \n public FlatIterator(List l){ \n this.list=l; \n stack = new Stack(); \n currIterator = list.iterator; \n} \n \n boolean hasNext() { \n \n  if(!currIterator.hasNext()){ \n   if(stack.isEmpty()) \n  return false; \n else{ \n return stack.peek().hasNext(); \n} \n}else{ \n return true;; \n} \n } \n \n Integer next() {   \n  if(currIterator.hasNext()){ \n \n  Object curr =currIterator.next(); \n  if(curr instanceof Integer) \n return curr; \nelse{ \n stack.push(currIterator); \n currIterator = curr.iterator; \n return this.next(); \n} \n} else if(!stack.isEmpty()){ \n currIterator = stack.pop(); \n return this.next(); \n} \n \n } \n \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5153954321137664","download_status":"DOWNLOAD_DONE","votes":"-4","answersCount":"1","title":"Flatten an iterator of iterators in Java. If the input is [ [1,2], [3,[4,5]], 6], it should return [1,2,3,4,5,6]. Implement hasNext() and next().","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"GZ_Penny, you have been warned.  Stop posting dozens of questions ever few days."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6332750214725632","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"22","title":"Given a set of intervals, find the interval which has the maximum number of intersections (not the length of a particular intersection). So if input (1,6) (2,3) (4,11), (1,6) should be returned. Some suggest to use Interval Tree to get this done in O(logn), but I did not understand how to construct and use the Interval Tree after reading its wiki page. Is there any other way to do it? If Interval tree is the only option, please educate me how to construct/use one. Thanks.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This algorithm is O(n log n) where n is the number of intervals. We first sort the array on the end points. Call this array C. Then we build two arrays (with size equal to C.size() ) A and B where A[i] shows how many intervals gets opened in from C[A.size()-1] down to C[i+1] and B[i] shows how many intervals got closed from C[0] up to C[i]. Trivially we can build both A and B in O(n). Now for each interval I with left point in C[i] and right point in C[j], the number of intervals intersecting interval I would be (n - A[j] -B[i])."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Say point records are as {X,Y}.  1. We sort all Xi's and all Yi's on the number line [Some DS] and maintain entry and exit  counts for each such Xi and Yi, all initialized to zeros. 2. For each record {Xi, Yi}, we add 1 in entry count of Xi and add 1 in exit count of Yi. 3. Now for the number line, we have at each interval a count of active number of intersections. 4. The max number of that is the answer. While finding the max, if we track the intervals where we are getting that value, we could also get the range of the required intersection."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If nothing has been said about the order of the algorithm and none of the above solutions seems to work, here is one solution (with O(n^2) :) ) n = number of the intervals  1. create a n x n matrix with all zeros 0 0 0 0 0 0 0 0 0  2. starting with the first interval and checking its intersection with the next intervals we have: 0 1 1 1 0 0 1 0 0  3. going on the second interval and checking with the next intervals and so on in this case we have: 0 1 1 1 0 0 1 0 0  4. summing up all the rows (or columns) we have 1 | 0 1 1 | = 2 2 | 1 0 0 | = 1 3 | 1 0 0 | = 1  so the first interval is the interval that has the most intersections =  (1,6)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"No need for interval trees.  You can sort all endpoints into a single array , or use separate sorted arrays as below:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"My algorithm is O(nlogn + m*n), where m is the maximum number of intersections with any single interval.  Sort the interval by both start points and end points. Keep track of the active segments. When reaching a start point, increment the intersection counts of all active intervals, and set the new interval's intersection count to the number of active intervals (excluding itself). When reaching an end point, remove the interval from the active intervals.  So worst case would be O(n^2). Can we do better than this?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"package amazon; \n \nimport java.util.ArrayList; \nimport java.util.HashMap; \nimport java.util.Iterator; \n \npublic class Lab2 { \n \n public static void main(String[] args) { \n  line maxLine = null; \n  int maxCount = 0; \n \n  ArrayList ar = new ArrayList(); \n  ar.add(new line(1,6)); \n  ar.add(new line(2,3)); \n  ar.add(new line(3,4)); \n  ar.add(new line(4,11)); \n  System.out.println(ar.get(0)); \n  System.out.println(ar.get(1)); \n  System.out.println(ar.get(2)); \n  int len = ar.size(); \n  HashMap hs = new HashMap(); \n  for(int i = 0; i < (len - 1) ; i++) \n  { \n   line l = ar.get(i); \n   int count = 0; \n   for(int j = i + 1; j < (len - 1); j ++) \n   { \n    line l2 = ar.get(j); \n     \n    if((l.start < l2.start) && (l.last > l2.last)) \n    { \n     count = count + 1; \n    } \n    if(count > maxCount) \n    { \n     maxLine = l; \n     maxCount = count; \n    } \n   } \n    \n  } \n  System.out.println(\"The line is \" + maxLine + maxCount); \n } \n \n} \nclass line \n{ \n int start; \n int last; \n public line(int start, int last) { \n  super(); \n  this.start = start; \n  this.last = last; \n } \n @Override \n public String toString() { \n  return \"(\" + start + \",\" + last + \")\"; \n } \n  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Guys! Are you morons?! Don't try answering if you got nothing to say..."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4825980929572864","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"3","title":"What happens when you type a link in any browser and click GO button? List all steps.  What should be the issue if the browser app build that i have today is 1 second 250 milliseconds slower than yesterday's build? ASSUME: WiFi is perfect, loading 10 webpages from a controlled server - hence there are no infrastructure or server side delays causing this.  What would you think might be the issue? How would you debug?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. figure out what code changes between today and yesterday, only consider covered code changes by the input test cases. 2. use some runtime performance tools to check affected functions 3. read source code, guess, reverse back... check it again.  Any experienced programmers have better ways to handle this?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Programmatically these are the approaches that I would take. 1. Test it on multiple browsers and check if the behavior(delay) is same or occurring only particular browser. 2. use the time collected from past few weeks and observe for any patterns. 3. Write some complete end to end integration/regression test cases. 4. Rely on some unit tests that are written for the code developed from yesterday to today. 5. see if there are any data structures in the back end are changed. 6. see if the datasource/database queries are changed."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"On top of my head, the url will first go to either your local cache or DNS server to get ip. It will then send to http request to the target ip and get response from the server with that ip.  I might think the other way, if my browser cache is cleaned, it would take more time then yesterday. It would also because the website was updated yesterday. More css, js or resource file need to be parsed. I would try a few more times before give the conclusion that there were something wrong with my code."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5157655484039168","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"19","title":"You are given a string FOOFIGHTERS. You have to come up with an algorithm that will compress this string.  You also have to make sure that you are not using extra memory. For example: FOOFIGHTERS will be compressed as FO2FIGHTERS. You should not use another array or bitfield to keep a frequency count for the individual letters.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"ASCII code uses only 8 bits of the available 32 bits of word size. I have tried using the remaining 24 bits to store additional characters."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"BBBCCCAAAAUUUAAABBBDEF will be converted to B3C3A4U3A3B3DEF. Is this correct assumption?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about regular expressions, wouldn't that be easier?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"they said that no extra memory is needed:  1) scan through left to right 2) find max contiguous same characters substring, assume the start/end indices are i and j respectively for current character c. 3) write (j-i+1) integer as string from position i+1, assume the end of integer string is k. move all the rest of original string forward to position k+1.  Only O(1) extra space is needed. and the time complexity is O(n^2)?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is one solution Read the string (Char[]) from the end to the front and modified the char[] in place from the end to front."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static String compress(char[] input) { \n  if (input == null )  return null; \n  if (input.length == 1) return String.valueOf(input); \n  StringBuilder result = new StringBuilder(); \n  int p = 0; \n  for ( int i = 1; i < input.length; ++ i) { \n   if ( input[i] != input[p] ) {     \n    result.append(input[p]); \n    if (i-p > 1) {  \n     result.append(String.valueOf(i-p)); \n     p+=(i-p); \n    } else { \n     p++; \n    } \n   } \n  } \n  result.append(input[input.length-1]); \n  if (p < input.length-1) { \n   result.append(String.valueOf(input.length-p)); \n  } \n return result.toString(); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"string int2str(int i){ \n string res; \n while(i > 0){ \n  res.push_back('0'+i%10); i/=10; \n } \n reverse(res.begin(), res.end()); \n if(res.length() == 0) return \"0\"; \n return res; \n} \nstring compress(string s){ \n if(s.length() < 2) return s; \n string res; \n int i = 0, j = 0; \n while(j < s.length()) \n { \n  if(s[i] == s[j]){ \n   j++; continue; \n  } \n  res.push_back(s[i]); \n  if(j-i>1) res += int2str(j-i); \n  i = j; \n } \n res.push_back(s[i]);  \n if(j-i>1) res += int2str(j-i); \n return res; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming, that we basically want collapse repetitions to  format. E.g. \"HHHHHHHHHHELLLLLLLLLLLLPPPP ME BOBBBBBB\" becomes \"H10EL12P4 ME BOB6\" Also, assuming numbers are not allowed in the input."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class CompressString { \n \n /** \n  * @param args \n  * You are given a string FOOFIGHTERS. \n  *  You have to come up with an algorithm that will compress this string. \n  *  You also have to make sure that you are not using extra memory.  \n  *  For example: FOOFIGHTERS will be compressed as FO2FIGHTERS.  \n  *  You should not use another array or bitfield to keep a frequency count for the individual letters. \n  */ \n public static void main(String[] args) { \n  // TODO Auto-generated method stub \n  CompressString cs = new CompressString(); \n  cs.compress(); \n } \n \n private void compress() { \n  String s = \"ffreesourrrrrrcecooomkhhhggggyutttkkkkkk\"; \n  char arr[] = s.toCharArray(); \n \n  int arrayLength = arr.length; \n  int pointer1 = 0; \n  int pointer2 = 0; \n  char element = '\\0'; \n  int count = 1; \n  for (int i = 0; i < arrayLength; i++) { \n   if (i > 0) { \n    if (arr[i] == arr[i - 1]) { \n     if (pointer1 == 0) { \n      if (pointer2 > 0) { \n       pointer1 = pointer2 + 1; \n      } else { \n       pointer1 = i; \n      } \n     } \n     count++; \n    } else { \n     if (count > 2) { \n      pointer2 = pointer1; \n      arr[pointer1] = (char) ('0' + count); \n      pointer1 = 0; \n      count = 1; \n     } else if (count == 2) { \n      if (pointer2 > 0) { \n       pointer2 = pointer1; \n      } \n      arr[pointer1] = (char) ('0' + count); \n      pointer1 = 0; \n      count = 1; \n     } \n    } \n \n    if (pointer2 > 0 && count == 1) { \n     pointer2++; \n     arr[pointer2] = arr[i]; \n    } \n \n   } \n  } \n \n  if (pointer2 > 0) { \n   if (count > 1) { \n    arr[++pointer2] = (char) ('0' + count); \n   } \n   for (int i = (pointer2 + 1); i < arrayLength; i++) { \n    arr[i] = '\\0'; \n   } \n  } \n \n  for (char c : arr) { \n   System.out.print(c + \" \"); \n  } \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a clean c++ code. Although I have used string class from c++, the same can be done with c style pointers. I just feel lazy to do with c-style string."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is my java solution   public String compress(String word) {   char lastLetter = 0;   int lastLetterCounter = 0;   for (int i = 0; i < word.length() ; i++) {    char tempLetter = word.charAt(i);    if (tempLetter == lastLetter) {     if (++lastLetterCounter >= 2) {      word = word.substring(0, lastLetterCounter == 2 ? i : i - 1) + lastLetterCounter + word.substring(i+1);     }    } else {     lastLetterCounter = 1;    }    lastLetter = tempLetter;   }   return word;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public char[] compress(char[] A) \n{ \n int k = 0; \n for(int i = 0; i < A.length(); ) \n { \n  A[k] = A[i]; \n  int j = i + 1; \n \n  while ((j < A.length()) && (A[i] == A[j])) \n  { \n   j++; \n  } \n \n  if(i < (j-1)) \n  { \n   A[k+1] = j - i; \n   k = k + 2; \n   i = j; \n  } \n  else \n  { \n   i++; \n   k++; \n \n   if(i == A.length()) \n   { \n    while(k < A.length()) \n    { \n     A[k] = null; \n     k++; \n    } \n   } \n  } \n } \n \n return A; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6283958983589888","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"28","title":"Find the k-th Smallest Element in Two Sorted Arrays. I followed the algorithm from this post, http://leetcode.com/2011/01/find-k-th-smallest-element-in-union-of.html But it does not handle the case where there are duplicates? Does anyone know how to do that? Also, in Java, how should we reduce the size of the arrays? I used the code below, but did not work.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* \n * where 'n' in [1, size1+size2] \n *// \nint find(const int *arr1, const int size1, const int *arr2, const int size2, const int n) \n{ \n    if (size1 <= 0 || size2 <= 0 || arr1 == 0 || arr2 == 0 || n == 0 || n > size1+size2) \n        return -1; \n \n    int i = 0, j = 0; \n    int val = 0; \n    while (i+j < n) \n    { \n        if ((i < size1 && !(j < size2)) || (i < size1 && arr1[i] < arr2[j])) \n        { \n            val = arr1[i]; \n            i++; \n        } \n        else \n        { \n            if (j < size2) \n                val = arr2[j]; \n            j++; \n        } \n    } \n \n    return val; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//this is sooo easy. just do something similar to a merge sort except u process it only k times. int gimme (int[] first, int[]sec, int k) {  int seen = 0, i = 0, j = 0;         for(; seen < k; ++seen)         {            if(i == first.length) { j++; continue; }            if(j == second.length) { i++; continue; }            if(first[i] < second[j])i++; else j++;                   }         return Math.min(first[i],second[j];)          }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You should clarify what kth smallest element mean when there are duplicates. If it means there are k-1 elements that are smaller than the result, but that k-1 elements may itself has duplicates, you algorithm still works.  If it means there are k-1 distinct values that are smaller than the result, then there is no O(log n) solution. At least not to my knowledge."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A simple solution in java. Worst case is O(n). Logic is the same of merge in MergeSort: we have two index i,j that move in the two arrays as minimum element is found respectively. We need an additional check for duplicate elements. This is a simple loop to move pointers to an element which is bigger than current minimum."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int findkthsmallest(int a[], int b[], int k, int len1, int len2) { \n \n    int i = 0, j = 0; \n    int elem=0, tmp=0, k1 = k; \n    assert(k); \n    if (k>len1 && k > len2) \n      assert (0); \n    while (k) { \n        if (i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can use merge sort approach. Use a variable, n, to keep the count of nth smallest number. Keep track of the current nth smallest number, if both values are the same and is equal to the ith smallest number, skip both values, otherwise increment n and update the smallest number. If n equals k, return the nth smallest number   If one of them reaches to the end of the array, do a while loop from there until n reaches k."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a solution in O(nlgm + mlgn) time, the idea is basically looking for a pair of indices (i, j) in arrays A and B respectively such that j = k - (i + 1) and B[j] <= A[i] <= B[j+1]. In other words, we're looking in A for an item larger than k - 1 items (making it the kth largest one).  We can do this with a binary search in A and if no such item exists in it we can look in B instead. This is the code for the described algorithm:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just a speed-up on the O(k) merge sort. The initial indexing variables on arrays a and b can both start from k/2 rather than 0, since the kth smallest element will definitely not be in [0-k/2] elements of each of the arrays. This way you could double the speed by reducing the merging size by half."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/** \n * Objective: To find Kth smallest element from two sorted arrays \n *  \n * @author sunichak \n * \n */ \npublic class KthSmallestElementInTwoSortedArrays { \n \n public static void main(String[] args) { \n  // sample input \n  int[] first = {1,5,6,7,9}; \n  int[] second = {1,3,5,5,8}; \n  int k = 5; \n  getKthElement(k, first, second); \n } \n  \n static void getKthElement(int k, int[] first, int[] second) { \n  int count = 0, i = 0, j = 0; \n  int val = 0; \n  if(k<1 || k>(first.length + second.length)) { \n   System.out.println(\"Invalid K!\"); \n   return; \n  } \n  while(count != k) { \n   int a, b; \n   if(i < first.length) {  \n    a = first[i]; \n   } else { \n    a = Integer.MAX_VALUE; \n   } \n   if(j < second.length) { \n    b = second[j]; \n   } else { \n    b = Integer.MAX_VALUE; \n   } \n   if(a == b && a != Integer.MAX_VALUE) { \n    i++; \n   } else if(a < b && a != val) { \n    if(val != a) { \n     val = a; \n     count++; \n    } \n    i++; \n    continue; \n   } else if(a > b) { \n    if(val != b) { \n     val = b; \n     count++; \n    }  \n    j++; \n    continue; \n   } else { \n    count++; \n   } \n  } \n  System.out.println(val); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The best I can think of is O(k log(n)) complexity. It is essentially finding first k (or up to k if there are fewer) distinct elements in each array, and using an O(log(k)) algorithm to find the kth distinct element."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Find the middle element of First array A, say Amid 2) Find the first element in B which is <= A[Mid], say Bbound 3) Let no of elements from AL to Amid be no_A 3) Let no of elements from BL to Bbound be no_B 4) if no_A+no_B == k , then max of A[Mid],B[Bound] is our solution 5) if no_A+no_B > K , then Kth element is in A(AL,AMid-1) or B(BL,Bound-1) 6) if no_A+no_B < K, then the Kth element is in A(Mid+1,AR) or B(Bound+1,BR), , you need to adjust K to K-(no_A+no_B) Base case: if A is exhaused return B[BL+k] if B is exhaused return A[AL+K]  I think the overall complexity is O(logn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Uses binary search among the first K elements in both the arrays."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"If Google is asking this, then I do not want to work there.  Way too easy."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6271724635029504","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"22","title":"Finding a pair of elements from two sorted lists(or array) for which the sum of the elements is a certain value. Anyway solution that can do better than O(a.length + b.length)?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"I think using binary search is O( min(a.length, b.length) + max(log(a.length), log(b.length)). It's better than O(a.length + b.length) if, say, b.length >> a.length"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Given two arrays A and B such that either their length is same or one of them is longer. Let say if A is longer then,  indexA = 0; indexB = B.length -1; initialize sum = B[indexB] + A[indexA]. while(indexA < A.length && indexB >= 0) { if( sum == target )  done  else if( sum > target )  indexB--; else  indexA++; }  Time complexity - We can think of above traversal as diagonal traversal that we do in sorted matrix to find a element, which will have complexity O(A.length + B.length ).  We can improvise above logic, by doing binary search on the hypothetical diagonal (0,0) to (A.length, B.length ) and follow the same logic for searching the element in a sorted matrix."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Let x be the value to which pair of elements sums up to.  Algorithm: Assume that a has a smaller size than b. Now, iterate over a. For each element e in a, do a binary search for (x-e) in b.  This algorithm will run in O(a.length * log(b.length)). This runtime will be less than O(a.length + b.length) when b.length >> a.length."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is it possible to get O(a.length + b. length) algorithm? GZ_Penny can you clarify whether it was not O(a.length*b. length).. I think the best is using Binary search on the longer array while considering each value in the smaller array could be the best run time as mentioned above by others.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. initialize idxA = 0, representing index in a[] 2. Do binary search for possible pair in b[0]. have a idxB record the resulting position 3. At this point idxB points to closest possible value (or equal) to the desired sum. 4. do linear search through a[] & b[], follow the rule:  if (a[idxA] + b[idxB] > x) idxB--  else if (a[idxA] + b[idxb] < x) idxA++  else found.  This should have worst case O(a.len+b.len) but slightly better in average case."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is obvious to use each value, say n, in shorter list to conduct binary search in longer list for  value sum - n. The trick is that after first search, any following search can be restricted to range  of (0, p) of the longer list, where p, returned by the previous search, is the index in the longer list, and whose value + n > sum. Here is Java implementation:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The approach i would prefer is:  1) First choose the smaller array from the two. Get lengths, compare. 2) for each number in the chosen array, compute the diff of required sum, perform binary search on the second array. if found, preserve the pair and continue.  worst case would be A and B of equal size. assuming N then complexity would be O(NlogN)  Correct me if i am wrong!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Take the smaller of the two arrays. Do a binary search to find whether there exists an element in the longer array s.t. a[0]+b[x] = N. That search just takes log(b) time. Now, walk backwards along the longer array from that point, looking for elements that satisfy a[i] + b[j] = N. Each time you either find an element s.t. a[i] + b[j] <= N move forward once in a and re-test. Continue going forward in a until a[i] + b[j] >= N. Then resume going backward through b.  I think that's the optimal algorithm, but yeah, it's going to run in O(a+b). I mean, you could get cute about it and if you know N is odd, you could only test a[i] with b[j] when one is odd and the other is even, or if N is even, only test a[i] and b[j] when both are odd or both are even. Testing for evenness means only looking at the least order bit, which might be faster than actually adding two numbers, especially if they're very large. But in the worst case, all pairs between a and b are potentially valid by this test, and all you've done is add a small piece of work to every step. So, perhaps there are optimizations possible depending on what you know about your data, but for the general case, I think O(a+b) is as good as you're liable to get."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class SortedListPairSum { \n/* \n * Finding a pair of elements from two sorted lists(or array) for which the sum of the elements is a certain value. \n * Anyway solution that can do better than O(a.length + b.length)? \n */ \n  \n static int[] a = { 2, 4, 7, 11, 16, 19, 20, 21, 21, 22, 27, 28, 29, 30, 30, \n   31, 35, 36, 39, 43, 43, 57, 58, 62, 65, 67, 71, 71, 71, 77, 85, \n   87, 87, 94, 95, 95, 96, 96, 98, 99 }; \n static int[] b = { 10, 29, 30, 30, 33, 35, 37, 42, 44, 46, 49, 67, 69, 70, 71, \n   84, 88, 92, 94, 98 }; \n  \n static int sum = 78; \n  \n public void find(int sum, int startA, int endA,  int startB, int endB){ \n   \n  int midA = (startA + endA) / 2; \n  int midB = (startB + endB) / 2; \n  System.out.println(\"came here midA \" + midA + \" val: \" + a[midA] +\" midB: \" + midB + \" val:\" + b[midB]); \n  if(a[midA] + b[midB] == sum){ \n   System.out.println(\"found the pair:\"); \n   return; \n  } \n  if(midA <= 0 || midB <= 0){ \n   System.out.println(\"Pair not found!!\"); \n   return; \n  } \n  if(a[midA] < b[midB]){ \n   if(a[midA] + b[midB] < sum){ \n      while(a[midA] + b[midB] < sum){ \n     ++midA; \n      } \n      startA = midA; \n   }    \n   else{ \n    while(a[midA] + b[midB] > sum){ \n      --midB; \n    } \n    endB = midB; \n   } \n   find(sum, startA, endA, startB, endB); \n  } \n  else{ \n   if(a[midA] + b[midB] < sum){ \n       while(a[midA] + b[midB] < sum){ \n      ++midB; \n       } \n       startB = midB; \n   }    \n   else{ \n    while(a[midA] + b[midB] > sum){ \n      --midA; \n    } \n    endA = midA; \n   } \n   find(sum, startA, endA, startB, endB); \n  } \n   \n } \n public static void main(String[] args) { \n  // TODO Auto-generated method stub \n        new SortedListPairSum().find(sum, 0, a.length, 0, b.length); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Clearly you cannot beat O(lengths)."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4699414551592960","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"22","title":"we have a random list of people. each person knows his own height and the number of tall people in front of him. write a code to make the equivalent queue. for example : input: <\"Height\",\"NumberOfTall\",\"Name\">,  <6,2,\"A\">,<1,4,\"B\">,<11,0,\"C\">,<5,1,\"D\">,<10,0,\"E\">,<4,0,\"F\"> output: \"F\",\"E\",\"D\",\"C\",\"B\",\"A\" --> end of queue","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"We will use recursion to solve this."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"1.Sort by \"NumberOfTall\" and \"height\":  (1)those who have fewer people taller in front of them have smaller index;  (2)for those having same number of tallers in front, the taller his own height is, the smaller index he has."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"# Idea: Sort them first base on their height. After that insert each of them \n# into the final queue. The insert position is simply how many taller people are \n# ahead of them. \n \ninput = <"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"# here 2 arrays are used p and final.    # sort the input array in ascending order in p[]. then use the function .  final[] will contain the output"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Array of Linked list, index numOfTals, LinkedList is sorted by heights. head of  Linked List at 0 is next element. Unlik part of linked list from index 1 and on and move to linked list at index one less. The unlik part is from the heights equal to removed and on.  Each linked list is also indexed to allow binary search where to unlink  or where to link"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Explain the question properly please.  Equivalent queue???"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Seems suitable for bash...  taller_input: 6 2 \"A\" 1 4 \"B\" 11 0 \"C\" 5 1 \"D\" 10 0 \"E\" 4 0 \"F\"  taller.sh:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5727310284062720","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"16","title":"given an 2D matrix M, is filled either using X or O, you need to find the region which is filled by O and surrounded by X and fill it with X.  example 1:  X X X X X X X O O X X X O O X O X X X X  Answer :  X X X X X X X X X X X X X X X O X X X X  example 2:  X X X X X X X O O X X X O O O O X X X X  answer 2: X X X X X X X O O X X X O O O O X X X X","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"#include  \n#include  \n#include  \n \nusing namespace std; \n \nvoid fillWithY(vector& A, int i, int j) \n{ \n    if (i < 0 || i >= A.size() || j < 0 || j >= A[i].size() || A[i][j] != 'O') \n        return; \n \n    A[i][j] = 'Y'; \n \n    fillWithY(A, i - 1, j); // absorb more 'O' on the top \n    fillWithY(A, i + 1, j); // absorb more 'O' on the bottom \n    fillWithY(A, i, j - 1); // absorb more 'O' on the left \n    fillWithY(A, i, j + 1); // absorb more 'O' on the right \n} \n \nint main() \n{ \n    vector A; \n \n    A.push_back(\"XXXXX\"); \n    A.push_back(\"XXOOX\"); \n    A.push_back(\"XXOOX\"); \n    A.push_back(\"OXXXX\"); \n    \n    // first try to aborb '0's at the boundary and replace them with 'Y' \n    for (int j = 0; j < A[0].size(); j++)  \n        fillWithY(A, 0, j);  \n \n    for (int j = 0; j < A.back().size(); j++)  \n        fillWithY(A, A.size() - 1, j); \n \n    for (int i = 0; i < A.size(); i++) { \n        fillWithY(A, i, 0);  \n        fillWithY(A, i, A[i].size() - 1);  \n    } \n \n    // rewrite internal 'O's with 'X', and restore 'Y's \n    for (int i = 0; i < A.size(); i++) { \n        for (int j = 0; j < A[i].size(); j++) \n            if (A[i][j] == 'Y') \n                A[i][j] = 'O'; \n            else if (A[i][j] == 'O') \n                A[i][j] = 'X'; \n    } \n \n    // shown me the result \n    for (int i = 0; i < A.size(); i++)  \n        cout << A[i] << endl; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"1) Scan the array in concentric squares outside in. 2) Mark all 'O' elements as 'o' if any of the 8 elements surrounding it is an 'o' or its on the edge. In case neither of the above is true change it to 'X' 3) In the end scan through the array and convert all 'o' to 'O'"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this question is the opposite of leetcode oj (surrounded-regions)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For an NxN board, I found a solution O(N^2) time. The worst case space is also O(N^2) when all the cell values are \"O\". But for random input it will be much less (the space is due to stack for recursion).  The only logical clue I found is that if there is an \"O\" on the border, then any it along with all the connected \"O\"'s won't turn into \"X\".  In my code I treat \"0\" as X and \"1\" as \"O\". Also, \"fillup()\" is the function to call and it will use \"spread(i, j)\" to mark the \"O\"'s that won't convert into \"X\". Code in C:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void replace(char *a,int rows,int cols) /* passed array has to be 2d char array */ {  int k,i,j;  for(i=1;i {   for (j=1;j  {    if(*(a+i*cols+j)=='o')    {     for(k=i;k    {      if (*(a+k*cols+j)=='x')          break;     }     if(k==cols) break;     for(k=i;k>=0;k--)     {      if (*(a+k*cols+j)=='x')          break;     }     if(k==-1) break;     for(k=j;k>=0;k--)     {      if (*(a+i*cols+k)=='x')       break;     }     if(k==-1) break;     for(k=j;k    {      if (*(a+i*cols+k)=='x')       break;     }     if(k==rows)       break;          *(a+i*cols+j)='x';    }   }  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// identify the cells which are O and are surrounded \nbool isSurrounded(int i, int j) \n{ \n bool top, bottom, left, right = true; \n bool returnValue = true; \n visited[i][j] = true; \n if(j > 0) \n { \n  if(matrix[i][j-1] == 'O' && visited[i][j-1] != true) \n  { \n   top = isSurrounded(i, j-1); \n  } \n } \n else if(matrix[i][j] == 'O') \n { \n  returnValue = false; \n } \n \n if(j < MAXJ) \n { \n  if(matrix[i][j+1] == 'O' && visited[i][j+1] != true) \n  { \n   bottom = isSurrounded(i, j+1); \n  } \n } \n else if(matrix[i][j] == 'O') \n { \n  returnValue = false; \n } \n \n if(i > 0) \n { \n  if(matrix[i-1][j] == 'O' && visited[i-1][j] != true) \n  { \n   left = isSurrounded(i-1, j); \n  } \n } \n else if(matrix[i-1][j] == 'O') \n { \n  returnValue = false; \n } \n \n if(i < MAXI) \n { \n  if(matrix[i+1][j] == 'O' && visited[i+1][j] != true) \n  { \n   right = isSurrounded(i+1, j); \n  } \n } \n else if(matrix[i+1][j] == '0') \n { \n  returnValue = false; \n } \n \n return returnValue && top && bottom && left && right; \n} \n \n// mark all Xs with Os by looking at the visited matrix \nbool mark(int i, int j) \n{ \n matrix[i][j] = 'O'; \n visited[i][j] = false; \n \n if(i > 0) \n { \n  if(visited[i-1][j]) \n   mark(i-1, j); \n } \n \n if(i < MAXI) \n { \n  if(visited[i+1][j]) \n   mark(i+1, j); \n } \n \n if(j > 0) \n { \n  if(visited[i][j-1]) \n   mark(i, j-1); \n } \n \n if(j < MAXJ) \n { \n  if(visited[i][j+1]) \n   mark(i, j+1); \n } \n} \n \nvoid main() \n{ \n for(int i = 0; i <= MAXI; i++) \n { \n  for(int j = 0; j <= MAXJ; j++) \n  { \n   if(matrix[i][j] == 'O' && visited[i][j] == false) \n   { \n    if(isSurrounded(i, j)) \n    { \n     // an isolated region exists, mark all Xs with Os \n     mark(i, j); \n    } \n   } \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; \nimport java.util.List; \n \npublic class Solution { \n \n    public static char[][] fillMatrix0(char[][] m) { \n         \n        int rows = m.length; \n        int cols = m[0].length; \n        char[][] ret = new char[rows][cols]; \n        List posList = new ArrayList(); \n         \n        for (int i = 0; i < rows; i++) { \n            for (int j = 0; j < cols; j++) { \n                 \n                if (m[i][j] == 'O' && ret[i][j] != 'X') {                  \n                 posList.clear(); \n                 posList.add(i + \",\" + j); \n                    if (isSurroundedByX(posList, m, i, j)) {                      \n                     // mark X for all found in block \n                     for (String string : posList) {        \n                      // expecting format i,j \n                      int posI = Integer.parseInt(string.substring(0, 1)); \n                      int posJ = Integer.parseInt(string.substring(2, 3));                       \n                      ret[posI][posJ] = 'X'; \n      } \n                    } else { \n                        ret[i][j] = 'O'; \n                    } \n                } else { \n                    ret[i][j] = 'X'; \n                }                 \n            } \n        } \n         \n        return ret; \n    } \n     \n    public static boolean isSurroundedByX(List positionList, char[][] m, int i, int j) { \n        if (m == null || m.length == 0) { \n            return false; \n        } \n         \n        int rows = m.length; \n        int cols = m[0].length; \n         \n        // test boundary \n        if (i == 0 || i == rows - 1) { \n            return false; \n        } \n        if (j == 0 || j == cols - 1) { \n            return false; \n        } \n         \n        // check up,  \n        if (m[i - 1][j] == 'O' && !positionList.contains((i - 1) + \",\" + j)) {                   \n         positionList.add( (i - 1) + \",\" + j); \n         if (!isSurroundedByX(positionList, m, i - 1, j)) { \n          return false; \n         } \n        } \n        // check right \n        if (m[i][j + 1] == 'O' && !positionList.contains((i) + \",\" + (j + 1))) {         \n         positionList.add( (i) + \",\" + (j + 1) ); \n          \n         if (!isSurroundedByX(positionList, m, i, j + 1)) { \n          return false;  \n         }             \n        } \n        // check down \n        if (m[i + 1][j] == 'O' && !positionList.contains((i + 1) + \",\" + j)) { \n         positionList.add( (i + 1) + \",\" + j ); \n          \n         if (!isSurroundedByX(positionList, m, i + 1, j)) { \n          return false;  \n         } \n        } \n        // check left \n        if (m[i][j - 1] == 'O' && !positionList.contains(i + \",\" + (j - 1))) { \n         positionList.add( i + \",\" + (j - 1) ); \n          \n         if (!isSurroundedByX(positionList, m, i, j - 1)) { \n          return false;  \n         } \n        } \n        return true; \n    }  \n \n    public static void printMatrixResults(char[][] ret) { \n        int rows = ret.length; \n        int cols = ret[0].length; \n         \n        // print results \n        for (int i = 0; i < rows; i++) { \n            for (int j = 0; j < cols; j++) { \n                System.out.print(ret[i][j] + \" \");     \n            } \n            System.out.println(); \n        }      \n    } \n     \n    public static void runSampleTests() { \n     \n    /* \n     X X X X X  \n     X X O O X  \n     X X O O X  \n     O X X X X \n    */ \n     \n    char[][] m = new char[4][5]; \n     \n    m[0][0] = 'X'; \n    m[0][1] = 'X'; \n    m[0][2] = 'X'; \n    m[0][3] = 'X'; \n    m[0][4] = 'X'; \n \n    m[1][0] = 'X'; \n    m[1][1] = 'X'; \n    m[1][2] = 'O'; \n    m[1][3] = 'O'; \n    m[1][4] = 'X'; \n \n    m[2][0] = 'X'; \n    m[2][1] = 'X'; \n    m[2][2] = 'O'; \n    m[2][3] = 'O'; \n    m[2][4] = 'X'; \n \n    m[3][0] = 'O'; \n    m[3][1] = 'X'; \n    m[3][2] = 'X'; \n    m[3][3] = 'X'; \n    m[3][4] = 'X'; \n     \n    char[][] ret = fillMatrix0(m); \n    printMatrixResults(ret); \n \n    /* \n X X X X X  \n X X O O X  \n X X O O O  \n O X X X X \n*/ \n m = new char[4][5]; \n  \n m[0][0] = 'X'; \n m[0][1] = 'X'; \n m[0][2] = 'X'; \n m[0][3] = 'X'; \n m[0][4] = 'X'; \n  \n m[1][0] = 'X'; \n m[1][1] = 'X'; \n m[1][2] = 'O'; \n m[1][3] = 'O'; \n m[1][4] = 'X'; \n  \n m[2][0] = 'X'; \n m[2][1] = 'X'; \n m[2][2] = 'O'; \n m[2][3] = 'O'; \n m[2][4] = 'O'; \n  \n m[3][0] = 'O'; \n m[3][1] = 'X'; \n m[3][2] = 'X'; \n m[3][3] = 'X'; \n m[3][4] = 'X'; \n   \n char[][] ret1 = fillMatrix0(m); \n System.out.println(); \n printMatrixResults(ret1); \n    } \n     \n    public static void main(String args[]) { \n     runSampleTests(); \n    }     \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Pretty much the same approach as Westlake, written in Java."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class MatrixFill { \n \n static int N = 10; \n static int M = 11; \n static int order = 0; \n static char[][] matrix = new char[N][M]; \n \n public static void main(String[] args) { \n  matrix[0] = \"XXXXXXXXXXX\".toCharArray(); \n  matrix[1] = \"XXXXOOXXXXX\".toCharArray(); \n  matrix[2] = \"XXXXOOXXXXX\".toCharArray(); \n  matrix[3] = \"XXXXXXXXXXX\".toCharArray(); \n  matrix[4] = \"XXXXXXOXXXX\".toCharArray(); \n  matrix[5] = \"XXXXXXOXXXX\".toCharArray(); \n  matrix[6] = \"XXXXXXOXXXX\".toCharArray(); \n  matrix[7] = \"XXXXXXOXXXX\".toCharArray(); \n  matrix[8] = \"XXXXXXOOOOO\".toCharArray(); \n  matrix[9] = \"XXXXXXXXXXX\".toCharArray(); \n \n  printMatrix(); \n  substitute('O'); \n  compute(); \n  substitute('1', 'X'); \n  substitute('0', 'O'); \n  printMatrix(); \n } \n \n private static void printMatrix() { \n  System.out.println(order); \n  for (int i = 0; i < N; i++) { \n   System.out.println(String.valueOf(matrix[i], 0, M)); \n  } \n  System.out.println(); \n } \n \n private static void compute() { \n  boolean changed = true; \n  while (changed) { \n   printMatrix(); \n   order++; \n   changed = false; \n   for (int i = 0; i < N; i++) { \n    for (int j = 0; j < N; j++) { \n     if (matrix[i][j] != 'X') { \n      changed = computeCell(i, j) || changed; \n     } \n    } \n   } \n  } \n } \n \n private static boolean computeCell(int i, int j) { \n  char value = matrix[i][j]; \n  if (j > 0) { \n   matrix[i][j] = multiply(i, j, i, j - 1); \n  } \n  if (i > 0) { \n   matrix[i][j] = multiply(i, j, i - 1, j); \n  } \n  if (j < N - 1) { \n   matrix[i][j] = multiply(i, j, i, j + 1); \n  } \n  if (i < N - 1) { \n   matrix[i][j] = multiply(i, j, i + 1, j); \n  } \n  return value != matrix[i][j]; \n } \n \n private static char multiply(int i, int j, int x, int y) { \n  if (matrix[x][y] == 'X') \n   return matrix[i][j]; \n  return matrix[x][y] == '0' ? '0' : matrix[i][j]; \n } \n \n private static void substitute(char c) { \n  order++; \n  for (int i = 0; i < N; i++) { \n   for (int j = 0; j < N; j++) { \n    if (matrix[i][j] == c) { \n     if (i == 0 || i == N - 1 || j == 0 || j == N - 1) { \n      matrix[i][j] = '0'; \n     } else { \n      matrix[i][j] = '1'; \n     } \n    } \n   } \n  } \n } \n \n private static void substitute(char c, char d) { \n  order++; \n  for (int i = 0; i < N; i++) { \n   for (int j = 0; j < M; j++) { \n    if (matrix[i][j] == c) \n     matrix[i][j] = d; \n   } \n  } \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package misc; \n \npublic class MatrixFill { \n \n static int N = 10; \n static int M = 11; \n static int order = 0; \n static char[][] matrix = new char[N][M]; \n \n public static void main(String[] args) { \n  matrix[0] = \"XXXXXXXXXXX\".toCharArray(); \n  matrix[1] = \"XXXXOOXXXXX\".toCharArray(); \n  matrix[2] = \"XXXXXXXXXXX\".toCharArray(); \n  matrix[3] = \"XOXXXXOOOXX\".toCharArray(); \n  matrix[4] = \"XOOOXXXXOXX\".toCharArray(); \n  matrix[5] = \"XXXOXXXXOXX\".toCharArray(); \n  matrix[6] = \"XOOOXXOOOXX\".toCharArray(); \n  matrix[7] = \"XOXXXXXXXXX\".toCharArray(); \n  matrix[8] = \"XOOOOOOOOOO\".toCharArray(); \n  matrix[9] = \"XXXXXXXXXXX\".toCharArray(); \n \n  printMatrix(); \n  substitute('O'); \n  compute(); \n  substitute('1', 'X'); \n  substitute('0', 'O'); \n  printMatrix(); \n } \n \n private static void printMatrix() { \n  System.out.println(order); \n  for (int i = 0; i < N; i++) { \n   System.out.println(String.valueOf(matrix[i], 0, M)); \n  } \n  System.out.println(); \n } \n \n private static void compute() { \n  boolean changed = true; \n  while (changed) { \n   printMatrix(); \n   order++; \n   changed = false; \n   for (int i = 0; i < N; i++) { \n    for (int j = 0; j < M; j++) { \n     if (matrix[i][j] != 'X') { \n      changed = computeCell(i, j) || changed; \n     } \n    } \n   } \n  } \n } \n \n private static boolean computeCell(int i, int j) { \n  char value = matrix[i][j]; \n  int x, y; \n  for (x = i, y = j; y < M && matrix[x][y] != 'X'; y++) { \n   multiply(i, j, x, y); \n  } \n  for (x = i, y = j; y > 0 && matrix[x][y] != 'X'; y--) { \n   multiply(i, j, x, y); \n  } \n  for (x = i, y = j; x < N && matrix[x][y] != 'X'; x++) { \n   multiply(i, j, x, y); \n  } \n  for (x = i, y = j; x > 0 && matrix[x][y] != 'X'; x--) { \n   multiply(i, j, x, y); \n  } \n  return value != matrix[i][j]; \n } \n \n private static void multiply(int i, int j, int x, int y) { \n  if (matrix[x][y] != 'X') { \n   matrix[i][j] = matrix[x][y] == '0' ? '0' : matrix[i][j]; \n   matrix[x][y] = matrix[i][j] == '0' ? '0' : matrix[x][y]; \n  } \n } \n \n private static void substitute(char c) { \n  order++; \n  for (int i = 0; i < N; i++) { \n   for (int j = 0; j < M; j++) { \n    if (matrix[i][j] == c) { \n     if (i == 0 || i == N - 1 || j == 0 || j == M - 1) { \n      matrix[i][j] = '0'; \n     } else { \n      matrix[i][j] = '1'; \n     } \n    } \n   } \n  } \n } \n \n private static void substitute(char c, char d) { \n  order++; \n  for (int i = 0; i < N; i++) { \n   for (int j = 0; j < M; j++) { \n    if (matrix[i][j] == c) \n     matrix[i][j] = d; \n   } \n  } \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this can be done with a queue or stack.   - Scan through the array until you reach an O. Add this to a temporary array  - Look at the 8 locations around the O.  --- If any are blank space, return false --- If any are X, continue looking --- If any are O, add them to the queue and the temporary array then mark it as visited  - Then take the next O off the queue. If the queue is empty, return true  - If true, change the O's in the temporary array to X's  - Continue the search with the next unvisited O"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Dynamic Programming."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#include  \n#include  \n#include  \n \nbool replaceWithAndCheck(char replace, char fillchar, char **grid, int posy, int posx, int sizey, int sizex) \n{ \n  if(posy<0 || posx<0 || posy>=sizey || posx>=sizex) \n  { \n    return false; \n  } \n   \n  char *line=grid[posy]; \n  if(line[posx]!=replace) \n  { \n    return true; \n  } \n   \n  line[posx]=fillchar; \n   \n  if(!replaceWithAndCheck(replace,fillchar,grid,posy,posx+1,sizey,sizex)) return false; \n  if(!replaceWithAndCheck(replace,fillchar,grid,posy,posx-1,sizey,sizex)) return false; \n  if(!replaceWithAndCheck(replace,fillchar,grid,posy+1,posx,sizey,sizex)) return false; \n  return replaceWithAndCheck(replace,fillchar,grid,posy-1,posx,sizey,sizex); \n} \n \n \nvoid enclose_grid(char **grid, int sizey, int sizex) \n{ \n  for(int y=1; y"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6407924087783424","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"20","title":"Given an array of n elements (a1,a2,..ai,...,an). You are allow to chose any index i and j, such that (i!=j) and allow to perform increment operation on ai = ai+1 and decrements operation on aj = aj - 1 infinite number of times.  How many maximum number of elements you can find that have same number.  example 1: 1 4 1 ans: 3  example 2: 2 1  ans : 1","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"So following Subbu's solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"We can always to n-1 (pick a dummy which absorbs +1 and -1 to make the others equal).  The key question is whether we can do n."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) First you have to find a candidate to which ai and aj will be adjusted. To do this count numbers and choose number which appears most often. 2) Take one number which is smaller then the candidate ai and one which is bigger aj and increment/decrements them respectively.  3) The result is equal   candidate's number of occurrence + 2. There is one border condition when the candidate is the biggest number in the array which means that you cant find aj to decrement. In that case you have to check if 'candidate's number of occurrence' - 'numOfOccurr of the secend most frequent number' >=1. Otherwise change the candidate to the second most frequent number."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(nk) where k is the number of possible candidates"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First sort the numbers. If there are 2 numbers then the minimal move is A[1] - A[0] by settling down the final number to any value between A[1]  and A[0]. If there are 3 numbers, then the minimal move is A[3] - A[1]. by settling down the final number to A[2]. For N numbers the minimal moves is   (A[N-1]-A[0]) + (A[N-2]-A[1]) ..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"temp = (a1+a2+a3+.......+an)%n;  ans will be max(temp,n-temp)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think it is always able to make them equal except one case: # of elements are 2 and they are different. We know that we can make at least (n-1) elements equal. (a b c d .... -> a a (c-b) d .... -> a a a (d-(c-b)) ... something like this.) As a result, 1st~(n-1)-th elements are same, but the n-th element is different. Then, we can just increase/decrease 1st~(n-1)th elements until they are the value of the n-th element."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5144997544329216","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"Given an array of n elements (a1,a2,..ai,...,an). You can allow to chose any index i and j, such that (i!=j) and allow to perform  increment operation on ai = ai+1 and decrement operation on aj = aj-1 infinite number of times. How many number of elements you can find which have same numbers.  example 1: 1 4 1 ans: 3  example 2: 2 1  ans : 1","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if sum(a1,a2,..ai,...,an) % n ==0, return n else return n-1"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4877486110277632","download_status":"DOWNLOAD_DONE","votes":"-4","answersCount":"11","title":"Given a circle with N defined points and a point M outside the circle, find the point that is closest to M among the set of N. O(LogN)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"It looks like the question is directly copy pasted from Stackoverflow: h t tp:// stackoverflow. com/questions/14994179/given-a-circle-with-n-defined-points-and-a-point-m-outside-the-circle-find-the"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How the defined points stored? Are they clockwise or randomly stored? If it is randomly, I guess it's impossible to do this in O(logn) time. If it is clockwise of anticlockwise, this is a binary search problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What about this: (1)Get the line defined by the circle center O and the outside point P, then  we can get the diameter AOB on this line. Let's say the endpoint close to P is A, and the other is B. (2)Now all the N given points are in the circle defined by center P and radius PB, while no point is in the circle defined by center P and radius PA. (3)Binary search radius till we find a radius R with which the defined circle has only one given point."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Join the line from center of circle to the outside point. Now the point at minimum distance from M has the least angle with this line i.e. min(theta, 360 - theta) should be the least among all the points. If we assume points are in order clockwise/anti clockwise this breaks down to the problem of rotated array which is solvable in log(N)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's a verbal description of a logarithmic algorithm:  Let C be the center of the circle and let P be the point of intersection of the circle with the line segment joining C and M. Let N_i designate the ith point in the list of N points ordered counter-clockwise (we must assume they are given to us in an ordering like this), and let -pi <= A_i < pi be the the *signed* measure of the angle from P to N_i. Then the problem is reduced to finding the index i so that |A_i| is minimized.  Note that the list [ |A_1|, |A_2|, ..., |A_N| ] is cyclically sorted, i.e., it is either ascending and then descending or else it is descending and then ascending. We want to find the minimum element. This can be achieved in logarithmic time via a modification of binary search."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming the points are in order"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Idea: binary search for the smallest value Use distance directly.  Compute three values for the middle point: (1) if go down, choose the right half (2) if go up, choose the left half (3) if valley, return the answer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I guess, we can modify the closest pair of points algorithm  of complexity O(n logn) to run in (log n)."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5162732873580544","download_status":"DOWNLOAD_DONE","votes":"-6","answersCount":"17","title":"Given a preorder traversal, create a binary search tree in optimized time","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"You sure just given a preorder traversal is sufficient?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public class ConstructTreeFromPreorder { \n \n    static Node[] preOrderArray = new Node[6]; \n    static int count = 0; \n \n    public static Node constructTree(Node[] preOrder) { \n        Stack stack = new Stack(); \n \n        Node root = preOrder[0]; \n        Node tmp = null; \n \n        stack.push(root); \n \n        for(int i = 1;i < preOrder.length;i++) { \n            tmp = null; \n \n            while (!stack.empty() && stack.peek().value < preOrder[i].value) { \n                tmp = stack.pop(); \n            } \n \n            if(tmp != null) { \n                tmp.right = preOrder[i]; \n                stack.push(preOrder[i]); \n            }  else { \n                 if(!stack.empty()) { \n                     stack.peek().left = preOrder[i]; \n                     stack.push(stack.peek().left); \n                 } \n            } \n        } \n \n        return root; \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"node getBST(int[] a, int start, int end) \n{ \n if(start>end) \n  return null \n   \n node x = new node(a[start]); \n  \n int i=0; \n for(i=start+1;ia[start]) \n   break \n } \n  \n x.left = getBST(a, start+1, i-1); \n x.right = getBST(a, i, end); \n  \n return x; \n  \n} \n \ngetBST(a, 0, a.length-1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Since we are given a PRE-ORDER traversal, we know that the root node will be the first one that is traversed, then the left child and after that the right child.  so here, it doesnt even matter whether or not the list is sorted or not (which is will be since it is a preorder traversal of a BST which has the property that the left child < root < right child.  So, if the tree were like this"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Since we are given a PRE-ORDER traversal, we know that the root node will be the first one that is traversed, then the left child and after that the right child.  so here, it doesnt even matter whether or not the list is sorted or not (which is will be since it is a preorder traversal of a BST which has the property that the left child < root < right child.  So, if the tree were like this"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"In C++, with optimisation for inserting when the next item is less than the last item inserted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"it might work."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5765091433644032","download_status":"DOWNLOAD_DONE","votes":"-4","answersCount":"14","title":"Given a binary tree, how would you copy it from one machine to the other, assume you have a flash drive. I believe we should write the binary tree to file and have the other machine de-serialize it. But how should we do it?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Serialize the tree in an array.And then transfer the array ...deserialize it back .  for example                1    2                      4                5              6         7          8  you will store the above tree in an array starting at index 1 with left child at 2i and right child at 2i+1 and then deserialize the array back in the machine.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"get the in-order and pre-order traversals in a file and use the binary tree reconstruction algorithm. Complexity : O(n)+O(n) to write to a file and reconstruction O(n log n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A. What kind of machines are we talking about (Linux to Windows for example) B. Serializing in one language and deserializing in another will not work (Think Java and .NET) C. The best way (inefficient ofcourse) is to serialize a stream in XML. That way all objects will get serialized properly and any client can deserialize them.  With that in mind, I would propose the following algorithm: A. Write out the BST using in-order traversal to an XML file B. Add attributes to the XML file indicating what traversal is used  C. If security is of concern, add security parameters"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"__3__         /     \\     _2_        _1_    /       \\     /        \\                null   nullnull   null pre-order way encounter null then insert \"#\" ->:   32##1##  using this way you can make a tree into file, this String can reconstruct only tree you want, whatever you use pre-order way or in-order way."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What really is a binary tree containing? Is it just integers? if yes, then integers can be directly written to a file. If there are complex objects serialize them and write them into a file."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class MyTree implements Externalizable{ \nclass Node implements Serializable{...}//Assuming the memebr objects implement Serializable too \n    @Override \n    public void writeExternal(ObjectOutput out) throws IOException \n    { \n        out.writeObject(root); \n    } \n    @Override \n    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException \n    { \n        root = (Node)in.readObject(); \n    } \n}//MyTree \n \npublic static void storeRestoreTest(Node root) \n{ \n try{ \n//print the tree for testing \n            FileOutputStream fos = new FileOutputStream(\"TreeDatafile.XYZ\"); \n            ObjectOutputStream oos = new ObjectOutputStream(fos); \n            oos.writeObject(root); \n            oos.flush(); \n            oos.close(); \n  \n            MyBinaryTree btRead; \n            FileInputStream fis = new FileInputStream(\"TreeDatafile.XYZ\"); \n            ObjectInputStream ois = new ObjectInputStream(fis); \n            btRead = (MyBinaryTree) ois.readObject(); \n            ois.close(); \n//print the new tree \n } catch (Exception ex) \n        { \n            ex.printStackTrace(); \n        } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"GZ/Kevin/whatever.  Please stop posting questions you were not asked."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4847954317803520","download_status":"DOWNLOAD_DONE","votes":"-8","answersCount":"5","title":"largest number that an int variable can fit given a memory of certain size","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"2^(n - 1) - 1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assume the size of int is n (bits), the largest number that can fit there is 2^(n) - 1."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5692127791022080","download_status":"DOWNLOAD_DONE","votes":"-5","answersCount":"3","title":"Implement a class to create timer object in OOP","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class MyTimer { \n \n        private volatile Long startTime; \n        private volatile Long endTime;   \n \n        public void start() { \n            startTime = System.currentTimeMillis(); \n        }    \n \n \n        public void stop() { \n            endTime = System.currentTimeMillis(); \n        } \n \n        public Long duration() { \n            if (startTime == null || endTime == null) \n                return null; \n             \n            return (endTime - startTime); \n        } \n \n        public Long durationInSec() { \n            Long d = duration(); \n \n            if (d == null) \n                return null; \n             \n            return ( d/1000 ); \n        } \n \n        public Long durationInMins() { \n            Long d = durationInSec(); \n             \n            if (d == null) \n            return null; \n \n            return ( d/60 ); \n        } \n \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Timer { \n \n     \n    private static final ThreadLocal context = new ThreadLocal(); \n \n    // it will start the timer  \n    void static start(){ \n        long start = System.currentmillies(); \n        context.set(start); \n    } \n     \n    // it will stop and return the duraton \n    long  static stop(){ \n        long end = System.currentmillies(); \n        long start = context.get(); \n        return end-start;  \n    } \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6331648220069888","download_status":"DOWNLOAD_DONE","votes":"-7","answersCount":"2","title":"What's the tracking algorithm of nearest location to some friends that are located in a grid region?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"weighted quick-union algorithm is best to find if 2 nodes are connected. with weighted I hope it is also a good option to find the shortest path.  You always connect the smaller tree to the larger tree keeping the height of the tree no more than lg of n."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using quick select you can take the median of the x coordinates and the y coordinates. the target function is sum i from friend 1 to friend n  |friend i x corrdinate -X| + | friend i y coordinate - Y| we need to find X,Y that minimize it. and obviosly we get this from the median element from x coordinate list and y coordinate list."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5377673471721472","download_status":"DOWNLOAD_DONE","votes":"-4","answersCount":"6","title":"How would you split a search query across multiple machines?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Strategy of splitting a search query across multiple machines would depend on the type of distributed index maintained by the machines.  Typically for large scaled index, the architecture be, there will be set of master index servers 1 to n that index documents from the crawler. Index is maintained across all these servers.  For every index master server, there will be multiple (1 to m) slave servers with replicated indexes. These slave servers will handle queries.  Now typically a query analyzer will receive query fired from the browser. Query analyzer will split the query into multiple sub queries as follows: So if the query is like \"Google Mountain view jobs\" Sub queries: 1. complete query: \"Google Mountain view jobs\" 2. boolean query: \"Google AND Mountain AND view AND jobs\" 3. Distance / Proximity query: (Google Mountain) AND (Mountain view) AND (View jobs) AND (Google Mountain View) AND (Mountain View Jobs) 4 .Single word queries: Google, Mountain, view, Jobs  Typically there will be another fuzzy query analyzer which will re-issue single word queries as fuzzy queries  5. Single word fuzzy queries: Google~, Mountain~, view~, jobs~ 6. Range Query: if the search term includes a date range, regular expressions will pickup the date range and create a date range query.  Once all the queries are finalized, the queries are fired across multiple shards (slave servers) in parallel.  Now this could be done using Publish Subscribe Messaging model or by directly firing query across multiple slave server using software or hardware load balanced way.  All the servers will receive one query each and will come up with the matching document result with the type weight (vector like structure) and count weight (no of word counts matched in the document).  Based on their individual weights, a dot product will be calculated to compute an IR score.Also a page rank score is calculated based on the search result page weight. (example: if the search resulted in wikipedia.org page then this result will have heigher value than mamapapa.com page which happens to have same searched terms)   Multiple results will be combined together based on their weight rank and page rank and first K results will be sent back to the server caching the complete result in the cache servers so that if the user clicks on page 2 of the result, the result can be sent back form the cache server than to compute the result all over again."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if we are dealing with boolean search query we can store different sets of documents on different machines, and do the intersect of the results from each machine.  for example if we shard our documents to 1 machine having a-h, 2 machine i-o , 3  machine p-z  and we get a search query like \"number of employees at google today\" employees, at google -> machine 1 number, of -> machine 2 today -> machine 3  if we store the documents on inverted index for each word, for example employees -> doc1, doc3, doc5 at -> doc1, doc2, doc3, doc4, doc 5 google -> doc1  doc5 do machine 1 will return doc1, doc5 and intersect it with the result of the other machines."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if we are dealing with boolean search query we can store different sets of documents on different machines, and do the intersect of the results from each machine.  for example if we shard our documents to 1 machine having a-h, 2 machine i-o , 3  machine p-z  and we get a search query like \"number of employees at google today\" employees, at google -> machine 1 number, of -> machine 2 today -> machine 3  if we store the documents on inverted index for each word, for example employees -> doc1, doc3, doc5 at -> doc1, doc2, doc3, doc4, doc 5 google -> doc1  doc5 do machine 1 will return doc1, doc5 and intersect it with the result of the other machines."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if we are dealing with boolean search query we can store different sets of documents on different machines, and do the intersect of the results from each machine.  for example if we shard our documents to 1 machine having a-h, 2 machine i-o , 3  machine p-z  and we get a search query like \"number of employees at google today\" employees, at google -> machine 1 number, of -> machine 2 today -> machine 3  if we store the documents on inverted index for each word, for example employees -> doc1, doc3, doc5 at -> doc1, doc2, doc3, doc4, doc 5 google -> doc1  doc5 do machine 1 will return doc1, doc5 and intersect it with the result of the other machines."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if we are dealing with boolean search query we can store different sets of documents on different machines, and do the intersect of the results from each machine.  for example if we shard our documents to 1 machine having a-h, 2 machine i-o , 3  machine p-z  and we get a search query like \"number of employees at google today\" employees, at google -> machine 1 number, of -> machine 2 today -> machine 3  if we store the documents on inverted index for each word, for example employees -> doc1, doc3, doc5 at -> doc1, doc2, doc3, doc4, doc 5 google -> doc1  doc5 do machine 1 will return doc1, doc5 and intersect it with the result of the other machines."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if we are dealing with boolean search query we can store different sets of documents on different machines, and do the intersect of the results from each machine.  for example if we shard our documents to 1 machine having a-h, 2 machine i-o , 3  machine p-z  and we get a search query like \"number of employees at google today\" employees, at google -> machine 1 number, of -> machine 2 today -> machine 3  if we store the documents on inverted index for each word, for example employees -> doc1, doc3, doc5 at -> doc1, doc2, doc3, doc4, doc 5 google -> doc1  doc5 do machine 1 will return doc1, doc5 and intersect it with the result of the other machines."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6544254671257600","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"def inc:    while True:        v = v + 1  //---A      set(s)       // ---B  def disp:    while True:       wait(s)      //---C        print v    //----D  print all possible value, which is shared value. At the begin , v = 0  s is binary semophore. initial value is 0","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This results in undefined behavior in c++ if v is not an atomic variable (I am assuming that we have two threads here one calling inc and another calling disp). Thread 1 will set v to 1 and then signal s. Thread 2 then can get to line D to print v,  but at the same time Thread 1 goes back to line A and tries to increment v. Since we are reading and writing v at the same time, the printed value can be any number (since the read might happen before, after or in the middle of writing).  If v is an atomic variable, then the read and write can happen in any order. So the first printed value can be either 1 or 2, the next will be 2 or 3 and so on."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5424071030341632","download_status":"DOWNLOAD_DONE","votes":"-6","answersCount":"25","title":"Given a list of strings. Produce a list of the longest common suffixes. If it asks for longest common substring, then building a suffix tree should be the way to go. But how should we implement this if it is for longest common suffixes?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Build a Trie Tree for all the strings with reverse order, find the longest common internal node T. Then from root to T, the output is the longest common suffix."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Oh, I think we'd still build a suffix tree, and mark each node as endOfWord if it is the last character of the string. Then the node sequence that contains all strings with endOfWord marked would be the answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Reverse all the strings and find the longest common prefix ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. reversed all words 2. sort these reversed strings 3. from the neighboring two words, find the longest prefix 4. reversed the obtained prefixes and update the results"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"I thought careercup was really helpful. At least for google. Haven't used glassdoor a lot. But my phone interview question (given grid of A,B,C,D...Z. output arrow sequence for a given word) was in careercup and practicing the questions here gave me a lot of confidence and exposed me to great approaches of solving google interview questions. So, I consider careercup really helpful. I had a phone interview with Twitter last week and one with LinkedIn coming up. I am relying completely on careercup questions. Looking at leetcode and a little bit of glassdoor too because careercup doesnt have a lot of twitter questions."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"I was asked this question at Google. I had been asked 2 other questions in that interview so we just had time for a pseudo code. I gave the solution that @Cyanny has given. He said \"Are you missing something?\" and smiled. I looked at the whiteboard for a minute and said, \"Oh, yes\" and smiled back. A minor detail. At each step, just delete the branches of the trie that don't you are not matching/traversing. Delete all such successor nodes in the current path as well. That's clearly what @Cyanny means as well, but I just thought I'd call it out clearly. And moreover, cz I was asked this same question in my interview as well :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"I was asked this question at Google. I had been asked 2 other questions in that interview so we just had time for a pseudo code. I gave the solution that @Cyanny has given. He said \"Are you missing something?\" and smiled. I looked at the whiteboard for a minute and said, \"Oh, yes\" and smiled back. A minor detail. At each step, just delete the branches of the trie that you are not matching/traversing. Delete all such successor nodes in the current path as well. That's clearly what @Cyanny means as well, but I just thought I'd call it out clearly. And moreover, cz I was asked this same question in my interview as well :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"Friend, I am really sorry about this. This was not the question I was asked. I was solving something else altogether. I am an idiot. Please down vote or delete this comment. I am not sure what I was thinking. I have not been able to delete it myself.  My interview was in September '13. It was for an SET position. As you can say, I did not get selected. Not for that position anyway. I was offered a test engineer position.  I don't remember clearly, but I think my question was something on the lines of - given a list of strings, find the longest common substring. I never really came back home and saw how that's supposed to be solved, but in the interview I basically just did whatever the heck came to my mind. I created a trie of all the suffixes of the first string. I did some matching and deleting of unmatched nodes at each step. But now when I look at it, it doesn't make total sense to me. Since I remember that the interviewer had agreed with me and expressed that verbally. So, that leads me to believing that I am not recalling something correctly. In this interview, the first question was about one of my projects. The second was a warmup question. That's all I can recall.  I apologize again. Just been doing these questions for 6 hours now preparing for another interview, so, I have become very confused now. Need a break.  Some questions I remember are - the first interviewer has asked me a question about having a set of boxes each with an infinite supply of stamps of a given denomination, write a program to - given an amount select stamps that sum up to the amount or more than it but as little more than it as possible. There was one question where I was asked to print values from a BST in an order x1x3x5..., etc. These are random questions that come to my mind from the interview. I remember some interviews had multiple short questions and some had one big and one short question, etc.  Since it was for SET, I was also asked to come up with test scenarios.  I will post if I remember more questions. I had thought about posting my questions right after the interview but I felt they were covered here already. Esp. cz they were SET interview questions."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5438941951950848","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"3","title":"Given a kernal code in \"0\"th machine. How soon you can replicate the kernal across N machines. Now if the machines has upload and download bandwidth constraints, how can you impove the copy time.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"This question has been discussed multiple times, without bandwidth constraints a 'torrent-like' architecture would work (while one machine is downloading it can simultaneously upload part of the kernel to other machines).   If bandwidth is limited, then file can be split into chunks and sent accordingly, an interesting paper by microsoft research about how to handle the details: hxxp://research.microsoft.com/pubs/64692/tr-2006-157.pdf"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Won't this depend on the topology of the network?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5680330589601792","download_status":"DOWNLOAD_DONE","votes":"-5","answersCount":"17","title":"If you have data coming in rapid succession what is the best way of dealing with redundant data?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"The question is fucking vague."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about developing a hash table, if the key produced by hash function for the input data is same, then compare the entry thats pointed to by the key and if similar either remove it or increase the count depending on the requirement..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if we don't have to keep track of the count of each number then use a bitmap"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What do they want to do with the redundant data? Do we want to gather stats? Or making sure no dups?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"When you say rapid succession, could we take incoming \"tweet\" data as an example? Another fact that needs to be cleared is : How important is the data ? Can we compromise losing a little bit of data in order to implement a  faster way of checking data redundancy?   As of today there are various ways to deduplicate data:  File-level: file-level data deduplication compares a file to an archived file by checking its attributes against an index. If the file is unique, it is stored and the index is updated; if not, only a pointer to an existing file is stored.   Block-level Block-level data deduplication operates on the sub-file level. The file is broken down into chunks or blocks ,these are examined for redundancy with respect to previously stored information.  From these two, if you are looking for computational efficiency, You would go for file level as the indexes are smaller in comparison to a block level deduplication.  The latest deduplication techniques automate the process of hunting down multiple files at a very granular level and apply specialized compression algorithms to what remains to shrink your data even further.  You can also read up on content aware de-dupe."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If all the data is to be checked and stored for redundancy, use multiple threads to process the incoming data, then push the data on multiple queues. Have a distributed hashtable to check and store newer values and maybe a count (if needed). I agree though it is a really vague question"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If all the data is to be checked and stored for redundancy, use multiple threads to process the incoming data, then push the data on multiple queues. Have a distributed hashtable to check and store newer values and maybe a count (if needed). I agree though it is a really vague question."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since this problem is within an interview context, I believe the answer should be something as simple as hashing the data and seeing if the hash has been seen before. The trick is that hashing once wouldn't be enough because of collisions, so hashing a few times with different hash functions would be necessary; see Bloom Filters."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since this problem is within an interview context, I believe the answer should be something as simple as hashing the data and seeing if the hash has been seen before. The trick is that hashing once wouldn't be enough because of collisions, so hashing a few times with different hash functions would be necessary; see Bloom Filters."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question is probably intentionally vague. Here we don't have access to the interviewer here to ask questions so we should make our own assumptions. If the range of the incoming data is small then we can fit all the hash table in memory and the solution is pretty trivial. But if the range is very big (like finding duplicate incoming images in imgur), we need a huge hash table to minimize collisions and we need to also think about how to map the data to a hash key. In this case the hash table might no longer fit in the memory or even in the same machine. Another important question to ask if duplicates happen often or rarely. If the answer is rarely then we can use bloom filters to check very quickly whether the incoming data is not present in our database (bloom filters are 100% accurate when they determine a data is not present in the set, otherwise we have to go to database to check for the answer)."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5085331422445568","download_status":"DOWNLOAD_DONE","votes":"-5","answersCount":"6","title":"How would you use Dijkstra's algorithm to solve travel salesman problem, which is to find a shortest path from a starting node back to the starting node and visits all other node exactly once.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You would not use Dijkstra's algorithm to solve the traveling salesman problem. Dijkstra's algorithm solves the single-source shortest path problem which gives the shortest path to each node from a singular starting node. Dijkstra's algorithm would be useful if it was necessary to go to each city and return back to the start after each trip.  You could, from the start node, determine the next shortest path to another node, i.e. the next closest node (taking care to not visit any nodes that had previously been visited), and continue this for each node until back to the start, but the simple greedy algorithm does not guarantee that you will get the overall shortest path from start to finish (and back to start)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do we use a combination of Dijkstras and Minimum Spanning Tree using Prims?, use Minimum Spanning Tree to go through all the nodes once, after that use Dijkstras to come back to the start node from the end node?, this might not be the best shortest path around, but an approximation of shortest path around."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can use Dijkstra for TSP graph where each edges only visit vertices once. For example, A->B->C->D->A. Or even if there's an additional edge from B->D but the weight is bigger than A->D.  I think it's not possible to use Dijkstra for any graph since Dijkstra complexity is E+VLogV, and TSP is NP."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6577142510911488","download_status":"DOWNLOAD_DONE","votes":"-4","answersCount":"13","title":"How does trie handle scalability as opposed to hashtable? Assuming it is used for a dictionary. Sclability here should cover large size of input, running out of memory, or even running out of memory on multiple machines if distributed system is used.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A trie stores only one 'instance' of a common prefix of several strings. Thus it saves memory that is consumed by 'common' prefixes of strings."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Implicit in your question is the premise that a hash table somehow handles running out of memory. A trie handles this the same way a hash table does -- it doesn't."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"When is your interview KevinLane aka Karin-Answer?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can easily distribute hash table into hundreds/thousands machines by assigning each machine a key range. Each machine will know what other machine is responsible for the give key. So any key can be looked up with at most two machine forwards.  You cannot easily distribute Trie, since there is no easy way of splitting data and looking up efficiently.  If you want to specify range by first letter, then you have only 26 options (assuming only letters) and it doesn't handle cases when data fits only in thousands machines.  You may have to use first 10 letters to locate a machine, then each machine has to keep this big machine table in memory which further reduces memory availability."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5481743482093568","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"12","title":"You have two sorted list. Write code for returning the first k elements. K may be a large number like 10 million.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use 'merge' subroutine of mergesort."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If you don't care about whether the returned numbers are in order (which the problem doesn't ask for) I think you can get a log(k) solution by using a form of binary search to decide how many numbers from each list you want. Start by looking at the k/2 element from each list. Whichever one is smaller, switch to the k/4 element of that list and the 3k/4 of the other list. Then, depending on which of these is smaller, add k/8 to one side and subtract k/8 from the other. Once 2^n is more than k, you can stop and the position of the pointers will tell you how many numbers to return from each list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"var getFirstKElements = function (arr1, arr2, k) { \n    var result = []; \n    for (var i = 0; i < k; i++) { \n        if (arr1[0] < arr2[0]) { \n            result.push(arr1.shift()); \n        } \n        else{ \n            result.push(arr2.shift());    \n        } \n    } \n    return result; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Time Complexity O(n) where n ==length of 1st N values to return"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"pseudo code"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5908384326877184","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"33","title":"You have a lists with integers. Find all the pairs of numbers that sum less than or equal to to a particular number k. The list contains minimum 5 Million number.  (I provided a n^2logn solution but they may be looking forward to having a better answer).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Approach:   1). QuickSort the list 2). Find out the max position (say p) where it's just less than or equal to K 3). Loop through the list starting at (P) backward.  Find the difference between the current indexed number and K (say q).  Use binary search to find the max (say t) position of q.  Then combine everything below t and p to add to the answer set.  Sample data:    List:  1, 3, 5, 9, 20, 28, 30, 37, 60, 100 K:  50   So, the max position of p is at 37.   Now, we loop through the list backward,  37 +30 <= 50?  No.  37 + 28 <= 50? No.  37 + 20 <= 50?  No.  37 + 9 <= 50?  Yes.  Then combine everything below 9 and 37.  pseudo code:   quicksort(list)    int p = binarysearch_max_position(k, list.length)  // p is the max position where it's just less than or equal to k in the list   for (i=p; i>=0; i--) [        x = list(i);     d = k - x;     // d is the difference in between k and x        j = binarysearch_max_position_helper(d,i)    // find the max position where j can exist    // since everything below j is less than j    // that it means position [0 to j] can be     // added to x and still be less than or equal    // to k     (if j != -1) {       all_combination_generator(j,i);         }   }   private void all_combination_generator(int i, int j) {      for (int x = i; x>=0; x--) {        answerset.add(j,list[x]);      }  }   Is this o(nlogn)?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Scan all elements and store all elements <= k in an array A  O(n) 2) Sort this array. Let the total elements be e  O(e*loge) in descending order 3) For i from 1 to e/2  d = k-A[i] Do a binary search in this array to find the position of d. Output pairs A[i] and all A[j<=d]  Total complexity O(n) + O(e*loge)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You mean it is a list? If it is a list, you can't quicksort it, don't you? Only mergesort may apply. But still it is not random access. So if it is a list, either use map(this will be O(n),O(n)) or use loop(O(n^2),O(1))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how about a modified version of a count sort where n is the number of records, and a is the array, if we assume that 0 <= a[0:n] <= m, we allocate a new array b of size m that stores the sorted array, and a Hash Set of capacity m that stores an ADT called Solution,  The Solution ADT is a pair of integers, a and b, the idea is that a + b <= k, and more solutions can be from the fact that all Solution(a, 0...b) and Solution(0...b) are also solutions  At the end we will have a Set of Solutions   pseudocode:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Will you let me know what exactly the array j is containing.. and what are you trying to decrease with j--?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think it can be done in O(n^2)  Iterate through the array and keep on creating the set with that number in case its lesser than k and also check that number against all the existing sets to see if that satisfies the criteria."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can we use hashmap here? like we can scan the list for numbers less than or equal to k and store it in hashmap (n, k-n). After putting all the elements we can just scan through the hash map and for each key, we will just have to check if the value is present in the key set. If yes then consider that to be the pair and continue with other keys."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include  using namespace std;    int main()  {      int a[] = {3, 1, 4, 2, 9, 10, 33, 42, 2, 0, 6};     int N = sizeof(a) / sizeof(*a);     sort(a, a + N);     for(int x=0 ;x    {                  cout<< a[x]<<\" , \";             }             cout<                      int K = 12;     int i = 0;     int *t = std::upper_bound(a, a + N, K - a[0]);     int j = t-a-1;     cout<< *t << \" \"<< *a<<\"   \"<<<\" \"<     while (i < j) {         for (int k = i + 1; k <= j; k++)              cout << \"(\" << a[i] << \", \" <        i++;         while (a[i] + a[j] > K && i < j) {             j--;         } }system(\"pause\");    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Why do we need O(n^2log(n)) to solve this ??   Even the brute force solution, where we simply produce all the pairs and check if their sum is  I don't believe that we can solve this problem in anything less than O(n^2) because in worst case sum of elements for all the pairs will be  \n   \n    \n   -  \n     Aritra \n     on February 05, 2014 Edit | Flag  \n    \n    \n   Reply"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"1) Sort the list first. 2) Using binary search find last number which is not bigger then k. Lets say this number is located at position 'p'. 3) Create to pointer which initially are at the following positions:   - start = 0   - end = p 4) Check following conditions: pseudo code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"int a[] = {3, 1, 4, 2, 9, 10, 33, 42, 2, 0, 6}; \n    int N = sizeof(a) / sizeof(*a); \n     \n    sort(a, a + N); \n    int K = 12; \n    int i = 0; \n    int *t = std::upper_bound(a, a + N, K - a[0]); \n    int j = t - a - 1; \n \n    while (i < j) { \n        for (int k = i + 1; k <= j; k++)  \n            cout << \"(\" << a[i] << \", \" < K && i < j) { \n            j--; \n        } \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"My algorithm is as follows: First of all, I assume the integers in the array and K are nonnegative numbers. I use a hash table to store numbers as a key and the count of that number as a value.  PseudoCode"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5975394641510400","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"21","title":"Implement a sudoku solution verifier function. ?The rules for sudoku is this:  You have a 9 by 9 board. ?This board is divided into nine rows, nine columns, and nine 3x3 blocks. ?In a solved puzzle, every row, every column, and every 0 block has to contain each of the digits from 1 to 9. ?This is an example of a solved puzzle:","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Oups/ I forgot to validate values from 0 to 9.  not big deal to fix that. Sorry about that.  Additional to that,  I could have fix the size of each hashtable to  10, to save some memory as well."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since we know the there are only 9 numbers, we do not need to use hash table. An array is enough."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public bool SudoKuVerfier(int[,] ip)         {             int i = 0;             int j = 0;             int m = 0;             int rowlen = ip.GetLength(0);             int collen = ip.GetLength(1);             List lst = new List();             while (i < rowlen && j < collen)             {                 if (i > 0)                 {                     m = i - 1;                     while (m >= 0)                     {                         if (!lst.Contains(ip[m, j]))                         {                             lst.Add(ip[m, j]);                         }                         else                         {                             return false;                         }                         m--;                     }                     m = i;                     while (m < rowlen)                     {                         if (!lst.Contains(ip[m, j]))                         {                             lst.Add(ip[m, j]);                         }                         else                         { return false; }                         m++;                     }                     m = 0;                     lst.Clear();                  }                 if (j > 0)                 {                     m = j - 1;                     while (m >= 0)                     {                         if (!lst.Contains(ip[i, m]))                         {                             lst.Add(ip[i, m]);                         }                         else { return false; }                         m--;                     }                     m = j;                     while (m < collen)                     {                         if (!lst.Contains(ip[i, m]))                         {                             lst.Add(ip[i, m]);                         }                         else { return false; }                         m++;                     }                     m = 0;                     lst.Clear();                 }                 i++;                 j++;              }             return true;         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Create one long string initialized with null characters. The first 81 characters represent 9 rows. The next 81 characters represent 9 columns and the last 81 characters represent the 9 3X3 cubes.  As we read in each digit we populate the three locations in the string. The expectation is that at the end of input the string will be filled with X.  If it isn't completely filled then the solution is not valid."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this solution will be much easier and simpler.   As the formula to find the sum of consecutive n numbers is [(n(n + 1) )/ 2]  the sum of numbers from 1 to 9 is 45.  So in my approach I add each of the n rows and check if the sum is less than 45 or not if there is a row whose sum is less that 45 than the algorithm stops and I output the row number as the error row if all the rows add upto 45 then I add each of the columns separately if the sum is less than 45 you stop and return with the column number (or false as exit status) else if all the columns also add upto 45 then exit as null (or true as success).  In addition to this, we can further enhance the solution as follows so that any malicious user can't  enter fake numbers to add them to 45 and pass the check.   1.) If we find a row or a column whose sum is less than 45 or more than 45 then we can iterate through the elements of the array and find out the missing/duplicated element.  2.) if all the rows and columns add upto 45, then we can use this approach:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I got little stuck at the interview and I couldn't get the right answer.  After I hang out the phone, my mind just relaxed and cleared out and the solution just came to my mind and I could code it in 10-15min ....  Too late I think.  Recomendation:  Take a deep breath, relax and DO NOT GET NERVOUS!!!  Interviews are not that hard ( when you prepare )"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I have a simpler solution, create 2 x 9 strings one per row and one per column  e.g. for the given suduko  first row will become \"248395716\" first column string will be \"259637814\"  Once we have these strings, we need to prove that these strings are anagrams of \"123456789\"  For that simply sort these strings and compare them against \"123456789\", if all of them matches we have a valid solution.  I believe that we don't need to verify the box constraints, row and column should take care of it indirectly."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"My solution is to check sum of all rows, all columns, all 3*3 block to match 45. If one of them did not match , then the solution is wrong."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"My approach was to add each value to a row and column to a set for each row and column. If the set has 9 elements for each row and column then it is correctly formed. Otherwise there is duplication which will return fewer items for a particular row or column and it won't validate."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"My approach was to add each value to a row and column to a set for each row and column. If the set has 9 elements for each row and column then it is correctly formed. Otherwise there is duplication which will return fewer items for a particular row or column and it won't validate."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5182360605687808","download_status":"DOWNLOAD_DONE","votes":"-5","answersCount":"29","title":"sort the array so that the odd number in front of the even number and their relative order doesn't change in Time O(n) and Space O(1). I believe quickselect can do this, but it would change the relative input order.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This question seems really fishy. To solve this you need to have read the paper \"STABLE MINIMUM SPACE PARTITIONING IN LINEAR TIME\" before the interview. If the space wasn't a problem you could simple use a Radix Sort and have the result in O(N) time and O(N) space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I suppose we can solve it in this way: (1)Go through the array and find how many odd numbers there are, say it's oddNum. (2)If oddNum == 0 || oddNum == arr.length then sort is done. (3)Else now we know that all odd numbers will be arr[0] to arr[oddNum-1] and all even numbers will be arr[oddNum] to arr[arr.length-1]. Thus we can go through the array again and at the same time put all the odd numbers into [0, oddNum) and all the even numbers into [oddNum, arr.length)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"\"\"\" \nsort the array so that the odd number in front of the even number and their relative order doesn't change in Time O(n) and Space O(1). I believe quickselect can do this, but it would change the relative input order. \n\"\"\" \ninput = [1, 2, 3, 4, 5, 6, 7, 8] \ni = 0 \nj = i + 1 \nlength = len(input) \n \nwhile(j < length): \n  if(input[i] % 2 == 0 and input[j] % 2 == 1): \n    temp = input[i] \n    input[i] = input[j] \n    input[j] = temp \n \n  while(i < length-1 and input[i] % 2 != 0): \n    i += 1 \n  while(j < length and input[j] % 2 != 1): \n    j += 1 \n \nprint input"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"could someone give an example input and output array?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int i = 0; \n  for(int j = 0; j<10; j++){ \n   if (a[i]%2 ==1){ \n    i++; \n   } else if(a[j]%2==1){ \n    swap(i,j); \n    i++;    \n   } \n   else continue; \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Going from left to right can preserve the relative order."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This problem can indeed be solved in O(n) time complexity and O(1) space complexity.  Think of the array as contiguous streaks of even and odd numbers: [o_lead, e1, o1, e2, o2, e3, o3, ...].   Each streak can have any amount of numbers in it.   We can ignore the leading streak of odd numbers o_lead (if any) because they are already in the sorted position.   Now we need to find a solution to sort each [ei, oi] pair of even streak followed by an odd streak.   After sorting the [ei, oi] pair we get [oi, ei] -- essentially swap/switch the locations of the even and odd streaks.   To do this, do the following steps   -- Reverse ei to get rev(ei)  -- Reverse oi to get rev(oi)  -- Reverse [ rev(ei), rev(oi) ] to get [ rev(rev(oi)), rev(rev(ei)) ] which is equal to [oi, ei]  -- Now the array will be [already-sorted-stuff, oi, ei, ei+1, oi+1, ...]. Now merge ei into ei+1.   This is very similar to reversing all the words within a sentence (not the whole sentence)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) { \n  ArrayList input = new ArrayList(); \n  input.add(2); \n  input.add(1); \n  input.add(3); \n  input.add(2); \n  input.add(4); \n  input.add(6); \n  input.add(8); \n  input.add(4); \n  input.add(2); \n  input.add(1); \n  input.add(5); \n  input.add(4); \n  input.add(5); \n  input.add(4); \n   \n   \n  System.out.println(input); \n   \n  int i = 0, j=0; \n  int k = 0; \n  int temp; \n  int arrayLength = input.size(); \n   \n  System.out.println(\"Array length : \" + arrayLength); \n  boolean check = false; \n  while(i < input.size()){ \n   \n   Integer t = input.get(i); \n   if(t%2 == 0 && !check){ \n    if(arrayLength ==  input.size()){ \n     temp = t; \n     j = i; \n     input.add(t); \n     check = true; \n    } \n     \n   } else if (t%2 == 1){ \n    System.out.println(\"Odd ball\"); \n    if(check){ \n     input.set(j, t); \n     input.set(i, input.get(input.size() - 1)); \n     input.remove(input.size() - 1); \n     evenSwap(input, j+1 ,i); \n     i = j; \n     j = 0; \n      \n     check = false; \n       \n    } \n   } \n    \n   i++; \n  } \n  if(arrayLength + 1 ==  input.size()){ \n   if(check){ \n    input.remove(arrayLength); \n   } \n  } \n  System.out.println(\"Over all output :\" + input); \n \n } \n  \n public static void evenSwap(ArrayList array, int i, int j){ \n   \n  boolean cont = true; \n  System.out.println(\"Input :\" + array); \n  while(cont){ \n   if(i == j){ \n    cont = false; \n   } else { \n    Integer temp = array.get(i); \n    array.set(i, array.get(j)); \n    array.set(j, temp); \n   } \n   i++; \n    \n    \n  } \n  System.out.println(\"Output : \" + array); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hello there, the code below seems to work ( passes the test cases that i could conjure) but neverthless it is not O(n) vis-a-vis runtime."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"basically we can introduce some count count1 = 0. keep track of # even visited count2 = 0. keep track of first even will need to start to swap if(array[0] %2 ==0){  swap (array[0],array[1]); } for (int i =1 ; i< array.size; i++){   if(array[i]%2 = =0 && array[i-1]%2 == 1){   //case even pre odd   if(count1 == 0){    count2 = i;   }   count1 ++;  } else if(array[i]%2 = =1 && array[i-1]%2 == 2){   //swap the odd with the first occurred even    swap(array[i],array[count2 + count1]);    count1 --;  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \nusing namespace std; \n \nvoid putOddInFrontOfEven(int a[], int n) \n{ \n    int i = 0; \n    //skip continuous odd numbers at front \n    for(; i < n && (a[i] & 1); ++i) ; \n \n    while(i < n){ \n        //now a[i] is an even number \n        int evenStart = i; \n        for(; i < n && (a[i] & 1) == 0; ++i) ; \n        if(i == n) break; \n \n        //now a[i] is an odd number \n        int oddStart = i; \n        for(; i < n && (a[i] & 1); ++i) ; \n \n        //put those odd numbers in front of those even numbers \n        reverse(a + evenStart, a + oddStart); \n        reverse(a + oddStart,  a + i); \n        reverse(a + evenStart, a + i); \n    } \n} \n \nint main() \n{ \n    int a[] = {2, 1, 5, 3}, n = sizeof(a)/sizeof(a[0]), i; \n \n    cout << \"Initially:\\n\"; \n    for(i = 0; i < n; ++i) cout << a[i] << \" \"; \n \n    putOddInFrontOfEven(a, n); \n \n    cout << \"\\nAfter putting odd numbers in front:\\n\"; \n    for(i = 0; i < n; ++i) cout << a[i] << \" \"; \n \n    return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void Resort(int* a,int n) \n{//find the leftmost even \n int left=0; \n while(a[left]%2==1 && left =0) \n    {right--;} \n if(right<0){return;}//all even \n while(left=0) \n         {right--;} \n     if(right<0){return;} \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Test the code below, it is O(n), memory usage O(1). Cheers!!!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Go through the array and maintain the last even index. Whenever you encounter and odd number, swap the number with the number at last even index"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Go through the array and maintain the last even index. Whenever you encounter and odd number, swap the number with the number at last even index"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Can someone please provide some examples of inputs and outputs?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5691998203805696","download_status":"DOWNLOAD_DONE","votes":"-5","answersCount":"11","title":"if EVER + SINCE = DARWIN , then what is D+A+R+W+I+N?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"dont know how   But got it with google  1. As it's a sum of 3 numbers hence the maximum value of D could be 2 or 1, but then we look at S which could have maximum value 9 and if it gets a carry of 1 then the value of A will be 0 and the D=1.  2. Then we looks at E and I which results in R, as 9 is already occupied by S so E could be 8 and I could be 7 and R will be 5 with carry 1.  3. Then we place the values of R=5 and E=8 resulting in N=3 with carry 1. 4. In ten's digits - E=8 and and value of C could be 3,4,6 (As all others are occupied) and To make I=7 (previously assigned in step 2) E must be added by 9 which is already occupied by S. So this hit ends here. Now start again with reduced value of E or I, repeat above steps until you get a correct answer or a dead end.  5. Repeating above steps one time comes with E=5 and I=7 which results in R=3 carry=1.  6. Placing R=3 and E=5 in unit digits and their sum gives 8. 7. in ten's digits place E=5 now you can add 2 to make I=7 hence C=2. 8. in 100's digits you have N=8 (from step 6) and only digits that are left now are 4 and 6 hence. So placing V=4 you will get W=2 which is not true because it is already assigned to C. So we are left with only V=6 as the ultimate choice and this leads the result in to W=4.   Hence this way we got the answer  ....5 6 5 3 ....E V E R ..9 7 8 2 5 + S I N C E ---------------------- D A R W I N 1 0 3 4 7 8  Hence D+A+R+W+I+N = 1+0+3+4+7+8 =23  got it from maths4math dot com"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Ans: 131  a system like ASCII can have the following definition, (with some 'x' as an offset) A=x+1  B =x+2 .. .. Z=x+26. Using this system,  EVER = E + V + E + R  = x+50 Similarly, SINCE = x+50, DARWIN = x+69.   So, EVER + SINCE = DARWIN (4x + 50) + (5x + 50) = 6x + 69 x = 31/2  Putting back x in DARWIN,  DARWIN = 6x + 69 = 131."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I can only conclude that D=1, A=0, S=9. With that, I further concluded that R cannot be 7 or 8 because otherwise you either end up with E & I (supposedly 2 distinct digits) being both 8, or that one of them is 9, which is taken.  So starting from R=2 to 6 I then just enumerate the possible values for E & I and checking whether the equation is valid. After some painstaking trials I realized the equation is:  5653 + 97825 = 103478  So D+A+R+W+I+N = 23. Now my question is why did the interviewer specifically ask for sum of these digits as opposed to figuring out the whole equation. Is there a simple way to calculate D+A+R+W+I+N? Did I miss any clues that can help me find all the digits without enumerating through all those possibilities?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"0 atoi of all these strings will return 0."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6222132728037376","download_status":"DOWNLOAD_DONE","votes":"-5","answersCount":"17","title":"sort the array so that the odd number in front of the even number and their relative order doesn't change in Time O(n) and Space O(1). I believe quickselect can do this, but it will change the relative order of the input.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Its almost impossible to solve this in O(n) and O(1) time.  There is a paper which describes citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.25.5554&rep=rep1&type=pdf : In the stable 0-1 sorting problem the task is to sort an array of n elements with two distinct values such that equal elements retain their relative input order.  But in order to do that we have to destroy the initial input array. But its just not done for just interviews of 1 hour."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the problem means {1, 2, 3, 4, 5} --> {1, 3, 5, 2, 4}, my code is as follows: (By the way, you were asked this many questions in one day interview??)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I don't think your solution is O(n). If you have an array 1 2 3 4 5 6 .... with a lot of numbers, then you have a main loop ("},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void swap(int &a, int &b) {  int tmp=a; a=b; b=tmp; }  void odd_even_sort(int* num, int n) {  int k=0;  for(int i=0; i  if( num[i]%2==1 ) {    swap(num[i],num[k]);    k++;   }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"forgot to surround the code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think it is wrong, too. Test {1,2,3,4,5}, i=0, k=0 -> {1,2,3,4,5}, i=1,k=1 -> {1,3,2,4,5}, i = 2, k = 2 -> {1,3,2,4,5}, i = 3, k = 2 -> {1,3,5,4,2} i = 4, k = 3. And that fails, because the correct answer should be {1,3,5,2,4} to save the relative order."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Thanks Alex, the following will preserve the relative order -- although the space complexity is O(1), it's time complexity is O(n^2). Wonder if one can solve this in time O(n) and space O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solving this in O(n) time and O(1) space seems impossible and I could only come up with a 'workaround' that involves using a recurrent algorithm so I could rely on the stack to hold the odd values. When the recursion returns, I just simply fill the array with the odd values from the stack."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"FYI: OP is just copy pasting interview questions found on glassdoor, OR Google just really likes interviewing him :P"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is possible. The solution is following: we scan the array from end to the beginning holding 2 pointers. 1st is on current odd number and 2nd is on current even number(when we start they are on first odd and even numbers). Further we swap numbers under pointers and move pointers till they meet corresponding numbers toward beginning of array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There's a limit to stupidity. I don't understand what are these companies trying to prove by asking questions that have no solutions. If these companies really want people who can answer prize-winning questions like this, they should hold a coding competition and select the winners to work for them. There's no point in conducting 45 min interviews. So, which ever company asks such questions should simply eliminate the concept of interviewing and just seek winners from a coding competition, if such winners do exist."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5795040777469952","download_status":"DOWNLOAD_DONE","votes":"-3","answersCount":"2","title":"What happens during and after a query is being typed (autocomplete) in a search box whether the user is trying to go to a website or asking a question etc, and how do servers complete the request and what is the best (parallel) structure for the request to go through. DFS and how servers are located for proximity","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please,clarify the question."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Autocomplete can be achieved many different ways. Most common is Ajax on the client side, and an NLP search engine application like Apache Lucene or Solr that does a reverse lookup and returns the matches based on the typed characters. These search engines can be very finely tuned. The rest of the question is not clear."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5713445122998272","download_status":"DOWNLOAD_DONE","votes":"-3","answersCount":"10","title":"How to remove duplicate lines in a large text file? I think it's easy to find duplicate lines, but how do we efficiently remove them from the file?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Plenty of ways to do this in Unix, like sort file.txt | uniq -u | tee out.txt. Obviously sorting isn't asymptotically optimal, though. A faster approach would be to build a histogram (as a hash map).  If the file is so large that it can't be held in memory at once, an obvious extension is to break it into chunks, build a histogram for each chunk, and merge the histograms.  Possibly a more practical approach would be to first construct a bloom filter. This can be made highly accurate, though it will still produce the occasional false positive. A second pass would be needed to detect false positives, but by that point the dataset should be very pruned."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"What if we used another file and a hash map? For each line read from the original file, hash it and check if it exists in the hash map and if it does it means that it's a duplicate so you just  don't write it in the new file. This would require only one pass but it also requires doubling the storage space and the extra memory for the hash map."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Apply a modified version of external sort. 1. Split the large file into smaller chunks and sort these chunks. 2. Apply pair-wise merge of these chunks, ignoring duplicate lines as they are found."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// Alternative approach to above would be to create a dict : Hash the lines  //  [or the digest? in case of very large length lines] such that // Obviously this *assumes* a good hash with no collisions. // [Is untested.]  hash_dict={} line_number=1 with open (\"filename\", \"wb\") as file:        for line in file:            hash=generate_hash(line)            if hash not in hash_dict.keys():                 hash_dict[hash]=line_number   line_number+=1            else:                 delete_line_from_file_inplace(file)  //delete_line_from_file_inplace can be done in different ways, google can help  ----------------------------------- Just a thought, off the top of my head the order of lines can be maintained in a convoluted way, for the first method mentioned by Alex, before sorting, record the line number/ append it at the beginning of the line(n), and ignore this entry while sorting(nlogn), make a pass over the file to remove the duplicates(n), and sort again with the line numbers (nlogn), Remove line# (n). But this seems expensive :\\"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can use hashing + hashing + hashing approach. First hash will be based on number of characters in line Second hash will be number of words in the line third will be hash of words and now we can store line here.   When a new line comes, it will pass all three hashes and if comes into same bucket then we can compare lines. using these 3 hash (or filters) we can minimize the chances of clashing lines."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6278204062957568","download_status":"DOWNLOAD_DONE","votes":"-2","answersCount":"19","title":"Write code to return a random line from a file of unknown size and variable length rows","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"It suffices to store only a single line in memory at once, specifically the line that current_line currently points to. If current_line gets updated, you can update the line stored in memory as well.  The algorithm is like this, in pseudocode:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"General idea (no code):  Set current_line initially to 0. Iterate over the lines. For the nth line, set current_line to n with probability 1/n. This will produce a uniform distribution on the set of lines."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public bool IsMatch(String FilePath,String matchString) \n{ \n \nStringReader sr= new StreamReader(FilePath); \n \nint hashStr = matchString.GetHashCode(); \n \nwhile(sr.ReadLine()!=null) \n{ \n  String tempStr = sr.ReadLine(); \n \n  int hashTempStr = tempStr.GetHashCode(); \n \n if(hashTempStr  == hashStr ) \n  { \n   return true; \n   break; \n  }         \n \n} \n \n \nreturn false; \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"At time i we read the i'th line. We pick this line with the possibility 1/i. If this line is not selected, nothing needs to be done later for this line. At time (i+1) we re-choose the i'th line with possibility i/(i+1), so that the possibility to  keep the i'th line at time (i+1) is 1/i * i / (i+1) = 1/(i+1).   This process can be continued until we reach the end of the file. For the lines kept we can randomly pick one."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ya Martin sorry I made an error while typing , yes we have to do   while((tempStr = sr.ReadLine()) != null) { }  My Mistake I missed out this thing."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5842242904260608","download_status":"DOWNLOAD_DONE","votes":"-3","answersCount":"7","title":"How would you design a chess game in OOP?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Hey Google told me they stopped asking design questions a few weeks before my interview. My interview was in 09/2013. When was this question asked?   I was not asked any design questions in my interview either. Btw, I applied for the Software Engineer in Test position and was offered the Test Engineer position. I did not accept."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I don't actually think knowing the exact rules matters that much. You can always leave a method make_move() and I highly doubt you will be asked to specify the implementation for each type of pieces."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is what I'm talking about:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5841310594367488","download_status":"DOWNLOAD_DONE","votes":"-3","answersCount":"6","title":"Given inputs from Google Search, you have K chunks. Each chunk is individually alphabetically ordered (apple, banana, cat) ... (*apple, *banan, *cat). You want to merge all chunks into a single list. How would you do it?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"K-way merge. Keep merging one pair of chunks at a time. After the first pass, k/2 chunks will be left. After the second pass, k/4 chunks will be left and so on. At each pass, need to take care of merging the last remaining chunk as a special case in case k/i is odd, where i = 1..k"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"We should create MinHeap containing first elements of chunk. Each time we extract min from the heap and push it to the output. And add new element from head of chunck, which element was pushed to output."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Further optimize with something similar to reduce step in map-reduce? Usually map would do the sorting, and the reduce would be merging; use a good hash such that reducer[i] has all the elements that are smaller than reducer[i+1]; merging on an individual reducer now can be done with the heap; [->these step can be parallelized]"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6031783804010496","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"9","title":"given 2 Dimensional array  I/P -- String[][] input = { { \"abc\", \"def\", \"gh\" },        { \"f\", \"g\" },       { \"qrt\",\"xyz\",\"pqr\" } };  Program shd return a 2-D Array with  O/P -- { { \"abcfqrt\", \"abcfxyz\", \"abcfpqr\" ,abcgqrt and so on ..","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) { \n  String[][] a = {{\"abc\", \"def\", \"gh\"},{\"f\", \"g\"},{\"qrt\",\"xyz\", \"pqr\"}}; \n   \n  print(a); \n \n } \n  \n public static void print(String [][] a){ \n   \n  if( a == null) \n   return; \n \n  int x = a[0].length; \n  int y = 0; \n   \n  for(int i = 0; i < x; i++){ \n   if( y < a.length){ \n    printMore(a, a[0][i], y + 1); \n   } \n  } \n   \n } \n  \n public static void printMore(String[][] a, String str, int yIndex){ \n     \n  int x = a[yIndex].length; \n   \n  for(int i = 0; i < x; i++){ \n   if(yIndex < a.length-1){ \n    printMore(a, str + a[yIndex][i], yIndex +1); \n   }else{ \n    System.out.println(str + a[yIndex][i]); \n   } \n    \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void stringComb(vector> &myStrings) { \n \n vector>::iterator itr = myStrings.begin(); \n \n if (itr != myStrings.end()) { \n  std::string newStr = \"\"; \n  stringComb(myStrings, itr, newStr); \n } \n \n} \nvoid stringComb(vector> &myStrings, vector>::iterator itr, std::string myString) { \n \n static int printCount = 0; \n \n if (itr == myStrings.end()) { \n  printf(\"%d: %s\\n\", ++printCount, myString.c_str()); \n  return; \n } \n  \n for (auto &innerItr : *itr) { \n  std::string newStr = myString + innerItr; \n  stringComb(myStrings, itr+1, newStr); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Take two consecutive rows, concatenate the strings as a cartesian product of the rows and merge them into a single row. Repeat the steps until only one row is left. The procedure can follow either a top-down approach or a bottom-up approach, with the initial rows being the first two or the last two respectively."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#should work for arbitrarily long sub list"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Backtracking?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class TwoDimensionMerge { \n \n    public static void main(String asd[]) { \n \n        String[][] input = {{\"abc\", \"def\", \"gh\"}, \n            {\"f\", \"g\"}, \n            {\"qrt\", \"xyz\", \"pqr\"}, \n            {\"ugur\",\"1\"}};         \n         \n        for (int i = 0 ; i < input.length-1 ; i++ ) { \n            input[i+1] = merge(input[i], input[i+1]); \n        } \n         \n        for ( int i = 0 ; i < input[input.length-1].length ; i++ ) { \n            System.out.println(input[input.length-1][i]); \n        } \n \n    } \n     \n    public static String [] merge (String [] input1, String [] input2) { \n         \n        String [] output = new String[input1.length * input2.length]; \n         \n        int i = 0; \n         \n        for (int j = 0 ; j < input1.length ; j++ ) { \n            for (int k = 0 ; k < input2.length ; k++ ) { \n                output[i++] = input1[j] + input2[k]; \n            } \n        } \n         \n        return output; \n         \n    }  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void convert_from_one_form_to_another(std::vector> &s,int row,int max_row,std::string &new_string) \n{ \n    if(row==max_row) \n    { \n        std::cout<<\"\\n\"<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why is the output a 2 dimensional array if it's just a merge? Or is it a output of permutations?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4752301805797376","download_status":"DOWNLOAD_DONE","votes":"-3","answersCount":"37","title":"Count the number of positive integers less than N that does not contains digit 4.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"import java.util.*; \n \npublic class CountFours \n{ \n    public CountFours() \n    { \n    } \n \n    /** \n     * Recursively count how many numbers below n don't have a 4 in decimal \n     * representation. \n     */ \n    public int count(int n) \n    { \n        // base case when we have single digit \n        if (n < 4) { \n            return n; \n        } \n         \n        if (n >= 4 && n <=9) { \n            return n - 1; \n        } \n \n        // otherwise for multi digit numbers, compute the order of magnitude \n        int orderPower = (int) Math.floor(Math.log10(n)); \n        // actual number order  \n        int order = (int) Math.pow(10, orderPower); \n \n        // the first digit of the number n \n        int d = (int) n / order; \n \n        // the rest of the number when first digit is removed \n        int remainder = n % order; \n \n        // if the number starts with 4, then all of the remainder should not \n        // be counted. Therefore, the count value is the same as number that \n        // starts with d-1 as first digit and all the rest of digits are 9 \n        if (d == 4) { \n            // remainder is all 9s \n            remainder = (int) Math.pow(10, orderPower) - 1; \n        } \n \n        // compute the power of 9 \n        int ninePower = (int) Math.pow(9, orderPower); \n \n        if (d < 4) { \n            return d * ninePower + count(remainder); \n        } else { \n            return (d - 1) * ninePower + count(remainder); \n        } \n    } \n \n    /** \n     * Count number of times 4 appers in any number less than equal to \n     * n by converting the numbers to string and comparing digits as chars. \n     */ \n    public int naiveCount(int n) \n    { \n        int withoutFourCount = 0; \n \n        for (int i = 1; i <= n; i++) { \n            if (!containsFour(i)) { \n                withoutFourCount++; \n            } \n        } \n \n        return withoutFourCount; \n    } \n \n    /** \n     * Check if the number contains 4 by converting the number to string, \n     * walking through the string and looking for char '4' \n     */ \n    public boolean containsFour(int n) \n    { \n        String value = String.valueOf(n); \n \n        if (value.indexOf('4') != -1) { \n            return true; \n        } \n \n        return false; \n    } \n \n    /** \n     * Test recursive algorithm against naive algorithms for all numbers \n     * up to n \n     */ \n    public void test(int n)  \n    { \n        for (int i = 0; i <= n; i++) { \n            if (naiveCount(i) != count(i)) { \n                System.out.println(\"Recursive algorithm is wrong for n = \" \n                        + i); \n                return; \n            } \n        } \n \n        System.out.println(\"Passed for all numbers up to \" + n); \n    } \n \n    /** \n     * Print how many numbers below n do not contain 4 \n     */ \n    public void testCount(int n)  \n    { \n        System.out.println(\"For n = \" + n + \" there are \" + count(n)  \n                + \" numbers that don't contain 4\"); \n    } \n \n    public static final void main(String args[]) \n    { \n        CountFours app = new CountFours(); \n        app.test(10000); \n        app.testCount(1000); \n        app.testCount(Integer.MAX_VALUE); \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"The first 10 numbers contain 9 numbers without 4. The first 100 numbers contain (9*9) numbers without 4. The first 1000 numbers contain (9*9*9) numbers without 4... and so on. Store the number of numbers without 4 against each power of 10. Maybe in an array.  Split N into its powers of 10 like: a*10^x + b*10^(x-1) + c*10^(x-2)+... and so on  Use the above array to calculate the total number, but beware of any 4s in a, b, c, etc.  So the total becomes: a*(number of 4less numbers in first 10^x) + b*(number of 4less numbers in first 10^(x-1)) + ... and so on."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Brute Force \npublic int count(int N){ \n  int sum = 0, i = 0; \n  String s; \n  while (i++ < N){ \n   s = Integer.toString(i); \n   if (s.indexOf(\"4\") == -1) sum++; \n  } \n  return sum; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/*   * Pouya Karimi -  This code is written in C */ #include  int main(int argc, char const *argv[]) {  int a, counter = 0, b;  std::cout << \"Enter a number: \";  std::cin >> a;  for(int i=1;i<=a;i++){   b = i;   while ( b != 0 ){    if(b % 10 == 4){     counter ++;    }    b = b/10;   }  }   std::cout << \"The number is: \" << a-counter << \"\\n\" ;  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void getCountForNumber(int num) \n{ \n    int count = 0; \n    for (int i = 1; i< num; i++) \n    { \n        int temp = i; \n        while ( temp ) \n        { \n            if ( temp % 10 == 4 ) \n            { \n                //Digit 4 found. \n                break; \n            } \n            temp /= 10; \n        } \n \n        if ( temp == 0) \n        { \n            ++count; \n        } \n    } \n    std::cout<<\"\\nNumbers found : \"<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have found more efficient algorithm of this problem?? it uses recursion??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A more optimized approach using recursion can be used: C(k) : number of numbers of k digits that do not contain 4 N[k] : kth digit in the number N f(k) : for a given digit k return the number of digits possible for that place (unit, tens, hunderds) e.g if k = 3 then we have 4 options 0,1,2,3 and if k = 5 then we have 5 options 0,1,2,3,5 The recursion equation will be C(k+1) = (f(N[k]) -1)*(9^k) + C(k) Base case C(1) = f(N[1])  Note: This solution includes 0 as a number in its answer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Runs in constant time. Uses recursion and written in C++"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class Googleque \ndef initialize(val) \n@n=val \n@array= Array.new \n@i=0 \n@count=0 \nif @n <= 0 then \nputs \" No Positive numbers present\" \nelse \nlogic \nend \nend \n \ndef logic \nfor i in 0..@n \ncalculation(i)    # Applying calculation logic for every number until 'N' \ni=i+1 \nend \nputs \"Total no of positive integers which does not contain '4' it are.\\n\" \nputs \"#{@n-@count}\" \nend \n \ndef calculation(i) \n@i= 0 \n \nuntil i==0 \n@array[@i]= i%10 \ni=i/10 \n@i=@i+1 \nend \nif @array.include?(4) then \n@count = @count+1 \nend \n \nend \n \nend \n \nputs \"Enter your number\" \nval= gets.to_i \nob= Googleque.new(val)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be solved by a recursive approach that works by removing Most Significant Digits(MSD) one at a time in each recursive step and counting the number of numbers that don't include 4.  Suppose the given integer N has k digits - d1,d2,...,dk. There are 2 cases: d1 < 4 and d1>=4 and the recursion yields itself as:  1. For d1 < 4   f(d1,d2,...,dk) = d1 * (k-1)^9 + f(d2,d3,..,dk)  2. For d1 >= 4   f(d1,d2,...,dk) = (d1-1) * (k-1)^9 + f(d2,d3,..,dk)  Both can as well be combined to:   f(d1,d2,...,dk) =  [(d1 - floor((d1)/4) - floor((d1)/8)) * (k-1)^9] + f(d2,d3,..,dk)  The base cases are:  f(d) = d,  for d<4. [It could have been d+1, had the question not been asking for numbers *lesser* than the given number]  f(d) = d - 1, for d>=4 [It could have been d, had the question not been asking for numbers *lesser* than the given number]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def nine_based_numeral_system(max) \n    sw  = count = 0 \n    pos = max.to_s.length \n \n    max.to_s.scan(/./).each do |number| \n      number = number.to_i \n      if number == @filter && sw == 0 \n        number -= 1                     # As will be the same result 4xx than 399 \n        sw      = 1 \n      elsif sw == 1 \n        number = 9                      # As it has a previous 4 so this is the same as 3xxx \n      elsif number > @filter \n        number -= 1 \n      end \n      pos   -= 1 \n      count += number * 9 ** pos \n    end \n    count -= 1 \n  end \nend"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Written in C#"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void countNot4(unsigned int N) \n{ \n int count =0; \n  \n for(int i=1;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class NonFour {         \n    public long getNonFourCount(long N) { \n        int numberOfDigits = (int)Math.floor(Math.log10(N)) + 1; \n        int fisrtDigit = (int)(N / (long)Math.pow(10, numberOfDigits-1)); \n         \n        long count =0; \n        if(N<10) { \n            for(int j = 0; j<=N; j++) { \n                if(j!=4) \n                    count++; \n            } \n            return count; \n        } \n         \n        long pow = (long)Math.pow(9, numberOfDigits-1); \n        count = pow; \n         \n        for(int i =1; i< fisrtDigit; i++) { \n            if(i != 4) { \n                count += pow; \n            } \n        } \n         \n        N = N % (long)Math.pow(10, numberOfDigits-1); \n        return count + (N==0? 1 : getNonFourCount(N)); \n    } \n     \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorry, in my last solution didn't take care of numbers starting with 4. This is not brute-force:  /*  * To change this template, choose Tools | Templates  * and open the template in the editor.  */ package javatest;  /**  *  * @author neerajks  */ public class NonFour {             public long getNonFourCount(long N) {         int numberOfDigits = (int)Math.floor(Math.log10(N)) + 1;         int fisrtDigit = (int)(N / (long)Math.pow(10, numberOfDigits-1));                  long count =0;         if(N<10) {             for(int j = 0; j<=N; j++) {                 if(j!=4)                     count++;             }             return count;         }                  long pow = (long)Math.pow(9, numberOfDigits-1);         count = pow;                  for(int i =1; i< fisrtDigit; i++) {             if(i != 4) {                 count += pow;             }         }                  N = N % (long)Math.pow(10, numberOfDigits-1);         return fisrtDigit !=4 ? count + (N==0? 1 : getNonFourCount(N)) : count;     }      }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Scanner; \n \n/** \n * \n * @author u?ur \n */ \npublic class CountNumber { \n     \n    public static void main (String args[]) { \n         \n        Scanner scanner = new Scanner(System.in); \n         \n        int n = scanner.nextInt(); \n         \n        int count = 0; \n         \n        for (int i = 0 ; i < n ; i++ ) { \n            if ( !containFour(i)) { \n                count++; \n            } \n        } \n         \n        System.out.println(count); \n         \n    } \n     \n    public static boolean containFour(int i) { \n         \n        return String.valueOf(i).contains(\"4\"); \n                 \n    } \n     \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What about this :P  public int integerCount(int N)  {      int count = 0;  for(int i =0 ; i < N; i++)  {      if(!Integer.toString(i).contains(\"4\"))  {      count++;  }  }  return count; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int pow = 0; \n        int sum = 0; \n        int digit = 0; \n        while (number > 0) { \n            digit = number % 10; \n            sum += (digit > 4)? ((digit-1) * power (9,pow)) : \n                           ((digit) * power (9,pow)); \n            number /= 10; \n            pow++; \n        }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6609034656350208","download_status":"DOWNLOAD_DONE","votes":"-8","answersCount":"14","title":"If you had a savings account with $1, at a 100% interest rate, at what year would you have 15 billion dollars? I know it's Log base 2 of 15 billion. But how did it get to log base 2? What's the formula here?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"100% interest rate means that the amount that you have in the bank doubles after each year: $1 at the beginning, 2 * $1 after one year, 2 * 2 * $1 after two years, ..., 2^n * $1 after n years = 15B . Therefore log_2(15B) = n."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"this cannot be a interview question. It's middle school math. Too easy, not much knowledge involved"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"With 100% interest rate, money is doubling every year.  1, 2, 4, 8, ..... x  So x = 2^k x = 15 billions  So 2^k = 15 billions k = log(15 billions) -log with base 2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ln(15 billion) - ln(2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What could this interview question possibly reveal about a SDE candidate?  It has nothing to do with computer science.  If it's a real question, that interviewer should cease and desist being involved in interview loops."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Let's say the principle amount is m and  interest rate is r% and is calculated annually. so after n years the amount will be m*(1+ r/100)^n. Here m=1 and r = 100 so the amount will be 1*(1+100/100)^n = 2^n. given that 2^n = 15B. so n = ln(15B) ln means log with base 2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question is incomplete. The answers would differ for a simple interest vs compound interest."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"log2 (x) = logy (x) / logy (2) use built in log"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"n=15b; while(n!=1) { n=n/2; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"n=15b; year=0; while(n!=1) { year++; n=n/2; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Think of it is a binary tree, interest is 100%, means every dollar becomes double, so essentially answer is height of binary tree where number of leaves is 15 billion."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5105977028247552","download_status":"DOWNLOAD_DONE","votes":"-4","answersCount":"7","title":"The setup is that we are given a series of text files which contain information regarding a code repository's commits. Each file represents a single commit and they are formatted as follows: \" Commit #: XXX Author: XXX Reviewer(s): XXX, XXX, ... File: XXX File: XXX ... Date: XX:XX:XX XX/XX/XXXX \" The commit number is unique and is generated in synchronous order. There is exactly 1 unique author. There are a variable number of reviewers, delimited by commas; if there are no reviewers, that line is absent from the file. There are a variable number of edited files in the commit, each receiving its own line. The time/date is when the commit was submitted.  First design a graphical model for all of the commit data. Then describe how this model is updated when a new commit is generated. Finally, write the code segment called when a new commit is generated which edits a system that has implemented your model of the data - its input is a file name and whatever necessary data structures that are maintained by your system.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what does graphical model really mean? you can maintain in-memory linked list of all commits, new commit is appended to a tail, this can be generated from information stored in files."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Linked list ??? but I do not know how many Files were affected and I do not know how people review the commit . I do not understand what does graphical model really mean? , but what about using Big-table  with commit as row-key and he remainder of attributes as column family"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Maintain a DAG with latest commit file at HEAD maintained by a pointer for each branch."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5654693460049920","download_status":"DOWNLOAD_DONE","votes":"3","answersCount":"10","title":"Given a timer time() with nanosecond accuracy and given the interface","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"stackoverflow.com/questions/17562089/how-to-count-number-of-requests-in-last-second-minute-and-hour"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"(Poster here.)   Another point of clarification: \"in the last X\" is measured relative to the current nanosecond, i.e., it refers to the time interval [time() - X, time()]. This is a continuously updating and moving window of time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"If the timer is at nano scale, then a queue will not be ideal solution: Assuming 32 bytes/ message, holding a day's worth of timestamp in a queue would require 3600 * 24 * 10^9 * 32 bytes which would be in peta bytes."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"class A implements RealTimeCounter { \n \n        private volatile ArrayList timers = new ArrayList(); \n        private static java.util.Timer timer = new Timer(); \n        private static TimerTask task = new TimerTask() { \n            public void run(){ \n                // query for today's date \n                removeEntriesLongerThanDay(); \n            } \n        }; \n \n        static { \n            // run once every day say 10pm, you can change this to any other time or any frequency. \n            DateTime now = new DateTime(DateTimeZone.forID(\"US/Eastern\")); \n            DateTime fivePM = now.withTime(22,00,0,0); \n            timer.scheduleAtFixedRate(task, fivePM.toDate(), 1000*60*60*24);  \n        }  \n \n        public void increment() { \n            timers.add (System.currentTimeMillis()) ; \n        } \n \n        private int getCounters(long n) { \n            int count = 0; \n \n            long currentTime = System.currentTimeMillis(); \n            for (Long val:timers) { \n                if  ( (( currentTime - val )/ n) > 0  ) \n                    count ++; \n            }        \n \n            return count; \n        } \n \n        public int getCountInLastSecond() { \n            return getCounters(1000) ; \n        } \n \n        public int getCountInLastMinute() { \n            return getCounters (60*1000) ; \n        } \n \n        public int getCountInLastHour() { \n            return getCounters (60*60*1000) ; \n        } \n \n        public int getCountInLastDay() { \n            return getCounters (24*60*60*1000) ; \n        } \n \n        /** \n         * Removes the entries which are older than day,  \n         * this will make sure the ArrayList 'timers' doesn't  \n         * grow very very long as we are cleaning up entries eventually. \n         * @param null \n         * @return null \n         */ \n        private void removeEntriesLongerThanDay() { \n \n            if (getCountInLastDay()  <= 0 ) \n                return; \n \n            long currentTime = System.currentTimeMillis(); \n            ArrayList removalIndexes = new ArrayList(); \n            long n = 24* 60 * 60 * 1000; // Number of sec in 1 day. \n            for (int i = 0; i < timers.size(); i++) { \n                if  ( (( currentTime - timers.get(i) )/ n) > 0  ) { \n                    removalIndexes.add((long) i); \n                } \n            } \n \n            synchronized(timers){ \n                for (Long index:removalIndexes)  \n                    timers.remove(index); \n            } \n \n        } \n \n \n    }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5640295119060992","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"9","title":"given a double linked list and an array of nodes in that dll??output number of clusters. example: dll: n1 n2 n3 n4 n5; array: n1 n4 n5; output 2( (n1) (n4 n5))","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have already mentioned  a space based solution which some1 has downgraded without giving reason the other solution without keeping space is:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Go through the linked list and build a hash table mapping each node to the node that follows it. Then go through the array and for each position, look at the next position and see whether the node there matches what the hash table says the next node should be. Increment a counter each time there's not a match (counter starts with 1 since we always say there's at least 1 cluster)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static void findClusters(Node[] nodes) { \n  int numberOfClusters = 1; \n  LinkedHashSet runningCluster = new LinkedHashSet(); \n  for (int i = 0; i < nodes.length - 1; i++) { \n   if (nodeMap.get(nodes[i].getVal()).getNext() == nodes[i + 1] \n     || nodeMap.get(nodes[i].getVal()).getPrev() == nodes[i + 1]) { \n    runningCluster.add(nodes[i]); \n    runningCluster.add(nodes[i+1]); \n   } else { \n    printList(runningCluster); \n    runningCluster.clear(); \n    numberOfClusters++; \n    runningCluster.add(nodes[i+1]); \n   } \n  } \n  printList(runningCluster); \n  System.out.println(\"Total number of clusters are \" + numberOfClusters); \n } \n \nprivate static Node createDoublyLinkedList(int[] array) { \n  Node head = null, temp = null; \n  for (int num : array) { \n   if (head == null) { \n    head = new Node(num, null, null); \n    temp = head; \n    nodeMap.put(num, head); \n   } else { \n    Node newNode = new Node(num, null, temp); \n    temp.setNext(newNode); \n    temp = newNode; \n    nodeMap.put(num, newNode); \n   } \n  } \n  return head; \n } \n// pretty printing \n private static void printList(LinkedHashSet runningCluster) { \n  System.out.print(\"(\"); \n  for(Node node : runningCluster) { \n   System.out.print( node.getVal() + \" \"); \n  } \n  System.out.print(\")\"); \n  System.out.println(); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"i guess the array of nodes is unordered or else its just a simple question  on a simple thought: can create a bool a[n] = {false} and then set it for every occurance in the array then rescan the bool array and we will have the count"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"By cluster do they mean greater than 1 successive node?  if yes, high level: - clusterCount = 0 - Sort the Array (if not sorted - nLogN) - foreach node in the NodeList, do a BinarySeach on the Array nLogN - increment the clusterCount only if two or greater nodes are found"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"There are 2 possible questions: 1) If you cannot shuffle the array. Then we just use 2 pointers. 2) If we can shuffle the array. (This algorithm apparently solves first case as well). We put all values from array to hash map. Then go through the linked list and check if we have node in the hash map."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5717108864319488","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"16","title":"Given a list of integers that fall within a known short but unknown range of values, how to find the median value? Some say we could use selection algorithm. But that will take O(n/2 * n), which results in O(n^2). I don't know how it is a good solution.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"use quickselect with random pivot should achieve linear/O(n) time in practice"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using the Median of Medians algorithm, worst case time is O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \nusing namespace std; \n \ndefault_random_engine generator; \n \nint randi(int low, int high){ \n uniform_int_distribution distribution(low, high); \n \n return distribution(generator); \n} \n \nint selectRand(int *array, int low, int high, int rank){ \n int randIndex = randi(low, high); \n swap(array[low], array[randIndex]); \n  \n int pivot = array[low]; \n int lh = low+1; \n int rh = high; \n \n while(true){ \n  while(lhlow && pivot<=array[rh]) rh--; \n \n  if(lh rank) \n  return selectRand(array, low, rh-1, rank); \n \n} \n \n////////////////////////////////////////////////////////////////////////////// \nint main(){ \n int array[10] = {2,4,6,8,10,1,3,5,7,9}; \n \n cout << selectRand(array, 0, 9, 7) << endl; \n  \n for(int i=0; i<10; i++) \n  cout << array[i] << \"  \" ; \n \n  \n \n  \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use MaxHeap and MinHeap concept. The size of the maxHeap can be either equal or one greater than minheap. When a new element arrives, insert them into the maxHeap or minHeap as per follows:  If MaxHeap and minHeap size is equal then 1. If the number is greater than root of maxHeap (It has to be inserted into minHeap then.) But since the size of minheap cannot exceed MaxHeap, we will take the root of minheap and insert into MaxHeap. Then insert the new element into minHeap. 2. Otherwise, if the number is smaller that root of maxHeap, then insert the number in maxHeap. (Remember the size of maxheap can be 1 greater than Minheap).  If the size of maxHeap and minHeap is not the same then 1. If number is small than root of maxHeap, it has to be inserted in maxHeap. Since the size is not same, it means that the maxHeap is already 1 greater than minheap. Since the difference cannot be more than 1, we shift the root of MaxHeap into minHeap and insert the number in MaxHeap. 2. Otherwise, If number is larger than root of maxHeap, insert it into minHeap.  Use priority queue to implement MinHeap and MaxHeap behaior.  Code :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use MaxHeap and MinHeap concept. The size of the maxHeap can be either equal or one greater than minheap. When a new element arrives, insert them into the maxHeap or minHeap as per follows:  If MaxHeap and minHeap size is equal then 1. If the number is greater than root of maxHeap (It has to be inserted into minHeap then.) But since the size of minheap cannot exceed MaxHeap, we will take the root of minheap and insert into MaxHeap. Then insert the new element into minHeap. 2. Otherwise, if the number is smaller that root of maxHeap, then insert the number in maxHeap. (Remember the size of maxheap can be 1 greater than Minheap).  If the size of maxHeap and minHeap is not the same then 1. If number is small than root of maxHeap, it has to be inserted in maxHeap. Since the size is not same, it means that the maxHeap is already 1 greater than minheap. Since the difference cannot be more than 1, we shift the root of MaxHeap into minHeap and insert the number in MaxHeap. 2. Otherwise, If number is larger than root of maxHeap, insert it into minHeap.  Use priority queue to implement MinHeap and MaxHeap behaior.  Code :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sort the integers into an array using mod R, where R is the known short range. While sorting into the buckets record the position of the minimum element. This element is then the offset and the median is in bucket (R/2+offset) mod R.  If duplicate numbers are allowed need to take care of counting how many, and you have to actually walk along you're R buckets to find the median.  Complexity of this should be O(N) if N, number of integers, and O( N + R ) if duplicates are allowed."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int getMedian(int[] nums) \n{ \n int min, max = nums[ 0 ]; \n \n for( int num : nums ) \n  if( num > max ) \n   max = num; \n  else if( num < min ) \n   min = num; \n \n int counts = new int[ max - min + 1 ]; \n \n for( num : nums ) \n  counts[ num - min ] ++; \n \n int sum = counts[ 0 ]; \n  \n int med = 0; \n \n while( sum < ( nums.length / 2 )) \n { \n  sum += counts[ ++med ]; \n } \n \n return med + min; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It's known short, ie small, right? I'd stick the /count of/ each integer into an array (or c++ vector, deque, whatever you want), with a global min and max for the numbers you've seen, and a total count (not sum) of the numbers seen. 'Min' acts as an offset telling you what to add to incoming numbers to make the index where their count is stored (eg, if the first number is '5' and you store it at index 0, the offset would be -5, ie -min). If the number is already present, bump the count (of eg the 5s you've seen). If the number is higher than your max seen, set the new max, set the array elements between your old max and your new one to 0, and bump the count at the new max. If you have a new min, well, painfully shift the array elements so as to accommodate the new min (maybe with some buffer space eh?), and set min and max accordingly. Now, this 'painful shift' is O(n), and you'll do it, what, 'size-of-known-short-range' / 2 times on average (right?) so that's actually constant. Everything else in maintaining this array is O(1). When you want to sample the median, walk from min to max, summing the array entry counts as you go, until the bin where you hit total count / 2. This number of this bin (taking your min offset into account) is the median."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Keep a max heap and a min heap. Whenever you insert in max heap pop an element and push it in min heap. Finally depending on the total number of elements, take the max and min and average them or take one from max heap."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6246384562864128","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"26","title":"Program an iterator for a Linked List which may include nodes which are nested within other nodes. i.e. (1)->(2)->(3(4))->((5)(6). Iterator returns 1->2->3->4->5->6","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"C++ solution. This one also uses a stack, similar to previous answers I omitted some code which is not relevant to the question itself, as well as some \"friend\" commands to make it more readable.  NestedNode contains a value and two pointers: to the nested element and to the next element."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"package test; \n \nimport java.util.*; \n \npublic class Test { \n \n public static void main(String[] args) { \n \n  Node start = new Node(1); \n \n  start.addNextNode(2).addNestedNode(3).addNestedNode(4).addNextNode(5) \n    .addNestedNode(6); \n \n  List list = new List(start); \n  Iterator t = list.iterator(); \n \n  while (t.hasNext()) { \n   System.out.print(t.next() + \"  \"); \n  } \n \n } \n \n} \n \nclass MyIterator implements Iterator { \n \n Node n1; //traverses main nodes \n Node n2; //traverses nested nodes \n \n boolean traverseNestedNodes; \n \n MyIterator(List list) { \n  n1 = list.start; \n  n2 = null; \n } \n \n @Override \n public boolean hasNext() { \n  return n2 != null || n1 != null; \n } \n \n @Override \n public Integer next() { \n  int value; \n  if (n1 == null && n2 == null) { \n   throw new NoSuchElementException(); \n  } \n \n  if (n2 == null) { \n   value = n1.value; \n   n2 = n1.nestedNodes; \n   n1 = n1.next; \n  } else { \n   value = n2.value; \n   n2 = n2.next; \n  } \n \n  return value; \n \n } \n \n @Override \n public void remove() { \n \n } \n} \n \nclass Node { \n int value; \n Node next; \n \n Node nestedNodes; \n \n Node(int value) { \n  this.value = value; \n } \n \n @Override \n public String toString() { \n  return value + \"\"; \n } \n \n Node addNextNode(int value) { \n  Node nextNode = new Node(value); \n  this.next = nextNode; \n  return nextNode; \n } \n \n Node addNestedNode(int value) { \n  Node newNode = new Node(value); \n  if (nestedNodes == null) { \n   nestedNodes = newNode; \n  } else { \n \n   Node cursor = nestedNodes; \n   while (cursor.next != null) { \n    cursor = cursor.next; \n   } \n   cursor.next = newNode; \n  } \n  return this; \n } \n \n} \n \nclass List { \n Node start; \n \n List(Node start) { \n  this.start = start; \n } \n \n @Override \n public String toString() { \n  Node current = start; \n  StringBuilder buf = new StringBuilder(); \n  while (current != null) { \n   buf.append(current + \"  \"); \n   current = current.next; \n  } \n \n  return buf.toString(); \n } \n \n Iterator iterator() { \n  return new MyIterator(this); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Iterator { \n \n protected LinkedList flattenedList = LinkedList = new LinkedList(); \n ListNode pointer = null; \n \n public Iterator(ListNode head) { \n  pointer = head; \n  traverseNodes(head); \n } \n \n public boolean hasNext() { \n  if (pointer == null) return false; \n  else return true;  \n } \n  \n public ListNode next() { \n  ListNode returnVal = pointer; \n  pointer = pointer.next(); \n  return returnVal; \n   \n } \n \n public void traverseNodes(ListNode x) { \n  while ( x != null ) { \n   flattenedList.add(x); \n \n   // traverses 'downwards' \n   if (x.nestedNodes != null) { \n    traverseNestedNodes(x.nestedNodes); \n   } \n   // Iterate through current level's linkedlist \n   if (x.next != null) { \n    x = x.next; \n   } \n  } \n  return; \n } \n} \n \npublic class ListNode() { \n int data; \n ListNode nestedNodes; \n ListNode next; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class FlattenIterator implements Iterator { \n     stack st; \n     public FlattenIterator(LinkedList in) \n     { \n            if (in != null) { \n                 st = new Stack();  \n                 st.push(in.iterator());  \n            } \n     } \n     private void moveToNext()  \n     { \n            next = null;  \n            while (!st.isEmpty()) \n            { \n                     Iterator it = st.peek(); \n                     if (it.hasNext()) \n                     { \n                             Object o = it.next(); \n                             if (o  instanceof Integer) {  \n                                        next = (Integer)o ; \n                                         break; \n                             }  \n                             if (o instanceof List) { \n                                       st.push( (List)o.iterator() );  \n                             } \n                     } \n                     else { st.pop(); { \n            } \n     } \n \n     public boolean hasNext() { \n          next = null; \n          moveToNext(); \n          return next != null;  \n     } \n     public Integer next()  \n     { \n           if (next == null) throw NoSuchElementException; \n           return next; \n     } \n     public void remove() \n     { \n             throw UnSupportedOperationException; \n     } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// For those want in python, use yield"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct Node { \n    int value; \n    Node *next; \n    Node *nextNested; \n}; \n \nvoid traverse(Node *start) \n{ \n    if (start != NULL) \n    { \n        printf(\"%d \", start->value); \n        traverse(start->nextNested); \n        traverse(start->next); \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I like the anonymous Python solution. Technically, though, lists in Python may not be implemented as linked lists, so here's a solution with explicit linked lists:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"test cases: 1) null ? 2) 1 3) 1-2 4) 1-(2-3)-4 4.a) 1-(2-3)-(4-5) 5) 1-(2-(3-4))-5"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can consider this Binary Tree where next pointer of Linked List Node is equivalent to right node of Binary Tree and Nested pointer of Linked List Node as left node of Binary tree. Then simple do pre-order traversal."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simple DFS Kind of solution for this"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simple DFS Kind of solution for this \nNode  \n{ \n Node next; \n Node nested; \n int value; \n} \n \nvoid iterator(Node head) \n{ \n if(head == null) \n  return; \n System.out.println(head->value); \n iterator(node->nested); \n iterator(node->next);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simple DFS Kind of solution for this \nNode  \n{ \n Node next; \n Node nested; \n int value; \n} \n \nvoid iterator(Node head) \n{ \n if(head == null) \n  return; \n System.out.println(head->value); \n iterator(node->nested); \n iterator(node->next);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simple DFS Kind of solution for this \nNode  \n{ \n Node next; \n Node nested; \n int value; \n} \n \nvoid iterator(Node head) \n{ \n if(head == null) \n  return; \n System.out.println(head->value); \n iterator(node->nested); \n iterator(node->next);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A composite iterator (composite pattern) can be designed for as s solution to this problem. The main intent of Composite lets clients treat individual objects and compositions of objects uniformly. We can come up with a Composite iterator which will implement existing Iterator and internally will make use of Stack.  One of the solution suggested in this thread (FlattenIterator  to be precise) is in fact a composite iterator."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"there is no need to use the stack, just push the nested element between current node and next node. something like,"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"So Did you enter google?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Simple DFS Kind of solution for this"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5180373679996928","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"3","title":"Given a line length insert white space so text is uniformly displayed within the given length","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"More details."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do you justified text that occupies entire line like in microsoft word?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I guess the question means this: Given the line length 10 and given a word \"hello\" output : \"h e l l o \" --> evenly distributed text"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5665481646145536","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"4","title":"What is mean by non blocking thread safe? Is it different from thread safe blokcing? Code a non blocking thread safe queue in Java","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"For precise definitions you can check books like \"The Art of Multiprocessor Programming\". Otherwise, \"Java Concurrency in Practice\" provides a pretty good idea in Chapter 15.  \"non blocking\" roughly means where threads are not blocked waiting to acquire some lock. Just combine that with what thread-safe means, so you have - code where threads do not wait to acquire some lock and still it works correctly with multiple threads.  Here's an attempt to do this using an AtomicBoolean flag to guard the non-threadsafe queue:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You mean 'non-blocking thread-safe /queue/s'? Is it different from blocking thread-safe /queue/s? Yes, different."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6579701673885696","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"27","title":"You are given an array, divide it into 2 equal halves such that the sum of those 2 halves are equal. (Imagine that such division is possible for the input array and array size is even)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Partition problem .It is similar to finding whether we can get sum/2 value using arr.size()/2 elements. This can be solved using recursion or DP. The recursive Function call will be rec(0,arr.size()/2,sum/2);  where arr is the given array ,  sum is total sum of all values in the array. and memoize is just for avoiding recalculation. If this function returns true then its possible to partition otherwise not."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"StackOverflow question #5898104. There is no great answer there though."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Unlike the general partition  problem, this one asks specifically for two sublists of equal length. At the very least, this allows the problem to be solved in polynomial time, as the untested Python below shows:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This can be done using subset sum problem"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this question asks to divide the array in two equal halves with equal number of elements and equal sum that's why it says that array length is even. If this is the case just sort the array and pick alternate elements. that will give two arrays with equal number of elements and sum."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution in O(n):  Output: 3 1 1 2 2 1 4 9 3 2 9 1 sum(A)38 sum(B)20 sum(C)18"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I gave it a go in javascript.  I assumed that this statement, which is given in an answer above, is correct: ???I think this question asks to divide the array in two equal halves with equal number of elements and equal sum that's why it says that array length is even???  This solution uses bruteforce and it is not optimized."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a C implementation, which is an O(n^2) algorithm, the first step is calc the difference between two array, and then, if the sum of the difference array is not zero, you pick the closet element around the value of half of the total difference, keep going. As long as the partition is possible, you will reach the point that sum difference is zero in at most n steps."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Brute force C++ using recursion, but sped up considerably by sorting the array before hand."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int[] a = {7,5,4,1,1,2}; \n   \n  Arrays.sort(a); \n   \n  int[] a1 = new int[a.length /2]; \n  int[] a2 = new int[a.length /2]; \n   \n  int i =0; \n  int j = a.length -1; \n   \n  boolean b = true; \n  int k1 =0; \n  int k2 =0; \n  while(i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can use either dfs + memorization or 3d DP to resolve the issue. The time complexity is O((n^2)sum), while sum is the sum of all elements in the array.   I don't think this one have O(n*sum) solution -- unless we remove the restriction of evenly splitting the array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the problem of partitioning array in equal halves with minimum sum difference I think can be solved in O(NlogN)+O(N) time. first sort the array in ascending order. Since length of array is even, assign value with odd index to set #1, value with even index to set #2. increase iterative step by two and apply reverse process."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A brute force solution in Java, where we create all possible subsets of array.length/2 size until we find sum = sum(array)/2 or all sets were evaluated"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Find sum, say S 2. find all subsets 3. select ones with length n/2 where n is number of elements in first array 4. from list in 3 select one whose sum matches S/2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A solution in n + n*logn. Sort the array descending. Take each input element and add it to the half that has it's missing average closer to it. missing average means: sum required to reach the target value divided by the number of empty slots."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"An O(n^2) solution. 1)Find the sum of elements of entire array 2)Based on the given assumption now find the subset of elements which add upto sum/2. 3)print the elements that are in subset as 1st half and print the elements that are not as 2nd half.  There is a dynamic programming algorithm for finding the subset in O(n^2) time.So the time complexity could be O(n^2).  Another way is to use backtracking which would be O(2^n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-4","title":"main() \n{ \n    printf(\"Hello World\") \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5747769461440512","download_status":"DOWNLOAD_DONE","votes":"3","answersCount":"25","title":"Given an integer, find the next highest and next lowest integers, with equal number of 1s in their binary representation as the original number.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming a long int here. I excluded the highest and the lowest bit (boundaries). For the rest, a simple bit shift will work I guess. Am I missing something here?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simply count the number of 1-bits in the word. Let their number be n. The highest integer would be the one with n 1s in the more significant positions and the lowest integer would have n 1s in the less significant positions."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My approach would be, in order to get the next higher int, to switch the lowest '1' with the next higher '0'  Here the c# code for writing the next higher int:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's some code  Wrote for next larger number, sure you can do the something similar for next smaller, didn't write it yet."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is some code for nextSmallest integer with the same number of set bits"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Few observations: 1) A number and two times of this number have the same number of 1's (multiplying shifts bit pattern by a position towards left) 2) By point 1, half of a number will also be having same number of 1's (except for those patterns which are all 1's) 3) For numbers whose bit pattern is all 1's no solution possible for \"lesser than\" case  A simple approach is (a) for highest number, loop over numbers from N to 2*N. Get bit representation of each number in the loop, compare number of 1's. Stop at the first match. (b) for lowest number, loop over numbers from N to N/2, get bit representation for each, compare number of 1's. Stop at the first match.  Complexity will be O(N*logN) : loop will iterate atmost N times, fetching bit representation is O(logN), comparing counts of 1's also O(logN)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Number Properties Approach for Next Number Observations: ??If we ??£þturn on??? a 0, we need to ??£þturn off??? a 1 ??If we turn on a 0 at bit i and turn off a 1 at bit j, the number changes by 2^i - 2^j. ??If we want to get a bigger number with the same number of 1s and 0s, i must be bigger than j.  Solution: 1. Traverse from right to left. Once we??ve passed a 1, turn on the next 0. We??ve now increased the number by 2^i. Yikes! Example: xxxxx011100 becomes xxxxx111100 2. Turn off the one that??s just to the right side of that. We??re now bigger by 2^i - 2^(i-1) Example: xxxxx111100 becomes xxxxx101100 3. Make the number as small as possible by rearranging all the 1s to be as far right as possible: Example: xxxxx101100 becomes xxxxx100011 To get the previous number, we do the reverse. 1. Traverse from right to left. Once we??ve passed a zero, turn off the next 1. Example: xxxxx100011 becomes xxxxx000011. 2. Turn on the 0 that is directly to the right. Example: xxxxx000011 becomes xxxxx010011. 3. Make the number as big as possible by shifting all the ones as far to the left as possible. Example: xxxxx010011 becomes xxxxx011100"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//with overflow error \nunsigned long long next_largest(unsigned long long n) \n{  \n unsigned long long m = n, x = 0; \n  \n while(true) \n { \n  if( !(n&2) && (n&1) )      \n   return (m & ~(3<>= 1; \n  x++; \n } \n}  \n \n//with underflow error \nunsigned long long next_smallest(unsigned long long n) \n{ \n unsigned long long m = n, x = 0; \n  \n while(true) \n { \n  if( (n&2) && !(n&1) )   \n   return (m & ~(3<>= 1; \n  x++; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why not do simple logic 1. Find out number of 1 bits in number 2. test each number for number of 1 bits if same as original check with min max so far, update if more than max and lower than min  am i missing something here doesn't look me supper complicated as kind of solutions i am seeing"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"only have culculated the nearest high,  public static int getLowestNear(int a){         String binary  = Integer.toBinaryString(a);         //add 0 at the left of the string         binary = \"0\"+binary;         int result = 0;         //if it is odd, then find the first 0 from the right most, position as i,         // then the nearest low is 2^i-2^(i-1)=2^(i-1),i start from 0         //if it is even, then find the first 0 after 1 from the right most, position as i.         // then the nearest low: if has 1 of 1s, 2^i-2^(i-1)=2^(i-1) ;         // if has 2 of 1s, 2^i-2^(i-1)-2^(i-2)+1=2^(i-2)+1 ;         // else 2^(i-1)+1.         if(a<=0) return 0;         if(a%2==1){              for(int i=0;i                int index = binary.length()-i-1;                 if(binary.charAt(index)=='0') {                     result = a+ ((Double)(Math.pow(2,i-1))).intValue();                     break;                 }              }         }else{             int count=0;             int has1count = 0;             for(int i=0;i                int index = binary.length()-i-1;                 if(binary.charAt(index)=='0') {                     if(has1count>0)count++;                     if(count==1) {                         if(has1count==1) {                             result = a+ ((Double)(Math.pow(2,i-1))).intValue();                         }else if(has1count==2){                             result =  a+ ((Double)(Math.pow(2,i-2)+1)).intValue();                         }else{                             result = a+ ((Double)(Math.pow(2,i-1)+1)).intValue();                         }                         break;                     }                 } else{                     has1count ++;                 }             }         }         return result;     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"find number of set bit.  move all at least significant bit for lowest and most significant bit for highest number"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"from graphics.stanford.edu/~seander/bithacks.html#NextBitPermutation :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A solution for the next lower permutation:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here is the algorithm  switch means making 0 to 1 and 1 to zero"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In this problem, we don't have to care about higher digits over the lowest 0, 1 sequence when adding 1 (or smaller numbers) to the number. For example, 11010100 --> 1101 0100 (the lowest 0,1 sequence happens in LSB+3 digit) all we have to do is to find the next highest integer of 0100, and add 1101 on top of it. It is because 01xx pattern can be increased to 10xx pattern and it is guaranteed that we can find 10xx pattern which has the same number of 1's as that of 01xx pattern. (In other words, if we add too big number so that 1101 part is changed, it shouldn't be the next highest number) For example, 0110 --> 1001, 0101 --> 1001.  Notice that we cannot use 01abcd --> 10abcd, as shown in the case 0110 --> 1001. It is because that if we push a sequence of 1s to LSB side, we can get lower number. For example, 011100 --> 101100 (but is this the lowest? No. push 11 to LSB) --> 100011 (now it is the lowest among all 6 digit number starting with 10 and having 3 1s)  Getting the next lowest number is similar. Just 1 and 0 exchanged.  My code is as follows:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/************************************************************** \n** \n**  Auto-generated to help solve interview questions. \n** \n**  Question :  \n    Given an integer, find the next highest and next lowest integers, with \nequal number of 1s in their binary representation as the original \nnumber.  \n**  Carreercup Link: \n    careercup.com/question?id=5747769461440512 \n \n***************************************************************/ \n \n#include  \n#include  \n#include  \n#include  \n \nint next(int x, int high) \n{ \n  int n = x, step=0, count=0, lookfor; \n  if(high) \n      lookfor = 1; \n  else \n      lookfor = 0; \n  while (n ) \n  { \n      if( n % 2 == lookfor) \n          step =1; \n      else if ( step == 1) \n      { \n          break; \n      } \n      n = n / 2; \n      count ++; \n  } \n  if (high) \n    n = x | ( 1 << count--); \n  else \n    n = x & (~( 1 << count--)); \n \n  if(high) \n    n = n & (~( 1 << count)); \n  else \n    n = n | ( 1 << count); \n  return n; \n} \n \n \nint main() \n{ \n  int i; \n   \n  for(i = 1; i <= 100; i++ ) \n  { \n      printf(\" value : Next =  %d  : %d \\n\", i , next(i, 0)); \n  } \n  return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please check \"Next higher number with same number of set bits\" on geeksforgeeks"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5158808112332800","download_status":"DOWNLOAD_DONE","votes":"-6","answersCount":"4","title":"i am working on project and we want to access ASCII value of string at some index But we don't want access chat at index and parse it to integer  Example:- char character = s.charAt(8); int ASCII = (int) character;  is there any other way to do same without converting to char?? and what will be time complexity? is there any built in function in java ? i don't know how char store in memory please anyone can explain me ? and how to handle Unicode without converting to char ??  Thanks!!","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"int ascii=s.charAt(i)-0;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"codePointAt(int index) Returns the character (Unicode code point) at the specified index.  Ref: Check String Class API"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"USE STACKOVERFLOW OR USE THE FORUM ON THIS SITE. STOP POLLUTING THE QUESTIONS HERE."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is it a question google asked???  Anyway, you could convert to byte[] using utf-8 encoding using the string function. If it is ascii string, you could refer any index as it would represent one character. Won't work with 2 byte or 3 byte characters though. What is the specific requirement."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5731487106203648","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"3","title":"How would you model the animal kingdom (with species and their behavior) as a class system?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"By arranging them in a tree order we can easily form the model and if necessary new species can be added."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use factory design pattern"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"by simply defining an interface or by defining an abstract class"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5948026472366080","download_status":"DOWNLOAD_DONE","votes":"-3","answersCount":"0","title":"How would you model the animal kingdom (with species and their behavior) as a class system? Java"}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5464585372958720","download_status":"DOWNLOAD_DONE","votes":"-2","answersCount":"5","title":"How would you model the animal kingdom (with species and their behavior) as a class system?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class animal  //base of all \n{ \nvar parents[],childrens[],species,behaviors[]; //behaviours may contain it is carnivorous or hervivorous , color etc . \nanimal(){ \n} \n~animal() \n{ \n} \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The Animal Family can be broadly classified as below sub categories: > Bird Family > Mammal Family > Insect Family > Fish Family  Animals can be also classified based on many of their characteristics, such as: > Carnivores vs Herbivores > Scavengers > Land vs. Water Animals  > Noctural or Night Animals > Cold Blooded vs Warm Blooded Animals > Vertebrates vs. Invertebrates > Fly / Swim / Run > Number Of Legs"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For me makes sense to reuse all the effort made in taxonomy, I would create:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Animals are mainly categorized into two :   (1)Vertebrates: Animals with backbone (2)Invertebrates:Animals with no backbone (bacteria etc.)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5730055875461120","download_status":"DOWNLOAD_DONE","votes":"-3","answersCount":"0","title":"How would you model the animal kingdom (with species and their behavior) as a class system? (Java)"}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5923505161895936","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"26","title":"what is time complexity of concatenating two int in java example :-  int a=18965; int b=78521369741; after concatenation i want ans in primitive integer data types like,  int c=1896578521369741; i want to know what is the fastest way to do this and what will be the time complexity ?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"The second number in your example is out of range of int type in java. I assume that the result and numbers are in range of int type: Code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"concat(n1,n2)  // Assuming there is no buffer overflow  1. x = number of digits in n2, i:e ceil(log to the base 10 of n2) 2. if(x ==0 ) x = 1; 3. return n1*x +n2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"From Mathworld site:  \" The formula for the concatenation of numbers p and q in base b is p??q=pb^(l(q))+q,  where l(q)=|_log_bq_|+1 \" This is a solution in constant time.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Correct Solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Hi all. I see a lot of O(n) solutions but this problem can actually be solved in O(log n) time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int a=18965;    int b=7852;    String s=Integer.toString(a)+Integer.toString(b);       System.out.println(Integer.parseInt(s));"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n \nint concatenation(int i1, int i2){ \n  \n stringstream ss; \n ss << i1; \n ss << i2; \n \n int result; \n ss >> result; \n \n return result; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"An response in Go"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"in Java. I don't know that much of complexities thing. If anyone can provide me some good tutorials regarding algorithm complexities that will be a great help."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why not toString and then concat two string?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Time complexity depends on rank. We can find rank using binary search because int has manixum number and minimun number. In this case, time complexity is  log(rank(b))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"range of integer is only from 0 to 4294967295 then how can the variable b and c hold values 78521369741 and 1896578521369741 respectively that are declared as integers without proper typecasting?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If we can restrict the arguments to positive integers (likely), this can be done very simply.  The trick is to use a logarithm:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-6","title":"STOP POSTING YOUR F***KING HOMEWORK."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6613080834310144","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"8","title":"You're given a machine (Let's say a sprinkler). The machine is controlled with a software component that has UI. The user can set different parameters in the UI. for example : 'speed' : 120 'pressure' : 30 Change the system so it will accept an arithmetical expression in the UI. The expression can contain constants, parameters (e.g 'speed') and operators.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"More details please..were you expected to solve an arithmetic equation of type 10A+20B = X etc?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am assuming that it would be expecting expressions say: P+30 (exceed pressure by 30 P) S-10 (reduce speed by 10) and so on..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ya @amitpetkar ji, for that we need to put some constant value for s and p right? so that we can exceed or reduce the speed n pressure by giving the expression as u noted, p+30..but its not user friendly at any way.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Moreover there should be a global way of storing them, you may want to remember the earlier state of the system before actually executing the newer values. Perform sufficient checks to ensure that pressure and speed are always positive at any given time (real time scenario). If the state of the system changes to negative values after performing the operation we may simple raise error."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It's a calculator and need compling technique. Use yacc to generate the lexical and grammar parsers. 'Parameters' are variables(look it up in a global symbol table), and reserve operators and write regular expressions for constants."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The intent of the problem is probably for you to implement a shunting-yard algorithm to convert an arithmetic expression from in-fix to post-fix and then to evaluate the post-fix expression. Quite a tricky exercise for a short interview, although standard material from a CS degree."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5197964926517248","download_status":"DOWNLOAD_DONE","votes":"4","answersCount":"17","title":"You need to develop the game Snake. What data structures will you use? Code your solution.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"Two parts: 1. 2D plate: 2D array of short, 0 for free, 1 for items to eat, 2 for blocks (including snake body); 2. Snake body: Queue of int pair indicating position like (x, y), every move enqueue new head position and dequeue tail position. Enqueue two nodes if a item eaten. Enqueue and dequeue operation includes set flag in its pixel.  For every move, only constant time (O(1)) needed."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"One very simple one comes my mind is a 2-D matrix (let's say initialized with 0s).   We keep track of head, tail and length of snake.  if head is in Right direction and so is Tail - you increment [i, n+1] col to 1 and [i, n-1] col to 0 -> to signify that snake has travelled in right direction.   if head is in Down direction and so is Tail - make [n+1, j] to 1 and [n-1, j] to 0  interesting things happen when Snake makes a turn. You can store the history of all turns made by snake. Let's say at any point in Matrix P(bendRow, bendCol) when snake was travelling left-to-right, it makes a down turn. You change direction of 'Head' to Down, but direction of 'Tail' remains the same i.e. Right. So now when snakes moves forward, you change [i, bendCol+1] as 1 and [bendRow-sankeLength-1, j]. When 'Tail' passes over P(bendRow, bendCol), you delete that point.  Sanke die events - If head hits any of the matrix boundaries or lands up on a cell with 1 (i.e. sanke body still exists there)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I'll go for a double linked list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I will use the following data structures for it:  Grid: Array of nxn  Snake: Queue to hold the head position and all other positions where the snake made a turn. The positions are en-queued when the head makes a turn and de-queued when the tail reaches it. This will also involve a special functionality to update the position of the head.  Items that the snake eats: A linked list"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using LinkedList data structure. At each movement, delete the first node and add a new node at the end."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. We can have Array of int Board[99] for the Board. 2. Hash Map data Structure - Snakes. Key value pairs Where Key will be Head of the Snake and corresponding Value will be Tail of the Snake 3. Hash Map data Structure - Ladders. Key will be Starting point of Ladder and value will be end point of Ladder"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My snake is a  double linked list of points. I used double linked list in order to append a new element in O(1). I have used java.util.LinkedList which is double linked list implementation. Game is over whenever end point hits the borders."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution documented here: amitcodes.com/2014/01/26/design-the-nokia-snake-game/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package google; \n \nimport java.util.HashMap; \nimport java.util.LinkedList; \nimport java.util.ListIterator; \n \npublic interface SnakeGame \n{ \n void move(direction dir) throws Exception; \n void eat(Node head) throws Exception; \n int getScore(); \n} \n \nenum direction \n{ \n RIGHT, \n LEFT, \n UP, \n DOWN \n} \n \nclass Node \n{ \n public direction dir; \n public int xPos; \n public int yPos; \n} \n \nclass SnakeGameImpl implements SnakeGame{ \n  \n private LinkedList snake; \n private HashMap boundary; \n  \n \n public SnakeGameImpl(int xlength, int ylength, Node animal) \n { \n  for(int i=0; i itr = snake.listIterator(); \n  while(itr.hasNext()) \n  { \n   cur = itr.next(); \n   if(bitesItself(cur, head)) \n    throw new Exception(\"You've bite yourself, game over!!! \"); \n   cur.xPos = prev.xPos; \n   cur.yPos = prev.yPos; \n   cur.dir = prev.dir; \n   prev = cur; \n  } \n } \n  \n @Override \n public void eat(Node head) throws Exception \n { \n  Node animal = generateAnimalAtRandomPosition(); \n   \n  if(animal.xPos==head.xPos && animal.yPos==head.yPos) \n  { \n   Node last = snake.peekLast(); \n   Node addn = new Node(); \n   addn.xPos = last.xPos; \n   addn.yPos = last.yPos; \n   addn.dir = last.dir; \n   snake.add(addn); \n   if(bitesItself(addn, head)) \n    throw new Exception(\"You've bite yourself, game over!!! \"); \n  } \n } \n  \n private Node generateAnimalAtRandomPosition() { \n  // generate animal node at random position \n  return new Node(); \n } \n \n private boolean bitesItself(Node node, Node head) \n { \n  return node.xPos == head.xPos && node.yPos == head.yPos; \n } \n  \n private boolean hitsWall(Node node) \n { \n  return boundary.get(node.xPos)==node.yPos; \n } \n  \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5642030185185280","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"Provide a system design for real world URL shortener (solution must scale to millions of users). Back up your assumptions with real numbers.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"While shortening the URL:  Store the Long URL in a DB table which has an auto-generated identity column (increments by 1 each record)  Next write an algorithm to convert the integer ID of this database record in to a base 62 number and then represent the number in base62: where a-z are mapped to 0-25 A-Z are mapped to 26-51 and 0-9 are mapped to 52-61  essentially we want to say that the shortened URL would contain a-z; A-Z and/or 0-9 characters only"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"something like that:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am thinking about two big hashmaps.   One maps the long URL to the short one. The other maps the short one to the long one.  For each long URL, do the hash with SHA or something, if found in the map A, return the short URL. If not found, generate a new seq number (the latest + 1), convert this seq number to a string containing a-z0-9. For 6 char short URL, it supports 36^6 = 2.1 billion URL address. If adding chars like \"_-\", 38^6=3 billion"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Please, could you clarify question about shortener."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5104572540387328","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"58","title":"Given a sorted array of integers, write a function that will return the number with the biggest number of repetitions.  (Asked to refine the solution to be more efficient)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"A solution with O(n) time complexity and O(1) space complexity. Logic:1) maintain 4 variables called count and element element,max count,max element.Initialise count to 1 and maximum element to 1st element of array. 2) while traversing if the element is same as maximum count then increment count by one. 3)Else decrement count.If count reaches zero then assign maximum element to the element at which count became zero and reinitialise the variables"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Below is the java code solution The first method time complexity is: ???(n) The second method average time complexity is: ???(logn) :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"This solution is based on the idea of skipping forward by a length equal to the most number of repeats seen so far."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Biggest {   public static void main(String args[])  {   int []  a ={1,2,2,3,3,3,3,5,6,6,6,6,6,6,6,7,8,8,8};      int prevnum =a[0];   int count =0;   int maxrepvalue =a[0];   int maxrepcount =0;   for (int  i =0;i  {        prevnum = a[i];    if(prevnum ==a[i+1])    count ++;    else    {     if(count >maxrepcount)     {      maxrepvalue=prevnum;      maxrepcount =count;     }          count=0;    }              }   System.out.println(maxrepvalue +\">>\" +(maxrepcount+1));        }   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just start to count when coming across a different number, the code is easy:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Refer to skip list?? always try to skip K numbers to avoid unnecessary scan, if encounter a different number, then backward........"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void main(){ \n \n  int i,j; \n  int arr[] = {1,2,2,2,4,4,4,48,48,48,48,48,48,48,48}; \n  int length = 14; \n  int index,count=1,findex,fcount=-1; \n  for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include   int main() {  int a[] = {1,1,1,1,1,1,1, 2, 2, 2, 3 ,4, 5, 5 , 5 ,5 ,5 };  int n = sizeof(a)/sizeof(a[0]);   int num, max_repeat = 1;  int prev = a[0];  int rep = 1;  int i;  num = a[0];   for (i=0;  i < n; i++)  {   if (a[i] == prev)   {    rep++;   }   else   {    if (rep > max_repeat)    {     num = prev;     max_repeat = rep;    }    rep = 1;   }   prev = a[i];  }   if (rep > max_repeat)  {   num = prev;   max_repeat = rep;  }   printf (\"Number with max repeatations = %d \\n\", num ); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n \nusing namespace std; \n \nint evalMaxRepeatElem(int *array, int num_Elem){ \n int maxcount = 1; \n int i = 0, count = 0; \n int repeatElem = array[0]; \n while( i maxcount) \n   repeatElem = array[i-1]; \n  } \n return repeatElem; \n} \n \nint main(){ \n int array[] = {1,1,1,1,2,3,3,3,5,5,5,5,5,5,7,7,7,7,7,7,7,7,7,7,7,8,9,9}; \n int maxRepeatElement; \n  \n maxRepeatElement = evalMaxRepeatElem(array, sizeof(array)/sizeof(array[0])); \n cout<<<\"\\n\"; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's a short Implementation in Python"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In Go"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For sorted:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n) complexity with no additional space"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void LargeRepetations(int[] arr) \n        { \n            int len = arr.Length; \n            int mostFreq = arr[0]; \n            int largeFre=1; \n            int currentFre = 1; \n             \n            for (int i = 1; i < len; i++) \n            { \n                if (arr[i-1]!=arr[i]) \n                { \n                    currentFre = 1; \n                } \n                else \n                { \n                    currentFre++; \n                } \n                if (largeFre < currentFre) \n                { \n                    largeFre = currentFre; \n                    mostFreq = arr[i]; \n                } \n                 \n            }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include void main(){  int a[] = {2,7,9,7,5,7,0,9,4,3,5,7};    int i,j,max=0,number,k;    for(i=0;i<12;i++){     number=1;     for(j=i+1;j<12;j++){        if(a[j]==a[i])           number++;       }       if(number>max){          k=a[i];        max=number;       }    }    printf(\"MAximum occurence of a number is: %d and the number is %d\", max,k);    getch(); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) { \n  int[] intArray= { 1, 1, 1, 1, 2, 3, 3, 3, 4, 5, 5, 5, 5, 5, 5, \n    5, 5, 5, 5, 6, 6, 6, 6, 7, 8, 9, 9, 9, 9, 9, 10, 11, 12, 12, \n    12, 13, 13, 13, 13, 13, 13, 13, 22, 23, 24, 32, 33, 35, 36, 55, \n    55, 55, 55, 55, 56, 56, 57, 58, 59, 59, 59, 60, 65, 65, 65, 65, \n    65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 66, 66, \n    66, 67, 67, 68, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, \n    70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, \n    70, 70, 71, 72, 72, 72, 72, 72, 72, 72, 72, 72, 80, 80, 85, 86 }; \n  int count=0; \n  int pricount=0; \n  int currentNo=intArray[0]; \n  int maxInt=0; \n  int i=0; \n  for(int no:intArray){ \n   if(no==currentNo){ \n    count++;  \n   }else{ \n    if((count>pricount)){ \n       pricount=count; \n       maxInt=currentNo; \n    }    \n    count=1; \n    currentNo=no; \n   } \n    i++; \n   } \n  if((i==intArray.length)){ \n   if(count>pricount){ \n     pricount=count; \n     maxInt=currentNo; \n   } \n         System.out.println(\"Maxi int :\"+maxInt +\" and count : \" +pricount); \n         \n   } \n  // TODO Auto-generated method stub \n \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What should be the complexity for the following, as this seems like the easiest approach to me: HashMap test = new HashMap<>();   Integer[] array = {1,2,3,1,1,3,2,2,2,2};   int maxKey =0;   int maxValue=0;   int newCounter =0;   for (Integer check: array)   {    if (!test.containsKey(check))    {     test.put(check, 1);     System.out.println(\"FIRST key:\"+check+\" counter:\"+1);    }    else    {     newCounter=test.get(check)+1;     test.put(check, newCounter);     if (newCounter>maxValue)     {      maxValue=newCounter;      maxKey=check;     }     System.out.println(\"key:\"+check+\" counter:\"+test.get(check));    }      }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int maxCount(int a[]){ \n int maxCount = 0; \n int count = 0; \n for(int i = 1; i < sizeof(a); i++){ \n  if(a[i] == a[i-1]){ \n   count ++; \n  } \n  else{ \n   if(maxCount < count) \n    maxCount = count; \n   count = 0; \n  } \n } \n return maxCount+1;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int maxRepetitionCount =0; \n  int maxRepetitiveElement =0; \n  int tmp =0; \n  for(int i =0; i< a.length-1;i++) { \n   if(a[i+1] == a[i]) { \n    tmp++; \n   }else if( tmp > 0) { \n    //Repetition sequence ends \n    if(tmp > maxRepetitionCount) { \n     maxRepetitionCount = tmp; \n     maxRepetitiveElement = a[i]; \n      \n     if(maxRepetitiveElement > (a.length-1 -i)) { \n      //Not enough elements left to overcome this value \n      tmp =0; \n      break; \n     } \n    } \n    tmp =0; \n   } \n  } \n \n  //if max repetiting element is the last element \n  if(tmp > maxRepetitionCount) { \n   maxRepetitionCount = tmp; \n   maxRepetitiveElement = a[a.length -1]; \n  } \n   \n  System.out.println(maxRepetitiveElement+\"  \"+(++maxRepetitionCount));"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Python one-liner:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This one has also o(n) as worst case (when the largest run is very small, e.g 2). however, it gets much better as runs grow. For example, a run of size 200 in an array of size 1000 would require only ~50 comparisons. A run of size 60 in the same array requires ~150."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) { \n \n  int[] testArr = new int[] { 1,1, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9 \n \n  }; \n \n  int maxFreq = 0; \n  int currentFreq = 0; \n  int max = testArr[0]; \n \n  for (int i = 1; i <= testArr.length - 1; i++) { \n \n   currentFreq++; \n    \n   int prev = testArr[i-1]; \n   int next  = testArr[i]; \n \n   if (prev != next || (i == testArr.length - 1)) { \n \n    if (maxFreq <= currentFreq) { \n     max = testArr[i-1]; \n     maxFreq = currentFreq; \n    } \n \n    currentFreq = 0; \n \n   } \n  } \n \n  System.out.println(\"Max freq \" + maxFreq + \" Number \" + max); \n \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i don't think dividing with binary can help as you still need to scan whole array. Here is my take on this. it will skip k where k is max known so far. So its best will be o(n/k) and worst will be O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int most_freq(const int *i, const int size) \n{ \n if(0 == size) return -1; \n int count = 1; \n int m; \n int prev = i[0]; \n int highest_count = count; \n int retVal = i[0]; \n for(m=1; m highest_count) \n   { \n    highest_count = count; \n    retVal = i[m]; \n   } \n  } \n  else \n  { \n   prev = i[m]; \n   count = 1; \n   if(i[m + highest_count -1 ] == prev) \n   { \n    count = highest_count; \n    m+=highest_count-1; \n   } \n  } \n } \n return retVal; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include main() {       int i , j, a[20], n, count =0, maxrepeat=0,maxrepeatvalue;         printf(\"entr the size of array \");     scanf(\"%d\", &n);   printf(\"enter the element\");      for(i=0;i  {                    scanf(\"%d\",&a[i]);                                        }             for(i=0;i  {                 for(j=i+1;j  {                       if(a[i]==a[j]){                                     count++;}                     else                     {                        if (count >  maxrepeat)                    {                              maxrepeatvalue=a[i];                              maxrepeat=count;                               count=0;                               }                               }                                      }                   }                   printf(\"total count =%d \\n maximum repeated number %d\\n\", maxrepeat+1, maxrepeatvalue);                   getch();                   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include main() {       int i , j, a[20], n, count =0, maxrepeat=0,maxrepeatvalue;         printf(\"entr the size of array \");     scanf(\"%d\", &n);   printf(\"enter the element\");      for(i=0;i  {                    scanf(\"%d\",&a[i]);                                        }             for(i=0;i  {                 for(j=i+1;j  {                       if(a[i]==a[j]){                                     count++;}                     else                     {                        if (count >  maxrepeat)                    {                              maxrepeatvalue=a[i];                              maxrepeat=count;                               count=0;                               }                               }                                      }                   }                   printf(\"total count =%d \\n maximum repeated number %d\\n\", maxrepeat+1, maxrepeatvalue);                   getch();                   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include main() {       int i , j, a[20], n, count =0, maxrepeat=0,maxrepeatvalue;         printf(\"entr the size of array \");     scanf(\"%d\", &n);   printf(\"enter the element\");      for(i=0;i  {                    scanf(\"%d\",&a[i]);                                        }             for(i=0;i  {                 for(j=i+1;j  {                       if(a[i]==a[j]){                                     count++;}                     else                     {                        if (count >  maxrepeat)                    {                              maxrepeatvalue=a[i];                              maxrepeat=count;                               count=0;                               }                               }                                      }                   }                   printf(\"total count =%d \\n maximum repeated number %d\\n\", maxrepeat+1, maxrepeatvalue);                   getch();                   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include main() {       int i , j, a[20], n, count =0, maxrepeat=0,maxrepeatvalue;         printf(\"entr the size of array \");     scanf(\"%d\", &n);   printf(\"enter the element\");      for(i=0;i  {                    scanf(\"%d\",&a[i]);                                        }             for(i=0;i  {                 for(j=i+1;j  {                       if(a[i]==a[j]){                                     count++;}                     else                     {                        if (count >  maxrepeat)                    {                              maxrepeatvalue=a[i];                              maxrepeat=count;                               count=0;                               }                               }                                      }                   }                   printf(\"total count =%d \\n maximum repeated number %d\\n\", maxrepeat+1, maxrepeatvalue);                   getch();                   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include main() {       int i , j, a[20], n, count =0, maxrepeat=0,maxrepeatvalue;         printf(\"entr the size of array \");     scanf(\"%d\", &n);   printf(\"enter the element\");      for(i=0;i  {                    scanf(\"%d\",&a[i]);                                        }             for(i=0;i  {                 for(j=i+1;j  {                       if(a[i]==a[j]){                                     count++;}                     else                     {                        if (count >  maxrepeat)                    {                              maxrepeatvalue=a[i];                              maxrepeat=count;                               count=0;                               }                               }                                      }                   }                   printf(\"total count =%d \\n maximum repeated number %d\\n\", maxrepeat+1, maxrepeatvalue);                   getch();                   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  int count(int[],int); int max = 1; int tempmax = 1; int count(int a[],int size){   for(int i=0;i {      if(a[i]==a[i+1])   max++;   else   {    printf(\"\\n [ %d ]-> %d\",a[i],max);    if(max>tempmax)    {     tempmax = max;     max = 0;    }            }  }  if(max>tempmax)  return max;  else  tempmax;   }    int main() {  int arr[] = {1,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5};  int maxcount = count(arr,(sizeof(arr)/sizeof(int)));  printf(\"\\n highest -> %d\",maxcount); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Cant we have Map with key as the number and value as the number of times it is in the list?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package com.tutorial.sorting; \n \npublic class GetMaxNumberRepeatedTest { \n  \n public static void main(String[] args) { \n  GetMaxNumberRepeatedTest gmrt = new GetMaxNumberRepeatedTest(); \n  int[] testList1 = new int[]{1}; \n  int[] testList2 = new int[]{1,2,3,4}; \n  int[] testList3 = new int[]{1,2,2,3,4,4,5,5,5,6,6,6,7}; \n  int[] testList4 = new int[]{1,2,2,3,3,3}; \n   \n  System.out.println(\"==========================================\"); \n  System.out.println(\"\\t Get Number Repeated Most Times \\t\"); \n  System.out.println(\"==========================================\"); \n  System.out.println(\"Test Case 1: Expected: -1 Actual: \" + gmrt.getMaxNumberRepeated(testList1)); \n  System.out.println(\"Test Case 2: Expected: -1 Actual: \" + gmrt.getMaxNumberRepeated(testList2)); \n  System.out.println(\"Test Case 3: Expected: 5 Actual: \" + gmrt.getMaxNumberRepeated(testList3)); \n  System.out.println(\"Test Case 4: Expected: 3 Actual: \" + gmrt.getMaxNumberRepeated(testList4)); \n } \n  \n public int getMaxNumberRepeated(int[] listSorted) { \n  // Base Case \n  if(listSorted.length < 2) { \n   return -1; \n  } \n  int countMaxRepeated = 0; \n  int itemMaxRepeated = -1; \n  int countCurrentRepeated = 0; \n  int itemCurrentRepeated = -1; \n   \n  for(int i=1; i < listSorted.length; ++ i) { \n   if(listSorted[i] == listSorted[i-1]) { \n    itemCurrentRepeated = listSorted[i]; \n    ++ countCurrentRepeated; \n   } \n   else { \n    countCurrentRepeated = 0; \n   } \n   if(countCurrentRepeated > countMaxRepeated) { \n    countMaxRepeated = countCurrentRepeated; \n    itemMaxRepeated = itemCurrentRepeated; \n   } \n  } \n \n  return itemMaxRepeated; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"int findRepetition(int[] array){ \n int ans = -1, count = 0, prevMax=0; prevNumber = Integer.MAX; \n  for(int i= 0; i< array.length; i++){ \n if(prevNumber == array[i]){ \n  count++; \n     } \n else{ \n  if(count >= prevMax){ \n   ans = prevNumber; \n   prevMax = count; \n   } \n prevNumber = array[i]; \n count = 1; \n } \n  } \n return ans; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5940697714655232","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"11","title":"Given a board made of 2 x n squares, and boards made of 2 x 1 squares, write a function that will calculate the number of possible ways to arrange the 2 x 1 boards on the 2 x n board, in a way that will fill it completely.   (Asked to refine the solution to be more efficient)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"10","title":"At first it seems like a dynamic programming type of problem but looking more closely it reduces to the simple problem of finding the nth Fibonacci number. Denote by f(n) the number of possibilities to tile a 2xn board.  Consider tiling a 2xn board for some n>2. Let us sort all the possibilities according to the last 2 columns. There are f(n-1) possibilities where the last column includes a single tile and there are f(n-2) possibilities where the last 2 columns include 2 horizontally placed tiles. This covers all possibilities and hence: f(n) = f(n-1) + f(n-2) which is exactly the nth Fibonacci number.  The common iterative O(n) solution for finding the nth Fibonacci number is as follows:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Please clear my doubt. Are all arrangements unique? What I mean it consider a 2x3 board, there can be 2 unique ways of arranging 2x1 tiles. However, you can also do another ways if you consider all arrangements unique.   _____ |   |___| I_ |___|  is same as  _____ |___|   | |___| _|"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I din't understand why f(3) is not 24: here are all the possibilities:  If I'm right the formula to f(n) is f(n)=n*2*f(n-1), or I'm missing something?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the solution would be F(n) = int(n/2) * (n+1)  Every 2x2 block on the board will result in 2 ways.. and in 'n' is odd, we need to place one more block which has n + 1 options.  Can anyone please tell me if this doesn't work in any case?  Thank you."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"f(1) = 1 + (1-1)+ (1-1) = 1 f(2) = 2 + (2-1)+ (2-1) = 4"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It's a combination problem  for i from 0 to [n/2]  sum = 0  sum = sum + Combination (pick n-2*i elements from n-i elements)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6538761173204992","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"7","title":"Design a Rubik's Cube, including backend database portion.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What do you mean by backend database portion? Since a cube has 6 faces, each face has 9 squares, can we just represent it by an array that's 54 items in length?  a[i] can have color of the element i.  (Using 1 as starting index for simplicity) a[1-9] = face1, a[10-18] as face2 and so on."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For a 3x3x3, we have 27 smaller cubes  1 at the center, no color 6 at the center of each face, 1 color  8 corners, 3 colors  Remaining 12 with 2 colors  That sums up to 54."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since they asked Rubiks cube I believe we can leave out the center 1/ 27 cube. Basically we divide a cube into  6 centers 8 corners 12 edges  But this is only the numbers of squares visible now we have to account for filling the six colors.  So an array of (3x3) x6 should be sufficient to hold a cube configuration."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"with reference to stackoverflow 500221. here is a DS"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6486723970203648","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"23","title":"Write a program to return list of words (from the given list of words) that can be formed from the list of given characters. This is like Scribble game. Say for example the given characters are ('a' , 'c' , 't' } and list the words are {'cat', 'act', 'ac', 'stop' , 'cac'}. The program should return only the words that can be formed from given letters. Here the output should be {'cat', 'act', 'ac'}.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"import java.util.ArrayList; \nimport java.util.List; \n \n \npublic class GoogleQuestion1 { \n \n public static void main(String[] args) { \n  byte[] letters = { 'a', 'c', 't' }; \n  String[] words = { \"cat\", \"act\", \"ac\", \"stop\", \"cac\" }; \n  List tempList = new ArrayList(); \n  String tempword = \"\"; \n  for (String x : words) { \n   tempword = x; \n   for (byte z : x.getBytes()) { \n    tempList.add(z); \n   } \n   for (byte z : letters) { \n    tempList.remove((Object) z); \n   } \n   if (tempList.size() == 0) { \n    System.out.println(tempword); \n   } \n \n  } \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"(1)count the times each character can be used. (2)check each word's character use, if within limit, the word can be formed. C++ Code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"python solution :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"and in the above code if you also want those values which have multiple occurrence of a particular letter. Example : acc,cattt,etc then replace"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.lang.*; \nimport java.util.*; \nimport java.io.*; \npublic class Main { \n public static void main(String args[]){ \n  Scanner inp = new Scanner(System.in); \n  char dict[] = {'a','c','t'}; \n  String words[] = {\"cat\",\"act\",\"ac\",\"stop\",\"cac\"}; \n   \n  for(String str:words){ \n   Hashtable counter = new Hashtable(); \n   for(char c:dict){ \n    if(counter.contains(c)){ \n     counter.put(c, counter.get(c) +1); \n    } \n    else{ \n     counter.put(c, 1); \n    } \n   } \n   boolean cannotbe=false; \n   for(char c:str.toCharArray()){ \n    if(counter.get(c)==null){ \n     cannotbe = true; \n     break; \n    } \n    else{ \n     if(counter.get(c)==0){ \n      cannotbe = true; \n      break; \n     } \n     else{ \n      counter.put(c, counter.get(c)-1); \n     } \n    } \n   } \n   if(!cannotbe){ \n    System.out.println(str); \n   } \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static ArrayList getValidWords(String[]sIn, char[] chars ){ \n  //set up a boolean array and init all to false   \n  Boolean[] charList = new Boolean[128]; \n  for (int i = 0; i < charList.length; i++) { \n   charList[i]= false; \n  } \n  //set valid char to true \n  for(char c: chars){ \n   charList[c]= true; \n  } \n  ArrayList sOut = new ArrayList<>(); \n   \n  // Check each char in each word with the valid chars \n  for(String word: sIn){ \n   Boolean validWord = true; \n   for(char x: word.toCharArray()){ \n    if(charList[x] == false){ \n     //found InValid char break the inner for loop \n     validWord = false; \n     break; \n    } \n   } \n   //if all valid char add the word to output \n   if(validWord) \n    sOut.add(word); \n  } \n  //System.out.println(sOut); \n  return sOut; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is similar to question id=5518949642928128, may be easier."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void Test6486723970203648() \n    { \n    char sym[] = {'a', 'c' , 't'};                            \n          std::set chrs(sym, sym + sizeof(sym));  \n          char* arr[] = {\"cat\", \"act\", \"ac\", \"stop\" , \"cac\" };       \n    int result = 0; \n     \n    for( size_t i = 0; i < _countof(arr); i++)                 \n    { \n     size_t length = ::strlen(arr[ i ]); \n \n     if( sizeof(sym) >= length ) \n     { \n                  char tst[255] = {'\\0'}; \n \n         for( size_t j = 0; j < length; j++ ) \n         { \n                    char& chr = arr[ i ][j]; \n \n        if( chrs.find( chr ) == chrs.end()  \n                       || '\\0' != tst[ chr ] )           // word should not use symbol twice \n        { \n         length = 0x00; \n         break; \n        } \n                    tst[ chr ] = chr; \n            } \n         if( 0x00 != length ) \n         { \n          std::cout << arr[i] << std::endl; \n          result++; \n         } \n              } \n    } \n          CPPUNIT_ASSERT_EQUAL_MESSAGE( \"successed\", 3, result ); \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"function scribble($realwords = array(), $characters = array()) { \n    $output = array(); \n    foreach ($realwords as $realword) { \n        $l = strlen($realword); \n        for ($i = 0; $i <= $l-1; $i++) { \n           if (!in_array($realword{$i}, $characters)) { \n               break(2); \n           } \n        } \n        $output[] = $realword; \n    } \n    return $output; \n} \n \nprint_r(scribble(array('cat', 'act', 'ac', 'stop', 'cac'), array('a', 'c', 't'))); \n \n/* \nArray \n( \n    [0] => cat \n    [1] => act \n    [2] => ac \n) \n*/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Yet another solution in Java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution in C :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void getWords(String [] words , char [] chs ){ \n  boolean [] dp = new boolean [256]; \n  boolean flag = true; \n  for (int i =0 ;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) For given letters, create Hashmap (lets call it master map ) 2) For each word in list -  for each char in the word   - check if char exist in master map, if not skip   - if yes, then insert entry in local map, if entry exist then   match count, in case of mismatch, skip.  add to valid list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def scribble(words, letters): \n  \n    from itertools import ifilter, imap \n    from itertools import permutations, combinations, chain \n     \n    # Generate all substrings  \n    sub = (imap(lambda x: \"\".join(x), combinations(letters, i))  \n           for i in xrange(1, len(letters)+1)) \n     \n    substring_list = chain(*sub) \n \n    def legit_words(letters): \n        \"\"\" Return the set of words that can be expressed using 'letters'\"\"\" \n        all_possible_words = imap(lambda x: \"\".join(x), permutations(set(letters))) \n        matches = set(ifilter(lambda x: x in words, all_possible_words)) \n         \n        return matches \n     \n    return reduce(set.union, imap(legit_words, substring_list)) \n                 \nwords = set(['cat', 'act', 'ac', 'stop' , 'cac']) \nletters =\"actactastop\" \nassert scribble(words, letters) == set(['cat', 'act', 'ac', 'stop'])"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What about sorting ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the question is not clear/ proper. What if some of the words which contain repeated letters form proper word. For example if letters are { 'a','c','n','o','u','t'}.  \"account\" is a valid word which contains letter c two times.,"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"If the dictionary contains many words and it is extenssively searched, a tria based solution may be the most efficient solution.   The search function should get a tria node and a set of possible letters (\"act\"). It should check if there is a sub node for \"a\", \"c\" and \"t\". Suppose we found a sub node for \"c\", then the sub node should be searched for the ramaining letters \"at\".   The efficiency of such implementation depends only on the number of letters and does not depend on the number of words in the dictionary.   Here is a sample main:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5154240347504640","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"8","title":"Implement a circular queue of integers of user-specified size using a simple array. Provide routines to initialize(), enqueue() and dequeue() the queue. Make it thread safe.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"public class CircularQueue { \n private int[] data; \n private int front; \n private int rear; \n private int size; \n private int count; \n \n public CircularQueue(int capacity) { \n  intialize(capacity); \n } \n \n public synchronized void intialize(int capacity) { \n  size = capacity; \n  data = new int[size]; \n  front = 0; \n  rear = -1; \n  count = 0; \n } \n \n public synchronized void enqueue(int value) throws Exception { \n  if (count >= size) { \n   throw new Exception(\"Queue overflow\"); \n  } \n \n  if (rear == size - 1) { \n   rear = -1; \n  } \n \n  data[++rear] = value; \n  count++; \n } \n \n public synchronized void dequeue() throws Exception { \n  if (count <= 0) { \n   throw new Exception(\"Queue is Empty\"); \n  } \n \n  if (front == size - 1) { \n   front = 0; \n  } else if (front == rear) { \n   front = 0; \n   rear = -1; \n  } else { \n   front++; \n  } \n  count--; \n } \n \n /** \n  * For testing purpose only - Prints the values in the Queue \n  */ \n public void printQueue() { \n  if (front <= rear) { \n   for (int i = front; i <= rear; i++) { \n    System.out.print(data[i] + \" -> \"); \n   } \n  } else if (count > 0) { \n   for (int i = front; i < size; i++) { \n    System.out.print(data[i] + \" -> \"); \n   } \n   for (int i = 0; i <= rear; i++) { \n    System.out.print(data[i] + \" -> \"); \n   } \n  } \n  System.out.println(); \n } \n \n public static void main(String[] args) throws Exception { \n  CircularQueue cq = new CircularQueue(5); \n  cq.enqueue(1); \n  cq.enqueue(2); \n  cq.enqueue(3); \n  cq.enqueue(4); \n  cq.printQueue(); \n \n  cq.dequeue(); \n  cq.enqueue(5); \n  cq.enqueue(6); \n  cq.printQueue(); \n } \n} \n \nOutput: \n1 -> 2 -> 3 -> 4 ->  \n2 -> 3 -> 4 -> 5 -> 6 ->"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Classic producer consumer bounded buffer problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class CircularQueue { \n \n private E[] queue; \n private int size; \n private int head,tail; \n \n public CircularQueue(int size){ \n  this.head = 0; \n  this.tail = 0; \n  this.size = size; \n  this.initialize(size); \n } \n  \n @SuppressWarnings(\"unchecked\") \n public void initialize(int size){ \n  this.setQueue((E[]) new Object[size]); \n  this.head = 0; \n  this.tail = 0; \n  this.size = size; \n } \n \n public E[] getQueue() { \n  return queue; \n } \n \n public void setQueue(E[] queue) { \n  this.queue = queue; \n } \n  \n public synchronized void enqueue(E e){ \n  if(checkOverflow()){ \n   System.out.println(\"Queue overflow\"); \n   return; \n  } \n  this.queue[this.tail] = e;   \n  this.tail = (this.tail+1)%this.size; \n } \n  \n public synchronized void dequeue(){ \n  if(checkUnderflow()){ \n   System.out.println(\"Queue underflow\"); \n   return; \n  } \n  this.queue[this.head] = null; \n  this.head = (this.head+1)%this.size; \n } \n  \n private boolean checkOverflow(){ \n  if(this.tail==this.head && this.queue[this.head]!=null){ \n   return true; \n  } \n  return false; \n } \n  \n private boolean checkUnderflow(){ \n  if(this.tail==this.head && this.queue[this.head]==null){ \n   return true; \n  } \n  return false; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A solution using lock is trivial. Did the interviewer expect a lockless implementation?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Thread-safety could also assume blocking queue, i.e. instead of throwing an exception, enqueuing thread(s) is waiting when space is available and dequeuing thread(s) is waiting when the queue is empty. Has this been discussed at the interview?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class CircularQueue { \n \n  \n int maxSize; \n int[] array; \n \n int head; // index of the head element \n int tail; // index of the last added element \n \n int size; \n \n CircularQueue(int maxSize) { \n \n  array = new int[maxSize]; \n  this.maxSize = maxSize; \n  head = 0; \n  tail = -1; \n  size = 0; \n \n } \n \n synchronized void push(int value) { \n \n  if (size == maxSize) { \n   throw new RuntimeException(\"Queue is full\"); \n  } \n \n  if (tail == array.length - 1) { \n \n   // wrap around case \n   tail = -1; \n  } \n \n  array[++tail] = value; \n  size++; \n } \n \n synchronized int pop() { \n  if (size == 0) { \n   throw new RuntimeException(\"Queue is empty\"); \n  } \n \n  int value = array[head++]; \n \n  if (head == array.length) { \n   head = 0; \n  } \n \n  size--; \n  return value; \n } \n \n @Override \n public String toString() { \n   \n  if(size ==0 ) { \n   return \"Queue is empty\"; \n  } \n   \n  StringBuilder buf = new StringBuilder(); \n   \n  buf.append(\"Size: \"+size+\"  Queue: \"); \n   \n   \n  int i = head; \n   \n \n  while(true) { \n   buf.append(array[i]+\" \"); \n    \n   if( i == tail) { \n    break; \n   } \n    \n   if(i == array.length -1) { \n    i =-1; \n   } \n    \n   i++; \n  } \n   \n  return buf.toString(); \n } \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6505727237554176","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"7","title":"Write a function that receives three integer inputs for the lengths of the sides of a triangle and returns one of four values to determine the triangle type (1=scalene, 2=isosceles, 3=equilateral, 4=error). Generate test cases for the function assuming another developer coded the function","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"To see if it is an impossible triangle (or error): we need to check, for all sides, if one side of a triangle is less than the sum of the other two sides. If the check fails for any side, return error.  Otherwise, put all sides into a hashmap and check the size.  If size = 3, return scalene If size = 2 return isoceles If size = 1 return equilateral  Also check for edge cases and things like negative integer values, non-integer inputs etc..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"I think there is a way to do this with exclusive or but here is better but obviously not the best way:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Suppose the integers are a, b and c. (1)int arr[3]; arr[0] = a; arr[1] = b; arr[2] = c; (2)if(arr[0] > arr[1]) swap(arr, 0, 1);    if(arr[1] > arr[2]) swap(arr, 1, 2);    if(arr[0] > arr[1]) swap(arr, 0, 1); (3)if(arr[0] <= 0 || arr[2] >= arr[0]+arr[1]) return error;    if(arr[0] == arr[1]){       if(arr[1] == arr[2]) return equilateral;       else return isosceles;    }    else if(arr[1] == arr[2]) return isosceles;    else return scalene;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about  following these steps 1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"triangle type detection code:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6332981908078592","download_status":"DOWNLOAD_DONE","votes":"5","answersCount":"67","title":"Given two sorted array in ascending order with same length N, calculate the first K min a[i]+b[j]. time complexty O(N). some misunderstood first K, to put it straight, to find the Kth min, not the first min","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"It's doable in O(N) but not easy.  Look up the paper \"Selection in X + Y and matrices with sorted rows and columns* \"."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I don't think above is the right answer, though I haven't got it either, because the above solution can not work in the following case: a[]: 1  2  3 b[]: 1  4  7"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"KlogK will be too slow in case if K ~ n^2; It will be approximately N^2log(N^2) I can solve it in exactly N^2 :) just write out every pair a[i] + b[j], and find k-th; in C++ it is builtin function nth_element(); other have to implement nth order median statistics"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The time complexity lower bound of this problem is O(klgk) rather than O(n). With a min-heap,  we can solve it with O(klgk) time complexity and O(k) space complexity. I'll show you the code later."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can we reuse the same array's elements to compute multiple sums? I mean for this ex and K = 4: a[]: 1 2 3  b[]: 1 4 7 The correct answer is 1+1, 2 + 1, 3+1, 1+4 ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package careercup;  public class KthMinSum {     public static Integer[] find(int k, int[] a, int[] b) {         final Integer[] _result = new Integer[k];          int q = (int) Math.sqrt(k);          for (int i = 0; i < q; i++) {             for (int j = 0; j < q; j++) {                 _result[i * q + j] = a[i] + b[j];             }         }          int left = 0;         int right = 0;          for (int i = q * q; i < k; i++) {             _result[i] = (a[q] + b[left]) < (b[q] + a[right]) ? (a[q] + b[left++]) : (b[q] + a[right++]);         }          return _result;     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I'm trying to submit working code for returning first K min sums, but unfortunately system does not allow for me to do it :("},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ooops, please remove duplicated answers ;)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The way I implemented this takes O(K log(K)) time if I use a heap, or O(K^2) if I use a naive sorted array.   Here is the key idea: Obviously, the first pair is A[0] and B[0]. Furthermore, the first pair where we take index \"i\" from array \"A\" is indeed (A[i], B[0]). So we can initialize a list of \"K\" pairs of (A[i], B[0]) for \"i = 0, 1, ..., K- 1\".  Assume this list is sorted (or Heap with Extract Min). Take first Pair out say, (A[0], B[0]). NOTE: If the next pair leading to K-minimum sum includes (A[0]) it must be (A[0], B[1]). So we simply put the pair (A[0], B[1]) inside. In general, when you extract the pair (A[i], B[j]), you must Insert (A[i], B[j + 1]) back in.   Insertion and Extraction takes O(K) time if you use a simple sorted array, and O(log(K)) if you use a Heap. Overall, it takes, O(K Log(K)) = O(K^2).  Here is what I used for class Pair:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def find_kth(a, b, k): \n    a_count, b_count = 0, 0 \n    is_last_b = False \n \n    while a_count * b_count < k: \n        if a[a_count] < b[b_count]: \n            a_count += 1 \n            is_last_b = False \n        else: \n            b_count += 1 \n            is_last_b = True \n \n    if is_last_b: \n        return a[a_count - (a_count * b_count - k) - 1], b[b_count - 1] \n    else: \n        return a[a_count - 1], b[b_count - (a_count * b_count - k) - 1]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Interesting problem that kept me busy some time but the trick is that arrays are sorted so, given a[0]+b[0] is for sure the first number that is to be produced, what are the next possible sums, well:  - S1 = a[a_i+1] + b[b_i];  - S2 = a[a_i+1] + b[0];  - S3 = a[a_i]   + b[b_i+1];  - S4 = a[0]     + b[b_i+1];  as you want to iterate over each arrays always checking the sum result of the other first array element when you increment either A index or B index. The smallest sum of the above for is the next one given that you:   - discard any sum smaller than the previous generated sum   - does not go beyond array boundaries  resulting code passing all the test series in this page is:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about the following solution, it will run as long as we don't request K to be more then the number of all the possible combinations"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Finally I worked out it! It can pass all the test cases before! Here is the code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class MaxSumsOf2SortedArrays { \n \n  \n public MaxSumsOf2SortedArrays() { \n  a = new int[]{0, 1, 3, 5}; \n  b = new int[]{1, 2, 4, 7}; \n } \n int[] a;int[] b; \n \n void findMax(int K){ \n  int a1=0;int a2=1; \n  int b1=0;int b2=1; \n  int count = 0; \n  System.out.println(a[0]+b[0]); \n  while(count"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class MaxSumsOf2SortedArrays {     public MaxSumsOf2SortedArrays() {   a = new int[]{0, 1, 3, 5};   b = new int[]{1, 2, 4, 7};  }  int[] a;int[] b;   void findMax(int K){   int a1=0;int a2=1;   int b1=0;int b2=1;   int count = 0;   System.out.println(a[0]+b[0]);   while(count   count++;        int aSum = a[a1]+b[a2];    int bSum = b[b1]+a[b2];    if(aSum<=bSum){     System.out.println(aSum + \"--\"+a[a1]+\"+\"+b[a2]);     a2++;     if(a2==b.length){      a1++;      a2=a1;     }         }    else{     System.out.println(bSum+ \"--\"+b[b1]+\"+\"+a[b2]);     b2++;     if(b2==a.length){      b1++;      b2=b1;     }          }   }     }    public static void main(String[] args) {   // TODO Auto-generated method stub   MaxSumsOf2SortedArrays m = new MaxSumsOf2SortedArrays();   m.findMax(100);     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n) algorithm was proposed from this paper www dot cse dot yorku dot ca/~andy/pubs/X+Y.pdf, however it doesn't fit for an interview."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class KthMinSumFromTwoArrays { \n public static void main(String[] args){ \n  int[] a = new int[]{1,5,9,15,20}; \n  int[] b = new int[]{3,4,7,10,12}; \n   \n  KthMinSumFromTwoArrays obj = new KthMinSumFromTwoArrays(); \n   \n  for(int i = 1; i<=9; i++){ \n   System.out.println(obj.findNthMinSum(a, b, i));  \n  } \n } \n  \n private int whichIsMin(int first, int second, int third){ \n  int min = Math.min(first, second); \n  if(min == first){ \n   min = Math.min(first, third); \n   if(min == first){ \n    return 1; \n   } else { \n    return 3; \n   } \n  } else { \n   min = Math.min(second, third); \n   if(min == second){ \n    return 2; \n   } else { \n    return 3; \n   } \n  } \n } \n  \n private int findNthMinSum(int[] a, int[] b, int n){ \n  if(n == 1){ \n   return a[0]+b[0]; \n  } \n  int aLimit = a.length; \n  int bLimit = b.length; \n   \n  int firstA = 0; \n  int firstB = 0; \n   \n  int secondA = 1; \n  int secondB = 0; \n   \n  int thirdA = 2; \n  int thirdB = 0; \n   \n  int nThMin = 0; \n   \n  while(n > 0){ \n   int firstSum = Integer.MAX_VALUE; \n   int secondSum = Integer.MAX_VALUE; \n   int thirdSum = Integer.MAX_VALUE; \n    \n   if(firstA < aLimit && firstB < bLimit){ \n    firstSum = a[firstA]+b[firstB]; \n   } \n    \n   if(secondA < aLimit && secondB < bLimit){ \n    secondSum = a[secondA]+b[secondB]; \n   } \n    \n   if(thirdA < aLimit && thirdA < bLimit){ \n    thirdSum = a[thirdA]+b[thirdB]; \n   } \n    \n   int whichIsMin = whichIsMin(firstSum, secondSum, thirdSum); \n    \n   switch(whichIsMin){ \n   case 1: \n    nThMin = a[firstA]+b[firstB]; \n    firstB++; \n    if(firstB == bLimit){ \n     firstA = secondA; \n     secondA = thirdA; \n     thirdA++; \n     firstB = secondB; \n     secondB = thirdB; \n     thirdB = 0; \n    } \n    break; \n   case 2: \n    nThMin = a[secondA]+b[secondB]; \n    secondB++; \n    break; \n   case 3: \n    nThMin = a[thirdA]+b[thirdB]; \n    thirdB++; \n    break; \n   } \n   n--; \n  } \n  return nThMin;   \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Minimum value will be a[0] + b[j]  or a[i] + b[0]  so the answer is"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Minimum value will be a[0] + b[j]  or a[i] + b[0] Note#  a[0] + b[0] is the special case, we need to be careful for  this case. k > N case is also special case.  so the answer is"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Since both are sorted array,The first element of both the array will be minimum. So the sum a[0]+b[0] will be less than any of other a[i]+b[j]  so the answer is straight  A[0] + B[0]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"k = 1: a[0] + b[0] k = 2: min(a[0] + b[1], a[1] + b[0]) k = 3: max(a[0] + b[1], a[1] + b[0]) k = 4: a[1] + b[1] ... k = 3n-1: min(a[n-1] + b[n], a[n-1] + b[n]) k = 3n: max(a[n-1] + b[n], a[n-1] + b[n]) k = 3n + 1: a[n] + b[n] k = 3"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Please tell me how wrong I am:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public int findKthMin(int[] A, int[] B, int K) \n{ \n int indexA = 0; \n int indexB = 0; \n int count = 1; \n \n while (count < K) \n { \n  int sum1 = A[indexA + 1] + B[indexB]; \n  int sum2 = A[indexA] + B[indexB + 1]; \n   \n  if (sum1 > sum2) \n  { \n   indexA++; \n  } \n  else \n  { \n   indexB++; \n  } \n } \n return A[indexA] + B[indexB]; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Got it finally: (1)do merge process, record each item is from a[] or b[]. (2)find the Kth smallest pair(remember a pair must be one from a[], the other from b[]).  time complexity:  O(N) space complexity: O(N)  As I'm more familiar with C++, following is my C++ code with annotation:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public int kthMinimum(int a[], int b[], int k){    ArrayList temp = new ArrayList();    for(int i=0; i    for(int j=0; j     temp.add(a[i]+b[j]);     }        }    Collections.sort(temp);    return temp.get(k);   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"k=0;j=0;i=0; \nwhile(k"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"dont keep computing sums inside the loop. Just need to keep track of which is the kth min and (k+1)th min number in combined array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public class KthMinSum { \n    public static Integer[] find(int k, int[] a, int[] b) { \n        final Integer[] _result = new Integer[k]; \n \n        int q = (int) Math.sqrt(k); \n \n        for (int i = 0; i < q; i++) { \n            for (int j = 0; j < q; j++) { \n                _result[i * q + j] = a[i] + b[j]; \n            } \n        } \n \n        int left = 0; \n        int right = 0; \n \n        for (int i = q * q; i < k; i++) { \n            _result[i] = (a[q] + b[left]) < (b[q] + a[right]) ? (a[q] + b[left++]) : (b[q] + a[right++]); \n        } \n \n        return _result; \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"package careercup; \n \npublic class KthMinSum { \n    public static Integer[] find(int k, int[] a, int[] b) { \n        final Integer[] _result = new Integer[k]; \n \n        int q = (int) Math.sqrt(k); \n \n        for (int i = 0; i < q; i++) { \n            for (int j = 0; j < q; j++) { \n                _result[i * q + j] = a[i] + b[j]; \n            } \n        } \n \n        int left = 0; \n        int right = 0; \n \n        for (int i = q * q; i < k; i++) { \n            _result[i] = (a[q] + b[left]) < (b[q] + a[right]) ? (a[q] + b[left++]) : (b[q] + a[right++]); \n        } \n \n        return _result; \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"static int kthMinimum(int index1, int index2, int curr, int k) \n { \n  if(curr == k) \n  { \n   return array1[index1] + array2[index2]; \n  } \n   \n  int n1 =  array1[index1 + 1] + array2[index2]; \n  int n2 =  array1[index1] + array2[index2 + 1]; \n   \n  if(n1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"int findKthSum(int A[], int B[], int N, int K) \n{ \n ASSERT(N*N > K); // we must have K pairs \n \n // lets say A[a] and B[b] is Kth lowest sum \n // we must have ((a-1) * b < K) and  (a * (b-1) < K) \n  \n // merge sort \n int a = 1; // this is elements used from A. \n int b = 1; // this is elements used from B. \n bool lastFromA = false; \n while (a * b < K) \n { \n    if (A[a-1] < A[b-1]) \n    { \n  a++; \n  lastFromA = true; \n    } \n    else \n    { \n  b++; \n  lastFromA = false; \n    } \n } \n  \n if (a*b == K) return A[a-1]+B[b-1]; \n  \n  \n // so far we have used up a-1 elements from A, and b-1 elements from B. and have found (a-1)*(b-1)th lowest. \n // we also have one of the correct index (nextFromA). just find the other one. \n if (lastFromA) \n { \n     b = K - (a-1)*b; \n } \n else \n { \n     a = K - (b-1)*a; \n } \n // our answer is A[a] + B[b] \n return A[a] + B[b]; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"like merge sort, increase pointers from a and b. You do not need to calculate the min values, you just count the min values while increasing the pointers. And when you exceed the desired k, you can calculate a[i]  + b[j] for the kth min."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"O(n) algorithm: suppose you have initial minimum: a[i]+b[j] To find next minimum you need to test the following 4-6 pairs and find the pair with minimum sum that is greater than the current one. Rinse-repeat K times.   Code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Minimum value will be a[0] + b[j]  or a[i] + b[0]  so the answer is"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Since both are sorted array,The first element of both the array will be minimum. So the sum a[0]+b[0] will be less than any of other a[i]+b[j]  so the answer is straight  A[0] + B[0]"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5746897784406016","download_status":"DOWNLOAD_DONE","votes":"4","answersCount":"7","title":"Given a huge N*N matrix, we need to query the GCD of numbers in any given submatrix range???x1,y1,x2,y2??. Design a way to preprocess the matrix to accelerate the query speed. extra space should be less than O(N^2) and the preprocess time complexity should be as litte as possible.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"I'll try to present a Segment Tree based approach, which takes O(n^2) time and space to pre-process, and answers each query in O(r * log(c)) time. r and c are the number of rows and columns in the query.  For each row A[i] in the matrix A, we build a segment tree, such that each node remembers  GCD(A[i][a..b]) for some range [a,b). The root node remembers GCD(A[i][0..n]), its children remembers GCD(A[i][0..n/2]) and GCD(A[i][n/2..n]), and so on. The tree allows us to query GCD(A[i][a..b]) in O(log n) time for some row i and an arbitrary range [a,b). The memory complexity of each segment tree is O(n), which gives us O(n^2) total memory complexity.  To answer a query, we just query GCD(A[y1][x1..x2]), GCD(A[y1+1][x1..x2]), ... GCD(A[y2][x1..x2]) and take a GCD on all these numbers.  We can further improve the query time to O(logn * logn) by building one 2-d segment tree for the entire matrix, but I doubt whether it's feasible to implement a 2-d segment tree within the timespan of an interview."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"1) compute GCD for every 2 adjacent point, then we need a matrix with size N*N/2 2) compute GCD for every 4 adjacent point, then we need a matrix with size N*N/4 .... the total space N^2(1/2+1/4+....) <= n^2 each step we can reuse the previous result. so the time complexity is also the same n^2   To compute GCD for every submatrix, first we divide the big matrix into the small submatrixs that we prepossessed. And then we compute the GCD of them."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Lawrence, in your solution, let's say n = 10, which element remembers GCD for"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5207082001235968","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"22","title":"A soda water machine,press button A can generate 300-310ml, button B can generate 400-420ml and button C can generate 500-515ml, then given a number range [min, max], tell if all the numers of water in the range can be generated.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Generate(int min, int max){ \n  bool isPossible = new bool[max+1]; \n  for(int i=300; i<516; i++) \n    if((i>299 && i<311) || (i>399 && i<421) || (i>499 && i<516)) \n      isPossible[i] = true; \n  for(int i=516; i<=max; i++){ \n    if(!isPossible[i]) \n      for(int j=300; j<311 && !isPossible[i]; j++) \n        if(isPossible[i-j]) \n          isPossible[i]=true; \n    if(!isPossible[i]) \n      for(int j=400; j<421 && !isPossible[i]; j++) \n        if(isPossible[i-j]) \n          isPossible[i]=true; \n    if(!isPossible[i]) \n      for(int j=500; j<516 && !isPossible[i]; j++) \n        if(isPossible[i-j]) \n          isPossible[i]=true; \n  } \n  for(int i=min; i<=max; i++) \n    if(!isPossible[i]) \n      return false; \n  return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Seems ripe for dynamic programming."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.*; \nimport java.lang.*; \nimport java.io.*; \n \nclass Ideone \n{ \n static boolean isGeneratable[];  \n \n public static void fillArray(int max) \n { \n  isGeneratable = new boolean[max + 1]; \n  \n  for(int i=300; (i <=310) && (i <= max ); i++) \n   isGeneratable[i] = true; \n \n  for(int i=400; (i <=420) && (i <= max); i++) \n   isGeneratable[i] = true; \n \n  for(int i=500; (i <=515) && (i <= max); i++) \n   isGeneratable[i] = true; \n \n \n  for(int i=515; i <= max; i++) \n  { \n   for(int j=1;j<=i && !isGeneratable[i] ; j++) \n   { \n    isGeneratable[i] = isGeneratable[j] && isGeneratable[i-j]; \n   } \n  } \n \n } \n \n public static void printResult(int min,int max) \n { \n  for(int i= min; i<=max; i++) \n  { \n   int startIndex = i; \n   int endIndex = i; \n   \n   while(i<=max && !isGeneratable[startIndex]) \n    { \n     startIndex++; \n     i++; \n    } \n     \n   endIndex = startIndex; \n   while(i<=max && isGeneratable[endIndex]) \n    { \n     endIndex++; \n     i++; \n    } \n   endIndex--; \n    \n   if(endIndex >= startIndex) \n    System.out.println(\"[\" + startIndex + \" , \" + endIndex + \" ] \" ); \n     \n  } \n } \n  \n public static void main (String[] args) throws java.lang.Exception \n { \n  fillArray(2000); \n  printResult(0,2000); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@Sathya - agreed, perhaps an interval based data structure(to store only the range(s) for which the denominations can be generated) is a better idea than boolean array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a dynamic programming solution, it can be optimized as some combinations are checked more then once.  However it allows you to do any combination of A, B, C and repeat them as many time as needed.  To run set low and high with initial value of 0 and min and max as the searched range."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is another version - a combination of recursion and dynamic programming. This takes more space (stack grows for recursion and allocating huge array), but runs faster (don'n need to calculate every single element in array and a lot of recursive calls will be skipped with first if statement)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Notice that if min>=8000, whatever max is, the answer is yes, because I can get all the range by pushing button 400-420 for 20 times or more. So I need only generate all the ranges under 8000( or even smaller), then the search for [min, max] can be done in O(log N). Here is the code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. The described problem of only 3 given intervals (300,310),(400,420) and (500,515) is finite and can be solved in O(1) run-time and space complexity by simply checking whether [min,max] intersects with any of the following intervals:  (-infinity,300),(310,400),(420,500),(515,600),(620,700),(730,800),(840,900),(935,1000),(1040,1100),(1150,1200),(1260,1300),(1355,1400),(1460,1500),(1570,1600),(1680,1700),(1775,1800),(1880,1900),(1990,2000),(2195,2200).  2. The general problem of n intervals (n buttons where each can generate 0<=k<=n) I think can be solved using a variant of the dynamic programming algorithm to solve the unbounded knapsack problem.   The total weight is max, the element weights are each interval's starting point. We'll also store the end point for each combination of intervals and the goal would be to find for each number j, a combination of intervals for which the sum of the starting points is as close as possible to j while the sum of the end points is as large as possible. All that's left is to check whether for every number in the range of [min,max] there is an interval combination such that the sum of the starting points is lesser/equal than the number and the sum of the ending points is greater/equal than the number."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Interval Tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"modified coin change problem"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"check if the numbers lie within the following range [300-310] [400-420] [500-515][700-730][800-825][900-935][1200-1245] if they do lie then answer is yes else it is no(where no means all numbers cannot be generated)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-4","title":"What is the expected complexity.With O(n) complexity this is a very easy question. Check for all the numbers in the range [min,max] , if the number lies between   300 -310 or 400-420 or 500-515.  Before getting inside the loop we may wnt to check if   300 <= min and max >= 310 or  400 <= min and max >= 420 or 500 <= min and max >= 515  In this case all the numbers can be generated and we need not to get inside the loop"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5275980205654016","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"5","title":"Given an input file, find the line with the most vowels ( Easy)  Followup: Given an input file and any criteria write a function that will find the best score line and return it.  (He told me the best score can be anything, min/max/(anything that can be measured) of the criteria).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Solution in python"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If we can work on distributed environment we can also use MapReduce algo to improve performance."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution in java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java code using Pattern and Matcher class."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5083698865111040","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"27","title":"Given a amount and several denominations of coins, find all possible ways that amount can be formed? eg amount = 5, denominations = 1,2,3.      Ans- 5 ways 1) 1,1,1,1,1  2) 1,1,1,2 (combinations aren't counted eg 1,2,1,1 etc) 3) 1,1,3  4) 1,2,2  5) 2,3","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"A recursive solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"For 5 the total combinations without duplicates is 8 and for 4 it is 5 Here is the code using dynamic programming"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public static void main(String[] args) { \n  final int[] coins = new int[] { 1, 2,3 }; \n  System.out.println(\" Combinations :\" + getCoinCombinations(0, coins, 5)); \n } \n \n static int getCoinCombinations(final int start, final int[] coins, \n   int amount) { \n  int result = 0; \n  if (amount == 0) { \n   return 1; \n  } \n  for (int i = start; i < coins.length; i++) { \n   if (amount >= coins[i]) { \n    result += getCoinCombinations(i, coins, amount - coins[i]); \n   } \n  } \n  return result; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int findPossibleWays(int val , int [] denominations){ \n  int []  dp = new int [val+1]; \n  dp[0] = 0; \n     for (int i =1; i<=val ;++i){ \n      for (int j =0 ;j=denominations[j]){ \n        dp [i] =dp[i]>dp[i-denominations[j]]+1?dp[i]:dp[i-denominations[j]]+1; \n       } \n      } \n     } \n     return dp[val];"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming denominations have single digit numbers for the convenience of printing -"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for convenience i took denominations as boolean array"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"greedy or dynamic is optimal in this such kind of problems"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question says find all possible ways, and not the number.  Here is non-optimal recursive, generational python code. Dynamic programming can be used to generated all the combinations too."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \nusing namespace std; \n \nint FindCombination(int amount, const vector& domination, int max_dom_index, vector* combination) { \n    if (amount == 0) { \n        int comb_size = combination->size(); \n        if (comb_size == 0)  // if original amount is 0, the combination count may be zero or infinite big number, which depends on your definition. \n           return 0; \n \n        // find a combination, output the combination. \n        for (int i = 0; i < comb_size-1; ++i) { \n            cout << (*combination)[i] << \",\"; \n        }    \n        cout << (*combination)[comb_size-1] << endl; \n        return 1; \n    }    \n    int ret = 0; \n    // backtracking by trying domination in descending order, thus eliminates duplications.  \n    for (int i = max_dom_index; i >= 0; --i) { \n        if (amount >= domination[i]) { \n             combination->push_back(domination[i]); \n             ret += FindCombination(amount-domination[i], domination, i, combination); \n             combination->pop_back(); \n        }    \n    }    \n    return ret; \n} \n \nint FindAllCombinations(int amount, const vector& domination) { \n    if (domination.size() == 0) \n        return 0; \n    vector combination; \n    return FindCombination(amount, domination, static_cast(domination.size())-1, &combination); \n} \n \nint main (){  \n  vector dom; // assuming dominations have already been sorted. \n  dom.push_back(1); \n  dom.push_back(2); \n  dom.push_back(3); \n  int num = FindAllCombinations(7, dom); \n  cout << \"====================================\" << endl; \n  cout << \"There are \" << num << \" combinations.\" << endl; \n  return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \nusing namespace std; \n \nint findWay(int amount, int den[], int maxDen) \n{ \n if (maxDen == 0) return 1; \n int sum = 0; \n for (int i = amount/den[maxDen]; i>=0; i--) \n  sum += findWay(amount-(i*den[maxDen]), den, maxDen-1); \n return sum; \n} \n \nint main() { \n int myDen[3] = {1, 2, 3};  \n cout<<\"There are \"<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; \nimport java.util.List; \nimport java.util.Set; \nimport java.util.TreeSet; \n \n \npublic class DenominationsOfCoins { \n  \n Set mAllowedDenominations; \n DenominationsOfCoins(){ \n  mAllowedDenominations = new TreeSet(); \n  mAllowedDenominations.add(1); \n  mAllowedDenominations.add(2); \n  mAllowedDenominations.add(3); \n } \n \n public static void main(String[] args){ \n  DenominationsOfCoins obj = new DenominationsOfCoins(); \n  obj.findPossibleCombiations(5); \n } \n  \n int findPossibleCombiations(int num){ \n  List possibilities = doFindPossibleCombiations(num, 0); \n  for(String str:possibilities){ \n   System.out.println(str); \n  } \n  return possibilities.size(); \n } \n  \n List doFindPossibleCombiations(int num, int sumWith){ \n  List possibilities = new ArrayList(); \n  for(int denom:mAllowedDenominations){ \n   if(denom > num){ \n    break; \n   } \n   if(denom < sumWith){ \n    continue; \n   } \n   int remainder = num - denom; \n   if(remainder==0){ \n    possibilities.add(String.format(\"%d\", denom)); \n    break; \n   } else if(remainder >= denom){ \n    List possibilitiesWithRemainder = doFindPossibleCombiations(remainder, denom); \n    for(String str:possibilitiesWithRemainder){ \n     possibilities.add(String.format(\"%d, %s\", denom, str)); \n    } \n   } \n  } \n  return possibilities; \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"DFS"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This code is in java. Logic is simple, using recursion."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#procedure for generating subsets  \nout = []    \ndef subset(s,i,ss) : \n global out \n if i == len(s): \n    return \n else : \n    ss.append(s[i]) \n    out.append(list(ss)) \n    i = i+1 \n    subset(s,i,ss) \n    ss.pop() \n    subset(s,i,ss) \n \n#intialising variables \ns = [] \nss = [] \ntarget = 5 \ndenom = [1,2,3] \n \n#generate the list [1,1,1,1,1,2,2,3] \nfor var in denom : \n  fac = target / var \n  for i in range(0,fac) : \n    s.append(var) \n \n#generate the all subsets of list [1,1,1,1,1,2,2,3] \nsubset(s,i,ss) \n \n#remove duplicate lists in the above generated subsets \nout = set(tuple(x) for x in out) \nout = [list(x) for x in out] \n \n#increment the count if the sum of the subset is 5  \ncnt = 0 \nfor x in out : \n  if sum(x) == target : \n    cnt = cnt + 1 \n     \nprint cnt"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import math \ndef findAllDenomination(val, allDenominations): \n  possibleDenominations = [] \n  if val == 0: \n    return possibleDenominations \n  tempDenominations = allDenominations.copy(); \n  theDenomination = tempDenominations.pop(); \n  highestDenominations = math.trunc(val/theDenomination); \n  if len(tempDenominations) == 0: \n    if val%theDenomination == 0: \n      currentDenominations = [];  \n      for i in range(0, highestDenominations): \n        currentDenominations.append(theDenomination); \n      possibleDenominations.append(currentDenominations); \n  else: \n    for i in range(0, highestDenominations+1): \n      if (val - theDenomination*i) == 0: \n        currentDenominations = []; \n        for j in range(0, i): \n          currentDenominations.append(theDenomination); \n        possibleDenominations.append(currentDenominations); \n      else: \n        allPossibleLowerDenominations = findAllDenomination(val - theDenomination*i, tempDenominations) \n        if len(allPossibleLowerDenominations) != 0: \n          currentDenominations = [];  \n          for j in range(0, i): \n            currentDenominations.append(theDenomination); \n          for lowerPossDenominations in allPossibleLowerDenominations: \n            lowerPossDenominations.extend(currentDenominations); \n            possibleDenominations.append(lowerPossDenominations); \n  return possibleDenominations  \n \npossDenominations = findAllDenomination(5, [1,2,3]) \nprint(possDenominations)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int getCount(int[] denom, int value) { \n return getCount(denom, 0, value); \n} \nint getCount(int[] denom, int index, int reqValue) { \n int value = 0; \n int count = 0; \n if (index == denom.length) { \n  return 0; \n } \n while(value < reqValue) \n { \n  value += denom[index]; \n } \n if (reqValue == value) \n  count++; \n value -= denom[index]; \n while(value >= 0) { \n  count += getCount(denom, index+1, reqValue-value); \n  value -= denom[index]; \n } \nreturn count; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a recursive solution in java.  *assume denom is sorted or we can just sort it"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Note denominations should be sorated ascending \n \nclass Finder{ \nint[][] dp; // initialized by -1 \nint[] denominations; \nint find(int amount, int[] denominations){ \n this.amount = amount; \n this.denominations = denominations; \n this.dp  = new int[amount][denominations.length] \n for(int i = 0; i < amount; i++){ \n  for(int j = 0; j < denominations.length; j++){ \n   dp[i][j] = -1; \n  } \n} \nreturn _find(amount, 0); \n} \nprivate int _find(int amount, int index){  \n int result = 0; \n if(amount == 0){ \n  dp[amount][index] = 1; \n return 1; \n}else if(amount < 0){ \n dp[amount][index] = 0; \n return 0; \n} \nif(dp[amount][index] != -1){ \n return dp[amount][index]; \n} \nfor(int i=index;i < denominations.length;i++){ \n  result += _find(amount-denominations[i], i+1); \n} \ndp[amount][index] = result; \n return result; \n} \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5648527329853440","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"34","title":"Question: You are given a CSV file with 3 columns -- all integers:   id,parent,weight  10,30,1  30,0,10  20,30,2  50,40,3 40,30,4  0 is the assumed root node with weight 0  which describes a tree-like structure -- each line is a node, 'parent' refers to 'id' of another node.   Print out, for each node, the total weight of a subtree below this node (by convention, the weight of a subtree for node X includes the own weight of X).   You may assume that the input comes pre-parsed as a sequence of Node objects  (substitute the appropriate syntax for java/python/c++):   Node {   int id;    int parent;    int weight;   // ... you can add other fields right here, if necessary  }  implement the following: public void printSubTreeWeight(List nodes) { ....}","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"My idea is use map. it's O(n) time and O(n) space where n is the number is nodes Given a list of nodes   1. put nodes in a hashmap 2. find the direct child nodes of each node and put it in a hash map  ---1) make a new HashMap> (ie name it map) ---2) for each node, map.put(node.id, new ArrayList()) ---3) for each node, map.get(node.parent.id).add(node.id) 3. make a new HashMap (ie name it weight) which the id is key and weight is value 4. for each key->value in map,   for each subelement in value, process them"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"First create a hashtable that stores the list of children for each node. Set the root to be the node with parent=0. Then do a recursive call on the root. The recursive call will find the weight of the subtree under this node, print it, then return it. So given a node, we can apply this recursive call to its children to both print their weights as well as calculate the total weight for current node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's how I see one possible approach:  1.) Parse the CSV file into a tree. the algorithm should be recursive as the entries in the CSV are not guaranteed to be sorted. So, the moment you come across an entry where the parent is not yet in the tree, just put aside in a list of orphans. Then run p.1 with this list and repeat until it's empty. 2.) Once you have a tree, then traverse the tree (DFS or BFS doesn't matter) and for each node, call printWeight(Node node, 0). 3.) printWeight(Node node, int *sum) does traverse all it's nodes (again DFS or BFS doesn't matter) and sum the weights into the sum external variable.  The thing is how to optimize p.2 and not over-visit the already visited nodes and remember the intermediate sum results?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hey here is my quick and dirty \"brute force\" solution in C++.  The run time complexity is O(N^2) as it relies on a nested for loop.  Let me know if anyone has any improvements/suggestions.  Hope this helps!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node {  \nint id;  \nint parent;  \nint weight;  \nint subtree_weight; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You should be able to do a post order traversal on the tree. I have a snippet but mine doesn't add the 30 node's weight right  Post order traversal is usually used to sum up the disk space in a dir. So if you want to get the weight at each node-post order traversal"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You should be able to do a post order traversal on the tree. I have a snippet but mine doesn't add the 30 node's weight right  Post order traversal is usually used to sum up the disk space in a dir. So if you want to get the weight at each node-post order traversal"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You should be able to do a post order traversal on the tree. I have a snippet but mine doesn't add the 30 node's weight right  Post order traversal is usually used to sum up the disk space in a dir. So if you want to get the weight at each node-post order traversal"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You should be able to do a post order traversal on the tree. I have a snippet but mine doesn't add the 30 node's weight right  Post order traversal is usually used to sum up the disk space in a dir. So if you want to get the weight at each node-post order traversal"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorry about the 4 messages. This form wasn't working right"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A method that doesn't build a tree, but uses a queue, a children counter array, a subtree weight array instead. 1. O(n) time to determine leaf nodes, put them in a queue. (initially scan the node array from left to right, and use an array to store the number of its direct children, leaf nodes are those that have no direct children). Initialize each node's subtree weight with its own weight.   2. O(n) time to calculate the weights in a bottom-up way. You add each node's weight to its parent's subtree weight, decrease children counter of the parent node(enqueue the parent node if childern counter has dropped to zero),  and then dequeue current node.  3. Output each node's weight."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class TreeNode {   int id;   int parentId;   int weight;    public TreeNode(int id, int parentId, int weight) {    this.id = id;    this.parentId = parentId;    this.weight = weight;   }  }   public TreeNode[] calWeight(String[] strs) {   HashMap childParentMap = new HashMap();   HashMap idNodeMap = new HashMap();   HashSet visited = new HashSet();   for (String str : strs) {    String[] items = str.split(\",\");    int id = Integer.valueOf(items[0]);    int parent = Integer.valueOf(items[1]);    int weight = Integer.valueOf(items[2]);    TreeNode cNode;    if (idNodeMap.containsKey(id)) {     cNode = idNodeMap.get(id);     cNode.weight += weight;     cNode.parentId = parent;    } else {     cNode = new TreeNode(id, parent, weight);     idNodeMap.put(id, cNode);    }    TreeNode pNode;    childParentMap.put(id, parent);    visited.add(id);    if (parent == 0){     continue;    }    if (!idNodeMap.containsKey(parent)) {     pNode = new TreeNode(parent, -1, weight);     idNodeMap.put(parent, pNode);    } else {      int t = id;     do {      int p = childParentMap.get(t);      pNode = idNodeMap.get(p);      pNode.weight += idNodeMap.get(t).weight;      t = p;     } while (visited.contains(pNode) && childParentMap.containsKey(t));    }    }   TreeNode[] r = new TreeNode[strs.length];   int index = 0;   for (TreeNode tn : idNodeMap.values()) {    r[index] = tn;    index++;   }   return r;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"keep a list of all the leave nodes and process all the nodes keeping their parent id as the weight.. then just update the list above the leaf nodes adding the weights up.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n#include  \n#include \nusing namespace std; \nclass node{ \npublic: \n    node(){ \n    } \n    node(int a,int b,int c,int d=0){ \n id=a; \n pid=b; \n w=c; \n sum=d; \n    } \n    node& operator=(const node& n){ \n id = n.id; \n pid = n.pid; \n w = n.w; \n sum = n.sum; \n    } \n    int id; \n    int pid; \n    int w; \n    int sum; \n}; \n \nint get_weight_sum(const map >& graph,int id,map& csv){ \n    int result=0; \n    map >::const_iterator it = graph.find(id); \n    result=csv[id].w; \n    if(it==graph.end()){ \n    }else{ \n const vector& vec = it->second; \n for(int i=0;i& csv){ \n    map >graph; \n    map::iterator it1 = csv.begin(); \n    for(;it1!=csv.end();it1++){ \n if(it1->second.id){ \n     graph[it1->second.pid].push_back(it1->second); \n } \n    } \n    return  get_weight_sum(graph,0, csv); \n} \n \nint main(){ \n    mapcsv; \n    csv[0]=node(0,0,0); \n    csv[10]=node(10,30,1); \n    csv[30]=node(30,0,10); \n    csv[20]=node(20,30,2); \n    csv[50]=node(50,40,3); \n    csv[40]=node(40,30,4); \n    get_weight(csv); \n    map::iterator it1 = csv.begin(); \n    for(;it1!=csv.end();it1++){ \n std::cout<<\"id:\"<first<<\" sum:\" <second.sum<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think disturbing the struct Node least would be better. Also, I would avoid making helper functions until extremely necessary. So, first make a hash map(unordered_set in this case) that maps id to index in the list (vector in this case) and identify the root while doing this (O(n))  Then create a data structure to store set of children of each parent (I have used vector > child for this purpose) . Again O(n).  Now iteratively run DFS on this . Recursion can be used here, but I avoid making unnecessary helper functions. Again O(n)  Total O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I haven't seen any great answers here.  I used a Stack object solve this puzzle.  The answers are:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \nusing namespace std; \n \nclass Node { \n public: \n int id;  \n int parent;  \n int weight;  \n // ...  can add other fields right here, if necessary  \n int totalWeight; // a total weight of self and all the sub tree. \n Node(int id_, int parent_, int weight_) \n { \n  id = id_; parent = parent_; weight = weight_; totalWeight = 0; \n } \n  \n}; \n \n \nvoid printSubTreeWeight(vector nodes) { \n int ct; // current index \n bool haveParent; \n for (int i=0; i nodes; \n //Node n = new Node(10,30,1); \n nodes.push_back(Node(10,30,1)); \n nodes.push_back(Node(30,0,10)); \n nodes.push_back(Node(20,30,2)); \n nodes.push_back(Node(50,40,3)); \n nodes.push_back(Node(40,30,4)); \n  \n printSubTreeWeight(nodes); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think we can add a subweight and subcount to the structure.and make a hash of and then traverse the hash, if subcount equals to 0, print and sub its' parents subcount and add weight as well, so each travese, we eliminated the current leaf nodes. Below is the code, just an examlpe. the complexty is o(nh), if balanced would be nlgn"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I suggested to use the union-find algorithm to find the weight of a sub tree. Which is theoretically faster."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's a simple memoized Python solution that builds the tree (as a hash map sending each node to the list of its children) and prints the weight of every node in the tree:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I think it's not necessary to parse the CSV into a tree. I just sorted the entries by parent and accumulated the weights of the children (and the children of the children) for every parent. Time complexity O(nlogn). Written in C++.  Output:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5664860016738304","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"6","title":"Suppose you have N machines connected to a network. Now you generate a new file on one machine, and want to sync up across all machines. please design a system to accomplish this task and also analyze the error tolerance issue.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"We had this problem at the office. The best way to do it is to order your nodes as a binary tree (a heap representation will do)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"wouldn't that cause retransmission, how about divide file into smaller fixed size segments then main computer uses UDP datagram and broadcast each segment along with sequential incrementing id. Once all packets done transmission clients may ask for missing segment, and it can retransmit."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Besides the file, generate a digest for the file. A node performs a digest check after receiving the file and the digest.  The data can be pipelined between all nodes. GFS does data transfer in this way."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"mediator pattern"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Transfer file in P2P way(i.e. split it into small fixed-size chunks, and send heartbeating messages peridically to know other server's chunks, and send request to get the chunk). Use checksum in messages to tolerate the errors."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Use torrent :P"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5093004398297088","download_status":"DOWNLOAD_DONE","votes":"-2","answersCount":"7","title":"Sorry","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"space"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I know you are asking this clarifying question to clarify the use of hash table for the solution to careercup.com/question?id=5633395035996160 .  so let's go straight to the point: how many possible keys are there (universe size) for all possible logfile names?  Wouldn't it be a (huge number) ?   The ONLY way to prevent collisions is to have a table of the size == ALL POSSIBLE KEYS.  And this is usually too large to be practical."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You'd need a lot of space to eliminate hash table collisions entirely. To be completely guaranteed to not have any, you'd need a bucket for every possible value an element can take on, which is potentially a huge number. For example, you'd need 2^32 buckets for 32-bit integers, 2^64 buckets for 64-bit integers, and ~10^18 buckets for alphanumeric strings of length 10.  Even if your keys are hashed fairly randomly by the hash function and you're willing to settle for only a high probability of no collisions, by the Birthday Paradox, you need at least k*n^2 buckets, for some constant k depending on the desired probability, where n is the number of keys."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is this really a google-interview question?  what else except for space efficiency?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"increase the chance of cache miss"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5633395035996160","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"19","title":"Given two log files, each with a billion usernames (each username appended to the log file), find the usernames existing in both documents?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Two approaches 1. Build Hash with smaller file and check for match in other Time O(n) Space O(n) 2. Sort both files (nlogn) and now find match with 2 fingered approach O(n) total complexity O(nlogn) + O(n) = O(nlogn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"What I would do, since clearly I cannot load both files in memory (probably not even each alone). I would still sort them (External merge sort, check wikipedia for that). Then I will load as much from each file as I can put into memory, for example 512kb from each file, and perform a merge sort where I only keep the last element and the list where it came from, if the came from different lists, I add it to my result set. When a chunk is over, I load the next chunk."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"How about this -  USe a trie-like data structure storing all valid user names. Populate it using one pass over the first list, keep marking the words present. Next, pass over the second list and keep looking up the trie for it. Pick the ones already present in trie and report them."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"How about using Bloom Filters. It can help in finding whether the element is present or not. Though, it might lead to false positives(showing element is present though it is not). In that case, go for other approaches like hash functions on smaller files."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You question about hashing that you just posted after this question was posted suggestion you already figured out what to do here."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a sort of open ended question. It is crucial to ask more details from the interviewer.   - Are we using a single core or a cluster of cpus?  - How much memory is available? Do the files fit in memory? - Can we create auxiliary files?  Assuming 1 cpu core, a possible approach could be partition the usernames into buckets. Each bucket contains a portion of the valid usernames.  Assume for simplicity that the alphabet used in the usernames are only letters A-Z. One possible partition would be to split all usernames starting with A to one file, B to a another file, etc. Then, each file will have a fraction of the billion usernames and we can intersect the usernames from the log files.  The above approach is very simple and won't partition the usernames into the buckets uniformly. We should discuss it further with the interviewer. We could try to check the usual distribution of the usernames over the alphabet and partition (start with A is probably more likely than starting with Q). Of course we don't need to split just by the starting character, but the first 2, 3, etc chars.  Note: don't assume the usernames use the latin charset. Ask first if other chars like Chinese or Japanese are used (unicode in general)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorting looks to me over kill, rather i would create index of string hashcode and save info like {hashcode, stringFileLocationArray} in a avl tree. O(n)  Once this structure is in place then scan second file pick each user name lookup hash code in index (nlog n) if hash code matches then compare with actual string in file.   you can use chche of strings read from file some kind of (LRU etc) to speed up matching. You can also do some IO optimization by adding all matched (hash code) in a queue and order items in queue by order of file location."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think a possible approach would be sorting both log files which will take O(nlogn) and, after that, read both files by chunks simply comparing the usernames and skipping when the username in one list is lower than the other one. Some kind of merge search..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First and foremost thing is to reduce the search Space. Every Name has vowels so basically use that property and generate words and reduce search space in both files and search only in that to determine the occurrence.   We can then hash them or sort them which ever way needed."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use trie (dictionary) is better.  let the length of user name is O(k).  First, load the first file, and build a dictionary. O(kn) time and O(kn) space.  Second, load the second file, for each user, search whether it exists in the dictionary. If it exists, output it. O(kn) time.  In general case, k is a small constant. The algorithm can achieve O(n) time and use O(n) space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how about start hashing both the files simulataneosly, take one username from one file, hashmap it (bucket hashing),,  then take one user name from second file do the same. Do this till for all 2 billions usernames. Once done, Space O(2n) = O(n). Pick any user name and you can check with O(1) if it has a duplicate. (worst case O(m) m being duplication constant or depends on the hashing function. do this for all 2N records, which would be O(2n) = O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I believe that the only way to solve that efficiently is to use famous B-Tree data structure. Building the tree will take O(N*Log(N)) but it shall be done only once. You can keep only some parts of the tree called pages in memory and the rest of them you can store on the file system so no problem with huge number of usernames and you wil still have O(Log N) to check if username already exists in the tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"To avoid space complexity,  1) simply compare first string from File1 with all strings in File2.  2) Repeat the same for all strings in File1.   Time complexity: n^2 Space complexity: 0"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5394358983458816","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"given string of chars??find way to compress consecutive char with no ambiguity. example??daaad to d4*ad; 5eeeecd to 5*14*ecd","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* Let me explain how this function works. This function takes a string called s and uses an algorithm to compress is. (*NOTE: this is slightly different from the questions ex:, but still accomplishes the same goal) this algorithm will take a string, say 45eeeedfghfffeff62 and transform it into 4_5_4edfgh3fe2f6_2. If there is a number to the left of a character, it is there to explain how many times that character should be multiplied (ex: eeee: 4e    dddddddddd : 10d) The \"_\" character is there to denote that if a number is by itself during input,say 6eee2, then the output will be 6_3e2. This is similar to the \"*\" character in the example. We do not want vagueness.  (*NOTE: this algorithm is to be used with very large strings. This will do a great job of compressing a large string, such as 5eeeeeeeeeedddddfff65ggggeeffssaasddffdsacvffd, but not smaller strings like 5ee (takes up the same amount of characters.  AUTHOR: BILL GLESIAS  this algorithm is implemented in c++ */    #include  #include  #include   std::string charCompress(std::string s){  unsigned i = 0;  std::string newString = \"\";  while( i < s.length()){    char r = s[i];   if( i == s.length()-1){    newString += s[i];      return newString;     }   else if(s[i] == s[i + 1]){    unsigned sum = 1;    while( i < s.length()- 1 && (s[i] == s[i + 1])){            sum++;     i++;        }    std::ostringstream convert;    convert << sum;     if( i == s.length()-1){    newString += convert.str() + r;      return newString;     }    else{          newString += convert.str() + r;    }       }//end if   else{       newString += s[i];    if(s[i] > 47 && s[i] < 58){    newString += \"_\";     }  }//end else   i++;  } }  int main(){  std::string a = charCompress(\"5eeeeddf55555dcgleeettff\");  std::cout << a << std::endl;      a = charCompress(\"5eeeeeeeeeedddddfff65ggggeeffssaasddffdsacvffd\");  std::cout << a << std::endl;  system(\"PAUSE\"); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It does not account for this input: 9___6aab The compression would yield: 9_3_6_2ab Decompression would incorrectly yield: 936aab"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5352828797190144","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"13","title":"Write a routine that does secret santa in O(N) time. I don't really understand what it means by 'does secret santa' actually.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Secret Santa should mean shuffle the contents of an array where if the index of element represent a person the content would represent the person who is assigned [for gifting] to him.  Input would             : 0 , 1, 2, 3, 4 ...n Output should be   : shuffled contents such that a[i] != i   Iterate over elements of the array:  copy the content to next cell  copy the content of last cell to first cell.  The approach can be randomized by picking the shift distance randomly instead of 1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"should have asked then, that might be the answer :D"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Input: A list of santas, by some unique identifier. Output: \"id1 --> id2\" means santa with id1 is assigned to the santa with id2.  If there are no restrictions on \"randomness\":"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Seems like the challenge is how to keep generating a random number within a range while excluding the numbers already picked."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the solution could be found in terms of permutations. First, let's define the state as some permutation that could be divided on cycles, like: 1 3 2 -> 2 cycles 1 -> 1, and 3 -> 2 -> 3. Then in one iteration we can merge 2 cycles. Just find random 2 components and random vertices in each.  Using pointers we can do everything in linear time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sounds like graph visitation problem, each person is a vertex, the direct edge is the direction of the gift giving, keep picking random vertices from a list of unvisited vertices  or put it another way, make the graph completely connected and do a DFS, skipping vertices that have already been visited"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"vector< pair > santa(vector& names) \n{ \n          vector tmp = names; \n          vector< pair > ans; \n          int n = names.size(); \n          for (int j = n-1; j>=1; j++) { \n                    int k = rand(0, j-1); \n                    swap(tmp[k], tmp[j]); \n          } \n          for (int i= 0 ; i < n; i++) \n                 ans.push_back( make_pair(tmp[i], names[i]) ); \n          return ans; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5840928073842688","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"17","title":"We have a list of N nodes with each node pointing to one of the N nodes.  It could even be pointing to itself. We call a node ??good??,  if it satisfies one of the following properties:  * It is the tail node (marked as node 1) * It is pointing to the tail node (node 1) * It is pointing to a good node  You can change the pointers of some nodes in order to make them all ??good??.  You are given the description of the nodes.  You have to find out what is minimum number of nodes that you have to change in order to make all the nodes good.  Input: The first line of input contains an integer number N which is the number of nodes.  The next N lines contains N numbers,  all between 1 and N.  The first number, is the number of the node pointed to by Node 1;  the second number is the number of the node pointed to by Node 2;  the third number is the number of the node pointed to by Node 3 and so on.  N is no larger than 1000.  Output: Print a single integer which is the answer to the problem  Sample Input 1: 5 1 2 3 4 5  Sample output 1: 4  Explanation: We have to change pointers for four nodes (node #2 to node #5) to point to node #1.  Thus 4 changes are required  Sample input 2: 5 5 5 5 5 5  Sample output 2: 1  Explanation: We have to just change node #5 to point to node #1 (tail node) which will make node #5 good. Since all the other nodes point to a good node (node #5), every node becomes a good node.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"1. Remove the edge (pointer) from 1. 2. Find connected components. 3. The answer is the number of connected components - 1 (i.e. all the connected components except for the one that contains 1)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I think this problem can be reduced to finding a spanning dfs forest with minimum number of trees.  1. First, we'll create a new graph by reversing all the edges in original input graph, this graph will simply be denoted by G. Notice that all the vertices reachable from 1 in G are \"good vertices\".  2. We'll build a stack of the roots of the dfs forest which is the result of running dfs on G starting from the vertex 1 and when you need to select a new root, select the minimum possible (notice that if all the vertices are reachable from 1 then instead of a forest we have a single tree). Whenever we encounter a new root throughout the dfs run we'll just push it to the stack.  3. We'll run dfs again on G but this time, instead of starting from 1, we'll use the roots stack from (2) whenever we need a new root to traverse from (roots that were already encountered throughout the dfs run will just be popped and ignored). Throughout this dfs run we'll yet again build a root stack of the roots in the dfs forest (for this dfs run).  4. The resulting root stack from step (3) should contain the minimum number of trees in the dfs forest for the graph G (considering the special structure of G - exactly 1 incoming edge to each vertex). The result is the number of roots in the stack from (3) minus 1 if 1 is a root as well.  Complexity: Two dfs runs - O(n) (the number of vertices and edges is O(n)).  Code: snipt.org/BihG4"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Find all good nodes from the begging.( BFS or DFS) 2. Then Find all strong connected components. From those node, who arent good. Answer uis a number of SCC."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. We just need to detect cycles and trees, later we need just count them as in cycle we can change any node to point to first node and in tree we need to change only root node to pointing to first node, the alg quite similar to union find"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For this input we just have to keep a set of unique numbers different then 1.  These are nodes which are connected neither to tail nor any 'good' node. The size of the set is the number of nodes which have to be changed. For the examples given in question: a) 5 5 5 5 5 5 - set is {5} - change one element the remaining elements are pointing to it. b)1 2 3 4 5 - set is {2 3 4 5} - None of the nodes is connected to the 'good' node so all of them have to be changed. I don't see any reason to construct a graph while we are able to determine the connections based on the node's values."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"keep a map M of lists such that map.get(i) = lists of nodes that points to (i) minus the i-th node; also keep a set S of good nodes, initialize with the tail node; then starting from the list of nodes that point to the tail node, proceed the lists and mark every node a good node (put it in the set S); repeat this step with nodes in the list; finish when every node in the list is already a good node or the list is empty;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"(1) Scan the list, for each node U if U points to V and V is not U, mark node U (there's an out going edge from U)   (2) Scan the list and count the number of node V that is not marked in (1) and that is not the tail."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Create a graph. First run strong connected component algorithm, in the SCCG count nodes without outgoing edges."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6228597727559680","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"29","title":"Generate MAX_INT (Max signed int value) using bitwise operators. Should work in 32 and 64 bit processors","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"int i = -1; i = i >>> 1;  //This will shift the singed bit to right by 1 and hence making the value 2147483647"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"The best way to get the max value of int on 32 or 64 bit processors is by negating the 0(so that we get all 1's) and then doing an unsigned right shift (>>> in java).  int c = (~0) >>> 1;  In C, if we do normal shift (~0 >> 1), the compiler will perform arithmetic shift and will append the sign bit into the shifted bit. Instead, we would have to force a logical shift by explicitly declaring the value as unsigned, i.e. by doing something like this:  ~0u >> 1;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"int int_max = (unsigned int)-1 >> 1;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int i=0; int int_max = ~i & (~i-1) //all ones and-ed with sign bit 0 rest all ones."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int m = ~(1<<(sizeof(int)*8-1))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int m = (~0u)>>1;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1 #include                                                                \n  2                                                                                  \n  3 int main()                                                                       \n  4 {                                                                                \n  5   unsigned int i=0;                                                              \n  6   printf(\"%u\\n\" ,((unsigned int)~i/2));                                          \n  7   return 0;                                                                      \n  8 }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def max_int():     import struct     max_int_list = [1] * (struct.calcsize(\"i\")*8)     max_int_list[0] = 0 # highest priorty bit is reserved for negative flag     max_int_str = \"\".join(str(x) for x in max_int_list)     print(max_int_str)     return int(max_int_str,2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def max_int(): \n    import struct \n    max_int_list = [1] * (struct.calcsize(\"i\")*8) \n    max_int_list[0] = 0 # highest priorty bit is reserved for negative flag \n    max_int_str = \"\".join(str(x) for x in max_int_list) \n    print(max_int_str) \n    return int(max_int_str,2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int MAX_INT = ~0 & ~(1 << 31);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  int main(){     printf(\"%u\\n\",((unsigned int)~0)); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \nint add(int i, int j) \n{ \n  int sum = i ^ j; \n  int carry = i & j; \n  while(carry != 0){ \n    carry = carry << 1; \n    i = sum; \n    j = carry; \n    sum = i ^ j; \n    carry = i & j; \n  } \n  return sum; \n} \n \nint multiply(int i, int j){ \n  int result = 0; \n  while(j != 0) \n  { \n    if(j & 01) \n    { \n      result = add(result, i); \n    } \n    i <<= 1; \n    j >>= 1; \n  } \n  return result; \n} \n \nint get() \n{ \n  int size = sizeof(int); \n  unsigned int ret = 1; \n  int i = 1; \n \n  while(true){ \n    if(i == 31) \n      return (int)(ret | (1 << size)); \n    i = add(i, 1); \n    ret <<= 1; \n    ret |= 1; \n  } \n} \n \nint main() \n{ \n  printf(\"%d\\n\", get()); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"AD's answer is perfect. Here is a bit of explanation:   Imagine you have a signed 4 bit system. In that system"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"career cup app for android"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int int_max = -1 >> 1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class GenMaxInt { \n    public static void main(String[] args) { \n        int i = 0; \n        int j =0; \n        int ans =0; \n        while(true) { \n            int y = ~i& 1 << j; \n            if( y < 0) { \n               System.out.println(ans); \n               break; \n            } \n            ans += y; \n            j++; \n        } \n    } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"printf(\"MAX_INT=%d\\n\", ~(1<<31));"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//C++ int int_max=~(1<<31); int int_min=1<<31;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// Generate INT_MAX \nvoid int_max_generate() \n{ \n int num = 1; \n num = static_cast(-1) >> 1; // instead of -1 use ~0 \n cout << num << endl; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#include  int main(){     printf(\"%u\\n\",((unsigned int)~0)); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"int int_max = -1 >> 1"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6696054317645824","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"9","title":"You have a plain with lots of rectangles on it, find out how many of them intersect","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"You need to project them on axis X and form massiv on begins end ends of their sides. Then you do the same on Y axis. After that we consiver all rectangles that fits int some interval of another interval. And check wther those rects are intersect."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Instead of finding which intersect, find the conditions where they dont intersect. There are total 4 conditions which tell if two rectangles intersect or not. For all the rectangles that pass those 4 conditions, means they intersect."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"New free career cup android app   store/apps/details?id=com.andersoncouncil.careercup.ui"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can we assume that the edges of the rectangle are parallel to the X and Y axis?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have a solution O(n^2) though for a larger number of rectangles it may not work.  simply add a boundary check whether a particular point falls in that boundary."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a famous swipe line algorithm used to solve this problem. First let's have a data structure that stores segments [le, ri] and can answer these questions: 1) query1(X) : how many segments are there with le > X. 2) query2(X) : how many segments are there with ri < X. 3) total number of segments in data structure. 4) Add segment 5) Delete segment Then let's create a vector of events:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4601987345678336","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"9","title":"Sort a list of numbers in which each number is at a distance k from its actual position","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There Can be two approaches both are easy ones.  First. 1. Insert K elements in heap 2. after that delete min and add new element 3.repeat till the end complexity nlogk  Second This one also provides nlogk but needs a better implementation of merge sort 1.divide array in n/k parts 2. sort those subparts O(klogk) time 3.Merge them from left"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question says at a position k from its actual positions. So,  assuming that we can take an extra array, we start traversing the array. For element at 0th index we put, kth element.  Similarly for any index i, we find element at (i-k), (i+k) index. We put at that position the leat of the two nos. provided the element is greater or equal to the element at (i-1) index."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@Shankar: Can you please give some example for this question? I have some doubts regarding this question: 1) Output array will be fully sorted? in that case there will be only one possible position for each element in array, how can that be k from its initial position? 2) Is it possible that there is no solution of some given input? 3) Or output should be just each element should be k distance away from its initial position, but not sorted among themselves ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i am doubtful about first solution...are you using heap-sort. what will be size of heap ..if i am understanding que properly ..then is it like below 0 --- n --> k+0 -->k+n-1 then we can apply simple sorting  (k+intial_index,k+end)  ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is each element *exactly* k positions from its actual position or *at most* k positions from its actual position? If the former, simple swapping suffices. If the latter, one method is to have a moving window of length k. Find the smallest element of this window and then move the window to the right. (Represent the window as a heap to do this efficiently.)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Isn't just about rotating the list about k positions so as to put number on its correct position? 1) Convert the list to the array to quickly access random elements. 2) Rotate array about k positions. 3) Reconstruct the list from the rotated array"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Its not clear if this is in place sorting or can use a new Array. In any case, to get new position use (index + k) % N where index is the ith position in the array, k is the number to shift by and N is the size of the Array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In my understanding, if we want to make sure all elements are shifted k distance, k and N must satisfy: (1) N >= 2k; (2) N % 2k == 0  For example: input: 1, 2, 3, 4, 5, 6, 7, 8 N = 8, k = 3;  1. consider input[0], it can only be moved to input[3]; and only input[3] can be moved to input[0] to fill it; thus, they are going to be swapped.  2. situation 1 applies when input[i] < k; and after doing that, all first 2k numbers are sorted.    we get  4, 5, 6, 1, 2, 3, 7, 8 3. now we need to get into next segment 7, 8; it is clear that they can not be sorted. This is the reason for the 2 conditions mentioned in the beginning."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"since each number is at a distance k from its actual position, there are an even number of elements and to sort all one has to do is swap.  Let N be the size of the array  The size of the array is at least 2k for(int i=0; i   swap(a[i], a[i+k]);  if(4k <= N)     for(int i=0; i                    swap(a[2k+i], a[2k+i+k]);  and so on till the end of the array , i.e., divide the array into blocks of size 2k, and inside each block swap the elements which are at a distance of k"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6361609643491328","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"3","title":"Store a set of sudden-death tournament results in a compact format (eg. a bit array) and a set of predicted match results (also in a bit array). Score the predictions, giving one point per correctly guessed match, without unpacking the bit array into a more convenient format (ie. you have to traverse the tree in-place).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Could you please explain the question? Example is plus"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"just XOR the bit positions, if its a 0 then we have a successful predictions. You can have two byte arrays in java. Initially all are zero and after that for each number of tournaments shift 1 to the number to the left and make an AND and test that corresponding bit."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"MSB : the result of the final. If a team from the left bracket wins, put 0 in MSB. Otherwise, 1. MSB-1 : the result of the semi-final of the left bracket.  MSB-2 : the result of the semi-final of the right bracket. the next four bits are the results of quarter finals.  In this way, make an integer value S for scores, P for predictions. ~(S^P) shows how many predictions were correct. Just the count the 1 in ~(S^P) and that's the number of correct predictions."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5570154410803200","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"Implement a simple regex parser which, given a string and a pattern, returns a boolean indicating whether the input matches the pattern. By simple, we mean that the regex can only contain special character: * (star), . (dot), + (plus). The star means what you'd expect, that there will be zero or more of previous character in that place in the pattern. The dot means any character for that position. The plus means one or more of previous character in that place in the pattern.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is written in Go:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There could be DP approach. f[i][j] = true / false (can we parse first j characters of the string with first i characters of the regexp). We also can represent regexp as automata, but that is optional."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6666552321507328","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"5","title":"1. find all the combinations of a string in lowercase and uppercase. For example, string \"ab\" -> \"ab\", \"Ab\", \"aB\", \"AB\". So, you will have 2^n (n = number of chars in the string) output strings. The goal is for you to test each of these string and see if it match a hidden string.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"One possible Solution using BFS:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What's the meaning of a hidden string? If it is totally hidden, how can we check if it is matched."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"One possible Solution using BFS:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just double-clicked the submit button... Sorry for that :("},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i think you can just turn both to all lowercase and compare? to use extra O(2^n) time and space just for finding if the hidden string matches a give string doesn't make any sense to me."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4582840347918336","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"int[] first = {3};   // size 1 int[] second = new int[3];    // size 3 second[0] = 2; second[1] = 4;   //2,4  Second array has enough space to hold all elements of first and second array, where both the arrays are merged. Now write code to have first array into second.  The following Cracking the coding interview code doesn't work.   public static int[] merge2(int[] first, int[] second){   int lastA = first.length-1;  //0   int lastB = second.length-1;   //2   int indexMerge = (lastA + lastB);   while(lastA >= 0 && lastB >= 0){    if(first[lastA] > second[lastB]){     second[indexMerge] = first[lastA];     indexMerge--;     lastA--;        }else{     second[indexMerge] = second[lastB];     indexMerge--;     lastB--;    }       }      while(lastA >= 0){    second[indexMerge] = first[lastA];    indexMerge--;    lastA--;   }   return second;  }","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i think, in this case we can  modify int indexMerge = (lastA + lastB); to int indexMerge = (lastA + lastB) +1; because you are couting 0 twice for same position.."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5326347538792448","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"16","title":"You are given a 2-Dimensional array with M rows and N columns. You are initially positioned at (0,0) which is the top-left cell in the array. You are allowed to move either right or downwards. The array is filled with 1's and 0's. A 1 indicates that you can move through that cell, a 0 indicates that you cannot move through the cell. Given a function numberOfPaths which takes in the above 2-D array, return the number of paths from the top-left cell to the bottom-right cell (i.e. (0,0) to (M-1,N-1)).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"We can solve the above problem using recursion with backtracking.  We start by moving from the bottom-right cell that is (m-1,n-1). We can move either left or top from each cell. Recursively call the findPath function with left cell and top cell. If you encounter a 0 at a cell position, discard that path. When we reach the (0,0) cell, increment the count variable.  Keep a count variable that keeps track of all the possible path.  Code :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would think that you can do BFS.   Mark nodes visited with a negative value, starting with -1. When two paths meet the same point make it count for path 1 + path 2. I.e. -1 + -1 = -2 etc. Return the value when you reach end."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Using DP \n \nint a[m][n]; \nint paths[m][n] = {0}; \n \nfor(i=0; i=0?paths[i-1][j]:0) + (j-1>=0?paths[i][j-1]:0); \n } \n} \n \nprintf(\"Number of paths = %d\\n\", paths[m-1][n-1]);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Convert the matrix to a DAG: each '1' cell makes a vertex, which is connected to its right/down neighbors (if exist). There are no back edges (cycles), because we're not allowed to go up or left - hence we have a DAG. This is good, because there are polynomial algorithms for finding all paths between two nodes in a DAG: the idea resembles DP, where in each step we build on top of the previous ones. we'll compute the number of distinct paths from a given node to the target node by summing up the paths counters of its descendants. we start from the nodes directly connected with the target node and go backwards till we get to the source. the easiest way for verifying that we only process a node after all its children are processed is to run first a topological sort and then process the nodes in a topological reverse order."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class FindPath { \n \n /** \n  * @param args \n  */ \n int m=5; \n int n=5; \n static int count=0; \n  \n public static void main(String[] args) { \n   \n  FindPath fp=new FindPath(); \n   \n  int arr[][]=new int[][]{{1,0,1,0,0},{1,0,0,1,1},{1,1,1,1,1},{0,1,1,1,1},{1,1,0,0,1}}; \n  fp.findPaths(arr,0,0,\"\"); \n  System.out.println(\"Total Path : \"+count); \n } \n \n private void findPaths(int[][] arr, int i, int j, String path) { \n   \n  path=path+\" (\"+i+\",\"+j+\")\"; \n  if(i==(m-1) && j==(n-1)) \n  { \n   System.out.println(path); \n   count++; \n   return; \n  } \n   \n  if(i<(m-1) && arr[i+1][j]==1) \n  {    \n   findPaths(arr, i+1, j, path); \n  } \n  if(j<(n-1) && arr[i][j+1]==1) \n  { \n   findPaths(arr, i, j+1, path); \n  } \n   \n    \n   return; \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void PathArray()         {             int[,] ipmatrix = new int[4, 4] { { 1,1,0,0 }, { 1,1,1,0}, {0,1,1,0}, { 1,0,1,1} };             int rowlen=ipmatrix.GetLength(0);             int collen=ipmatrix.GetLength(1);             int count = 0;             count=   wrapperpatharray(ipmatrix, 0, 0, rowlen, collen);          }          public int wrapperpatharray(int[,] ip,int i,int j, int rowlen, int collen)         {                          if (i == rowlen - 1 && j == collen - 1)             {                 Console.WriteLine(\"Pathfound\");                 return 1;             }             if (i > rowlen - 1 || j > collen - 1)                 return 0;             if (ip[i, j] == 0)                 return 0;                   return( wrapperpatharray(ip, i, j + 1, rowlen, collen)+          wrapperpatharray(ip, i + 1, j, rowlen, collen));                      }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/// function numberOfPaths(arr) {   // Assume each row has the same number of arguments  var M = _array.length;  var N = _array[0].length;  var pathCount = 0;   var x = 0;  var y = 0;   findPath(arr, x, y, M, N);  console.log(pathCount + \" paths found!\");   function findPath(a, x, y, rows, cols) {    if (a[y][x]) {     // Check end condition    if (y == rows-1 && x == cols-1) {     pathCount++;    }    if (x+1 < cols) {      // Check right     findPath(a, x+1, y, rows, cols);    }    if (y+1 < rows) {      // Check down     findPath(a, x, y+1, rows, cols);    }   }   else {    console.log(\"Dead end (\"+y+\", \"+x+\")\");   }  } } \\\\\\"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use DP...o(n2) solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package test;  public class ArrayPath {   private int totalNumberOfPath = 0;    public int numberOfPaths(int[][] array) {   if (array[0].length == 0 || array.length == 0) {    return -1;   }   findPath(array,0,0);   return totalNumberOfPath;  }    private void findPath(int[][] array, int posX, int posY) {   if (posX == array[0].length - 1 && posY == array.length -1) {    totalNumberOfPath++;    return;   }    if (posX+1 < array[0].length  && array[posY][posX+1] == 1) {    findPath(array, posX+1, posY);   }   if (posY+1 < array.length && array[posY+1][posX] == 1) {    findPath(array, posX, posY+1);   }   return;  }    public static void main(String argv[]) {   ArrayPath arrayPath = new ArrayPath();   int[][] array = {{1, 1, 1, 1},        {1, 1, 1, 1},        {1, 0, 1, 1}};      System.out.println(arrayPath.numberOfPaths(array));  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Use the android app for Careercup   store/apps/details?id=com.andersoncouncil.careercup.ui"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4617309071081472","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"5","title":"Given a kernal code in \"0\"th machine. How soon you can replicate the kernal across N machines. Now if the machines has upload and download bandwidth constraints, how can you impove the copy time.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I can think of three basic mechanisms for accelerating the content distribution to N nodes: 1. compression: data is compressed before transmission and decompressed before deployment. we'll need the compression factor in order to calculate its impact. 2. pipelining: intermediate nodes starts transmitting to the next machine before getting the full content. this is mainly effective when download speed is greater-equal to upload speed, so after some initial buffering period each machine transmits at the same rate it receives. 3. sprinkling: transmit to more than one machine simultaneously. this puts an interesting trade-off, because a single transmission becomes slower, but the number of transmitting machines grows exponentially.  Let's put all this in one model: N: number of machines, FSZ: file size in Mb, CMP: compression factor, CMPT: time to compress/decompress 1Mb, SPD: min(Upload,Download) in 1Mbps, BUF: buffering period before starting to pipeline, SPR: sprinkling factor.  SingleTransmission = (FSZ * SPR) / (SPD * CMP) DistributionTime(N) = SingleTransmission + BUF * (LOG(N-1, SPR)-2) + 2 * CMPT   For example, if the sprinkling factor is 2, then we only need log2(N-1) copying phases. only the intermediate ones needs a buffering period, so we can ignore the first and last phases. As for compression time, we count it once for the initial file compression and once for decompressing the file at the last phase's nodes. Decompressing at the intermediate nodes does not increase the total copying time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can we use the Bit Torrent protocol for transferring the large files across N machines. This is one of the way to overcome the network bandwidth constraints."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I believe overcoming network bandwidth constraints is not about large files, but transferring data efficiently through large capacity links. Depending on the network protocol you may think of different approaches of data segmentation.  I wonder, has anyone ever thought of using Minimum Spanning Tree (MST) for this problem? It is centralized, rather than distributed approach. Each node (machine) needs to have the full information of the network links and bandwidth to compute a tree that spans along entire network."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why we need upload and download bandwidth, meaning we can have a centralized server so that we can upload the data from the 0th machine to the server and then stream to the rest N machines?  In this sense, if there is no bandwidth constraints, and downloads can proceed while uploading is ongoing, the fastest way is to have sprinkling factor = N, meaning N machines to download at the same time, then take buffering into consideration, we can simply do the math; if there is bandwidth constraints, then we need to reconsider sprinkling factor, because more downloading simultaneously, more overhead."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5453933971505152","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"5","title":"Consider in Java arraylist we have mix of int, double, float, string, etc. How will you find if a given index of arraylist have string. No need to worry about generics and type safe.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"boolean isString(ArrayList arr, int idx) { \n                if (arr == null || idx < 0 || idx >= arr.size()) return false; \n                return  arr.get(idx) instanceof String  ? true : false; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Maybe with instanceof operator? Like  if (element instanceof String) { //do stuff }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"yes, you are partially right. The explanation to this is:  as in ArrayList each element will be stored as its corresponding wrapper class, i.e. int as Integer, float as Float, double as Double, and hence now we may apply:  if(element instanceof yourwrapper_datatype) { //do stuff }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Each non-primitive type (like Integer but not int), inherits from the Object class the method getClass(). this getClass() further supports .getName(), which returns the name of the class of the object.   For example:  String s=\"blabla\"; System.out.println(s.getClass().getName()); //returns java.lang.String  Integer i=1; System.out.println(s.getClass().getName()); //returns java.lang.Integer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Perform a divison or multiplication  if its throws an exception its a string ."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5449136090382336","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"30","title":"Consider the following array   {1,2,3,4,5,2,5,4,4}; In the above array, index 4 could be considered as breaking point where summation of 0 to 4 in the array is equal to summation of 5 to end of array. We need to find the breaking point for the given array. I solved this. But follow up was for this array","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"Java Code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"My solution would be: 1. divide the array to 2 sum sets, at this step first = 0, second = sum(arr) 2. maintain an index \"i\" initialized to 0 3. substract arr[i] from \"second\" and add the value to \"first\", then increment \"i\" 4. repeat the previous step until \"first\" and \"second\" are not equal, the solution will be \"i-1\" (but of course you can rearrange the loop as you like)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"1) Count two cumulative sums from left to right and from right to left. Store the results in corresponding arrays. 2) Iterate over the left -> right array and check if at any position leftRight[i] == rightLeft[i+1] if yes current position is a breaking point. Code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Really all you're asking for is to find an index k such that arr[0] + ... + arr[k] = 1/2 * sum of entire array. You could sum up the list, set your target value as 1/2 of the sum, and then start summing elements from the beginning until the total reaches the target value."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simply use a cumulative array. Keep summing up the elements until the end. If the value at the end is n, the breaking point is the location where the sum is n/2."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think in the above mentioned approach we will have to traverse the array twice. I am suggesting a small change. Better we maintain two sums as mentioned above. lets say beginningSum, endingSum. beginningSum = endingSum = 0 ; two indices, startIndex and endIndex; startIndex = 0;  lastIndex= arrayLength -1; while(startIndex < lastIndex) { beginningSum = beginningSum+array[startIndex]; endSum = endSum+array[lastIndex]; if(beginningSum < endSum) { beginningIndex++; } else { lastIndex++; } } if(endSum == beginningSum) { print start index as breaking point  } else { print no breaking point exists }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int findBreakPoint(int [] array){ \n  int sum = 0; \n  for (int i = 0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int findBreakingPoint (int[] arr) { \n  int sum = 0; \n  for (int i:arr) { \n    sum += i; \n  } \n  int newSum=0; \n  for (int brPoint=0; brPoint"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int findBreakingPoint (int[] arr) { \n if (arr.length > 0) { \n  int sum = 0; \n  for (int i:arr) sum += i; \n  if (sum^1 != 0) return -1; \\\\sum cannot be odd \n  sum >>= 1; \n  for (int pos = 0; pos < arr.length; pos++) { \n   target -= arr[pos]; \n   if (target == 0) return pos; \n  } \n } \n return -1; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use dynamic programming here is a solution in python:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sum=sum of all of the elements at array a int tempSum=0; int j; for(j=N-1;j<=0;j--) {     sum-=a[j];     tempSun+=a[j];     if(sum==tempSum)break; } return j-1;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I started with 2 sub-Arrays. Front-Array starts with only one element and grows till the 2nd last element ((n-1)st element). The Back array consists all the elements from 2nd element to the last element (nth element) and it reduces to just one element(last element)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int getBreakingPoint( int[]  array )     {         int sum = 0;          for( int element : array)             sum += element;          if((sum & 1) != 0)             return -1;          int breakVal = sum >> 1;          int breakSum = 0;          for (int i = 0; i < array.length - 1; i++) {             breakSum += array[i];             if(breakSum == breakVal)                 return i;         }          return -1;     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Step1 : First sum all the element of array.and store this in variable part2, \n \nStep 2: Initialize variable part1 to 0 and iterate array from index  0. \n \nStep 3: For each iteration part1=part1+array[index]  and part2=part2-array[index] and chk for (part1==part2), if it satisfy this condtion den current index is the breaking point."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Step1 : First sum all the element of array.and store this in variable part2,  Step 2: Initialize variable part1 to 0 and iterate array from index  0.  Step 3: For each iteration part1=part1+array[index]  and part2=part2-array[index] and chk for (part1==part2), if it satisfy this condtion den current index is the breaking point."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//works with negative values \n int GetBreakingPoint(int arr[], int nSize) \n { \n  int nTotalSum = 0; \n \n  for(int i = 0; i < nSize; ++i) \n  { \n   nTotalSum += arr[i]; \n  } \n \n  if(nTotalSum % 2) \n   return -1; \n \n \n  int nItemVal = nTotalSum/2; \n \n  int nBPIndex = -1; \n \n  for(int i = 0; i < nSize; ++i) \n  { \n   if(i != 0) \n   { \n    arr[i] = arr[i] + arr[i - 1]; \n    if(arr[i] == nItemVal) \n    { \n     nBPIndex = i; \n     break; \n    } \n   } \n  } \n \n  //restore the array \n  if(nBPIndex != -1) \n  { \n   for(int i = nBPIndex; i > 0; --i) \n   { \n    arr[i] = arr[i] - arr[i - 1]; \n   } \n \n  } \n \n  return nBPIndex; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static int findBreakingpt(int[] in) { \n  int result1=0; \n  int result2=0; \n  for(int i =0;iresult1) \n      break; \n   } \n   if(result1 == result2) \n    return i; \n  } \n   \n  return -1; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In case someone wants a recursive approach , not the most optimal, but simple to understand"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"One more approach. Using the sum/2 method."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5695609600212992","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"17","title":"How would you synchronize a linked list across multiple computers. If nodes are added/removed to a linked list on one computer, all others must reflect this change. Concurrancy must be accounted for. (java)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"One solution is that, Identify one node as primary node, and everytime there needs to be a change in local copy, lock the linked list in primary node, perform change in local copy, update it to reflect in the primary node, relese lock, send broadcast message to everyother node to sync to latest, with ChangeID."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Distributed locks!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be done without distributed locks--however, coding and analyzing this approach in a short interview is really not realistic. Links aren't allowed here, so just google \"Lock-Free Linked Lists and Skip Lists\" by Fomitchev and Ruppert."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please check below link for solution:  trydatastructure.blogspot.com/2014/01/technical-question-answer.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Google \"Paxos Made Live - An Engineering Perspective\"."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can use optimistic locking machanism."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can tackle this problem using a master for synchronization and N nodes for actual storage of the linked list.  Every time a node wants to do something on the linked list (since we are using a linked list we can suppose the operations available are append on both ends/remove on both ends), it has first to acquire a lock which state is controlled by the master.  This will work but won't allow for much concurrency as no parallel operations would be possible.  If we want to allow parallel operations to occur, we can make the operations reported (marked as => below) to the master before they are actually performed on any node : Operation 1 - Node i => Append 3 to the linked list Operation 2 - Node j => Remove the top element of the linked list  The master would allow the operation 1 and start propagating it to every N nodes. Then it would see the operation 2 and would not allow it as it is not compatible with operation 1 (add/delete on the same side cannot be done concurrently).  Another sequence could be: Operation 1 - Node i => Append 3 to the linked list Operation 2 - Node j => Append 5 to the linked list  In that case, the master could allow each operation to be performed but would propagate operation 1 before it actually starts propagating operation 2.  In my opinion, the key point here is to ask : - should we allow parallel operations and which ones ? if no, then a master lock will do fine - does it matter if the order of insertion/deletion is not respected ? (i.e. we can permute two consecutive append or two consecutive delete) If not, then we can allow for some leven of concurrency"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There can be two ways of doing this: [1] Consistent way where the linked lists in different computers are guaranteed to be consistent. This however will be at the expense of availability and latency. When an update happens on one machine, it sends the update to the other machines and  waits till a majority of updates are applied. When a read query comes, it must also look for a majority of machines to agree on the state of the linked list. Paxos may be used to do this more efficiently.  [2] Eventually consistent way where the linked lists may be out-of-sync for a small amount of time, but they will be in-sync eventually. Here every machine sends its updates with timestamps to everybody else. When one machine receives others updates, it will apply those and its own based on the timestamp.  This is just a brief sketch - there are more issues here like what if updates come out-of-order, machine goes down, network partition, durability (commit log) etc"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5719778454929408","download_status":"DOWNLOAD_DONE","votes":"-2","answersCount":"3","title":"Bag-of-words model. Write the process of search based on inverted index. The follow up is given some attributes(an array), how to filter the search result.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the question needs to be clarified."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the question needs to be modified."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5666130555305984","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"14","title":"Find the shortest path in a maze (from origin to destination). I believe we are supposed to use Dijkstra or BFS. But what I am confused with is that Dijkstra computes the shortest path based on the distance of each edge. But a maze doesn't have weighted edges, and its shortest path should be 'minimum number of cells'. How can we make use of Dijkstra, or BFS?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"DFS is a natural selection for searching a maze."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Dijkstra is for finding the short path on a weighted graph, that would apply if the edges have weights, otherwise you can use BFS on an unweighted graph.  A maze could either be weighted or not.  Weighted if you treat long paths without decision points as a longer edge or unweighted if you treat the same as multiple edges.  If you have a lot of long paths like that a weighted graph would be smaller in size this way (kinda how some compression works)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since in your graph all the edges have the same weight, you can use a BFS to get the shortest path as well with cost O(|E|+|V|)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"kelvin198897, you should have provided this matrix detail about the maze earlier ;)  Also, BFS will reveal the shortest path for graph which has edges of same weight (as is the case here), missed to notice that earlier :)  Here is an attempt to solve this in Java. I have assumed that only row or column movements are allowed, no diagonal ones. Also, it is important to notice that while nodes are being discovered - for current node, only the next one in its row and next one in its column matter (diagonal ones not allowed, previous ones in row and column must have already been discovered). Also, start is at (0,0)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use a Dijkstra and on encountering a wall at a position make the distance to that position as infinity or do not add it to heap for consideration."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"You may represent maze in a two dimensional array. BFS should be applicable to find the shortest path from source to the destination. Depending how you can move through the maze, simple iterative approach can be implemented. Suppose right, down and diagonal - distance for each cell from source will be min(a[i-1][j-1], a[i][j-1], a[i-1][j])+1. Another alternative is recursive approach.  Sample code for recursive BFS"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"As far as I remember, mazes are generally solved using DFS. In this problem, there are 2 parts (i) find the destination/exit in the maze (ii) find the shortest path from start to destination.  If there is no other information available about the maze, I think we can make 2 assumptions (i) the number of edges in the path is its length (ii) there is only one exit/destination in the maze.  Using the above assumption, a simple solution is: (i) find destination using DFS (ii) apply Dijkstra's algorithm to find shortest path.  Total runtime = O((|V|+|E|)*log|V|) ... Dijkstra's runtime dominates DFS's runtime"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5177997858439168","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"5","title":"The final question was just how to write a connection pool (i.e, a class that returns connections to the user, and if the user is done, returns them back to the pool)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"This is about creating a Singlenton class that holds a cache of connections so that the connections can be reused when future requests to the database are required.   When you say that \"When the user is done, returns them back to the pool\" means that you just freed one of your N connection hold in your cache, wich means It can be use by another user/request/process/thread/etc  There is a creational design pattern called  object pool pattern if you want to get into details.  Additionally, there are a lot open source software that are in charged of such task.  In real life, It is hard that someones needs to rebuild the wheel, but It is a good idea to knoew in details such open source software to disscuss it during the interview and why not came up with your own implentation.  hope It works.  cheers"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This is semaphore problem. Let say you have 20 connection pools, you will allow 20 threads to get the pool, and wait if there are more requests coming in. Until one of them returns it to the pool then the waiting thread can get it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A. Keep a maxCount that depends on the underlying implementation of the resource availability such as max allowed connections in an RDBMS.  B. Keep a currentCount that needs to be synchronized across threads when incrementing/decrementing C. Keep a timeOut in case, connection is not released  D. Keep a Queue for waiting clients in case pool is full, must be synchronized as well for multi-threading E. High level methods: getConnection, releaseConnection, forceTimeout, Queue operations such as push, pop etc."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For others, a 'connection pool' is for databases, not web connections (at least, the DB version was what came up first on Google). I had a hard time imagining how web-connections could be reused."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5965996481314816","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"2","title":"Difference between cloning a directed graph vs undirected graph. There are lots of tutorials on how to clone a directed graph online, such as leetcode. But what if it's undirected graph? It appears to me that it would be pretty much the same? For example,","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Yes, you are right. Undirected graph cloning is pretty much the same. It is just cloning the structure which requires (as you correctly pointed out) a map of original nodes to new nodes."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Could it be that in an un-directed graph, we could skip edges that were already visited since they appear twice in the representation of un-directed graph ?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6333076967784448","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"23","title":"Does a given file name match a single-star pattern? (can't use regex I assume) index.html matches *.html foo.txt does not match *.html  matches(??£þindex.html???, ??£þ*html???) returns true matches(??£þfoo.txt???, ??£þ*html???) returns false matches(??£þcat???, ??£þc*t???) returns true","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static bool Matches(string text, string pattern) \n        { \n            if (text == string.Empty && pattern == string.Empty) \n                return true; \n             \n            int i = 0; \n            for (; i < pattern.Length && i= i || pattern.Length - 1 >= i) \n                return false; \n \n            return true; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static bool Match(string p, string s) \n        { \n            if (string.IsNullOrEmpty(p)) \n            { \n                throw new ArgumentNullException(\"pattern cannot be null or empty\"); \n            } \n \n            int i = 0; \n            while (p[i] != '*') \n            { \n                if (i >= s.Length || p[i] != s[i]) \n                { \n                    return false; \n                } \n \n                i++; \n                if (i == p.Length) \n                { \n                    throw new ArgumentException(\"Pattern doesn't have *\"); \n                } \n            } \n \n            if (s.Length - i < p.Length - 1 - i) \n            { \n                return false; // s doesn't have enough leftover to compare \n            } \n \n            // Compare everything behind the * \n            for (int j = 0; j < p.Length - 1 - i; j++) \n            { \n                if (p[p.Length - j - 1] == '*') \n                { \n                    throw new ArgumentException(\"multiple *s detected\"); \n                } \n \n                if (s[s.Length - j - 1] != p[p.Length - j - 1]) \n                { \n                    return false; \n                } \n            } \n \n            return true; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static boolean matches(String fileName, String singleStarPattern) throws FileNameFormatException, singleStarPatternFormatException { \n \n        if(fileName.contains(\"*\")) \n            return false; \n \n        if(singleStarPattern.indexOf(\"*\") != singleStarPattern.lastIndexOf(\"*\") || !singleStarPattern.contains(\"*\")) \n            return false; \n \n        int startRun = 0; \n \n        while (fileName.charAt(startRun) == singleStarPattern.charAt(startRun)) \n            startRun++; \n \n        int endRun = singleStarPattern.length() - 1; \n \n        int run = fileName.length() - 1; \n \n        while (fileName.charAt(run) == singleStarPattern.charAt(endRun)) \n        { \n            run --; \n            endRun --; \n        } \n \n        return startRun == endRun; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// The main function that checks if two given strings match. The first \n// string may contain wildcard characters \nbool match(char *first, char * second) \n{ \n    // If we reach at the end of both strings, we are done \n    if (*first == '\\0' && *second == '\\0') \n        return true; \n  \n    // Make sure that the characters after '*' are present in second string. \n    // This function assumes that the first string will not contain two \n    // consecutive '*'  \n    if (*first == '*' && *(first+1) != '\\0' && *second == '\\0') \n        return false; \n  \n    // If the first string contains '?', or current characters of both  \n    // strings match \n    if (*first == '?' || *first == *second) \n        return match(first+1, second+1); \n  \n    // If there is *, then there are two possibilities \n    // a) We consider current character of second string \n    // b) We ignore current character of second string. \n    if (*first == '*') \n        return match(first+1, second) || match(first, second+1); \n    return false; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algo: regex_matcher(s1, s2) 1. if s1 and s2 are empty return true 2. if *s1 and *s2 are same recurse for rest of the strings 3. if in wildcard string(s2) we find * we have option of skipping it and going ahead with next character or match one character in s1 and recurse 4. if none of the above matches return false"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"boolean isMatch(String src, String pattern) \n { \n  int src_index =0; \n  int pattern_index = 0; \n  while(src_index < src.length() && pattern_index < pattern.length()) \n  { \n   if(pattern.charAt(pattern_index)=='*') \n   { \n    if(pattern_index+1 < pattern.length()) \n    { \n     pattern_index++; \n     while(src_index < src.length() && src.charAt(src_index)!=pattern.charAt(pattern_index)) \n     { \n      src_index++; \n     } \n     if(src_index >= src.length()) \n      return false; \n    } \n    else \n    { \n     return true; \n    } \n   } \n   else \n   { \n    pattern_index++; \n    src_index++; \n   } \n  } \n  if(pattern_index < pattern.length() || src_index < src.length()) \n   return false; \n  else \n   return true; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"boolean isMatch(String src, String pattern) \n { \n  int src_index =0; \n  int pattern_index = 0; \n  while(src_index < src.length() && pattern_index < pattern.length()) \n  { \n   if(pattern.charAt(pattern_index)=='*') \n   { \n    if(pattern_index+1 < pattern.length()) \n    { \n     pattern_index++; \n     while(src_index < src.length() && src.charAt(src_index)!=pattern.charAt(pattern_index)) \n     { \n      src_index++; \n     } \n     if(src_index >= src.length()) \n      return false; \n    } \n    else \n    { \n     return true; \n    } \n   } \n   else \n   { \n    pattern_index++; \n    src_index++; \n   } \n  } \n  if(pattern_index < pattern.length() || src_index < src.length()) \n   return false; \n  else \n   return true; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static boolean matches(String text , String pattern){ \n  int p_length = 0; \n  for (int i = 0 ;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It seems to me this is mainly about catching all the \"edge cases.\" I think I got them all but maybe not:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The recursive version that many have posted is elegant but not efficient since it performs backtracking.  We can match any regex in a single scan, although it may be tricky.  In my case, it was just a lot of tricky edge cases.    Here's my shot at it:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private boolean matches(String text, String pattern) {      if (text == null && pattern == null) return true;      if ((text != null && pattern == null) || (text==null && pattern!=null) ) return false;      for (int i=0;i      if(pattern.charAt(i) == '*') {         return text.contains(pattern.substring(i+1));       } else (pattern.charAt(i) == text.charAt(i)) {         return matches(text.substring(i + 1), pattern.substring(i + 1));       }     }     return false;   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static bool matches(string input, string pattern) \n        { \n            bool matches = true; \n \n            if (pattern.Count(c => c == '*') != 1) \n                return false; \n            var parts = pattern.Split('*'); \n            if (parts.Length != 2) \n                return false; \n            bool isLeftSideNotEmpty = !String.IsNullOrEmpty(parts[0]); \n            bool isRightSideNotEmpty = !String.IsNullOrEmpty(parts[1]); \n \n            if (isLeftSideNotEmpty) \n            { \n                matches &= input.StartsWith(parts[0]); \n            } \n \n            if (isRightSideNotEmpty) \n            { \n                matches &= input.EndsWith(parts[1]); \n            } \n \n            Console.WriteLine(matches); \n            return matches; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we just have to find whether the left hand side string of * is a prefix and right hand size is a suffix. then we will need to find whether suffix.length + prefix.length < original_string.length or not. If * also allows blank characters we even will not need this check.  we have to assume that blank \"\" character is always a prefix and suffix."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/*     Check if a given file name match a single-star pattern? (can't use regex I)      index.html matches *.html      foo.txt does not match *.html           matches(\"index.html\", \"*html\") returns true      matches(\"foo.txt\", \"*html\") returns false      matches(\"cat\", \"c*t\") returns true */ public class Solution {          public static void main(String ... args) {         Solution sol = new Solution();         System.out.println(sol.isMatch(\"*\", \"hello.txt\"));         System.out.println(sol.isMatch(\"he*\", \"hello.txt\"));         System.out.println(sol.isMatch(\"*txt\", \"hello.txt\"));         System.out.println(sol.isMatch(\"he*xt\", \"hello.txt\"));         System.out.println(sol.isMatch(\"xx*\", \"hello.txt\"));      }      private boolean isMatch(String singleStarPattern, String filename) {          int starIndex = singleStarPattern.indexOf(\"*\");         if(starIndex == -1) { throw new IllegalArgumentException(\"Invalid pattern\"); }         else if (singleStarPattern.length()==1) {return true;} // * matches everything         String prefix = singleStarPattern.substring(0, starIndex);         String suffix = singleStarPattern.substring(starIndex+1);                  boolean prefixMatches=false, suffixMatches=false;         if(prefix.length()==0 || filename.startsWith(prefix)) { prefixMatches=true; }          if(suffix.length()==0 || filename.endsWith(suffix)) { suffixMatches=true; }                   return prefixMatches && suffixMatches;     }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* \n    Check if a given file name match a single-star pattern? (can't use regex I)  \n    index.html matches *.html  \n    foo.txt does not match *.html  \n     \n    matches(\"index.html\", \"*html\") returns true  \n    matches(\"foo.txt\", \"*html\") returns false  \n    matches(\"cat\", \"c*t\") returns true \n*/ \npublic class Solution { \n     \n    public static void main(String ... args) { \n        Solution sol = new Solution(); \n        System.out.println(sol.isMatch(\"*\", \"hello.txt\")); \n        System.out.println(sol.isMatch(\"he*\", \"hello.txt\")); \n        System.out.println(sol.isMatch(\"*txt\", \"hello.txt\")); \n        System.out.println(sol.isMatch(\"he*xt\", \"hello.txt\")); \n        System.out.println(sol.isMatch(\"xx*\", \"hello.txt\")); \n \n    } \n \n    private boolean isMatch(String singleStarPattern, String filename) { \n \n        int starIndex = singleStarPattern.indexOf(\"*\"); \n        if(starIndex == -1) { throw new IllegalArgumentException(\"Invalid pattern\"); } \n        else if (singleStarPattern.length()==1) {return true;} // * matches everything \n        String prefix = singleStarPattern.substring(0, starIndex); \n        String suffix = singleStarPattern.substring(starIndex+1); \n         \n        boolean prefixMatches=false, suffixMatches=false; \n        if(prefix.length()==0 || filename.startsWith(prefix)) { prefixMatches=true; }  \n        if(suffix.length()==0 || filename.endsWith(suffix)) { suffixMatches=true; }  \n         \n        return prefixMatches && suffixMatches; \n    } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If it is only one star, then only need to compare if the star & end equals the two parts in the pattern seperated by \"*\". 1. String[] strArr= pattern.split(\"\\\\*\"); get two patterns for 'start with' and 'end with'. 2. just see if the string is start with strArr[0], and end with strArr[1]. 3. some special cases, like empty..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In English (for the lazy), take the piece(s) of the query that are before, between, and after the wildcards, ie just the pieces that are not the wildcard, and strstr them in order against the body string. If / when you find a match for a piece, continue strstr'ing the next piece from the end of that match. This is O(N)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"java code:  I assumed that if there is no star in the second String, false should be returned."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5131269318901760","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"8","title":"Given a set of intervals (time in seconds) find the set of intervals that overlap. Follow-up: what if we were to find the interval with maximum overlap.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"I can propose NlogN solution. Place all begins and ends of intervals to array, mark beg as +1 end as -1. Sort them by time component. Then iterate over and accumulate ones. Interval with maximum sum will be interval of max overlap."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Given [0, 3] [3, 6], do they overlap? If yes, the output should be [3, 3]?  And given [0, 3] [4, 6] [2, 5], the output is {[0, 3], [2, 5]} {[4, 6], [2, 5]} ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Look on wikipedia for interval tree -- exists for solving this very same problem. Similar to that is Segment Tree. Both are tricky to build but very efficient in answering the question. Not sure what expectation of interviewers in this particular case."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For discussion of the first part, prepend stackoverflow to: questions/4446112/search-for-interval-overlap-in-list-of-intervals"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I just assume  - the method should return all possible sets of intervals which overlap - [0, 3] [3, 6] are regarded as overlapped  For the follow up question, I would need the definition of \"maximum\" Is it for the length of overlap or the count of intervals which overlap? In either case, I can get it easily from the returned sets."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"sort the data on the start time in ascending order. Use each given end point to find out the overlapped intervals."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6005493369667584","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"18","title":"Given a set top box: a, b, c, d, e, f, g, h, i, j, k, l, m, n, o p, q, r, s, t u, v, w, x, y z  Write code to give the character sequence given a word, For example, if the word is \"CON\", the function will print this: Right//now we're at B Right//now we're at C OK//to select C Down DOwn Right Right OK//to select O Left//now at N OK//to select N  note: Be careful when you're at Z. if you go to the right, you will get stuck. Afterwards, the interviewer adds a space to the right of 'Z' to test the code.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"import java.util.LinkedList; \nimport java.util.Queue; \n \npublic class PathFinder { \n \n    private Queue queue; \n public class Coordinator{ \n  int x; \n  int y; \n   \n  public Coordinator(int x , int y){ \n   this.x = x; \n   this.y = y;    \n  } \n } \n  \n public PathFinder(){ \n  queue = new LinkedList(); \n } \n  \n char [][] maze = {{'a','b','c','d','e'}, \n                      {'f','g','h','i','j'}, \n                      {'k','l','m','n','o'}, \n                      {'p','q','r','s','t'}, \n                      {'u','v','w','x','y'}, \n                      {'z',' ',' ',' ',' '}}; \n  \n  \n public void setupCoordinator(String word){ \n    for (int i = 0 ;i0){ \n        for (i = pre.x+1 ; i<=pre.x + xMove;++i){ \n         System.out.println(\"Down//now we are at \" + maze[i][j]); \n        } \n        i-=1; \n       }else if (xMove<0){ \n        for (i = pre.x-1; i>=pre.x - Math.abs(xMove);--i){ \n         System.out.println(\"up//now we are at \" + maze[i][j]); \n        } \n        i+=1; \n       } \n        \n        \n             if (yMove >0){               \n        for (j = pre.y+1 ; j<=pre.y + yMove;++j){          \n         System.out.println(\"Right//now we are at \" + maze[i][j]); \n        } \n        j-=1; \n       }else if (yMove<0){        \n        for (j = pre.y-1; j>=pre.y - Math.abs(yMove);--j){          \n         System.out.println(\"Left//now we are at \" + maze[i][j]); \n        } \n        j+=1; \n       } \n             System.out.println(\"OK//to select \" + maze[i][j]); \n              \n             pre = cur; \n  } \n   \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"assume its a graph as links to element on left, right, top and bottom. use bellman ford or any other algorithms to find shortest path between all nodes. Then its just about searching the start and end points in a 26x26 array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"C++ solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \"stdio.h\" #include \"conio.h\" #include \"string.h\" #define kColumnCount 5 char maze[6][kColumnCount] ={  {'a','b','c','d','e'},  {'f','g','h','i','j'},  {'k','l','m','n','o'},  {'p','q','r','s','t'},  {'u','v','w','x','y'},  {'z',' ',' ',' ',' '}}; int xp = 0, yp = 0; void printStepsForMessage(char *mess) {    for(int i=0;i   {   int asciVal = mess[i]-'a';   if(asciVal<0||asciVal>25)    continue;   int y = asciVal/kColumnCount;   int x = asciVal%kColumnCount;   if(xp  {    for(;xp    printf(\"Move Right\\n\");   }   else if(xp>x)   {    for(;xp>x;xp--)     printf(\"Move Left\\n\");   }    if(yp  {    for(;yp    printf(\"Move Down\\n\");   }   else if(yp>y)   {    for(;yp>y;yp--)     printf(\"Move Up\\n\");   }    printf (\"OK/to select %c\\n\", mess[i]);    } }  int _tmain(int argc, _TCHAR* argv[]) {  printStepsForMessage(\"   \");  printStepsForMessage(\"mapzansz     \");  getch();  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Not sure why so much very hard to read code is dumped here...   Let's consider 'con'. The distance between 'c' and 'o' is 'o'-'c'=12. This means currently we are 12/5=2 rows up and 12%5=2 cols left. So go down 2 and right 2. Similarly 'n'-'o'=1, so we are 0 rows down/up and 1 col to the left. Thus just go 1 to the right. We must be careful to stay in bounds, i.e. if the word is 'conq' then diff is 3 but we are at distance of 2 from the border (we always know where we are) then we have to wrap, i.e. add a row and go left instead of right. I guess the devil is in details :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void findCharSequence(String word) { \n  int currX = 0, currY = 0; \n   \n  for (int i = 0; i < word.length(); i++) { \n   int charValue = word.charAt(i) - 'a'; \n   int destX = charValue % 5; // no need to -1 since charValue already starts from 0 \n   int destY = charValue / 5; \n    \n   for (int j = 0; j <= Math.abs(currY-destY); j++) { \n    if (currY-destY < 0)  // if currY is row 1, and destY is row 3 \n     print \"Down\" \n    else \n     print \"Up\" \n   } \n   for (int j = 0; j <= Math.abs(currX-destX); j++) { \n    if (currX-destX < 0)  // if currX is col 1, and destX is col 3 \n     print \"Right\" \n    else \n     print \"Left\" \n   } \n   print \"OK\" \n   currX = destX; \n   currY = destY; \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void findCharSequence(char[][] m, String word) { \n   int currX = 0, currY = 0; \n    \n   for (int i = 0; i < word.length(); i++) { \n    int charValue = word.charAt(i) - 'a'; \n    int destX = charValue % 5; // no need to -1 since charValue already starts from 0 \n    int destY = charValue / 5; \n    // inclusive, a -> c, starting from 1, so that we can use j to print \n    for (int j = 1; j <= Math.abs(currY-destY); j++) {   \n     if (currY-destY < 0)  // if currY is row 1, and destY is row 3 \n      System.out.println(\"Down //we are at \" + m[currY+j][currX]); \n     else \n      System.out.println(\"Up //we are at \"+ m[currY-j][currX]); \n    } \n    for (int j = 1; j <= Math.abs(currX-destX); j++) { \n     if (currX-destX < 0)  // if currX is col 1, and destX is col 3 \n      System.out.println(\"Right //we are at \"+ m[destY][currX+j]); \n     else \n      System.out.println(\"Left //we are at \" + m[destY][currX-j]); \n    } \n    System.out.println(\"OK //to select \" + m[destY][destX]); \n    currX = destX; \n    currY = destY; \n   } \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You need take care of z case even if you process y before x. Take into consideration \"acz\", the correct order should be: OK RIGHT RIGHT OK LEFT LEFT DOWN DOWN DOWN DOWN DOWN OK"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4681357536002048","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"7","title":"How do you design a Maze and what kind of data structures you use for Maze. In addition, write a method to print the shorted path from start to end point.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I can see 2 options:  - a graph with each cell representing a node. This gives very easy way to setup walls (no connectivity between nodes), traps (some property of edges), etc. as well as base for solving the maze. As as side effect it doesn't restrict number of connections between cells, i.e. it could be hexagon based maze.  - a matrix with 4 bits representing ability to move in each direction. Same graph algorithms applied if the matrix is treated as connectivity matrix. The downside is that non-flat mazes (2D) could be harder to comprehend and cells must be uniform in shape, i.e. more bits that 4 maybe confusing and connection between cells of different shape could be hard to describe."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* A recursive utility function to solve Maze problem */ \nbool solveMazeUtil(int maze[N][N], int x, int y, int sol[N][N]) \n{ \n    // if (x,y is goal) return true \n    if(x == N-1 && y == N-1) \n    { \n        sol[x][y] = 1; \n        return true; \n    } \n  \n    // Check if maze[x][y] is valid \n    if(isSafe(maze, x, y) == true) \n    { \n        // mark x,y as part of solution path \n        sol[x][y] = 1; \n  \n        /* Move forward in x direction */ \n        if (solveMazeUtil(maze, x+1, y, sol) == true) \n            return true; \n  \n        /* If x moving in x direction doesn't give solution then \n           Move down in y direction  */ \n        if (solveMazeUtil(maze, x, y+1, sol) == true) \n            return true; \n  \n        /* If none of the above movements work then BACKTRACK:  \n            unmark x,y as part of solution path */ \n        sol[x][y] = 0; \n        return false; \n    }    \n  \n    return false; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use graph where vertices are in a matrix configuration.  Gen maze: pick a random out side vertex for the starting point, do a DFS to generate a path where the edge is picked at random, if the vertex is already discovered, pick another edge, if all edges have been discovered, DFS continues with another vertex, this way all vertices will be visited.  Solve: do a DFS until you get to the end, if dead end is reached, that part of the path is not part of the optimal path, DFS = shortest path"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Maze falls under a graph G(V, E) problem which can be solved by Adjacency Matrix or Adjacency List. Adjacency Lists are preferred as most graphs are sparse by nature . As for traversing the graph, the important thing to note is that a DFS algorithm is typically solved using a Stack. The stack basically remembers all the visited nodes/vertex so that each node is visited only once."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"All we need to do is to structure the maize as an adjacency list and do a simple BFS starting from the source. BFS will always return the shortest path from source to destination, in case of \"unweighted\" graphs."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4647544969756672","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"6","title":"Design Short URL. (I am not sure what it even means)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Store full URLs in a database table. To get the shortened form, just get, say, the base 62 version of the ID of the URL's row in the table (62 = ten digits, 26 lowercase characters, 26 uppercase characters). The service itself would issue HTTP 302 redirects to avoid putting its own shortened link into the browser's history."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The formulation of the question is probably wrong; \"Design a URL shortener\" seems more like it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This thread will give you some idea about shortURL.. stackoverflow.com/questions/1562367/how-do-short-urls-services-work"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6189985468252160","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"5","title":"Given two Binary trees. these trees \"may\" have right and left branches swapped. Now compare it.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"public boolean areEqual(Node node1, Node node2) { \n    if (node1 == null && node2 == null) { \n  return true; \n }  \n if (node1 == null || node2 == null || node1.value != node2.value) { \n  return false; \n } \n   \n if ((areEqual(node1.left, node2.left) && areEqual(node1.right, node2.right)) ||  (areEqual(node1.left, node2.right) && areEqual(node1.right, node2.left))) { \n  return true; \n }   \n return false; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* Given two trees, return true if they are \n structurally identical */ \nint identicalTrees(struct node* a, struct node* b) \n{ \n    /*1. both empty */ \n    if (a==NULL && b==NULL) \n        return 1; \n  \n    /* 2. both non-empty -> compare them */ \n    if (a!=NULL && b!=NULL) \n    { \n        return \n        ( \n            a->data == b->data && \n            identicalTrees(a->left, b->left) && \n            identicalTrees(a->right, b->right) \n        ); \n    } \n      \n    /* 3. one empty, one not -> false */ \n    return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool compare(TreeNode* a, TreeNode* b) \n{  \n    if (a == NULL && b == NULL) return true; \n    else if (a == NULL ^ b == NULL) return false; \n    bool noswap = compare(a->left, b->left) && compare(a->right, b->right); \n    bool swap = compare(a->left, b->right) && compare(a->right, b->left); \n    return a->val == b->val && (swap | noswap);  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This problem, also referred as Tree Isomorphism can be implemented recursively. The approach is to implement the code that detects if two trees are identical and add component that considers thatc branches have been swapped. Below is C/C++ code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Your solutions work in O(2 ^ n) time, add memorization to make complexity O(n ^ 2)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5482486612099072","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"4","title":"Given a undirected graph, clone it. Now if the undirected graph has the neighbors with the nodes as same data - how do you make sure you create the exact same branches and also how do you make sure you don't run into loops for the exact node. He gave a empty directed graph and asked me write code after that.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"stackoverflow . com/questions/12886036/deep-copying-a-graph-structure"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Not sure about the question. But i will answer some of the specific points in the question. How to differentiate between different nodes with same data and encountering the same node? A: use the address of the node to differentiate  also how do you make sure you don't run into loops for the exact node? A: as its done in DFS."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Actually this problem can be formed as serialization problem. We need some function to check object identity. We can use Java identityHashCode and put all node of graph to map. Where key if this identityHash."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4900821338685440","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"9","title":"There are 10,000 balls and may be 500 different colors of ball  Example: There are:     4 - red ball 5900 - Blue ball 3700 - Green ball  396 - mintcream ball Or there may be 10,000 red balls.  Or all balls are has same range, i.e. 500 red, 500 blue, etc.  We don??t know the range of any ball and number of color balls, but the minimum is 1 color and maximum is 500 colors, and we have auxiliary array of size 500. how to arrange all same color ball together in minimum passes over balls? is it possible to do in less than two passes ??","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"You can do it in one pass, just use the auxiliary array as an array of linked lists, and append each ball to its respective linked list as you iterate through the 10,000 balls.  Pseudocode (assuming the aux array is already created as an array of linked lists):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Gus, you are assuming that 'ball.color' is an integer.  What if it is a string?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"You probably don't need to store the balls again. Just maintain a count of each type of ball. Take a convention where each array index represents a color, like 0=red, 1=blue, etc. If you can use a map then key would be ball color and value would be a count.  You pass over it once. Do a get, if present increment value, if not present insert and set value to 1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Maybe I am missing something...but here goes my idea. 1. Allocate one location in the auxiliary array for each color. 2. Pick a ball from the set of 10000 and place it in the auxiliary array.  3. If you get another ball of the same color, replace the one in the auxiliary array with the new one and push the old one back into the 10000 set, but remember not to pick this up. 4. As more balls are moved from the 10000 set to the 500 set, you can insert more from the 500 set into the 10000 set PROCESSED area using insertion sort say.  Is this acceptable?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's my solution (one sweep):  1) Initialize a dictionary of lists that holds up to 500 objects 2) Traverse the list of balls while adding them to the dictionary"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I can think of an algorithm to do it in 2 passes but not less than that.  1) Take 1 pass through the entire set of balls and use the array to capture frequency of each color (histogram). Thus we can decide what range positions to allot to each color i.e. positions are from 1 to 10000.  2) In the array capture the first available position for each color. 3) Pick the ball at position 1 and place it at the correct position according to the color. Simultaneously update the array to capture the next position available for that color. 4) Repeat the above step for the ball that was displaced because of it."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5398298810646528","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"There are 10,000 balls and may be 500 different colors of ball  Example:-there are              4 - red ball          5900 - Blue ball          3700 - Green ball           396 - mintcream ball Or there may be 10,000 - red ball  Or all balls are has same range means 500-red,500-blue and so on..  We don??t know the range of any ball and no of color ball but minimum is 1 color and max is 500 color of ball and we have auxiliary array of size 500. What will be the time complexity to arrange all same color ball together??","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n)? Two passes?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming the balls are also in an array, I would consider sorting them by color, where colors order is determined through their bit representation.  This should cost O(n*log(n)) due to the sorting.  But maybe I missed something..."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6291347770179584","download_status":"DOWNLOAD_DONE","votes":"-4","answersCount":"14","title":"There's a matrix. Each element in the matirx is a bit (0 or 1). Write a method to reverse this matrix. The matrix is stored in a one dimensional char array. The length of each row is given. How do you improve your solution when handling large amount of data?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Can you please put some more light on what do you mean by reversing a matrix here ? Is it row-wise reversal or column-wise ? I apologize if this is intuitive and I am unable to figure it out."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I'm assuming by reverse you mean the following:  ex array (i'm using numbers here for the sake of the example):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am sure, this guy would have been rejected by Google. How can it hire someone who is unable to explain what 'reversing' a matrix means?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would do a NxN matric multiplication, by taking the given matrix and multiplying it with a diagonal matrix which has NxN elements with diagonal 1. the char array placement has to taken care of here to get the multiplication right. i.e if you take char m[16] the it is a 4x4 matric if char m[4] it is a 2x2 matrix, so our diagonal matrix md[N] should have N as 16 or 4 depending on the other matrix, Then multiplay and add the appropriate column and row values. the end result will be a reversal of the matrix."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think if A is a 2D array represented as [2,3,4,5,6,7] when num_rows=3 then reverse(A) is [3,2,5,4,7,6]."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//initialize the char array into a 2D matrix of int type \npublic int[][] matrix= {{1,0,1,1},{0,1,1,1},{1,1,1,1}}; \n \npublic char[] transpose() \n { \n  StringBuilder sb = new StringBuilder(); \n   \n  for (int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Guys, he said specifically it's a matrix storing BITS. So reversing should mean reversing the bits."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I feel like a lot of info is missing in this question. Why would the question clarify that the matrix stores bits, for instance? That seems like a detail which would have a purpose in a short interview question."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5686646808772608","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"18","title":"How do you add two numbers that are larger/longer than Integer datatype? I said I would use BigInteger , then he asked how will you add if the number is larger than BigInteger?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public static String addUsingString(String firstNumber, String secondNumber) \n { \n  if(firstNumber == null && secondNumber != null) \n   return secondNumber; \n  if(secondNumber == null && firstNumber != null) \n   return firstNumber; \n   \n  int carry = 0; \n  String result = \"\"; \n  for(int i = firstNumber.length() - 1, j = secondNumber.length() - 1 ; i >= 0 || j >= 0 ; i--, j--) \n  { \n   if(i < 0) \n   { \n    while(j >= 0) \n    { \n     int valTwo = (int)secondNumber.charAt(j)- (int)'0'; \n     int sum = carry + valTwo; \n     carry = 0;  // reseting carry for next iteration \n     if(sum > 9) \n     { \n      carry = sum / 10; \n      sum = sum % 10; \n     }  \n     result = sum + result; \n     j--; \n    } \n    if(carry != 0) \n     result = carry + result; \n    return result; \n   } \n   else if(j < 0) \n   { \n    while(i >= 0) \n    { \n     int valOne = (int)firstNumber.charAt(i)- (int)'0'; \n     int sum = carry + valOne; \n     carry = 0;  // reseting carry for next iteration \n     if(sum > 9) \n     { \n      carry = sum / 10; \n      sum = sum % 10; \n     } \n     result = sum + result; \n     i--; \n    }  \n    if(carry != 0) \n     result = carry + result; \n    return result; \n   } \n   else \n   { \n    int valOne = (int)firstNumber.charAt(i) - (int)'0'; \n    int valTwo = (int)secondNumber.charAt(j) - (int)'0'; \n    int sum = carry + valOne + valTwo; \n    carry = 0;   // reseting carry for next iteration \n    if(sum > 9) \n    { \n     carry = sum / 10; \n     sum = sum % 10; \n    } \n    result = sum + result; \n   } \n  } \n  if(carry != 0) \n   result = carry + result; \n  return result; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"private static String addNumberUsingString(String strNum1, String strNum2) { \n  if (strNum1.length() == 0 && strNum2.length() == 0) \n   return \"0\"; \n  if (strNum1.length() == 0) { \n   return strNum2; \n  } \n  if (strNum2.length() == 0) \n   return strNum1; \n  int loopCount = strNum1.length() > strNum2.length() ? strNum1.length() : strNum2.length(); \n  int carry = 0; \n  StringBuffer resultBuffer = new StringBuffer(); \n  for (int i = loopCount - 1; i > -1; i--) { \n   int n1 = 0, n2 = 0; \n   if (strNum1.length() >= i + 1) \n    n1 = Integer.parseInt(strNum1.substring(i, i + 1)); \n   if (strNum2.length() >= i + 1) \n    n2 = Integer.parseInt(strNum2.substring(i, i + 1)); \n   int sonuc = carry+n1 + n2; \n   String strSonuc = Integer.toString(sonuc); \n   resultBuffer.append(strSonuc.substring(strSonuc.length() - 1)); \n   if (strSonuc.length() > 1) \n    carry = Integer.parseInt(strSonuc.substring(strSonuc.length() - 2, strSonuc.length() - 1)); \n   else \n    carry = 0; \n  } \n  StringBuffer newResult = new StringBuffer(carry > 0 ? Integer.toString(carry) : \"\"); \n  for (int i = resultBuffer.length()-1; i > -1; i--) { \n   newResult.append(resultBuffer.substring(i, i+1)); \n  } \n  return newResult.toString(); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can represent numbers as a List where each digit is the node in the list and then perform add operation like on the paper."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How we are storing the numbers ? How is the input pattern in here ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class AddBigNumbers { \n  \n public static String addBigNumber(String num1, String num2){ \n  StringBuffer total = new StringBuffer(); \n   \n  int maxlength = num1.length() >= num2.length() ? num1.length() : num2.length(); \n   \n  for (int i=0; i=0; i--){ \n   int val = (n1[i]-'0') + (n2[i]-'0') + carry; \n    \n   if (val > 9) { \n    carry = 1; \n    total.append(val % 10); \n   } \n   else { \n    carry = 0; \n    total.append(val); \n   } \n  } \n   \n  return total.reverse().toString(); \n } \n  \n public static void main(String str[]){ \n  System.out.println(addBigNumber(\"2147483647\",\"2147483647\")); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can use Stack here instead of string processing i guess"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A general naive solution but a working one .. Only problem being if String starts with 0 e.g : String s1=\"000099999\", then it does not work .. any suggestions ????  import java.util.ArrayList; import java.util.List;  public class AddNumbers {     public static void main(String[] args) {    String s1 = \"9\";   String s2 = \"7\";   StringBuilder sb = new StringBuilder(\"\");    List x = new ArrayList();   int s1_length = s1.length();   int s2_length = s2.length();   int carry = 0;   int to_be_appended;   int to_be_appended_temp = 0;   int diff_in_length = s1.length() - s2.length();   if (s1.length() >= s2.length()) {    int difference_in_length = s1.length();    for (int i = s2.length() - 1; i >= 0; i--) {     char x1 = s1.charAt(i);     char x2 = s2.charAt(i);     String m = x1 + \"\";     String m1 = x2 + \"\";     int value1 = Integer.parseInt(m);     int value2 = Integer.parseInt(m1);     int result = value1 + value2 + carry;     if (result > 10) {      carry = 1;      to_be_appended = result - 10;     } else {      carry = 0;      to_be_appended = result;     }      sb.append(to_be_appended);      if (i == 0 && result > 10 && s1.length() == s2.length()) {      carry = 1;      sb.append(carry);     }     }     for (int k = diff_in_length - 1; k >= 0; k--) {      char x3 = s1.charAt(k);     String new_string = \"\" + x3;     int val = Integer.parseInt(new_string);     val = val + carry;     if (val >= 10) {       carry = 1;      to_be_appended_temp = val - 10;      } else {      carry = 0;      to_be_appended_temp = val;     }      sb.append(to_be_appended_temp);     if (val >= 10 && k == 0) {      carry = 1;      sb.append(carry);     }     }     String s = sb.toString();    System.out.print(\"resulting number is=======\");    for (int m = s.length() - 1; m >= 0; m--) {     System.out.print(s.charAt(m));    }    }   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Scanner; \nimport java.util.Stack; \n \n/** \n * \n * @author u?ur \n */ \npublic class AddTwoBigInteger { \n     \n    public static void main (String args[]) { \n         \n        Scanner scanner = new Scanner(System.in); \n         \n        String inp1 = scanner.next(); \n        String inp2 = scanner.next(); \n         \n        Stack stack1 = new Stack<>(); \n        Stack stack2 = new Stack<>(); \n         \n        for (int i = 0 ; i < inp1.length() ; i++ ) { \n            stack1.add(inp1.charAt(i)); \n        } \n         \n        for (int i = 0 ; i < inp2.length() ; i++ ) { \n            stack2.add(inp2.charAt(i)); \n        } \n         \n        Stack result = new Stack<>(); \n        int carry = 0; \n         \n        while ( !stack1.isEmpty() || !stack2.isEmpty() ) { \n             \n            int i1; \n            int i2; \n             \n            if (stack1.isEmpty() ) { \n                i1 = 0; \n            } \n            else { \n                i1 = Character.getNumericValue( stack1.pop() ); \n            } \n             \n            if (stack2.isEmpty() ) { \n                i2 = 0; \n            } \n            else { \n                i2 = Character.getNumericValue( stack2.pop() ); \n            } \n             \n            result.add( (i1 + i2 + carry ) % 10 ); \n            carry = (i1 + i2 + carry ) / 10; \n             \n        } \n         \n        if ( carry != 0 ) { \n            result.add(carry); \n        } \n         \n        while( !result.isEmpty() ) { \n            System.out.print(result.pop()); \n        } \n         \n    } \n     \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Scanner; \nimport java.util.Stack; \n \n/** \n * \n * @author u?ur \n */ \npublic class AddTwoBigInteger { \n     \n    public static void main (String args[]) { \n         \n        Scanner scanner = new Scanner(System.in); \n         \n        String inp1 = scanner.next(); \n        String inp2 = scanner.next(); \n         \n        Stack stack1 = new Stack<>(); \n        Stack stack2 = new Stack<>(); \n         \n        for (int i = 0 ; i < inp1.length() ; i++ ) { \n            stack1.add(inp1.charAt(i)); \n        } \n         \n        for (int i = 0 ; i < inp2.length() ; i++ ) { \n            stack2.add(inp2.charAt(i)); \n        } \n         \n        Stack result = new Stack<>(); \n        int carry = 0; \n         \n        while ( !stack1.isEmpty() || !stack2.isEmpty() ) { \n             \n            int i1; \n            int i2; \n             \n            if (stack1.isEmpty() ) { \n                i1 = 0; \n            } \n            else { \n                i1 = Character.getNumericValue( stack1.pop() ); \n            } \n             \n            if (stack2.isEmpty() ) { \n                i2 = 0; \n            } \n            else { \n                i2 = Character.getNumericValue( stack2.pop() ); \n            } \n             \n            result.add( (i1 + i2 + carry ) % 10 ); \n            carry = (i1 + i2 + carry ) / 10; \n             \n        } \n         \n        if ( carry != 0 ) { \n            result.add(carry); \n        } \n         \n        while( !result.isEmpty() ) { \n            System.out.print(result.pop()); \n        } \n         \n    } \n     \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Store both the numbers in char arrays and perform addition of individual chars from the last to the first index in both the arrays with the appropriate carry.  It looks lame for google standards but is all I can think of :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"use recursion. first represend two numbers in string with same length, which means to add \"0\" before head for the shorter number. Then add digits by recursive:  f(n) = f(n-1).subString(1) + sum of n's digits +1  or   f(n) = f(n-1).subString(0,1) + sum of n's digits. This does not work for negative numbers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"The code snippets posted so far are just naive re-implementations of the same idea behind BigInteger. This question is about what happens when even BigInteger isn't big enough, so none of the responses here seem to come close to answering the question."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5201559730257920","download_status":"DOWNLOAD_DONE","votes":"13","answersCount":"192","title":"Give you an array which has n integers,it has both  positive and negative integers.Now you need sort this array in a special way.After that,the negative integers should in the front,and the positive integers should in the back.Also the relative position should not be changed. eg. -1 1 3 -2 2 ans: -1 -2 1 3 2.  o(n)time complexity and o(1) space complexity is perfect.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"This can be done in O(nlogn) using divide and conquer scheme. Before starting the algorithm, please see the following observation:  Observation: given an array A, say [1, -2, ..., 4], with n elements, we can get the inverse of A, denoted as A?? (4, ??, -2, 1),  in \\theta(n) time with O(1) space complexity.   The basic idea of the algorithm is as follows: 1. We recursively ??sort?? two smaller arrays of size n/2 (here ??sort?? is defined in the question) 2. Then we spend \\theta(n) time merging the two sorted smaller arrays with O(1) space complexity.  How to merge?  Suppose the two sorted smaller array is A and B. A1 denotes the negative part of A, and A2 denotes positive part of A. Similarly, B1 denotes the negative part of B, and B2 denotes positive part of B.   2.1. Compute the inverse of A2 (i.e., A2??) in \\theta(|A2|) time; compute the inverse of B1 (i.e., B1??) in \\theta(|B1|) time. [See observation; the total time is \\theta(n) and space is O(1)] Thus the array AB (i.e., A1A2B1B2) becomes A1A2??B1??B2.  2.2.  Compute the inverse of A2??B1?? (i.e., B1A2) in \\theta(|A2|) time. [See observation; the total time is \\theta(n) and space is O(1)]  Thus the array A1A2??B1??B2 becomes A1B1A2B2. We are done.  Time complexity analysis: T(n) = 2T(n/2) + \\theta(n) = O(nlogn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"O(nlogn) average case time, O(1) space solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Method 1: O(n log(n)) for arrays  Too complicated to code but leads to O(n log n) for arrays Start with an array A = [a1 b1 a2 b2 a3 b3 a4 b4 .... ak bk]     where ai and bi are subarrays of positive and negative numbers. assume ni = len(ai) and mi = len(bi) Observation: [a1 b1] --> [b1 a1] in O(max(ni, mi)) which is obtained by repeatedly swaping the first, second, ... elements.     For ni = mi it is obvious. For ni > mi, do it for the first mi, then ignore the first mi since they are in place, do it [ni - mi, mi] positive ones and put them in order. Repeat until you finish after ni swaps.  So recursively do this: Take [a1 b1 a2 b2] -> [b1 a1 a2 b2] -> [b1 b2 a1 a2] this is done in max(n1, m1) + max(n1 + n2, m2) < 2n1 + n2 + m1 + m2  For k pairs of [ai bi], we find k / 2 new pairs pairs. Reapeat the procedure. Note that in the second run, your new value of n1 is (n1 + n2) from previous step. The same for m1. For k pairs we need the time complexity T(k) = k / 2 * (2n1 + n2 + m1 + m2) + T(k / 2). Put averages here: (E[ni] = E[mi] = n / k. ET(k) = k / 2 * (5 n / k) + ET(k / 2) = 2.5 n + ET(k / 2). For k / 2, the sizes of ni and mi are doubled. So we have ET[k] = 2.5 n + 2.5 n + .... + 2.5 log2(k) times. Then ET[k] = O(nlog(k)). Finally, average over \"k\". Note that k is O(n) for random arrays. Therefore, the overall complexity = O(n log(n)) Repeat it for all the k / 2 pairs."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"import java.util.Arrays;  public class NegativeAndPositive {   private static final int[] array = new int[] { 100, -1, 5, 4, -7, 11, 12, 0, -2, -1, -10, 11, -2 };   public static void main(String[] args) {    for (int i = 0, j = array.length - 1; i < j;) {     if (array[i] < 0) {     i++;     continue;    }     if (array[j] > 0) {     j--;     continue;    }     swap(i, j);    }    System.out.println(Arrays.toString(array));   }   private static void swap(int i, int j) {   int temp = array[i];   array[i] = array[j];   array[j] = temp;  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Do an in-place partition (i.e. from the quick sort algorithm) on the pivot value 0. However, the partition algorithm is not stable, but we can fix that without too much extra work and constant overhead.  Example:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"O(n) and O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"O(n) O(1)!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The n^2 solution would be:  Keep trace of a first met positive number = P. If you find a negative number = N, and P is set, then store P into T, insert value of N into positon P, shift the table right from P to N positon, insert T into P+1.  Can we really do it in O(n) without extra space?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class NegativePositiveSort \n{ \n    public static void main(String[] args) { \n        int[] array = {-1,1,3,-2,2}; \n        int positiveIndex=-1; \n        int negativeIndex=-1; \n        // Find 1st positive index \n        for(int i=0;i=0) { positiveIndex=i; break;} \n        } \n         \n        // Find 1st negative index after positive index \n        for(negativeIndex=positiveIndex+1;negativeIndex=0;negativeIndex++);         \n         \n        while(positiveIndex>-1 && negativeIndex=0;negativeIndex++);         \n        } \n         \n        for(int i=0;itgt) { \n            array[src-1] = array[src] ^ array[src-1]; \n            array[src]   = array[src] ^ array[src-1]; \n            array[src-1] = array[src] ^ array[src-1]; \n            src--; \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This should work. how to compute the time complexity ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Author : A.Nasimunni  #include main() { int n; printf(\"\\n\\tEnter the length of the array : \"); scanf(\"%d\",&n); int a[n],b[n]; int i=0; printf(\"\\n\\n\\tEnter the elements into array \\n\"); for(i=0;i{printf(\"\\t\\t Enter : \"); scanf(\"%d\",&a[i]); } int k=0; for(i=0;i{ if(a[i]<0) { b[k]=a[i];k=k+1; } else {k=k;} }   for(i=0;i{ if(a[i]>0){b[k]=a[i];k++;}else{k=k;} }  for(i=0;i{ printf(\" %d\",b[i]); } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Author : A.Nasimunni  #include main() { int n; printf(\"\\n\\tEnter the length of the array : \"); scanf(\"%d\",&n); int a[n],b[n]; int i=0; printf(\"\\n\\n\\tEnter the elements into array \\n\"); for(i=0;i{printf(\"\\t\\t Enter : \"); scanf(\"%d\",&a[i]); } int k=0; for(i=0;i{ if(a[i]<0) { b[k]=a[i];k=k+1; } else {k=k;} }   for(i=0;i{ if(a[i]>0){b[k]=a[i];k++;}else{k=k;} }  for(i=0;i{ printf(\" %d\",b[i]); } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList;   class Test  {     public static void main(String[] args){      int[] arr = {-1, 1, 3, -2, 2,5,-7,-6};   ArrayList list = new ArrayList();      for(int i=0;i       if(arr[i]<0){          list.add(arr[i]);    }   }      for(int i=0;i       if(arr[i]>0){          list.add(arr[i]);    }   }      System.out.println(list);  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"So you only have to swap the last item in a run of positives or negatives. So you only have to keep an index of the last index of the previous signage run. The following code is O(N) and has O(1) space.  I don't handle the 0 case, because it is unclear what to do with that case."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int[] sortInOrder(int[] data){      int pos=0;   int negPos=0;   for (pos=0;pos       if(data[pos]>=0){     while(negPos=0  ){      negPos++;     }          if(negPos==data.length)      break;     while(negPos>pos){      int temp=data[negPos];      data[negPos]=data[negPos-1];      data[negPos-1] = temp;      negPos--;     }    }     negPos++;     pos++;       }      return data;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int[] sortInOrder(int[] data){ \n   \n  int pos=0; \n  int negPos=0; \n  for (pos=0;pos=0){ \n    while(negPos=0  ){ \n     negPos++; \n    } \n     \n    if(negPos==data.length) \n     break; \n    while(negPos>pos){ \n     int temp=data[negPos]; \n     data[negPos]=data[negPos-1]; \n     data[negPos-1] = temp; \n     negPos--; \n    } \n   } \n    negPos++; \n    pos++; \n    \n  } \n   \n  return data; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int[] sortInOrder(int[] data){ \n   \n  int pos=0; \n  int negPos=0; \n  for (pos=0;pos=0){ \n    while(negPos=0  ){ \n     negPos++; \n    } \n     \n    if(negPos==data.length) \n     break; \n    while(negPos>pos){ \n     int temp=data[negPos]; \n     data[negPos]=data[negPos-1]; \n     data[negPos-1] = temp; \n     negPos--; \n    } \n   } \n    negPos++; \n    pos++; \n    \n  } \n   \n  return data; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If 0 exists, partition around it..Otherwise, insert a 0 and then partition around it. Please confirm if it's possible to add a 0 to the array in O(1) space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Code on C#, I think this is O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int main() {     int arr[7] = {-1,-1,-3,-3,-2,-2,-8};     int size = sizeof(arr)/sizeof(*arr);     cout<<    int n=0;     for(int i=0;i     if(arr[i]<0) {       int temp = arr[i];       int j=i;       while(j>n){        arr[j] = arr[j-1];        j--;}       arr[n++]= temp;}}     for(int i=0;i    cout<  return 0;}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class array2 { \n public static void printarray(String name,int [] src) \n { \n  System.out.println(name); \n  for(int i=0;i=0) \n   { \n    a[j]=src[i]; \n    j++; \n   } \n  } \n  System.out.println(); \n  printarray(\"Final\",a); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class array2 { \n public static void printarray(String name,int [] src) \n { \n  System.out.println(name); \n  for(int i=0;i=0) \n   { \n    a[j]=src[i]; \n    j++; \n   } \n  } \n  System.out.println(); \n  printarray(\"Final\",a); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The idea here is when we encounter a positive number in the slot we're examining, we find the next negative number, store it in a temp variable, then shuffle over all the positives. Finally, insert the saved negative number into the current slot.   i.e. if we had: [ -1, <1>, 2, 3, 4, -2, ..]  When we encounter the 1, we search forward til we find the index of the -2, and we store that value. We then copy between our current index and that index:  [ -1, <1>, 1, 2, 3, 4, ....]  Then finally insert the saved number into our current location.  [-1, <-2>, 1, 2, 3, 4, ...]  Then we move onto examining the next index.  This is O(n) in the worst case, because in [3,2,1,-3,-2,-1], we perform n/2 shuffles, where each shuffle swaps at most n/2 elements. n/2 * n/2 = O(n).  It's actually O(n^2), thanks for the correction lxduan."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we need two arrays ary1, ary2 ; both size of n, for positive values and negative values"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.arrange the first half as negative and second half as negative 2.then call quick sort for first half of the array check for abs(i) pos with abs(j) 3.then call quick sort for the second half of the array   the complexity is O(n) for arranging positive and negative numbers and O(nlogn)+O(nlogn) for sorting... still can we have better solution :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class google {   public static void main(String[] args) {   int[] a={-1,1,3,-2,2};   int neg=0;   int pos=0;      for(int i=0;i   if(a[i]<0)     neg++;    else     pos++;   }      int countneg=0;   int i=0;   int j=1;   int k=0;   int temp=0;   while(countneg   if(a[i]<0){     countneg++;     i++;    }    else{     j=i;     k=i;     while(a[k]>0){      k++;     }     temp=a[j];     a[j]=a[k];     for(int z=k;z>j;z--){      a[z]=a[z-1];     }     a[j+1]=temp;     countneg++;     i++;    }   }    for(i=0;i   System.out.println(a[i]);   }   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// anshumandvyas@gmail.com \n \n \npublic class google { \n \n public static void main(String[] args) { \n  int[] a={-1,1,3,-2,2}; \n  int neg=0; \n  int pos=0; \n   \n  for(int i=0;i0){ \n     k++; \n    } \n    temp=a[j]; \n    a[j]=a[k]; \n    for(int z=k;z>j;z--){ \n     a[z]=a[z-1]; \n    } \n    a[j+1]=temp; \n    countneg++; \n    i++; \n   } \n  } \n \n  for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include   void swapT(int* a,int* b, int *c){  int temp=*c;  *c=*b;  *b=*a;  *a=temp; }  #define N 5  int main(){     int i, pos, mid, neg = 0;     int a[] = {-1,1,3,-2,2};     for (i = 0; i < N; i++) printf (\" %d \", a[i]);  printf (\"\\n\");  int totNeg = 0;  for (i = 0; i < N; i++){      if (a[i] < 0) totNeg++;  }  mid = totNeg;  pos = totNeg;  while (totNeg > 0){      if (a[neg] < 0){          neg++;          totNeg--;      }      else {          while (a[pos] >= 0) pos++;          swapT(&a[neg], &a[mid], &a[pos]);          neg++;          pos++;          mid++;          totNeg--;      }  }   for (i = 0; i < N; i++) printf (\" %d \", a[i]);  printf (\"\\n\");   return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \nvoid swap(int *, int *); \nmain() \n{ \n int array[6] = { \n 1,2,3,4,-2,-3 \n }; \n int a = 0, b = 5; \n while (a <= b) { \n  while (array[a] < 0) \n   a++; \n  while (array[b] > 0) \n   b--; \n  if (b -a > 1) { \n   swap(&array[a], &array[b]); \n   a++; \n   b--; \n  } \n } \n int i = 0; \n for (; i < 6; i++) \n  printf(\"%d \", array[i]); \n printf(\"\\n\"); \n return 0;  \n} \n \nvoid swap(int *a, int *b) \n{ \n int temp = *a; \n *a = *b; \n *b = temp; \n};"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My apology, previous code is not work for some special test data, so i edit and add the second one."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void rearrange(vector  &nums) \n{ \n    vector temp; \n    int start_pos = 0; \n    for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void sortIntegers(int[] intarray)     {         for(int h=0;h            System.out.print(intarray[h]+ \" \");                  int lastnegative = 0;         for(int i=0; i< intarray.length;i++)         {             if(intarray[i]<0)             {                 swap(intarray,lastnegative,i);                 lastnegative = lastnegative+1;                         }         }         System.out.println();         for(int m=0;m            System.out.print(intarray[m]+ \" \");              }     void swap(int[] intarray, int lnegative, int j)     {         int temp = intarray[j];        for(int k = j-1;k>=lnegative;k--)        {            intarray[k+1] = intarray[k];                           }        intarray[lnegative] = temp;     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we can also use queue data structure like this in Java public class Sort {    public static void sortArray(int[] a)  {   int N = a.length;   Queue q1 = new Queue();   Queue q2 = new Queue();      for (int i = 0; i  {    if(a[i] < 0 ) q1.enqueue(a[i]);    else q2.enqueue(a[i]);   }   int i = 0;   while (!q1.isEmpty())    a[i++] = q1.dequeue();   while(!q2.isEmpty())    a[i++] = q2.dequeue();     }    public static void main(String[] args)  {   int[] a = {-1,1,3,-2,2};   sortArray(a);   for (int i =0; i   System.out.println(a[i]);  }    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"NOT possible in o(n)time complexity and o(1) space complexity"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If this wasn't an array it would be doable!  if you had a linked list you could easily do this in one pass!  Just link the negative list together then link the last item with the first positive."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"[    o(1) space, by time complexity is not o(n) :(   ]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nvoid swap(int*,int*); \nvoid insert(int*, int*); \nint main() \n{ \n int arr[5] = {-1,1,3,-2,-4}; \n int negcount = 0, i, p; \n  \n /*Counting negetive numbers*/ \n for(i=0;i<5;i++) \n  if(arr[i]<0) \n   negcount++; \n /*p points to the next location to insert positive number */ \n p = neg; \n  \n /*Main algo part*/   \n for(i=0;i0) \n  { \n   printf(\"swapping\\n\"); \n   swap(&arr[i], &arr[p]); \n   p++; \n   if(arr[i] <= 0) \n    insert(&arr[i], &arr[neg-1]); \n   i--;  \n  }   \n } \n  \n /*Print The Result*/ \n for(i=0;i<5;i++) \n  printf(\"%d\\t\", arr[i]); \n printf(\"\\n\"); \n  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is like merge sort with a twist. The best solution I can think of for an O(1) space complexity is O(nlogn) time complexity. The trick is to think in terms of merge sort and perform matrix rotation through reverse"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def swap(list,idx1,idx2) \n    t = list[idx1] \n        list[idx1] = list[idx2] \n        list[idx2] = t \n        list \nend \n  \ndef separate(list) \n        idx = list.length \n        idx -= 1 \n        while(idx > 0) do \n                iidx = idx \n                if list[idx] < 0 \n                        pidx = idx - 1 \n                        while(pidx >= 0) do \n                                if list[pidx] > 0 \n                                        list = swap(list,idx,pidx) \n                                        if idx < iidx \n                                                iidx += 1 \n                                        end \n                                        break \n                                else \n                                        idx = pidx \n                                end \n                                pidx -= 1 \n                        end \n                end \n                idx = iidx - 1 \n        end \n        list \nend \n  \nlist = [1,2,-3,4,6,-9,10] \nputs separate(list).join(',')"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class GoogleSort { \npublic static void main(String args[])  { \n int[] in = {-1,2,3,-2,4,-5}; //input array \n int temp;//space1 \n for (int i = 0; i < in.length; ) { \n  if(in[i]<0) i++; \n  else{ \n   temp=i; \n   while(temp < in.length && in[temp]>0 ) \n    temp++; \n   if(temp >= in.length) \n    break; \n   while(i < temp ){ \n    //XOR swap \n    in[temp] ^= in[temp -1]; \n    in[temp-1] ^= in[temp]; \n    in[temp] ^= in[temp -1]; \n    temp --; \n   } \n   i = temp;    \n  } \n } \n for (int i = 0; i < in.length; i++) { \n  System.out.println(in[i]); \n } \n   \n} \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I haven't figured out the O(N) solution given an array, but it'd be easy to do with a linked list. Then you could just keep track of pointers for the end of the positive and negative lists, and then connect them in the end, with O(1) space (all you'd need is three pointers, one for the current position, one for the start of the positive list and one for the start of the negative)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is the best I got keeping the space on O(1) and O(n) without zeros Wasn't sure by the description if the array has zeros in it so added code to handle but not without extra time"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"function for the solution is given below,it solves the problem in O(n) time:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* \n Question ID: 5201559730257920 \n  \n Give you an array which has n integers,it has both positive and negative integers. \n Now you need sort this array in a special way.After that,the negative integers should in the front,and the positive integers should in the back. \n Also the relative position should not be changed. \n  \n eg. -1 1 3 -2 2 ans: -1 -2 1 3 2. \n O(n)time complexity and O(1) space complexity is perfect. \n*/ \n \npublic class sol5201559730257920{ \n \n static int length; \n static int[] a; \n static int start; \n static int end; \n static int total_n; \n  \n public static void sort(){ \n  while(start < total_n){ \n   if(a[start] < 0)  \n    start ++; \n   else{ \n    a[end] = a[start] + (a[start] = a[end]) - a[end]; // swap; \n    end ++; \n   } \n  } \n } \n  \n public static void display(){ \n  for(int i = 0; i < length; i ++){ \n   System.out.print(a[i] + \" \"); \n  } \n } \n  \n public static void main(String[] args){ \n  length = args.length; \n  a = new int[length]; \n  for(int i = 0; i < length; i ++){ \n   a[i] = Integer.parseInt(args[i]); \n   if(a[i] < 0) // count total negative numbers \n    total_n ++; \n  } \n  end = total_n; // index where positive num starts \n  sort(); \n  display(); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void sort(int[] array){ \n   \n  int cout_pos = 0; int count_neg = 0; \n  int sum_pos = 0; int sum_neg = 0;  \n  int neg_co = 1; int pos_co = 1; \n   \n  for(int i=0; i!=array.length; ++i){ \n   if(array[i] < 0){ \n    neg_co *= 10; \n    count_neg++; \n    sum_neg += -1 * array[i] * neg_co; \n     \n   } \n   else{ \n    pos_co *= 10; \n    cout_pos++; \n    sum_pos += array[i] * pos_co; \n     \n   } \n  } \n   \n  //put them back in the array \n  for(int i = count_neg -1; i!=0; --i){ \n   array[i] = -1*(sum_neg / neg_co); \n   sum_neg -= array[i] * neg_co; \n   neg_co /= 10; \n    \n  } \n   \n  for(int i = array.length-1; i!=count_neg-1; --i){ \n   array[i] = sum_pos / pos_co; \n   sum_pos -= array[i] * pos_co; \n   pos_co /= 10; \n    \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void sort(int[] array){      int cout_pos = 0; int count_neg = 0;   int sum_pos = 0; int sum_neg = 0;    int neg_co = 1; int pos_co = 1;      for(int i=0; i!=array.length; ++i){    if(array[i] < 0){     neg_co *= 10;     count_neg++;     sum_neg += -1 * array[i] * neg_co;         }    else{     pos_co *= 10;     cout_pos++;     sum_pos += array[i] * pos_co;         }   }      //put them back in the array   for(int i = count_neg -1; i!=0; --i){    array[i] = -1*(sum_neg / neg_co);    sum_neg -= array[i] * neg_co;    neg_co /= 10;       }      for(int i = array.length-1; i!=count_neg-1; --i){    array[i] = sum_pos / pos_co;    sum_pos -= array[i] * pos_co;    pos_co /= 10;       }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void sort(int[] array){ \n   \n  int cout_pos = 0; int count_neg = 0; \n  int sum_pos = 0; int sum_neg = 0;  \n  int neg_co = 1; int pos_co = 1; \n   \n  for(int i=0; i!=array.length; ++i){ \n   if(array[i] < 0){ \n    neg_co *= 10; \n    count_neg++; \n    sum_neg += -1 * array[i] * neg_co; \n     \n   } \n   else{ \n    pos_co *= 10; \n    cout_pos++; \n    sum_pos += array[i] * pos_co; \n     \n   } \n  } \n   \n  //put them back in the array \n  for(int i = count_neg -1; i!=0; --i){ \n   array[i] = -1*(sum_neg / neg_co); \n   sum_neg -= array[i] * neg_co; \n   neg_co /= 10; \n    \n  } \n   \n  for(int i = array.length-1; i!=count_neg-1; --i){ \n   array[i] = sum_pos / pos_co; \n   sum_pos -= array[i] * pos_co; \n   pos_co /= 10; \n    \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args){ \n  int []A={1,-2,-3,4,5,6,7,8,-9,-10,11,12,13,-14,-15,-16,-17,-18, 19}; \n  int l=A.length; \n  int j=l-1; \n  int i=0; \n  int [] b=sortArr(A, i, j); \n  for(i=0; i=0 & j>-1){ \n   j--; \n  } \n  int k=j; \n  while(A[k]<0 && k>-1){ \n   k--; \n  } \n  for(int p=k; p"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Multiply all negative numbers by 10 and odd numbers by 10 and add 1 2. sort the array using stable sorting algorithm considering only the last digit of the number     -10 -20 11 31 21 3. divide all elements by 10  -1 -2 1 3 2  This is O(N) and O(1) OR  2.  O(NlogN) soln - sort using any standard algo considering only the last digit"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def rearrange(src, tgt): \n    src_pos = {} \n    for i, s in enumerate(src):   # O(n) \n        src_pos[s] = i \n \n    zero = src.index(0)     # O(n) \n \n    for i, t in enumerate(tgt):  # n times O(1) \n        if t == 0 or t == src[i]: \n            continue \n        swap(src, zero, i) \n        swap(src, src_pos[t], i) \n        zero = src_pos[t] \n    print src"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I know time complexity is O(n^2)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Two Threaded solution: One thread starts from n direction left to right. Another thread from 1 right to left. LR thread stops if it encounters -ve and waits for RL to encounter positive. If so swap. Iteration breaks if two threads cross path. o(n), o(1)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void specialSort(int[] arr){ \n  if (arr == null) throw new NullPointerException(); \n  if(arr.length == 1) return; \n   \n  int temp = arr[0]; \n  int pos, neg; \n  int n = arr.length; \n  pos = neg = 0; \n  while(neg < n){ \n   for(int k = neg;pos < n && neg < n;k++){ \n    if(arr[neg] >= 0){ \n     //check if the last element in the array is \n     // a positive number. If so we are done \n     if (neg < n-1){ \n      // move the positive numbers to the right \n      // if you haven't reached the end of \n      // the array \n      int exch = arr[neg]; \n      arr[neg] = temp; \n      temp = exch; \n     } \n      neg++; \n    } \n    if(arr[pos] < 0) pos++; \n    if(neg >= n) break; //no more negative numbers \n    if(arr[pos] >= 0 && arr[neg] < 0) break; \n   }  \n         if(neg < n){//if neg > n then the last element of \n          // the array is a positive number and we are done \n       if(neg > pos ){ \n        if(arr[neg] < 0){ \n         arr[pos] = arr[neg]; \n            arr[neg] = temp; \n            pos = neg; \n        } \n       } \n       else neg = pos; // make sure we continue at  \n       // the higher index \n       neg++; \n       temp = arr[pos]; \n         } \n  } \n   \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I believe I have achieved O(n) time and O(1) extra space complexity:-  Let us maintain such an invariant at all times:   The first n numbers of the array are negative. The next p numbers of the array are positive. So let the array look like this:  -ve -ve -ve ... -ve; +ve +ve +ve ... +ve; -ve ....       n times              p times        remaining   Now let us find n1 and p1 such that  -ve -ve -ve ... -ve; +ve +ve +ve ... +ve; -ve -ve -ve ... -ve; +ve +ve +ve .... +ve; -ve ....       n times             p  times             n1 times               p1 times        remaining  Now let us try to 'consume' the n1 and p1 elements in the n and p elements. We can do this by swapping the 2nd and 3rd blocks(p and n1 elements). If we can do this in O(p+n1) time, then increment n to be n+n1 and p to be p+p1 and keep doing this, we should be able to do this for the whole array in O(n) time.  So the challenge is this:  x1 x2 x3 ... xp; y1 y2 y3 ... yq has to be rearranged to form y1 y2 y3 ... yq; x1 x2 x3 ... xp in O(p+q) time.  If p==q, then it's easy. Just keep on swapping x1, y1; x2, y2 and so on. If p!=q, suppose p>q without loss of generality. Then swap the elements y1..yq and x1..xq to get  y1 y2 y3 ... yq xq+1 xq+2 ... xp x1 x2 x3 ... xq  and repeat the procedure for the subarray xq+1 xq+2 ... xp; x1 x2 x3 ... xq  This way, it is possible to swap an unequal number of elements in place in O(n) time and O(1) extra space.  Code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n \nint main() \n{ \n char arr[]= \n{0,-1,1,-5,3,-2,6}; \n int i,j=0; \n int k=0; \n \n int size=sizeof(arr)/sizeof(arr[0]); \n \n printf(\"before\\n\"); \n for(i=0;i=0&&!k) \n  { \n   j=i; \n   k=1; \n  } \n  if((arr[i]>=0)&&(arr[i+1]<0)) \n  { \n   int t=arr[i]; \n   arr[i]=arr[i+1]; \n   arr[i+1]=t; \n   if(i==j) \n    j=i+1; \n   cnt=0; \n  } \n  if(i==size-2) \n  { \n   i=0; \n   k=0; \n  } \n  else \n   i++; \n } \n  \n printf(\"after\\n\"); \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void reArrageArray(int []data) {   int loopCount = 0;   int nPos = -1;   for (int i = 0; i < data.length; i++) {    int nValue = data[i];    if (nValue < 0) { //2     if (nPos != i-1) {      for (int j = i ; j > 0; j--) {       if (data[j-1] >= 0) {        data[j] = data[j-1];         data[j-1] = nValue;       } else {        nPos = j;       }       loopCount++;      }     } else {      nPos = i;      loopCount++;     }         } else {     loopCount++;    }   }   System.out.println(\"Total loop count : \" + loopCount);   for (int i = 0; i < data.length; i++) {    System.out.println(data[i]);   }   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about do the \"dividing\" part of quicksort with the value 0 as the pivot. All values lesser than 0 will be on left and values greater than 0 will be on right.   Takes O(n) time.  Not sure about whether the relative positions are maintained."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Test{ \n \n   public static void main(String[] args){ \n      int[] a = {-1, 1, 3, -2, 2, -6, -7, 8,9,12}; \n    \n      int i = 0, j = a.length - 1, tmp; \n     \n      while (i < j){ \n         if (a[i] < 0){ \n            i++; \n         } \n         if (a[j] > 0){ \n            j--; \n         } \n         if(i < j){ \n            tmp = a[i]; \n            a[i] = a[j]; \n            a[j] = tmp; \n            i++; \n            j--;         \n         } \n      } \n       \n      for(int k = 0; k < a.length; k++){ \n      System.out.print(a[k] + \" | \"); \n      } \n \n   } \n \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It seems not that difficult, someone did mention 'mergesort' but no one mentioned how to make it O(N): So, how about using a special version of mergesort recursively, where \"merge\" involves inserting +ve and -ve parts of the 'right' sub-list into the 'left' sub-list, this \"merge\" will take O(1), leading to O(N) for the whole mergesort?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is not possible in O(1) space, O(n) time is fine. I guess interviewer wanted to see if interviewee is confident enough to say this."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for O(1) space, can we not allocate max integer space and then fill it sequentially with occurred positive integers in given array, and then fill them back in original array from end of the array, here we will ensure that all -ve integers are pulled ahead. (filling up in original array should be easy). Help expand this logic if makes sense."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A() algorithm group(A) { n<-- length(A) k=n+1 for i<-- 0 to n do {    if(A[i]>0)    {           A[k]=A[i]   A.erase(A.begin()+i)      k=k+1    } } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include using namespace std;  void swapp(int* a,int* b) {     int t= *a;     *a=*b;     *b=t; }  int main() {     int n;     cin>>n;     int* a=new int[n];     for(int i=0;i    cin>>a[i];      int countneg=0,countpos=0;     for(int i=0;i    {         if(a[i]<0)countneg++;         else countpos++;     }     cout<<<\" \"<<    int j=0,tempcount=countneg;     for(int i=0;i    {         if(a[i]>0 && i        {             swapp(&a[i],&a[tempcount]);             tempcount++;         }         else if(a[i]<=0)         {             swapp(&a[i],&a[j]);             j++;if(i>0) i--;         }         else continue;      }     for(int i=0;i    cout<delete []a; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do an in-place partition (i.e. from the quick sort algorithm) on the pivot value 0. However, the partition algorithm is not stable, but we can fix that without too much extra work and constant overhead.  Example:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"With a singly linked list (instead of an array) you can obtain O(n) time complexity and O(1) space complexity:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n) time O(1) space solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I don't think this solution will maintain relative order.   Can you give an example?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"complexity is little more than (n)..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have a completly different approach.  What I would suggest is to use Godel numbering to hold the array. we will have 2 Godel numbering. one for the positive numbers, and one for the negative ones.  The godel numbers will be created based on the position of the numbers in the array.  there are some issues in the solution, such as Godel number might grow exponentially with n, and also that if the numbers are not in N, this method won't work.  but still this is a cool approach, maybe someone can develop it a bit more."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using double pointers. The first pointer is to head and the other one to tail.  If the first pointer value is less than zero, first pointer move one step forward. Otherwise, if first pointer greater than zero, waiting second pointer scan from tail till find the first one which is negative.   The complex is O(1) (the constant is 1) and space is O(1) ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int negatifindex=0; int prevnegatifindex=-1; int pozitifindex=4; // array.length-1 int nextpozitifindex=-1; while (negatifindex<=pozitifindex) {    if(array[negatifindex]<0) { if (prevnegatifindex!=-1) swap(array[prevnegatifindex],array[negatifindex])    prevnegatifindex=-1;    negatifindex++;     }    if(array[pozitifindex]>0)  {     if (nextpozitifindex!=-1)    swap(array[nextpozitifindex],array[pozitifindex])    nextpozitifindex=-1;    pozitifindex--; }    if (array[pozitifindex]<0 & array[negatifindex]>0) {    swap(array[pozitifindex],array[negatifindex])    prevnegatifindex=negatifindex;,    pozitifindex--;    nextpozitifindex=pozitifindex;    negatifindex++; } }  Time complexity is O(n) and space is O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Let's solve this problem by diving it into two much simpler problems: A) We want negative numbers to be at the right positions; we don't care about the positive one B) We move the positive numbers at the right positions, not caring about the negative one C) We apply A B on copies of the array and then combine the result to get the final solution  A and B can be easily solve linearly.  Solution for A: {{  void solveA(int* a, int n)  {   int p = 0;   for (int i = 0; i < n; i++)    if (a[i] < 0)     {     a[p] = a[i];      p++    }  } }}  For B the solution is similar.  C) is also quite easy. We just need to count how many negative and positive number we have in order to know how many values to copies from the two partial solution.  Complexity: O(n) both time and space"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package problems; \n \npublic class  \nSpecialSort  \n{ \n public static int[] \n SS \n (int... is) \n { \n  for (int i = is.length - 1; i > 0; --i) \n   for (int j = i; j < is.length && is[j-1] >= 0 && is[j] < 0; ++j) { \n    int tmp = is[j-1]; \n    is[j-1] = is[j]; \n    is[j] = tmp; \n   }  \n  return is; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n) and O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's the simple code, where you shift right everything when you encounter negative number."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This works in O(n) time and O(1) space.  Algorithm:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my solution O(n) time and constant space complexity 1) count number of negative numbers in the array 2) set the index where positive number is supposed to start as pivot 3) count number of positive numbers before pivot and after pivot 4) iterate each number in the array until pivot  a) if number is negative proceed  b) if number if positive initiate rearrangment to place each number in its correct position until we come back to current position.  c++ code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Instead of numbers we should work with segments of positive or negative numbers. Lets say the numbers are [1 2 -1 -2 -3 4 5 6 -7 -8 -9].  initial segments: [1 2], [-1 -2 -3]*, [4 5 6], [-7 -8 -9] step 1. [-1 -2], [1 2]*, [-3], [4 5 6], [-7 -8 -9] ... pushed right seg to left, 2 swaps step 2. [-1 -2 -3], [1 2 4 5 6]*, [-7 -8 -9] ... pushed left seg to right, 2 swaps step 3. [-1 -2 -3], [1 2], [-7 -8 -9]*, [4 5 6] ... pushed left seg to right, 3 swaps step 4. [-1 -2 -3 -7 -8], [1 2]*, [-9], [4 5 6] ... pushed right seg to left, 2 swaps step 5. [-1 -2 -3 -7 -8 -9], [1 2 4 5 6] ... pushed left seg to right, 2 swaps  Total 11 swaps.   Lets say the negative segment is N and the positive segment is P. Now, given a situation like \"[all negative], P, N, [unknown]\", we need to do the following.  1. If |N| >= |P|, send right segment to left, total swap needed |N|+|P| 2. If |N| < |P|, send left segment to right, total swap needed |N|+|P|  Amortized O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please let me know if it has any problem? it is in O(N) time complexity and O(1) space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] arg) {         int[] arr = { -1, 1, 3, -2, 2, -7, 8 };         System.out.println(Arrays.toString(arr));         for (int i = 0; i < arr.length; i++) {             if (arr[i] < 0) {                 checkAndSwap(arr, i);             }         }         System.out.println(Arrays.toString(arr));     }     private static void checkAndSwap(int[] arr, int currIndex) {         for (int i = currIndex - 1; i > 0; i--) {             if (arr[i] > 0) {                 int temp = arr[i];                 arr[i] = arr[currIndex];                 arr[currIndex] = temp;                 currIndex = i;             } else {                 break;             }         }     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{    public static void main(String[] arg) {         int[] arr = { -1, 1, 3, -2, 2, -7, 8 };         System.out.println(Arrays.toString(arr));         for (int i = 0; i < arr.length; i++) {             if (arr[i] < 0) {                 checkAndSwap(arr, i);             }         }         System.out.println(Arrays.toString(arr));     }     private static void checkAndSwap(int[] arr, int currIndex) {         for (int i = currIndex - 1; i > 0; i--) {             if (arr[i] > 0) {                 int temp = arr[i];                 arr[i] = arr[currIndex];                 arr[currIndex] = temp;                 currIndex = i;             } else {                 break;             }         }     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class TestLogic {      public static void main(String[] arg) {         int[] arr = { -1, 1, 3, -2, 2, -7, 8 };         System.out.println(Arrays.toString(arr));         for (int i = 0; i < arr.length; i++) {             if (arr[i] < 0) {                 checkAndSwap(arr, i);             }         }         System.out.println(Arrays.toString(arr));     }     private static void checkAndSwap(int[] arr, int currIndex) {         for (int i = currIndex - 1; i > 0; i--) {             if (arr[i] > 0) {                 int temp = arr[i];                 arr[i] = arr[currIndex];                 arr[currIndex] = temp;                 currIndex = i;             } else {                 break;             }         }     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class TestLogic {      public static void main(String[] arg) {         int[] arr = { -1, 1, 3, -2, 2, -7, 8 };         System.out.println(Arrays.toString(arr));         for (int i = 0; i < arr.length; i++) {             if (arr[i] < 0) {                 checkAndSwap(arr, i);             }         }         System.out.println(Arrays.toString(arr));     }     private static void checkAndSwap(int[] arr, int currIndex) {         for (int i = currIndex - 1; i > 0; i--) {             if (arr[i] > 0) {                 int temp = arr[i];                 arr[i] = arr[currIndex];                 arr[currIndex] = temp;                 currIndex = i;             } else {                 break;             }         }     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The problem can indeed be solved in O(n) time and with O(1) complexity.  Below is my solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution in C++ below. Running time is O(n) (two passes) and it's done in place (O(1) extra-space) :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There is a paper showing O(n) time and O(1) space algorithm \"Stable minimum space partitioning in linear time.\"  diku.dk/hjemmesider/ansatte/jyrki/Paper/KP92b.pdf"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Time O(N) and space O(1) \n \n#include  \n \n/* \n we will take positive number block and negative number block. \n And will move negative number block in front of positive number block. \n*/ \n \nint main() \n{ \n int num[] = {-1, 1, 3, -2, -3, 4, 5, -7, 2, 8, -8}; \n int len = sizeof(num)/sizeof(int); \n int i,l_t,var_t; \n int ps,pe,ns,ne,nc,pc; \n \n ps = pe = ns = ne = 0; \n \n while (1){ \n  for (;num[ps] < 0; ps++); /* Find start of positive number block */ \n  for (pe = ps; num[pe+1] >= 0 && pe+1 < len; pe++);  /* Find end of positive number block */ \n  if (pe+1 == len) { \n   break; \n  } \n  ns = pe + 1; /* Assign start of negative number block */ \n  for (ne = ns; num[ne+1] < 0 && ne+1 < len; ne++);  /* Find end of negative number block */ \n  nc = ne - ns + 1;  /* Count negative numbers in block */ \n  pc = pe - ps + 1;  /* Count positive numbers in block */ \n \n  i = ns; \n  var_t = num[ns]; \n  while (1) { \n   if (i-pc >= ps && num[i-pc] >= 0) {  /* Move negative number to new position */ \n    i -= pc; \n    l_t = num[i]; \n    num[i] = var_t; \n    var_t = l_t; \n   } else if (i+nc <= ne) { /* Move positive number to new position */ \n    i += nc; \n    l_t = num[i]; \n    num[i] = var_t; \n    var_t = l_t; \n   } else {  /* Pick next -ve number  */ \n    for (;num[ns] >= 0 && ns <= ne; ++ns); \n    if (ns > ne) break; \n    i = ns; \n    var_t = num[ns]; \n   } \n  } \n } \n \n for (i=0; i < len; ++i) { \n  printf(\"%d \", num[i]); \n } \n printf(\"\\n\"); \n  \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void sortNegPos(int arr[], size n) \n{ \n int i = 0, j = n-1, index = -1, key = 0; \n \n while (arr[i] < 0) \n i++; \n \n while (arr[j] >= 0) \n j--; \n \n // At this point i points to the first positive integer and j to the last negative integer \n \n index = i; \n key = arr[i]; \n \n while (i < j) \n { \n  if (key >= 0) \n  { \n   key = arr[i + 1]; \n   arr[i+1] = arr[i]; \n  } \n  else \n  { \n   arr[index] = key; \n   ++index;  \n  } \n  i++; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool isNegative(int t) {  return t < 0 ? true : false; }  void sort(int A[], int n) {  std::stable_partition(A, A + n, isNegative); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool isNegative(int t) {  return t < 0 ? true : false; }  void sort(int A[], int n) {  std::stable_partition(A, A + n, isNegative); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool isNegative(int t) {  return t < 0 ? true : false; }  void sort(int A[], int n) {  std::stable_partition(A, A + n, isNegative); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool isNegative(int t) {  return t < 0 ? true : false; }  void sort(int A[], int n) {  std::stable_partition(A, A + n, isNegative); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The following solution seems like O(n) time and O(1) to me. Comments?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#include main() { int n; scanf(\"%d\",&n); int a[n],b[n]; int i=0; for(i=0;i{ scanf(\"%d\",&a[i]); } int k=0; for(i=0;i{ if(a[i]<0) { b[k]=a[i];k=k+1; } else {k=k;} }   for(i=0;i{ if(a[i]>0){b[k]=a[i];k++;}else{k=k;} }  for(i=0;i{ printf(\" %d\",b[i]); } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public int[] sortInOrder(int[] data){ \n   \n  int pos=0; \n  int negPos=0; \n  for (pos=0;pos=0){ \n    while(negPos=0  ){ \n     negPos++; \n    } \n     \n    if(negPos==data.length) \n     break; \n    while(negPos>pos){ \n     int temp=data[negPos]; \n     data[negPos]=data[negPos-1]; \n     data[negPos-1] = temp; \n     negPos--; \n    } \n   } \n    negPos++; \n    pos++; \n    \n  } \n   \n  return data; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"It cannot be done in O(n) . If it can done in O(n), then lower bound for comparision based sorting is O(n) which is false. So, the order is O(nlogn) and space is O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#include  \n#include  \nusing namespace std; \n \nint arr[] = {1,2,-1,1,3,-2,2}; \n \nvoid reverse(int i, int j){ \n while(i=0 && arr[k]>=0)   \n  k--;  \n j = k;  \n do { \n  while(j>=0 && arr[j]<0)   \n   j--; \n  j++;  \n  i = j-1; \n  while(i>=0 && arr[i]>=0)  i--; \n  i++; \n  rotatelist(i, j, k); \n  k = i + (k-j); \n  j = i-1;   \n }while(j>0);   \n} \n \n \nint main(){  \n int N = sizeof(arr) / sizeof(arr[0]); \n for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Very bad code, see what happens with the array {-1,1,3,-2,2}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Part of the inplace quicksort algorithm?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Here is an O(n) solution without extra space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"1.Start counters i at 0th index and j at nth index of the array. 2.Increase i until arr[i]>=0 3.Decrease j until arr[j]<0 4.swap arr[i] ,arr[j] 5.repeat steps 2, 3,4 till i time-O(n),space-O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"1) Make an Auxiliary Array , out of the given numbers, where Auxiliary Array comprises of two attributes : The Integer Number , and it's sign ,'1' for positive, and '-1' for negative . 2) Sort the auxiliary array acc. to the sign (Make a stable sort in use ) e.g Merge Sort . 3) Print the integer Value for elements in the Auxiliary Array ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"start = 0; \n end = length(array)-1; \n while(start0 && a[end]<0) swap(a[start],a[end]) \n  if(a[start]>0) start += 1 \n  if(a[end]<0) end -= 1 \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"1. Find the number of negative integers[count]. 2. Create another array having two indices, one[neg] starting at 0 and the other[pos] starting at count+1. 3. Scan the array sequentially and place the negative integers at the index pointed by neg and the positive at the index pointed by pos, incrementing the respective indices."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"Its impossible, its a classical time-space trade off"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5700226908160000","download_status":"DOWNLOAD_DONE","votes":"6","answersCount":"41","title":"Rearrange an array using swap with 0.  You have two arrays src, tgt, containing two permutations of the numbers 0..n-1. You would like to rearrange src so that it equals tgt. The only allowed operations is ??£þswap a number with 0???, e.g. {1,0,2,3} -> {1,3,2,0} (??£þswap 3 with 0???). Write a program that prints to stdout the list of required operations.  Practical application:  Imagine you have a parking place with n slots and n-1 cars numbered from 1..n-1. The free slot is represented by 0 in the problem. If you want to rearrange the cars, you can only move one car at a time into the empty slot, which is equivalent to ??£þswap a number with 0???.  Example: src={1,0,2,3}; tgt={0,2,3,1};","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"The question does not require the minimum swap number. So, an easy way to do is, find the index of first does not match (except ZERO), then swap ZERO with it, then swap ZERO with the tgt value of that index. Just loop for all positions. Then, it is done. eg. {0, 1, 2} -> {0, 2, 1} first does not match index is 1, and tgt value is 2. So, {0, 1, 2}-> {1, 0, 2}->{1, 2, 0}  If it require the minimum swap number, then, shortest path algorithm will resolve it. Every permutation is one node, and all possible links are just a swap of ZERO. For performance improvement, A* can be used. So, never swap ZERO with any value that matched already. And it is better to generate nodes in run time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"void swap( int *arr, int pos1, int pos2 ) \n{ \n std::cout << pos1 << \" \" << pos2 << std::endl; \n int temp = arr[pos1]; \n arr[pos1] = arr[pos2]; \n arr[pos2] = temp; \n} \n \nvoid swapWith0( int src[], int tgt[], const int n ) \n{ \n int *now = new int[n]; \n int i; \n \n for( i = 0; i < n; i++ ) \n  now[ src[i] ] = i; \n \n do \n { \n  while( tgt[now[0]] != 0 ) \n   swap( now, 0, tgt[now[0]] ); \n \n  for( i = 0; i < n; i++ ) \n  { \n   if( tgt[now[i]] != i ) \n   { \n    swap( now, 0, i ); \n    break; \n   } \n  } \n }while( i < n ); \n \n free( now ); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"1)Make for loop of tgt 2)if ith element of tgt is 0 then contine (skip current iteration) with loop 3)Now find the position of ith element of tgt in src array and store it in say p variable. 4)check if postion found in 3rd step is equal to i? 5)if position is not equal to i than  store p found in 3rd step to other variable say p2. 6)do while loop till p2!=i 7)in this while loop check if p2 is equal to p. this will be true for first iteration of while loop 8) if p2==p then replace zero in src array with p th element in src, then store new postion of pth element in p2.  9)if condition checked in step 7 is not true then  10) initialize temp=0; 11) And  replace zero in src array with temp th element in src 12) Now replace zero with p2 in src array. 13) after while loop increment temp;   Below is pseudocode"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public class RearrangeArray \n{ \n public static void main(String[] args) \n { \n  printArray(\"Soruce\", src); \n  printArray(\"Target\", tgt); \n   \n  rearrange(); \n   \n  printArray(\"Achieved\", src); \n } \n \n static int[] src = { 1, 0, 2, 3, 7, 4, 8, 9 }; \n static int[] tgt = { 0, 2, 8, 3, 1, 9, 4, 7 }; \n \n public static void rearrange() \n { \n  int length = src.length; \n \n  int indexInSrc = -1; \n  int indexOfZeroSrc = -1; \n \n  for (int i = 0; i < length; i++) \n  { \n   if (tgt[i] != 0 && src[i] != tgt[i]) \n   { \n    indexOfZeroSrc = findPosition(src, 0); \n    swapInSrc(indexOfZeroSrc, i); \n    indexInSrc = findPosition(src, tgt[i]); \n    swapInSrc(i, indexInSrc); \n   } \n  } \n } \n \n private static int findPosition(int[] array, int key) \n { \n  for (int i = 0; i < array.length; i++) \n  { \n   if (array[i] == key) \n   { \n    return i; \n   } \n  } \n \n  return -1; \n } \n \n private static void swapInSrc(int index1, int index2) \n { \n  int temp = src[index1]; \n  src[index1] = src[index2]; \n  src[index2] = temp; \n } \n \n public static void printArray(String tag, int[] a) \n { \n  System.out.print(tag + \": \"); \n  for (int i = 0; i < a.length; i++) \n  { \n   System.out.print(a[i] + \",\"); \n  } \n \n  System.out.println(\"\"); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My thoughts:  1) As any number can be swapped only with '0' -> The relative position of most of the numbers should be same, except the case of 1st position.  2) Zero always bubbles up to the first position, its like every new car gets to park on the top of the stack, so which means either (here zero travelling is nothing but swapping)         - Zero travels all the way to right-most and get swapped with left-most element.  - Zero travels all the way to the left-most  So if we consider target possibility of given src={1,0,2,3} would be either   Case 1: tgt={0,2,3,1} - Which is zero travels right-most and gets swapped with left-most element. or Case 2: tgt={0,1,2,3} - Which is zero travels left-most  I mean we compare src[0] with tgt[0] and decide whether to take zero to travel in which direction.  I might be assuming lot of things like  If we assume tgt[0] is always zero then tgt possibilities would be (n-1)!, so by assuming relative position I am ruling out all tgt possibilities except two.  So for {X, , , } => 1, 2, 3 can be arranged in 3! = 6 ways, but I am ruling out {0, 2, 1, 3}, {0, 3, 1, 2}, {0, 3, 2, 1} and {0, 1, 3, 2}  Sai"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class SwapWith0 \n{ \n    public static void main(String[] args) { \n        int[] src = new int[] {1,0,2,3}; \n        int[] tgt = new int[] {0,2,3,1}; \n        int srcEmptyIndex = -1; \n        int tgtEmptyIndex = -1; \n         \n        int[] indexTable = new int[src.length]; \n        for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just have to iterate through the cyclic transposition, only trick is that the graph may not be connected."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static void rearrange(int[] src, int[] trg){ \n    int[] indexTable = new int[src.length]; \n    int swapLocation = -1; \n    for (int i = 0; i < src.length; i++) { \n        indexTable[src[i]] = i; \n        if (src[i] == 0) swapLocation = i; \n    } \n     \n    for (int i = 0; i < trg.length; i++) { \n        int trgNum = trg[swapLocation];          \n        int srcLoc = indexTable[trgNum]; \n        \n        src[srcLoc] = 0; \n        src[swapLocation] = trgNum; \n         \n        System.out.println(srcLoc + \"<->\" + swapLocation +\"; \" + Arrays.toString(src));// +\"; \" + Arrays.toString(location)); \n         \n        swapLocation = srcLoc; \n        \n        if (trg[swapLocation] == 0){ \n            boolean finished = true; \n            for (int j = 0; j < trg.length; j++) { \n                if(src[j] != trg[j]){ \n                    finished = false; \n                    src[swapLocation] = src[j];         \n                    indexTable[src[j]] = swapLocation;              \n                    src[j] = 0; \n                    System.out.println(swapLocation + \"<->\" + j +\"; \" + Arrays.toString(src));// +\"; \" + Arrays.toString(location)); \n                    swapLocation = j; \n                    break; \n                } \n            } \n            if (finished) break; \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.io.*; \nclass eg11{ \n public static void main(String args[])throws IOException{ \n  int[] src = new int[]{1,0,2,3}; \n  int[] trg = new int[]{0,2,3,1}; \n  System.out.println(\"the no of steps required for conversion are:\"+rearranged(src,trg)); \n } \n  \n public static int rearranged(int[] src,int[] trg){ \n  int count=0; \n  int k = findElement(0,src); \n  int l = findElement(0,trg); \n  while(k!=l){ \n   int m = trg[k]; \n   int n = findElement(m,src); \n   src[n] = 0; \n   src[k] = m; \n   k = n; \n   count++; \n  } \n  return count; \n } \n  \n public static int findElement(int n,int[] a){ \n  int i; \n  for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \nvoid printVector(const std::vector& value) { \n    for (int i=0; i& source, const std::vector& target) { \n    if (source.size() != target.size()) { \n        std::cout << \"Source and target differ in size.\" << std::endl; \n    } \n \n    // Make a copy of the initial state \n    std::vector currentState = source; \n \n    int zeroIndex = -1; \n    int outOfPlaceIndex = -1; \n    for (int i=0; i= 0 && outOfPlaceIndex >= 0) \n            break; \n    } \n \n    // Bail out if everything is in order \n    if (outOfPlaceIndex < 0) \n        return; \n \n    // If zero is in place, swap it with something that is out of place \n    if (currentState.at(zeroIndex) == target.at(zeroIndex)) { \n        std::cout << \"Swap \" << currentState.at(outOfPlaceIndex) << std::endl; \n        currentState[zeroIndex] = currentState[outOfPlaceIndex]; \n        currentState[outOfPlaceIndex] = 0; \n        zeroIndex = outOfPlaceIndex; \n        printVector(currentState); \n    } \n \n    while (currentState.at(zeroIndex) != target.at(zeroIndex)) { \n        // Find the index of what should be where the zero index is \n        for (int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It can be achieved in O(n) time algo. \nPut both arrays ( src A[ ] , tgt B[ ] ) in map ( mapA , mapB ) , key will be value of array element and value will be index of array element. \n \nIndex of 0 in A=x; \nIndex of 0 in B=y; \n \nInt i=0; \nWhile ( i < A.lenght){ \n if ( A[i] != B[i]]){ \n  replace (B[i] , B[x]); \n  if(B[i] != A[i]){ \n   var index = mapB.get(A[i]);  \n   replace(B[i], B[index]); \n  } \n } \n i = i+1;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simply modify answer of edlai"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n \n#define SIZE(A) (sizeof(A)/sizeof(A[0])) \n \nvoid swap(int &a, int &b) \n{ \n int tmp=a; \n a=b; \n b=tmp; \n} \n \n \nint main() \n{ \n int source[]={1,0,2,3,5,4,7,9,6,8};//{1,0,2,3}; \n int target[]={0,2,3,1,4,5,9,8,7,6};//{0,2,3,1};//{1,3,2,0}; \n  \n int i,j; \n int size=sizeof(source)/sizeof(source[0]); \n \n int ind=-1; \n \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"template \n    bool computeSwapSequence( \n        const T& space_value, \n        const vector& source, \n        const vector& target, \n        vector* sequence) { \n      hash_map source_map; \n      int ii = 0; \n      for (const T& elem : source) { \n        auto insert_result = source_map.insert(make_pair(elem, ii++)); \n        if (!insert_result.second) { \n          return false; \n        } \n      } \n \n      auto space_iter = source_map.find(space_value); \n      if (space_iter == source_map.end()) { \n        return false; \n      } \n      int space_index = space_iter->second; \n      source_map.erase(space_iter); \n \n      while (source_map.size() > 0) { \n        if (target.at(space_index) == space_value) { \n          swap(space_index, source_map.begin()->second); \n        } else { \n          const T& target_elem = target.at(space_index); \n          auto map_iter = source_map.find(target_elem); \n          if (map_iter == source_map.end()) { \n            return false; \n          } \n          space_index = map_iter->second; \n          source_map.erase(map_iter); \n        } \n        sequence->push_back(space_index); \n      } \n      return (target.at(space_index) != space_value); \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I find an algorithm could achieve the goal in O(n) time, and here is the procedure: 1) scan the tgt array to find out the target position of i( i is an element in src ), and store it as an array tgt_index, so tgt[2] means where 2 should be in the tgt array; 2) scan the src array to find out the position of zero, denoted as zero_pos; 3) for each element src[i], let its target position in tgt be ti = tgt_index[src[i]] 3.1) if src[i] == 0, just swap src[i] and src[ti], and change zero_pos   to ti; 3.2) if src[i] == 0, first swap src[ti] with src[zero_pos]( src[ti]has zero now ), then swap src[i] with src[ti]( src[i] has zero now ), and at last swap src[zero_pos] with src[i]( src[zero_pos] has zero new ).  Here is my code in C++:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algo 1: O(n^2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for (int i = 0; i < tgt.length; i++) { \n if (tgt[i] == 0) continue; \n int pos = findPos(src, tgt[i]); \n if (i == pos) continue; \n int posZero = findPos(src, tgt[i]); \n if (posZero != i) { \n  swap(src[posZero], src[i]); \n } \n swap(src[pos], src[i]); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// My idea is based on regular permutation implementation, and it is easy to understand. By iteratively swap 0 with others element in the array, we can get desired permutation(target). Also, swapping two non-zero values require some trick.   say src={1,0,2,3}, dest={3,2,0,1}  By swapping forward, we get: {1}+0+perb(2,3),{1,2}+perb(0,3), {1,3}+perb(2,0); by swapping backward, we get: 0+perb(1,2,3)  src={...., 0, ...}, the first part contains i elements before 0 and the second part contains j elements after 0, and i+1+j=n  //swap forward and permutation for(int k=i+1;k swap(0,src[k]);  int first[]=src[0...k-1];  int second[]=perb(src,k+1,n,k);  int result[]=first+second; }   //swap backward ...  // note we are unable to do swap(a[i],a[j]) directly, and use swap_ex to replace swap  void swap_ex(int a[], int i, int j, int h){// h is the position of 0    swap(&a[i],&a[h]);    swap(&a[h],a[j]) }  void perb(int src[], int k, int n, const int h){  // h is the pos of 0 {     if (k==n){      // we have a chance here to find if src matches target  return;     }     else{  for(int j=k;j    swap_ex(src[k],src[k+1],h);            perb(src,k+1,n);            swap_ex(src[k],src[k+1],h);         }     } }  Time and space complexity is ok(if the input is a huge string, it might be a problem!)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I felt confused about swap with 0. Does it mean swap(&a[i], &[j]) when a[i] or a[j] has value 0?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def swap(l1,l2): \n  n = len(l1) \n  k = 0 \n  while l1[k] == 0: \n    k += 1 \n  for i in range(n): \n    if l1[i] != l2[i]: \n      j = i+1 \n      while j < n and l1[j] != l2[i]: \n        j += 1 \n      if ( l1[i] != 0 ): \n        print(\"swap %d with 0\" % l1[i]) \n      print(\"swap %d with 0\" % l1[j]) \n      l1[k] = l1[i] \n      l1[i] = l1[j] \n      l1[j] = 0 \n      k = j"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void reArrange(int src[], int dest[]) { \n  int i; \n  int n = src.length; \n  for(i = 0; i < n; i++) { \n   if(dest[i] != 0 && dest[i] != src[i]) { \n    int zero_pos = getIndex(src, 0); \n    swap(src, i, zero_pos); \n    int dix = getIndex(src, dest[i]); \n    swap(src, i, dix); \n   } \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class SwapZero { \n public static void main(String[] args) { \n  int[] i1 = { 0, 1, 2, 3 };//{1, 0, 2, 3} \n  int[] i2 = { 0, 2, 3, 1 }; \n  swap(i1, i2); \n } \n \n public static void swap(int[] i1, int[] i2){ \n  int c = 0; \n  int ip1 = 0; \n  int ip2 = 0; \n   \n  for( int i = 0 ; i < i1.length; i++){ \n   if( i1[ i ] == 0) \n    ip1 = i; \n   if (i2[i] == 0) \n    ip2 = i; \n  } \n   \n  if( ip1 == ip2 ){  \n   if(ip1 + 1 < i1.length){ \n    swap(ip1, ip1 + 1, i1); \n    ip1 = ip1 + 1; \n   }else{ \n    swap(ip1, ip1 - 1, i1); \n    ip1 = ip1 - 1; \n   } \n  } \n  while( c < i1.length - 1){ \n   for(int i = 0; i < i2.length; i++ ){ \n    if ( i2[ip1] == i1[i]){ \n     swap(i, ip1, i1); \n     ip1 = i; \n     c++; \n     break; \n    } \n   } \n  } \n } \n  \n private static void swap(int i, int j, int [] i1){ \n  int t = i1[i]; \n  i1[i] = i1[j]; \n  i1[j] = t; \n  for(int intg : i1 ) \n   System.out.print(intg + \" \"); \n  System.out.println(); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"A simple recursion should be suffice:  1) Find the 0's index (pos_0) in src[] 2) If tgt[pos_0] == 0, stop recursion, otherwise swap 0 with tgt[pos_0], then recursion.  Time complexity is O(N^2), space is O(1)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#include  #include  #include  int a[100],b[100],n,s[100]; int posb(int i) {     int j,l;     for(j=0;j    {         if(b[j]==i)         return j;     } } swap(int i,int j) {     int t;     t=b[i];     b[i]=b[j];     b[j]=t; } rea(int l,int p) {     int i,j,k,m;     if(l!=0)     {         k=a[p];         if(k!=0)         {             m=posb(k);             l--;             swap(p,m);             s[p]=1;             printf(\"\\npositin %d <--> %d\",p+1,m+1);             for(i=0;i            {             if(b[i]==0)             {                 m=i;                 break;             }             }         }         else         {             i=p+1;             while(s[i]==1)             {                 if(i==n-1)                 {                     i=0;                 }                 else                 i++;             }             m=i;         }         rea(l,m);     } } main() {     FILE *fp;     fp=fopen(\"input.txt\",\"r\");     int i,d,k;     fscanf(fp,\"%d\",&n);     printf(\"%d\\n\",n);     for(i=0;i    {         fscanf(fp,\"%d\",&a[i]);     }     for(i=0;i    {         fscanf(fp,\"%d\",&b[i]);     }     for(i=0;i    {         printf(\"%d \",a[i]);     }     printf(\"\\n\");     for(i=0;i    {         printf(\"%d \",b[i]);     }     for(i=0;i    {         s[i]=0;     }     for(i=0;i        {             if(b[i]==0)             {                 k=i;                 break;             }         }     rea(n-1,k);     printf(\"\\n\");     for(i=0;i    {         printf(\"%d \",a[i]);     }     printf(\"\\n\");     for(i=0;i    {         printf(\"%d \",b[i]);     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#A.Nasimunni"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Javascript version without recursion Less memory because it doesn't need to keep a stack of calls Count and logs for easier understanding"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5136177443110912","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"43","title":"Write a method to determine if two strings are anagrams of each other. e.g. isAnagram(??£þsecure???, ??£þrescue???) ??? false e.g. isAnagram(??£þconifers???, ??£þfir cones???) ??? true e.g. isAnagram(??£þgoogle???, ??£þfacebook???) ??? false","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"This complexity is O(n) for this program.  I use a hashmap for storing the characters of the firstString. The hashmap has all the characters of firstString as key and its occurrence as value. As you iterate over the firstString, find if the character is already present in the map. If yes, then add plus one to its value. else make an entry with value as 1. After constructing the map, iterate over the secondString and do a lookup against the hashmap to find the key.Decrement the value by 1 once an occurence is found. When the value of occurence becomes 0, remove the entry from hashmap.  Once the iteration is over, if the hashmap is empty, then secondString is an anagram of the firstString. else not an anagram.  The following is the code.  private boolean isAnagram(String firstString, String secondString) {   if(firstString.equals(secondString))    return true;   Map mapOfLettersWithOccurence = new HashMap();   for(int i = 0; i < firstString.length(); i++) {    char ch = firstString.charAt(i);    if(mapOfLettersWithOccurence.get(ch) != null) {     int occur = mapOfLettersWithOccurence.get(ch);     ++occur;     mapOfLettersWithOccurence.put(ch, occur);    } else {     mapOfLettersWithOccurence.put(ch, 1);     }   }   for(int i = 0; i < secondString.length(); i++) {    char ch = secondString.charAt(i);    if(ch == ' ')     continue;    if(mapOfLettersWithOccurence.get(ch) == null)     return false;    else {     int occur = mapOfLettersWithOccurence.get(ch);     --occur;     if(occur == 0)       mapOfLettersWithOccurence.remove(ch);     }   }   if(mapOfLettersWithOccurence.isEmpty())    return true;      return false;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Based wikipedia description. It seems the first case should return true. Is that right?  Then, a quick way to check will be use a hash of character to number. Then compare the hash. The hash can be implemented by array index if the string is ascii only."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Keep an ascii char array.  Code :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Yeah, @Jie has a valid question. Why isAnagram(??£þsecure???, ??£þrescue???) ??? false ??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \nint charCounts[26]; \n \nvoid changeCharCount(const char value, int amount) { \n \n    int valueIndex = tolower(value) - 'a'; \n \n    if (valueIndex < 0 || valueIndex > 25) \n        return; \n \n    charCounts[valueIndex] += amount; \n} \n \nbool isAnagram(const std::string& a, const std::string& b) { \n    // Count character occurances in a \n    for (int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Determine if two strings are anagrams of each other \nimport java.util.HashMap; \nclass AnagramApp \n{ \n public static void main(String args[]) \n { \n  boolean is = isAnagram(\"stressed\",\"desserts\"); \n  System.out.println(is); \n } \n \n public static boolean isAnagram(String first, String second) \n { \n  //both strings are null \n  if(first == null && second == null){ \n   return true; //debatable whether or not it should return true or false \n  } \n  //one of the strings is null, but the other is not  \n  if((first == null && second != null) || (first != null && second == null)){ \n   return false; \n  } \n  //if they are equal then they are anagrams \n  if(first.equals(second)){ \n   return true; \n  } \n  //if the length doesn't match, they are not anagrams \n  if(first.length() != second.length()) \n   return false; \n \n  //as this point we have 2 non-null strings with matching lengths \n  HashMap charMap = new HashMap(); \n \n  int i; \n  Integer current; \n \n  for(i = 0; i < first.length(); i++){ \n \n   current = charMap.get(first.charAt(i)); \n   if(current == null) \n    current = 0; \n   charMap.put(first.charAt(i), ++current); \n  } \n \n  Character k; \n  Integer v; \n   \n  for(i = 0; i < first.length(); i++){ \n   k = second.charAt(i); \n   v = charMap.get(k); \n   if(v == null || ( v != null && --v < 0)){ \n    return false; \n   } else { \n    charMap.put(k,v); \n   }     \n  } \n  return true; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"first input rescue and secure should return true... na"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"# Best Python solution. O(n) \n \nfrom collections import Counter \nanagrams = lambda s1, s2: Counter(s1) == Counter(s2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"iterate on each char of the first string, keep a count,  and look into the second string for the char, if match is found remove it from the second string, at the end check if count and the length of the second string is 0."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool isAnagram( char *s1, char *s2 ) \n{ \n int map[255] = {0}; \n \n if( ( s1 == NULL ) && ( s2 == NULL ) ) \n  return true; \n \n if( ( s1 == NULL ) || ( s2 == NULL ) ) \n  return false; \n \n while( *s1 != '\\0' ) \n { \n  map[*s1]++; \n  s1++; \n } \n \n while( *s2 != '\\0' ) \n { \n  map[*s2]--; \n  s2++; \n } \n \n for( int i = 0; i < 255; i++ ) \n { \n  if( map[i] != 0 ) \n   return false; \n } \n \n return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"* i did this in O(n).  * i did this by maintaining a map of characters in a numerical array. since possible values of alphabets relative to 'a' is only from 0-25. so maintained a numerical array of 26 length and initialize each element to 0. * next to do was traverse the given string and increase each index of the current characcter by one on occurence. [I ASSUMED THAT THE INPUT WAS NOT IN CAPS OR I WOULD HAD ADDED A SMALL stlwr TO FORMAT STRINGS TO LOWER CASE]. * also i ignored occurences of space and eliminated its processing. after mapping the first, i traversed the second and checcked of the index of that character was >0. * also at the end i made a check for the residue if any related to corner cases. rest comments in the code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if __name__=='__main__': \n string1=\"\".replace(' ','') #string1_Value \n string2=\"\".replace(' ','') #string2_Value \n  \n dict={} \n for i in string1: \n  if (dict.has_key(i)): \n   dict[i]+=1 \n  else: \n   dict[i]=1 \n  \n        zeroValue=0 \n isAnagram=True \n for j in string2: \n  if dict.has_key(j): \n   dict[j]-=1 \n   if dict[j]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ALGO: ---------  Check if both the words belong in some dictionary. There can be a hash map of the dictionary. If there are multiple words, then a split operation might have to be performed on a predefined set of separators (e.g. ' ', ',', ':', ';' etc.)  Use an array of 256 for ascii characters.  1. Go through the first string and add 1 to the array[ascii index] for every character.  2. Go through the second string and add 1 to the array[ascii index] for every character. If at the end, if all the values of the ascii array are even or 0 then we have an anagram. Else not.  One of the conditions might be, do not increment for special characters like space. This can be defined apriori."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.io.BufferedReader; \nimport java.io.IOException; \nimport java.io.InputStreamReader; \nimport java.util.Arrays; \nimport java.util.Scanner; \n \n \npublic class Anagram { \n \n public static void main(String[] args) throws IOException { \n  //Scanner a = new Scanner(System.in); \n     BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); \n  String s1 = br.readLine(); \n  String s2 = br.readLine(); \n   \n  if(s1.equals(s2)) \n   System.out.println(\"true\"); \n  else{ \n   s1 = s1.replace(\" \", \"\"); \n   s2 = s2.replace(\" \", \"\"); \n   char c1[] = s1.toCharArray(); \n   char c2[] = s2.toCharArray(); \n   Arrays.sort(c1); \n   Arrays.sort(c2);    \n   if(new String(c1).equals(new String(c2))) \n    System.out.println(\"true\"); \n  } \n   \n   \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package test;  import java.util.HashMap; import java.util.Map; import java.util.Scanner;  /**  * @author p80025131  *  */ public class Anagram {   /**   * @param args   */  public static void main(String[] args) {   // TODO Auto-generated method stub   Scanner kb = new Scanner(System.in);   String firstString=kb.next();   String secondString=kb.next();  /* String firstString=\"vdlpeeeor\";   String secondString=\"developer\";*/   Boolean isSame = checkIdenticle(firstString,secondString);   if(isSame)   {    System.out.println(\"Yes, Both \"+firstString+\" and \"+secondString+\" are identicle\");    }   else   {    System.out.println(\"No, Both \"+firstString+\" and \"+secondString+\" are not identicle\");   }  }   public static boolean checkIdenticle(String firstString,String secondString)  {      Map  collect= new HashMap();   for(int i=0;i  {    char ch= firstString.charAt(i);    if(collect.get(ch)!= null)    {     int counter = collect.get(ch);     ++counter;     collect.put(ch,counter);         }    else    {     collect.put(ch,1);    }   }   for(int i=0;i  {    char ch= secondString.charAt(i);    if(ch == ' ')     continue;    if(collect.get(ch)== null)    {     return false;    }    else    {     int counter = collect.get(ch);     --counter;     if(counter==0)     {      collect.remove(ch);     }     else     {     collect.put(ch,counter);     }    }       }   if(collect.isEmpty())    return true;    return false;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static bool IsAnagram(string source, string target) \n        { \n            if (source == null || target == null) \n                return false; \n            Hashtable listOfChars = new Hashtable(); \n \n            foreach (char ch in source) \n            { \n                if (ch == ' ') \n                    continue; \n                 \n                if (listOfChars[ch] == null) \n                   listOfChars.Add(ch,1); \n                else \n                { \n                    int _cnt = (int)listOfChars[ch]; \n                    _cnt++; \n                    listOfChars[ch] = _cnt; \n                } \n            } \n            foreach (char ch in target) \n            { \n                if (ch == ' ') \n                    continue; \n                if (listOfChars[ch] == null) \n                    return false; \n                 \n                int _cnt = (int)listOfChars[ch]; \n                _cnt--; \n                listOfChars[ch] = _cnt; \n            } \n \n            foreach (DictionaryEntry de in listOfChars) \n            { \n                if ((int)de.Value != 0) \n                    return false; \n            } \n \n            return true; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Guys its so simple. concatenate and XOR, Below is the code:  complexity O(n) time"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java solution for ASCII characters, including a parameter to know if we accept space between words (e.g. isAnagram(??£þconifers???, ??£þfir cones???) ??? true ) or not."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can do it in O(n), with no extra space used"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"EXPLAIN your ideas so the original poster gets some general technique from it.    Here is my line of thinking (not necessarily the best). strings are just arrays of integers   If you want to compare two arrays of integers, how would you do it? 1)  Brute force O(n^2). Now you think of your brute force method and realize if the arrays were sorted you can linear check on both and see if each position matches.  What is the complexity of sorting?     Comparison sorts: O(n*lg(n))    Integer based sorts O(n+k) for k=max(int)    AHAAAA.  At this point my lightbulb goes off, here k=fixed (it is 26 or however many characters in your alphabet).      Since each character is guaranteed to have a small range of integers, we can use a linear integer sorting algorithm!!     So let's do that:    Sort the first one using bucket/counting sort O(n)    Sort the second one using bucket/counting sort O(n)     Now linear scan from left to right checking each position O(n).    This takes O(n+k) extra space.      ----- I can also think of a way to save A BIT MORE time doing the above, but who cares. ----   Hash table can be used IF you treat them with care (think about it, what if you have two strings \"sssssssssssssssa\" \"assssssssssssss\"  .... usually Hash tables will perform badly in these cases and give O(n) lookup)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static bool IsAnagrams(string first, string second) \n        { \n            bool result = false; \n            IDictionary temp = new Dictionary(); \n \n            foreach (char c in first) \n            { \n                if (temp.ContainsKey(c)) \n                    temp[c] = temp[c] + 1; \n                else \n                    temp.Add(c, 1); \n            } \n \n            foreach (char c in second) \n            { \n                if (temp.ContainsKey(c)) \n                { \n                    temp[c] = temp[c] - 1; \n                    if (temp[c] == 0) \n                        temp.Remove(c); \n                } \n            } \n \n            if (temp.Count == 0) \n                result = true; \n \n            return result; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#!/usr/bin/env python \n \nfrom collections import Counter \nimport string \n \ndef isAnagram(s1, s2): \n    \"\"\" \n    > Counter(\"abc\") \n    Counter({'a': 1, 'c': 1, 'b': 1} \n \n    >>> isAnagram(\"secure\", \"rescue\") \n    True \n \n    >>> isAnagram(\"conifers\", \"fir cones\") \n    True \n \n    >>> isAnagram(\"google\", \"facebook\") \n    False \n \n    \"\"\" \n \n    allowed = set(string.ascii_letters + string.digits) \n \n    clean_s1 = \"\".join([c for c in s1 if c in allowed]).lower() \n    clean_s2 = \"\".join([c for c in s2 if c in allowed]).lower() \n \n    return Counter(clean_s1) == Counter(clean_s2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static int GetCharSum(string str) \n        { \n            int sum = 0; \n            foreach (var ch in str) \n            { \n                if (ch == ' ') \n                    continue; \n                sum += ch; \n            } \n            return sum; \n        } \n \n        public static bool IsAnagram(string one, string two) \n        {           \n            int oneSum = GetCharSum(one); \n            int twoSum = GetCharSum(two);         \n          \n            if (oneSum == twoSum) \n                return true; \n \n            return false; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static boolean isAnagram (String str1,String str2){ \n  int [] dp = new int [26]; \n  for (int i =0 ; i < str1.length() ; ++i){ \n   if (Character.isAlphabetic(str1.charAt(i))){ \n    dp[str1.charAt(i)-'a']++; \n   } \n  } \n   \n  for (int i =0 ; i < str2.length() ; ++i){ \n   if (Character.isAlphabetic(str2.charAt(i))){ \n    dp[str2.charAt(i)-'a']--; \n   } \n  } \n   \n  for (int i =0 ;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#Python 2.x code def sortString(s):  m = list(s)  m.sort()  i = \"\"  for j in m:   i+=j  return j str1 = raw_input() str2 = raw _input() if sortString(str1)==sortString(str2):  print \"Anagram\"#or True else:  print \"Not an anagram\""},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"We can also sort the two strings and then see if they are the same. KMP runs in O(n) time and O(n) space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Method 1: -------------- For O(N) complexity use hashmap or binary search tree  Method 2: -------------- For O(NLOGN) complexity sort both the strings and traverse both the strings one by one . If at any index if both are not equal then return false else return true"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#Author : A.Nasimunni   #This programme takes O(1) complexity  n=raw_input(\"  \\n\\tEnter your string  : \"); n2=raw_input(\" \\n\\tEnter your checking word : \"); d=sorted(n2) c=sorted(n) if d==c:  print \"\\n\\t True\\n\\n\" else:  print\"\\n\\t false\\n\\n\""},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#Author : A.Nasimunni   #This programme takes O(1) complexity  n=raw_input(\"  \\n\\tEnter your string  : \"); n2=raw_input(\" \\n\\tEnter your checking word : \"); d=sorted(n2) c=sorted(n) if d==c:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6634738777325568","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"34","title":"Given a tree in the form of parent pointers of every node (for root assume parent pointer to be null), write code to find the diameter of tree.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"I had to look up what diameter of a tree is: length of longest path between two leaves. My solution is in Java and I'm using the original data structure, without building a regular tree structure first.  The general idea is to start at the leaf nodes and traverse the tree towards the root. Each node is annotated with the maximum height and the max diameter for this node. The diameter only gets updated once - when we hit a path that is already annotated and then we skip to the next iteration. If during traversal we hit a node that has a bigger height than our current path, skip to the next iteration.  Asymptotic Running Time: O(n) to identify leaf nodes O(n) to traverse tree -> O(n)  To see that O(n) is true for the tree traversal: We visit each leaf node once.  Each inner node is visited only once if it is only on one path. Each inner node that is on more than one path gets visited again only if the path height is higher at that point. If they were to be visited every time (worst-case), the runtime would be O(n log n). But we can safely assume, that on average that won't happen.  { { {  int diameter(Node[] nodes) {      // Identify leaf nodes     // TODO could be more efficient by marking nodes that have children as:     // not-leaf-node     ArrayList leafNodes = new ArrayList    for(Node n: nodes) {         leafNodes.remove(n.parent);     }      // walk leafNodes up to root and set max height/diameter     // we may have to use hashmaps to set vars to nodes instead of assuming     // member vars inside the nodes      int treeDiameter = 0;      for(Node n: leafNodes) {         int height = 1;         boolean disableDiameterUpdate = false;          while(n != null) {             if(!disableDiameterUpdate && n.maxHeight > 0) {                 n.diameter = height + n.maxHeight - 1;                 if(n.diameter > treeDiameter)                     treeDiameter = n.diameter;                 disableDiameterUpdate = true;             }              if(n.maxHeight >= height)                 break;              n.maxHeight = height;             height++;             n = n.parent;         }     }      return treeDiameter; }  } } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Check out \"w w w.geeksforgeeks.org/diameter-of-a-binary-tree/\" for explanation and the solution for this problem.  Note that there is a very good O(n) solution provided, but it doesn't use parent pointers. I am very interested to see, if there is a better solution using the parent pointers though."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Please define what a diameter of a tree is!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I think this solution should work 1.Split the nodes as parent nodes and leaf nodes(can be done in O(n^2) time, worst case) just mark the node if it is reached by moving to parent of another node 2.Create a global variable max_diameter = 0 3.Mark all parent nodes as white, and distance as 0. 4.For each leaf node, start with temp_distance as zero, and as you move up a parent, keep incrementing the temp_distance count 5.If a parent is marked as white, make distance of parent = temp_distance, mark node as black 6.If parent is marked black, temp = distance stored in parent + temp_distance, if temp > max_diameter, make max_diameter = temp, and if temp_distance > parent distance, update parent distance 7.do this for all nodes 8.max_diameter is the value to be returned  I check this for all cases and it worked fine, if someone can come up with a counterexample, please post it here"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"assume that all nodes are stored in an array or a list:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think we just know the parent of each node and know nothing about their sons. And the tree can be any tree, not only BST. When allowed to use O(n) space and the space is static, I can give an algorithm with O(nh) time.  (Of course, we can malloc the sons of each node, but the memory will be dynamic.)  Here's the program in C++:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How is the tree represented? I mean, if it is represented by the root of the tree, there is no way to access any other node if only parent nodes are given."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Based on the description of question, here is my assumption: Tree has three nodes a) Left Node b)Right Node c)Parent Node Maximum diameter of tree will be distance between two nodes. These two nodes will be leaf nodes only. so, here is pseudo code: 1.Find farthest leaf node in left subtree: Traverse Left subtree and store all leaf nodes in an array . Loop through all leaf nodes and use parent pointers to find distance to root node, using a temp varaible. Keep updating temp varaible with Max distance. 2. Find farthest leaf node in right subtree Find all leaf nodes in right subtree of root node. Traverse till each leaf node and record the maximum distance. Diameter will be distance between leaf node in left subtree which is farthest from root , and leaf node in right subtree which is farthest from root.  Please comment your views if My analysis is in correct direction or I am missing something."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I suppose this problem could be solved as follows: 1. use the given parent information to build up the topology of the tree. i.e., if a is the parent node of b, add a link between a and b. 2. start with any node u of the tree, use a breadth first search to find the farthest node of u (suppose it's s). 3. start with node s, use a breadth first search to find the farthest node of s (suppose it's t). The distance between s and t would be the required diameter."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For binary tree there is simple answer in O(n). But in general case, it's the longest path problem in undirected acyclic graph, no simple solution, bounds by theta(n^3) or n^2 depending on implementation."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think for an O(n) solution we need to cheat a bit."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Definition: The diameter of a tree (sometimes called the width) is the number of nodes on the longest path between two leaves in the tree.   Algorithm: The diameter of a tree T is the largest of the following quantities: * the diameter of T??s subtree (path does not go through the root) * the longest path between leaves that goes through the root of T (this can be computed from the heights of the subtrees of T)   Code?? (with test case in main)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"find the longest path (travel parent pointer). set parent pointer to null for this path. find another longest path. return add the length - 1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Diameter = Max(depth(leftSubTree), depth(RightSubTree)) + 1;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* Should work; should be bounded by O(2n) */ \npublic class  \nPointerToParent  \n{ \n public static class \n Node \n { \n  Node parent; \n  public Node(Node parent) { this.parent = parent; } \n } \n  \n public static int \n PP \n (List ns) \n { \n  Map hm = new HashMap<>(); \n  int max_len = 0; \n   \n  for (Node n : ns) { \n   Node cur = n; \n   int len = 0; \n   while (cur.parent != null && !hm.containsKey(cur)) { \n    cur = cur.parent; \n    len++; \n   } \n   if (hm.containsKey(cur)) len += hm.get(cur); \n    \n   hm.put(n, len); \n   if (len > max_len) max_len = len; \n    \n   cur = n; \n   while((cur = cur.parent) != null && !hm.containsKey(cur)) \n    hm.put(cur, --len); \n  } \n   \n  return max_len; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java Implementation of tree diameter /**          6     /   \\     2     7          /  \\     \\       1    4     9                   / \\    /                 3   5 8       */"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Even if you don't have parent pointer you can solve this problem in O(n). Use following code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if you know bfs algo to find diameter of any tree/graph the below is the answer in O(n). if you don't then google it first. Algo: 1. find the max height leaf node - o(n); 2. travel that leaf node up to root node and mark each node's parent to null. 3. find the max height leaf node now - O(n) 4 answer is the distance between #1 node and #3 node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this does not work always as in the case of  below tree             4      2                  7            5     8              9  In this case, the max diameter is 5 but the above program returns 4. Because 1. When you start from node 2, then height(4) = 2. The diameter at node 4 is not calculated yet 2. Now we start from node 5,  then height(7)= 2 and node(4) is already annotated so the diameter of node 4 will be calculated as 4 3. Now we start from 9, then node 7 is already annotated so diameter at node 7 will be 4. 4. But the actual diameter is 5 5. Correct me if I am wrong"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"We have the child-parent relationship available to us. In addition, we know where the parent of the root is (i.e., NULL or -1). Here, I am assuming we know the number of the nodes to be n:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Why cant just sort both the string and match them."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"If there are only parent node . The diameter of the tree would the largest path from the leaves to the root   For example consider the tree"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Isn't that the height of the tree?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=25127665","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"14","title":"I have a list of several million words unsorted.  How can you find the largest and the smallest words that can be typed by a single hand on a qwerty-style keyboard?  Following the rules of finger placement, a word can either be typed fully on the left-hand side of the keyboard, the right-hand side, or both.  Find the largest and smallest left-hand word(s), and the largest and smallest right-hand word(s).   given: millions of words, unsorted given: set of left-hand chars - a,s,d,f,... given: set of right-hand chars - j,k,l...","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"14","title":"1)For all characters in the left hand set add weight = 2. 2) For all characters in the right hand set add weight = 5. lefthand set is \"qwerasdfzxcvtgb \" righthand set is \"uiopjklmnhy \" weight[] = {2 or 5 for all of 26 chars};  Foreach word w in dictionary:     1) computer cummulative weight as :         cum_weight = product of weight of all chars in the word. Eg: cum_weight(cat) = weight[c]*weight[a]*weight[t] = 2*2*2 = 8      2) If (cum_weight % 2 ==0) and (cum_weight %5 !=0)             the word consists of ONLY LEFT HAND set chars.         If (cum_weight %5 ==0) and (cum_weight %2 != 0)             the word consists of ONLY RIGHT HAND set chars.     3) Now u can use max variable to keep track of longest word. Longest word is essentially maximum value in each category."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I realized I forgot to comment my code, so I am resubmitting it with comments now. Tell me what you think!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class OneHandWords { \n public static String left = \"qwerasdfzxcvtgb \"; \n public static String right = \"uiopjklmnhy \"; \n  \n public static String largestLeft(String[] words) { \n  String ret = \"\"; \n  for (String s : words) { \n   if (isLeft(s.toLowerCase()) && s.length() > ret.length()) { \n    ret = s; \n   } \n  } \n  return ret; \n } \n  \n public static String smallestLeft(String[] words) { \n  String ret = \"\"; \n  for (String s : words) { \n   if (isLeft(s.toLowerCase())) { \n    if (ret.length() > s.length())  \n     ret = s; \n    else if (ret.equals(\"\"))  \n     ret = s; \n   } \n  } \n  return ret; \n } \n  \n public static String largestRight(String[] words) { \n  String ret = \"\"; \n  for (String s : words) { \n   if (isRight(s.toLowerCase()) && s.length() > ret.length()) { \n    ret = s; \n   } \n  } \n  return ret; \n } \n  \n public static String smallestRight(String[] words) { \n  String ret = \"\"; \n  for (String s : words) { \n   if (isRight(s.toLowerCase())) { \n    if (ret.length() > s.length())  \n     ret = s; \n    else if (ret.equals(\"\"))  \n     ret = s; \n   } \n  } \n  return ret; \n } \n  \n public static String largestOneHandWord(String[] words) { \n  String right = largestRight(words); \n  String left = largestLeft(words); \n  if (right.length() >= left.length()) \n   return right; \n  else \n   return left; \n } \n  \n public static String smallestOneHandWord(String[] words) { \n  String right = smallestRight(words); \n  String left = smallestLeft(words); \n  if (left.length() < right.length()) \n   return left; \n  else \n   return right; \n } \n  \n  \n private static boolean isLeft(String s) { \n  boolean isGood = left.contains(s.subSequence(0, 1)); \n  if (s.length() < 2 && isGood) { \n   return true; \n  } \n  else if (isGood) { \n   return isLeft(s.substring(1)); \n  } \n  else \n   return false; \n } \n  \n private static boolean isRight(String s) { \n  boolean isGood = right.contains(s.subSequence(0, 1)); \n  if (s.length() < 2 && isGood) { \n   return true; \n  } \n  else if (isGood) { \n   return isRight(s.substring(1)); \n  } \n  else \n   return false; \n } \n  \n  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simple comparisons seem work to me. Does the following solution miss any key points?  To find the largest right-hand-word: 1. max = the first right-hand-word; // initialization 2. For each word{  3.??????if the word is a right-hand-word{ 4. ???????????max = word > max? word : max; 5.  ????} 6. } 7. Output max;  The comparison in 4 is defined, since the order of words must be given in the question (by the interviewer)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void wrodProcessor(String [] words) { \n     \n    int weight[] = {2,2,5,5,................}; \n    String lmax = \"\"; \n    String lmin = \"\"; \n    Stirng rmax = \"\"; \n    String rmin = \"\"; \n    int lMaxVal = Integer.MAX_VALUE; \n    int rMaxVal = Integer.MAX_VALUE; \n    int lMinVal = Integer.MIN_VALUE; \n    int rMinVal = Integer.MIN_VALUE; \n     \n    int i; \n    int n = words.length; \n    for(i = 0; i< n; i++) {     \n        String word = words[i]; \n        int j; \n        int n1 = word.length(); \n        int w = 1; \n        for (j = 0; j < n1; j++) { \n            char ch = word.charAt(j); \n            w = w * weight[ ch - 'a']; \n        } \n         \n        if(w % 2 == 0 && w % 5 != 0) { \n            if(lMinVal > w ) { \n                lMinVal = w; \n                lmin = word; \n            }  \n            if( lMaxVal < w ) { \n                lMaxVal = w; \n                lmax = word; \n            }  \n        } else if(w % 2 != 0 && w % 5 == 0) { \n            if(rMinVal > w ) { \n                rMinVal = w; \n                rmin = word; \n            }  \n            if( rMaxVal < w ) { \n                rMaxVal = w; \n                rmax = word; \n            } \n        } \n    } \n    System.out.println(lmin + \" \" +  lmax + \" \" + rmin + \" \" + rmax); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I believe instead of doing multiplication. We can maintain an integer byte. Lets say one for left hand words and other for right hand words. Which is one time process. Now for each character in each word, it is possible to find whether it is left hand word or right hand. ( bit flipping) And yes it good idea to check if word length is greater than or less than current maximum and minimum. But my point in that in this case either we must know length of each word before hand or we ourselves need to determine. And if we ourselves determine that it will be bad since we are traversing the whole word."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4534583521443840","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"21","title":"How to find medium of 1 billion numbers across N distributed machines efficiently?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"1)Each machine sorts it's own elements.  Comlexity: nlog(n)  Time: Highest of all the machines. 2) Leader machine builds a heap of m elements(m being the number of machines)    Heap node contains numbers and machine to which the number belongs 3) Leader machine asks each machine to give next smallest element.    Complexity: m log(m) 4) Leader machine removes the smallest element from heap(o(1)) and asks for next min number to the machine to which that number belonged. 5) Insert the next min number in heap, repeast from step 4 till the time kth min number is found. Total time complexity:   if h is highest chunk of data with a machine, h log(h) for sorting. If m is number of machines: m log(m) for building heap. If k is half of billion numbers, find kth element complexity is: k log(m) Total messages passed: k(half billion).  I am wondering if I could do the heap part in parallel."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"1. the leader of the N machines tells a random worker machine announce its median to its rest of the workers 2. all fellow workers machines replies with how many numbers are strictly bigger than the number broadcasted  3-a if the sum of the numbers that workers replied is 500M, then you have the answer! 3-b if the sum of the numbers that workers replied with is more than 500M, then Leader tells everyone to disregard anything less than the broadcasted number, then recurse 3-c if the sum of the numbers, call it K, that workers replied with is less than 500M, then Leader will look for the Kth number, then recurse"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I assume that there is a leader machine and N machine  1. each machine, except the leader, receive N chunks of data 2. each machine sorts its own list in O(nlog(n)) 3. each machine sends its minimum value along with its ID to the leader machine. 4. The leader machine stores these pairs of values and IDs in a heap. 5. The leader machine is idle until all the N machines send their values. 6. The leader machine removes the minimum value from its heap. eg. (v_i, id_i) 7. The leader machine sends a message to the machine id_i asking for another minimum value and waits for the respond.  8. the leader performs step 6 and 7 for 500 million times. 9. the medium would be the next minimum value in the leader's heap.  Note that the heap data structure should be thread safe!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"- Split list into 1/N chunks.  - Send a 1/N chunk to each of the N machines.  - Do a local sort on each machine. - Merge sorted lists across N machines until you you hit value 500 million. That is your median"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think kg's algorithm is called the \"median of medians\" algorithm if I'm not mistaken. Link: en.wikipedia.org/wiki/Selection_algorithm#Linear_general_selection_algorithm_-_Median_of_Medians_algorithm"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"123"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"With MapReduce:- Divide them in N chunks, Now each chunk has a associated replication just for HA, Now map each num as key and value as the number of the key. Nw when they move out of Map to reduce they are sorted. Once done, write the key to context which comes at 500 million position."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-4","title":"Map-Reduce?)))"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5261732222074880","download_status":"DOWNLOAD_DONE","votes":"5","answersCount":"22","title":"how to merge two binary search tree into  balanced binary search tree.. Let there be m elements in first tree and n elements in the other tree. Your merge function should take O(m+n) time with in constant space.  Examples:    A Balanced BST 1      90    /  \\   70    110     A Balanced BST  2        60     /  \\    5    800   output :-->                              70        /            \\                  60            90                 /                    \\                5   800","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"This can be done in 3 steps: 1. covert the BSTs to sorted linked list (this can be done in place with O(m+n) time) 2. Merge this two sorted linked lists to a single list (this can be done in place with O(m+n) time) 3. Convert sorted linked list to balanced BST (this can be done in place with O(m+n) time)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"output :-->            \n                     70 \n         /   \\ \n                   60     90 \n                  /         \\ \n                 5           800"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sorry , output tree is not clear in que due to error in que box."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The output here is missing 110. The output should be: 90 (60 (5)(70)) (110 () (800)).  Looks like a tree rotation problem to handle balancing, just as in AVL trees."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a solution with time complexity of O((m + n)*log min(n,m)) and constant space complexity. If min(m,n) << m+n, we might say that this is O(m+n). If someone can optimize this to get an O(m+n) solution (without the log min(n,m)) with constant space, I would be curious to hear the solution. The assumption here is that since the question requires using no extra space, we need to modify the existing trees to derive our merged tree. We use the algorithm in a recursive fashion to arrive at our final merged tree :- 1. First traverse all the elements to find the center element of the m+n elements. So, if this were an m+n sized array, we would be looking for the (m+n/2)th element if m+n is odd OR the ((m+n)/2 + 1)th element if m+n is even. This is because if there are even number of elements, the balance binary trees right subtree would have one element less than the left subtree. This is our first (m+n)th traversal while tracking time complexity and thus far we have not used any extra space. 2. Next choose the bst which contains the the element that we found in step 1, and modify it so that this element becomes the root. Again, we use no extra space, and this is an O(n) or O(m) time complexity operation.  3. Now add a node to the other tree with the same value as the root of the other tree, and modify this tree to make this node the root node. Again an O(m) or O(n) operation in terms of time complexity, and one node extra in terms of space complexity. 4. Now choose the tree with fewer nodes, and free the root node, after holding pointers/references to the left and right subtrees - Let us call the resultant trees from this operation the left main bst and right main bst. 5. (recursion)  a. final_root = root b. merge left main bst with the left subtee of the other tree c. merge right main bst with the right subtree of the other tree 6.  if (final_root != null)  a. final_root->left = root of left merge b. final_root->right = root of right merge else return final_root"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":". convert bst to linkedlist merge 2 sorted lists convert list to bst  // use morris trasversal. and in-place.. and but won't be O(m+n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1)Get a sorted linked list out of the two trees.    a) Create first sorted list by Inorder traversal on first tree    b) Create Second sorted list by Inorder traversal on first tree    c) Merge two sorted list. Or    a) Inorder traversal of both trees together to create single sorted merged list.(Do inorder on first and second, stop first till the time second is smaller and viceversa) Complexity: O(m+n) 2)Build balanced binary tree out of sorted linked list.  Complexity: O(m+n) Hint: Middle element is root of balanced btree"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Convert two trees in DoubleyLinkedlist using inorder traversal then merge them thus you will have a sorted list now make a tree out of it using recursive procedure using divide and conquer will result in a balanced binary search tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Find min in left subtree(call this modified subtree T1), Find max in right subtree(T2) Make T1 the left child of T2  Note: since the input trees are already balanced, the generated tree should also be balanced, similar trick is used in splay trees"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Balance Tree 1 using rotations. I believe this is O(log n) if doing log n rotations and each rotation is constant time. Insert nodes of Tree 2 in a preorder fashion into Tree 1. O(m) to traverse + O(log n) to insert."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Remove each element from BST-2 and add it to BST-1. So the space which was being used for BST-2 is free now. 2) Remove each element from BST-1 and make a balanced tree (Red-Black/AVL) out of it.   In this way extra space won't be utilized. The space will be utilized only after making that space free from the other tree.  Time Complexity = O(log(m+n))  Please give suggestions."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/**       Tree1:  90           /   \\              70   110                Tree2:   60           /    \\          5   800             Balanced Tree3:                          70                     /     \\           5     110            \\     /     \\            60 90   800   */ Java language solution of this problem is given below:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5912840674213888","download_status":"DOWNLOAD_DONE","votes":"8","answersCount":"37","title":"Consider a hash table with M slots. Suppose hash value is uniformly distributed between 1 to M, and it uses linked list to handle conflicts (if two keys hashed to the same slot). Suppose we put N keys into this M-slotted hash table, what is the probability that there will be a slot with i elements? i could vary from 0 to N.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Why not to consider this as Bernoulli trial, where: 1/M - probability of single success (that a value goes to a single slot) i - expected numbers of success (the success = the value goes exactly to the same slot) N - numbers of tries 1 - 1/M - a probability of failure:  So then having a Bernoulli trial formula where (N i) stands for  binomial coefficient:  P(i)=(N i) * (1/M)^i * (1 - 1/M) ^(N - i)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Base case, i=0. Probability of an element hashing in a slot = 1/M Probability of an element not hashing in a particular slot (ending in remaining M-1 slots) = (M-1)/M All N elements not hashing in that slot = (M-1)/M * (M-1)/M * (M-1)/M ...      = ((M-1)/M)^N  Let us take the case of i=1. First element can hash at any possible slot, probability = 1. Now, probability of remaining N-1 elements not hashing in that particular slot = ((M-1)/M)^(N-1)   Let us take the case of i=2. First element can hash at any possible slot, probability = 1. Probability of second element going into same slot = 1/M Now, probability of remaining N-2 elements not hashing in that particular slot = ((M-1)/M)^(N-2) Probability of a slot having 2 elements = (1/M)*((M-1)/M)^(N-2)  To make it generic:  P(i) = ((M-1)/M)^N,    when i=0 P(i) = (1/M)^(i-1) * ((M-1)/M)^N,  otherwise"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Hint: Inclusion-Exclusion Principle"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"(1/M)^i (M-1/M)^(N-i)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is statistics math problem.  I would think it this way.   (1)P(there is one slot with i elements) = 1- P(there is no slot with i elements)  (2)P(there is no slot with i elements) = P(the first slot does not have i elements)*P(the second slot does not have i elements)*...*P(the last slot does not have i elements)  Because the probability of any slot does not have i elements is the same, we get   (2*) P(there is no slot with i elements) = P(a slot does not have i elements)^N  (3) P(a slot does not have i elements) = 1- P(a slot has i elements)  (4) P(a slot has i elements) = [(1/N)^i] * [(1-1/N)^(N-i)]  Use (1), (2*), (3), (4) to solve the problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how about this:  (c(N,i)*(M-1)^N-i)/M^N"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The probability of an element being in one slot = 1/M Consider i=2, probability that there will be a slot with i elements? will be 1/M*1/M  Since 1 \n   \n    \n   -  \n     Cloudster \n     on August 14, 2013 Edit | Flag  \n    \n    \n   Reply"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"# of ways to drop N samples into M slots = M^N (denote this as denominator). binding i samples together, dropping the bundle into one of M slots, and dropping the other samples into the remaining M-1 slots, the number of ways to do this = C(N, i) * M * (M-1) ^ (N-i) (denote this as numerator). The probability is therefore numerator / denominator."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The probability that a particular slot has i elements = (1/M)^i * ((M-1)/M)^(N-i) No. of ways that slot can be chosen = C(M,1) = M Therefore probability that a slot has i elements = M * (1/M)^i * ((M-1)/M)^(N-i)  Note: There would be no C(N,i) because we do not get to choose which i elements go to that slot. It is already pre-decided by the hash function."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Probability of an event = No of occurences of an event / All possible event occurences   Total No of ways to put N objects in M slots = M^N Total No of ways such that there is a slot with i objects = No of ways to put i objects in a slot * no of ways to put N-i objects in M-1 slots   No of ways to put i objects in 'a' slot = choose a slot * choose i objects * 1^i (since there is a singel way to put i objects into a single chosen slot)  No of ways to put i objects in 'a' slot = MC1 * NCi * 1 No of ways to put N-i objects in M-1 slots = (M-1) ^ (N-i)  Probability = MC1 * NCi * (M-1)^(N-i)    / (M^N)   but I am worried about how to eliminate the duplicates."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Let any one of m slots contains exactly i element and remaining n-i elements distributed among rest (m-i) slots =  C(m,1)*C(n,i)*((1/m)^i)*((1-1/m)^n-1)         ..1  But above formula counts multiple time if there can be more than 1 slot with i elements. Probability that more than 1 slot with i element =  Summation over k = 2 to [n/i], (k-1)*C(m, k)*C(n, k*i)* C(k*i, i)*C((k-1)*i, i)*...C(i,i) *((1/m)^k*i)*((1-1/m)^(n-k*i))   ..2  Substract ..2 from ..1, we get the answer: C(m,1)*C(n,i)*((1/m)^i)*((1-1/m)^n-1) -  Summation over k = 2 to [n/i], (k-1)*C(m, k)*C(n, k*i)* C(k*i, i)*C((k-1)*i, i)*...C(i,i) *((1/m)^k*i)*((1-1/m)^(n-k*i))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This follows the binomial distribution with parameters (N, 1/M) and so P(X = i) =  N Ci (1/M)^i(M-1/M)N-i. This is because all M slots were equally probable. If the probabilities of falling into a slot varies, that would be a multinomial distribution(with different probabilities for individual trial for each slot)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My attempt, feels right but probably wrong.  What is the probability that there will be at least 1 of m slots with (exactly) k elements in a hash table with n inserted elements.  Assuming k < n.  Total ways to bucket n elements into m slots = m^n  Pr [ the first slot has exactly k elements ] = = [number of ways n-k elements are in one of the other m - 1 buckets (which effectively enforces that k elements are in the first bucket)] / [number of ways n elements are in m slots] = (m-1)^(n-k) / (m^n)  Pr [ exactly 0 slots have exactly k elements] = product over i=1...m of Pr [ith slot does not have k elements] = product over i=1...m {1 - Pr [ith slot has exactly k elements]} = {1 - [(m-1)^(n-k) / m^n]}^m  Pr [ > 0 slots have exactly k elements] = 1 - Pr [ 0 slots have exactly k elements] = 1 - {1 - [(m-1)^(n-k) / m^n]}^m"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Pr(\"there exist a slot with exactly i items\") = newtonSymbol(N,i) * M * (M-1)^(N-i) / M^N"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a problem of poisson approximation to the binomial distribution.  Total number of keys = N In an average if two keys hash to the same bucket, then N = 2M  P(i) ==> Probability that i keys collide  P(i) = e ^ (-lambda) * (lamda^i) / i!  where lambda = np  where n = total number of keys = 2M where p = probability that a bucket is chosen = 1/M  therefore lambda = 2. Hence p(i) = e^-2 * (2^i)/i!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"A typo in my above anwser:  (2*) P(there is no slot with i elements) = P(a slot does not have i elements)^M  (4) P(a slot has i elements) = [(1/M)^i] * [(1-1/M)^(N-i)]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Probability of 1 slot having i elements P(1)="}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=24532662","download_status":"DOWNLOAD_DONE","votes":"13","answersCount":"51","title":"You are given two array, first array contain integer which represent heights of persons and second array contain how many persons in front of him are standing who are greater than him in term of height and forming a queue. Ex A: 3 2 1 B: 0 1 1 It means in front of person of height 3 there is no person standing, person of height 2 there is one person in front of him who has greater height then he, similar to person of height 1. Your task to arrange them Ouput should be. 3 1 2 Here - 3 is at front, 1 has 3 in front ,2 has 1 and 3 in front.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"Though I like the idea of sorting using the comparator as mentioned above by amitb2108 but below is the approach that came to my mind first. lets say height[] = {3,1,2,4}                  pos[] = {0,2,1,0}; //no of persons greater height than him 1. create an array of person struct of size n and fill the data from the above two arrays     struct person    {   int height;        int num;    }; 2. Sort the person array with height as the key in decreasing order. o(nlgn)     index          0,1,2,3                      person[] = {4,3,2,1}                      {0,0,1,2} //person.num 3. Remember the index of array represents the no of persons greater in front of the current index. e.g. person with height 3 has array index 1, so 1 person is in front of him with greater height. But we need to have 0 no of person greater than 3, so swap it with index 0.  person[] = {3,4,2,1} //after swapping 3 //2 has only one person in front but index of 2 is 2 currently there are 2 persons //swap it with index 1 person[] = {3,2,4,1} //1 has only 2 persons in front but index of 1 is 3, so currently there are 3 persons //swap it with index 2 person[] = {3,2,1,4} the idea is, previous index, has a person with greater height than current index. The previous index person's position is already set. Now if we move this previous index person towards right it doesn't impact the position of this person. e.g. person with height 4, if we move this person towards the right, still the no of persons with greater height will be 0. Total complexity = o(nlogn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"This can be solved using rope data structure. It's like a binary tree except that each node maintains the number of nodes in the left subtree+1 for itself. Whenever a new number is inserted, if the value is smaller than the node's number it goes to the left otherwise right. When it goes to the right, the value of the node is decreased by the value of the branch node. Ex   Nodes: 6 5 4 3 2 1 values:  0 0 0 2 2 4 1. Make 6 as the root of the tree, its value = 1; 2. Insert 5. Value of 5(0) < value of 6(1) so it goes to the left. New value of 6 = 2, value of 5=1; 3. Insert 4, value of 4 < value of 6 so goes to the left; again goes to the left of 5. New values of 4 = 1, value of 5 = 2, value of 6 = 3 4. Insert 3, goes to the left of 6 but to the right of 5. New values 6 = 4, value of 3 = 1, rest unchanged 5. Insert 2, goes to the left of 6, right of 5 (value of 2 is decreased by value of 5 so its now 0), left of 3. New values of 3 = 2, value of 2 = 1, value of 6 = 5 6. Insert 1, goes to the left of 6, right of 5, right of 3. Do an in-order traversal of tree. It is imperative to insert the nodes in decreasing order"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"sort the person by the height if the count is not zero, swap the person on the right who is higher until the count become zero  time: O(n^2)  example 1  235461 020004  sort  123456 402000  swap 1  234516 020000  swap 3  245316 000000  example 2  3 1 2 4 0 2 1 0  sort   1 2 3 4 2 1 0 0  swap 1  2 3 1 4 1 0 0 0  swap 2  3 2 1 4 0 0 0 0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can sort the list of persons (person: height,numTallBeforePerson) using the following comparator:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is my code and this code  can be used in any amount of integers in an array  public class class2 { public static void main(String args[]){  int arr1[]={3,5,1,6,7};  int arr2[]={0,1,1,2,3};  for(int i=0;i  for(int j=i+1;j   if(arr1[i]    int n=0;     n=arr1[i];     arr1[i]=arr1[j];     arr1[j]=n;    }   }  }    int arr3[]=new int[arr1.length];  int k=1;  while(k<=arr3.length){        arr3[arr3.length-k]=arr1[arr2[arr3.length-k]];      arr1[arr2[arr3.length-k]]=0;      for(int i=0;i      if(arr1[i]==0){        for(int j=i;j        arr1[j]=arr1[j+1];        }        arr1[arr1.length-k]=0;        break;       }      }      k++;  }     for(int s=0;s     System.out.println(arr3[s]);     } } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Backtrack.  Let's say the first  array is height array and the second is count array. Sort the count array from low to high (say [0,1,1]). Start from the first height 3 (corresponding to count 0), the root node of the backtrack tree is (3), then insert the second height 2, generating one child node (3,2). Then insert the third height 1, generating one child node (3,1,2). If a node does not generate any child node, then it is an dead end. In this case, backtrack to the upper level node to visit its next child node.  This way you can find all possible sequences satisfying the two arrays. And you can confidently know if there is no such sequence at all."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My algorithm: Time -- O (N LOG N) & Space --O(N) .. please let me know your comments... it seems to work for all cases, let me know if I am missing something...  Approach:  (1) Sort the input in descending order of size -- O(N LOG N) (2) Use a stack based approach -- O(N) : (find below)  Given:   A[] = {1,2,3,4,5} b[]=  {3,1,1,1,0}  Step 1: Sort A (and hence B) -->  A[] = {5,4,3,2,1}  B= {0,1,1,1,3} // Here, this is still O(N.LOG N)  Step 2: Stack based algorithm (Say have 2 stacks: S1->stack.new, S2->stack.new)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"all persons height are unique how about persons with the same height."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int main (int arc, char * argv[]) {   int arrHeight[] = {3,2,1};   int arrKeyGiven[] = {0, 1, 1};      int i, j, temp = 0, length = 0;    length = 3;//4;     /** LOGIC FOR RESETING THE POSITION ACCORING TO THE KEY GIVEN       if Current position < keyPostion then          : do one swap with teh previous one :)       else          : do one swap with the next one :)   **/    for (i = 0; i < length; i++)   {     if ( arrKeyGiven[i] < i)     {        temp = arrHeight[i];       arrHeight[i] = arrHeight[i-1];       arrHeight[i-1] = temp;     }   }   printf(\"REPOSITIONED ARRAY IS \\n\");   for (i = 0; i < length; i ++)      printf(\"%d\\t\", arrHeight[i]);    return 0;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"THIS IS THE MODIFIED LOGIC:----- WORKS WELLL :) please have one try by assigning some logically correct values to arrHeight, and arrKeyGiven and see the result...if any issues plz revert to jitu059@gmail.com U need to edit, arrHeight/arrKeyGiven and length to test more problems ################################# int main (int arc, char * argv[]) {   int arrHeight[] = {3,1,2};   int arrKeyGiven[] = {0, 2, 1};    int i, j, temp = 0, length = 0;    length = 3;//4;     /** LOGIC FOR RESETING THE POSITION ACCORING TO THE KEY GIVEN       if keyPosition < Current Position then          : do one swap with teh previous one :)       else if keyPosition > Current Position then          : do one swap with the next one :)       else : DO NOTHING......current position is desired one :)   **/    for (i = 0; i < length; i++)   {     if ( arrKeyGiven[i] < i)     { printf(\"Swaping in process\\n\");       temp = arrHeight[i];       arrHeight[i] = arrHeight[i-1];       arrHeight[i-1] = temp;     }     else if( arrKeyGiven[i] > i)     {       temp = arrHeight[i];       arrHeight[i] = arrHeight[i+1];       arrHeight[i+1] = temp;     }   }   printf(\"REPOSITIONED ARRAY IS \\n\");   for (i = 0; i < length; i ++)      printf(\"%d\\t\", arrHeight[i]);    return 0;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Given  Hight Arrays H[], Queue Arrays Q[], Return Output O[] 1. Sort H in desc order as H' 2.Loop  while N--;   pick Q[N] th element of H' as O[N];   adjuct H' // remove H'[Q[N]] in H'"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Isn't the question incorrect: if the heights are 3,2,1 in some height-units, shouldn't the array be 0,1,2 - representing no one in front of 3, 1 guy in front of 2 and 2 guys in front of 1. Or maybe i am missing something that rest everyone is not - pls enlighten"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I found that the max element is at the rightmost position(call pos) whose value is zero in the array b, so everytime I insert the max element of the remaining elements, and all the elements on the right of pos in b should decrement by one, because one max element is eliminated on the left, and carry on untill no elements left in a, and here is my code:(O(n^2), I think my algorithm supports duplicate heights)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about next idea. The last element of second array - let call it array of inversions in following, is always that we have in desc order. For example. 3 2 1. 2  0 1 1 - is element with index 1 in desc order. so it must be placed the in that way: * * 2 0 1 * so 1 - is element with 1 index in desc order without 2. it must be placed there * 1 2  and following  3 1 2  We process array from right to left. element i must be placed with element from first array without already processed element in desc order."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use an order stastisc tree: - Insert all the heights into an order statistic tree - for i from B.length -1 to 0:  - what is the B[i] order statistic value in the order statistic tree  - remove that value from the tree and insert it into the results array at i  Time is nlogn (n queries for order statistics) Space is n (order statistic tree size)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Another O(n logn) time and O(n) space solution. Please correct me if there are issues."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"One solution: Every time, select the smallest number with front[] = 0.  e.g. height[] = {3, 1, 2, 4}, front[] = {0, 2, 1, 0} 1) Find the smallest number from height[] that has 0 in front[], in this case it is 3, then 3 is 1st element in the queue.  2) For rest of the elements i in height[], if it is smaller than 3, then front[i] - 1, otherwise keep front[i] the same.  Go back to 1)   This is pretty much like topological sorting; each time remove the node with indegree == 0."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Observe that in any arrangement of heights, the smallest element can have one and only one spot to go.  eg.  { 3, 1, 2, 4 } {1, 2, 2, 0}  1 is the smallest element and needs to have 2 elements ahead of it. All other elements are larger, so it must only be able to go into ar[2]. After placing 1 in ar[2], count 2 empty spaces, skip 2 because it's taken and place 2 into ar[3]. 3 needs 1 empty space and goes into ar[1] and 4 into ar[0].  Fail if there are no available spots. Collisions or cases like  { 3, 1, 2, 4, 1 } {1, 2, 2, 0, 2}  are handled elegantly by the space counting.  Unoptimized this is O(n^2)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a python code that runs in O(n logn) time. If you use some sorting algorithm, say radix sort, that runs in O(n) time, then this algorithm will take O(n) time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Consider line[] array where people have to be placed.   Assumption : all people have distinct height from 0 to N-1. so sort A and hence B array (along with A) in increasing order.  Now A=[0,1,2,3,4...].  So, now we can ignore A[] and only consider B[] ans array where B[i] is = number of people with greater height in front that person of height i.  Now, in line[], 0th person will be at index B[0] since there are exactly B[0] person > than 0th person. For second largest person if B[1] < B[0] 1 ahead of 0th person in line[]. else after 0th person. Eg   if B=[3,2,....] line = [--10-------]   - is space to be taken by others.   0th person took 4th free seat. 1st took 3rd free  if B=[3,3,....] line = [---01------]    => 0th person took 4th free seat. 1st took 4th free seat, after 0 took its seat. so 1 basically took 5th seat  notice how 1 after 0 in line.  So basically you have a set of free seats and each person comes and takes whatever is left.  So Algo : put 0th person at index B[0] in line[]. remove B[0] index from line[] from free seat list. next for ith person, traverse whatever free spaces are left in line[] from index 0 and place them there. pseudo code :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My take on this  1. we need to arrange the numbers based on the index difference given {3,2,1}->{0,1,1} means {3} has none taller in front, {2} has 1 taller, {1} has 1 taller so {3}>{1}>{2} or (3 greater than 1 greater than 2)  2. {5,4,3,2,1}->{0,0,0,0,0} means {5} has none taller in front, {4} has none taller in front, {3} has none taller in front, ... so {1}>{2}>{3}>{4}>{5}  3. {5,4,3,2,1}->{0,1,2,3,4} means {5}>{4}>{3}>{2}>{1}  4. looking at the options above we can easily build an iteration to move the person to the index on the second array, taken the example {3,2,1}->{0,1,1}, steps are -move {3} to position 0 - nothing to do -move {2} to position 1 - nothing to do -move {1} to position 1 - move {1} to position 1, {2} will need to move 1 position down  algorithm is quite simple"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Variant of tree travel/shortest path/bfs. with number of element in front as level. and on each level shortest first. or just sort the elements by value and then stable sort on number of elements greater"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution is in O(2n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"C++"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class person {   \n    int h; \n    int r; \n    public person(int h1, int r1) { \n        h = h1; \n        r = r1; \n    } \n     \n    public int getH() { return h;} \n    public int getR() { return r;} \n } \n \n \npublic static void arrangHeight(int height[], int rank[]) { \n     \n    ArrayList  p = new ArrayList  (); \n    int i; \n    int n = height.length; \n    for(i = 0; i < n; i++) { \n        person p1 = new person(height[i], rank[i]); \n        p.add(p1); \n    } \n     \n    Collections.sort(p, new comparator() { \n        public int compare(person p1, person p2) { \n            return p2.getH - p1.getH; \n        } \n    }); \n     \n  //  height[] = {3,1,2,4}  \n  //  pos[] = {0,2,1,0} \n  // op -> [4, 3, 2, 1] \n  // op    [0, 0, 1, 2] \n   \n  ArrayList  out = new ArrayList(); \n  out.add(p.get(0).getH()); \n  for (i = 1; i < n; i++) { \n      person p1 = p.get(i); \n      int pos = p1.getR(); \n      out.add(pos, p1.getH()); \n  } \n  System.out.println(out); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n^2) 1. sort persons by height and num greater before 2. find place for each person (from short to high)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n^2) 1. sort persons by height and num greater before 2. find place for each person (from short to high)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think an elegant solution to this problem would be to sort the array of heights and also put array B in that order O(nlogn)    Make another array of size n as our position array. Then get the element of the smallest height and see how many people are in front of him and place him into the index of that our position array.  Keep taking the next smallest element with x people in front of him.  Start from the beginning of the array and count x non filled spaces in the array and place it there.    This is because the non filled spaces in the array will have height greater than that of our element while the filled spaces will have height less than our element so we can ignore those elements.  So our overall complexity is O(nlogn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have a very simple O(nlogn) solution I'm finding difficult to explain  Calculate a prefix big enough so that it's bigger than every other number prefix = pow(10, ciel(log10(n)) + 1))  now create an array where each cell's value is height + prefix * number_heigher_infront  Now, sort the new array ascending and remove from each number (prefix * number_heigher_infront)  Voila!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution in C++. The list of (Heights, Count of people in front) is sorted based on the height. Then each person is added - in order - at the position given by the count of people in front of him. We maintain a \"jump\" table at each step in order to jump over position occupied by a smaller person. The algorithm time complexity is O(n log n). Reviews are welcome :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I get a O(N^3) algorithm. The idea is just search all possible arrangements, upon number of taller violation, backtrack."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=24423662","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"28","title":"/*  Random set of WORD.  Criterion : Given a word find out if the word can be broken into smaller word, by removing one alphabet at a time.  a) all such word should be valid dictionary word.( Assume a function is there to test whether the word exist in dictionary) b) Remove one alphabet at a time but the new word need to be in dictionary.  For eg : restated -> restate -> estate -> state -> stat -> sat -> at -> a fullfill the criterion. ( single alphabet assume belong to dict) My solution below. I assume it can be done using dynamic programming or trie data structure */","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"public boolean isCriteriaSuccess( String s1) {    System.err.println( \" Calling  \"+s1);    if ( s1 == null) return false;    if ( s1.length() == 1 ) return true;    if ( !inDict(s1)) return false;    System.err.println( \" Calling recursively \"+s1);    boolean retValue = false;    int strLength = s1.length();    for ( int i = 0;i < strLength ;i++) {         retValue = retValue || (isCriteriaSuccess(s1.substring(0,i)+s1.substring(i+1,strLength)));            }    return retValue;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"If the number of query words is large and dictionary is static, here is what I propose:   Preprocessing:  Create a graph of all the dictionary words. Each word will get a node and there will be an edge between 2 nodes (or words) if one of the words is only one alphabet lesser than the other word. This should take O(M^2) time, but for practical purpose we can assume the number of words in dictionary are constant, so it could be assumed as a constant time preprocessing operation. (Note that M is the number of dictionary words)  Now to search if a word can be broken down to smaller words (until the word becomes null) do this: 1. Find the word in the graph. Let this node is called N(word). This step takes O(M) time where M is the number of dictionary words. 2. Do a depth first or breadth first traversal starting at N(word). You can stop traversing when you find a node with length zero and return True. (You'll only to traverse at most lengthOf(word) deep nodes from N(word)). If you couldn't reach a node with length 0, return False. If L is the length of the query word, this step will take O(L*L) worst case time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Yes it can be done using dynamic programming. The problem here is not to check whether the word is in the dictionary or not. The problem is used to determine whether by taking out one alphabet at a time the remaining word is in the dictionary or not. Now this can be easily done by using dynamic programming or recursion. Here is the idea"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just wanted to understand one thing. Isn't the requirement of the problem to check if each word formed by removal of a character is a word again? i.e say ABCDxPQRS is a word. Then we need to confirm whether ABCDPQRS is a word or not? Similarly for other removals. Right?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"dict = ['restated','restate','estate','state','stat','sat','at','a'] \n \ndef removeWords(string): \n    l=[] \n    for i in range(len(string)): \n        ns = string[0:i]+string[i+1:] \n        if ns in dict: \n            l = l +[ns] \n    return l \n \n \nq = removeWords('restate') \nsize = len('restate')-1 \nflag = 0 \nwhile len(q)>0 and size > 1: \n    qnew = [] \n    for a in q: \n        qnew = qnew + removeWords(a) \n    size = size -1 \n    if len(qnew)==0: \n        flag = 1 \n        break; \n    else: \n        q = qnew \n \n \nif flag=0 and size==1: \n    print true"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use dfs"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Arrays; import java.util.List;  public class strCriteria {     public static void main(String args[])     {         String a=\"restat\";         System.out.println(check(a,0,a.length()));     }     public static boolean findWord(String a)     {         List st = Arrays.asList(\"restated\",\"restate\",\"estate\",\"state\",\"stat\",\"tat\",\"at\",\"a\");         if(st.contains(a))             return true;         return false;     }     public static boolean check(String a,int beg,int end)     {         if(beg>=end)             return true;         if(findWord(a.substring(beg, end)))             return check(a,beg+1,end) || check(a,beg,end-1);         return false;     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  using namespace std;  int main(void) {     char a[] = \"restated\";     unsigned int i, j;     char window[100];     vector validWord; // will contains the vaid dictionary words      for(i = 1; i < strlen(a); i++)     {         for(j = 0; j <= strlen(a) - i; j++)         {             memcpy(window, a + j, i);             window[i] = 0;             if(IsInDictionary(window))                 validWord.push_back(&window[i]);         }     }     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.HashSet; \n \n \npublic class RandomWord { \n \n    public static void main(String[] args){ \n \n        String str = \"restated\"; \n        System.out.print(checkword(str)); \n \n \n \n    } \n    public static boolean checkword(String str){ \n \n        if(str.length()==1) \n            return true; \n \n        for(int i=0;i wordSet = new HashSet<>(); \n        wordSet.add(\"restate\"); \n        wordSet.add(\"estate\"); \n        wordSet.add(\"state\"); \n        wordSet.add(\"stte\"); \n        wordSet.add(\"stat\"); \n        wordSet.add(\"sat\"); \n        wordSet.add(\"at\"); \n        wordSet.add(\"a\"); \n \n        return wordSet.contains(str); \n \n \n    } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java Implementation of remove word using dynamic programming..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This can be done using DP  The recursion looks something like this: Keep an index to the first and last char of the string say, beg and end  Now in every function call recurse using these two calls func(str, beg, end-1) and func(str, beg+1, end) , if beg==end return  int getSubWords(String str, int beg, int end) {  if(beg == end) {   return isWord(str.charAt(beg)) ;  }   return( isWord(str.substr(beg, end +1) + getSubWords(str, beg+1, end) + getSubstr(str, beg, end-1))); } This can be converted into DP by using a 2d memo array for keeping a count of the number of words found."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"If I understand problem correctly, \"sat\" should not be the correct sub word of \"restated\"."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=23806685","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"29","title":"We have two strings: a normal alphanumeric string and a pattern string. the pattern string can be composed by alphanumeric chars plus the char \"?\" and \"*\"  We want to check if the first string match the pattern, where the ? means that every char (alphanumeric) is permitted in that position, while * allows to have a sequence of alphanumeric chars.   as test we want to check that the function returns true to the following calls.  isMatching(\"abab\",\"abab\") isMatching(\"abab\",\"a**b\") isMatching(\"ababab\",\"ab*b\") isMatching(\"\",\"*\") isMatching(\"aaaaaab\",\"*?*b\")  i found this question hard, since the language we want to parse is not L1 (there's an ambiguity in the parsing tree) it means that a backtrack modality must be implemented.  Took me a while to find a reasonable solution (that, to be honest i was not happy with)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"You can solve this recursively.  Let isMatching(i,j) denote the indices of the string and the pattern respectively (returns true or false). Basically, we'll start from the indices (0,0) of the string and the pattern and if we are able to reach (lengthOfS,lengthOfP) it means that we've successfully matched the string and the pattern(returns 1 in this case and 0 otherwise).  If the current character of the pattern is not a special character - '?' or '*' then we have the following cases: 1) It is equal to the character of the string 2) It is not equal to the character of the string In case of (1) we can simply go ahead and check with the next character, i.e we must match isMatching(i+1,j+1). In case (2) we must return zero.  If the current character of the pattern is a '*', then it means we can match the current character of the string or  we can move ahead with the next character of the pattern,i.e  isMatching(i,j) = isMatching(i+1,j) or isMatching(i+1,j+1)  If the current character of the pattern is a '?', then irrespective of the character of the string, we can move to the next character on both the pattern & the string. isMatching(i,j) = isMatching(i+1,j+1)  But implementing the above will lead to an exponential complexity owing to the repeated computation of the substructures. So we can memoize this recursion and hence an O(N*M) solution(space and time) is possible.  Python implementation with memoization"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"You can solve the problem using the dynamic programming technique. Construct the matrix match, where match[i][j]  is true iff the first i characters of a match the first j characters of b.  The recurrence relation is the following:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In python we can write in simple  in pattern * means is repeated zero or more times (allowing a pattern to repeat zero times means it does not need to appear at all to match).  and pattern ?  means the pattern appears zero or one time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"looks like it is a case of implementing a turing machine for language processing. You have states and events where events would be the character seen."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can also think of the first string being stored in a TST structure and use the second string to search whether a string with that pattern is found in the TST. The search for '?' is trivial for TST. The '*' needs a little bit logic where all characters are skipped over until after that character after '*'. So for example, isMatching(\"ababab\",\"ab*b\") . See 'a', then 'b', then see '*' and character after '*' is 'b', so skip over 'a' and see 'b' but then there is still \"ab\" remaining but the 2nd string already finish. So this is not a solution, back track one step and continue to skip over 'b', 'a', then see another 'b'. This would be the end of string 1 and string 2. Then this would return true."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I suppose that no interviewer is expecting a truly efficient regular expression matcher. One improvement to your approach is to mark the states we already processed. The search state can be described by the position i in the search string and position j in the pattern string from which we are trying to find the matching. This leads to a O(|S| * |P|) algorithm."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In below c++ code , for checking it you need to copy code and just run, without any change, In input you put simple string as first string and pattern for second string, then program give output true or false  code:  #include #include using namespace std;   bool check(string s1,string s2) {     int l1 =s1.length(),l2 = s2.length();     if(l1==0 && l2==0)     {         return true;     }     else if(l1==1 && l2==0)     {         return false;     }     else if(l1==0 && l2==1)     {         if((int)s2[0] > 96)         {             return false;         }         else         {             return true;         }     }     else if(l1==0 && l2>1)     {         if((int)s2[0] > 96)         {             return false;         }         else         {             return check(s1,s2.substr(1,l2));         }     }      if(l1==1 && l2==1)     {         if((int)s2[0] > 96)         {             if(s1[0]==s2[0])             {                 return true;             }             else             {                 return false;             }         }         else         {              return true;         }     }      int t = (int)s2[0];      if(t>96)     {        if(s1[0]==s2[0])        {            return check(s1.substr(1,l1), s2.substr(1,l2));        }        else        {            return false;        }     }     else if(t==42)     {        return (check(s1.substr(1,l1),s2) | check(s1, s2.substr(1,l2)));     }     else if(t==63)     {        return (check(s1,s2.substr(1,l2)) | check(s1.substr(1,l1), s2.substr(1,l2)));     }      return false; }    int main() {     //* = 42, ?=63     while(1)     {      string s1,s2;     cout<<\"Enter first string(Base):  \";     cin>>s1;     cout<<\"Enter second string(Pattern):  \";     cin>>s2;     int t=check(s1,s2);      if(t==1)      {          cout<<\"\\nOutput:  True\\n\\n\";      }      else      {          cout<<\"\\nOutput:  False\\n\\n\";      }     }     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool IsOnlyAsterisk(std::wstring Pat) \n{ \n    std::wstring::iterator Itr = Pat.end(); \n \n    for(Itr = Pat.begin(); \n         Itr != Pat.end() && *Itr == L'*';++Itr); \n \n    return (Itr == Pat.end()); \n} \n \n \nbool Match(std::wstring Str,std::wstring Pat) \n{ \n    if(Str.empty()) \n    { \n        return (Pat.empty() || IsOnlyAsterisk(Pat)); \n    } \n \n    if(Pat.empty()) \n    { \n        return (false); \n    } \n \n    if(Pat[0] == L'?') \n    { \n        return Match(Str.substr(1),Pat.substr(1)); \n    } \n \n    if(Pat[0] == L'*') \n    { \n        return (Match(Str.substr(1),Pat) || Match(Str.substr(1),Pat.substr(1)) || Match(Str,Pat.substr(1))); \n    } \n \n    return ((Pat[0] == Str[0]) &&  \n        Match(Str.substr(1),Pat.substr(1))); \n} \n \n \nint main() \n{ \n    bool Res = Match(L\"abcab\",L\"a*?*c*?*b*\"); \n \n    cout << Res << endl; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The best way to solve such a problem is to first build a DFA out of the expression. Then after eliminating obvious redundant states, you get the most efficient program that can match an input against the state. Of course for small expressions you can directly write a program by simply going back n forth in  the input to check for a match."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There are a number of backtracking quadratic solutions proposed, but it seems to me there is a linear solution with no backtracking.  I'll assume the pattern string starts and ends with an asterisk (we can easily reduce the general case to this, by first verifying that the start and end of the alphanumeric string disjointly match the portions of the pattern string before and after any asterisks, respectively, so as to only have to deal with the remaining portions of the pattern and alphanumeric strings).  Note that, conceptually, we might as well treat any repeated asterisks in the pattern string as just a single asterisk. Thus, the pattern string amounts to a sequence of specific texts (possibly with ?s in them, but this is no big deal to match against), separated by *s. That is, specific texts which must show up in a specific order, but no further constraints.  We can simply match this greedily, in linear time: run through the alphanumeric string looking for the first instance of the first text; once you've found that, keep running through the alphanumeric string from where you left off till you find the first instance of the second text; once you've found that, keep running through from where you left off till you find the first instance of the third text, etc. If you eventually find instances of every text, hooray, there's a match; if you hit the end of the alphanumeric string before doing so, boo (or hooray), there's no match."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Regular Expression matchers work in linear time. Since this problem uses simple RE, there is also a linear time solution. However, these algorithms are complex. I don't think any interviewer is expecting a candidate to be able to code this in an interview.  I don't think that simple approach works. Consider this example s: \"abcabdcd\" p: \"ab*d\" you'll greedily match the 'd' in the pattern with the first 'd' in the string, which is incorrect. even if you make a quick fix for this case, i think it still won't work in more complex cases where '*' shall skip several characters (not necessarily the first match)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think recursion if easy for understanding, but DP is butter, since I'm not good at DP, so just the recursion way, kind of time consuming."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool Match(const char *pat, const char *str) { \n  std::list curr, next; \n  curr.push_back(pat); \n  while (*str != '\\0') { \n    while (!curr.empty()) { \n      const char *i = curr.front(); \n      curr.pop_front(); \n      if (*i == *str || *i == '?') { \n        next.push_back(i + 1); \n      } else if (*i == '*') { \n        next.push_back(i); \n        curr.push_back(i + strspn(i, \"*\")); \n      } \n    } \n    if (next.empty()) return false; \n    curr.swap(next); \n    ++str; \n  } \n  for (const char *i : curr) { \n    if (strspn(i, \"*\") == strlen(i)) return true; \n  } \n  return false; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I took some time to make this. Seems to be working fine."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Modification of Knuth-Morris-Pratt String matching algorithm.  Time Complexity = O(m+n)  where m is the string length and n is the pattern length"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java Implementation of string matcher using dynamic programming..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \n#define FALSE 0 \n#define TRUE  1 \n \ntypedef unsigned char BOOL; \n \ntypedef struct { \n    char *input; \n    char *pattern; \n} test_case; \n \nBOOL regex_match(char *s, char *p) \n{ \n    if ((!s[0] && !p[0]) || \n        (!s[0] && p[0] == '*' && !p[1])) { \n        return TRUE; \n    } \n \n    if (p[0] == '?' || p[0] == s[0]) { \n        return regex_match(s+1, p+1);  \n    } \n \n    if (p[0] == '*') { \n        return regex_match(s, p+1) || // ignore the '*' completely \n               regex_match(s+1, p);   // '*' in pattern consumes s[0] \n    } \n \n    return FALSE; \n} \n \nint main() \n{ \n    int i; \n    test_case tc[] = { \n                        {\"abcd\",\"abdd\"}, \n                        {\"abcd\",\"abcd\"}, \n                        {\"abcd\",\"ab?d\"}, \n                        {\"\",\"?\"}, \n                        {\"ab\",\"?*\"}, \n                        {\"a\",\"\"}, \n                        {\"\",\"a*b\"}, \n                        {\"\",\"****\"}, \n                        {\"\",\"*c\"}, \n                        {\"\",\"\"}, \n                        {\"\",\"*\"}, \n                        {\"acfdfcdcdcd\",\"a*cd*cd\"}, \n                        {\"abdfpdcdcd\",\"ab*cd\"}, \n                        {\"abdfpdcdcd\",\"ab*\"}, \n                     }; \n \n    for (i=0; i"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=23823662","download_status":"DOWNLOAD_DONE","votes":"6","answersCount":"57","title":"Given an equation in the form 2^i * 3^j * 5^k * 7^l where i,j,k,l >=0 are integers.write a program to generate numbers from that equation in sorted order efficiently.  for example numbers from that equation will be in the order 2,3,5,6,7,8,9.....and so on..","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"13","title":"The key here is to use a heap (aka priority queue). Start with number 1 and add it to the heap. Then, do a loop a) Pop the minimum value from the heap b) Print this minimum c) Add minimum*2, *3, *5 and *7 to the heap  If we want N numbers, the complexity will be O(N log N). Note that since i,j,k,l >=0, the first number should be 1, not 2."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"11","title":"These are basically referred to as ugly numbers . Here is the code for it: a. Take variables for multiples of 2,3,5,7. b. Everytime find a minimum of the multiple. c. Store 1 in the first index as it is multiple of all. d. Find the minimum of all the multiples of 2,3,5,7. Whenever that minimum is equal to any of the multiples. Store that multiple in the indexes assigned for 2,3,5,7 and also multiply that element with the number to get the next higher multiple in next iteration."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"limit=10 \nprint \"looping for\", limit ,\"times\" \n \nnumlist = [\"0000\"] \n#----------------------------------------- \ndef generator(nlist,count): \n    for i in range(1,count): \n        nlist.append(str(i)+str(i-1)+str(i-1)+str(i-1)) \n        nlist.append(str(i-1)+str(i)+str(i-1)+str(i-1)) \n        nlist.append(str(i-1)+str(i-1)+str(i)+str(i-1)) \n        nlist.append(str(i)+str(i)+str(i-1)+str(i-1)) \n        nlist.append(str(i-1)+str(i-1)+str(i-1)+str(i)) \n        nlist.append(str(i-1)+str(i)+str(i)+str(i-1)) \n        nlist.append(str(i)+str(i)+str(i)+str(i-1)) \n        nlist.append(str(i-1)+str(i-1)+str(i)+str(i)) \n        nlist.append(str(i-1)+str(i)+str(i)+str(i)) \n        nlist.append(str(i)+str(i)+str(i)+str(i)) \n    #print numlist \n    #print count \n \n#----------------------------------------- \n     \ngenerator(numlist,limit) \n#print numlist \n \nfor item in numlist: \n    part = list(item) \n    #print part \n    calcOP = (2**int(part[0]))*(3**int(part[1]))*(5**int(part[2]))*(7**int(part[3])) \n    print calcOP"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"below numbers can't be generated using this formula  1. all PRIME numbers that are greater than 7 2: all numbers that are divisible by PRIME numbers greater than 7  numbers excluding from above two cases can be generated"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"so in this question  2^i * 3^j * 5^k * 7^l  should mean 2 to the power of i multiplied by 3 to the power of j and so on.. thus for i=1,j=1,k=1,l=1 shouldnt the first number be 2*3*5*7 = 210 ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For the heap solution, please use java's BigInteger since numbers will get bigger for higher exponents."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this should print out all the nos. whose only prime factors are 2,3,5 or 7. We will print out 1 by default. We should try to reduce a number to 1 by dividing it with different powers of 2,3,5 and 7. if the number reduces to 1 then print it out.  std::cout << 1 << \" \"; size_t n = 2;  void reduce( size_t& num, size_t divisor ) {  while( num % divisor == 0 )   num /= divisor; }  int main() {  std::cout << 1 << std::endl;  size_t num = 2;  while( true )  {   num = reduce( num, 2 );   num = reduce( num, 3 );   num = reduce( num, 5 );   num = reduce( num, 7 );   if( num == 1 )    std::cout << num << std::endl;   num++;  } }  complexity: O(N)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For anybody that is interested, this question is very, very similar (and requires a nearly identical solution) to question 7.7 in Cracking the Coding Interview 5th ed.  \"Design an algorithm to find the kth number such that the only prime factors are 3, 5, and 7.\""},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's a dynamic programming approach that I think does it in O(n) with a memory space of ~N."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My idea is same as Miguel Oliveira's, and the time complexity is O(nlogn), here is my code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Not going in to time complexity, this is how i wrote the program."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Any number that conforms to this formula is a number that is divisible by 2 or 3 or 5 or 7. So just loop over the integers and check if any is divisible by 2,3,5 or 7."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Solution{    public ArrayList sortedOrder(int len){          PriorityQueue qe = new PriorityQueue(2*len , Word.com );     ArrayList  res = new ArrayList ();     qe.add(new Word(2,2));     qe.add(new Word(3,3));     qe.add(new Word(5,5));     qe.add(new Word(7,7));     int k = 0;     while( k < len ){       k++;       Word t = qe.poll();       res.add(t.val);       switch( t.calss ){         case 2:           qe.add(new Word(2,2 * t.val));           qe.add(new Word(3,3* t.val));           qe.add(new Word(5,5* t.val));           qe.add(new Word(7,7* t.val));           break;                    case 3:           qe.add(new Word(3,3* t.val));           qe.add(new Word(5,5* t.val));           qe.add(new Word(7,7* t.val));           break;         case 5:                      qe.add(new Word(5,5* t.val));           qe.add(new Word(7,7* t.val));           break;         case 7:           qe.add(new Word(7,7* t.val));           break;       }     }     return res;   } }  public class Word{   int class;   int val;   public Word(int cla, int v)   {     class = cla;     val = v;   }      public static Comparator com = new Comparator(){     @override     public int compare(Word a , Word b){       if(a.val > b.val ) return 1;       if(a.val < b.val ) return -1;       return 0;     }   } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why dont we simply take a loop over numbers and for any no see whether it is divisible by the combination of the given number. if it is then it can be generated else not.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"think we should use four queues, initialy each queue has only one num 2,3,5,7,we name them q2,q3,q5and q7 then we compare the top of the four queues to get the min, and if min is from q2, then we add *2 to q2, and the *min to q3 q5andq7, if min is from q3, we only add *3 to q3 and the *min to q5 and q7, etc to avoid duplicates  for instance 2 2*2  3 3*2  5 5*2 7 7*2  then 3 is min so  2 2*2  3 3*2 3*3 5 5*2 5*3 7 7*2 7*3 then 4 from q2 is min so  2 2*2 4*2 3 3*2 3*3 3*4 5 5*2 5*3 5*4 7 7*2 7*3 7*4 etc"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Question is not clear. Can you please explain the intent with an example or \"Miguel Oliveira\"  can you please help with a pseudo code and a simulation around it please."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Meh, going to have to heap it after all. Coffee first, then code :(  vgeeks algorithm is the best I can come up with. Here it is in Python:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-5","title":"Rohit ke bachche tu yeh sawal kar paaya?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=23596662","download_status":"DOWNLOAD_DONE","votes":"-2","answersCount":"33","title":"Longest increasing subsequence:  Given n numbers A1..An determine subsequence of maximum length values in the subsequence form a strictly increasing sequence.  ex: input 5,2,6,3,4,1,9,9,8,9,5 output: 2,3,4,8,9","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"geeksforgeeks.org/construction-of-longest-monotonically-increasing-subsequence-n-log-n/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"subsequence doesn't necessarily mean consecutive numbers, right?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"A simple way of finding the longest increasing subsequence is to use the Longest Common Subsequence (Dynamic Programming) algorithm. 1. Make a sorted copy of the sequence A, denoted as B. O(nlog(n)) time. 2. Use Longest Common Subsequence on with A and B. O(n2) time.  Credit goes to"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"None of the solutions on this page appear to work for the case where the sequence is not contiguous. Here are 2 solutions to that problem. First a brute force 2^n solution that loops through the set of all subsequences."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"My solution might be similar to some others since this is a standard DP problem. Basically have 2 arrays: (1) max[i] stores the maximum number of elements in the longest subsequence ending with arr[i] (2) prev[i] stores the index of the previous element in the longest subsequence ending with arr[i]  So basically we just need to iterate through the array, update the 2 arrays above, and then keep traversing the \"prev\" array until we can't anymore."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"List longestSequence(List list){ \n  if(list == null  || list.size()==0) return null; \n \n  List longest = new LinkedList<>(); \n  List current = new LinkedList<>(); \n  int previous = 0; \n  for(int elem: list){ \n        if( current.size() == 0 || elem >= current.getLast()){ \n           current.add(elem); \n       } \n       else{ \n                 if(current.size() > longest.size() ){ \n                    longest = current;  \n                 } \n                    current = new LinkedList<>();    \n                    current.add(elem);              \n        } \n   } \n    if(current.size() > longest.size() ){ \n                    longest = current;  \n    } \n   return longest; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void subsequence(const int *list, int size) { \n  \n if (size == 0 || size == 1) \n  return; \n int *M = new int[size]; \n        int *Post = new int[size]; \n        for (int i=0; i=0; i--) { \n  int max = 0; \n                for (int j=i+1; j= list[i] && max < M[j]+1) { \n    max = M[j]+1; \n    Post[i] = j; \n    if (longest < max) { \n     longest = max; \n     front = i; \n                               } \n                      } \n               } \n          } \n \n          while(front != -1) { \n          cout <"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"/// @param a the array containing the numbers we are checking \n    /// @param indices[out] The indices(inclusive) the function will return \n    /// @return true if the finding is successful, false otherwise \n    bool find(const vector& a, pair& indies) \n    { \n        if (a.empty()) return false; \n \n        indies.first = 0; \n        indies.second = 0; \n        for (int i = 0, j = 0; j < a.size(); ++j) \n        { \n            if (a[j] > a[j - 1]) \n            { \n                if (j - i > indies.second - indies.first) \n                { \n                    indies.first = i; \n                    indies.second = j; \n                } \n            } \n            else \n            { \n                i = j; \n            } \n        } \n        return true; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"fill all a[i][j] for j = i +1  a[i][j] = a[i][k] && a[k][j]  for k -> i+i..j-1  travers matrix a from [0][n], searching for max(j-i) from the right, upper corner - go left from the right, upper corner - go down  if all false, go to next right-upper corner"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public static void findLongest(int[] array_) { \n    int start = 0; \n    int startIndex = 0; \n    int endIndex = 0; \n    for (int i = 0; i < array_.length-1; i++) { \n      if (array_[i] > array_[i+1]) {         \n        if (i - start > endIndex - startIndex) {         \n          startIndex = start; \n          endIndex = i; \n        } \n        start = i+1; \n      } \n    } \n     \n    System.out.println(\"array range is \" + array_[startIndex] + \" to \" + array_[endIndex]); \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Python Solution for Subsequence (non-contiguous)  Many of the solutions on this page are solving the trivial problem of contiguous runs in a list.  A subsequence can actually have gaps, which makes this a bit more challenging, but you can do it NlogN time.  My solution is actually N-squared, but the linear search can be fairly trivially converted to a binary search."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#include  #include  #include  #include  using namespace std;  int merge(__gnu_cxx::hash_map& map, int left, int right) {      int newMax = map[left] + map[right];      map[left] = newMax;      map[right] = newMax;      return newMax; }  int findLongestSequence(vector& a) {      int max = 0;      __gnu_cxx::hash_map map;       for (int i = 0; i < a.size(); i++)      {           if (map[a[i]]) continue;            map[a[i]] = 1;           // update the neighbours           if (map[(a[i]-1)]) //left neighbor           {                int retval = merge(map, a[i]-1, a[i]);                if (retval > max) max = retval;           }            if (map[a[i]+1]) // right neighbor           {                int retval = merge(map, a[i], a[i]+1);                if (retval > max) max = retval;           }      }      return max; }  int main()  {      vector b(5);      b[0] = 6;      b[1] = 55;      b[2] = 5;      b[3] = 4;      b[4] = 3;      b[5] = 99;       int ret = findLongestSequence(b);      cout << \"ret = \" << ret << endl;       //expect = 4   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"The possible reason that someone (not me) to down vote this one might be the wrong output. But anyway this is well-know problem \"Longest increasing subsequence\" you can google it. The complexity is O(nlogn). Beware it is not easy to make it right. This is mine version"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#include  \n#include  \n#include  \n  \nusing namespace std; \n  \n#define ARRAY_SIZE(A) sizeof(A)/sizeof(A[0]) \n// Binary search (note boundaries in the caller) \n// A[] is ceilIndex in the caller \nint CeilIndex(int *A, int *table, int l, int r, int key) { \n    int m; \n  \n    while( r-l > 1 ) { \n        m = l + (r-l)/2; \n        (A[table[m]] >= A[key] ? r : l) = m; // ternary expression returns an l-value \n    } \n  \n    return r; \n} \n  \nint LongestIncreasingSubsequenceLength(int A[], int size, int *result) { \n    // Add boundary case, when array size is one \n  \n    int *tailTable   = new int[size]; \n    int *parentIndex = new int[size]; \n    int len, pos; // always points empty slot \n  int i; \n    memset(tailTable, 0, sizeof(tailTable[0])*size); \n    memset(parentIndex, -1, sizeof(parentIndex[0])*size); \n    tailTable[0] = 0; \n    len = 1; \n    for(i = 1; i < size; i++ ) { \n        if( A[i] < A[tailTable[0]] ) \n            // new smallest value \n            { \n          tailTable[0] = i; \n       parentIndex[i] = -1; \n   } \n     else if( A[i] > A[tailTable[len-1]] ) \n            // A[i] wants to extend largest subsequence \n            { \n        tailTable[len] = i; \n        parentIndex[i]=tailTable[len-1]; \n     len++;     \n   } \n        else \n            // A[i] wants to be current end candidate of an existing subsequence \n            // It will replace ceil value in tailTable \n            { \n         pos= CeilIndex(A, tailTable, -1, len-1, i); \n         tailTable[pos] = i; \n      parentIndex[i]=tailTable[pos-1]; \n      } \n             \n    } \n  i=tailTable[len-1]; \n  for (int j=len-1;j>=0 && i!=-1;j--){ \n  result[j]=A[i]; \n  i=parentIndex[i]; \n } \n    delete[] tailTable; \n    delete[] parentIndex; \n    return len; \n} \n  \nint main() { \n    //int A[] = { 2, 5, 3, 7, 11, 8, 10, 13, 6 }; \n    int A[] = {5,2,6,3,4,1,9,8,9,5,6,7}; \n    int n = ARRAY_SIZE(A); \n    int x; \n    int *result= new int[n];  \n    printf(\"Length of Longest Increasing Subsequence is %d\\n\", \n            x=LongestIncreasingSubsequenceLength(A, n, result)); \n    cout<<\"result\"<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"use a max heap data structure so only maximum elements will be there in the heap..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"use a min heap...."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=22767685","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"33","title":"calculate (x^y)%z without pow();","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"the question here is how we can reduce the complexity... if we compute the x^y by normal method the complexity is O(y)... to reduce the complexity we can use binary weighted power computation method in which complexity is O(logy).."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Nicely explained here: ht p://stackoverflow.com/questions/2177781/how-to-calculate-modulus-of-large-numbers C Version"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"int calcp(int x,int y,int z) \n{  \n   int t = 1; \n   for(int j = 0;j< y;j++) \n      { \n          t = (t*x)%z; \n       } \n      return t; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"The following is a O(logn) based algorithm to compute the power. We can just do:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Here is an O(log(y)) algorithm. It is the classical fast exponential algorithm. I won't get into details into it because it is a simple algorithm and can be found easily by googling it.  However, the trick to this problem is to watch out for arithmetical overflows: - since x^y can grow really big, you can't just compute x^y and then apply % z, since it will likely overflow; so you need to apply modulo z operation on each multiplication; - furthermore for high values of z even one multiplication can overflow (take for instance x = 2 billions - 1, y = 2, z = 2 billions), so you need to use the long long type for each multiplication;  In order to make sure  there is no arithmetic overflow happening, I've defined the modMul(x, y, z) operation which performs the operation \"(x * y) % z\" and guarantees there is no overflow."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int theCode(int x, int y, int z)   {   int temp = x;   for (int i = 1; i <= y; i++)   {    x = x * temp;  }   return x % z;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"(int) exp(y * log(x)) % z"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"So far no one has handled the case where y is a negative integer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it means u cannot first use pow(x,y) and then mod it by z . i guess."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int count(int x, int y, int z) \n{ \n int temp_x = x; \n int temp_y = 1; \n while(temp_y"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can eliminate % by doing:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/** \n     * Computes (x^y) % z, without using power function in O(log y) time. \n     * Uses distributive property of modulo function: (a*b) % c = ((a%c) * (b%c)) % c \n     * To compute (x^y) % z, first recursively calls itself compute to (x ^ (y/2)) % z, \n     * then uses this value to compute (x ^ y) % z, by appropriately squaring, etc. \n     * @param x \n     * @param y \n     * @param z \n     * @return \n     */ \n    public static int CalculatePowerModulo(int x, int y, int z) \n    { \n        int factor = x % z; \n        if (y == 1) \n        { \n            return factor; \n        } \n \n        int value1 = CalculatePowerModulo(x, y/2, z); \n        int value2; \n \n        if (y % 2 == 0) \n        { \n            value2 = value1; \n        } \n        else \n        { \n            value2 = (factor * value1) % z; \n        } \n \n        return (value1 * value2) % z; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nlong int power(long int x,long int y,long int z); \nint main() \n{  long int x=2; \n   long int y=10; \n    long int z=200000; \n printf(\"%ld\",power(x,y,z)); \n return 0; \n} \nlong int power(long int x,long int y,long int z) \n{ long int k; \nif(y==0) \n return 1; \n if(y==1) \n  return x%z; \n if(y%2==0) \n { k=power(x,y/2,z); \n  k=k%z; \n  return((k*k)%z); \n } \n else \n {k=power(x,y/2,z); \n  k=k%z; \n     k=(k)%z; \n     x=x%z; \n  return((k*k*x)%z); \n } \n  \n#include \n#include \nlong int power(long int x,long int y,long int z); \nint main() \n{  long int x=2; \n   long int y=10; \n    long int z=200000; \n printf(\"%ld\",power(x,y,z)); \n return 0; \n} \nlong int power(long int x,long int y,long int z) \n{ long int k; \nif(y==0) \n return 1; \n if(y==1) \n  return x%z; \n if(y%2==0) \n { k=power(x,y/2,z); \n  k=k%z; \n  return((k*k)%z); \n } \n else \n {k=power(x,y/2,z); \n  k=k%z; \n     k=(k)%z; \n     x=x%z; \n  return((k*k*x)%z); \n } \n  \n \n \n} \n  \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"principle: ???a*b??mod n = ((a mod n)*(b mod n)) mod n Apply: ???a*a*a*a*a*a*??mod n = (((a*a)mod n)((a*a)mod n)((a*a)mod n)*(x mod n))mod n SO, Code is; int pow(int x, int y, int mod)   {       int res = 1;       while(y)       {           if(y & 1) res =  res * x % mod;           x = x * x % mod;           y = y / 2;       }       return res;   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int compute(int x, int y, int z) { \n int r = x % z; \n for (int i=0; i< y-1; i++) { \n  r = r * x; \n  r = r % z; \n } \n return r; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ans = 1; \nwhile(y>0) \n{ \n  while(y%2==0) \n  {p = ((p%z)*(p%z))%z; \n  y/=2; \n  } \n  ans = (ans*p)%z; y--; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=21787663","download_status":"DOWNLOAD_DONE","votes":"-11","answersCount":"20","title":"you have data provided to you in pairs. the relationship is that the 2nd element is a child of the first element.  print out the final output with tabs as shown in examples below  input:   output:  a    b  input:     output:  a    b    d     c  input:    output: a   c    b    d","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"This is a straight forward question on topological sort (which is nothing starting the dfs with vertices which no parent(ie. no out-going links, all in-coming) \n \n   void dfs(int u, vector< pair >& depth, int d) \n   { \n         depth[u].first = d; \n         list& adjList = graph[u].begin(); \n         for (auto it = adjList.begin(); it != adjList.end(); it++) \n         { \n                   int v = *it; \n                    if (depth[v].first == 0) dfs(v, depth, v+1); \n         } \n   } \n   void printTab(const vector< pair >& data) \n   { \n            vector< list > graph(N); \n            vector parent(N); // start the dfs which is the parent (ie. no outgoing links) \n            for (int i=0; i < data.size(); i++) \n            { \n                      int u = data[i].first -'a'; \n                      int v = data[i].second-'b'; \n                      graph[v].push_front(a); \n                      parent[v] = false; \n            } \n            vector< pair > depth(N); //  ->    \n            for (int i=0; i < N i++) { \n                 depth[i].second = i; \n                  if (parent[i]) dfs(i, depth, 0); \n            }  \n            sort(depth.begin(), depth.end()); \n            for (int i=0; i < N; i++) \n            { \n                     string space(depth[i].first, ' '); \n                     cout << space << depth[i].second + 'a' << endl; \n            } \n            \n   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"correcting whitespace not being captured properly. please use this output instead."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"final attempt, please treat every *tab as a tab input:   output:  a   *tab b  input:     output:  a   *tab b   *tab d    *tab *tab c  input:    output: a   c   *tab b   *tab d"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the question is interpreted as to print the elements in a level-by-level fashion, an alternative is to use a dynamic array of hashtables to solve the problem.  Suppose we have an array A of hashtables with size m. Then:  1. If a new pair (e1, e2) is seen in the input, check if e1 is present in the hashtable at location A]m-1].  2. If present, create a new hashtable at location A[m] and insert e2 into it. 3. Else, continue checking if e1 is present in the hashtables from A[m-2] up to A[0].   3a. If e1 is found in a hashtable at location j (where m-2 <= j <= 0), insert e2 into a hashtable at A[j+1]  3b. Otherwise insert e1 into hashtable at A[0] and e2 into hashtable at A[1].  After the input is processed, Iterate through each of the hashtables from A[0] to A[size-1] in that order and print the values."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sites.google.com/site/spaceofjameschen/home/stl/print-ordered-chars-with-specified-format"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we can construct a tree then we can print data breadth wise(bfs )"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ht tp geeksforgeeks.org/custom-tree-problem/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* you have data provided to you in pairs. the relationship is that the 2nd element is a child of the first element. print out the final output with tabs as shown in examples below  input:  output: a b  input:    output: a b d c  input:   output: a c b d */   #include #include #include #include  void print_ordered_chars( std::vector< std::pair > in_graph ) {  std::map place_holder_map;  std::multimap final_ordered_map;   //Reset all values in map, the values corresponding to the nodes indicate the level of node in graph   for( std::vector< std::pair >::iterator it = in_graph.begin(); it != in_graph.end(); it++ )  {   place_holder_map[ it->first ] = 0;   place_holder_map[ it->second ] = 0;  }   //Calculating the level of a the node in graph  for( std::vector< std::pair >::iterator it = in_graph.begin(); it != in_graph.end(); it++ )  {   int a  = place_holder_map[ it->first ];   int b = place_holder_map[ it->second ];   place_holder_map[ it->second ] = std::max( place_holder_map[ it->first ] + 1 , place_holder_map[ it->second ]);  }   //store the result in an std::multimap, ordered (A for( std::map::iterator it = place_holder_map.begin(); it != place_holder_map.end(); it++ )  {   final_ordered_map.insert( std::make_pair( it->second, it->first ) );  }   for( std::multimap::iterator it = final_ordered_map.begin(); it != final_ordered_map.end(); it++ )  {   for( int i=0; i<= it->first ;i++)    std::cout<<\"\\t\";    std::cout<second<<\"\\n\";  } }  int main(int argc, char const *argv[]) {  std::vector< std::pair< char,char > > input;  input.push_back( std::make_pair( 'a','b' ) );  input.push_back( std::make_pair( 'b','c' ) );  input.push_back( std::make_pair( 'd','c' ) );   print_ordered_chars( input );  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ah the spaces don't preserve"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Unless it's a C++ question and I am missing a requirement, why does it have to this complex? In Java it's trivial actually:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=20786668","download_status":"DOWNLOAD_DONE","votes":"-5","answersCount":"17","title":"Find the shortest path between two nodes in a graph, given only the start node and the end node as parameters.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"If it's an unweighted, undirectional graph then this can be done in O(N) (rather than O(N^2) for Djkstra) by simply doing a BFS traversal. You just keep looking through the nodes adjacent to any nodes you're currently examining that you haven't seen before until you see the node you're looking for, and then you reconstruct the path."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Really? Dijkstra's, straight out of the textbook?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is sample implementation of dijkstra's algorithm"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a C# implementation."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package com.careercup.google;  import java.util.ArrayList; import java.util.LinkedHashSet;  public class ShortestPath {  static class Node   {   public ArrayList neighborNodes;   public int value;      public Node(int v)   {    neighborNodes = new ArrayList();    value = v;   }  }   static int traverse(Node node1, Node node2, LinkedHashSet traversedNodes, int knownLength, LinkedHashSet out)  {     int minLen = Integer.MAX_VALUE;   LinkedHashSet minPath = new LinkedHashSet();    if (!traversedNodes.contains(node1))   {    traversedNodes.add(node1);        if (!node1.equals(node2))    {         for (int i =0; i < node1.neighborNodes.size(); i++)     {      int len = traverse(node1.neighborNodes.get(i), node2, traversedNodes, knownLength + 1, out);      if (len < minLen)      {       minLen = len;       minPath.clear();       minPath.addAll(out);      }            }    }    else    {     minLen = knownLength + 1;         minPath.addAll(traversedNodes);        }        if (minPath.size() > 0)    {        out.clear();     out.addAll(minPath);        }        traversedNodes.remove(node1);   }       return minLen;  }    static void printResult(LinkedHashSet path) {   int i = path.size();   for (Node n : path)   {    System.out.print(n.value + \",\");   }  }   /**   * @param args   */  public static void main(String[] args) {     Node node1 = new Node(1),     node2 = new Node(2),     node3 = new Node(3),     node4 = new Node(4),     node5 = new Node(5),     node6 = new Node(6),    node7 = new Node(7),    node8 = new Node(8),    node9 = new Node(9);      node1.neighborNodes.add(node2);   node2.neighborNodes.add(node5);   node5.neighborNodes.add(node6);   node6.neighborNodes.add(node8);      node2.neighborNodes.add(node6);      node1.neighborNodes.add(node3);   node3.neighborNodes.add(node4);   node4.neighborNodes.add(node8);      node1.neighborNodes.add(node5);   node5.neighborNodes.add(node6);   node6.neighborNodes.add(node8);       LinkedHashSet traversedNodes = new LinkedHashSet();   LinkedHashSet out = new LinkedHashSet();   int i = traverse(node1, node8, traversedNodes, 0, out);   if (i != Integer.MAX_VALUE)   {    printResult(out);   }  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It think the hidden point in this question is \"only the starting and the end nodes and nothing else\". This implies that we are unsure about the wights. Algorithm such as Dijkstra cannot be a safe bet since it can't deal with negative weights. Furthermore, BFS is a good choice for finding the shortest path in a graph with unit weights edges. I think the better idea is to use the Bellman-Ford algorithm since it handles the shortest path regardless of the sign of the weight values and also checks if the graph has a negative-weight cycle in which case no all-pairs shortest paths (in case needed/asked) can be constructed."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"asd"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"If you downvote any question please put reasons...it would serve as guideline to people who are going to post any new questions..else there is no meaning...In this questions I guess downvote is for not describing the graph type properly..  (or downvoted because question is very simple ???? it is simple if you have a lot of time...)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=21630672","download_status":"DOWNLOAD_DONE","votes":"4","answersCount":"42","title":"Given a list of integers, find out the biggest interval that has all its members in the given list. e.g. given list 1, 7, 4, 6, 3, 10, 2 then answer would be [1, 4]. Develop algorithm and write code for this","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"12","title":"shsf has a good solution.  Do you need to have the second hash?  Can't you remove already examined values from the hash as you go?  Here's an example in C#:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Sorting is an obvious solution with O(nlgn) time complexity. This can be solved using connected components of a graph in O(n) time and space complexity as discussed at question?id=19778663  The graph in this case is 'linear', with each node having at most 2 edges, and hence can be built in O(n) time. Finding connected components, and storing the maximal connected component, in this graph using DFS has O(n) time complexity. Hence overall complexity is O(n).  Java implementation given below. Provide the input as:  16 1 21 7 4 6 15 3 2 8 14 9 17 35 19 45 18 73 22 44 43 71 20 33"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"I think the solution with best run time O(n) is mentioned at stack overflow (answer by Grigor):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I Think sorting the array... and comparing all the conective elements will solve the proble, please correct me if i am wrong"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You are absolutely right. Just wondering can it be done in linear time :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sort the array O(nlogn) Then start from the beginning scanning the array for consecutive elements. Store the start and end index of the consecutive element sub-array and modify when a new larger sub-array is found. At the end return the start and end index of the larget sub-daary having consecutive elements. O(n) So final complexity = O(nlogn + n) = O(nlogn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hello guys I have little bit problem in understanding the problem.  1,4 output because 1,2, 3, 4 exists; that's why ? could some1 please answer ? ;)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"But if that is then question does not seem clear ;) Still I can't believe ........... if so then my 1st question is this a Google Question ?  From the given input it seems that If I do swap across elements whenever I shall not find any suitable elements then I shall break.  1 is @ first position 2 is 7th position and 7 is 2nd position 3 is 4th position and 4 is 3rd position  I am not sure the pattern is always like this  If the pattern is not so then complexity is n + n = 2n First I shall take same sized array then I shall place elements on the basis of it's value Whenever placing the elements if the element is out of the range then skip it In second phase longest sequential array  I am not sure, anonymous says right ? ;) lolz"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Answer 1 seems overly complicated. Simply sort the list, and the iterate through keeping track of what ranges your have seen.   Here is a simple mock up of this in MATLAB"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"As mentioned by dumbo, it can be solved in linear time using connected graph. Other simple solution can be using two hash table, one to tell if next/previous integer exists not, other to take care of already processed continuous integers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class BiggestInterval {  public static void main(String[] args) {   int[] A = {1,7,4,6,3,10,2};   int[] endPoints = new int[2];//endpoints[0] stands for the ??                     //left endpoint while endpoints[1] stands for the right point.   Arrays.sort(A);   int max = -1;   for(int i=0; i   for(int j=i; j    if(A[j] - A[i]==j-i && j-i>max){      endPoints[0] = A[i];      endPoints[1] = A[j];      max = j-i;     }    }   }      System.out.println(\"the biggest interval is: \" + max );   System.out.println(\"the interval is : [\" + endPoints[0] + \", \" + endPoints[1]+\"]\");     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"could anyone explain me the question? i am confused with how [1,4] will come!!1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"could anyone explain me the question? i am confused with how [1,4] will come!!1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's a C# example. I've tested this against a single element array, an array containing all of the same elements, and against the sample posted above."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the question's example answer is [1, 4] meaning the straight begins with the value of 1 and runs for 4 consecutive values.  This is a way to identify the subset { 1, 2, 3, 4 }."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Based on the solution from Stackoverflow (stackoverflow.com/a/17592550/538743),  it can be done with hashtable in O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using hashset and claiming O(N) doesn't feel right. Sure, your loop runs in O(N) calling hash functions. But Hashset cannot guarantee O(1) due to collisions with large number of keys."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"One more implementation"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"One of the O(N) solutions, with HashSet:   public void biggestInterval2(Collection is) {   Set all = new HashSet(is);   Set visited = new HashSet();   int bestStart = 0;   int bestLen = 0;   for(int i : is) {    if(! visited.contains(i)) {     visited.add(i);     int start = i;     while(all.contains(start - 1)) {      start --;      visited.add(start);     }     int end = i;     while(all.contains(end + 1)) {      end ++;      visited.add(end);     }     int len = end - start + 1;     if(len > bestLen) {      bestStart = start;      bestLen = len;     }    }   }   System.out.println(\"[\" + bestStart + \", \" + (bestStart + bestLen - 1) + \"]\");  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"One of the O(N) solutions, with HashSet:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can find my implementation below:   /* Given a list of integers, find out the biggest interval that has all its members in the given list.  e.g. given list 1, 7, 4, 6, 3, 10, 2 then answer would be [1, 4]. Develop algorithm and write code for this. */  import java.util.BitSet;  public class LargestContiguousInterval {          public static void main(String[] args) {    int[] arr = {1, 7, 4, 6, 3, 10, 2};   printLargestContInterval(arr);     }      private static void printLargestContInterval(int[] arr) {  BitSet bits = new BitSet();    for (int i = 0; i < arr.length; i++) {      bits.set(arr[i]);  }   // scan through the bit set  int len = bits.length();  int count = 0;  int maxCount = Integer.MIN_VALUE;  int maxStart = -1;  int start = -1;   for (int i = 0; i     if (bits.get(i)) {   count++;   if (start == -1)        start = i;      } else {      if (count > maxCount) {       maxCount = count;       maxStart = start;          }    start = -1;   count = 0;      }  }   // print the max cont range in 'arr'  System.out.println(\"[\" +  maxStart + \" - \" + (maxStart+maxCount-1) + \"]\");      } }   It uses the BitSet type from Java."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include using namespace std; int main() {     int no[100]={0},cnt=0,x,y,n,xf,yf,cntf=0;     bool nohash[100]={false};     cout<<\"enter the no of elements\"<    cin>>n;     cout<<\"enter the elements\"<    for(int i=0;i    {       cin>>no[i];       nohash[no[i]]=true;     }     for(int i=0;i<100;i++)     {         if(nohash[i]==true)         {x=i;          while(nohash[i]==true)          {           cnt++;i++;          }          y=i-1;         }       if(cnt>cntf)       {           cntf=cnt;           xf=x;           yf=y;       }       cnt=0;     }  cout<<\"range is\"<<<\"to\"<<} //an O(n) soln. using hash table"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void findInterval(List myList){ \n \n        int noOfElements=0; \n        int priviousElementCount=0; \n        int intStart=0; \n        int intEnd=0; \n        String output=\"\"; \n         \n        /* Sorting Will Take nLog(n) */ \n        Collections.sort(myList); \n         \n        /* 0(n) Time */ \n        for (int i=0; i \" + output);   \n \n       }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A different approach: (space utilization: O(n), Time Complexity: O(n))  1) Make a binary search tree or any balanced tree out of the values in given array 2) Get the output of in-order of that tree (to get a sorted array) 3) Find max interval from this sorted array in O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.HashSet;  \npublic class Solution{  \n  public int[] Interval(int[] arr){ \n    HashSet ht = new HashSet(); \n    for(int i = 0 ; i < arr.length ; i++)  \n      ht.add(arr[i]);  \n    int res = 0 ; \n    for(int i = 0 ; i < arr.length ; i++)  \n      if(ht.contains(arr[i]))  \n        res  = Math.max(res, scan(ht , arr[i]));  \n    return res; \n  } \n  public int scan(Hashset  ht, int k ){ \n    if(!ht.contains(k)) return 0; \n    ht.remove(k); \n    return 1+scan(ht,k-1) + scan(ht,k+1); \n  } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java Implementation using hashMap in time complexity O(n)..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static String findMaxInterval(int[] arr){      if(arr == null || arr.length == 0){    throw new IllegalArgumentException(\"Array must not be empty\");   }      Arrays.sort(arr);      String endResult = \"\";   int startIndex = 0;   int endIndex = 0;   int pass = 0;      int endMax = 0;      while(startIndex + pass < arr.length - 1){    pass++;    endIndex = startIndex + pass;    if(arr[startIndex] + pass == arr[endIndex]){     continue;    }    if(arr[startIndex] + pass != arr[endIndex]){         if(pass > endMax){      endMax = pass;      endResult = \"[\" + Integer.toString(arr[startIndex]) + \" , \" + Integer.toString(arr[endIndex-1]) + \"]\";     }     startIndex++;     pass = 0;    }           }      return endResult;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static String findMaxInterval(int[] arr){ \n   \n  if(arr == null || arr.length == 0){ \n   throw new IllegalArgumentException(\"Array must not be empty\"); \n  } \n   \n  Arrays.sort(arr); \n   \n  String endResult = \"\"; \n  int startIndex = 0; \n  int endIndex = 0; \n  int pass = 0; \n   \n  int endMax = 0; \n   \n  while(startIndex + pass < arr.length - 1){ \n   pass++; \n   endIndex = startIndex + pass; \n   if(arr[startIndex] + pass == arr[endIndex]){ \n    continue; \n   } \n   if(arr[startIndex] + pass != arr[endIndex]){     \n    if(pass > endMax){ \n     endMax = pass; \n     endResult = \"[\" + Integer.toString(arr[startIndex]) + \" , \" + Integer.toString(arr[endIndex-1]) + \"]\"; \n    } \n    startIndex++; \n    pass = 0; \n   } \n    \n    \n  } \n   \n  return endResult;"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=21180673","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"12","title":"Write code to clone a graph recursively","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"#include  \n \nusing namespace std; \n \nNode * CopyGraph(Node * node, unordered_map &copied) \n{ \n if(node==NULL) \n  return NULL; \n \n //First check if this node has already been copied \n unordered_map::iterator it = copied.find(node); \n if(it!=copied.end()) \n  return it->second; \n \n //If not, then create a copy of the node \n Node * new_node = new Node; \n new_node->data = node->data; \n \n //Add the copied node to the Hash table \n copied[node] = new_node; \n \n //Copy the node's neighbors using recursive calls \n for(int i=0; ineighbors.size(); i++) \n  new_node->neighbors.push_back(CopyGraph(node->neighbors[i], copied)); \n \n return new_node; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"It is not easy coding question...there can be a lot of constrains as you may need to take care such as  cycle in the graphs, or it is directed or not and other small details. If you still think it is easy then try coding and you may find many issues with first draft of  your code. As said, we can use dfs or bfs and we need to take care of cycle in the graph. We may like to use hash table to track cycle in the graph."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Does google really ask so easy question?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package com.careercup.google; \n \nimport java.util.ArrayList; \n \npublic class CloneGraph { \n \n static class Node { \n  int data; \n  ArrayList neighbors; \n } \n \n static void clone(Node sGraph, Node dGraph) { \n  if (sGraph != null) { \n   dGraph.data = sGraph.data; \n  } \n \n  if (sGraph.neighbors != null) { \n   if (dGraph.neighbors == null) { \n    dGraph.neighbors = new ArrayList(); \n   } \n \n   for (Node n : sGraph.neighbors) { \n    Node cloneN = new Node(); \n    dGraph.neighbors.add(cloneN); \n \n    clone(n, cloneN); \n   } \n  } \n } \n \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n  Node node1 = new Node(); \n  node1.data = 1; \n  node1.neighbors = new ArrayList(); \n \n  Node node2 = new Node(); \n  node2.data = 2; \n  node1.neighbors.add(node2); \n \n  Node node3 = new Node(); \n  node3.data = 3; \n  node1.neighbors.add(node3); \n \n  Node clonedGraph = new Node(); \n  clone(node1, clonedGraph); \n \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This takes care of cycles and is independent of whether the graph is directed or not."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.*;   public class Clone {  private HashMap marker;    public Clone() {marker = new HashMap(); }    void clone(Node s, Node d) {      if (s != null) {    d.data = s.data;    marker.put(s, d);   }         for (Node w : s.neighbors) {     if (!marker.containsKey(w)) {     Node c = new Node();     clone(w, c);     d.add(c);    }    else {     d.add(marker.get(w));    }    }  }    public static void main (String[] args) {   Node n1 = new Node(1);   Node n2 = new Node(2);   Node n3 = new Node(3);      n1.add(n2);   n2.add(n3);   n3.add(n1);      Clone c = new Clone();    Node c1 = new Node();   c.clone(n1, c1);      DFS p1 = new DFS(c1);  } }  class DFS {  private HashSet marker;  private int count;    public DFS(Node s) {marker = new HashSet();dfs(s);}  private void dfs(Node s) {      if (s != null) {    marker.add(s);   }      for (Node w : s.neighbors) {    if (!marker.contains(w))     dfs(w);        System.out.println(\"(\"+ s.data() + \")\" + \"->\" + \"(\" + w.data() + \")\");   }  } }  class Node {  int data;  ArrayList neighbors;  public Node(){neighbors = new ArrayList();}  public Node(int data) {   this.data = data;   neighbors = new ArrayList();}  public void data(int i) {this.data = data;}  public ArrayList neighbors() {return this.neighbors;}  public int data() {return this.data;}  public void add(Node i) {this.neighbors.add(i);} }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.*; \n \n \npublic class Clone { \n private HashMap marker; \n  \n public Clone() {marker = new HashMap(); } \n  \n void clone(Node s, Node d) { \n   \n  if (s != null) { \n   d.data = s.data; \n   marker.put(s, d); \n  } \n   \n   \n  for (Node w : s.neighbors) { \n \n   if (!marker.containsKey(w)) { \n    Node c = new Node(); \n    clone(w, c); \n    d.add(c); \n   } \n   else { \n    d.add(marker.get(w)); \n   } \n \n  } \n } \n  \n public static void main (String[] args) { \n  Node n1 = new Node(1); \n  Node n2 = new Node(2); \n  Node n3 = new Node(3); \n   \n  n1.add(n2); \n  n2.add(n3); \n  n3.add(n1); \n   \n  Clone c = new Clone();  \n  Node c1 = new Node(); \n  c.clone(n1, c1); \n   \n  DFS p1 = new DFS(c1); \n } \n} \n \nclass DFS { \n private HashSet marker; \n private int count; \n  \n public DFS(Node s) {marker = new HashSet();dfs(s);} \n private void dfs(Node s) { \n   \n  if (s != null) { \n   marker.add(s); \n  } \n   \n  for (Node w : s.neighbors) { \n   if (!marker.contains(w)) \n    dfs(w); \n    \n   System.out.println(\"(\"+ s.data() + \")\" + \"->\" + \"(\" + w.data() + \")\"); \n  } \n } \n} \n \nclass Node { \n int data; \n ArrayList neighbors; \n public Node(){neighbors = new ArrayList();} \n public Node(int data) { \n  this.data = data; \n  neighbors = new ArrayList();} \n public void data(int i) {this.data = data;} \n public ArrayList neighbors() {return this.neighbors;} \n public int data() {return this.data;} \n public void add(Node i) {this.neighbors.add(i);} \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using a map to store the mapping between the old node and the new node"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"typedef unordered_map Map; \n  \nNode *clone(Node *graph) { \n    if (!graph) return NULL; \n  \n    Map map; \n    queue q; \n    q.push(graph); \n  \n    Node *graphCopy = new Node(); \n    map[graph] = graphCopy; \n  \n    while (!q.empty()) { \n        Node *node = q.front(); \n        q.pop(); \n        int n = node->neighbors.size(); \n        for (int i = 0; i < n; i++) { \n            Node *neighbor = node->neighbors[i]; \n            // no copy exists \n            if (map.find(neighbor) == map.end()) { \n                Node *p = new Node(); \n                map[node]->neighbors.push_back(p); \n                map[neighbor] = p; \n                q.push(neighbor); \n            } else {     // a copy already exists \n                map[node]->neighbors.push_back(map[neighbor]); \n            } \n        } \n    } \n  \n    return graphCopy; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=21443663","download_status":"DOWNLOAD_DONE","votes":"-4","answersCount":"6","title":"What suggestions you can provide for improving the Page Rank algorithm.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"If the user is signed in , the algorithm can use the profile information of the user to return better search results , for example if the user regularly searches about the computer science concepts, then algorithm can use this information to return results of the related field when there's an ambiguity in the search keywords , for example  if the user is searching for tree , the algorithm may assign more weights to the TREE datastructure.  If the user clicks on the k-th result the algorithm can reduce the relevancy of the the previous k-1 results.  If the user returns back to the search engine within a certain time frame and uses the same keywords it means that he/she is not satisfied with the past results , so the relevancy of the past results can be decreased.  The algorithm can also use soundex , stemming & translation algorithms to create larger number of results (this increases the False Positive).  The algorithm can also use the context of the keywords to guess what user is really looking for. (For this task, Natural Language Processing and Machine Learning Techniques may be useful)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can find lots of stuff in these links, hope these help.  google.co.in/competition/howgooglesearchworks.html pr.efactory.de/e-pagerank-algorithm.shtml google.co.in/intl/en/insidesearch/howsearchworks/algorithms.html math.cornell.edu/~mec/Winter2009/RalucaRemus/Lecture3/lecture3.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can give along the improving the priors .. google uses around 200 priors for a web page"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can give along the improving the priors .. google uses around 200 priors for a web page"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=21024669","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"19","title":"Given N integer array, I want to fill the array with product of all numbers except the number in that cell.  What is the complexity ? Do not worry about 0's or negative numbers in the array. [Interviewer was more interested in how the multiplication/division gets effected as number of bits required to represent the intermediate products increases.]","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"1. First pass calculate the product P of all the numbers in array A 2. Second pass recreate the array A[i] = P / A[i]  As the interviewer has indicated the product can be very big, if the numbers in the array are big and/or the array length is big. Some languages support BigInteger operations, like Python and I think Java also has BigInteger class. If using the programming language provided implementation is not an option, then you'll need to implement your own \"BigInteger\" class. You need to only implement the constructor, which will take the number and convert it to string and then two methods for multiplication and division. C++ version will probably will overload the multiplication(*) and division(/) operators."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Guys , I beg to differ.  What you posted is only the beginning of a solution , but not a real algorithm.  Think about it, assuming the numbers all have exactly 10 digits , and there are N numbers in the array , to compute the product P of all the array numbers has the following cost:  Cost(product) = Sum(Cost( a number with >= 10*i digits * a number with 10 digits ) )   Assuming one uses an inefficient method to compute a*b , meaning the traditional n^2 algorithm , then Cost( a number with 10*i digits * a number with 10 digits ) = 11 * i   Considering this it is obvious that the cost of the product  algorithm is O(n^2)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I think the Actual question will have one more constraint that you can not use division operator.   Google \"A Product Array Puzzle\" for more info."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int n = a.length; \nint[] b = new int[n]; \n \nb[0] = 1; \nfor(int i = 1; i < n; i++) { \n  int prev = i-1; \n  b[i] = a[prev] * b[prev]; \n} \n \nint temp = a[n-1]; \nint temp2; \na[n-1] = 1; \nfor(int i = n - 2; i >= 0; i--) { \n  temp2 = a[i]; \n  a[i] = a[i+1] * temp; \n  temp = temp2; \n} \n \nfor(int i = 0; i < n; i++) { \n  a[i] = a[i] * b[i] \n} \n \n// a is the result"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"two arrays would be used: prev and post, prev[i] = a[i]*prev[i-1]; post[i]=a[i]*post[i+1], then result[i]=prev[i-1]*post[i+1]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package com.careercup.google; \n \nimport java.util.ArrayList; \n \nclass BigIntTest \n{ \n static class BigInt \n { \n  public BigInt(int[] _digits) \n  {    \n   for(int d : _digits) \n   { \n    digits.add(d); \n   } \n  } \n   \n  public BigInt multiply(BigInt b) \n  { \n   int size = digits.size() + b.digits.size() + 1; \n   int[] finalProduct = new int[size];   \n    \n   for (int i=0; i= b.digits.get(i)) \n     { \n      digits.set(i, digits.get(i) - b.digits.get(i)); \n     } \n     else \n     { \n      digits.set(i, digits.get(i) + 10 - b.digits.get(i)); \n      int j=i+1; \n      while (digits.get(j) == 0) \n      { \n       digits.set(j, 9); \n       j++; \n      } \n       digits.set(j, digits.get(j) - 1); \n      } \n    } \n    result++; \n   }  \n    \n   return result; \n  } \n   \n  public String toString() \n  { \n   String s = new String(); \n   while(0 == digits.get(digits.size()-1)) \n   { \n    digits.remove(digits.size() -1); \n   } \n    \n   for (int i= digits.size()-1; i>=0; i--) \n   { \n    s += digits.get(i).toString(); \n   } \n   return s; \n  } \n   \n  private Boolean zero(BigInt a) \n  { \n   for (Integer d : a.digits) \n   { \n    if (d != 0) \n    { \n     return false; \n    } \n   } \n    \n   return true; \n  } \n   \n  public ArrayList digits = new ArrayList(); \n } \n  \n public static void main (String[] args) \n { \n  //2765 \n  BigInt a = new BigInt(new int[]{5,6,7,2}); \n  BigInt b = new BigInt(new int[]{2}); \n  System.out.println(a.multiply(b)); \n  System.out.print(a.multiply(b).devide(b)); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// int a[N],b[N]; int i,j,tmp,tot = 1,index=0;  for (i=0; i < N; i++) {  tmp = a[i];  a[i] = 1;  tot = 0  for (j=0; j {   tot = tot * a[j];          }          b[index++] = tot;  a[i] = tmp; } // complexity O(n^2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int a[N],b[N];   \n       int i,tot = 1;  \n \n       for (i=0; i < N; i++)  \n       {  \n             tot = tot * a[i]; \n       } \n       for (i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Wait, I'm confused about this question. Why is it hard? Can we just go through an array, multiply all the numbers together (except for the selected cell), and then go through the array again, setting all the cells except for the selected cell to the product we just found?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"No overflow void fillproduct(vector &num)  {   if (num.size() == 0)    return;   if (num.size() == 1)   {     num[0] = 1;    return;   }    int cur = 1;   int last = num[num.size() -1];   for(int i=0; i  {    int tmp = num[i];    num[i] = cur;    cur *= tmp;   }    cur = num[num.size() -1]/ num[num.size() -2];   for(int i=num.size() - 2; i>= 0; i--)   {    int tmp = i == 0 ? 1 : num[i]/ num[i-1];    num[i] *= last;    last *= cur;    cur = tmp;   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Fairly simple question.  Previous poster gave the psuedo:  @oOZz 1. First pass calculate the product P of all the numbers in array A 2. Second pass recreate the array A[i] = P / A[i]   NOTE:  that you do have to make a special adjustment for the first element.  You set your accumulator equal to the beginning element, and then loop starting with the 2nd element.  Proper pseudo would read:  1.  Set accumulator variable equal to first element in the array 2.  Start with 2nd element in array and accumulate the product to the end of the array 3.  Start at beginning of the array and assign to each element:  accumulator/element value to the end of the array  Final consideration:  As the numbers get larger, you would need to implement BigInteger or use long, or possibly another customer data type to capture the massive values that can accumulate.  This algorithm runs on O(n) time and O(n) space complexity.  Here is a simple implementation of the actual code."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-5","title":"k"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=21326664","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"20","title":"Given a screen with all pixels having one of two colors. Now I will click on a random pixel.  Then that pixel & all the adjacent pixels with same color should change the color to the second color.  adjacent = vertically or horizontally above or blow.  Edit: Question seem to be not clear to some ppl. Giving an ex:  Given below & clicked on 2nd row, 2nd col W B W W B W B B W W B W W B B B W B W B W W B B  Covert to  W W W W B W W W W W B W W W W W W B W W W W B B","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"flood fill algo. was asked same question in google years back."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"It can be done with recursion. Just check for adjacent elements while also keeping track of out of bounds of array. Here is the code. You can test it:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"So what's exactly is required yo be done?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"That's the simple flood fill algo, for which the iterative implementation is given below:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"All the neighbours of the pixel (x,y) selected have to be changed including the current pixel. There are 8 neighbours for a pixel. (x-1, y-1) (x-1, y) (x-1, y+1) (x, y-1) (x, y+1) (x+1, y-1) (x+1, y) (x+1, y+1) for all these pixels the color will be the same as the new color of the clicked pixel at (x,y)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's my implementation of the algorithm. I used the recursive approach since it's much easier to understand. It is important to change the value in cell (i,j) BEFORE diving into the recursive calls, because if not you can end up with infinite recursive calls. Here's the C++ implementation:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This was great ... Flood fill algorithm .. hmm  i came with a totally different approach but I think it will work well though. Can anybody comment about my approach. Make each entry as a vertex in graph and make its adjacent elements as adjacent nodes. Algorithm: Push the clicked vertex to the queue.  while(queue not empty) pop the element from queue push the adj nodes which are only B in to the queue (and toggle their color)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"flood fill algorithm....its beautiful.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{{//first we need to check what the color is at a particular index..  void colorat(int *matrix[], int m, int n, int x, int y) //m, n are dimensions of the matrix, and x,y is //the current position { if(x<=0 || x>=m) return ; if(y<=0 || y>=n ) return;  char color = matrix[x][y];  changecolor(matrix, x-1,y-1, color); changecolor(matrix, x,y-1, color); changecolor(matrix, x+1,y-1, color); changecolor(matrix, x-1,y, color); changecolor(matrix, x+1,y, color); changecolor(matrix, x-1,y+1, color); changecolor(matrix, x,y+1, color); changecolor(matrix, x+1,y-1, color);  }  void changecolor(int *matrix[], int x, int y, char color) { if(matrix[i][j]!=color) { matrix[i][j]=color; } else return; }   }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package com.zhuyu_deng.test; \n \nimport java.util.Stack; \n \npublic class Test \n{ \n \n private static void printMatrix(char[][] a) \n { \n  for (int i = 0; i < a.length; ++i) \n  { \n   for (int j = 0; j < a[i].length; ++j) \n   { \n    System.out.print(a[i][j] + \"  \"); \n   } \n   System.out.println(); \n  } \n } \n  \n private static void floodFill(char[][] a, int x, int y) \n { \n  class Node \n  { \n   public Node(int x, int y) \n   { \n    this.x = x; \n    this.y = y; \n   } \n \n   int x; \n   int y; \n  } \n \n  char orgColor = a[x][y]; \n  char revColor = a[x][y] == 'W' ? 'B' : 'W'; \n  int size = 0; \n  \n  Node stack[] = new Node[a.length * a[0].length]; \n  stack[size] = new Node(x, y); \n  while (size >= 0) \n  { \n   Node cur = stack[size]; \n   size--; \n   a[cur.x][cur.y] = revColor; \n   if (cur.x - 1 >= 0 && orgColor == a[cur.x - 1][cur.y]) \n   { \n    stack[++size] = (new Node(cur.x-1, cur.y)); \n   } \n   if (cur.x + 1 < a.length && orgColor == a[cur.x + 1][cur.y]) \n   { \n    stack[++size] = (new Node(cur.x+1, cur.y)); \n   } \n   if (cur.y - 1 >= 0 && orgColor == a[cur.x][cur.y - 1]) \n   { \n    stack[++size] = (new Node(cur.x, cur.y-1)); \n   } \n   if (cur.y + 1 < a[0].length && orgColor == a[cur.x][cur.y + 1]) \n   { \n    stack[++size] = (new Node(cur.x, cur.y + 1)); \n   } \n  } \n   \n } \n \n public static void main(String args[]) \n { \n  // int[] a = {-2,11,-4,13,-5,-2}; \n  int[][] b = { { 0, -2, -7, 0 }, { 9, 2, -6, 2 }, { -4, 1, -4, 1 }, \n    { -1, 8, 0, -2 } }; \n  int[][] matrix = { { 2, 3, 4, 1 }, { 1, 1, 3, 9 }, { 2, 2, 3, 1 }, \n    { 2, 2, 3, 1 } }; \n  char a[][] = new char[][] { { 'W', 'B', 'W', 'W', 'B', 'W' }, \n    { 'B', 'B', 'W', 'W', 'B', 'W' }, \n    { 'W', 'B', 'B', 'B', 'W', 'B' }, \n    { 'W', 'B', 'W', 'W', 'B', 'B' } }; \n   \n   \n  printMatrix(a); \n \n  floodFill(a, 2, 2); \n \n  System.out.println(); \n \n  printMatrix(a); \n   \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.*; \n \npublic class Fill { \n \n public static void print(char[][] a) { \n  System.out.println(); \n  System.out.print(a[0].length); \n  for (char[] l : a) { \n   for (char c : l) { \n    System.out.print(c + \" \"); \n   } \n   System.out.println(); \n  } \n } \n  \n public static ArrayList checkAdj(char[][] a, int i, int j) { \n  ArrayList ps = new ArrayList(); \n  char c = a[i][j]; \n   \n  int curI = i-1; int curJ = j; \n  if (curI >= 0 && curJ >= 0 && curI < a.length && curJ < a[0].length && (a[curI][curJ] == c)) \n   ps.add(new Point(curI, curJ)); \n    \n  curI = i+1; curJ = j; \n  if (curI >= 0 && curJ >= 0 && curI < a.length && curJ < a[0].length && (a[curI][curJ] == c)) \n   ps.add(new Point(curI, curJ)); \n   \n  curI = i; curJ = j-1;  \n  if (curI >= 0 && curJ >= 0 && curI < a.length && curJ < a[0].length && (a[curI][curJ] == c)) \n   ps.add(new Point(curI, curJ)); \n   \n  curI = i; curJ = j+1; \n  if (curI >= 0 && curJ >= 0 && curI < a.length && curJ < a[0].length && (a[curI][curJ] == c)) \n   ps.add(new Point(curI, curJ)); \n   \n   \n  return ps; \n } \n  \n public static void fill(char[][] a, int i, int j, char f) { \n   \n  // check adjacent pixels \n  ArrayList ps = checkAdj(a, i, j); \n  //  \n  a[i][j] = f; \n   \n  for (Point p: ps) { \n   fill(a, p.i, p.j, f); \n  }  \n } \n  \n public static void main (String[] args) throws FileNotFoundException { \n  char a[][] = new char[][] { { 'W', 'B', 'W', 'W', 'B', 'W' }, \n    { 'B', 'B', 'W', 'W', 'B', 'W' }, \n    { 'W', 'B', 'B', 'B', 'W', 'B' }, \n    { 'W', 'B', 'W', 'W', 'B', 'B' } }; \n  print(a); \n  fill(a, 1, 1, 'L'); \n  print(a); \n }  \n} \n \nclass Point{ \n int i; \n int j; \n  \n Point(int i, int j) {this.i = i; this.j = j;} \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think BFS can do the job as well. Pass the node that is recently clicked to the BFS as the starting node and then do a simple BFS walk onward. We should keep the previous color of the recently clicked node in a temporary variable, say prevColor. In the main loop of the BFS we should do something like:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A solution in Python:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A solution in Python:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"So I am assuming this is simply how to make the pixels change color and there is no end goal (like turn the screen from black to white and count the number of clicks).  1.  Initialize 2D array with 0's to represent color 1. 2.  Initialize mouse event handler that returns point x,y on mouse click 3.  Return x,y to the colorChange function 4.  colorChange then flips pixels:  (x,y) (x-1,y) (x+1,y) (x,y-1) (x,y+1) to the opposite value (0's to 1's, and 1's back to 0's) as long as their current value matches the value at x,y.    4a.  You must utilize edge/corner checking to make sure you do not encounter ArrayOutOfBounds Exceptions."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=20311667","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"14","title":"Define a class to represent a graph which supports following opertations addEdge(Node n1,Node n2) addNode(Object nodeData)  How do you differentiate between an edge n1->n2 and n2->n1","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"I would use a HashMap> to store the nodes as keys and the list of adjacent nodes as values. That way both operations take O(1). The adjacency matrix approach isn't optimal for supporting these 2 operations, because you would need to expand the matrix (a 2-dimensional array) with each additional node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I'm not sure if I got this question right. In case we don't need to delete nodes from graph we can use a classic graph representation, such as adjacency list or adjacency matrix. If we implement adjacency list with std::vector it will take amortized constant time to add a new node or edge. Also there is no trouble to distinguish an edge n1->n2 from n2->n1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assume we have a matrix .. ( adjacency matrix ) adj[3][3] (assuming we have only 3 vertices).. while adding an edge just mention the source and destination as node1 and node2  ..  i.e  addEdge(Node n1,Node n2) { ... ... adj[n1][n2]=1; ... .. } here we can see that we have edge from some vertex to other only if there is '1' ... similarly  here there wont be edge from n2 to n1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Store nodes in a list.  Store edges in a list of tuples. Example,  represents an edge n1->n2. In a list the lookup will be O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The graph can be represented as an adjancency matrix or list of nodes with list of tuples for directed edges. In an adjancency matrix representation, the edge direction can be stored by having 1 for adj[i][j] = 1 such tht i->j is a directed edge. In the tuple representation, , where i->j is a directed edge."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my solution that uses multi-structured linked list to solve the problem:  \"I know its a bit complicated, but when you will run the code, you will know that it works\". :)  The solution might seem a bit complicated because I have modified the problem to also hold relations to other node data such as distance between two nodes, to make the problem more challenging.  Each node contains its ID and a link to another structure called Link. This \"structure\", Link is a linked list where each node of this link list tells what other nodes this node is connected to.  Link contains two fields. One field points to the actual structure (Relation) where all the data is kept such as what is the distance to the other node and what node it is connected to. The other field just points to the next structure.  The header file goes as follows:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"\"How do you differentiate between an edge n1->n2 and n2->n1\""},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"take a map and linked list , map will store node_value and corresponding linked_list start address. Linked list will keep information about those nodes with whom that node is connected."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I did research on Graphics. If you have some computer graphics background, you can tell clearly he was expecting the answer: helf-edge structure, which is some basis knowledge in this field."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=20308668","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"40","title":"Given a string pattern of 0s, 1s, and ?s (wildcards), generate all 0-1 strings that match this pattern. e.g. 1?00?101 -> [10000101, 10001101, 11000101, 11001101]. You can generate the strings in any order that suits you.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"use simple recursion..call function print(string name,0)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"non recursive algorithm is provided on sites.google.com/site/spaceofjameschen/home/string/generate-strings-with-a-specified-pattern----google"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"there is a fault in the question if m nt wrong....this is obviously they asked things related to the compiler design/theory of computing related topics....or shud i say turing machine related things...but the problem is on what basis Google wants u to print those 1's or 00's ,cause ofcourse u need to generate 101 only once...but what about the first two elements...upto infinity ??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Recursion. Not much to elaborate on."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void outputAllString(String pattern){ \n  ArrayList potential_pattern=new ArrayList(); \n  potential_pattern.add(\"\"); \n  for(int i=0; i=0; j--){ \n    String s=potential_pattern.remove(j); \n    if(pattern.charAt(i)!='?'){ \n     s+=pattern.charAt(i); \n     potential_pattern.add(j, s); \n    } \n    else{ \n     String temp=s+\"0\"; \n     potential_pattern.add(j,temp); \n     temp=s+\"1\"; \n     potential_pattern.add(j, temp); \n    } \n   } \n  } \n  //output result \n  for(String s:potential_pattern) \n   System.out.println(s); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It can be done by rotating the substring whose length is equal to the number of the wildcards and is initialized to zero. Use every rotation to fill the wildcards locations within the original string with the current values of the substring. Here's the code to compute the substrings, iteratively. The rest if trivial:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I did the problem in Notepad, so as to not benefit from autocomplete.  Then I fixed the few errors I had (i.e. I had written StringBuffer.add() instead of StringBuffer.append()) and verified that it works correctly.  Here is my answer. I would appreciate any critique."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void generateResultSet(String inp)   {   if (inp == null || inp.length() == 0)    return;   if (!inp.contains(\"?\"))   {    System.out.println(inp);    return;   }   else   {    String withZero = inp.replaceFirst(\"\\\\?\", \"0\");    String withOne = inp.replaceFirst(\"\\\\?\", \"1\");    generateResultSet(withZero);    generateResultSet(withOne);       }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; \nimport java.util.HashMap; \nimport java.util.List; \nimport java.util.Map; \nimport java.util.Stack; \n \npublic class WildCardReplacer { \n    private Substitutor substritutor; \n \n    public WildCardReplacer() { \n        substritutor = new Substitutor(); \n    } \n \n    public List substituteWildChar(String strWithWildChar, String wildChar) { \n        Stack stack = new Stack(); \n        stack.push(strWithWildChar); \n        String[] substitutedStr = null; \n        String strContainsWildChar = null; \n        List stringlistRelacedWildCharList = new ArrayList(); \n        while (!stack.isEmpty()) { \n            strContainsWildChar = stack.pop(); \n            if (strContainsWildChar.indexOf(wildChar) >= 0) { \n                substitutedStr = substritutor.substitute(strContainsWildChar, wildChar); \n                for (String sub : substitutedStr) { \n                    stack.push(sub); \n                } \n            } else { \n                stringlistRelacedWildCharList.add(strContainsWildChar); \n            } \n        } \n        return stringlistRelacedWildCharList; \n    } \n \n    public static void main(String[] args) { \n        System.out.println(new WildCardReplacer().substituteWildChar(\"?001?00?\", \"?\")); \n    } \n \n} \n \nclass Substitutor { \n    private static Map substituteStringMap = new HashMap(); \n    static { \n        String[] substituteChar = { \"0\", \"1\" }; \n        substituteStringMap.put(\"?\", substituteChar); \n    } \n \n    public String[] substitute(String srcStr, String wildChar) { \n        if (substituteStringMap.containsKey(wildChar)) { \n            String[] substituteChar = substituteStringMap.get(wildChar); \n            String[] substitutedStr = new String[substituteChar.length]; \n            int indx = 0; \n            for (String schar : substituteChar) { \n                substitutedStr[indx++] = srcStr.replaceFirst(\"\\\\\" + wildChar, schar); \n            } \n            return substitutedStr; \n        } \n        throw new RuntimeException(\" Wild char :\" + wildChar + \" not supported!!\"); \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can tweak the idea we use to generate truth table to support this."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Logic: \n \n-get the no. of '?' char in string given [ noOfWildChar ]  \n \n-now calculate no of possible strings = [ noOfStrings = 2 ^ noOfWildChar ] \n \n-write a loop initiating from 0 to noOfStrings having index as loopIndex \n \n-Inside Loop: \n --calculate binary form of loopIndex for ex: 11 = 1011, 12 = 1100, 17 = 10001 [binaryForm] \n --now start replacing '?' char with binaryForm sequence and print it. \n \nFor Ex: \nString = 1 1 0 ? 1 ? 0 0 ? ? 1 ? \nnoOfWildChar = 5 \nnoOfStrings = (2^5) = 32 \n \nLoop \n -loopIndex = 0 then binaryForm = 00000 hence put '0' at all occurance of '?' char  \n -loopIndex = 1 ......... \n -loopIndex = 2 ......... \n -... \n -.. \n -loopIndex = 11 then binaryForm = 01011 hence put '0' at first and third occurance of '?' and rest fill '1'  \n -.. \n -.. \n -loopIndex = 31 then binaryForm = 11111 hence put '1' at all occurance of '?' char   \nEND LOOP"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{{ //i can think of the solution which is of the O(n.2^k) where n is the length of the string and k is the count of '?' in the string... as there would 2^k patterns for k '?' and we need to write all..  Is there any better solution??? }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include using namespace std;  void GenarateString ( string s_pattern , int index ){         int i_size=s_pattern.size();         if( index == i_size ){                 std::cout<<                return;         }          if( s_pattern[index]== '?' ){                  s_pattern[index]='0';                  GenarateString ( s_pattern , index + 1 );                  s_pattern[index]='1';                  GenarateString ( s_pattern , index + 1 );          }          else                 GenarateString ( s_pattern , index + 1 ); }   int main(){          int i_num;          std::cin>>i_num;          string s_pattern;          for( int i=0 ; i                 std::cin>>s_pattern;                  std::cout<<\"The pattern is= \"<<                         GenarateString(s_pattern , 0 );          } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Let it be a binary number.  ? ? ? can be of range 000 to 111 which is decimal 0 to 7. plug the result into ?s."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A non-recursive solution is here:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if ARGV.size == 1         strng = ARGV[0] else         strng = \"10?01?11\" end input=0 itter=0 puts strng.size strng.split(//).each{|chr| input+=1 if (chr == '?')} outerloop = 2**input innerloop = input cont = Array.new var = Array.new itter = 0 def show_array(input, var, strng)         itter=0         while(itter < input)                 strng = strng.sub('?',var[itter].to_s)                 itter+=1         end         puts strng end         while(itter < input)                         cont[itter]=2**(input - 1 - itter)                         var[itter]=0                         itter+=1         end          itter=1         litter=0         while(itter <= outerloop)         show_array(input, var, strng)                 while(litter < input )                         if( itter%cont[litter] == 0 )                                 if(var[litter] == 0)                                 var[litter]=1                                 else                                 var[litter]=0                                 end                         end                 litter+=1                 end                 litter=0                 itter+=1         end [amitn@amitn-ux railprac]$ ruby pattern.rb \"11?00?11?\" 9 110000110 110000111 110001110 110001111 111000110 111000111 111001110 111001111"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Wrote non recursive program in RUBY."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void theCode(String pattern) { \n  System.out.println(pattern); \n  int temp = 0; \n  LinkedList locations = new LinkedList(); \n \n  for (int i = 0; i < pattern.length(); i++) { \n   if (pattern.charAt(i) == '?') { \n    temp++; \n    locations.add(i); \n \n   } \n  } \n  int limit = 1; \n  for (int i = 1; i <= temp; i++) \n   limit = limit * temp; \n \n  System.out.println(limit); \n  for (int i = 0; i < limit; i++) { \n   String model=String.format(\"%\" + temp + \"s\",Integer.toBinaryString(i)).replace(' ', '0'); \n    \n   System.out.println(model); \n    \n   int q=0; \n   for(int k=0; k"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static string[] generatePattern(string pattern) \n        { \n            int count = pattern.Count(c => c == '?'); \n            int comb = (int)Math.Pow(2, count); \n \n            getPattern(\"0\", 1); \n            getPattern(\"1\", 1); \n \n            string[] generatedPatterns = new string[comb]; \n            for (int i = 0 ; i < patterns.Count; i++) \n            { \n                StringBuilder patternConvin = new StringBuilder(pattern); \n                int index = -1; \n                foreach (Char c in patterns[i]) \n                { \n                    index = patternConvin.ToString().IndexOf('?', (index == -1) ? 0 : index); \n                    patternConvin[index] = c; \n                } \n                generatedPatterns[i] = patternConvin.ToString(); \n            } \n            return generatedPatterns; \n        } \n \n        static List patterns = new List(); \n        static string getPattern(string pchars, int c) \n        { \n            if (c < 3) c++; \n            else return pchars; \n \n            string zpat = getPattern(pchars + \"0\", c); \n            if (!string.IsNullOrEmpty(zpat)) \n                patterns.Add(zpat); \n            string opat = getPattern(pchars + \"1\", c); \n            if (!string.IsNullOrEmpty(opat)) \n                patterns.Add(opat); \n \n            return string.Empty; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Argument Can be any patteren with question mark   \"???\" or ?10101?? or 0101010??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Solution{ \n  ArrayList res; \n  public ArrayListPatten( String str ){ \n    res = new ArrayList();   \n    Patten_DP(str, new StringBuffer() , 0); \n    return res; \n  } \n  private void Patten_DP(String str,StringBuffer buf , int index){ \n    if(index == str.length()) res.add(buf.toString()); \n    switch(str.charAt(index)){ \n      case '1': \n        buf.add('1'); \n        break; \n      case '0': \n        buf.add('0'); \n        break; \n      case '?': \n        String buf2 = new StringBuffer(buf); \n        buf.add('0'); \n        buf2.add('1'); \n        Patten_DP(str,buf , index+1); \n        Patten_DP(str,buf2 , index+1); \n        break; \n    } \n  } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's another approach: 1.Traverse the string and count the total number of wildcards that are included in the string. 2. Given n wildcards, it is clear that the total number of new strings that can be formed by filling these blank positions is n! (assuming that ? implies single character placement). 3. We can generate these n! permutations one-by-one and fill the wildcards."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I wrote a tail recursive version of the program. I ran the code. It works. Here it is:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=20229674","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"46","title":"A binary search tree is given. Find the ceiling value present in the BST  of a given key.  eg-","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Working code is given below... call function using.. findCeil(root, num, num);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public Node ceil(int i) { \n  largest = null; \n  largest = ceilInt(root,i); \n  return largest; \n } \n  \n private Node ceilInt(Node n, int x){ \n  if(n == null) return largest; \n   \n  if(n.value > x){ \n   largest = n; \n   return ceilInt(n.left,x); \n  }else{ \n   return ceilInt(n.right,x); \n  } \n } \n private Node root = null; \n private Node largest = null;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Similar to search in BST..just keep a reference variable updating the smallest value greater than given node value  see this-- geeksforgeeks.org/floor-and-ceil-from-a-bst/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since it is a BST, try to find a range where  (root)<(target)<(root->right), then find the smallest item(Upper ceiling) in the right subtree.  It toke O(logN) time since it is a BST.  To find the smallest, another O(logN) spent, and in sum it still hold O(logN) complexity."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since it is a BST, try to find a range where  (root)<(target)<(root->right), then find the smallest item(Upper ceiling) in the right subtree.  It toke O(logN) time since it is a BST.  To find the smallest, another O(logN) spent, and in sum it still hold O(logN) complexity."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"allaboutalgorithms.wordpress.com/2013/06/24/find-ceil-of-a-key-in-a-binary-search-tree-bst/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// Function to find ceil of a given input in BST. If input is more // than the max key in BST, return -1 int Ceil(node *root, int input) {     // Base case     if( root == NULL )         return -1;       // We found equal key     if( root->key == input )         return root->key;       // If root's key is smaller, ceil must be in right subtree     if( root->key < input )         return Ceil(root->right, input);       // Else, either left subtree or root has the ceil value     int ceil = Ceil(root->left, input);     return (ceil >= input) ? ceil : root->key; }  copied from geeksforgeeks, thought will help others.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming an existing node class with node.left, node.right, and node.value properties, below is a Python solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"TreeNode *findCeiling(TreeNode *curr, int target) { \n       if (curr == NULL) return NULL; \n if (curr->val > target) { \n  Node *findsmaller = findCeiling(curr->left, target); \n  if (findsmaller) \n   return findsmaller; \n  else \n   return cure; \n } else { \n  return findCeiling(node->right, target) \n } \n   \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int ceilingValue(BTNode node, int value, int currCeil) \n { \n  if(node == null) \n   return Integer.MIN_VALUE; \n \n  int nextCeil = 0; \n  if(node.data < currCeil && value < node.data) \n   currCeil = node.data; \n \n  if(value >= node.data) \n   nextCeil = ceilingValue(node.right, value, currCeil); \n  else \n   nextCeil = ceilingValue(node.left, value, currCeil); \n \n  if(nextCeil == Integer.MIN_VALUE) \n   return currCeil; \n  else \n   return nextCeil; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Augment the BST with size field. 2. First find the rank of the given key k, and let it be r. 3. Find the (r+1)st order statistic, which is the ceiling element of the key k. (Finding rank and selecting the ith order static are standard procedures on a size-field augmented BST)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Take coursera.org/course/algs4partI course, Prof. has explained BST Floor and Ceil ling function in a more precise way which is better than all above solution. Its in section 9.5. Before Coursera, you need to put dubdubdub"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A simple solution would be to find the successor of the key. Well but the given key may exist or may not exist.  case 1: given key exist in the tree... then its simple to find its successor. case 2: given key doesn't exist in the tree... In this case, we will first try to find the key in the tree and we will find the successor of the last element before we hit the null.  Time complexity: O(log n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//just do a inorder traversal and then store collection in an array, and then traverse over it  //O(n) time and O(n) space vector vec;  int *inorder(node *root) { if(root ==NULL) return; else { inorder(root->left); vec.push_back(root->data); inorder(root->right); } return vec; } vector::const_iterator it;  //now traverse the vec  int trave(vector *vec,int key) { it=vec.begin(); while(*it <=key) { it++; } cout<<*it++; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If it's a binary search tree, then by \"ceil\" and the example given, i assume that you are looking for the element which immediately succeeds the given value.  i.e.: 13 => 15  You have to handle two cases:  1.) The successor is your right child 2.) The successor is your ancestor  This assumes that we already have a pointer to the target node we are trying to get the ceil of.  It's just a way to do an inorder traversal given a start-node, and not a traversal of the entire tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my non-recursive solution. Note:  It assumes that we are asked to return the successor even if the given key is in the tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"TreeNode* ceilNode(TreeNode* root, int key) \n{ \n     TreeNode* ans; \n     while (root) \n     { \n                     if (root->val > key) { \n                               ans = root; \n                               root = root->left; \n                     } \n                     else root = root->right; \n     } \n       return ans; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java solution using static variable and in order traversal"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"With python and lazy evaluation"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"CeilVal=INT_MAX; \nstruct bst *CielNode=NULL; \nif(node==NULL) \n  return CeilNode; \nwhile(node!=NULL) \n{ \n  if(node->data > givenValue) \n  { \n     if(node->data < CeilVal) \n     {   \n         CeilNode=b; \n         CielVal=node->data; \n     }   \n     node=node->lc; \n  } \n  else \n     node=node->rc; \n} \nreturn CeilNode;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if(b==NULL) \n  return NULL; \nstruct bst *CeilVal=NULL; \nwhile(b!=NULL) \n{ \n  if(b->data>GivenValue) \n  { \n     if (CeilVal==NULL || b->data < CeilVal->data) \n  CeilVal=b; \n     b=b->lc; \n  }  \n  else \n     b=b->rc; \n} \nreturn CeilVal;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if(b==NULL) \n  return NULL; \nstruct bst *CeilVal=NULL; \nwhile(b!=NULL) \n{ \n  if(b->data>GivenValue) \n  { \n     if (CeilVal==NULL || b->data < CeilVal->data) \n  CeilVal=b; \n     b=b->lc; \n  }  \n  else \n     b=b->rc; \n} \nreturn CeilVal;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Call this function Ceil(root,input, -1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is can be done in big-oh(log n) complexity.  The question needs to return the strictly next larger but smaller than anything for a given element.  And finding next larger takes big-oh (h)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(NLogN) - Using In-Order Traversal"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's my iterative solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"inorder successor ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Assume all node values are positive. -1 is an unvalid node value."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"just traverse in reverse of inorder starting from right most. Store the immediate greater value known. When the first node you hit less then the input print the immediate greater value."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public class BinarySearchTree { \n \n private class Node { \n  int value; \n  Node left; \n  Node right; \n \n  public Node(int val) { \n   value = val; \n   left = null; \n   right = null; \n  } \n } \n Node root = null; \n  \n private int keyCeiling(int key, Node currNode) { \n  if(currNode == null) return -1; \n  int ceiling = -1; \n  if(key == currNode.value) ceiling = currNode.value; \n  else if(key < currNode.value) { \n   ceiling = currNode.value; \n   int ceil = keyCeiling(key, currNode.left); \n   ceiling = (ceil == -1) ? ceiling : ceil; \n  } \n  else { \n   int ceil = keyCeiling(key, currNode.right); \n   ceiling = (ceil == -1) ? ceiling : ceil; \n  } \n  return ceiling \n } \n \n public void findCeiling(int key) { \n  if(root == null) { \n   System.out.println(\"Empty binary search tree\"); \n   return;  \n  } \n  int ceilValue = keyCeiling(key, root); \n  if(ceilValue == -1) \n   System.out.println(\"Not found ceiling value for \" + key); \n  else \n   System.out.println(\"Ceiling value for \" + key + \" is \" + ceilValue); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"to keep stuff simplier, you have to use recursion: assuming"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"int func(int key,node* root) \n{ \n    int ceil=32767;//or MAX_INT \n    while(root!=NULL) \n    { \n             if(root->val > key) \n             { \n                       if(root->val < ceil) \n                       { \n                               ceil=root->val;                   \n                       }                 \n                       root=root->left; \n             }                          \n             else  //both cases of equal and lesser \n             root=root->right; \n    }     \n    return ceil; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I think it can simply be done using recursion in the following way.It just traverse the bst in a recursive way which will take the same time as that required to traverse a bst. You can test the below code:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=20044670","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"23","title":"How many  unique words(does not required to have meaning) can you generate from a \"EFFICIENT\" word","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"9","title":"It's permutation, but note that there are repeated characters.   9!/2!x2!x2!= 45360, because you have 9 characters, but there are two Es, Is, and Fs."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It would make an interesting question if you were asked to find the number of unique dictionary words, otherwise it's just a simple permutations problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \n \nvoid permutation(char *string,int level,int k) \n{ \n   \n char temp; \n k = level; \n if(level == strlen(string)) \n { \n  printf(\"%s \",string); \n  return; \n } \n while(1) \n { \n  permutation(string,level+1,k); \n  if(k < strlen(string)) \n  { \n   temp = *(string+(level - 1)); \n   *(string+(level - 1)) = *(string + k); \n   *(string + k) = temp; \n   k++; \n  } \n  else \n  { \n   break; \n  } \n   \n } \n return; \n} \n  \nint main() \n{ \n char *string = (char*)malloc(sizeof(50)); \n strcpy(string,\"EFFICIENT\"); \n int level = 1; \n int k = 1; \n permutation(string,level,k); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think it should be the powerset of the given string. It includes all possible permutations hence -> sum_(k=1)_n p(n,k)=2^n-1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"HashSet permutaion(String s){ \n   HashSet set=new HashSet(); \n   permutation(\" \", s,set); \n \n  }  \n \n void permutation(String prefix,String s,HashSet set){ \n    \n   if(s.length()==0){ \n    set.add(prefix); \n    System.out.println( prefix); \n   } \n    \n   for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solving the problem for the case of unique words of any length:  Also see: gist [dot] github [dot] com/kastur/6477508"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Total number of subsets of a given set is 2^n. In this case n is the length of the string. If repeated character is not allowed then n = n-Number_of_Repeated_Character"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A_9_1-3 + A_9_2-3-A_9_3-3*(C_7_1*C_3_1)........... seems too complicated"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Isn't this a simple permutation? So this means it's factorial of length of \"EFFICIENT\" = 9! = 362880"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"I think the answer is 9!/2"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6005446611566592","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"40","title":"Given a server that has requests coming in. Design a data structure such that you can fetch the count of the number requests in the last second, minute and hour.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"- Use a queue implemented as a resizable array to store the timestamps of all new requests - maintain head/tail pointers as usual - Also maintain three pointers: ptr_last_1hr_from_tail, ptr_last_1min_from_tail, ptr_last_1sec_from_tail  Updates to the Queue: everytime a new timestamp is enqueued (added to tail): - continue dequeueing while(timstamp[head]-timestamp[tail] > 1hour) . this ensures that we dont continue to keep storing timestamps we dont need.  - set ptr_last_1hr_from_tail = head - decrement ptr_last_1min_from_tail until (timestamp[ptr_last_1min_from_tail] -timestamp[tail] > 1min) - decrement ptr_last_1sec_from_tail until (timestamp[ptr_last_1sec_from_tail]-timestamp[tail] > 1sec)  Fetch counts from Queue: On every new fetch request: - for last 1 hour count: set fetch_1hr_ptr to ptr_last_1hr_from_tail and decrement fetch_1hr_ptr wile timestamp[fetch_1hr_ptr]-fetch_timestamp > 1hr ;  - for last 1 min count: set fetch_1min_ptr to ptr_last_1min_from_tail and decrement fetch_1min_ptr wile timestamp[fetch_1min_ptr]-fetch_timestamp > 1min;  - for last 1 sec count: set fetch_1sec_ptr to ptr_last_1sec_from_tail and decrement fetch_1sec_ptr wile timestamp[fetch_1sec_ptr]-fetch_timestamp > 1sec ;  - req count in last 1hr  = (fetch_1hr_ptr-tail) - req count in last 1min = (fetch_1min_ptr-tail) - req count in last 1sec = (fetch_1sec_ptr-tail)  Depending on the nature of the request traffic, we could also use binary search when updating the various pointers instead of linear decrement."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The server requests is like a continuous input stream. For the time consider a moving window with 1 second or 1 minute or 1 hour as the size of the window. Consider last 1 second. Maintain a HashMap with key as the url and value as the count of the url requested. Begin time is the time from when we want last 1 second url requests. So from the log consider keep scanning till (time stamp for the request - begin time) <= 1 second. For every such request satisfying the time criteria, if new request add the url to a hashmap with count as 1 ; else increment the count for the existing matching url. Once a url is reached such that (time stamp for the request - begin time) > 1 second flush all the url and the counts onto some file and create a new HashMap."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A balanced binary tree such as AVL or red block and arrange nodes as per arrival time of request. Every node should also have a counter of no.of nodes rooted at the left child of that node.  Here all operations takes O(logn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use a max-heap and put the events as them come in. The latest event will be at the top. Time complexity is O(n log n) for inserts.  Then you can query the heap with max() in O(1) time and extract-max() in O(log n) time and get the events in last sec, min, or hour."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Problem statement says that query can be for last second, last minute or last hour. We have to maintain list for each window.  My Solution: --> Maintain a list of seconds, minutes, hour of size 60, 60 & 1 respectively.  Now, basically we have to run two operations: 1) Update all three array when user logs in. 2) Update all three array after each second. (All three array need not to be updated per second)  So array will be like: second[60] = {0,0,0,0...0} minute[60] = {0,0,0,0...0} hour[24] = {0}  Now 1st operation: (Simple) Whenever any user logs in, increment each arrays' 0th index. 0th index will always point to the last second, minute, hour.  Now 2nd operation: Keep updating newest & keep outdating oldest index values. This can be done by timeout operation. Timeout value is 1 sec:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Add request listener to track request."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Isn't it simpler to just store the timestamps of all requests from current time - hour up to current time in a queue?  You can create the a queue which contains all the timestamps as requests come in. Then every time interval say every 1millisecond remove all the timestamps in the head which is 1 hour old.   All you have to do to get the count is is peek from the head of the queue up to last the time stamp which is current queue timestamp > current time - hour/minute/seconds.   Or alternatively just create a score array say int score[3]  and update every millisecond by reading the queue as described above and update the counters."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use a RingBuffer of Size 3600, each element of the buffer is an int (or maybe an AtomicInt) and represents a counter for one second.  We'll have a variable for the current postion in the buffer, this will be used by readers to figure out where to start reading.  And by the writer to know when it's advanced and needs to set the current position's counter to 1.  On each update calculate the current postion: requests_time/1000 % 3600"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"One straight forward way may be: Maintain a LinkedList of nodes with  pairs. As requests come, keep adding to this linked list (sorted by timestamps).  Maintain 3 pairs of pointers.  1st pair of pointers = lastSecondStart, lastSecondEnd 2nd pair=lastMinuteStart, lastMinuteEnd 3rd pair=lastHourStart, lastHourEnd  After every second do below:  lastSecondStart = lastSecondEnd->next;  lastSecondEnd=move right to node by a 'second' using currentTime & node.timeStamp;   lastMinuteStart=move right to node by a 'second' using currentTime & node.timeStamp;  lastMinuteEnd=lastSecondEnd;   lastHourStart=move right to node by a 'second' using currentTime & node.timeStamp;  lastHourEnd=lastMinuteEnd;  Essentially 3 traversals to right. Num of nodes depends on num of requests in that second.  Caveats: 1.If there are not too many requests this works.  2. Concurrent requests can be handled by making add() method synchronized. But too many of these can tamper performance."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I already answered to this question.With respect to that answer some1 asked me that I missed synchronization and told if I use lock then it may degrade the performance that means all request can't be tracked per second."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we need a data structure that can handle this.  I would go with already synchronized data structures like hashtable. With keys as \"previous_hour\", \"pevious_minute\", previous_second\", \"current_hour\", \"current_minute\", current_second\". I will also have variables for current_hour, current_minute, current_second, new_hour, new_minute,new_second.  Every time, a request comes in check if new_second is different than previous, then update the map. Or increase the current counts."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am going to handle this in a controversial way, which is to use a HashMap to store the #requests for each second. Then to calculate the #requests for the past second, minute and hour, I only need 3,600 checks to the HashMap, which is O(1). The downside is that the HashMap can get big really fast, and so we might also want to throw in some code to remove any obsolete keys from it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question is ill-formed.  Not clear if they are asking for a continuous timeframe, or discrete time intervals.  Discrete time interval problem is solvable... continuous is not (on a real machine executing real machine instructions each cycle)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am thinking about a solution which behaves better in concurrent environment.  To lock less often and to save memory, I suggest that we keep the resolution say about 1%. This means we update the count each 10ms for the 1s number, each 0.6 s for the 1min and each 0.6 min for the 1 hour. The 1 min and 1 hour counts are just simpler variant of the same, so let's think only about the 1 sec timer.  We can have a AtomicLong count, to which it adds. When it realizes that 10ms has passed, it takes this count and sends it to a list with the timestamp, similarly to what others described. We can lock on sendToList, but usually there will be no concurrency because it happens just once in 10 ms. The \"optimistic locking\" in AtomicLong.compareAndSet takes care about the rest of the concurrency."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There is a very simple elegant solution to this using circular queue. Idea is to have a circular queue of size 3600*SamplesPerSec  At every sample interval, collect count till last sample and add it to circular queue.  - To get count of last 1 second, return sum of last SamplesPerSec  elements - To get count of last 1 minute, return sum of last SamplesPerSec*60 elements - To get count of last 1 hr, return sum of last SamplesPerSec*3600 elements  All operation like returning sum and purging old entries are O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Sorry for misspell .. I am not sure Google really asks so easy question? :P"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"import java.util.Date; \n \nclass RequestHandler { \n     \n    long counter = 0; \n     \n    synchronized void incrementCounter() { \n        counter++; \n    } \n     \n    long getCounter() { \n        return counter; \n    } \n     \n} \n \n \n \nclass Request implements Runnable { \n     \n    RequestHandler handler = null; \n     \n    Request(RequestHandler handler) { \n        this.handler = handler; \n    } \n \n    @Override \n    public void run() { \n        this.handler.incrementCounter(); \n    } \n     \n} \n \n \n/** \n *  \n */ \npublic class ThreadTest { \n     \n    static final long MAX_REQUEST = 18000; \n     \n    public static void main(String ... args) throws InterruptedException { \n        RequestHandler handler = new RequestHandler(); \n         \n        long start_time = new Date().getTime(); \n        System.out.println(\"Before request thread(s) creation .....\"); \n        //System.out.println(\"Start time : \" + start_time); \n         \n        for(long i = 0; i < MAX_REQUEST ; i++) { \n            new Thread(new Request(handler)).start(); \n        } \n         \n        long end_time = new Date().getTime(); \n        System.out.println(\"Immediate after request thread(s) creation .....\"); \n        System.out.println(\"Duration : \" + (end_time - start_time)); \n        start_time = end_time; \n        System.out.println(\"Request Counter : \" + handler.getCounter()); \n         \n        Thread.sleep(1000); \n         \n        end_time = new Date().getTime(); \n        //System.out.println(\"After one minute of request thread(s) creation.....\"); \n        //System.out.println(\"Duration : \" + (end_time - start_time)); \n        //System.out.println(\"Request Counter : \" + handler.getCounter()); \n    } \n     \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5598833467719680","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"38","title":"Given an 8x8 chess board, you have a bishop that moves from the current to the target position. write a code to find the minimum path from the current to the target position.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"If I were in an 45 min interview I would have used a Graph Representation of the problem. So, I would have created a Graph in which each Node correspond to a single square (x,y) and two nodes A,B are connected if a bishop can directly move from A to B (and viceversa),ie, they are in the immediate diagonal of one another. So, in a chess board, this Graph will have 32 nodes because the Bishop can only move in half of the chess board (all whites or all blacks).   So, suppose the chess board is 4x4. The graph will look like this:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Unless I'm misunderstanding this problem, the algorithm part is way simpler than most of these answers are making it out to be.  As long as the board is empty, bishops moves are trivial.  Simply rotate the chessboard 45 degrees in your mind, so that the corners are oriented horizontally & vertically.  Next, decompose the board into two subboards, one made up of white squares & the other of black ones, since a bishop can only move on one subset.  We now have two diamond-shaped boards, each containing 32 squares in the format (row length ordered top to bottom) 1, 2, 3, 4, 5, 6, 7, 8, 7, 6, 5, 4, 3, 2, 1, where our bishops move either side to side or up and down, just like rooks.  The question is now equivalent to asking how a rook can move from one location to another in the fewest moves, which is simple - would you ever use Djikstra or any graph to move a rook?  If not, you shouldn't use it to move a bishop, the problems are isomorphic under this transformation.  If the \"rooks\" are on different boards, there is no path.  If they are on the same board, then if they are on the same row or column, it is a single move.  If they are not, then there are 2 options: move up/down then left/right or vice versa.  This algorithm is very fast, but the direct translation into code is not particularly short, due to the transformations into and out of \"bishop coordinates\", and there are plenty of gotchas on the math.  I'm not claiming this is the simplest solution to code, but it establishes that the answer is always either \"impossible\", 0, 1, or 2 moves; and gives you direct calculations for which the answer is, and what the moves are (if any)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Represent each square with a point (x,y) where both x and y integers.  0 <= x,y <=7. Possible moves of bishop can be represented as two lines y=x+c and y=-x +c. Similarly possible moves from destination can be represented as two lines. Find the intersection of lines. Check if solution point, say (a,b) is in acceptable limit or not. a,b both should be integers also and 0<= a,b <= 7"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"For an 8x8 board, you will always reach from source to target in maximum of 2 moves. So we can determine whether a location is black or white in O(1). A bishop in \"Black\" box will never be able to move to target lying in \"White\" box.  For move=1, this can be determined whether abs(x1-x2) == abs(y1-y2) Rest all cases will always have move=2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"find the difference b/w the horizontal co-ordinates (say h) n also for vertical coords (say v). if (v==h)                //a diagonal path to the target moves=1; path= diagonal  else      //bishop will cover min(h.v) diagonally and the remaining in a straight line. moves=2; path=diagonal+ straight line to the target"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can we assume that there are no other pieces on the board that might be in the way of the bishop movement?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"All the possible movement lines of the Bishops on the board can be described by 2 set of lines, namely: y = x + c1 y = -x + c2  We have 2 points (x1, y1) i.e. start and (x2, y2) i.e. end  I've given a pseudocode, assuming there are no pieces which could block the shortest path."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is not a difficult problem. Two simple observations can lead us to an optimal solution  1. For a given location (i,j) of bishop, the next possible moves will have locations (i+k, j+k) ,where k=1 or -1 2. if (srcI, srcJ) is the source location and (tgtI, tgtJ) is target location then AbsoluteValue(srcI-srcJ) and AbsoluteValue(tgtI-tgtJ) must both be even or both be odd to be considered as valid moves.  3. This leads us to a simple recursive solution where we can trace the path from the source to the target by incrementing or decrementing x and y coordinates values(and at the same time checking that we lie within the boudaries).  Follows is a complete implementation: The source and target locations can be given as: 1 1 8 8"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I somehow feel that this should work but it is not working for all the inputs,howeever if you anyone has some corrections to make in this code than i WILL really appreciate."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the following works:  1- Start from the target cell  2- label all diagonal cells immediately around it as 1 (i.e. distance 1) 3- Now take all cells with distance 1 and label all diagonal cells immediately around them that are not yet labeled as 2.  4 - Continue until the entire board is labeled   5 - Now start with the starting cell.  6 - Pick a surrounding cell that has distance smaller than that of the starting cell. 7 - from that cell, again select one neighbor that has a smaller distance than the current cell. 8 - continue until you get to the target  Here is the code (that probably can be simplified by a bit):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Would this be a worthy solution?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If its a phone interview, simple recursion with visited mark on all visited cells should do..  Here is pseudo code:  ================"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include  int findPos(int src,int dest) {  int flag = 0,arr[8],temp=0,i=0,j=0,diff=0,min=65;  static int count,k,valid[64];     do{    ++count;   i=0;    if((src % 8 == 3)||(src % 8 == 4)||(src % 8 == 5)||(src % 8 == 6))   {    temp=src-(8*2)-1;    if(temp > 0)     arr[i++]=temp;        temp=src-(8*2)+1;    if(temp > 0)     arr[i++]=temp;          temp=src-8+2;    if(temp > 0)     arr[i++]=temp;          temp=src-8-2;    if(temp > 0)     arr[i++]=temp;          temp=src+(8*2)-1;    if(temp > 0)     arr[i++]=temp;          temp=src+(8*2)+1;    if(temp > 0)     arr[i++]=temp;        temp=src+8+2;    if(temp > 0)     arr[i++]=temp;        temp=src+8-2;    if(temp > 0)     arr[i]=temp;    }    else if((src % 8 == 0)||(src % 8 == 7))   {    temp=src-(8*2)-1;    if(temp > 0)     arr[i++]=temp;         /*temp=src-(8*2)+1;    arr[i++]=temp;          temp=src-8+2;    arr[i++]=temp;*/          temp=src-8-2;    if(temp > 0)     arr[i++]=temp;          temp=src+(8*2)-1;    if(temp > 0)     arr[i++]=temp;      /*    temp=src+(8*2)+1;    arr[i++]=temp;     temp=src+8+2;    arr[i++]=temp;*/     temp=src+8-2;    if(temp > 0)     arr[i]=temp;       }    else if((src % 8 == 1)||(src % 8 == 2))   {/*    temp=src-(8*2)-1;    arr[i++]=temp;     */    temp=src-(8*2)+1;    if(temp > 0)     arr[i++]=temp;          temp=src-8+2;    if(temp > 0)     arr[i++]=temp;      /*    temp=src-8-2;    arr[i++]=temp;          temp=src+(8*2)-1;    arr[i++]=temp;*/          temp=src+(8*2)+1;    if(temp > 0)     arr[i++]=temp;        temp=src+8+2;    if(temp > 0)     arr[i]=temp;        //temp=src+8-2;    //arr[i]=temp;   }   min = 65;   for(j=0;j<=i;j++)   {    if((arr[j] < 1)||(arr[j] > 64))     continue;    if(dest > arr[j])     diff = dest - arr[j];        else if(dest < arr[j])     diff = arr[j] - dest;        else     return count;        if((diff < min)&&(valid[arr[j]]!=1))    {     min = diff;     src=arr[j];     valid[arr[j]]=1;     flag=1;    }   }    //src=min;     }while(flag == 1); }  int main() {  int src=0,dest=0,count=0;   printf(\"\\nEnter what is your source and destination : \");  scanf(\"%d %d\",&src,&dest);   count=findPos(src,dest);  printf(\"\\nTotal number of counts : %d\",count);   getch();  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Graph with each square (x,y) as vertex and cost of edge((x,y),(x+/-1),(y+/-1))=1 and other edge costs are INT_MAX.  Use single source shortest path algorithm to find the shortest from (x,y) to (l,k) ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it's really not a programming problem, it is a MATH problem. if you try a to move a bishop from (a,b) to (c,d), and only allowed to move to the adjacent position, then then minimum steps required is min(abs(a-c), abs(b-d)). Of course when you play chess, you do not have to move only to the adjacent position, so at most 2 steps is required to move from (a,b) to (c,d)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static List shortestPath = new List(); \n        public static void ChessMoves(bool[,] matrix, int startX, int startY, int endX, int endY, List path) \n        { \n            ChessMovesInternal(matrix, startX, startY, endX, endY, path); \n            foreach (string p in shortestPath) \n                Console.WriteLine(p); \n        } \n        public static void ChessMovesInternal(bool[,] matrix, int startX, int startY, int endX, int endY, List path) \n        { \n            if (startX< 0 \n                ||  startY <0 \n                ||  startX>=matrix.GetLength(0) \n                ||  startY>=matrix.GetLength(1) \n                ||  matrix[startX, startY]) \n            { \n                return; \n            } \n            if (startX == endX && startY == endY) \n            { \n                path.Add(endX + \", \" + endY); \n                if (path.Count < shortestPath.Count  \n                    || shortestPath.Count ==0 /*no path found yet*/) \n                { \n                    shortestPath = new List(); \n                    foreach (string p in path)  \n                        shortestPath.Add(p); \n                } \n                path.Remove(endX + \", \" + endY); \n                return; \n            } \n            List nextStep = new List(); \n            nextStep.Add(new int[] { startX - 1, startY - 1 }); \n            nextStep.Add(new int[] { startX + 1, startY + 1 }); \n            nextStep.Add(new int[] { startX - 1, startY + 1 }); \n            nextStep.Add(new int[] { startX + 1, startY - 1 }); \n \n            matrix[startX, startY] = true;//visited in this path \n            path.Add(startX + \", \" + startY); \n            foreach (int[] nextStart in nextStep) \n            { \n                ChessMovesInternal(matrix, nextStart[0], nextStart[1], endX, endY, path); \n            } \n            path.Remove(startX + \", \" + startY); \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's my O(1) code in java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Just use a DP Algorithm will solve this problem. Initiate a 8*8 matrix, start from the target position and use BFS to update the path in each possible position."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6430339136225280","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"13","title":"Design an API that will support constant time add, remove, search and random find operations.  Random find will get a random number and return that element.  Note: Only hash map will not be sufficient since it cannot support random read.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"12","title":"A hash table + an array that contains all the keys. The order of the keys stored in the array is not important  add  - we insert the key of the element at the end of the array (push_back).  - the element is then added in the hash table.  - we also keep in the hash table the position where the key was stored in the array  remove - from the hash table we determined the position where the key of the element is stored in the array. We need then to removed it (this will create a hole). We move then the last key from the array to the position of the removed key. Of course, we need to update the position which was stored in the hash table (for this last key). - then we do the \"normal\" removal from the hash;   getrandom - since all keys are stored in the array, it's really easy to determine a random key ( array[rand() % array.size()]. we then return the random element from the hash table"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"This is an implementation using two Hash Tables that has an approximate complexity of O(1) for every operation (Add, Remove, Search and Random) if the Hash Tables are well implemented (good hash function and load factor).  The Hash Tables are: map1: Key(string)->(Value(int), Index of map2 (int))  map2: Key(int)-> Value(string)   The Key of map2 represents an index (from 0 to size of data-1) and its value maps with Key of Map1.   Below you can see the C++ implementation (I used STL  for Hash Table), and assumed the Key is a \"string\" and the value is an \"int\"."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"add remove search what? in a tree, array of Structure, Linked list...?? please make it clear..:-)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about LRU cache ? I think LRU cache using hashtable and Doubly linked list has O(1) insert, delete, search and random search too."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4812957531766784","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"15","title":"Given a family tree for a few generations for the entire population and two people write a routine that will find out if they are blood related.  Siblings are blood related since they have the same parents.  Cousins are blood related since one of their parents have the same parents etc.  Design the data structure first and then write the routine.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"The data structure to store the generation tree will have nodes defined as \n \npublic class Person { \n String name; \n ArrayList children = null; \n Person parent1; \n Person parent2; \n \n public Person(String personName, Person personParent1, Person personParent2) { \n  name = personName; \n  children = new ArrayList(); \n  parent1 = personParent1; \n  parent2 = personParent2; \n } \n public Person getParent() { return parent; } \n} \n \nFor 2 persons to be blood related, perform a Breadth First Traversal with the person as root and the parents as child nodes and store in a ArrayList. \nThen for both the persons search is there is a common parent in the ArrayList. \nIf common parent found then, the persons are related, else not related."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Let's call the first generation individuals root. For each individual in the population, maintain a reference to the list of his/her ancestor roots. If two individuals share an ancestor roots, then they are blood related (at the very least, they share the blood of their common root ancestor) If two individuals are blood related, then any root ancestor of their LCA (Lowest Common Ancestor) is a shared ancestor root.  Space: N (population size) * K (roots population size) Time: K (intersection of two sorted lists of size at most K)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just rephrased problem of finding common ancestor of two nodes in a tree (an easy version, since there is parent pointer). Don't believe that Google asks such an easy questions"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In the worstcase wont the root of the tree be the \"LCA (least common ancestor)\" of any 2 nodes in the tree? Wouldn't that mean that 2 people are ALWAYS related somehow?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it is a graph, because two parents ... depends on the assumption, there can be many solutions."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First anonymous has it right, except I think you can make it more efficient by performing a dual BFS concurrently, and checking at each stage whether the next element to be processed exists in the set of ancestors of the other person:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since we have the liberty of making the data structure , I will go like this   struct {  node *par1;  node *par2;  int magicnumber; } node; par1,par2 are obvious. While filling in the data , who is child of whom etc, you leave magicnumber as 0; No lets say you get n queries for siblings or not.   for(i=0;i{  input(node1,node2);  findsiblingsornot(node1,node2,i); } in findsiblingsornot() i serves as the query number or the magic number. Do a BFS/DFS using node1 as you like and fill magicnumber=querynumber in nodes you meet; Next try to do BFS/DFS with node2 and if you get any node with magicnumer=i , you are done :)  Space here is just the space required to create DS. (if you still are considering extra space then its O(n). Time is O(N) too.  You dont need to worry about clearing up after your calls to the function.  Next time you call, you call with bigger magic number."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Isn't this same as lowest common ancestor?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is actually a \"connected components\" problem. The \"family tee\" is actually a DAG and If two persons belong to the same connected component they are blood relatives."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5388826746814464","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"8","title":"Given multiple stream of input numbers each of which may not fit in memory (we can assume each source to be individually sorted) give an API design to merge and store a fully sorted array. Design must be object oriented which can handle any number of input source types.  Obviously output also cannot fit in memory.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"en.wikipedia.org/wiki/External_sorting#External_merge_sort  Read one item at a time from each input stream and put them in a min-heap."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think, why don't we  use TreeSort, which sorts automatically, when the input data comes in and its also a Dynamic Array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"N = input sources \n \nint A[N]; \n \nfor( int i = 0; i < N; ++i ) \n \n{ \n \n    int ret = readNextValue( i, &A[i] ); \n \n    if( ret == NO_MORE_INPUTS ) \n \n    { \n \n        A[i] = MAX_INT; \n \n    } \n \n} \n \nint min_index; \n \ndo \n \n{ \n \n    min_index = 0; \n \nfor( i = 1; i < N; ++i ) \n \n{ \n \n    if( A[i] < A[min_index] ) \n \n    { \n \n        min_index = i; \n \n    } \n \n}    \n \n    if( A[min_index] != MAX_INT ) \n \n{ \n \nwriteIntoSortedArray( A[min_index] ); \n \nint ret = readNextValue( min_index, &A[min_index] ); \n \n    if( ret == NO_MORE_INPUTS ) \n \n    { \n \n        A[min_index] = MAX_INT; \n \n    } \n \n} \n \n} while( A[min_index] != MAX_INT );"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question here is asking for an API design and makes references to Object Oriented and accepting different types of streams.  This is much less about external sorting techniques and more creating a reasonable interface."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"k-way merge will work only if we are able to read one input from all the k input streams and store it in a min-heap ,  but will fail if k is very very large and memory is less to accomodate even a k-sized heap."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5683135085805568","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"27","title":"Given a sequence of numbers such that A[0] >= A[1] and A[N-1] >= A[N-2] find at-least one triplet such that A[n-1] >= A[n]  <= A[n+1].  Better than linear time is expected.  Example: 9 8 5 4 3 2 6 7 Answer: 3 2 6","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"9","title":"The question could definitely be worded more precisely, anyways here is a very nice explanation. \nFirst we need to understand that if in an array of unique integers first two numbers are decreasing and last two numbers are increasing there ought to be a local minima. Why so? We can prove it in two ways. First we will do it by negation. If first two numbers are decreasing, and there is no local minima, that means 3rd number is less than 2nd number. otherwise 2nd number would have been local minima. Following the same logic 4th number will have to be less than 3rd number and so on and so forth. So the numbers in the array will have to be in decreasing order. Which violates the constraint of last two numbers being in increasing order. This proves by negation that there need to be a local minima. \n \nWe can prove this in some other way also. Suppose we represent the array as a 2-D graph where the index of the numbers in the array represents the x-coordinate. and the number represents the y-coordinate. Now for the first two numbers, derivative will be negative, and for last two numbers derivative will be positive. So at some point the derivative line will have to cross the x axis. As the array contains only unique elements there cannot be a derivative point on the x axis. Because that will mean that two consecutive index having same number. So for any intersection of x axis by the derivative line will be a local minima. \n \nWe will solve this problem in O(log n) time by divide and conquer method. We will first check the mid index of the array. If it is smaller than its left and right, then it is the answer. If it is bigger than the left number then from start to left we have a subproblem, and as we proved already that starting with decreasing and ending with increasing sequence array will have to have a local minima, we can safely go to the left subarray. Otherwise if mid is bigger than its right, then we go to the right subarray. This way we guarantee a O(log n) algorithm to find any of the local minima present in the array. \n(copied from dsalgo dot com (find-local-minima))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"The question could be worded better, but the idea I think is that the numbers exclusively decrease until a certain point where they exclusively increase. There is only one such point in the array. We need to find that point, and we need to do it in better than O(n) time.  So lets use binary search. Cut the array into two parts. For the first half, check the last two elements. Is it still decreasing? if so, forget that half. recursively search in the second half. When you find the increasing part, keep that half and resursively search it.  Eventually you should find the point where it goes from decreasing to increasing, and this will take logn time.  The difficult is that the questions states greater than/equal, and not just greater than. So its possible to have 9, 8, 5, 4, 3, 3, 3, 3, 3 as an input value, and the algorithm proposed above will end without finding the spot where it starts increasing. however, the spot that you found should still be the center point of a valid return triplet."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"*O(log n) time complexity*"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void printTriplet(int[] array) { \n if(array == null  || array.length == 0) { \n  System.err.println(\"Empty array\"); \n  return ; \n } \n int index = getTriplet(array, 0, array.length -1 ); \n if(index == -1) { \n  System.out.println(\"No such triplet found\"); \n  return; \n } \n System.out.println(\"The required triplet is \" +  \n     array[index-1] + \", \" + \n     array[index] + \", \" + \n     array[index + 1]); \n} \n \npublic int getTriplet(int[] array, int lower, int upper) { \n if(lower >= upper) return -1; \n int middle = lower + (upper - lower)/2; \n if(array[middle - 1] >= array[middle] && array[middle + 1] >= array[middle]) \n  return middle; \n int index = getTriplet(array, lower, middle); \n if(index != -1) return index; \n index = getTriplet(array, middle + 1, upper); \n if(index != -1) return index; \n return -1; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"agree with GeekTycoon.. idea is gud but it does hav O(n) time cplxty since it scans both side"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void findTriplet(int lower, int array[]){     while(lower    if(array[lower]>=array[lower+1]&&array[lower+1]<=array[lower+2]){         System.out.println(\"Triplet is \"+array[lower]+\" \"+array[lower+1]+\" \"+array[lower+2]);         return;     }     lower+=2;     }     findTriplet(1,array); }  public static void main(String[] args){     int[]array= {9, 8, 6, 7};     findTriplet(0,array);     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class findTriplet { \n \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n  // TODO Auto-generated method stub \n  int arr[]={9, 8, 5, 4, 3, 2, 1, 7}; \n     int n=arr.length; \n        int i=findTriplet(arr,0,n-1); \n        if(i==-1) \n        { \n         System.out.println(\"No triplet exists\"); \n        } \n        else  \n        { \n       System.out.println(\"Triplet exists and it is \\n\"); \n       System.out.println(arr[i-1]+\" \"+arr[i]+\" \"+arr[i+1]); \n        } \n } \n \n public static int findTriplet(int arr[], int low, int high) { \n  while (low <= high) { \n   int mid = (low + high) / 2; \n   if(mid-1<0||mid+1>high) \n   { \n    break; \n   } \n   if (arr[mid-1]>=arr[mid]&&arr[mid]<=arr[mid+1]) { \n    return mid; \n   } else if (arr[mid-1] < arr[mid]) { \n    high = mid - 1; \n   } else { \n    low = mid + 1; \n   } \n  } \n  return -1; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Binary search - just need to decide to which side to recurse, based on values of the neighbors. Returns the index of the \"bottom\" or -1 if it doesn't exist."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"The triplet can be found out by using binary search in the following way. You can test the below code:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5200260502650880","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"26","title":"Find the majority number in a given sequence of numbers (a number that occurs more than N/2 times where N is the count of numbers in the sequence).  Don't maintain a map of all occurring numbers along with a count.  No number may be a majority.  Example: 1 1 2 3 4 1 6 1 7 1 1 Majority number is 1 since it occurs 6 times (> 11/2)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"maintain a counter and store the current number. If next number is same increment the counter, if different then decrement counter. If counter becomes zero, then store the next number as current number and set counter to 1, like a fresh start. After itertation is done, you will be left with a current number. Traverse the array once more to check if it is really majority or not. O(n) complexity."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"O(N) with median: We can find median in O(N) using the partition method from quicksort. A majority number must be the median.  Next step is go once more through the array and check the count of the median (this step is the same as the voting algorithm)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Thanks to share \"voting algo\", it's really number magic But I have concern, I think \"voting algo\" only works if existence is >= N/2 otherwise how it will find less than N/2 occurrence and returns null element.  \"Voting Algo\" also works for no sequential number.  Q. says the numbers are sequential and occurrence may be less than N/2, so I can use a mapping but in a different way ...not exactly map  numbers starts from 1 then maintain N sized array put the number count according to number in that corresponding index like 1->0, 2->1... when a count reaches >= N/2 then stop  but will google allow this ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void majority()         {             int[] arr = { 1, 1, 2, 3, 4, 1, 6, 1, 7, 8, 1, 1, 2 };             int mjr = 0;             int cnt = 0;             int maxmjr = 0;             int maxcnt = 0;             for (int i = 0; i < arr.Length; i++)             {                 if (cnt == 0) mjr = arr[i];                 if (mjr == arr[i]) cnt++;                 else cnt--;                 if (cnt > maxcnt)                 {                     maxmjr = mjr;                     maxcnt = cnt;                 }             }              cnt = 0;             for (int i = 0; i < arr.Length; i++)             {                 if (maxmjr == arr[i]) cnt++;             }              if (cnt > arr.Length / 2) Console.WriteLine(maxmjr + \" \" + cnt);         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void majority() \n        { \n            int[] arr = { 1, 1, 2, 3, 4, 1, 6, 1, 7, 8, 1, 1, 2 }; \n            int mjr = 0; \n            int cnt = 0; \n            int maxmjr = 0; \n            int maxcnt = 0; \n            for (int i = 0; i < arr.Length; i++) \n            { \n                if (cnt == 0) mjr = arr[i]; \n                if (mjr == arr[i]) cnt++; \n                else cnt--; \n                if (cnt > maxcnt) \n                { \n                    maxmjr = mjr; \n                    maxcnt = cnt; \n                } \n            } \n \n            cnt = 0; \n            for (int i = 0; i < arr.Length; i++) \n            { \n                if (maxmjr == arr[i]) cnt++; \n            } \n \n            if (cnt > arr.Length / 2) Console.WriteLine(maxmjr + \" \" + cnt); \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public int getMajorityNumber(int[] inputArray) { \n if(inputArray == null || inputArray.length == 0) { \n  System.err.println(\"Empty array\"); \n  return -1; \n } \n int maxCountNumber = inputArray[0]; \n int count = 1; \n for(int i = 1 ; i < inputArray.length; i++) { \n  if(inputArray[i] == maxCountNumber) count += 1; \n  else { \n   if(count > 0 ) count -= 1; \n   else { \n    count = 1; \n    maxCountNumber = inputArray[i]; \n   } \n  } \n } \n return maxCountNumber; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Google for Moore??s Voting Algorithm"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"yes... in the first iteration you are finding which element is repeated maximum times In the second iteration you checking its majority...  Excellent solution.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"First sort the array and then check if the adjacent elements are same.If yes then increment the count everytime and whenever a the count is greater than n/2 then print the element.Here us the code."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"can we do this... 1.maintain a hash while scanning input and check for n/2 condition and report.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"O(n) to find the median."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"moore's voting not working on this input 1142113211456"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"public int getMajorityNumber(int[] inputArray) { \n if(inputArray == null || inputArray.length == 0) {  \n  System.err.println(\"Empty array\");  \n  return -1;  \n } \n int maxCountNumber = inputArray[0];  \n int count = 1;  \n for(int i = 1 ; i < inputArray.length; i++) {  \n  if(inputArray[i] == maxCountNumber) count += 1;  \n  else {  \n   if(count > 0 ) count -= 1;  \n   else {  \n    count = 1;  \n    maxCountNumber = inputArray[i];  \n   }  \n  }  \n } return maxCountNumber;  \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5361081258082304","download_status":"DOWNLOAD_DONE","votes":"-7","answersCount":"22","title":"Given a file with a set of space separated numbers in a file write a program to remove duplicate rows.  Two rows are duplicate if they contain the same numbers regardless of the order in which they occur.  Constant time algorithm expected.  LogN time is not good enough.  Given file: 1 2 3 4 5 3 6 7 8 9 2 4 7 1 5 3 2 4  Answer expected: 1 2 3 4 5 3 6 7 8 9 2 4 7","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"What do you mean by constant time ? Just to read file with N lines and with K elements in each line you have to do O(N*K) operations. Looks like you didn't understand the problem correctly dude. Big minus for this."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Did anybody think about XORing as alternative and length?  I already have a counterexample.. row 1 : 1 3 3 5   same length and same xor as row 2.   row 2 : 1 4 4 5"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Are there any assumptions on the range of the numbers (for example - all are from [0,255] ?)  If so we can store a frequency array (which is const size) for every row as it's hashcode.   2. It is impossible to read the whole file in less then O(N)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i don't think it is possible. to solve this question, we need to go compare every 2 lines. there are (n C 2) lines to compare. Assume that we can check if 2 lines are identical in constant time and n = total number of lines. The complexity of this question O(n^2)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First, create a large table of prime numbers {P1, P2, P3, ... Pn} (where n is larger than the largest number you will encounter)  Second, when you encounter a line with the numbers {a b c d}, multiply together the numbers Pa, Pb, Pc and Pd and store in a hashtable.  When you encounter another line with the numbers {b d c a} and multiply then primes together, you will find that the entry already exists in hashtable, in constant time"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can we make each line as String by removing the space. Use HashSet to save whether that line has been or not. The trick is how to construct the Key. Take the idea of Anagrams.  {c, b, a, d} => tempStr: cbad==>sort tempStr: abcd {d, a, b, c} => tempStr: dabc ==>sort tempStr: abcd."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Maintain a hashmap, where key is the sorted line. e.g if a line is \"3 2 6 1 4\", it will be treated as \"1 2 3 4 6\" in hashtable.  Now, for each line: 1. sort it 2. lookup in hashmap 3. if it is not present, then enter it in hashmap and output it 4. if it is present, then don't do anything and continue to next line."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Two lines are equal if there sum and product of the numbers match. Start scanning each line of the file, for every line store the sum and product. Print the line, whenever a new line with already seen sum and product occurs move to the next line."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Good one. Will storing sum and sum of squares also work? Just wondering.."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5711103912837120","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"23","title":"Given 7 letter tiles and a dictionary of valid words, return the set of words that can be generated using 1-7 of those tiles. Example: letter tiles: SAPAPER word dictionary: A AA AAA APE PEA PARE PEAR FEAR SPARE APPEARS REAPPEARS would return: A AA APE PEA PARE PEAR SPARE APPEARS","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"You could build a trie from the input dictionary, and at each square do an exploration of the trie, selecting all words that can be reached by consuming additional characters while traversing down the trie."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"1. Put each letter tiles to the hashtable. Characters are keys and the character counts are values. 2. for each word in the dictionary dictionary  2.a. for each character in the word    check if the character is in the hashtable as well as how many times it is used    if it doesn't next word   print the word if all the characters of the word exist in the dictionary"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If I get the problem right, for any given tile we need to: 1. Generate all available subsets (2^7) 2. For every generated subset longer than 1 char generate all possible permutations (k! where k is subset size) 3. Hit the dictionary with every permutation to verify if it's valid.  If dictionary size is much smaller than number of tiles, we might want to do inverse procedure: 1. Covert tile into multi-set. 2. For every word from dictionary, remove char by char from multi-set verifying the removal was successful."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we can decrement the count each time the character matches and print the word if all the counts>=0. but in this case we'll have to construct the hast table again. complexity O(n^2) Does anyone have a better solution?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Build a hash-table containing the count of each letter for the given seven letter tile. 2. Traverse a word in dictionary, keep incrementing the count of the current letter in another hash-table. 3. If the count of that letter exceeds from the original hash-table count, repeat step 2. 4. If the word is traversed fully without satisfying step 3, append it to the set. 5. repeat step 2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Above solutions are more or less right, but the approach is maintaining HashTable (key is the tile letter and it's count, which is important to track repetition count)  I think, the trick is whole dictionary should not be traversed, we can maintain a BST so that intelligently we can decide which branch we should not traverse.  Guys is it possible ? I just guessed it ..... ;)  NB : n^2 solution won't be acceptable"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"One one more approach that clicks on my mind: 1. Sort the title (this is one step process) (since words are very less in size, we can go with insertion sort which is very fast in this case) 2. For every word in dictionary     a. If the word is greater than 7 letters, ignore this word and go for next word     b. Sort this word     c. Check this word is substring of title"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Code here : ideonecomvprTnw      Finding all possible permutation on the text entered."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think it's worth noting that all permutations are:  # of 7 tile permutations + # of 6 tile permutations + # 5 tile permutations + ... + #1 tile permutations  or  7! + 6! + 5! + 4! + 3! + 2! + 1!.  Let's just say the upper bound is : 7 x 7! ~ 35280, that's actually pretty small.  Let's just create all permutations of all possible words and look them up in the dictionary."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The Ternary Search Tree (TST) is perfect for this job. Assuming the dictionary is perfectly balanced, the order of complexity is pretty quick :-). The following algorithm allows for using character \".\"as a wildcard. The find() method accepts the string of letters to search and the minimum and maximum words required from the dictionary. This algorithm assumes TST already built with root node.  isGreater() and isSmaller() can be optimized maybe by using a LinkedList instead of Array to store the frequency of characters."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public ArrayList find(char[] tile, Set dic) {  ArrayList res = new ArrayList();  boolean[] check = new boolean[tile.length()];  char[] list = new char[tile.length()];  Arrays.sort(tile);  help(res, dic, tile,check, list, 0);  return res; } public void help(ArrayList res, Set dic, char[] t, boolean[] check, char[] list, int level) {  if(level == t.length) return;  for(int i=0; i  if(check[i]) continue;   check[i] = true;   list[level] = t[i];   String str = ??£þ???;   for(int j=0; j<=level; j++) {    str += list[j];    if(dic.contain(str)) res.add(str);   }   help(res, dic, t, check, list, level+1);   check[i] = false;   i++;   while(i } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public ArrayList find(char[] tile, Set dic) { \n ArrayList res = new ArrayList(); \n boolean[] check = new boolean[tile.length()]; \n char[] list = new char[tile.length()]; \n Arrays.sort(tile); \n help(res, dic, tile,check, list, 0); \n return res; \n} \npublic void help(ArrayList res, Set dic, char[] t, boolean[] check, char[] list, int level) { \n if(level == t.length) return; \n for(int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would probably do mine using a couple arrays.  One array of the unique tile counts.  So SAPAPER would be { 2, 1, 2, 1, 1 }.  Then an array indexing into that array for each character (or a hashtable)..  { A->0, E->1, P->2, R->3, S->4 }.  Then for each word in the dictionary I would just go through the characters, quickly using my hash/array to count characters.  If the character in a word doesn't exist in my hash, or if the letter count is too high, it throws it out and moves on.  If I reach the end of the word without these problems then I add it to my solution set.  This solution has some benefits:  Simple to code, simple to understand, low memory overhead, short circuiting as words are traversed, O(n) time for the most part."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=19789662","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"11","title":"Employees in my company are complaining about elevator, saying its too slow...  Lift operates for 50 floors  I hire you and you have to tell me what is the problem and solutions to it.  Input: Motor can't be changed You can't get a new elevator as its too costly.  Get 5 matrices you would collect and how would you use them.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Matrices gathered can be: 1> Average number of employes using the lift during the peak times(morning time and evening time) 2> Age distribution of the employes using the lift at peak times 3> Average number of times the lift changes direction(moving up to moving down, moving down to moving up) 4>Floors where the crowd is more 5>Lift door open and closing time  By knowing the average number of people using lift at peak times, may be its worth suggesting to management to get another lift. With age  distribution, we can suggest young employees to use stairs if possible. The number of times the lift changes the direction, may be useful in improving the algorithm used by the lift for servicing requests. For crowded floors, may be there can be separate lift movements at specific times of the day serving these floors. Reduction in the door opening and closing timing may have some improvement."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just guessing: Maybe track how many floors each elevator is serving. That could be slowing down the process.    Algorithm that the elevator is using to figure in what order various floors are to be served, provided many people are requesting the elevator at once. May be we can work on the open and close mechanism of the door. Some old elevators do take a lot of time opening and closing the doors."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Anonymous (Question Poster) - How many years of experience you have??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Have music running or have some dynamic wallpapers in the lift which will keep the employees engaged will reduce some noise of lift being slow."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can design the lift programming using Priority Queue instead of plain queue"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Reason for being slow might be: 1) There are people getting in and out on every floor 2)Lift equipment might be in repair  Corresponding Solutions: 1)Make the lift stop only at alternate floors so that number of stoppings decrease and people have to take at most one floor stairs which is relatively better compared to waiting. 2)May be the motor could be repaired.  Others: Have a web portal or mobile app which tells when the lift stops at his floor when he gives from and to details so that he can reduce his time waiting"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Some of the matrices i can think of 1.Determine the capacity of motor first.. 2. How many people at once are currently travelling in lift.  Say if employees want it to reach the top-most floor after x seconds, then based on above two data we can set a limit on the number of people that should go  inside the lift at once/per floor. Maybe because more no of people are travelling at once its speed is less.  3.Average age of employees.. Say if most people are young encourage them to use stairs rather than lift.  4.Time duration at which lift is mostly used...so at  time of rush we can allow more people to travel but with info that lift would take more time..so either wait outside the lift or inside the lift :)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=19768663","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"6","title":"How would you design a movie search engine.  Think about both abstract and specific questions. How would you answer each of them.  ex: get me romantic movies, latest movies, movies with fight of no more than 10 mins.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Each movie is a object of a movie class with attributes like genre, name, review stars, length, list of review comments, etc..  Now store these movie objects into memory or secondary storage disk. Create hashmaps with the key as the attribute(genre, length, etc..) and value as arraylist of the object references. So there is one genres hashmap, one movie length hashmap, multipe lead actors hashmaps, etc..  The hashmaps can be maintained in memory.  Whenever a new movie object is created update the hashmaps.  For answering the queries have the corresponding hashmap look up."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In memory representation, is it a good idea ?  Maintain a DB with good data modelling like key words mapping and other attributes mapping which can give fast data access. NB: I would prefer auto ranking (number of hits by users), typically popularity  If user types keywords like romantic, latest, fight movie with specific time of comedy/action/romance or may be some other attributes. Then we need to translate into SQL syntax say for examples, romantic movies->search by keyword romantic latest movies->release date < sysdate order by release date (limit N) action  more than 10 minutes->typically romantic movie so on ...   If any search criteria missing then system has to update missing search criteria intelligently"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Also I mentioned in -memory considering that we can maintain the maps in memory for faster retrieval. Also database queries are slower than an in-memory look up, isn't it?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I hope, we can use B Trees. Each node will have more than 2 children. All node will represent keys. Depending on the key , it will fetch the movie."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=19787662","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"22","title":"How would you determine if ads clicks are coming through a human being or not (it could be a program, virus etc.)  Identify 5 parameters and how would you use each of them.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"we can use the \"no captcha\" technique.. in which humans cant see any captcha with naked eyes (invisible), so proceed with the normal procedure, while the computer detect a captcha n thus getting caught/identified as non human"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"A 3 step strategy can be used: 1> Real time filter on the date, time and range of IP addresses from where clicks to a ad link are originating 2> Offline analysis of the click ad log files over past days comparing the number of ad clicks for a particular ad link from range of IP addresses 3> Human and machine investigation into false ad clicks involving the company paying for the ad considering data from other ad networks, market conditions, etc.. as required."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"click postition within the button.  human click ad button more than once usually in different position, while robot  clicks usually in the same position."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why would someone click on an ad if there is captcha...already hardly anyone clicks on ads.....its bad for business....  i said this and immediately took back my words citing the same reasons...interviewer agreed...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Will monitioring the number of clicks from an IP be feasible? It might be more of analytics rather than run time check."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"there can be a online filter which inspects the traffic for the ads. The ads must not be clicked with much high rate and also there must be a peek time for the ads click for a particular region. Also not most of  the clicks should come from same IP."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Min time interval between clicks 2. From which ip/area(router) it is coming 3. max num of clicks in a given interval (~ 1 min) 4. If time intervals between clicks is regular(ex: equal could mean a bot) 5."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Test user agent.  Obviously CURL and HTTPUnit are pretty good tells that it is a machine, as is repeated requests from the same IP.  But user agent and IP (via Tor) can be spoofed.  So you'll need more.  Look at outliars from your empirical data to zone in on potential false positives."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Test user agent.  Obviously CURL and HTTPUnit are pretty good tells that it is a machine, as is repeated requests from the same IP.  But user agent and IP (via Tor) can be spoofed.  So you'll need more.  Look at outliars from your empirical data to zone in on potential false positives."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"As far as I understand the question, the question is about how would you identify if the ad being clicked is by a genuine user or a script / virus. Now for \"this\" question , I do not understand some of the solutions mentioned here. 1) The check for IP address is incorrect solution as for both the cases user/script the ip address would remain the same 2) People suggesting here to use some kind of captcha, click on this part of the ad, hold left mouse key for x seconds, press various key combinations : guys, the question is about how to \"differentiate\" between users and script from the click requests that have already come in, and not to \"avoid\" scripts.   Now I did like this solution : Look at which part of the ad is being clicked continuously by this IP. humans tend to click at different places.  But, to me the questions seems unanswerable as , if the script writer is intelligent enough, he would obviously know that his script should place clicks NOT at constant intervals but at random times and at random places of the ad.  So, this questions highly depends on what the interviews wants to ask you, assume script writer is not much intelligent and differentiate between clicks that have come already. OR avoid scripts."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"As far as I understand the question, the question is about how would you identify if the ad being clicked is by a genuine user or a script / virus.  Now for \"this\" question , I do not understand some of the solutions mentioned here.  1) The check for IP address is incorrect solution as for both the cases user/script the ip address would remain the same  2) People suggesting here to use some kind of captcha, click on this part of the ad, hold left mouse key for x seconds, press various key combinations : guys, the question is about how to \"differentiate\" between users and script from the click requests that have already come in, and not to \"avoid\" scripts.   Now I did like this solution : Look at which part of the ad is being clicked continuously by this IP. humans tend to click at different places.   But, to me the questions seems unanswerable as , if the script writer is intelligent enough, he would obviously know that his script should place clicks NOT at constant intervals but at random times and at random places of the ad.   So, this questions highly depends on what the interviews wants to ask you, assume script writer is not much intelligent and differentiate between clicks that have come already.  OR avoid scripts."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Probably before redirecting to actual add website ..use some sort of captcha.This captcha would come into picture once user clicks on add."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=19778663","download_status":"DOWNLOAD_DONE","votes":"5","answersCount":"54","title":"Given a set of numbers, find the longest subset with consecutive numbers be it any order.  Input: S = { 5, 1, 9, 3, 8, 20, 4, 10, 2, 11, 3}  we have 2 consecutive sets s1 = {1, 2, 3, 4, 5} s2 = { 8, 9, 10, 11}  Ans.  s1 = {1, 2, 3, 4, 5}","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"here is my answer to this question  1. Create a new hashmap. Its key will contain starting index of contiguous set and value be ending index of contiguous set. 2. Iterator through array. 3. Let each value be x. look for x-1 and x+1 in hashmap.  case1. there exists an entry for x-1, so update its value to x if x is greater than existing value  case2. there exists an entry for x+1, get its value, say vx and insert an entry with key as x and value as vx.   case 3. there exists an entry for x; simply ignore  case 4: insert into hashmap, key x and value x   Ex: S = { 5, 1, 9, 3, 8, 20, 4, 10, 2, 11}  5 => {  (5,5) } 1 => {  (5,5), (1,1)  } 9 => {  (5,5), (1,1), (9,9)  } 3 => {  (5,5), (1,1), (9,9), (3,3)  } 8 => {  (5,5), (1,1), (8,9), (3,3)  } 20 => {  (5,5), (1,1), (8,9), (3,3), (20,20)  } 4 => {  (5,5), (1,1), (8,9), (3,4), (20,20)  } 10 => {  (5,5), (1,1), (8,9), (3,4), (20,20), (10,10)  } 2 => {  (5,5), (1,2), (8,9), (3,4), (20,20), (10,10)  } 11 => {  (5,5), (1,1), (8,9), (2,4), (20,20), (10,11)  } 3 => {  (5,5), (1,2), (8,9), (3,4), (20,20), (10,11)  }  -> (ignored)  after array iteration is done, repeat step 3 with minor modifications by iterating over map again and longest set  will be with max diff b/w key and value.   Let key be k and value be x  case1. there exists an entry for x-1, so update its value to x if x is greater than existing value.  delete entry with key = k  case2. there exists an entry for x+1, get its value, say vx and update k's value to vx.  delete entry for with key = x+1.  repeat this step with x = vx      Now iterate over  {  (5,5), (1,2), (8,9), (3,4), (20,20), (10,11) } 5 => no action,  1 => update 1's value to 4 and  delete (2,4)  resulting in      {  (5,5), (1,4), (8,9), (20,20), (10,11)  }     repeat with x = 4        update 1's key to 5 and delete (4,5) resulting in        {  (1,5), (8,9), (20,20), (10,11)  } 8 -> update 8's value to 11 and delete (10, 11) resulting in       {  (1,5), (8,11), (20,20)  }        repeat with x = 11 -> no action 20 => no action       {  (1,5), (8,11), (20,20)  }  Haven't mentioned above, at each step we will maintain key-value pair with max diff.  So at the end of map iteration, we have result.  Complexit = O(n)...though I'm finding this complex..Is there a simplified way of doing this."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Sorting seems too obvious. If this is a legit Google interview question, I'd suspect there must be a better solution than O(n log n).  I can think of a linear solution, but it has a lot of assumptions; if the numbers are small positive numbers, let's say [0,31), then you can use a 32 bit integer and set the bits with the corresponding number in the int array. e.g., S = { 5, 1, 9, 3, 8, 20, 4, 10, 2, 11, 3} becomes binary digit: 00000000 00010000 00001111 00111110  Then you can check the longest contiguous set bit sequence. This is linear time, but the worst case is the length of the bit vector, not the array length. Similarly, you can use 64 bit number for [0,64), for bigger numbers, you'll have to use a bit vector or a bit set.  Note that this solution will only make sense, if the numbers are positive, small, and/or there are a lot of repetitions."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What is the expected time complexity? Sorting can get the job done easily in O(nlgn). Also, are there any pecularities about data that they all are +ve numbers and that they fall within a certain range, duplicates allowed etc etc?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int max_seq = 0; \nint start = 0; \nint end = 0; \nfor(int i = 0; i < l -1 ; i++) { \n  \n int current = a[i]; \n int next = a[i + 1]; \n  \n // first sequence match \n if (current + 1 == next) { \n  int tmp = max_seq; \n  max_seq = 2; \n  // check for further sequence \n  int k; \n  for(k = i + 1; i < l -1 ; i ++) { \n   current = a[k]; \n   next = a[k + 1]; \n   if (current + 1 != next) { \n    // sequence break \n    break; \n   } else { \n    max_seq++; \n   } \n   \n  // maximum info poulation \n  if (tmp > max_seq) { \n   max_seq = tmp; \n  } else { \n   start = i; \n   end = k; \n  } \n   \n } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I made a mistake..... So in that case we need to sort it first. This may require typical nlog(n) time then some more operations.  So alternate solution is to maintain a HashTable (provided if numbers may not be unique)  NB: If the numbers are not unique then above code fragment should be changed ( a[k] == a[k + 1] + 1 || a[k] == a[k + 1]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can we use a hash table? we'll take the smallest element from the array and add 1 to it, and will check whether hash table has new element or not. if it has we'll again add one to the new element and check. (here we got a set of consecutive numbers). When new element is not present, we'll take the next smallest element in the hash table and go on with the same process."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Declare a struct  struct consecseq{ int first; int last; }  Declare an array of this structure where elements will be stored in sorted order of first/last.  For every element in array;  1) Do binary search to find the position where to place the value 2) if currval == (structarray[i].start - 1), add this element and change the first. Check if this can be merged with structarray[i-1] if exists 3) if currval == (structarray[j].last + 1), add this element and change the last. Check if this can be merged with structarray[i+1] if exists 4) If none of above, add a new structarray element in the current position and move the later elements. 5) At the same maximum and index of maximum length should be maintained."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n) solution using hash-table Need to traverse the array twice 1. First, fill the array elements in the hash-table Now, start with the first element (say k),  2. Check if k is present in the hash-table. If not, go to the next element. 3. If yes, find the max n such that elements between k & k+n are all present in hash-table, and then remove them from the hash-table. 4. Similarly, find the max m such that elements between k-m and k are present in the hash-table and remove them from the hash-table. 5. Now we know a sequence which is present in the array. 6. Save k-m and the count (m-n) (this is the sequence found so far). Update the min_element and the count if m-n is larger than so far count. 7. Remove k from the hash-table. 8. Move to the next element in the array and repeat step 2 9. The largest sequence is : min_element, min_element+1, ..., min_element+count"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"After sorting the whole list  We need two pointers start and end ->n1, n2, n3 .................................. N<- For each start pointer move pointer from end once end number == start number + (start index + difference between and start and end index) terminate program  Here if the probability is too high of getting a maximum sequence this provides best solution. If there is too low probability then it does not provide then HashTable provides best solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n) solution traversing the list only *once*"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sites.google.com/site/spaceofjameschen/home/array/find-the-longest-subset-with-consecutive-numbers----google"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have implemented an algorithm with complexity O(n) using a Hash Table (I used STL \"unordered_map\") that only has to iterate over the array once, and has onl a max of 6 accesses to the Hash Table per iteration.   I have implemented other working versions of this functions with complexity O(n) (one of them using a bitset), but this is the one I like the most. Here is the C++ implementation:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I thought of this solution:  1. Create all the subsets and store the integer of each line in a set (disregarding order of integer values). Store each set to a list. Lets say call the list as         List> numberSubsetList = new ArrayList>(); 2. set int longestSetIdx = -1, currSetLen = -1, longestSet = -1 2. For each set in the list        a. set currSetLen = # of item in current set       a. get max and min while computing sum of integers (call the sum as totalVal)       b. based on max and min compute sum of consecutive numbers between min and max                       consecSum ((#of items in set)/2)*(max+min)       c. if totalVal = consecSum and longestSetLen < currSetLen then              longestSetIdx = index of set             longestSetLen = currSetLen     3. Return numberSubsetList.get(longestSetIdx)  Technically, this is O(N) disregarding of course the cost of populating numberSubsetList."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Everyone does really complicated stuff.... Here is an order n solution that is very easy to read (in Python)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"thanks for explaination dumbo"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. find the sequences in a hashmap with H[x] = x-1 if x, x-1 both are in the list, otherwise H[X] = 0, through one iteration of the set.  O(N)    for example:    { 5, 1, 9, 3, 8, 20, 4, 10, 2, 11, 3}   maps to : { 1->-1, 2->1, 3->2, 4->3, 5->4, 8->-1, 9->8, 10->9, 11->10, 20->-1} 2. reverse the map and also get the headers of the sequences, through one iteration of the original list.      new hashmap:  { 1->2, 2->3, 3->4,4->5, 8->9, 9->10, 10->11 }, with headers {1, 8, 20 }  (3) from each header find the sequences and return the longest one, iterate throght all numbers once. O(N)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First we can sort the array and then start a check from the first index, checking next index value that it is consecutive with previous index value and keep incrementing count. As soon as we get a break from checking we can print the required subset up to the latest value of client."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n) solution in Python."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I also prefer using the hash table to solve the problem, and the expected time complexity is O(n), and here is my code in C++:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I first figured out the O(nlogn) solution (sort -> go through it once to find the longest sequence), and then immediately realized there must be an O(n) solution. Others have found it, but just to throw my C++, O(n) solution up here (I think others have come up with similar, but most seem to be more complex than they need to be):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A solution in Python:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A solution in Python:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Time Complexity: O(n) \n public static int[] longestConsecutiveSequence(int[] data){ \n  int first = Integer.MAX_VALUE; // the first number of the maximum consecutive sequence \n        int length = 0; // the length of the maximum consecutive sequence \n        Map table = new Hashtable(); \n        for(int value: data) { \n         if(!table.containsKey(value)) { \n          int start = value; \n          int end = value; \n          if(table.containsKey(value + 1) && table.get(value + 1) >= value + 1) { \n           end = table.get(value + 1); \n           table.remove(value + 1); \n           table.remove(end); \n          } \n          if(table.containsKey(value - 1) && table.get(value - 1) <= value - 1) { \n           start = table.get(value - 1); \n           table.remove(value - 1); \n           table.remove(start); \n          } \n          table.put(start, end); \n          table.put(end, start); \n          if(end - start + 1 > length) { \n           first = start; \n           length = end - start + 1; \n          } \n         } \n        } \n        int[] seq = new int[length]; \n        for(int i = 0; i < length; i++){ \n         seq[i] = first + i; \n        } \n        return seq; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we can also try doing it with tree binary tree and then using in order traversal we can find a sequence. this sequence can be stored in an array...and then we can determine the next consecutive number in the complete sequence and so the subset."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why can't we just use SortedSet (close to O(1) add operation) ? This can solve the problem easily.."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=19286747","download_status":"DOWNLOAD_DONE","votes":"13","answersCount":"99","title":"Given an array of integers. Find two disjoint contiguous sub-arrays such that the absolute difference between the sum of two sub-array is maximum. * The sub-arrays should not overlap.  eg- [2 -1 -2 1 -4 2 8] ans - (-1 -2 1 -4) (2 8), diff = 16  I gave him o(n^2) algorithm but he was not satisfied.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"16","title":"An O(n) solution is possible.  We consider all \"split points\", i.e. points such that one subarray lies to the left of it, and one to the right, and compute the best for each possible split point.  Dynamic programming works.  Given Array A[1,...n]  Using the standard dynamic programming algorithm, we can compute for a given i, the maximum and minimum sum subarrays in A[1...i] and A[i+1 ... n]. Note that the point between i and i+1 is a split point.  This can be done by making two passes once from 1 to n, and other from n to 1 and give us four arrays with the max and min sub-array sums.  Now given the above four arrays, for split point between i and i+1, we can take the max and min combinations (max from right, min from left and max from left, min from left), and get the combination which gives the better result.  Once we have the max for each split point, we get the global optimum.  O(n) time, O(n) space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Use dp with kadane's algorithm for solving above problem...:-)  import java.io.*; public class Main {              public static void main(String args[]) throws IOException         {                 BufferedReader br=new BufferedReader(new InputStreamReader(System.in));                 long a[]=new long[10000];                 long b[]=new long[10000];                 long max1[]=new long[10000];                 long min1[]=new long[10000];                 long max2[]=new long[10000];                 long min2[]=new long[10000];                         int n=Integer.parseInt(br.readLine());                         String arr[]=br.readLine().split(\" \" );                         int i=0;                         for(String s:arr)                         {                                 a[i]=Integer.parseInt(arr[i]);                                 b[i]=-a[i];                                 i++;                         }                                                  long maxsofar=a[0],maxendinghere=a[0];max1[0]=a[0];                         for(i=1;i                        {                                         //maxendinghere=maxendinghere+a[i]>0?maxendinghere+a[i]:0;                                         maxendinghere=maxendinghere+a[i];                                         maxendinghere=maxendinghere>a[i]?maxendinghere:a[i];                                         maxsofar=maxsofar>maxendinghere?maxsofar:maxendinghere;                                         max1[i]=maxsofar;                         }                         max2[n-1]=maxendinghere=maxsofar=a[n-1];                         for(i=n-2;i>=0;i--)                         {                                         //maxendinghere=maxendinghere+a[i]>0?maxendinghere+a[i]:0;                                         maxendinghere=maxendinghere+a[i];                                         maxendinghere=maxendinghere>a[i]?maxendinghere:a[i];                                         maxsofar=maxsofar>maxendinghere?maxsofar:maxendinghere;                                         max2[i]=maxsofar;                                                          }                         maxendinghere=maxsofar=b[0];                         min1[0]=-b[0];                         for(i=1;i                        {                                         //maxendinghere=maxendinghere+b[i]>0?maxendinghere+b[i]:0;                                         maxendinghere=maxendinghere+b[i];                                         maxendinghere=maxendinghere>b[i]?maxendinghere:b[i];                                         maxsofar=maxsofar>maxendinghere?maxsofar:maxendinghere;                                         min1[i]=-maxsofar;                         }                         maxendinghere=maxsofar=b[n-1];                         min2[n-1]=-b[n-1];                         for(i=n-2;i>=0;i--)                         {                                         //maxendinghere=maxendinghere+b[i]>0?maxendinghere+b[i]:0;                                         maxendinghere=maxendinghere+b[i];                                         maxendinghere=maxendinghere>b[i]?maxendinghere:b[i];                                         maxsofar=maxsofar>maxendinghere?maxsofar:maxendinghere;                                         min2[i]=-maxsofar;                         }                         long globalmax=0;                         /*                         for(i=0;i                        {                                 System.out.println(a[i]+\" \"+b[i]+\" \"+min1[i]+\" \"+max1[i]+\" \"+min2[i]+\" \"+max2[i]);                         }                         */                         for(i=1;i                        {                                 long m1=max1[i-1]-min2[i];                                 m1=Math.abs(m1);                                 long m2=max2[i]-min1[i-1];                                 m2=Math.abs(m2);                                 m1=m1>m2?m1:m2;                                 globalmax=globalmax>m1?globalmax:m1;                         }                         System.out.println(globalmax);         }   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"1. Find the max continues sum 2. Find the continues min sum 3. return 1-2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"So abstract the list of ints to a list of three subsets.   list of numbers=  {a, b, c}  where a,b,c are sums of contiguous numbers in the array and a,b,c are contiguous.  Each of those subsets represents the sum of contiguous numbers in the array. We are looking for the highest and lowest. Note that it is impossible for A or C to have the same signage (positive or negative) as B. Also, if either A or C is the empty set, then the positive subset is the highest and the negative subset is the lowest. If both A and C are the empty set, then B is either the high subset or low subset based off of B's signage. Also lets specify that, B can never be an empty set unless both A and C are empty sets. Now the important thing to note here is that we are going to try to maximize the absolute value of B. This is important because it will allow us to take the highest absoulute value of either A or C and get the highest combined difference.  So let's take a look at some real numbers  n  =  {a, b, c}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Will the following solution work?  1. Find maxsubsequence sum M1 (using Kadane's algorithm) 2. Negate the whole array and find again maxSubsequenceSum M2 3. M1 + M2 should be the absolute max difference. [M1 and M2 must be appearing in disjoint contiguous subarrays, for if they overlap, M1 and -M2 cannot be maximum +ve and maximum -ve values respectively]. and we have a proof by contradiction below]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"He is expecting O(n) time algorithm"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What about this: Must the two subarrays be adjacent? Yes, because the part \"in between\", unless it is 0, can contribute to either subarray, making it more optimal.  If so, then let's find a split point defining subarrays A[0,i] and A[i+1,n], such that the maximal subarrays (spanning together over whole A) give the optimal absolute difference of sums, that can be easily done O(n).  Now, here comes an interesting bit. You can prove that the optimal global solution are possibly trimmed subarrays found in the first step. In other words, you cannot find the global optimal solution by trimming subarrays, which do not optimize the first step criterion.  And so, without further ado, to find the optimum solution we have to possibly trim one or both of the subarrays, or \"expanding\" subarrays starting from one-element subarrays on the left hand side and right hand side of a split point found in the first step, and this is done in O(n).   So final time complexity O(n), space complexity O(1)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include void main() {  int a[]={2,-1,-2,1,-4,2,8},n=sizeof(a)/sizeof(int),max[n],min[n],max_max,min_min,i=0;  max[0]=min[0]=max_max=min_min=a[0];  for(i=1;i {   max[i]=(max[i-1]+a[i])>a[i]?max[i-1]+a[i]:a[i];   max_max=max[i]>max_max?max[i]:max_max;   min[i]=(min[i-1]+a[i])  min_min=min[i] }  printf(\"%d\\n\",max_max-min_min); } Is this ok? it will work in O(n). Are we supposed to identify the subsets also or need to print the difference only?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"An O(n) solution by finding maximum subsequences using Kadane's algorithm  1. Find maxsubsequence sum M1  2. Negate the whole array and find again maxSubsequenceSum M2 3. M1 + M2 should be the absolute max difference. [M1 and M2 must be appearing in disjoint contiguous subarrays, for if they overlap, M1 and -M2 cannot be maximum +ve and maximum -ve values respectively. and we have a proof by contradiction above] 4. Separately handle degenerate cases such as 1) the maximum subsum being contained in the minimum subsum and 2) vice versa  Full working implementation in java is below. Provide Input to the program as: 4 -1 7 -4 1 -7 -9 -4 1 2 -5 -7 -8 9  4 -1 -2 5 7 8"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"main() \n{ \n \nint a[7] = {2,-1, -2, 1, -4, 2, 8}; \nint max = a[0], trackMax = 0; \nint min = a[0], trackMin = 0;     \nfor(int i=1;i<7;i++) \n{        \n         \n        trackMax = trackMax + a[i];  \n        trackMin = trackMin + a[i];  \n        if(trackMax < 0) trackMax = trackMax - a[i]; \n        else trackMin = trackMin = trackMin - a[i]; \n        if(trackMax >= max) max = trackMax;  \n        else if (trackMin <= min) min = trackMin;  \n        cout << min << \"    \" <<< endl; \n} \n \ncout << max-min;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The code for this problem is given below.You can consider the following approach: a.Find maximum continuous sub-array sum using kadane's algorithm. b.Similarly find minimum continuous sub-array sum using the same approach. c.Find the difference between the maximum and minimum element."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"So this is what I got, there are no error checking which is obviously bad but I assume we are all coding and making suggestions for valid entries primarily so keep that in mind:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n) solution can be found at sites.google.com/site/spaceofjameschen/home/array/find-two-disjoint-contiguous-sub-arrays-such-that-the-absolute-difference"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"While thinking over this problem I just realized that maximum and minimum subarrays can overlap in only two scenarios: 1) When sum of the common numbers is zero. If sum of common sequence would have been +ve then it would have been part of maximum subarray and not of minimum subarray. Vice verse for -ve sum for common subarray. 2) One subarray is part of other. For example 10, 9, -1, -2, 10 10  Based on the above two possiblilities 1) Find maximum subarray 2) Find minimum subarray 3) If common subarray is zero then it can go either on maximum or minimum side. 4) If one subarray is part of other then find left and right part (non overlapping) of larger subarray and find the difference between this larger part and common elements.  Hence the complexity of this algo is same as finding maximum/minimum subarray problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  using namespace std; int computMaxDiff(int *array,int len) {  int *maxarray=new int[len];  int *minarray=new int[len];  maxarray[0]=array[0];  minarray[0]=-array[0];  int currentmax=maxarray[0]>0?array[0]:0;  int currentmin=minarray[0]>0?minarray[0]:0;  for(int i=1;i {   currentmax+=array[i];          //max   maxarray[i]=max(currentmax,maxarray[i-1]);   if(currentmax<0) currentmax=0;    currentmin+=-array[i];    // max of -array   minarray[i]=max(currentmin,minarray[i-1]);   if(currentmin<0) currentmin=0;  }   for (int i=0;i  minarray[i]=-minarray[i];    int *revmaxarray=new int[len];  int *revminarray=new int[len];  revmaxarray[len-1]=array[len-1];  revminarray[len-1]=-array[len-1];  int revcurrentmax=revmaxarray[len-1]>0?revmaxarray[len-1]:0;  int revcurrentmin=revminarray[len-1]>0?revminarray[len-1]:0;  for(int i=len-2;i>=0;i--)  {   revcurrentmax+=array[i];   revmaxarray[i]=max(revcurrentmax,revmaxarray[i+1]);   if(revcurrentmax<0) revcurrentmax=0;    revcurrentmin+=-array[i];   revminarray[i]=max(revcurrentmin,revminarray[i+1]);   if(revcurrentmin<0) revcurrentmin=0;  }   for (int i=0;i  revminarray[i]=-revminarray[i];   int maxdiff=0;  for (int i=0;i {   int currMax=max(abs(maxarray[i]-revminarray[i]),abs(minarray[i]-revmaxarray[i]));   if(currMax>maxdiff)    maxdiff=currMax;  }   return maxdiff; } int _tmain(int argc, _TCHAR* argv[]) {  int array[5]={-3,4,-1,4,5};  int maxdiff=computMaxDiff(array,5);  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"step 1 : find the sum of whole array. assign it TotalSum O(n)  step 2 : Lets have a few variables SumFromBegining=0, SumFromEnd=TotalSum, MaxDifference=0, MaxDifferenceSplitIndex=0. all these are integers or long ---O(1) step 3 : Iterate through the array from beginning to end.    for each iteration you need need to do the following   1. add the current array element ie. array[i] to SumFromBegining   2. subtract the current array element ie. array[i] from SumFromEnd   3. Difference=absolute(SumFromEnd-SumFromBegining)   4. if Difference > MaxDifference then MaxDifference=Difference and MaxDifferenceSplitIndex=i  now this process is of O(n)  After the iteration array[0 to MaxDifferenceSplitIndex ] and array[MaxDifferenceSplitIndex+1 to n]  are the answer.  this is a solution with O(n)  hope i did not make a mistake..:-)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I've been through all of these solutions and correct me if i'm wrong, but i think absolutely none of them work for all possible cases. There's one or two which work, but they aint 0(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for this problem finding maximum and minimum contiguous don't work. for example consider this two test case: 1)array=[-6, 3, 5, 4, -1, -7, 17, 8] in this case maxSum=25 and minSum=-8 if we search disjoint contiguous subarray. so the absolute difference is equal 33. however, the max difference is 35 if we separate [-6] and  [3, 5, 4, -1, -7, 17, 8]. sum1=-6, sum2=29 so difference is 35. 2)array=[4, -1, 5] the same above maximum absolute difference between two disjoint contiguous subarray is 6.[-1] and [5]."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Given an array, find the following max/min continuous array:        - left_min_array: continuous max array        - left_max_array: continuous min array        - right_min_array: reverse the array, calculate the continuous max array, reversed again        - right_max_array: reverse the array, calculate the continuous min array, reversed again 2. Iterate the array, find the maximum among the following four integers:        - abs(left_min_array[i]) + abs(right_min_array[i+1])        - abs(left_min_array[i]) + abs(right_max_array[i+1])        - abs(left_max_array[i]) + abs(right_min_array[i+1])        - abs(left_max_array[i]) + abs(right_max_array[i+1])     And store the largest result in an array, let's call result 3. The maximum difference is the max element in the result array  Code is attached at the end, following are the test cases:   - {2,-1,-2,12,453,-9,2,8}   - {7,-1,4}   - {1,2,3,4,5}   - {-1,-3,-5,-2,-1,-4}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"step 1 : find the sum of whole array. assign it TotalSum O(n)  step 2 : Lets have a few variables SumFromBegining=0, SumFromEnd=TotalSum, MaxDifference=0, MaxDifferenceSplitIndex=0. all these are integers or long ---O(1)  step 3 : Iterate through the array from beginning to end.  for each iteration you need need to do the following  1. add the current array element ie. array[i] to SumFromBegining  2. subtract the current array element ie. array[i] from SumFromEnd  3. Difference=absolute(SumFromEnd-SumFromBegining)  4. if Difference > MaxDifference then MaxDifference=Difference and MaxDifferenceSplitIndex=i   now this process is of O(n)   After the iteration array[0 to MaxDifferenceSplitIndex ] and array[MaxDifferenceSplitIndex+1 to n] are the answer.   this is a solution with O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here's a O(n) solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can anybody comment on my approach . 1. find the max sum subsequence using DP. Store the sum and store the subsequence. Replace those elements by INT_MAX. 2. find the min sum subsequence using DP. store the sum and subsequence 3. Now calculate the difference, and print those sets. I think there is no way this subsets will overlap.  This is O(n) solution since steps 2 and 3 takes O(n) in DP."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int get_index(vector& a) \n{ \n    int n = a.size(); \n    if (n <=1 ) return -1; \n    vector prefix_sum(n, 0); \n    prefix_sum[0] = a[0]; \n    for (int i=1; i < n; i++) prefix_sum[i] += prefix_sum[i-1]; \n    long long int min_diff min_idx(-1); \n    for (int i=0; i < n-1; i++) \n    { \n           long long  int diff = abs( prefix_sum[i] - prefix_sum[n-1] + prefix_sum[i+1] ); \n           if (min_idx == -1 || diff < min_diff) { min_diff = diff; min_idx = i; }  \n    } \n    return min_idx ;  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"List maxArray = new List(); \n            List minArray = new List(); \n            List currentRun = new List(); \n \n            int currentRunCount = 0; \n            int max = 0; \n            int min = 0; \n            for (int i = 0; i < array.Length; i++) \n            { \n                currentRun.Add(i); \n                currentRunCount += array[i]; \n \n                if (currentRunCount > 0) \n                { \n                    if (currentRunCount >= max) \n                    { \n                        if (maxArray.Count == 0 || maxArray.ElementAt(maxArray.Count - 1) == currentRun.ElementAt(0) - 1) \n                        { \n                            maxArray.AddRange(currentRun); \n                        } \n                        else \n                        { \n                            maxArray = currentRun; \n                        } \n \n                        max = currentRunCount; \n                        currentRunCount = 0; \n                        currentRun = new List(); \n                    } \n                } \n                  \n                if (currentRunCount < 0) \n                { \n                    if (currentRunCount <= min) \n                    { \n                        if (minArray.Count == 0 || minArray.ElementAt(minArray.Count - 1) == currentRun.ElementAt(0) - 1) \n                        { \n                            minArray.AddRange(currentRun); \n                        } \n                        else \n                        { \n                            minArray = currentRun; \n                        } \n \n                        min = currentRunCount; \n                        currentRunCount = 0; \n                        currentRun = new List(); \n                    } \n                }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I came across this problem and thought about this and came up with the possible solution. I am unable to find cases in order to fail this solution. Can someone please enumerate a set for the same?  My algorithm:  1.Calculate the continuous sum of all elements while going from 1 to n and store them in an array . Do the same while going from n to 1 2. In the first array mark a point which has minimum value and which has maximum value . Do the same for the second array 3. Check for four scenarios.     a)  Break array just after array 1 has hit a minimum value     b) Break array just before array 1 has hit a max value     c) Break array just before array 2 has hit a minimum value     d) Break array just after array 2 has hit a max value  4. Max of (a,b,c,d) from above is the answer  Example: Array : 10,1,3,-10,2  Array 1: 10,11,14,4,6                  Max: 14 Min: 4 Array 2: 6,-4,-5,-8,2                    Max: 6 Min: -8 a) Break after Min:4 i.e Break after -10 in Array . Absolute Diff is 2 b) Break before Max:14 i.e Break before 3 in Array . Absolute Diff is 16 c) Break after Max:6 i.e Break after 10 in Array . Absolute Diff is 14 d) Break before Min: -8 i.e Break before -10 in Array . Absolute diff is 22  Max(a,b,c,d) = 22  Solution complexity is O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I came across this problem and thought about this and came up with the possible solution. I am unable to find cases in order to fail this solution. Can someone please enumerate a set for the same?  My algorithm:  1.Calculate the continuous sum of all elements while going from 1 to n and store them in an array . Do the same while going from n to 1 2. In the first array mark a point which has minimum value and which has maximum value . Do the same for the second array 3. Check for four scenarios.     a)  Break array just after array 1 has hit a minimum value     b) Break array just before array 1 has hit a max value     c) Break array just before array 2 has hit a minimum value     d) Break array just after array 2 has hit a max value  4. Max of (a,b,c,d) from above is the answer  Example: Array : 10,1,3,-10,2  Array 1: 10,11,14,4,6                  Max: 14 Min: 4 Array 2: 6,-4,-5,-8,2                    Max: 6 Min: -8 a) Break after Min:4 i.e Break after -10 in Array . Absolute Diff is 2 b) Break before Max:14 i.e Break before 3 in Array . Absolute Diff is 16 c) Break after Max:6 i.e Break after 10 in Array . Absolute Diff is 14 d) Break before Min: -8 i.e Break before -10 in Array . Absolute diff is 22  Max(a,b,c,d) = 22  Solution complexity is O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think Loler is right, the algorithm could be implemented in O(n), and here is my code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sites.google.com/site/spaceofjameschen/home/array/find-two-disjoint-contiguous-sub-arrays-such-that-the-absolute-difference"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i am assuming the minimum sum of a sub array is negative or empty. and that the maximum sum of a sub array is positive or empty. the problem can be defined as follow: 1. Find the max sub sum 2. Find the min sub sum  if they do not intersect return their difference; otherwise check if the min sub sum is starting after the max sub sum:  [maxSubSumStart ---------- minSubSumStart ----------------MinSubSumEnd--------maxSubSumEnd]  I want to prove that if intersection is not allowed then either the left max sub sum or the right sub sum is the largest sub sum. In this case each side of minSubSumArray is larger than the absolute value of minSubSumArray  (otherwise their sum is below 0 and we would have taken only one part). assume the left sub array is the bigger one. That implies that it is also the biggest sub array in the array (because any other max sub array that wasn't added to the current max array, wasn't added because it is smaller (absolute value)than some minimum sub array, and therefore it is smaller then the minimum sub array and therefor smaller then the left and right parts of the maxsub array.  Therefore the result would be: max sub is the left side of the max array, and the min sub is the minimum sub array.  the same logic is true also in case the max array start in the middle of the min array  this is the code , i still need to do some re-factoring and also I might have some indexing issues:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Find the cumulative sum for 0<=i2. Find j, such that abs(cumulative[ j ] - cumulative [n-1]) is maximum 3. 0 to j is one subarray and j+1 to n-1 is the other subarray"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This solution should work for cases: 1 - compute kadane as follow: var kadane = function (arr, k, j, isMin) which should return min/max sum (according to isMin flag) for the arr elements starting at k index and end (inclusive) at j index. return value should be an object that includes the sum, start index, end index. 2 - find max when k==0 and j==arr.length-1. let's call it MAX and assume it has startIndex==si and endIndex==ei; 3 - find min when k==0 and j==arr.length-1. let's call it MIN and assume it has startIndex==si and endIndex==ei; 4 - for the output of 2 MAX - find min on the right side of it using k==MIN.endIndex+1 and j==arr.length and on the left side of it using k==0 and j==MIN.startIndex-1 (if possible and out of arr indexes). 5 - do the as in 4 step for the MIN (find max on both sides of it). 6 - out of the result in 4 and 5 take the highest and lowest among the two and calculate the range of them with MAX and MIN respectively. 7 - among the two pairs from step 6 - MIN and a max on its left/right and MAX and a min on its left/right choose the pair with the higher range and return it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution in C++ (based on the same idea as some other answers with O(n) running time) :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If there are 2 elements in the array, or all the elements are zero, the  solution is really trivial.  If there are less than 2 elements, there is no  solution.    If all the numbers are non-negative, the problem is completely different from  if you have both signs, all positive is somewhat easier.  The smaller sub-array  will contain only 1 element, and the larger subarray will contain either the  front or the back.  Start with the front of the array being the 'large' value  and the second item being 'small', we store this as our 'current optimum'.  Now  add the 2nd item to 'large' and call the next element 'small'; if this is  better than our first solution, we store it as our current optimum.  We go  through the array forwards the whole way through, then we do the same thing  going backwards.  The optimal solution we find after both passes is the optimal  solution.  This solves in order n (3 passes through n elements). The same logic  works if all the elements are 0 or negative.   If we have both positive and negative numbers, create a 2nd array (partioned  array) 'partitioning' every positive and negative sequence:  2 -1 -2 1 -4 2 8  becomes [2] [-3] [1] [-4] [10].  I am pretty sure this is the right direction,  but from here on out, I bet someone (possibly me with more time) comes up with  something better than I have following.   Now create yet another array combining all the negative elements if and only if  their sum is less than the number between them. Repeat this process until you  cannot.  So you get [-6] in this example.  Now create yet another array doing  this with the positive values, giving you [2][1][10].  The largest of the  positive and smallest negative are the solution if we can ignore the  requirement the arrays do not overlap, and the solution if they do not overlap.   So far, we've done nothing beyond order n.  If they overlap, we can find a  place to split the segment that overlaps fairly easily, and this is almost  always the correct solution, but you can come up with examples where it is not.   I think going back to our partioned array and finding other combinations is the  trick, but cannot think of better than n^2 way to do that.   Of course, you need to store a bit more to go back and find the array indexes,  but that is trivial so I left it out."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This problem can be divided into 2 subproblems: 1. Find a subset whose sum is maximum, it is O(n) algorithm 2. Find a subset whote sum in min, it is O(n) algorithm. 3. Also verify that solution from step 1 and step 2 dont overlap (they will not). Find the absolute difference between subsets find in steps1 and steps2 and take their absolute difference."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I can be done using kandane. For maximum difference we need to find minimum contiguous sub array and maximum contiguous sub array.  Then find the start and end index of both array and make sure they both are not colliding with each other if they are colliding then take maximum difference by including it into minimum subset and maximum subset."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"It can be done using kandane. For maximum difference we need to find minimum contiguous sub array and maximum contiguous sub array.  Then find the start and end index of both array and make sure they both are not colliding with each other if they are colliding then take maximum difference by including it into minimum subset and maximum subset."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Is the exhaustive algo O(2^n * n) where n is # of digits in original set? Thats because you could make 2^n different pairs of subsets, and for each pair, you do sums of O(n).   I wonder if you could sort the origianal set and then walk up the sorted list, splitting it at each of the N points (forming the two subsets) and computing the difference of each of these subsets at each step, looking for the max? If so, you could optimize the sum, as you are just adding one new value to the sum of the first and removing it from the sum of the second."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=19114716","download_status":"DOWNLOAD_DONE","votes":"3","answersCount":"46","title":"In a certain language which has same alphabets as in english language (ie.  a-z), but the order of the alphabets is different (for eg 's' is the first character, 'g' is second, and likewise). Given a dictionary of this new language (which has words arranged according to new alphabetical order), FInd out the order of alphabets in this language.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"9","title":"You can create a directed graph where vertices represent the characters in the language and the edges represent the order relationship, i.e., if there is an edge Eij, then character Vi comes before character Vj in the alphabet. You need to process two consecutive words in the dictionary at a time to determine the precedence relationship of the characters, so it will take O(N * M) time to create the graph, where N is the number of words and M is the length of the words. Then use topological sorting to get characters in the correct order in O(|V| + |E|) time"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I go on building pairs of characters(defining order) from each pair of strings, until I get 25 pairs with different first character(as 26 characters in total), according to this algo -- the first non-matching character from the given two strings defines an order between those unmatching characters. Ex: if str1=KPLLKDE, str2=KPLJKDE, in dictionary str1 appears before str2, LAt this point, I update two counts. If this is the first time L is found on left side of a pair, numOfOutgoings++.  If this is the first time J is on right side of a pair, numOfIncomings++;  Continue this process till we have numOfIncomings == 25 && numOfOutgoings==25.  Now I build a graph as below - First 26 nodes with 1 for each char. And if my pairs are {sk, kp, pl, lm etc} in my graph these edges exist s->k, k->p, p->l, l->m etc.   At this point I have a graph with 26 nodes, with at least 25 edges defining the order between some 2 chcaracters covering enough orders to define complete ordering. Now do the topological sort on these nodes, and you have the order of the new alphabet."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Hi,  I dont know whether i am clear with the question. My Answer is, you just want to find out the order of Alphabets. -> Take the first string and in that take out the first Alphabet, this represents the first alphabet. -> Select second string, such that 1st alphabet should be different, than the previous, which represents second alphabet in the series. EX:  Let dictionary be                        Gun                        God                        Graveyard                        Money                        Maintain -> here 1st alphabet is g, in the second string check whether 1st alphabet  == g, if yes, skip else store, which represents Second alphabet. -> Hope this solution can work. Now once u get all the alphabets u can store in a graph or linked list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Create a DAG (Directed Acyclic Graph) from the list of provided words, and perform a topological sort on the graph."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class AlphabetOrderFinder \n    { \n        private char[] find(String[] orderStrings) \n        { \n            Digraph g = new Digraph(26); \n \n            int j = 0; \n            for (int i = 0; i < orderStrings.Length - 1; i++) \n            { \n                string high = orderStrings[i + 1]; \n                string low = orderStrings[i]; \n                int minLength = Math.Min(low.Length, high.Length); \n \n                for (j = 0; j < minLength; j++) \n                { \n                    if (low[j] == high[j]) \n                        continue; \n \n                    if (low[j] != high[j]) \n                        g.addEdge(get(low[j]), get(high[j]));  \n                } \n            } \n \n            DirectedCycle cycle = new DirectedCycle(g); \n            if (cycle.hasCycle()) { \n                foreach (var c in cycle.getCycle()) \n                    Console.Write(c + \" -> \"); \n \n                Console.WriteLine(); \n                return null; \n            } \n \n            List orders = new List(); \n            DFSDiagraph dfs = new DFSDiagraph(g); \n            foreach (var v in dfs.sort()) { \n                orders.Add(get(v)); \n            } \n \n            return orders.ToArray(); \n        } \n \n        private int get(char c) { \n            if (!Char.IsUpper(c)) \n                c = Char.ToUpper(c); \n \n            return c - 'A'; \n        } \n \n        public char get(int c) { \n            return (char)(c + 'A'); \n        } \n \n        public void test() \n        { \n            const string NEW_ORDER = \"HIJKLMNOPQRSTUVWXYZABCDEFG\"; \n            String[] newlyOrdered = { \n                \"HACD\", \n                \"HIEF\", \n                \"IBEA\", \n                \"ID\", \n                \"JAC\", \n                \"K\", \n                \"KB\", \n                \"KC\", \n                \"KD\", \n                \"KE\", \n                \"KF\", \n                \"KG\", \n                \"L\", \n                \"LL\", \n                \"LM\", \n                \"LN\", \n                \"LO\", \n                \"LP\", \n                \"LQ\", \n                \"LR\", \n                \"LS\", \n                \"LT\", \n                \"LU\", \n                \"LV\", \n                \"LW\", \n                \"LX\", \n                \"LY\", \n                \"LZ\", \n                \"Z\", \n                \"A\", \n                \"B\" \n            }; \n \n            char[] orders = find(newlyOrdered); \n            String printRes = String.Join(\" -> \", orders); \n            String res = String.Join(\"\", orders); \n \n            Console.WriteLine(printRes); \n            AssertHelper.areEqual(NEW_ORDER, res); \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Build a directed graph according to the relationship of sorted strings. Also add a directed cycle detect logic to do the input detection in case the input is not correct. Then use a topological sort to get the sorted chars, it is basically a depth-first-search, then use a stack to reverse, which will get the ordered output."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What about another approach? What if we just sort the dictionary of new alphabet words by length and hopefully find a very small set of words with a very long length. For instance, en.wikipedia.org/wiki/Longest_word_in_English has the longest words. If we can find just one word that is unique in length, then we can easily map it back from the scrambled to the original alphabet. If we have a few, well, then we could then go and try each of them out exhaustively."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.HashMap; import java.util.Map;  public class AlphabetOrder {   static class Pos {    public Pos(int start, int end) {     this.start = start;    this.end = end;   }    private int start, end;    public void setStart(int start) {     this.start = start;   }    public void setEnd(int end) {     this.end = end;   }    public int getStart() {     return start;   }    public int getEnd() {     return end;   }  }   private static String getChar(String word) {    return word.substring(0, 1);  }   private static boolean put(Map alp, String ch, int pos) {    boolean insert = false;   if (alp.containsKey(ch)) {     Pos p = alp.get(ch);    if (p.getStart() > pos) {     p.setStart(pos);    }    if (p.getEnd() < pos) {     p.setEnd(pos);    }   } else {    alp.put(ch, new Pos(pos, pos));    insert = true;   }    return insert;  }   private static void calculate(String[] dictionary, int start, int end,    Map alp) {    if (end - start == 1)    return;    int mid = (start + end) / 2;   String ch = getChar(dictionary[mid]);   boolean insertFlag = put(alp, ch, mid);   if (insertFlag) {    calculate(dictionary, start, mid, alp);    calculate(dictionary, mid, end, alp);   } else {    if (start < alp.get(ch).getStart()) {      calculate(dictionary, start, alp.get(ch).getStart(), alp);    }    if (end > alp.get(ch).getEnd()) {      calculate(dictionary, alp.get(ch).getEnd(), end, alp);    }   }  }   public static void main(String... args) {    String[] dictionary = { \"plenty\", \"poem\", \"pink\", \"pink\", \"pink\",     \"pink\", \"pink\", \"pink\", \"pink\", \"pink\", \"pink\", \"pink\", \"pink\",     \"pink\", \"pink\", \"about\", \"and\", \"computer\", \"college\", \"cat\",     \"june\", \"eight\" };   // String[]   // dictionary={\"plenty\",\"poem\",\"pink\",\"mood\",\"mango\",\"mike\",\"is\",\"ink\",\"ilets\",\"in\",\"table\",\"type\",\"toy\",\"tv\",\"apple\",\"about\",\"and\",\"computer\",\"college\",\"cat\",\"june\",\"eight\"};    Map alp = new HashMap();    int i = 0;   int j = dictionary.length - 1;   put(alp, getChar(dictionary[i]), i);   put(alp, getChar(dictionary[j]), j);    calculate(dictionary, i, j, alp);    System.out.println(alp.keySet());   System.out.println(alp.keySet().size());   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It's time complexity is O(logn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Another approach for this is you maintain one bool array of 26 elements(assuming new language alphabet can be represented with ASCII char set). You traverse the first word's characters and set the right position in bool, if its not set, it means it's a unique char, Add it to one List collection. If its already set, don't add it. Once you list collection size is 26, it means you discovered all character sequences."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why not recursively:   Take the dictionary, first word, ok starting letter is [a].  Last world, starting letter is [z]. World at half the dictionary, starting letter is [X].  ([X]!=[a] && [X]!=[z]) then call again the function for 2 separate dictionaries: [a-x] and [x-z]. Of course the dictionary could split in one half only not 2, if [X]=[a] or [X]=[z]. And so on."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"*word not *world, my bad XD"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"write recursive function which  will use the chunk of dictionary, take first letter in the middle of chunk (put in the middle of alphabet), than call itself twice with left and right portion of chunk.  speed  O(logn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Yeah, exactly. The best way I guess. (I proposed the recursive version), forgot to put the name :)  But it took me longer than 15 minutes, 'cause I tried an approach with tree sets, to split the array of word node by node... but that is lot more complex. And useless. An array and 2 indexes. Easy and straightforward.  sadly, no link allowed, so no solution from ideone. :("},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//the recursive part  public void split(int a, int z) {         iterations++;         int offset = a;         int split = z - a;         if (vocabulary[a].toLowerCase().charAt(0) == vocabulary[z].toLowerCase().charAt(0)) {             if (letterOrder.indexOf(vocabulary[a].toLowerCase().charAt(0))==-1) {                 letterOrder = letterOrder + vocabulary[a].toLowerCase().charAt(0);             }             return;         } else {             split(a, offset + split / 2);             split(offset + split / 2 + 1, z);         }       }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this, Take first word of dictionary. Add its first letter in a linked list. Lets call this linked list Alphabets.  Take next word of dictionary. Find the index where this word is differnent from the last word. If the letter of difference is not in list already, insert it in the list after the position of letter in last word at the same index. For ex: let the last word be 'uiodl' and the current word is 'uiydk' or 'uiydl'. then the new letter would be 'y'. Now as it replaces the 'o' in last word. 'y' should come after 'o' in the Alphabet. Now insert letter 'y' in Alphabet linked list after 'o'.   Repeat this for rest or the words."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"That seems to be slower than the recursive solution.  Still, the cost-efficient recursive version has one problem: if the dictionary does not contain any letter starting with one letter, said that \"h\", for example. If you consider this particular condition, you will have to consider also the possibility of a letter contained in one word only.   If you include that as a possibility, there is no other way to deal with the problem than to scan it completely. Every word of it. In that case, which kind of storing you will use (string, linked list etc) doesn't do any difference, 'cause the expensive part of the problem will be the search."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Take every two consecutive words and find first difference letters in them"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Arrays; import java.util.Comparator; import java.util.HashMap; import java.util.Map;   class DictionaryCopmerator implements Comparator{    Map map = new HashMap();    DictionaryCopmerator()  {   map.put(\"c\", 1);   map.put(\"b\", 2);   map.put(\"a\", 3);   map.put(\"t\", 4);  }    @Override  public int compare(Object o1, Object o2) {   // TODO Auto-generated method stub   String s1 = (String)o1;   String s2 = (String)o2;      boolean b = true;      int i=0,j=0;      while(b)   {    String c1  = \"\"+s1.charAt(i);    String c2  = \"\"+s2.charAt(j);       Integer order1 = (Integer)map.get(c1);        Integer order2 = (Integer)map.get(c2);            if(order1>order2)     return 1;        if(order1==order2)    {     if(s1.length()>s2.length())      return 1;     else if(s1.length()     return -1;     return 0;     }             if(order1    return -1;        i++;    j++;   }      return 0;  }   }  public class NewDictionary {     public static void main(String[] args) {      String s[] ={\"a\",\"cat\",\"c\",\"bat\",\"c\"};         for (int i = 0; i < s.length; i++) {    System.out.println(s[i]);   }      System.out.println(\"\\n\");      Arrays.sort(s, new DictionaryCopmerator());      for (int i = 0; i < s.length; i++) {    System.out.println(s[i]);   }        } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Duplicate of: /question?id=19114716"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"r u sure your \"sorted words\" correct? \" ntr \" comes before \"act\" means,  \"n\" is ahead of \"a\", but words \" tan\" shows \"a\" comes before \"n\"."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Will someone please tell me how to infer \"n\" is head of \"r\"? In my opinion, the order of \"n\" and \"r\" can not be determined based on the given example."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if the order of some character can be determined, this character is not in final result."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about you have 26 trees, one for each alphabet,  Properties of the tree: It has a root, and n children Root occurs before all its children.  In English tree for A has 25 children, B has 24 Children. Similarly keep building the trees and stop when the number of children in all the trees is 25*(25+1)/2=325. Now order the roots based on the number of children you have."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//like file diff, the en-dictionary in Map or tries \n1> Iterate over the list of words from each dictionary and evaluate Edit Distance \n2> LCS against English words"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is naive implementation -- will not perform efficiently:   1. Check 2 words of alien dictionary at a time (eg: check word1 & word2, word2 & word3 and so on..) 2. Iterate each letter in both words, find differing letters. Eg: if the words are:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can start with the first character of the first word of the Alien's dictionary and go through all the words until the entire dictionary is exhausted. In each step we can search for the next word that starts with an new character (hence the new alphabet of this particular language) in 2^k and locate its exact location within the list of the words via searching between 2^(k-1) and 2^k. The code is somewhat like this:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi peeps, read through a few answers and couldn't find someone thinking the same way I did, could someone point out whether this is correct  Approach:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Perhaps a stupid answer - but I have used dictionary (English) and it also contains 'one letter word' representing a character in an alphabet."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=18929680","download_status":"DOWNLOAD_DONE","votes":"-3","answersCount":"8","title":"d1 = a1*x1 + b1*x2 + c1*x3 d2 = a2*x1 + b2*x2 + c2*x3 d3 = a3*x1 + b3*x2 + c3*x3  Knowing all of a,b,c,d, find x1, x2, x3. As you might notice, this is high school math. But it's hard to write the code for solving it.  /* /a1 b1 c1| /x1| /d1| |a2 b2 c2|*|x2|=|d2| |a3 b3 c3/ |x3/ |d3| */ double A[3][3], X[3], D[3]; X[0] = ? X[1] = ? X[2] = ?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This can be represented as \n \n \n  \n| d1 |        | a1 b1 c1  |  | x1 | \n| d2 |   =   |  a2 b2 c2 |  | x2 | \n| d3 |        |  a3 b3 c3 |  | x3 | \n \ni.e.  \n|D| = | ABC | * | X | \n \nNow use matrix multiplication/division  to get the answer \n \n \n| X | = |D| * | inverse of A|"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Reduce the matrix to an upper or lower triangular one. After that simply substitute values."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static function solveMatrix(a:Array, b:Array, X:Array):void         {             var invA:Array = [];             invA[0] = [];             invA[1] = [];             invA[2] = [];               var invDet:Number = 1/((a[0][0]*(a[2][2]*a[1][1]-a[2][1]*a[1][2]))-(a[1][0]*(a[2][2]*a[0][1]-a[2][1]*a[0][2]))+(a[2][0]*(a[1][2]*a[0][1]-a[1][1]*a[0][2])));             invA[0][0] = invDet * (a[2][2]*a[1][1]-a[2][1]*a[1][2]);             invA[0][1] = invDet * (-1 * (a[2][2]*a[0][1]-a[2][1]*a[0][2]));             invA[0][2] = invDet * (a[1][2]*a[0][1]-a[1][1]*a[0][2]);              invA[1][0] = invDet * (-1 * (a[2][2]*a[1][0]-a[2][0]*a[1][2]));             invA[1][1] = invDet * (a[2][2]*a[0][0]-a[2][0]*a[0][2]);             invA[1][2] = invDet * (-1 * (a[1][2]*a[0][0]-a[1][0]*a[0][2]));              invA[2][0] = invDet * (a[2][1]*a[1][0]-a[2][0]*a[1][1]);             invA[2][1] = invDet * (-1 * (a[2][1]*a[0][0]-a[2][0]*a[0][1]));             invA[2][2] = invDet * (a[1][1]*a[0][0]-a[1][0]*a[0][1]);              X[0] = invA[0][0] * b[0] + invA[0][1] * b[1] + invA[0][2] * b[2];             X[1] = invA[1][0] * b[0] + invA[1][1] * b[1] + invA[1][2] * b[2];             X[2] = invA[2][0] * b[0] + invA[2][1] * b[1] + invA[2][2] * b[2];         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is still HS math. You just don't know your linear algebra well enough.  Step 1) do a determination test (write a 3x3 det function, please don't tell me you can't even write an expression) If it is 0. It may have 0 or infinite solution  Step 2) Applied row reduction, but if det is not zero, you can divide the first row and make a[0][0] = 1. Then make a[0][1] = a[0][2] = 0, then make a[1][1] = 1 and a[0][1] = a[0][2] = 0, and do it for a[2] (maybe I indexed it backward from yours? whatever that is not the point). Then you finished row reduction and have the unique solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"main(){ det = computeDet();    computeAdj();         for(int i=0;i<3;i++){     System.out.println();     for(int j=0;j<3;j++){      result[i][j] = result[i][j]/det;     }    }        x1 = d1*result[0][0] + d2*result[0][1] + d3*result[0][2];    x2 = d1*result[1][0] + d2*result[1][1] + d3*result[1][2];    x3 = d1*result[2][0] + d2*result[2][1] + d3*result[2][2];    System.out.println((int)x1+\" \"+(int)x2+\" \"+(int)x3);   }      public static int computeDet(){    int sum = 0;    for(int i=0,j=0;j<3;j++){     sum = sum + abc[i][j]*((abc[(i+1)%3][(j+1)%3]*abc[(i+2)%3][(j+2)%3])-(abc[(i+2)%3][(j+1)%3]*abc[(i+1)%3][(j+2)%3]));    }    return sum;   }      public static void computeAdj(){    int[][] mTrans = {{1,0,0},{0,1,0},{0,0,0}};    for(int i=0;i<2;i++){     for(int j=i;j<2;j++){      mTrans[i][j+1] = abc[j+1][i];      mTrans[j+1][i] = abc[i][j+1];     }    }    for(int i=0;i<3;i++){     for(int j=0;j<3;j++){      adj[i][j] = (mTrans[(i+1)%3][(j+1)%3]*mTrans[(i+2)%3][(j+2)%3])-(mTrans[(i+2)%3][(j+1)%3]*mTrans[(i+1)%3][(j+2)%3]);     }    }   }  O(n^2). Messed up eh! this is what I would have given."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Not a programmer - Hence Pseudo code."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=19503663","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"19","title":"Given a 2D rectangular matrix of boolean values, write a function which returns whether or not the matrix is the same when rotated 180 degrees.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Launch two pointers Fwd and Bkw at the same time. Fwd is going in left-right/top-bottom direction and Bkw going in right-left/bottom-up direction. Compare values on every step and bail out if difference found. Terminate loop when Fwd == Bkw (i.e. they meet in the center)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//let a[][] be the matix  public bool IsSymmetric (int[][] a) for(int i = 0;i < n;i ++) {  for(int j = 0; j< n-i; j++)  {   if(a[i][j] != a[n-i][n-j]);   {    return false;   }  } } return true;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"with a[n-i][n-j], array will be out of bound, you need [n-1-i][n-1-j]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int ifSameOnRotation(int a[R][C]){ \n    int i,j; \n    for(i=0;i<=(R-1-i);i++){ \n                            for(j=0;j"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"180 rotation equal mean if you draw a line from bottom left to right up then both triangular half should be symetrical.then u traverse in the triangular array for both side nd figure out weather simmetrical or not"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool is_the_same_when_rotated(bool a[], size_t rows, size_t cols) \n{ \n bool bRes = true; \n for (size_t i = 0; i <= (rows / 2) && bRes; i++) \n { \n  for (size_t j = 0; j < cols; j++) \n  { \n   if (i == (rows / 2) && (j >= (cols / 2))) \n   { \n    break; \n   } \n \n   size_t currIdx = i * cols + j; \n   if (a[currIdx] != a[((rows * cols) - 1) - currIdx]) \n   { \n    bRes = false; \n    break; \n   } \n  } \n } \n \n return bRes; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def is180RotatedEqual(matrix1, matrix2): \n  if not matrix1: \n    return not matrix2 \n  if len(matrix1) != len(matrix1[0]): \n    return False \n \n  for i in xrange(len(matrix1)): \n    for j in xrange(len(matrix1)): \n      if matrix1[i][j] != matrix2[len(matrix1) - i - 1][len(matrix1) - j - 1]: \n        return False \n  return True \n \nprint is180RotatedEqual( \n    [[1, 2, 3], \n     [4, 5, 6], \n     [7, 8, 9]], \n    [[9, 8, 7], \n     [6, 5, 4], \n     [3, 2, 1]]) \nprint is180RotatedEqual( \n    [[1, 2, 3], \n     [4, 5, 6], \n     [7, 8, 9]], \n    [[9, 8, 7], \n     [6, 5, 4], \n     [9, 2, 1]])"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We should first ask from interviewer regarding 180 degree of rotation on the basis of x axis or y axis. In both the condition we have to only check whether the row or column are palindrome or not. We can check it in O(ROW*COL) time complexity by traversing each row or column ( on the basis of x and y axis constraints ) from start and end simultaneously."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do we need to give a solution based on transformation matrix"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for i = 1 to MAX_ROWS \n            while(MAX_ROWS - i + 1 > i) \n                    for j = 1 to MAX_COLUMNS  \n                                    while (MAX_COLUMNS -j + 1 > j) \n                                           if Matrix(i,j) != Matrix(MAX_ROWS - i + 1,MAX_COLUMNS -j + 1) then  \n                                                 message(\"Matrix not same when turned 180 deg\") \n                                                 break; \n                                           endif \n    endwhile \n  endfor \n endwhile \nendfor"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def is180RotationSame(matrix): \n lastRowsIndex=len(matrix)-1 \n lastColumnIndex=len(matrix[0])-1 \n  \n for i in range (lastRowsIndex+1): \n  for j in range(lastColumnIndex+1): \n   if (i<=lastRowsIndex-i or j<=lastColumnIndex-j): \n    if(matrix[i][j]!=matrix[lastRowsIndex-i][lastColumnIndex-j]): \n     return False \n   else: \n    #print \"Breaking at %d row and %d column\"%(i+1,j+1) \n    return True \n \n  \nif __name__=='__main__': \n #matrix=[[i for i in range(5)] for j in range(3)] \n matrix=[[1,2,3,4],[2,6,5,4],[4,5,6,2],[4,3,2,1]] \n print matrix \n print is180RotationSame(matrix)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=19188693","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"7","title":"Given a 'friendship' graph, how would you generate friend suggestions for people, and how would you distribute the data across machines?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"To generate friend suggestions, for a person in the graph find all the friends connected to this person(1-HOP) then suggest the friends of these friends(2-HOP). We can refine this more by suggesting 2-HOP friends who have common attributes like same school, same subject of interest, etc.. so on to order the suggested friends list.  I guess it would be better to store connected nodes(friends) in the graph on the same server machine since there is a high chance that friends will want to see updates from friends. Though some nodes on the friends graph will be redundant on more than one machine."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"we have only 'friendship' graph not there likes,schools or other here my pseudo code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"In a graph find cycles."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=18810679","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"13","title":"Design a counter across all Google's servers.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"The solution your looking for is a \"distributed counter\". You can search about this topic, because I cannot include links here. A good approach to solve the scalability design problems is that starting with a small scale version of the solution and then extend your solution for a large scale version."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"read this :  whynosql.com/scaling-distributed-counters/  highscalability.com/blog/2012/4/5/big-data-counting-how-to-count-a-billion-distinct-objects-us.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why cant we use a single master node that provides the counter.(something similar to the master node is a hadoop cluster). Each other server will ping the master and ask for the value of the counter.  We can have a request queue to take case of concurrency issues.  Then one question comes to mind that the master node becomes the single point of failure. we can do the same thing that cloudera did with master node and have multiple nodes/servers be passive master so that when one server/node goes down, some other node can take up the queue from there."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"There are many ways to do so. 1> Cache Coherence technique is highly used in industry scale. Specially at hardware level. 2> Another approach which I could think of is as follows.  Make a Counter Base Class and maintain in one of the Server. Rest of the remaining server may act only as the supplement support , which holds the copy of the counter class object  ( May be we can scale using Derived Class of this Base Class ).  Now, the counter update is not a simple counter increment but a queue, Once a counter gets incremented by any of the server, it process that by sending a increment info to the queue which is maintained by base server.   Base Server has to do 2 task,  1> Process the queue operation sequentially and in some routine time manner. 2> Once, the operation is completed, send the updated counter value to each of the corresponding associated servers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"define a class variable?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=18880663","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"29","title":"You are given a doubly linked list and an array of references to nodes on the linked list. How many \"blocks\" are there present in the linked list?   A \"block\" is defined as a group of nodes on the list with references directed at them and adjacent to eachother.   For example  [node #0] -><-[node#1] -><-[node#2] -><-[node#3]  node[] nodes = {ref_to_node#0, ref_to_node#2, ref_to_node#3};  Is two blocks because the first block is at node #0. Node #1 has no incomming reference. Node #2 and Node #3 have references are are adjacent so it's just one block.  Implement using JAVA: Hint: You can try using a HashMap.  Thanks.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Assumptions: * No duplicates in the references array * References array is NOT ordered * array.length <= list.length, as the array contains no duplicates. So ideally we only want to loop over the array if possible. E.g. if there are a billion items in the list, but only two references in the array, looping over the entire away is a total waist of time!  For each node: 1. Add node to a HashSet 2. increment the block count by one.  3. If the nodes previous or next siblings are already in the set, that means we have closed a gap between two blocks, so we must decrement the incorrectly counted blocks."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The following is the code for a working solution, it definitely is not a very efficient one, better solutions are welcome :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can you explain question with more example. Few questions are  1. Can array contain references of node which are not present in linked list, 2.  {ref#0 , ref#2 , ref#4, ref#1}  with this example you want output as 2 blokcs of 4 blocks? here  we have 0,1,2 adjacent in linkedlist but are not adjacent in array ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I may have figured it out just now with help from \"anonymous\", not sure though.   1. Put all the node refs into a hashtable. 2. Iterate through the linkedlist:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Basically you put the nodes refs as keys and array index as value, then iterate through list, every time there is no value for key you increment blocks. I haven't tested out the following code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if extra memory is allowed, we could define an array(call it B, call the original array as A) of the same size of the list, initialize to all null. then iterate thru the list, if an element exists in A, insert into array B in the corresponding position as the list. The resulted array B would be like node1ref null node2refe null null node3ref node4ref then it  becomes easy to find the no. of blocks."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In C++:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a c# solution in O(array.Length)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my version of code... Thought of using HashSet instead of HashMap"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think your solutions so far don't use the fact it is a double-linked list. Tell me what do you think about this:  1. You go over the array from the beginning to the end:  - for every object the array points to, you add to the linked list two DUMMY objects - one before and one after the pointed object  2. You go over the list from the beginning and delete the dummies:  - While deleting - you count the number of dummies   - You don't include in your count a dummy that had a dummy connected to him (before or after)  - Therefore, what you counted is the number of block starts + number of block ends.  - you divide this number in 2 and get the number of blocks!  Am I stupid? Please explain :-)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I believe below function will give the desired result in O(n). Please suggest if any improvement can be done in below code."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Recording the left boundaries and right boundaries of each potential block"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Logic (Assuming 1st element ref of the doubly linked list is present in the node[] array somewhere) 1. Build the hashmap  pair with \"key\" as nodes from node[] array provided (not the doubly linked list) and value as position of the node in the same array. 2. Create a new block array[] int of the same size as node[] array. 3. Iterate through the doubly linked list, for each node starting from beginning check if the key is present in the hashmap. 2 cases      3.1 If present : get the value which is the position in the node array. and do ++block[position]. This step is to ensure we have block size of 1 for all elements. We can avoid this case by assigning 1 to the block when the block was created initially. Either way it is good.       3.2 If NOT present : Go to the doublylinked list. Copy the current ref that is not present in a temp and go backwards in the doublylinked list until you find a ref which is present in the hashmap. Get the value of the reference in the hashmap which is the position, do ++block[position].  4. Continue until the end of the doublylinked list [note : you have used a temp here, so you still retain your iterating position]. 5. Return the block array which is of size position."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I thought a solution would just be:  Put each node* in a hash If head node is in hash, start blockcounter as 1, otherwise 0 Start iterating through the linked list. If the following case is detected: node -> prev is not in hash and node is in hash. Increment blockcounter; //All we need is the number of blocks and every signal for a begin of a block we increment Runtime: O(n)  Also possible without a doubly linked list if we keep 2 node pointers while iterating one following the lead."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use a TreeSet. 1. no duplicates, and sorted.  Check for broken links in reference array and update block count on each such encounter.  Set blockCheck = new TreeSet();   // add all nodes from node array.    for(Node n : node){     blockCheck.add(n);    }   // find broken links    for(Node s : blockCheck){     if(s.next==null || !blockCheck.contains(s.next))      ++blockCount;    }        System.out.println(blockCount);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"just suppose at the begining that the solution is the size of the double linked list. Now you go through the array, and if value at pos i and value at pos i+1 are adjacent , then you subside 1 from the solution."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=18822671","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"14","title":"Give me real time application of BST.....","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"map and set objects in many language where data is constantly entering and leaving"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Priority Queue is an application of binary search tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"finding nearest neighbor to a point using kd trees (application of binary trees)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Binary search trees are a fundamental data structure used to construct more abstract data structures such as sets, multisets, and associative arrays."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"BST is applicable in Serialization. You can take the complete File structure, serialize in a inorder fashion and can send over the network"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"I would say the Google's \"Query Auto suggestion\" feature in  Search Query box.  It is implemented as Trie but Trie in themselves are BST.   Other use is \"iNodes\" in Linux. There are stored using Red Black Tree ( another modified BST)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=18460667","download_status":"DOWNLOAD_DONE","votes":"4","answersCount":"68","title":"Eliminate all ??b?? and ??ac?? in an array of characters, you have to replace them in-place, and you are only allowed to iterate over the char array once.  Examples: abc -> ac ac->'' react->rt","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"we need delete the chars and move the remaining chars in the same iteration"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"It can be solved using two pointers thats it :-)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Logic is simple: Take 2 pointers which initially points to the start of the array. Here first one represents the end of string without 'b' and 'ac' and first represents the current scan position. scan the array from the start to end if the current characters is 'b' or 'ac', increment only second pointer appropriately if the current characters is not 'b' and 'ac', swap characters pointed by two pointers and then increment both pointers. result will be the string from the start of the array to the location pointed by first pointer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"you have to replace them in-place with what? I think this too straight forward or am i missing something?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class ElliminateChars { \n public static void main(String[] args) { \n  char[] ch = \"abcacd\".toCharArray(); \n  int opArrayIndex, ipArrayIndex; \n  for (opArrayIndex = 0, ipArrayIndex = 0; ipArrayIndex < ch.length;) { \n   if (ch[ipArrayIndex] == 'b') { \n    ipArrayIndex++; \n   } else if (ch[ipArrayIndex] == 'a' && ch[ipArrayIndex + 1] == 'c') { \n    ipArrayIndex += 2; \n   } \n   ch[opArrayIndex] = ch[ipArrayIndex]; \n   opArrayIndex++; \n   ipArrayIndex++; \n  } \n  for (; opArrayIndex < ch.length; opArrayIndex++) { \n   ch[opArrayIndex] = ' '; \n  } \n \n  for (opArrayIndex = 0; opArrayIndex < ch.length; opArrayIndex++) { \n   System.out.print(ch[opArrayIndex]); \n  } \n \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void Eliminate(char[] s) \n        { \n            int index = 0; \n \n            for (int i = 0; i < s.Length; i++) \n            { \n                char c = s[i]; \n \n                if (c == 'b') \n                    continue; \n                else if (c == 'a' && i + 1 < s.Length && s[i + 1] == 'c') \n                { \n                    i++; continue; \n                } \n \n                if (index != i) \n                    s[index] = c; \n \n                index++; \n            } \n \n            if (index < s.Length) \n            { \n                //compact array \n                for (int i = index; i < s.Length; i++) \n                    s[i] = '\\0'; \n            } \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void remove_ac_or_b(char* str) \n{ \n unsigned int len = strlen(str); \n int curr_pos_to_fill = 0;  /* index of char to fill */ \n int curr_pos_to_check = 0;  /* index of char to check */ \n \n printf(\"input: (%s)\\n\",str); \n while (curr_pos_to_check < len) \n { \n  /* if we reached \"ac\", go 2 chars ahead */ \n  if ((curr_pos_to_check < (len - 1)) && \n   (str[curr_pos_to_check] == 'a' && str[curr_pos_to_check+1] == 'c')) \n  { \n   curr_pos_to_check += 2; \n   continue; \n  } \n  /* if we reached \"b\", go 1 char ahead */ \n  if (str[curr_pos_to_check] == 'b') \n  { \n   curr_pos_to_check++; \n   continue; \n  } \n  /* \n   we didn't reach any special char, just fill current fill location with current check location \n   and then increase them both \n  */ \n  str[curr_pos_to_fill] = str[curr_pos_to_check]; \n  curr_pos_to_fill++; \n  curr_pos_to_check++; \n } \n /* null terimiate the string */ \n str[curr_pos_to_fill] = '\\0'; \n printf(\"result: (%s)\\n\",str); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static string ReplaceString(char[] toreplace)         {             int totalIndex = toreplace.Count();             int writeIndex = 1;             if (toreplace[0] == 'b')             {                 writeIndex = 0;             }              for (int i = 1; i < totalIndex; ++i)             {                 if (toreplace[i] == 'b')                 {                     continue;                 }                  if (toreplace[i] == 'c')                 {                     if (toreplace[writeIndex - 1] == 'a')                     {                         writeIndex--;                         continue;                     }                 }                  toreplace[writeIndex] = toreplace[i];                 writeIndex++;             }              return new string(toreplace, 0, writeIndex);         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Logic: -Traverse array -check each char for 'a' or 'b' -in case found 'b' delete it and continue traversing -in case found 'a' check for next char  -in case after 'a' next char is not 'b' continue -in case after 'a' next char is 'b' check for this 'b' next char -in case after 'a' next char is 'b' and 'b's next char is not 'c' then delete 'b' and continue traversing - in case after 'a' next char is 'b' and 'b's next char is 'c' then delete 'abc' and continue traversing  conclusion: search for occurrence of 'a' or 'b' in case 'b' comes first delete it or check whether 'abc'  pattern is there.... if yes.... delete it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Doubt: if input is \"abcd\" then the output should \"d\" or \"acd\""},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is my efforts for to solve this problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static String removeBAndAC(String s) { \n    Stack stack = new Stack(); \n    StringBuffer newString = new StringBuffer(); \n     \n    for (int i = 0; i < s.length(); i++) { \n      char currentChar = s.charAt(i); \n      switch (currentChar) { \n        case 'a': \n          stack.push(i); \n          break; \n        case 'b': \n          break; \n        case 'c': \n          if (!(stack.isEmpty())) { \n            stack.pop(); \n          } \n          else { \n            newString.append(currentChar); \n          } \n          break; \n        default: \n          if (!(stack.isEmpty())) { \n            stack.pop(); \n            newString.append('a'); \n          } \n          newString.append(currentChar); \n          break; \n      } \n    } \n     \n    while (!(stack.isEmpty())) { \n      stack.pop(); \n      newString.append('a'); \n    } \n    return newString.toString(); \n     \n  } // End of removeBAndAC()"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"in Scala solution is simple 4-liner:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static char[] eliminateChar(char[] input) { \n        int len = input.length, i=0; \n        for(i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"char *str = \"aaabbcccbaxc\";  std::vector myVector;   for (int i = 0; i < strlen(str); i++)  {   if(str[i] == 'c')   {    if(!myVector.empty())    {     if(myVector.back() == 'a')      myVector.pop_back();     else      myVector.push_back(str[i]);    }   }   else if(str[i] != 'b')    myVector.push_back(str[i]);  }   int i;  char *str2 = new char[myVector.size() + 1];  for ( i = 0; i  str2[i] = myVector[i];  str2[i] = '\\0';"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void Eliminate (String[] strIn){ \n   \n  List list = new ArrayList(Arrays.asList(strIn)); \n   \n  for (int i = 0; i < list.size(); i++) { \n   if (list.get(i).equals(\"b\")){ \n     list.remove(i); \n     i--; \n   } else if ((list.get(i).equals(\"a\")) && (i+1) < list.size()) \n   { \n    if ((list.get(i+1).equals(\"c\"))) { \n     list.remove(i+1); \n     list.remove(i); \n     i--; \n    } \n   } \n  } \n System.out.println(list);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this code should solve this problem..   public static String eliminate(String data){   char[] strArr = data.toCharArray();   int len = strArr.length;   int i = 0 ;   while(len>0){    if(strArr[i]=='b')     strArr[i]= ' ';    if( i    strArr[i] = strArr[i+1] = ' ';    i++;    len--;   }      return new String(strArr);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Pure c style"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this is my solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static char[] replace_b_ac(char[] array) { \n \n        int j = 0; \n        for (int i = 0; i < array.length; i++) { \n \n            if (array[i] != 'b') { \n \n                if (array[i] == 'c' && j > 0 && array[j - 1] == 'a') { \n                    j--; \n                } else { \n                    array[j] = array[i]; \n                    j++; \n                } \n            } \n \n        } \n \n        for (int k = j; k < array.length; k++) array[k] = '\\0'; \n        return array; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void  \neliminate (char *s) \n{ \n        int move = 0; \n        while (*s != '\\0') { \n                if (move) { \n                        if ((*s != 'b') && !(*s == 'a' && *(s+1) == 'c')) { \n                                *(s-move) = *s; \n                        } \n                } \n                if (*s == 'b') { \n                        move++; \n                } \n                if (*s == 'a' && *(s+1) == 'c') { \n                        s++; \n                        move=move+2; \n                } \n                s++; \n        } \n        *(s-move)='\\0'; \n        return; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be achieved in O(n)  private String remove(String s) {         StringBuilder temp = new StringBuilder();         int len = s.length();                  for(int i=0;i            if((s.charAt(i) != 'b') && (s.charAt(i) != 'a')) {                 temp.append(s.charAt(i));             }                          if(s.charAt(i) == 'a')  {                 if(s.charAt(i+1) == 'c') {                     i++;                 } else {                     temp.append(s.charAt(i));                 }             }         }                  return temp.toString();     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/*Eliminate all ??b?? and ??ac?? in an array of characters, you have to replace them in-place, and you are only allowed to iterate over the char array once.  Examples: abc -> ac ac->'' react->rt*/  #include int move=0;  int checkOut(int aPt,char *str) {     int i,x=0,j;     for(i=aPt+1;i    {         if(str[i]=='b')             x++;         else if(str[i]=='a')         {             j=i;             i=checkOut(i,str);             printf(\"%d %s\\n\",aPt,str);             if(str[j+1]=='c')             {                 move+=2+x;                 str[j-x]=str[j+2];             }             return i;         }         else if(str[i]=='c')         {             str[i-x]='c';             move+=x;             return i;         }         else             return i;     } }  int main() {     char str[50];     int i,j,x=0;     scanf(\"%s\",str);     for(i=0;i    {         printf(\"%d %d %s\\n\",i,move,str);         if(str[i]=='b')             x++;         else if(str[i]=='a')         {             j=i;             i=checkOut(i,str);             if(str[j+1]=='c')             {                 move+=2+x;                 if(j+2!=strlen(str))                     str[j-x]=str[j+2];             }         }         else if(str[i]=='c')         {             str[i-x]='c';             move+=x;         }         else             str[i-move]=str[i];     }     str[strlen(str)-move]='\\0';     printf(\"%d %s\\n\",move,str); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/*Eliminate all ??b?? and ??ac?? in an array of characters, you have to replace them in-place, and you are only allowed to iterate over the char array once.  Examples: abc -> ac ac->'' react->rt*/  #include int move=0;  int checkOut(int aPt,char *str) {     int i,x=0,j;     for(i=aPt+1;i    {         if(str[i]=='b')             x++;         else if(str[i]=='a')         {             j=i;             i=checkOut(i,str);             printf(\"%d %s\\n\",aPt,str);             if(str[j+1]=='c')             {                 move+=2+x;                 str[j-x]=str[j+2];             }             return i;         }         else if(str[i]=='c')         {             str[i-x]='c';             move+=x;             return i;         }         else             return i;     } }  int main() {     char str[50];     int i,j,x=0;     scanf(\"%s\",str);     for(i=0;i    {         printf(\"%d %d %s\\n\",i,move,str);         if(str[i]=='b')             x++;         else if(str[i]=='a')         {             j=i;             i=checkOut(i,str);             if(str[j+1]=='c')             {                 move+=2+x;                 if(j+2!=strlen(str))                     str[j-x]=str[j+2];             }         }         else if(str[i]=='c')         {             str[i-x]='c';             move+=x;         }         else             str[i-move]=str[i];     }     str[strlen(str)-move]='\\0';     printf(\"%d %s\\n\",move,str); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include {  int i,j;   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n int main() \n { \n  int i,j; \n  for(i=0;i<10;i++) \n  { \n   printf(\"%d\\n\",i); \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/*Eliminate all ??b?? and ??ac?? in an array of characters, you have to replace them in-place, and you are only allowed to iterate over the char array once. \n \nExamples: \nabc -> ac \nac->'' \nreact->rt*/ \n \n#include \nint move=0; \n \nint checkOut(int aPt,char *str) \n{ \n    int i,x=0,j; \n    for(i=aPt+1;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void eliminate(char *p){ \n     char *q=p; \n     while(*p){ \n               while((*p=='b') || (*p=='a' && *(p+1)=='c')){ \n                               if(*p=='b') \n                                          p++; \n                               else \n                                          p+=2; \n               } \n               *q=*p; \n               q++; \n               p++; \n     }      \n     *q='\\0'; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) {      char []arr = {'r','b','x','y','c','c','c'};   int j=-1;   for(int i=0;i   if(arr[i]=='b'){ //    arr[j]=arr[i+1];     continue;    }    if(arr[i]=='c' && arr[j]=='a'){     j-=1;     continue;    }    j+=1;    arr[j]=arr[i];   }   System.out.println(\"Final length is:\"+(j+1));   for(int i=0;i<=j;i++){    System.out.print(arr[i]+\",\");   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This should work fine ..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{{ i=0 c=0  while i     if a[i]=b then i++     elseif a[i]=a and i+1    else {   a[c]=a[i]  c++     }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class removeacAndb { \n public static void main(String[] args) { \n  int k = 0; \n  int i = 0; \n  String s = \"acbadc\"; \n  char[] a = s.toCharArray(); \n \n  while (i < a.length) { \n   if (!(a[i] == 'a' && ((a[i + 1] == 'c') && i + 1 < a.length))) { \n    if (a[i] != 'b') { \n     a[k] = a[i]; \n     k++; \n    } \n   } else \n    i++; \n   i++; \n  } \n  int p = 0; \n  while (k > p) { \n   System.out.print(a[p]); \n   p++; \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think we can use prime numbers for this one."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use two pointer char * write and char * scan, write points to the position to write, whereas scan points to the position to scan."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I was thinking about different solutions but didn't find any one of them generic for all such problems, so writing this solution of mine. I am planning to use a TRIE tree. Will create an TRIE tree using all pairs which can be replaced like b -> \"\" and ac ->\"\". TRIE will be something like"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// Replacing ac and b with blank. Once done, splitting, merging and converting to char[] again.  for(int i=0,j=-1;i   switch(arr[i]){     case 'a' : j=i;        break;     case 'c' : if(j!=-1){        arr[j--] = ' ';        arr[i] = ' ';        }        break;           case 'b' : arr[i] = ' ';        break;     default :  j=-1;        break;             }   }      String result = \"\";   for(String s : (new String(arr).split(\" \")))    result = result + s;     arr = result.toCharArray();      for(char c : arr)    System.out.print(c+\" \");"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hi, please check this piece of code. If there is any issue in this"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void removeChars(char *src){   char *i = src, *j = src;  while ((*i++ = *j++)) {   if(*(j-1) == 'b') i--;   if((i-src) >=2 &&  *(j-1) == 'c' && *(j-2) == 'a') i-=2;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nvoid edit(char *str); \nint main() \n{ \n        char str[20]=\"bacbacapplebbac\"; \n        edit(str); \n        printf(\"%s\\n\",str); \n} \nvoid edit(char *str) \n{ \n    int i=0; \n    char *temp=str; \n    while(*temp) \n    { \n        if(*temp=='b') \n       temp++; \n        else \n        { \n            if(*temp=='a'&&(*(temp+1)=='c')) \n            { \n                temp=temp+2; \n \n            } \n \n            else \n            { \n                str[i]=*temp; \n                temp++;i++; \n \n \n            } \n        } \n    } \n        str[i]='\\0' ; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using in-place stack - this is the only right solution and it actually works!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \nusing namespace std; \n \nint main()  \n{ \n    char s[] = \"adaabunhaccc\"; \n     \n    int p, i, l; \n     \n    l = strlen(s); \n    i = 0; \n    p = -1; \n      \n    while(i < l) \n    { \n        if(s[i] == 'b') \n          s[i] = '\\0'; \n        else if(s[i] == 'a' && s[i + 1] == 'c') \n        { \n          s[i] = s[i + 1] = '\\0'; \n          ++i; \n        } \n        else if(s[i] == 'c') \n        { \n            if(s[p] == 'a') \n            { \n               s[i] = s[p] = '\\0'; \n               --p; \n            } \n            else \n               s[++p] = s[i]; \n        } \n        else \n           s[++p] = s[i]; \n        ++i; \n    } \n    s[++p] = '\\0'; \n     \n    cout << s << endl; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"In the first pass remove all 'b' Then in the second pass search for a 'c' and once you find a 'c' then go back and look for its immediate 'a' and found delete it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public String removeBandAC(String s) {  String s = s.removeAll(s,\"b\");  s = s.removeAll(s,\"ac\");  return s; }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=18469665","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"36","title":"Two numbers are represented as linked lists. Both lists are of same length. Add them without manipulating the lists and without a second traversal.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"It's a simple mathematics problem and no additional DS or additional traversal  are required. Just do a single traversal of both LL's from start to end,  and add up the current two values (CRV=L1[i] + L2[i]), multiply the stored  accumulator by 10 and add the CRV.  Below is the pseudo code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"try it recursively..  first go to end of both the list.  from there start adding number and return the carry number. while in each recursion add the numbers and carry number. at the end when we reach to the first nodes  i.e. the MSB of the number add these and get the carry number. if that carry number is non zero then add one more node to the head with that value."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Assuming the first list is list1, second list is list2, result has to be stored in list3 if ((list1==null) and (list2==null))  { list3==null; }  If (list1 == null)  //traverse through list 2 and assign list3 = list2  if(list2 == null) //traverse through list 1 and assign list3=list1  //assuming all error cases are handled  consider this function"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"We can use a helper data structure? like stack? If so, we can iterate both lists. push elements of list1 to stack1, push elements of list2 to stack2.  Than start popping elements from the stack (elem1 from stack1, elem2 from stack2): adds them and put the new value in the beginning of the new list we are building... something like:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use lazy evaluation of recursion. So technically the unfolding of recursion is not a traversal. So, h1 and h2 are the heads, h3 is the result. h3 could have length 1 greater than that of h1. Ive written a quick sample here.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int Count(List* first, List* second) \n{ \n if(!first || !second) \n return; \n Stack numbers = new Stack(); \n while(first) \n { \n  numbers.push(first->data + second->data); \n  first = first->next; \n  second = second->next; \n } \n int count = 0; \n for(int i = 0; !numbers.Empty(); ++i) \n { \n  int num = numbers.Pop(); \n  if(i == 0) \n   count = num; \n  else \n   count += (num << (3*i)) + (num << i); \n } \n return count; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static Integer addList(LinkedList listone, LinkedList listtwo){ \n \nint carryover = 0; \nint tempsum = 0; \nint carryoverindex = 0; \n \nStringBuilder sumbuild = new StringBuilder(); \n \n \n \nfor(int i=listone.size()-1;i>=0;i--){ \n \n \n     \nif((carryoverindex - 1) != i){ \ncarryover = 0; \n} \n \n \ntempsum = (int)listone.get(i) + (int)listtwo.get(i) + carryover; \n \nif(tempsum > 9 && (i != 0)){ \ncarryoverindex = i; \ncarryover = (tempsum-(tempsum - 10))/10; \ntempsum = tempsum - 10; \nif (carryover == 0){ \ncarryover = 1; \ntempsum = 0; \n} \n \n} \n \n//System.out.println(sumbuild+\" \"+i+\" \"+\"before \"+tempsum); \nsumbuild.append(tempsum); \n \n \n \n} \nreturn Integer.parseInt((sumbuild.reverse()).toString()); \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Logic: recursion is one of the best solution for this problem but yes it will be considered as 2 traversal of input list because one time traversal means one you analysed the the node and moved out don't come back to that node again.... whereas in our case one time we check whether the node is not null to get end point for node and second time we analysed the node to perform adding operation. so 2 traversal..... it seems :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If extra space is not a problem, the below approach should work.   1) Compute two integers by parsing the first two lists (assuming the numbers stored in the list are within integer's size. If not, any of the recursive solutions in this thread should be fine).  2) Add both the integers and store it in a resultant variable 3) Break down the digits in the resultant variable and store it in the third list"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is recursive solution in java."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct Node * RecurAddWrap(struct Node *first,struct Node *second,int &carry) {  if(!first && !second)   return NULL;  struct Node *local=RecurAddWrap(first->next,second->next,carry);  int sum=first->data + second->data+carry;  carry=sum>=10?1:0;  struct Node *temp=NewNode(sum>=10?sum%10:sum);  temp->next=local;  return temp; } struct Node * RecurAdd(struct Node *first,struct Node *second) {  int carry=0;  struct Node *res=RecurAddWrap(first,second,carry);  if(carry)  {   struct Node *t=NewNode(carry);   t->next=res;   return t;  }  else   return res; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The problem can be solved if you can handle the carry... there are two cases to handle the carry... 1 is if 9 + 9 =  18. in that case we'll receive the carry as the head of the list. other cases are 99 + 99 = 198 in  which we've to add the carry to the previous node. just little paper and pencil will ensure that we'll never have a carry greater than 1 and we'll never have a sum%10 greater 8. therefore we just have to handle two cases only.   Following is the algorithm please suggests any improvement."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// Addition may also be so complex :) but google can make it in interview, i think !! \n /*   AUTHOR @ AVANEESH KUMAR2013 ,BIET JHANSI, prmrs111@live.com       */ \n  \n#include \n#include \n#include \n#include \n#include \n#include \n#include \n#include \n#include \n#include \n#include \n#include \n#include \n#include \n#include \n#include \n#include \n#include \n#include \n#include \n// TOO lazy  :) \nusing namespace std; \n  \n#define input(t) scanf(\"%d\",&t) \n#define input_ll(t) scanf(\"%lld\",&t) \n#define LL long long \n#define myfor(i,a,b) for(i=a;i<=b;i++) \n#define vi vector  \n#define pb push_back \n//<<<<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>> \nvi array1; \nvi array2; \nint ans[79]; \nint n,spcarry=0,l; \nint carry(int start) \n{ \nif(start==n-1) \n{  \n \n     ans[start]=(array1[start]+array2[start])%10; \n  return (array1[start]+array2[start])/10; \n} \nelse if(start>n-1) \n{ \n return 0; \n} \nelse \n{ \n    ans[start]=(array1[start]+array2[start]+carry(start+1));  \n    if(start==0) \n    spcarry=ans[0]/10; \n    ans[start]=(array1[start]+array2[start]+carry(start+1))%10; \n    return (array1[start]+array2[start]+carry(start+1))/10; \n} \n \n \n} \nint main() \n{ \n int i,temp; \n cout<<\"what is the length of arrays?\"<>n; \nmyfor(i,0,n-1) \n{ \n  cin>>temp; \n  array1.pb(temp); \n} \nmyfor(i,0,n-1) \n{ \n   cin>>temp; \n   array2.pb(temp); \n} \n carry(0); \n cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct node { \n        int x; \n        struct node *next; \n}; \n \n \nint  \nadd (struct node *n1, struct node *n2, int *level) { \n        int l = 0; \n        int sum = 0; \n        if (!n1 || !n2) { \n                exit(EXIT_FAILURE); \n        }    \n        if (n1->next == NULL && n2->next == NULL) { \n                *level = 1; \n                return (n1->x + n2->x); \n        } else { \n                sum = add(n1->next, n2->next, &l); \n                *level = l + 1; \n                return (pow(10, l)*(n1->x + n2->x) + sum); \n        }    \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//init flag = 1; \nvoid add_list(struct node *lista, struct node *listb, struct node **target,int flag) { \n    if (lista == NULL && listb == NULL)  \n        return; \n    add_list(lista->next,listb->next,target,0); \n    struct node temp,temp1; \n    temp = malloc(sizeof(struct node)); \n    temp->data = lista->data + listb->data; \n    if(*target != NULL) { \n        if(*target->data >= 10) { \n            *target->data = *target->data - 10; \n            temp->data = temp->data + 1; \n        } \n    }     \n    temp->next = *target; \n    *target = temp; \n     \n    //Used only for the first iteration and that is why it is messy !! \n    if (flag && (*target->data >= 10)) { \n        temp1 = malloc(sizeof(struct node)); \n        temp1->data = 1; \n        *target->data = *target->data - 10; \n        temp1->next = *target \n        *target = temp1; \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node* add(Node *n1,Node *n2,int *carry){ \n      if(!n1) \n             return NULL; \n      Node *t=add(n1->next,n2->next,carry); \n      int sum=n1->data+n2->data+*carry; \n      *carry=(sum/10)%10; \n      sum=sum%10; \n      Node *n=create(sum); \n      n->next=t; \n      return n; \n} \nNode *addTwoNums(Node *n1,Node *n2){ \n     int carry=0; \n     Node *t=add(n1,n2,&carry); \n     if(!carry) \n               return t; \n     Node *n=create(carry); \n     n->next=t; \n     return n; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"As some mentioned above the recursive solution is the most efficient. Here is my solution in Scala. Wrote it in 'gedit' :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"L1 : 4 -> 5 -> 6 L2 : 4 -> 5 -> 6  result should be a linked list. L3:  9 -> 1 -> 2  9 <- 1 <- 2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here you go. This handles unequal sized lists too.     int[] carriage = new int[Math.max(num1.size(), num2.size())+1];    int[] result = new int[carriage.length];    boolean carr = false;        Iterator itMax = num1.size()   Iterator itMin = num1.size()   int n,n1,n2;    int multiplier = (Math.max(num1.size(), num2.size()) - Math.min(num1.size(), num2.size()));    int minSize = Math.min(num1.size(), num2.size());    int maxSize = Math.max(num1.size(), num2.size());     int y=0,x=0;        // Initial sum from left to right. Also maintaining carriages for normalization.    // Parsing the linked list only once.    for(int i=0;itMax.hasNext();i++){     n1 = itMax.hasNext()?(itMax.next()).val:0;     n2 = itMin.hasNext()?(itMin.next()).val:0;     y = (int) (y + n2 * (Math.pow(10,(minSize-1-i))));          n = (n1 + n2);     if(n/10 > 0 || n==10){      carriage[i] = 1;      carr = true;     }     result[i+1] = n%10;    }     //Normalizing    while(carr){     x = 0;     carr = false;     for(int i=1;i     if((result[i]+carriage[i])/10>0 || (result[i]+carriage[i])==10){       carriage[i-1] = 1;       carr = true;      }      result[i] = (result[i]+carriage[i])%10;      x = (int) (x + (result[i] * (Math.pow(10,(maxSize-i)))));       carriage[i] = 0;     }    }        //Result Sum    System.out.println(\"SUM = \"+(x-(int)(((Math.pow(10,multiplier))-1)*y)));"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int sum = 0; int count = 0; int totaCount = 0;    private void sumNode(MyLinkList.Node n1, MyLinkList.Node n2) {   if(n1.next != null){    count++;    if(totaCount < count){     totaCount = count;    }    sumNode(n1.next, n2.next);   }   int ret = n1.val+n2.val;   sum += (ret*Math.pow(10,(totaCount-count)));   count--;  }  Basically adding from back to front node to node and multiplying every node with its decimal position before adding so  919 935 woule be Sum += 9+5 = 14*10^0 = 14 sum += 3+1 = 4*10^1 = 40 sum+= 18*10^2 = 1800  sum = 1854"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Are you sure without second traversal... it can be done in O(n) but second traversal would be needed"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"second traversal means ??"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=18405668","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"22","title":"Add a number to array and if there is carry increase array size. ---------------------------------------------------------------------- For example input = {7,3,5,3,9} convert this to number 73539, add 1 so it becomes 73540 and convert to array {7,3,5,4,0}.  Array can be of any length, so you can't always represent array in form of in-built number format. So you have to do this summation in-place. Also, how would you increase array size in-case input = {9,9,9} so output = (1,0,0,0}  Assume, all elements of arrays are between 0 and 9.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"int[] add(int arr[], int val){ \n int carry = 0; \n for(int i=arr.lenght() -1; i>=0; i--){ \n  arr[i] = val%10 + arr[i] + carry; \n  val /= 10; \n   \n  if(arr[i]> 9){ \n   carry = 1; \n   arr[i] %= 10; \n  } \n  else carry = 0; \n } \n \n if(carry!=0){ \n  int[] temp = new int[arr.length()+1]; \n  for(int i=temp.lenght()-1; i>0; i--) \n   temp[i] = arr[i-1]; \n  temp[i] = carry; \n  delete(arr); \n  return temp; \n } \n  \n return arr; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"How do you do 999 to 1000 inplace?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int[] Addition(int val, int a[])  {  int array=new array[a.length()+1];  for(int index=0;index<=a.length();index++)           {   val=val%10;   if(val){    array[index]=a[a.length()-index]+val;                    }           }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class XSLT { \n \n  \n public static void main(String[] args) { \n   \n   \n   \n  int[] arr = {9,9,9}; \n  int num = 1; \n  int a=0; \n  for(int i=0;i0) { \n    \n   ram/=10; \n   temp++; \n  } \n  if(temp>arr.length) \n   carry=true; \n  ram/=10; \n  a/=10; \n  if(!carry) \n  while(newSum>0 && a>0) { \n    \n   if(ram%10>a%10) { \n     \n    carry=true; \n   } \n    \n   ram/=10; \n   a/=10; \n  } \n   \n  ram=newSum; \n  System.out.println(\"New SUm ::\"+newSum); \n  int lenth=0; \n  while(ram>0) { \n    \n   ram/=10; \n   lenth++; \n  } \n   \n  if(carry) { \n   System.out.println(\"Carry is there\"); \n   arr = new int[lenth]; \n    \n   while(newSum>0) { \n     \n    arr[lenth-1]=newSum%10; \n    System.out.println(arr[lenth-1]); \n    lenth--; \n    newSum/=10; \n   } \n  } \n  else \n   System.out.println(\"No carry\"); \n   \n   \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If we are interested in the final result, then the we can achieve the result without conversion. The code is given below"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Arrays;   public class ArrayToNumber {   /**   * @param args   */  public static void main(String[] args) {   // TODO Auto-generated method stub   //int [] inputArray = {9,9,9};   int [] inputArray = {7,3,5,3,9};   System.out.println( \"out put:\"+ Arrays.toString(inputNumber(inputArray)));   }  /**   *    For example input = {7,3,5,3,9} convert this to number 73539,    add 1 so it becomes 73540 and convert to array {7,3,5,4,0}.    Array can be of any length, so you can't always represent array in form    of in-built number format. So you have to do this summation in-place.    Also, how would you increase array size in-case input = {9,9,9}    so output = (1,0,0,0}    Assume, all elements of arrays are between 0 and 9.   */  public static int [] inputNumber(int [] inputArray){   int integerValue=0;   int [] outputArray = new int[inputArray.length];   int [] overFlowOutputArray = null;     //Converting array of elements into integer number   for(int i=0; i   integerValue=integerValue*10+inputArray[i];   }   //Adding one to the integer number which got from previous step   integerValue = integerValue+1;     //Converting integer number back array   for(int j=inputArray.length-1; integerValue>0;j--){     //Check the array need to be increased and return the array    if(j==-1){     overFlowOutputArray = new int[inputArray.length+1];     System.arraycopy(outputArray, 0, overFlowOutputArray, 1, inputArray.length);     overFlowOutputArray[0] = integerValue%10;     return overFlowOutputArray;    }    outputArray[j] = integerValue%10;    integerValue = integerValue/10;    }   return outputArray;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Arrays; \n \npublic class ArrayToNumber { \n \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n  // TODO Auto-generated method stub \n  //int [] inputArray = {9,9,9}; \n  int [] inputArray = {7,3,5,3,9}; \n  System.out.println( \"out put:\"+ Arrays.toString(inputNumber(inputArray))); \n \n } \n /** \n  *  \n  For example input = {7,3,5,3,9} convert this to number 73539,  \n  add 1 so it becomes 73540 and convert to array {7,3,5,4,0}.  \n  Array can be of any length, so you can't always represent array in form  \n  of in-built number format. So you have to do this summation in-place.  \n  Also, how would you increase array size in-case input = {9,9,9}  \n  so output = (1,0,0,0}  \n  Assume, all elements of arrays are between 0 and 9. \n  */ \n public static int [] inputNumber(int [] inputArray){ \n  int integerValue=0; \n  int [] outputArray = new int[inputArray.length]; \n  int [] overFlowOutputArray = null;   \n  //Converting array of elements into integer number \n  for(int i=0; i0;j--){  \n   //Check the array need to be increased and return the array \n   if(j==-1){ \n    overFlowOutputArray = new int[inputArray.length+1]; \n    System.arraycopy(outputArray, 0, overFlowOutputArray, 1, inputArray.length); \n    overFlowOutputArray[0] = integerValue%10; \n    return overFlowOutputArray; \n   } \n   outputArray[j] = integerValue%10; \n   integerValue = integerValue/10;  \n  } \n  return outputArray; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int[] add(int[] arr, int num){ \n  int carry = 0; \n  for(int x = arr.length -1; x >= 0; x--){ \n   int place = (int) Math.pow(10, ((arr.length-1) -x)); \n   int otherNum = (num % (place*10)) / place; \n   int newNum = arr[x] + otherNum + carry; \n   carry = newNum /10; \n   arr[x] = newNum % 10; \n  } \n  if(carry != 1) \n   return arr; \n  else{ \n   int[] res = new int[arr.length+1]; \n   res[0] = carry; \n   for(int x = 1; x < res.length; x++){ \n    res[x] = arr[x-1]; \n   } \n   return res; \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class Test{ \n    public static void main(String[] args){ \n        int a[] = {9,3,4}; \n        int add = 999,carry = 0,val=0,sum=0; \n        for(int i = a.length-1; i >= 0; i--){ \n            val = add%10; \n            add = add/10; \n            sum = val + a[i] + carry; \n            if(sum > 9){ \n                carry = 1; \n                a[i] = sum % 10; \n            }else{ \n                a[i] = sum; \n                carry = 0; \n            } \n        } \n        if(add > 0 || carry == 1){ \n                System.out.println(\"add \" + (add+ carry) + \" before array like arr[-1].. hahha\"); \n        } \n        for(int i = 0; i< a.length; i++){ \n            System.out.print(a[i]+\" \"); \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Python function:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nint main(){ \n int n,a[20],b[20],i,count=0; \n long num=0,num1; \n clrscr(); \n printf(\"Enter number of elements in the array: \"); \n scanf(\" %d\",&n); \n for(i=0;i=0;i--){ \n     b[i]=num1%10; \n     num1=num1/10; \n } \n printf(\"\\nThe new array is: \"); \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static int[] calculate(int[] input) {         int len = input.length, sum = 0, i = 0;         boolean flag = true;         for(i =0; i            sum = sum*10 + input[i];             if(input[i] != 9) flag = false;         }         sum += 1;                  if(flag){             len = len+1;             int[] returnArr = new int[len];             for(i=len-1; i >=0; i--) {                 returnArr[i] = sum%10;                 sum=sum/10;             }             return returnArr;         } else {             for(i=len-1; i >= 0; i--) {                 input[i] = sum%10;                 sum = sum/10;             }         }         return input;     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Language: JavaScript Assumptions: arr is an integer array, num is an integer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Language: JavaScript Assumptions: arr is an integer array, num is an integer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class HAarray{  public static int[] add(int [] data){     int [] hold=new int[data.length];         for(int i=data.length-1;i>=0;i--){        if(data[i]==9 ){            if(i==0){              return newArray(data.length);            }            data[i]=0;        }        else {            data[i]=data[i]+1;            return data;        }    }    return data;     }  public static int [] newArray(int lengthh){     int [] chk=new int[lengthh+1];     for(int i=0;i        if(i==0){             chk[i]=1;         }         else {             chk[i]=0;         }     }     return chk; } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Arrays; \n \npublic class AddNumberToArray { \n \n public static void main(String[] args) { \n  int[] a = { 9, 9, 9, 9, 9, 5, 8, 9, 9, 9, 3, 5, 6, 7 }; \n  int[] ans = addNumber(a); \n  System.out.println(Arrays.toString(ans)); \n } \n \n private static int[] addNumber(int[] a) { \n  int l = a.length; \n  int lastEl = a[l - 1] + 1; \n  if (lastEl < 10) { \n   a[l - 1] = lastEl; \n   return a; \n  } else { \n   int carry = 1; \n   a[l - 1] = lastEl % 10; \n   int j; \n   for (int i = l - 2; i >= 0; i--) { \n    j = a[i] + carry; \n    a[i] = j % 10; \n    carry = j / 10; \n   } \n   if (carry == 1) { \n    int[] res = new int[l + 1]; \n    res[0] = carry; \n    System.arraycopy(a, 0, res, 1, l); \n    return res; \n   } \n   return a; \n  } \n \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this approach?  Since in worst case, the array size will increase by only one assuming the addend is that the array size, so in that case, we can go for the following approach:  Len:= arr.size() put all the digits from arr[Len+1] back to the first position. Now if after all this addition, carry exists, then add that carry to arr[0]. Else left-shift the array by 1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int [] arrayPlusOne(int[]num) \n { \n  int i=1; \n  while(num[num.length-i]==9&&i < num.length){ \n   num[num.length-i]=0; \n   i++;   \n  } \n  if(num[0]==9 && num[1]==9){ \n   int finArr[]=new int[num.length+1]; \n   finArr[0]=1; \n   for(int j=1;j"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simple: Since digit is between 0-9, traverse from the last element, if it is 9, change it to 0; if non-9, increment it, stop the loop when we see the first non-9 digit. If all digits are 9, return 10....."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=18090674","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"16","title":"Data-structure and algorithm used in Load Balancer??  Explaining algorithm write code for it","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"We can use something like a min-heap. Where the node value is the number of connections handled by the server. Each server can maintain a list of clients it is serving.   In addition to this we can have a HashMap to store the  pair to retrieve the server."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I had implemented load balancer by using the algorithm Round Robin algorithm for load balancing servers and it was implemented with Cirular Linked List.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I would ask more questions to the interviewer, if it is dumb load balancer a round robin will work like Aresh mentioned, otherwise we'll have to have a policy by which we will decide the request goes to which server. like random, scatter and gather, sticky session, based on some parameter. Look at this page for some ideas: http :// horicky.blogspot.com/2010/10/scalable-system-design-patterns.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There are many different kinds of load balancers. The question isn't meaningful without more context. You should mention what kind of load balancer you're interested in. What problem will this load balancer solve?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"simplest, round robin increment index modulo count"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the real issue/challenge is to break up a task into estimatable loads or tasks to be distributed."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Nah...  supposing this is a server, wouldn't be better to have a self organizing array?  Such as if you have a request for a server, you can always return the list's first element and then auto organize the list...  But if you have two request at the same time, you can treat those requesting threads as readers threads and give them the first element while you auto organize your data structure internally for the next requests...  this way you always return the server as fast as possible and doesn't need a synchronized area...  although I think the round robin could work well to because is simple enough to don't be a bottleneck if your request are not that big. If they are, you can always organize your servers as a tree, delegating forward the request."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You should ask some clarification questions before answering.  Are the machines identical?  Do they have same \"max connection limit\"?  All the incoming requests to the load balancer takes same time to complete, i.e., fixed?  Lets say, we've three machines A,B,C. Now, the job of load balancer is to make sure the load is uniformly distributed across all the machines and same time it doesn't overload the machines. This means, the load balancer should consider the max processing power of each machine (i.e., the max connections that a machine can support). Typically its not same for each machine, the hardware configuration will vary between machines (or each machine may run additional processes). Above data are almost static., we've to consider an another important runtime parameter, the time taken for a request (or number of active connections on a machine), also must to be  to balance the load. The naive approach is to use round robin method (just distribute one request to each machine circularly). Otherwise maintain the above mentioned details in a bucket and distribute the load. When we reach the bucket capacity, keep the incoming requests on hold (may be in a queue) instead of overloading the machines (that will crash the all machines).  Hope it helps!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is some code for a min heap. The key is the comparable strategy, is this case minimum usage and incriminating that usage upon getting the top of the heap. The rest should be straight forward.   Kind regards"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17886663","download_status":"DOWNLOAD_DONE","votes":"-2","answersCount":"16","title":"Consider a city with 50 locations each numbered from 0 to 49.  Mr. XYZ runs a taxi service in a city. He has 25 Taxi??s to service the passengers. When passenger needs a taxi he makes a call to Mr. XYZ and give details like his current location as a source, and where he is willing to travel as a destination. He also tells max time he can wait for a taxi. In return Mr. XYZ either allocate a taxi to the passenger or tell him request can??t be satisfied within the given max_waiting time. Allocated taxi travels from its current location to the passengers pick-up point i.e. the source. This travel is termed as non revenue travel. Mr. XYZ charge passenger only for the distance from source to the destination. After dropping passenger to the destination taxi waits for call from Mr. XYZ to serve next passenger. Let??s assume we know all TaxiHireRequests in advance. We also know the distance and time to travel between any two locations in the city.    Write a program which will choose the taxi??s such that sum of non_revenue distance travelled by all the Taxi??s is minimum and the number of unsatisfied requests are minimized. Also print the total non_revenew distance and number of unsatisfied requests.    pseudo helper structures.  struct TaxiHireRequest{ int Time Of Request;//Number of seconds from 12AM int Source; // an int from 0 to 49 int Destination;// an int from 0 to 49 int Maximum waiting time // in seconds; }[200]    struct Taxi{ int location;//an int from 0 to 49 bool isHired//true or false }[25]    int Distance[50][50]; int Time[50][50]; // Extend the structure whenever required.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"In-Person? Yeah right. When is the homework due?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is this a case of a dynamic stable matching ? The car's preferences keep changing. The passengers however luckily are known in advance - is there an algorithm that deals with this?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Note: This is just pseudo code... And I think it's right but you be the judge."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Correction:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Did anyone else try this?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi llwire,  Doesn't your code have the problem, that the same taxi might be chosen as bestTaxi for multiple jobs. So beside current job you also need to take care if the taxi has already been alloted for next job."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just a try:  Sort the jobs by max_waiting_time. Step 1: For each job, find the taxi at the nearest location(s)  and assign it for the job if it can reach within the waiting time. This way we are minimizing both the unsatisfied and non-revenue distance.  Step 2: However, we also need to take care that what happens when a taxi has completed current job. I would update each location with those taxis  as well which have their destination set to that location and have additional wait time for that taxi, equal to the time for current job and repeat step 1.  Please let me know your views"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Yes, an assigned taxi maybe assigned more jobs if its final destination is closest to the new job while still meeting the wait time requirement. Consider a case where the an assigned taxi is already heading to the destination of the next pickup. In such a case, you wouldn't need to assign a new taxi when the non revenue distance for the assigned one is 0.   There is a flaw in the code above, however. The algorithm here only assigns one extra job to a car. As a matter of fact, it is possible for one car to handle all the jobs if every request destination is the source of the next request provided the time constraints are met. For that case, the Taxi structure needs to be modified to include a list (priority queue) of next jobs. This priority queue would be ordered with distance as the priority and max wait time as the tie breaker.   As a greedy solution, the algorithm must try to greedily service every request with one taxi until that taxi can no longer service any more requests with  respect to the constrains of the problem. It is only then that a new car is used.   What do you think?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"consider, u sort in by distance wise  there are 6 people, person1 is at a minimum distance of 20 from taxi1, and at a distance of 21 from taxi2 consider all the 6 person stands in a straight line(left to right) so that taxi1 is between person 1 and person 2,  while taxi 2 is at a distance of 21 on the left side of person1 so no point of using taxi 2 considering infinite waiting time.   person 2 at dist 23 p3 at d 24 p4 at d 25 p5 at d 26 p6 at d27  if taxi 1 services person1 1st, the unwanted_distance will be 20*2+23+1+1+1+1=40+27=67  if taxi 2 services person 1unwanted_dist=21 so for 6 people with taxi1 unwanted_dist=27 for person1 the unwanted_dist=22 so total unwanted_dist=27+21=48   so we see the above solution provided fails"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the last 3 lines written again corrected*  if taxi 2 services person1 unwanted_dist=21  so for rest 5 people with taxi1 unwanted_dist=27  so total unwanted_dist=27+21=48"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I'm sorry but I'm not sure what you're talking about. Nowhere in the solution do we sort according to distance. Also, I don't think the scenario you're describing is entirely accurate. You don't consider, at all, the start and end points of any of the trips which are very important in the taxi selection.  For instance if taxi1 in selected for a pickup, which is at d 20 away, where is the person going? If it is as you say and person 2 is at d 21 from taxi one's final destination then, how much time does it take taxi 1 to finish his current pickup and go back to pick up person? Can he make it in given waiting time? If taxi one can make it in time it doesn't matter if taxi 2 is free at d 23 away from person. You have to send taxi 1 because it is the shortest non revenue distance while still meeting the wait time requirement. This is what the algorithm does.  You can't assume that requests should be handled on a 1 to 1 basis. Since the positions of the taxis are always changing, one taxi may serve more customers than the others."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My logic:- \nstruct distance{ \n int distance[50][50]; \n int Time[50][50]; \n}; \nstruct taxi{ \n bool isHired; \n int location; \n int destination; \n} \nstruct MrXYZ{ \n struct taxi t[25]; \n} \nstruct caller{ \n int Source; \n int destination; \n int max_waiting_time; \n} \n \nConditions will be :- \n \n 1. if(taxi[i].isHired == 0 && taxi[i].location == caller.Source) \n change attribute of Taxi and Hire it. \n 2. else if(taxi[i].isHired==1&& taxi[i].end == caller.Source &&distance.Time[taxi[i].location][taxi[i].end]< caller.max_waiting_time) \n change attribute of taxi and Hire it. \n 3. else { \n  if(taxi[i].isHired == 0 && distance.Time[taxi[i].location][caller.Source]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hard to believe they asked you this question. This is a linear programming problem, you can use Excel Solver (an extension to Microsoft Excel) to solve it. Generally linear programming is used to solve operations research problems. Operations research is a MBA course."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There are two key issues: i) The local optimal solution (obtained by greedy algo) does not guarantee the global optimal solution. ii) The number of optimal solution may be more than one since the two goals are paradoxical to each other. For example, in some cases, just reject all requests to maintain 0 non-revenue distance would be an optimal solution.  The following is the code. The general idea is to enumerate all possible schedules and find the best ones. The algo goes like this: for each request, i) reject it; ii) choose possible taxi to accept the request. For each option, record the result (i.e., the number of rejected requests and accumulated non-revenue distance). At the end, scan all solutions and find best ones."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17850664","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"45","title":"Given N dices.Each dice has A faces.That means each dice has numbers from 1 to A.Given Sum S,Find the number of ways to make the sum S if dices are rolled together.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"Dynamic Programming solution: Let Nways(s, n) - number of ways to make sum s with n dices. Nways(s, n) = Summation{1..a} Nways(s-i, n-1) Base case:  Nways(s, 1) = 1 if (s<= a && s>0), 0 otherwise.   Edit: I see lot of new solutions posted are using only recursion. Memoization should be used otherwise the algorithm is very slow.   Recursion with a lookup table for already computed values is the right way to go."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Same solution as described by Vinay:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I can only think of a recursive solution wherein you every permutation of the dices which will give me time complexity of A^A. There will be better solution than this."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. 2 <= S <= 2A 2. Total number of variations of dice thrown together: A*A 3. Hence 1/(A*A) <= P(S) <= 1/A"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I use JavaScript function get_dice(s,n,a){  var method = 0;  if(n===1){   if(s>0&&s<=a)    return 1;   else    return 0;  }  for(var i =1;i<=a;i++){   method+=get_dice(s-i,n-1,a);  }  return method; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"good point, I should take 'a' out from the recursive function, thanks"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"noOfWays(N,S) = sum ( noOfWays(N-1,S-i) ) // where i ranges from [1 ,A]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am sorry but it seems like I got this question in different way and I could only get this in Polynomial time.  I mean using binomial theorem it get ( N is a variable number of Die and F is a variable number of faces of each die) so  N1(F)+N2(F)......N(n-1)(F)+N(n)(F)=S   Which clearly frames polynomial expression.  Any Pointers??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@lru_cache(maxsize = None) \ndef numOfWays(max_dice_value, base_sum): \n     \n    if base_sum <= 1:  \n        return 1 \n     \n    total = 0 \n     \n    for val in range(1, max_dice_value+1): \n        if val > base_sum: \n            break         \n        total += numOfWays(max_dice_value, base_sum - val) \n \n    return total"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@lru_cache(maxsize = None) \ndef numOfWays(dices, max_dice_value, base_sum):        \n \n    if base_sum == 0 or (dices == 1 and base_sum > max_dice_value): \n        return 0 \n     \n    if base_sum == dices or (dices == 1 and base_sum < max_dice_value): \n        return 1 \n   \n    total = 0 \n     \n    for val in range(1, min(max_dice_value, base_sum) + 1):                \n         \n        curWaysCount = numOfWays(dices-1, max_dice_value, base_sum - val) \n         \n        total += curWaysCount \n \n    return total"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@lru_cache(maxsize = None) \ndef numOfWays(dices, max_dice_value, base_sum):   \n     \n    if base_sum == 0: \n        return 0 \n     \n    if base_sum > max_dice_value * dices: \n        return 0  \n     \n    if base_sum == dices or (dices == 1 and base_sum < max_dice_value): \n        return 1 \n   \n    total = 0 \n     \n    for val in range(1, min(max_dice_value, base_sum) + 1):  \n         \n        if val > base_sum: \n            break \n                  \n        if (base_sum - val) == 0 and dices == 1: \n            total += 1         \n        else:         \n            total += numOfWays(dices-1, max_dice_value, base_sum - val) \n \n    return total"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int sum(int[] atp) { \n  int sum = 0; \n  for (int i = 0; i < atp.length; ++i) { \n   sum += atp[i]; \n  } \n  return sum; \n } \n \n public static void tryDice(final int[] atp, final int F, final int N, final int count, final int S) { \n  if (count > N - 1) { \n   int sum = sum(atp); \n   if(sum == S){ \n    for (int i = 0; i < atp.length; i++) { \n     System.out.print(atp[i] + \" \"); \n    } \n    System.out.println(); \n     \n   } \n   return; \n  } \n  int cnt = count + 1; \n  for (int i = 1; i <= F; ++i) { \n   int[] newAtp = new int[atp.length]; \n   System.arraycopy(atp, 0, newAtp, 0, atp.length); \n   newAtp[count] = i; \n   tryDice(newAtp, F, N, cnt, S); \n  } \n } \n \n public static void main(String args[]) { \n  int F = 3; \n  int D = 6; \n  int[] atp = new int[D]; \n  int S = 10; \n  tryDice(atp, F, atp.length, 0, S); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a solution with DP and recursion. At each level of the recursion, fix the value of one dice."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if this is just finding number of ways,then here is the answer : 1.This is equivalent to x1+x2+x3+...+xn=S where 1<=x1,x2,x3,..xn<=A where x1,x2,..xn are variables whose values are specified on each dice respectively 2.so now let t1=x1-1,t2=x2-1,t3=x3-1,...so now we have (x1-1)+(x2-1)+..+(xn-1)=S-(1+1+..1)=S-n 3.so now we have t1+t2+t3+..+tn=S-n where 0<=t1,t2,..tn<=A-1 4.The number of ways of forming x1+x2+..xr=n where x1,is (n+r-1)C(r-1)(there is a proof :)) 5.so now the number of ways = (S-n+n-1)C(n-1)=(S-1)C(n-1) (where nCr=n!/(n-r)!(r!) )"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A simple DP approach: The function can be written as: F(N, A, S) = F(N - 1, A, S - 1) + F(N - 1, A, S - 2) +........+ F(N - 1, A, S - A) Where, The F(N, A, S) represents the number of ways of getting S with N dice each with A faces, numbered from 1 to A. Explaining the above equation in words, Find the number of ways of getting Sum (S - 1) from (N - 1) dice +  Find the number of ways of getting Sum (S - 2) from (N - 1) dice + ................. .................. Find the number of ways of getting Sum (S - A) from (N - 1) dice  Carefully handle the base cases like: 1. N = 1, S > A 2. S < 1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a simple implementation is given below which can be memo-ed of course"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what about printing all the possible solutions?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Feel free to correct my answer: the base case is where we roll one dice (N = 1). If number of faces (A) is greater than the sum (S), there is always one possible way.  Other cases: F(n, s, a) = Sum of F(n - 1, s - i, i) where i is 1 to number of faces (A)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Only one way.  All the dice must add up to S."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Guys correct me, if I am wrong. The question in non polynomial (NP) problem. Given N dices and 1...A faces. Therefore the combinations can be A*A*A.......A = A^N. I think all the guys are in right direction sloving by dynamic programming. But need to add distributed computing based on N. Divide the work and add it like map reduce"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class DiceProblem { \n \n public static void waysToFindSum(int sum, int remainingDices,int[] faces, int[] output,int numberOfDices,int numberOffaces){ \n  if(remainingDices == 0 && sum ==0){ \n   System.out.println(\"\"); \n   for(int i = 0; i < numberOfDices; i++){ \n    System.out.print(output[i]+\" \");     \n   } \n   return; \n  } \n  if(remainingDices == 0) \n   return; \n  if(sum == 0) \n   return; \n  for(int j =0; j< numberOffaces;j++){ \n   if(faces[j] <= sum){ \n    output[remainingDices-1] = faces[j]; \n    waysToFindSum(sum-faces[j], remainingDices-1, faces, output, numberOfDices, numberOffaces); \n   } \n  } \n } \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n  int numberOfDices = 3; \n  int numberOfFaces = 6; \n  int sum = 5; \n  int[] faces = {1,2,3,4,5,6}; \n  int[] output = new int[numberOfDices]; \n  waysToFindSum(sum, numberOfDices, faces, output, numberOfDices,numberOfFaces); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Recursive solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hi i wrote the below code for this, can anyone please verify this if it fails in any conditionsor any modifications that should be made"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A C# implementation of the recursive solution described in above posts."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Central limit theorem is for i.i.d random variables, here the probabilities are different for each RV."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I got half a solution so far. Let me know if you can get the other half before I do or I give up. Say you want 13 for a total  And you have 6 dice we won??t worry about the number of faces just yet  If you know that you role 3 ones 2 twos and 1 six you 3 * 1 + 2 * 2 + 1 * 6 = 13 (can I still add?) We can easily calculate that there are (3+2+1)!/(3!*2!*1!) ways to get it  So we added 60 to the count in one step   If we can quickly iterate through all the combinations of counts of each type of face rather than all the actual sets of roles we might come out ahead.  Know any good algorithm for this  Find all sets of X such that  Such that s is the number of faces   X1* 1 + X2*2 + X3*3 ???? Xs * s = total we want  And  X1 + X2 + X3 ???? Xs = total number of dice    We could start with X1 as large as possible and then try to make up the difference buy putting values into  Xs X(s-1), X(s-2). Then we need some way of transferring value from the high side to the low side without repeating any combinations and without missing any. Probably some loops some recursion and or some dynamic programming as in the solutions above. I think my approach makes the problem smaller in some ways but I am not convinced it really has any advantage when all is told.  If you did a brute force search it would cost O(s^n) perhaps even O(s^(1+n)) if you are lazy about how you calculate the totals to check. This is pretty bad. The complexity of the nice simple naive algorithm is O(n^s)  so if n and s are reasonably large and s < n the na?ve direct counting is better than the brute force iteration. Dynamic programming is beginning to look very attractive indeed.  I think I will try a direct recursive method with dynamic programming.  Any thoughts, you think there is hope for getting through the counts quickly?  I expect that they will ask a different question that needs my half of the answer in combination with some other solution  and another question that needs the fast iteration algorithm in combination with yet some other idea: if that makes any sense."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"The probability of Occurrence of a sum while throwing a number of dices can be thought of normal distribution. the probability  function would be p(sum). I forgot the formula, article about normal distribution in Wikipedia might help. After calculating the p(sum), we can multiply the p(sum) by the number of sides power the number of dices"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17693675","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"40","title":"How do you find the greatest 1000 elements in a list of a million elements? No other information given. What would be the runtime? Hint: You can do better than O(n log n). I didn't realize but it could be possible with Tree or Heaps.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"14","title":"It can be solved using heap data structure. The idea is to maintain a heap of 1000 largest elements while scanning through the million elements.  1. Construct a min heap using the first 1000 elements. Now the root has minimum element out of the first 1000 elements.  2. Iterate over the remaining elements one by one. Let 'item' be the element under consideration      if the item is greater than root of the heap, replace the root with the item and heapify the tree.     else continue with the next element.   At the we will have the min heap of 1000 largest elements of the list  Time Complexity : O(N) where N is the number of elements in the list"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Keep an ordered data structure. Insert every element as you go through the list. If the ordered data structure is larger than 1000, remove the smallest element (so it always stays at 1000). Every insert is log(1000) which is a constant factor. You do that for every element in the list, so you have O(N * log(1000)) = O(N * log(C)) = O(N).  Of course this only works as long as the number of 'largest' elements is in fact constant. If you wanted the largest half of elements for example then you'd be back to O(N*log(N)) runtime."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Use Quick sort partitioning method, to partition around the (n-k)th element. All elements to right  of (n-k)th element will be the result. In this case, n = 1 million, k = 1000."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Here is the code to find N largest element using Min heap . For simplicity i used an array as source of input elements and finding 10 largest element."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Probably faster ways, but I only thought about making it easy and still better than n log n  Repeat 1000 times: 1. Loop through the array and search for a max element (remember the index) 2. Add that element to your list 3. Remove the selected element from the original list (remove by index)  Now the list will contain the greatest 1000 elements of the list of million. Could have duplicates. Runtime is 1000 * O(n), which is O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"since the given list is already filled with million elements (assuming string, int or some data type), sort the elements in descending order. Use LSD Radix Sort (assuming fixed length elements). This will sort the array in O(N) time. Then print/extract the top 1000 elements in O(1000) time. Together, this approach should provide O(N) + O(1000) ~ O(N) time performance."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Divide the million elements of the input array into 1000 arrays of 1000 elements.  Send each array to one of 1000 machines in your GRID computing array.   Have them call Collections.sort() and return the first element to you.   What do you mean the network is down?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"One of the solution can be using min heap of size (1000).i.e heap at any instance contains at most  1000 maximum elements.  Algo :-   1> For each input element compare the element with the root element  of the heap. 2> if value(root) > value(element) ; replace root with input element and heapify  Time Complexity - O(nlogn)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"-> Implement a Tree Set in reverse order, so we can get 1000 maximum elements in single shot. Complexity is O(N).  -> Implement a Tree set and use ListIterator and iterate from end. which also has the  same time complexity."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using c#"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since there is nothing mentioned about the space complexity, declare an array of 1 million booleans. Say bool A[1 million]. Parse the list of numbers. Associate the highest number with 1 million in the array A and lowest 0 in the array. Call the minimum number as min. Parse the array again, if x is any number present in the list of million digits, A[x - min] = 1. Then traverse back from the highest index in the array set to 1 till you display 1000 elements."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"implement min heap for 1000 elements."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"u can use the concept of B tree what u have to do is to make 10 heap each of size 100,so that u can handle the 1000 number,now keep these heap on secondary data and in the B tree u keep the location of file and the root value of each heap.u can also maintain a heap of size 10 which keep the track of which heap u have refer when u processing the data.at the end u can traverse ur B tree and get all the 1000 no. :) Tell me if u feel any problem"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about a convex optimization approach with gradient descent? The memory requirements are almost nil (maybe one additional array), but there will be many iterations.   f = min_y ||x-y||_{2}^{2} such that  ||y||_{0} <=1000;   The above can be relaxed to a convex program by minimizing ||y-x||^2 + \\lambda ||y||_{1}. Put a small weight on the sparsity constraint. The second term is a convex relaxation for sparsity or in bayesian terms its the laplace prior. It can be solved via coordinate gradient descent which has low memory requirements."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Find the 1000th largest element using quickselect, which is quick sort modified to only recurse on half of each partition containing the kth largest element.  Then, iterate once more to find all elements less then or equal to the 1000th largest element."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Python code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O (n).  Run through the list once replacing your saved 1000 largest numbers as you encounter them."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Define: n = 1000000, k = 1000  1. Create a max heap of size n. O(n). 2. For K times: 2.1.  Pop max, and max heapify the heap. O(logn).  Running time is: O(n) + O(Klogn), but it is really O(n) as it dominates. Space: O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"you can use the Heap to implement it, build a max root heap to get the greatest 1000 elements"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17727664","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"44","title":"Flatten a List> in Java and implement the hasNext() and next() methods. e.g. [[6,8],4] should return true when at 6, 8 and false at 4.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Hi guys,  why over complicating it so much. The op just asks for flattening a list of lists of integers and implementing next and hasNext. No need for implementing Iterator thus far. Just forward requests to a backing list that just encapsulates the list of lists."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"With additional assumptions"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"From my understanding, \"flattening\" in this case is just returning the first inner list and ignoring all other inner lists. Let me know if this is correct.  Also, provide a more detailed example. eg. what is the unflattened output for [[6,8,9],[4,5,3],[1,2,7]] ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I answered this incorrectly during the interview. But now when I did it, I managed to do it properly. Here's my code : (Please suggest if you think anything's wrong with it)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"your code does not handle, list within list within list , etc ie multiple levels of nesting in the lists.  like [[[[12,23,23,3],2,2],1],9]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"With additional assumptions"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"With assumptions"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"With assumptions. \n \nimport java.util.ArrayList; \nimport java.util.Collections; \nimport java.util.Iterator; \nimport java.util.LinkedList; \nimport java.util.List; \nimport java.util.NoSuchElementException; \n// Ignores ConcurrentModificationExceptions \npublic class Lists implements Iterable { \n    private List> lists; \n    public Lists(List> lists) { \n        this.lists = lists; \n    } \n    @Override \n    public Iterator iterator() { \n        return new ListsIterator(); \n    } \n    public class ListsIterator implements Iterator { \n        private Iterator> listsIter; \n        private Iterator listIter; \n        private void hop() { \n            listIter = null; \n            if (listsIter == null) { \n                return; \n            } \n            while (listsIter.hasNext()) { \n                List list = listsIter.next(); \n                // Here is the flattening \n                if (list == null || list.isEmpty()) { \n                    listsIter.remove(); \n                } else { \n                    listIter = list.iterator(); \n                    break; \n                } \n            } \n        } \n        public ListsIterator() { \n            if (lists != null) { \n                listsIter = lists.iterator(); \n            } \n            hop(); \n        } \n        @Override \n        public boolean hasNext() { \n            if (listIter == null) { \n                return false; \n            } \n            if (listIter.hasNext()) { \n                return true; \n            } \n            hop(); \n            if (listIter == null) { \n                return false; \n            } \n            return true; \n        } \n        @Override \n        public T next() { \n            if (listIter == null) { \n                throw new NoSuchElementException(); \n            } \n            if (listIter.hasNext()) { \n                return listIter.next(); \n            } \n            hop(); \n            if (listIter == null) { \n                throw new NoSuchElementException(); \n            } \n            return listIter.next(); \n        } \n        @Override \n        public void remove() { \n            if (listIter == null) { \n                throw new IllegalStateException(); \n            } \n            listIter.remove(); \n            if (!listIter.hasNext()) { \n                hop(); \n            } \n        } \n    } \n    public static void main(String[] args) { \n        // Test 0 \n        Lists lists = new Lists(null); \n        Iterator i = lists.iterator(); \n        System.out.println(i.hasNext()); \n        try { \n            i.next(); \n        } catch (NoSuchElementException e) { \n        } \n        try { \n            i.remove(); \n        } catch (IllegalStateException e) { \n        } \n        // Test 1 \n        List> test1 = new ArrayList>(); \n        test1.add(null); \n        List list = new LinkedList(); \n        list.add(1);list.add(2); \n        test1.add(list); \n        test1.add(Collections.emptyList()); \n        list = new LinkedList(); \n        list.add(3);list.add(4); \n        test1.add(list); \n        lists = new Lists(test1); \n        i = lists.iterator(); \n        while (i.hasNext()) { \n            System.out.print(i.next() + \" \"); \n            i.remove(); \n        } \n        System.out.println(); \n        i = lists.iterator(); \n        while (i.hasNext()) { \n            System.out.print(i.next() + \" \"); \n        } \n        System.out.println(); \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"With assumptions"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"test"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"see 2nd for loop, i think u have add 2nd array  to 2nd list"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"see 2nd for loop, i think u have add 2nd array  to 2nd list"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This program works perfectly."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This program works perfectly."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class FlatList implements Iterator, Iterable {  List> listOfList;  int elemIndex = 0;  int listIndex = 0;  List curList;  public FlatList(List> listOfList) {   this.listOfList = listOfList;   if (listOfList.size() > 0)    curList = listOfList.get(0);  }   @Override  public boolean hasNext() {   while (listIndex < listOfList.size()) {    if (elemIndex < curList.size())     return true;    if (++listIndex < listOfList.size()) {     curList = listOfList.get(listIndex);     elemIndex = 0;    }   }   return false;  }   @Override  public T next() {   if (elemIndex >= curList.size())    return null;   return curList.get(elemIndex++);  }   @Override  public void remove() {   // TODO Auto-generated method stub   }   @Override  public Iterator iterator() {   return this;  }    public static void main(String[] args) {   List> listoflist = new ArrayList>();   List intList;   for (int i = 0; i < 5; i++) {    intList = new ArrayList();    for (int j = 0; j < i; j++)     intList.add(j);    listoflist.add(intList);   }   FlatList flatlist = new FlatList<>(listoflist);   Iterator iter = flatlist.iterator();   while (iter.hasNext())    System.out.println(iter.next());  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class FlatList implements Iterator, Iterable { \n List> listOfList; \n int elemIndex = 0; \n int listIndex = 0; \n List curList; \n public FlatList(List> listOfList) { \n  this.listOfList = listOfList; \n  if (listOfList.size() > 0) \n   curList = listOfList.get(0); \n } \n \n @Override \n public boolean hasNext() { \n  while (listIndex < listOfList.size()) { \n   if (elemIndex < curList.size()) \n    return true; \n   if (++listIndex < listOfList.size()) { \n    curList = listOfList.get(listIndex); \n    elemIndex = 0; \n   } \n  } \n  return false; \n } \n \n @Override \n public T next() { \n  if (elemIndex >= curList.size()) \n   return null; \n  return curList.get(elemIndex++); \n } \n \n @Override \n public void remove() { \n  // TODO Auto-generated method stub \n \n } \n \n @Override \n public Iterator iterator() { \n  return this; \n } \n  \n public static void main(String[] args) { \n  List> listoflist = new ArrayList>(); \n  List intList; \n  for (int i = 0; i < 5; i++) { \n   intList = new ArrayList(); \n   for (int j = 0; j < i; j++) \n    intList.add(j); \n   listoflist.add(intList); \n  } \n  FlatList flatlist = new FlatList<>(listoflist); \n  Iterator iter = flatlist.iterator(); \n  while (iter.hasNext()) \n   System.out.println(iter.next()); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class FlatList implements Iterator, Iterable { \n List> listOfList; \n int elemIndex = 0; \n int listIndex = 0; \n List curList; \n public FlatList(List> listOfList) { \n  this.listOfList = listOfList; \n  if (listOfList.size() > 0) \n   curList = listOfList.get(0); \n } \n \n @Override \n public boolean hasNext() { \n  while (listIndex < listOfList.size()) { \n   if (elemIndex < curList.size()) \n    return true; \n   if (++listIndex < listOfList.size()) { \n    curList = listOfList.get(listIndex); \n    elemIndex = 0; \n   } \n  } \n  return false; \n } \n \n @Override \n public T next() { \n  if (elemIndex >= curList.size()) \n   return null; \n  return curList.get(elemIndex++); \n } \n \n @Override \n public void remove() { \n  // TODO Auto-generated method stub \n \n } \n \n @Override \n public Iterator iterator() { \n  return this; \n } \n  \n public static void main(String[] args) { \n  List> listoflist = new ArrayList>(); \n  List intList; \n  for (int i = 0; i < 5; i++) { \n   intList = new ArrayList(); \n   for (int j = 0; j < i; j++) \n    intList.add(j); \n   listoflist.add(intList); \n  } \n  FlatList flatlist = new FlatList<>(listoflist); \n  Iterator iter = flatlist.iterator(); \n  while (iter.hasNext()) \n   System.out.println(iter.next()); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class FlatList implements Iterator, Iterable { \n List> listOfList; \n int elemIndex = 0; \n int listIndex = 0; \n List curList; \n public FlatList(List> listOfList) { \n  this.listOfList = listOfList; \n  if (listOfList.size() > 0) \n   curList = listOfList.get(0); \n } \n \n @Override \n public boolean hasNext() { \n  while (listIndex < listOfList.size()) { \n   if (elemIndex < curList.size()) \n    return true; \n   if (++listIndex < listOfList.size()) { \n    curList = listOfList.get(listIndex); \n    elemIndex = 0; \n   } \n  } \n  return false; \n } \n \n @Override \n public T next() { \n  if (elemIndex >= curList.size()) \n   return null; \n  return curList.get(elemIndex++); \n } \n \n @Override \n public void remove() { \n  // TODO Auto-generated method stub \n \n } \n \n @Override \n public Iterator iterator() { \n  return this; \n } \n  \n public static void main(String[] args) { \n  List> listoflist = new ArrayList>(); \n  List intList; \n  for (int i = 0; i < 5; i++) { \n   intList = new ArrayList(); \n   for (int j = 0; j < i; j++) \n    intList.add(j); \n   listoflist.add(intList); \n  } \n  FlatList flatlist = new FlatList<>(listoflist); \n  Iterator iter = flatlist.iterator(); \n  while (iter.hasNext()) \n   System.out.println(iter.next()); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class FlatList implements Iterator, Iterable { \n List> listOfList; \n int elemIndex = 0; \n int listIndex = 0; \n List curList; \n public FlatList(List> listOfList) { \n  this.listOfList = listOfList; \n  if (listOfList.size() > 0) \n   curList = listOfList.get(0); \n } \n \n @Override \n public boolean hasNext() { \n  while (listIndex < listOfList.size()) { \n   if (elemIndex < curList.size()) \n    return true; \n   if (++listIndex < listOfList.size()) { \n    curList = listOfList.get(listIndex); \n    elemIndex = 0; \n   } \n  } \n  return false; \n } \n \n @Override \n public T next() { \n  if (elemIndex >= curList.size()) \n   return null; \n  return curList.get(elemIndex++); \n } \n \n @Override \n public void remove() { \n  // TODO Auto-generated method stub \n \n } \n \n @Override \n public Iterator iterator() { \n  return this; \n } \n  \n public static void main(String[] args) { \n  List> listoflist = new ArrayList>(); \n  List intList; \n  for (int i = 0; i < 5; i++) { \n   intList = new ArrayList(); \n   for (int j = 0; j < i; j++) \n    intList.add(j); \n   listoflist.add(intList); \n  } \n  FlatList flatlist = new FlatList<>(listoflist); \n  Iterator iter = flatlist.iterator(); \n  while (iter.hasNext()) \n   System.out.println(iter.next()); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class FlatList implements Iterator, Iterable { \n List> listOfList; \n int elemIndex = 0; \n int listIndex = 0; \n List curList; \n public FlatList(List> listOfList) { \n  this.listOfList = listOfList; \n  if (listOfList.size() > 0) \n   curList = listOfList.get(0); \n } \n \n @Override \n public boolean hasNext() { \n  while (listIndex < listOfList.size()) { \n   if (elemIndex < curList.size()) \n    return true; \n   if (++listIndex < listOfList.size()) { \n    curList = listOfList.get(listIndex); \n    elemIndex = 0; \n   } \n  } \n  return false; \n } \n \n @Override \n public T next() { \n  if (elemIndex >= curList.size()) \n   return null; \n  return curList.get(elemIndex++); \n } \n \n @Override \n public void remove() { \n  // TODO Auto-generated method stub \n \n } \n \n @Override \n public Iterator iterator() { \n  return this; \n } \n  \n public static void main(String[] args) { \n  List> listoflist = new ArrayList>(); \n  List intList; \n  for (int i = 0; i < 5; i++) { \n   intList = new ArrayList(); \n   for (int j = 0; j < i; j++) \n    intList.add(j); \n   listoflist.add(intList); \n  } \n  FlatList flatlist = new FlatList<>(listoflist); \n  Iterator iter = flatlist.iterator(); \n  while (iter.hasNext()) \n   System.out.println(iter.next()); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi. I want to clarify  what this question really wants us to answer.  So the input is a list of lists - List> Now we do: flatten(List> which returns the String such as [[2,4,6], [5], [1, 10, 9]].  So hasNext() must work with a String ?  The approach I came up with was: Have two pointers, one at the start of a list and one at the end of the list (by list, I mean one list inside the superlist) and work with these pointers to retrieve next.   Is this the right understanding of the problem ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.LinkedList; \nimport java.util.List; \n \npublic class FlatList { \n \n    LinkedList flatList = new LinkedList(); \n    int index = 0; \n \n    public FlatList(List> original){ \n \n        for (List sublist : original){ \n \n            for(Integer i : sublist){ \n                flatList.add(i); \n            } \n \n        } \n \n        // Clean up some space \n        original.clear(); \n \n    } \n \n \n    Integer getNext(){ \n        return flatList.get(index++); \n    } \n \n    boolean hasNext(){ \n        return index >= flatList.size(); \n    } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's my solution in Java: ========================"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a solution in C#. Simply convert it to Java.  It doesn't implement IEnumerable but this can be added very easily."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/** \n *  \n */ \n \nimport java.util.ArrayList; \nimport java.util.Iterator; \nimport java.util.List; \n \n \n/** \n * @author Bhumir Jhaveri \n * \n */ \npublic class ListInsideListIterator { \n  \n /** \n  * @param args \n  */  \n public static void main(String[] args) { \n   \n  List list1 = new ArrayList(); \n  List listInner1 = new ArrayList (); \n  listInner1.add(12); \n  listInner1.add(2); \n  listInner1.add(312); \n  List listInner2 = new ArrayList (); \n  listInner2.add(4412); \n  listInner2.add(44); \n  listInner2.add(42); \n  list1.add(listInner1); \n   \n    \n  list1.add(listInner2); \n  list1.add(3433); \n   \n  ListInsideListIterator listIterator = new ListInsideListIterator(list1); \n  while(listIterator.hasNext()) { \n   System.out.println(listIterator.next()); \n  } \n   \n } \n  \n List localList; \n int currentElement, currentListCounter; \n \n /** \n  * @param list1  \n  *  \n  */ \n public ListInsideListIterator(List list1) { \n  localList = list1;   \n   \n } \n \n  \n \n private Integer next() { \n  Integer output = new Integer(0); \n   \n   \n  int currentCounter =0; \n  Iterator listIterator = ((List)this.localList.get(currentListCounter)).iterator(); \n  while (listIterator.hasNext()) {    \n   if( currentCounter < currentElement) { \n     \n    currentCounter++; \n    listIterator.next(); \n    continue; \n   } else { \n    currentElement++; \n    output = Integer.parseInt(\"\"+listIterator.next()); \n    break; \n   } \n  } \n  \n   \n  return output; \n } \n \n private void decideCurrentListCounter() { \n   \n  for(; currentListCounter"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This question doesn't sound like the difficulty for phone interview. This is trickier/harder than most of my google onsite interviews."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Implementation same as everyone here: basically keep the List> as an instance variable, as well as an index pointing to current list (currentList) and another index pointing to current position of current list (currentIndex). Just hopefully more compact and correct :)  It would actually be much easier had I first convert the List> into just a List, but I actually want to do it the harder (and less efficient) way."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My C# implementation is here. Java should be almost same. Notice that HasNext() and Next() methods are very similar. They can be combined, too."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution holds an iterator to the outer list and a second iterator to the inner list. It seems to me simpler than what I see from others."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"your code does not handle, list within list within list , etc ie multiple levels of nesting in the lists.  like [[[[12,23,23,3],2,2],1],9]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"your code does not handle, list within list within list , etc ie multiple levels of nesting in the lists.  like [[[[12,23,23,3],2,2],1],9]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"From my understanding, \"flattening\" in this case is just returning the first inner list and ignoring all other inner lists. Let me know if this is correct.  Also, provide a more detailed example. eg. what is the unflattened output for [[6,8,9],[4,5,3],[1,2,7]] ?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17188673","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"18","title":"Implementation of Advanced set which have the functionality as \"Set\" in c++ along with extra functionality-Random number generator.Returns the random number from the set.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"To provide a random() function in addition to the regular \"set\" interface, we keep a dynamic array (e.g. vector) of the keys in addition to the hashtable which is usually used to store unsorted-set. The index of the item in the array will be stored in the hash-table as the value assoicated with the key. When a key is added to the set, we append it to the array, and stoe the key in its location in the array in the hash-table. When a key is deleted from the set, we delete it from the array and the hash-table, and then move the last item in the array to where the deleted item was in the array. To return a random key, we create a random number from 0 to the number of items minus 1, and lookup the corresponding position in the array.  All operations, inclusing the new random() method, will remain O(1)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Set can be implemented using RB-Tree or AVL Tree. For random number what if we just return the number from any random position from the set."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"could someone please post a more well defined version of this problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can store the number of node in each sub trees. It will be easy to find the kth element in tree like that. Each time we rand a number k between 1 and N, where N is the total number of the element."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"else if (lc == k -1) { \n       return node; \n   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(1) solution for every set operation and random element of the set.  - Maintain a hash-table for insertion and deletion.  - Along with the hash-table, maintain a vector of pointers to the elements in the hash-table. Lets call it vector(hashtable-element-pointers). - For insertion, add the element to hash-table, and add a pointer to the end of the vector(hashtable-element-pointers). - For deletion, get the index of the key of vector(hashtable-element-pointers), replace that pointer with the last element of vector(hashtable-element-pointer) and perform pop_back() on the vector.   Here is the code.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"'Set' could be implemented as a 'hashtable' with chaining as a conflict resolution."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17332676","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"10","title":"Given a directed acyclic graph.How to represent it in the relational database for efficient retrieval of all the children nodes and all the parents of any node.(ex a->b here b is child of a and a is parent of b)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"This is a pretty general solution:  Table Nodes  (Node_ID INT, Node_Value X) Table Adjacents (Node_ID INT, Adj_Node_ID INT, PathCost INT)  Then to retrieve all children of a node: Select Adj_Node_ID from Adjacents Where Node_ID=SomeNodeId  To retrieve the 'parents' of a node: Select Node_ID from Adjacents Where Adj_Node_ID=SomeNodeId"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Store the graph as edge list. Columns: src, dst, cost. Create an index on columns src and dst. Query: To get all parents and child nodes of node A.   Select src as parent from edgelist where dst='A' union select dst as child from edgelist where src='A'"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"single index on src& dst or one index for src and another for dst?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"traverse the graph (N1->N2), (N1->N3), (N1->N4), (N2->N3), and (N3->N4) and extract nodes and add them to node_master table:    node_id, node_value N1  1234 N2  34 N3  56  N4  90  Then for each node, extract the children, add them to node_family table:  node_parent, node_child N1    N2 N1    N3 N1    N4 N2    N3 N3    N4  Then to find the parent/child: SQL query may be:  SELECT node_master.node_id, node_family.node_child FROM node_master INNER JOIN node_family ON node_master.node_id = node_family.node_id WHERE ;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I'd keep the PATH infomation for each node.  Table Node - Id - Value (or Cost) - Path  Assume that the graph is like below. (i.e. a complete binary tree which is a special form of a graph)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A self referential table would work.                   1               /      \\            2         3          /     \\          \\        4       5        6  Example Node Table |  ItemId  | ParentId | |  1           | NULL     | |  2           | 1             | |  3           | 1             | |  4           | 2             | |  5           | 2             | |  6           | 3             |  To select parent of node 2:   SELECT ParentId FROM Node WHERE ItemId = 2; To select children of node 2:          SELECT ItemId FROM Node Where  ParentId = 2;"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17221689","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"46","title":"Given a string.Find the longest substring in it such that the substring contains only 2 unique characters.Ex- aabbcbbbadef Ans-bbcbbb","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"c1 = first unique character \nc2 = second unique character \n \nsp1 = first position of c1 \nep1 = last position of c1 \nsp2 = first position of c2 \nep2 = last position of c2 \n \nInitialize c1=s[0]; sp1=ep1=0 \nc2=-1 \n \nFor each s[i]: \n if s[i] != c1 AND c2 is not initialized i.e. c2 == -1 : \n   //initialize c2,sp2,ep2 \n else if s[i] == c2: \n  //update end position of c2 \n else if s[i] == c1: \n  //we define second unique character as the last character found  \n  //in the substring of 2 unique characters so far \n  //so we have to swap c1 and c2 and their start and end positions \n  //s[i] i.e. c1 becomes c2 and c2 becomes c1 \n  //Do required variable swappings \n else if s[i] != c1 and s[i] != c2 i.e. s[i] is a new character: \n  //c2 will become c1 while s[i] will become c2 \n  //Now here is the corner case due to which we need both start and \n  //end positions of c1 and c2 \n  //Our new substring containing 2 unique characters must start from  \n  //the point after which there is no occurence of c1 till i i.e  \n  //after the last position of c1 \n  //So make required updates in sp1, sp2, ep1, ep2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Solution with nice explanation of a similar problem coders-stop[.]blogspot[.]in/2012/09/directi-online-test-number-of[.]html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class LongestSubStringWith2Char { \n  \n public String findString(String str){ \n  int firstFreq, nextFreq, totalCount, end = 0; \n  Character firstChar, secondChar; \n   \n  //Initially make the characters and frequencies to numm \n  firstChar = secondChar = null; \n  firstFreq = nextFreq = totalCount=0; \n   \n  for(int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Maintain two chars, When a new char is encountered, move back the pointer as far as possible such that there are only two strings in the string. And then expand the string to the front as well."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def longest_substr_two_uniqe_char(onestr):     max_len=beg=end=0     first_pos=-1     second_pos=-1     index=0     while index        if first_pos==-1:             first_pos=index         elif second_pos==-1:             second_pos=index         elif onestr[index]!=onestr[first_pos] and onestr[index] !=onestr[second_pos]:             break         else:             index+=1    #    index-=1     while index        if index-first_pos+1>max_len:             max_len=index-first_pos+1             beg=first_pos             end=index                      first_pos=second_pos         second_pos=index         while index            index+=1        if index==len(onestr):         if index-first_pos>max_len:             beg=first_pos             end=index     print beg,end     return onestr[beg:end]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bug free is so difficult: def longest_substr_two_uniqe_char(onestr):     max_len=beg=end=0     first_pos=-1     second_pos=-1     index=0     while index        if first_pos==-1:             first_pos=index         elif second_pos==-1:             second_pos=index         elif onestr[index]!=onestr[first_pos] and onestr[index] !=onestr[second_pos]:             break         else:             index+=1    #    index-=1     while index        if index-first_pos+1>max_len:             max_len=index-first_pos+1             beg=first_pos             end=index                      first_pos=second_pos         index=first_pos         while index            index+=1         second_pos=index         while index            index+=1        if index==len(onestr):         if index-first_pos>max_len:             beg=first_pos             end=index     print beg,end     return onestr[beg:end]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void substring(const char* const input) \n{ \n    char letters[2] = {0,0}; \n    char currentLetter = 0; \n    int currentLength = 0; \n    int overallLength = 0; \n    int bestOverallLength = 0; \n    int bestStartIndex; \n     \n    const int inputLength = (int)strlen(input); \n    for(int i = 0; i < inputLength; ++i) \n    { \n        char thisLetter = input[i]; \n         \n        // update \"letters\" \n        if(letters[0] == 0) \n        { \n            letters[0] = thisLetter; \n            currentLetter = thisLetter; \n            currentLength = 1; \n            overallLength = 1; \n        } \n        else if(letters[1] == 0) \n        { \n            if(thisLetter == currentLetter) \n            { \n                ++currentLength; \n            } \n            else \n            { \n                letters[1] = thisLetter; \n                currentLetter = thisLetter; \n                currentLength = 1; \n            } \n            ++overallLength; \n        } \n        else if((thisLetter == letters[0]) || (thisLetter == letters[1])) \n        { \n            if(thisLetter == currentLetter) \n            { \n                ++currentLength; \n            } \n            else \n            { \n                currentLetter = thisLetter; \n                currentLength = 1; \n            } \n            ++overallLength; \n        } \n        else \n        { \n            letters[0] = currentLetter; \n            letters[1] = thisLetter; \n            currentLetter = thisLetter; \n            overallLength = currentLength + 1; \n            currentLength = 1; \n        } \n         \n         \n        if(overallLength > bestOverallLength) \n        { \n            bestOverallLength = overallLength; \n            bestStartIndex = (i - bestOverallLength) + 1; \n        } \n    } \n     \n    printf(\"%d at %d\\n\",bestOverallLength,bestStartIndex); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Questions { \n \n    public static void main(String[] args) { \n         \n        //String input = \"aabbcbbbadef\"; \n        String input = \"aabcbcbcbcbcbcbcbcbcbbccbaa\"; \n        String result = longestSubstringContaining2Characters(input); \n        System.out.println(\"Longest subString for '\" + input + \"' is '\" + result + \"'\"); \n    } \n     \n    /* \n     * Given a string, find the longest substring in it such that the substring contains only 2 unique characters. \n     * Ex. aabbcbbbadef ---->>>>  bbcbbb \n     */ \n    public static String longestSubstringContaining2Characters(String input) { \n        String longestSubstring = \"\"; \n         \n        Character firstCharacter, secondCharacter; \n        firstCharacter = secondCharacter = null; \n        int firstCharacterIndex, secondCharacterIndex; \n        firstCharacterIndex = secondCharacterIndex = -1; \n         \n        for (int i = 0; i < input.length(); i++) { \n            char currentCharacter = input.charAt(i); \n             \n            if (secondCharacter == null && firstCharacter != null) { \n                secondCharacter = currentCharacter; \n                secondCharacterIndex = i; \n            } else if (firstCharacter == null) { \n                firstCharacter = currentCharacter; \n                firstCharacterIndex = i; \n            } \n             \n            if (firstCharacter == secondCharacter) { \n                secondCharacter = currentCharacter; \n                secondCharacterIndex = i; \n            } \n             \n            if ((secondCharacter != null) && (currentCharacter != firstCharacter && currentCharacter != secondCharacter)) { \n                String currentSubString = input.substring(firstCharacterIndex, i); \n                if (currentSubString.length() > longestSubstring.length()) { \n                    longestSubstring = currentSubString; \n                } \n                firstCharacter = secondCharacter; \n                firstCharacterIndex = secondCharacterIndex; \n                 \n                secondCharacter = currentCharacter; \n                secondCharacterIndex = i; \n            } \n             \n        } \n         \n        return longestSubstring; \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My attempt:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.*; import java.io.*;  public class findSubstring {    public String findString(String str){   int firstFreq, nextFreq, totalCount, firstPlace, nextPlace, start;   String result= new String();   Character firstChar, secondChar;      //Initially make the characters and frequencies to numm   firstChar = secondChar = null;   firstFreq = nextFreq = totalCount=firstPlace=nextPlace=start=0;      for (int i=0;i   char ch=str.charAt(i);        if (firstChar==null && secondChar==null){     firstFreq ++;     firstChar = ch;     firstPlace=i;     start=i;    }    else if (secondChar==null && firstChar == ch){     firstFreq ++;    }    else if (secondChar==null){     nextFreq ++;     secondChar = ch;     nextPlace = i;    }    else if (firstChar == ch && firstPlace < nextPlace){     firstFreq ++;     firstPlace=i;    }    else if (firstChar == ch && firstPlace > nextPlace){     firstFreq ++;    }    else if (secondChar == ch && firstPlace < nextPlace){     nextFreq ++;    }    else if (secondChar == ch && firstPlace > nextPlace){     nextFreq ++;     nextPlace = i;    }    else{     if (totalCount     totalCount=firstFreq+nextFreq;      result = str.substring(start, i);     }        if (firstPlace     firstChar=secondChar;      secondChar=ch;      firstPlace=nextPlace;      start=nextPlace;     }     else {      secondChar=ch;      start=firstPlace;     }     nextPlace=i;     firstFreq=i-firstPlace;     nextFreq=1;     continue;    }    if (totalCount    totalCount=firstFreq+nextFreq;     result = str.substring(start, i+1);    }   }         return result;  }    public static void main(String[] args) {   findSubstring demo = new findSubstring();   System.out.println(demo.findString(\"aabbcbbbadef\"));   System.out.println(demo.findString(\"aabbaacdef\"));   System.out.println(demo.findString(\"abbbbbbaddeeffff\"));   System.out.println(demo.findString(\"ffeeeeeeeeeeedddddddddddbbbbbbbbbaaaaaa\"));   System.out.println(demo.findString(\"aabaadddddaa\"));  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.*; \nimport java.io.*; \n \npublic class findSubstring { \n  \n public String findString(String str){ \n  int firstFreq, nextFreq, totalCount, firstPlace, nextPlace, start; \n  String result= new String(); \n  Character firstChar, secondChar; \n   \n  //Initially make the characters and frequencies to numm \n  firstChar = secondChar = null; \n  firstFreq = nextFreq = totalCount=firstPlace=nextPlace=start=0; \n   \n  for (int i=0;i nextPlace){ \n    firstFreq ++; \n   } \n   else if (secondChar == ch && firstPlace < nextPlace){ \n    nextFreq ++; \n   } \n   else if (secondChar == ch && firstPlace > nextPlace){ \n    nextFreq ++; \n    nextPlace = i; \n   } \n   else{ \n    if (totalCount"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In this algo, keep track of the start and end positions of current substring of 2 unique characters + keep track of max-length-substring found so far.  ALGORITHM {     c1 = first unique character (leftMost)     c2 = second unique character (rightMost)      sp1 = first position of c1     ep1 = last position of c1     sp2 = first position of c2     ep2 = last position of c2      global_sp = 0;     global_ep = 0;      Initialize c1=s[0]; sp1=ep1=0; c2=-1; sp2=ep2=-1;      For each s[i], from i = 0 to s.lastIndex(), do {         if ((s[i] != c1) && (c2 is not initialized i.e. c2 == -1)) {             // initialize (c2, sp2, ep2);             // c2 = s[i]; sp2=i; ep2=i;          } else if (s[i] == c2) {             // update end position of c2;          } else if (s[i] == c1) {             // update end position of c1;          } else if ((s[i] != c1) && (s[i] != c2), i.e., s[i] is a new character) {             // (1) Shift c1 to c2 by coping smartly.             if (s[i-1] == c1) {                 // COPY: c1 into c1                 c1 = c1;                 sp1 = MAX(ep2+1, sp1);                 ep1 = i-1;              } else { // (s[i-1] == c2)                 // COPY: c2 into c1                 c1 = c2;                 sp1 = MAX(ep1+1, sp2);                 ep1 = i-1;             }              // (2) UPDATE: (c2, sp2, ep2) values from (s[i], i, i)         }           // compare lengths of local and global max-subString found so far.         if(c2 == -1) {             local_max_length = (ep1 - sp1 + 1);         } else {             local_max_length = (MAX(ep1, ep2) - MIN(sp1, sp2) + 1);         }         if( local_max_length > (global_ep - global_sp + 1) ) {             global_sp = sp1;             global_ep = ep2;         }     }      return ( substring(s, global_sp, global_ep) ); }  Complexity : O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//file name maxsubstr_uniq.cpp \n// \n \n#include  \n#include  \n \nnamespace { \n    using std::string; \n    using std::cout; \n    using std::cin; \n    typedef string::const_iterator c_str_iterator; \n}; \n \nstring maxsubstr(const string& s) { \n    c_str_iterator max_l, max_r, curr_l, curr_r, next_l, last; \n \n    max_l = max_r = curr_l = next_l = s.begin();  \n    curr_r  = curr_l + 1 ; \n    for(last = s.end() ; curr_r < last; ) { \n        if( *curr_r != *(curr_r - 1) ) { //transition \n            if(*curr_l != *curr_r && *curr_l != *(curr_r -1)) //2 transitions? \n                curr_l = next_l; //update new sequence start \n            next_l = curr_r; //update where next new sequence starts \n        } \n        ++curr_r;  \n        if( max_r - max_l < curr_r - curr_l) { //update max \n            max_r = curr_r; \n            max_l = curr_l; \n        } \n    } \n    return string(max_l,max_r); \n} \n \nint main() { \n    string s; \n    cout << \"input string,output string\\n\"; \n    while ( cin >> s ) { \n        cout << s << \",\" << maxsubstr(s) << \"\\n\"; \n    } \n    cout << \"\" << \",\" << maxsubstr(\"\") << \"\\n\"; \n} \n \n//cat teststrings.txt \n//a \n//ab \n//abc \n//abb \n//abbc \n//abbcc \n//ababc \n//abcabbbbcdddddd \n//aabbaacdef \n//abbbbbbaddeeffff \n//ffeeeeeeeeeeedddddddddddbbbbbbbbbaaaaaa \n//aabaadddddaa \n \n//g++ maxsubstr_uniq.cpp -o maxsubstr \n//./maxsubstr < teststrings.txt \n//input string,output string \n//a, \n//ab,ab \n//abc,ab \n//abb,abb \n//abbc,abb \n//abbcc,bbcc \n//ababc,abab \n//abcabbbbcdddddd,cdddddd \n//aabbaacdef,aabbaac \n//abbbbbbaddeeffff,abbbbbbadd \n//ffeeeeeeeeeeedddddddddddbbbbbbbbbaaaaaa,eeeeeeeeeeeddddddddddd \n//aabaadddddaa,aabaadddddaa \n//,"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Working C Code with edge cases considered Time Complexity : O(n) Each time I start with the intention of writing some clean and elegant code but inevitably end with a not so pleasing piece"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is simple solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution in python"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//filename maxsubstr_uniq.cpp \n \n#include  \n#include  \n \nusing std::string; \nusing std::cout; \nusing std::cin; \ntypedef string::const_iterator c_str_iterator; \n \nvoid update_max(c_str_iterator& max_l,c_str_iterator& max_r, \n  c_str_iterator curr_l,c_str_iterator curr_r) { \n    if( max_r - max_l >= curr_r - curr_l) return; \n    max_l = curr_l; \n    max_r = curr_r; \n} \n \nstring maxsubstr(const string& s) { \n    if(!s.size()) return s; \n    c_str_iterator max_l, max_r, curr_l,  \n            curr_r, sec, next_l,last; \n    max_l = max_r = curr_l = sec = next_l = s.begin();  \n    curr_r  = curr_l + 1; \n    for(last = s.end() ; curr_r < last; ) { \n for( ; sec < last && *sec == *curr_l; ++sec); \n for( ; curr_r < last && *curr_r == *sec || *curr_r == *curr_l; ++curr_r) { \n     if(*next_l != *curr_r) \n  next_l = curr_r; \n } \n update_max(max_l,max_r,curr_l,curr_r); \n curr_l = next_l; \n sec = curr_r; \n    } \n    update_max(max_l,max_r,curr_l,last); \n    return string(max_l,max_r); \n} \n \nint main() { \n    string s; \n    cout << \"input string,output string\\n\"; \n    while ( cin >> s ) { \n        cout << s << \",\" << maxsubstr(s) << \"\\n\"; \n    } \n    cout << \"\" << \",\" << maxsubstr(\"\") << \"\\n\"; \n} \n \n// g++ maxsubstr_uniq.cpp -o maxsubstr \n//./maxsubstr < teststrings.txt \n//input string,output string \n//a,a \n//ab,ab \n//abc,ab \n//abb,abb \n//abbc,abb \n//abbcc,bbcc \n//ababc,abab \n//abcabbbbcdddddd,cdddddd \n//aabbaacdef,aabbaa \n//abbbbbbaddeeffff,abbbbbba \n//ffeeeeeeeeeeedddddddddddbbbbbbbbbaaaaaa,eeeeeeeeeeeddddddddddd \n//aabaadddddaa,aadddddaa \n//,"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static String bigSeqs(String str) { \n  char c[] = str.toCharArray(); \n  char c1, c2 = 0, lc; \n  int s1, s2 = 0, start = 0, bigstart = 0, bigend = 0; \n  if (c.length > 0) { \n   s1 = 0; \n   c1 = c[0]; \n   lc = c1; \n  } else \n   return null; \n  for (int i = 1; i < c.length; i++) { \n   if (c2 == 0 && c[i] != c1) { \n    c2 = c[i]; \n    s2 = i; \n   } else if (c[i] != c1 && c[i] != c2) { \n    if (i - start > bigend - bigstart) { \n     bigstart = start; \n     bigend = i; \n    } \n \n    if (lc == c2) { \n     c1 = c2; \n     s1 = s2; \n    } \n    start = s1; \n    c2 = c[i]; \n    s2 = i; \n   } else if (lc == c1 && c[i] == c2) { \n    s2 = i; \n   } else if (lc == c2 && c[i] == c1) { \n    s1 = i; \n   } else if (i == c.length - 1) { \n    if (i + 1 - start > bigend - bigstart) { \n     bigstart = start; \n     bigend = i + 1; \n    } \n   } \n   lc = c[i]; \n  } \n  if (bigend == 0) \n   bigend = c.length; \n  return str.substring(bigstart, bigend); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This version builds longest substrings adding one char at the time in front of the current one and examines each char (at most) only twice: once when t is put on the current longest substring, and once if a third char is found in front of it; when the latter happens, the pointer to the beginning of the substring is advanced to the earliest point where either of the two characters it actually contains no longer appears in it"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This version builds longest substrings adding one char at the time in front of the current one and examines each char (at most) only once, when it is added in front of the current longest substring; when a third char is found, the pointer to the beginning of the substring is advanced to the earliest point where either of the two characters it actually contains no longer appears in it"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Seems like it can be done simpler than most of the solutions above:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void findLongestSubstring(String target) \n { \n  if(target==null || target.length()==0) return ; \n  char first=target.charAt(0); \n  char second='\\0'; \n  int maxLength=0;  \n  String maxString=\"\";  \n  int start1=0; \n  int start2=0;  \n  for(int i=0; imaxLength) \n     { \n      maxLength= i-minValue; \n      maxString=target.substring(minValue, i); \n     }     \n     if(start1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def longest_2char_seq(str): \n    start_pos = end_pos = 0 \n    charmap = {} \n    maxstr = '' \n    strlen = len(str) \n    while end_pos < strlen - 1: \n        while len(charmap) < 3 and end_pos < strlen: \n            if not charmap.get(str[end_pos]): \n                charmap[str[end_pos]] = 0 \n            end_pos += 1 \n        end_pos -= 1 \n        if len(maxstr) < len(str[start_pos:end_pos ]): \n            maxstr = str[start_pos:end_pos] \n        charmap = {} \n        start_pos = end_pos - 1 \n        while start_pos > 0 and str[start_pos] != str[end_pos - 1]: \n            start_pos -= 1 \n    return maxstr"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class SubSequence { \n \n   public static void main(String[] args) { \n      findLongestSubsequence(\"aabbaabbaabbaabababa\"); \n      findLongestSubsequence(\"aabbcbbbadef\"); \n      findLongestSubsequence(\"aabaadddddaa\"); \n      findLongestSubsequence(\"aabaacdddddaa\"); \n      findLongestSubsequence(\"bbbcccbbbbcccca\"); \n   } \n \n \n   static void findLongestSubsequence(String input) { \n      // make validations for null and length 1 strings here \n      int initial = 0, changed = 0; \n      char firstChar = input.charAt(0), secondChar = input.charAt(1); \n       \n      firstChar = input.charAt(0); \n      String subSequence = \"\"; \n      for (int i = 0; i < input.length() - 1; i++) { \n         char current = input.charAt(i); \n         char next = input.charAt(i + 1); \n         // It may be xyx or xyz \n         if (current != next) {         \n            //End of current sequence \n            if(next != firstChar && next != secondChar){ \n               String currentSequence = input.substring(initial,i+1); \n               if(currentSequence.length() > subSequence.length()){ \n                  subSequence = currentSequence; \n               } \n               //Re initialize the sequence                \n               initial = changed; \n               firstChar = current; \n               secondChar = next; \n            } \n            //From next character we can restart \n            changed = i+1; \n         } \n      } \n      //If subsequence ends at last \n      if(changed <= input.length()-1){ \n         String currentSequence = input.substring(initial,input.length()); \n         if(currentSequence.length() > subSequence.length()){ \n            subSequence = currentSequence; \n         }    \n      } \n       \n      System.out.println(subSequence); \n \n   } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"# Logic  : track two characters upto that position  dynamic programming   O(N)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Substring { \n  public static void main(String[] args) \n   { \n    Substring sub= new Substring(); \n   String s=\"bbbbbbbbbbcccccccccddddeeeeee\"; \n    String c = sub.substring(s); \n \n     System.out.println(\"New String is \"+c); \n} \n \npublic String substring(String s) \n{String g = null; \n char c = 0;int r=0; \n for(int i=0;i1&&c!=s.charAt(i)) \n  {  \n  g=s.substring(0, i+1); \n   break; \n  } \n } \n  \n } \n return g; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I use a HashMap instead to keep track of the 2 characters (and their frequencies) so far. Basically iterate through the string and either increment the count for an existing character, or determine that we now have more than 2 unique characters. In the latter case, keep advancing the \"start\" pointer until we have only 2 unique characters in the HashMap again."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It can be easily done by automata and set theory."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can someone tell me whether this code misses any corner cases....??...Thanks in advance"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"just use two index, complexty O(2n)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17539664","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"32","title":"In a party there are n different-flavored cakes of volume V1, V2, V3 ... Vn each. Need to divide them into K people present in the party such that  - Each member of party gets equal volume of cake (say V, which is the solution we are looking for)  - A given member should get a cake of single flavour only i.e. You cannot distribute parts of different flavored cakes to same member.  - Minimum volume of cake gets wasted after distribution so that means a maximum distribution policy","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Hint: Binary Search on the Answer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"1) ELP's algorithm is correct but not efficient enough, it is an O(n*n*k) algorithm.  2) ChaoSXDemon's algorithm is not enough to solve this problem, but with some modification, it did help to figure out how many pieces of cakes the largest cake will have in the optimal solution, so that it is possible to speed up ELP's algorithm to be O(n*k).  In ELP's algorithm, there is an assumption that in the optimal solution, there must be at least one cake Vx which gets no wasted at all and it can be divided into V without any volumes remained (namely, Vx % V == 0). We can prove this by assuming the opposite case in the optimal solution. If in the optimal solution, every cake has certain volumes wasted, the V we find in that case can be increased obviously, which means it is not the optimal solution. So there must be at least one cake Vx which gets no wasted at all.  ChaoSXDemon's algorithm can be used to figure out how many pieces of cakes the largest cake will have in the optimal solution. For the largest cake, it may be divided into [1...k] parts.  Here are the steps I copied from ChaoSXDemon's algorithm (assume cake0 is divided into k0 parts, and with step 5 modified): 1. Sort the input cake from largest to smallest.  2. Starting at the number of input people, guess that each person gets cake[0] / k0 units  3. Check and verify given cake[0]/k0 units can be assigned to k people  4. If step 3 worked, decrease k0 by one and assign this bigger unit and repeat step 3  5. If during step 4 any check failed, revert to previous value 5.1 if previous value can result k pieces in total (the number of guests given) for all cakes, return it as the best result  5.2 if previous value can result (k + 1) or more pieces in total for all cakes, this means even the largest cake can have some volumes remained (we can at least discard the extra one piece from the largest cake), which violates the assumption we conclude. So previous value is not the optimal solution, and we can figure out cake[0] will be divided into current value k0 parts. Since the largest cake has some volumes remained, we cannot compute the V directly by dividing V0/k0.  I will use an example to illustrate this, consider input:  vols={6, 5, 12}, k = 4  1. sort vols, vols = {12, 6, 5} 2. k0=4, V=12/4=3, total = 12/3 + 6/3 + 5/3 = 4 + 2 + 1 = 7 > 4, k0-- 3. k0=3, V=12/3=4, total = 12/4 + 6/4 + 5/4 = 3 + 1 + 1 = 5 > 4, k0-- 4. k0=2, V=12/2=6, total = 12/6 + 6/6 + 5/6 = 2 + 1 + 0 = 3 < 4 5. when k0=3, total = 5 = 4 + 1, so k0=3 is not in the optimal solution, k0 should be 2 So we already know in the optimal solution, the largest cake cake[0] (with volume 12) should be divided into 2 pieces. So cake[0] will be divided into 2 parts, and each part should be larger than 4 and less than 6, but we don't know the exact size of it yet since cake[0] has some volumes remained.  Since there will be at least one cake that can be divided without any waste, we need to find out that cake. Intuitively, you can use the V for k0=3 (V=4) to compute the remained volumes for each cake to find out which cake is the cake with smallest volume remained for each piece it has. When V=4,  1. for cake[1]=6, it has 2 units (6-4=2) remained, and each piece can be increased by 2. 2. for cake[2]=5, it has 1 unite remained, and each piece can be increased by 1.  3. We will pick the cake with smallest increment, and it will be the cake that gets no waste at all, and we can get V by computing V = 5 / 1 = 5 in this case.  The entire process will be O(n*k) + O(n).   Additionally, if you examine closely, you will find that to find the k0 for cake[0] from 1...k, you can use binary search to speed it up, which means this algorithm can be an O(nlgk) algorithm.   Any comment is appreciated. Thanks."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Pseudocode: Go through each cake, dividing it up into between 1 and numCustomers slices.  Then carry that slice size through the other cakes to see how much was wasted.  If the wasted amount is less than the max then set it as the new max.  Ruby Code: {{ def wasted_cake(cakes, ci, slices, numCustomers)  # if we can cut everything out of cake CI using slices, then return the waste  if slices > numCustomers then return nil end   sliceSize = cakes[ci].to_f / slices.to_f  numSlices = slices   cakes.length.times do |i|   if i == ci then next end    cake = cakes[i]   while numSlices < numCustomers && cake >= sliceSize    cake -= sliceSize    numSlices += 1   end  end   if numSlices == numCustomers then    return ($sum - sliceSize * numCustomers) else   return nil end end  def cut_cakes(cakes, numCustomers)  $sum = 0  cakes.each do |cake|   $sum += cake  end   minWasted = Float::MAX  maxSlice = nil   cakes.sort!  cakes.length.times do |i|   (1..numCustomers).each do |slices|    wasted = wasted_cake(cakes,i,slices,numCustomers)    if nil == wasted then next end     if wasted < minWasted then     minWasted = wasted     maxSlice = cakes[i]/slices.to_f    else      break    end   end  end   return maxSlice end  puts cut_cakes([1,2,300],5) puts cut_cakes([1,2,3],1) puts cut_cakes([1,2,3],2) puts cut_cakes([1,2,3],3) puts cut_cakes([1,2,3],4) puts cut_cakes([1,2,3],5) puts cut_cakes([1,2,3],6) }}  60.0 3.0 2.0 1.5 1.0 1.0 1.0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Sort the input cake from largest to smallest. 2. Starting at the number of input people, guess that each person gets cake[0] / k units 3. Check and verify given cake[0]/k units can be assigned to k people 4. If step 3 worked, decrease k by one and assign this bigger unit and repeat step 3 5. If during step 4 any check failed, revert to previous value and return the best result  The time complexity if O(kN) where k is number of people and N is the number of cakes. So if k = N or larger then it's basically O(N^2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Objective: 1. Minimize the total waste by volume (not by flavor) 2. Maximize distribution (so maximum number of people must be served)  Constraints: 1. A person cannot have more than one flavor 2. More than one flavor cannot be distributed to a person 3. One flavor can be distributed to more than one person 4. Per person cake share V lies between Vmin and Vmax  Logic: To minimize the waste by volume, the per person share must be adjusted to achieve the minimal waste."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Given N cakes and K people with N >= K Find the (N - K + 1)th volume cake in asc order. This can be done in O(N) given that input is not sorted, or O(logN) if it is sorted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Take the volume of the smallest cake Vsmallest 2) Divide all the cakes into slices of of size Vslice = Vsmallest  4) Obtain the number of slices Nslices you would get if you divided all the cakes into slices of size Vslice 3) If Nslice is less than the number of people, then dived the smallest cake into to slices and set Vslice into Vsmallest/2 4) Repeat until the number of slices is greater than or equal to the number of people 5) If Nslice was to large (to many slices per person to start) then elliminate the smallest cake and start with the second largest cake"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I assume V1,V2, .... Vn are sorted. \n \nslicesPerCustomer= f(N) \n \nint f(i){ \n   if i=1 then return V1/K else \n   if Vi / K > f(i-1) then return Vi / K else return f(i-1) \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"asume the v1, v2.....vn are all integers   bindary search v,      vmax = max (v1,v2,...vn); vmin =  min (v1, v2....vn);  while (vmin{ v = (vmin+vmax)/2; if  (  [v1 v2.....vn]  has k times v )   then  vmin = v; else  vmax = v; }  return vmin;    time complexity:   O (n  log|vmax-vmin| ) example:    10000, 1, 1, ....3, 1...           k=2,     v=5000 8,7,6,3,1           k=3,   v = 4 ......"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Convert it to a mathematical equation and use Newton iteration method to get the root. The function is:  f(v)=sum{lowerBound(vi/v)}-k. Here is the code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Model it as a mathematical function and use Newton iteration to find the root. f(v)=sum (lowerBound(vi/v))  Here is the code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Binary search over V."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Assume the cakes are already sorted by volume, so V1 is smallest and Vn is largest 2. First try setting V=V1 and see if that works (usually doesn't) 3. Now, check the wastage from each cake, call them W1...Wn 4. Imagine we want to reduce V by as little as possible to produce 1 additional piece 5. We can do so by picking the cake with the most wastage, and setting V such that we can produce that 1 additional piece from this cake. If there's a tie for most wastage, use the cake with largest volume. 6. Repeat this process until we have enough pieces  For example, assume the volumes are {10, 14, 16, 22, 30} and K=10 people. First set V=10. That would produce {1, 1, 1, 2, 3} pieces, or 8 total. Calculate wastage as {0, 4, 6, 2, 0}. We realize that the 3rd cake has the most wastage (6), so we should try to produce the additional piece from this cake. To produce 2 pieces from cake 3, V should be 8.  Now we can produce {1, 1, 2, 2, 3} pieces, or 9 total. Calculate wastage as {2, 6, 0, 6, 6}. So we should use last cake to produce the additional piece, and set V=30/4 or 7.5 Now we can produce {1, 1, 2, 2, 4}, or 10 pieces.  Sorry I don't have proof that this greedy algorithm works, nor even 100% sure it works."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Let k be the total number of people, going to have the cake. -> First take each cake say v1, divide it with k, and store it into float, if the value is not a perfect integer.      Ex: float f = v1/k; -> now take that float value and assign it to integer using math.floor. which will round to the perfect integer. -> Now subtract this integer from float, which will give minimum wastage in cake. -> So total number of cakes x float values gives minimum wastage. Ex: Let volume of cake = 15 kg.                        People = 4.                  float f  = 15/4; f = 3.75                          int perHead = Math.floor(3.75); perHead = 3;                          float wastage = f - perHead; wastage = 0.75;                          So, total wastage = wastage * total number of cakes."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Imagine there are 2 cakes and you are the second person to choose a piece. Since person 1 is sure to claim the biggest cake, you have the choice to either pick the smaller cake or half of the bigger cake. Behind you is your friend who also wants some cake, assuming you chose to split the larger cake, then your friend can either claim the smaller cake or split the bigger cake with the 3 of you  So this seems like a greedy algorithm,"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Does this not solve this problem:  1. Obtain the GCD of the volumes of the cake. 2. Divide all the cakes with this volume. 3. Distribute those pieces equally among the K people.  we will waste (K-1)GCD_Vol in this way."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Does this not solve this problem:  1. Obtain the GCD of the volumes of the cake. 2. Divide all the cakes with this volume. 3. Distribute those pieces equally among the K people.  we will waste (K-1)GCD_Vol in this way."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17300668","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"Write a C program to search for a given pattern from various files in a directory without using grep or any other inbuilt command","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Knuth-Morris-Pratt (KMP) string matching Algorithm"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"using System; \nusing System.Collections.Generic; \nusing System.Linq; \nusing System.Text; \nusing System.Threading.Tasks; \n \nnamespace KMP \n{ \n    class Program \n    { \n        static void Main(string[] args) \n        { \n            String s = \"abccabccabccabcbaaaaabccabccabcaaaaaaaaa\"; \n            String Pattern = \"abccabccabca\"; \n            FindString(s, Pattern); \n            Console.Read(); \n        } \n \n        static int[] BuildPrefixArray(String pattern) \n        { \n            int[] result = new int[pattern.Length + 1]; \n            result[0] = -1; \n            result[1] = 0; \n            int k = 0; \n            for (int i = 2; i < result.Length; i++) \n            { \n                while (k > 0 && pattern[k] != pattern[i - 1]) \n                { \n                    k = result[k]; \n                } \n                if (pattern[k] == pattern[i - 1]) \n                { \n                    k++; \n                } \n                result[i] = k; \n            } \n            return result; \n        } \n \n        static void FindString(String s, String pattern) \n        { \n            int[] prefix = BuildPrefixArray(pattern); \n            int match = 0; \n            for (int i = 0; i < s.Length; i++) \n            { \n                while (match > 0 && s[i] != pattern[match]) \n                { \n                    match = prefix[match]; \n                } \n                if (s[i] == pattern[match]) \n                { \n                    match++; \n                } \n                if (match == pattern.Length) \n                { \n                    Console.WriteLine(\"We found the pair start on the index:\" + (i - pattern.Length + 1)); \n                    return; \n                } \n            } \n            Console.WriteLine(\"We did not find the string.\"); \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"By pattern do you mean regular expression or just a string,if its a string just scan the file line by line using KMP"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17433662","download_status":"DOWNLOAD_DONE","votes":"3","answersCount":"42","title":"I Got this Crazy Question on PHONE INTERVIEW AT GOOGLE:  Design and implement a class to generate random numbers in an arbitrary probability distribution given by an array of integer weights, i.e. for int[] w return a number, n, from 0 to w.length - 1 with probability w[n] / sum(w). Using an existing random number generator with a uniform distribution is permitted.  Example distribution: w = 1, 2, 3, 2, 1  Example probabilities: w / sum = 1/9, 2/9, 1/3, 2/9, 1/9  Example results: n = 0, 1, 2, 3, 4  Documentation:  Class java.util.Random  public int nextInt(int n)  Returns a pseudorandom, uniformly distributed int value between 0 (inclusive) and the specified value (exclusive), drawn from this random number generator's sequence. The general contract of nextInt is that one int value in the specified range is pseudorandomly generated and returned. All n possible int values are produced with (approximately) equal probability.  Parameters: n - the bound on the random number to be returned. Must be positive. Returns: the next pseudorandom, uniformly distributed int value between 0 (inclusive) and n (exclusive) from this random number generator's sequence Throws: IllegalArgumentException - if n is not positive","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"The idea is to create a prob. distribution out of the given prob. density and then choose the random numbers out of it. Here is the example. For a given Prod. density, say Den = [1,2,4,5,1,3], the distribution is cumulative sum of the array. So, Dist = [1,3,7,12,13,16].  Now, generate a uniform random number between 0 and Dist[n] = 16. The number to be returned is the index of whichever interval the generate random number fell into. Lets say, we generated 10. 10 lies in [7,12], so the return value is index(12) = 3. Here is a sample code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"def add(a,b): return a+b \n \nclass weightedRandom: \n    aliases = {} \n    sum = 0 \n     \n    def __init__(self, weights): \n        self.aliases = {} \n        self.sum = reduce(add, weights) \n        slot = 0 \n        dsum = weights[slot] \n        for i in range(sum): \n            if i >= dsum: \n                slot+=1 \n                dsum+=weights[slot] \n            self.aliases = slot \n         \n     \n    def next(self): \n        return aliases[random.randint(0,self.sum-1)] \n \n \nwr = weightedRandom([1, 2, 3, 2, 1]) \nwr.next()"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Here's a solution using floating-point numbers. The generation is not as efficient as it could be since it's going through the array every time, but given the array is small it's negligible anyways. You could make it faster by binary-searching where you're at in the range."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Given: w={w1, w2, .... wN} output: n with probability of (wn/sum(w))  Create a non zero weight array, W, with another array containing their corresponding index+1, K.  for example: w={11,22,13,0,2} create 2 arrays W={11,22,13,2} and K={1,2,3,5} --- O(N)  Generate a cumulative array of weights, Wc = {Wc1, Wc2, ... WcN} where Wci=Wc(i-1)+Wi  for i=2...N and WC1= W1 --- O(N)  For every input call generate a random number, r. let R=floor(r*WcN), so that R will be distributed randomly between 0 and WcN-1, remember WcN = sum(w)  I can think of two ways to solve this, one in O(log N) time and another in O(1) time but needs O(sum of w, i.e.WcN) memory.  O(log N) solution: Do a binary search on Wc to find i such that  Wc(i-1)<=RThen output K[i]  O(1) solution: Precompute output for full range of R (0 ... WcN-1) and store in an array of length WcN. You can look up an array after computing R for each input in O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Here is my C/C++ based solution. Idea here is that calculate the cumulative frequency array. Now suppose a number 10 appears at index 3 so cumu[3] will contain number 10 + cumu[3-1].  Therefore a index will have numbers, out of total sum in its bucket, equal to the weight assigned to it.  Now take a random function which returns a number \"output\" uniformly between 0 and (sum-1) that is rand()%sum. check this output falls in which bucket and return the index of that bucket.  Hence this function will give you the index with probability equal to the weight of the number it holds in the original array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Hi Guys,  I thought of two approaches : Approach 1 : 1. input = {1,2,3,2,1}; modify it so that each index = current value + sum of previous values     modified input = {1,3,6,8,9}  2. choose random value between 1 & 9 (9 is the total sum of weights) using existing random function  3. Output is the correct index for the value . eg. if the value is 5, the index is 3 (this can be found using binary search).    This approach takes O(log k) time (where k is the length of input array) and no additional memory.   Approach 2: 1. Make a copy of the array. eg. array a = {1,2,3,2,1};  array b = copy of a.      Note the total sum s (in this case, 9), and tempSum = s 2. If tempSum > 0         Randomly select a number x between (1, b.length)     else         return to step 1  3. If b[x] > 0          3.1 b[x]--         3.2 select x     else          return to step 2  This approach takes constant time and O(k) extra memory (where k is the length of the array).   Please correct me if I am wrong."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can you please explain, what is it your trying to do with  distribution? And this part?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution: Easily use an exisiting Random function, and set its low bound to 0 while high bound to n. N equals -> sum(int[] w), so it is nature to do as following: If w[1] = 2, than if the random number equals 0 or 1, it will falls into n = 0; If w[2] = 3, than if the random number equals 2 or 3 or 4, it will falls into n = 1... If w[n-1] = x, than if the random number equals n-1-x,n-x .... or n-1, it will falls into n = count(w)-1; This will provide a way to generate a random number with the expected possibility."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"So you have a space of n possible outputs and you have their weights in w[0 .. n - 1].  You can use rand() assuming it returns random numbers based on an uniform distribution.   One thing you could do is create an array of size sum(w) and fill it with numbers i: from 0 .. n -  1. Each i will have w[i] copies in this new array (regardless of where). Then just call rand() % sum(w) and return the number stored at this array's index."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In my above solutions, I assumed random numbers between (1, array.length) instead of (0, array.length-1)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \nusing namespace std; \n \nint getNext(int p[], int N)  \n{ \n    int c[N]; \n    c[0] = p[0]; \n    for (int i = 1; i < N; i++) { \n        c[i] = p[i] + c[i-1]; \n    } \n     \n    int next = rand() % c[N-1]; \n \n    for (int i = 0; i < N; i++) { \n        if (next < c[i]) { \n            return i; \n        } \n    } \n    return (N-1); \n} \n#define N 5 \n#define LOOP 100000000 \nint main()  \n{ \n    int p[N] = {1, 2, 3, 2, 2}; \n    int c[N] = {0, 0, 0, 0, 0}; \n     \n    for (int i = 0; i < LOOP ; i++) { \n        c[getNext(p, N)]++; \n    } \n \n    for (int i = 0; i < N; i++) { \n        cout << c[i] << \" \"; \n    } \n    cout << \"Loop : \" << LOOP << endl;  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This paper has an extremely elegant linear time init, constant time sampling algorithm to do just this:  (I cannot post a link, so just search for it) A Linear Algorithm For Generating Random Numbers With a Given Distribution Michael D. Vose  at web.eecs.utk.edu in the directory /~vose/Publications/random.pdf"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's a simple solution. Please note that the numbers to be selected is assumed from 0 - w.length-1. This can be replaced with an array oflength w.length and corresponding element can be selected"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@hrishi can you please explain ur comment in detail. I have used the function nextInt with the correct signature.correct?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@hrishi can you please explain ur comment in detail. I have used the function nextInt with the correct signature.correct?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A simple solution in python, which iteratively maps the weights to a 0 - 1.0 space, which random.random() is applied to"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"from random import random,choice \n \ndef myrand(den): \n  m = float(max(den)) \n  im = filter(lambda x: x[1]>=random(), enumerate(map(lambda x: x/m, den))) \n  return choice(im)[0]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"actually"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class MyRandom { \n \n private List values; \n private Random random; \n \n public MyRandom(int[] w) { \n \n  values = new ArrayList(); \n  for (int i = 0; i < w.length; i++) { \n   int amount = w[i]; \n   for (int j = 0; j < amount; j++) { \n    values.add(i); \n   } \n  } \n  random = new Random(); \n } \n \n public int nextInt() { \n  return values.get(random.nextInt(values.size())); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"For me the question itself isnt clear.As per my understanding. The random number generated as to be as close to the number as per its probability."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17192662","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"27","title":"Find the most frequently occurring element in a BST. In this BST we can have leftnode<=rootnode<=rightnode.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"9","title":"I agree with  brighama's saying. If we traverse this BST with Inorder, we can consider this is sorted array. Then we can get the most frequent node in [ Time : O(n), Space : O(1) ]. This is the code using C++."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"You could pass in a hashmap which counts up the occurrences of each element, and then select the element with the largest count, or you could just get the in-order traversal and then count the longest run."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"If this is one time process then the any of above solution would suffice , but if its recurring thing then we can augment the BST with node storing the frequency count for that node element , the frequency count would be incremented the decremented during the insertion and deletion in the BST. To get frequency count just do the BST traversal , find the element and output the frequency count from the node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Finding the most frequent item in a sorted list is O(n) in time and O(1) in space.  (We just iterate through the list and keep track of the current most-frequent number & its frequency.)  An in-order traversal of a BST will give a sorted list.   So, at worst we should have O(n) time and O(1) space..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void list::Count_Occuerence_BST(node *temp) \n \n{ \n \n \n \n if(temp==NULL) \n \n  return; \n \n  if(temp->lchild ==NULL && temp->rchild ==NULL) \n  { \n   return; \n  } \n  if(temp->rchild ==NULL && temp->lchild!=NULL) \n  { \n   if(temp->lchild->data ==temp->data) \n   { \n   Increment(temp->data); \n   Count_Occuerence_BST(temp->lchild); \n \n   } \n  } \n  if(temp->lchild==NULL && temp->rchild !=NULL) \n  { \n    \n    if(temp->rchild ->data==temp->data) \n    { \n    Increment(temp->data); \n    Count_Occuerence_BST(temp->rchild); \n \n    } \n    \n \n  } \n   \n     \n  if(temp->lchild && temp->rchild) \n  { \n \n \n if((temp->lchild->data< temp->data) && ( temp->rchild ->data > temp->data)) \n   { \n     \n \n   }  \n if(temp->lchild->data ==temp->data && temp->rchild->data >temp->data) \n  { \n   Increment(temp->data); \n  } \n   \n if(temp->lchild->data < temp->data && temp->rchild->data ==temp->data) \n  { \n   Increment(temp->data); \n    \n  }  \n   \n if(temp->lchild->data ==temp->data && temp->rchild->data ==temp->data) \n  { \n   Increment(temp->data); \n   Increment(temp->data); \n    \n  } \n \n     Count_Occuerence_BST(temp->lchild); \n   Count_Occuerence_BST(temp->rchild); \n  } \n  \n} \n \n \nvoid list::Increment(int val) \n{ \n  \n int arr[20][2]; \n  \n if(len==0) \n { \n  arr[0][0]=val; \n  arr[0][1]=2; \n  return; \n } \n for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"do a in-order traversal of the given tree, each node in the BST will also contain the frequency of occurence. We can create a max heap heap out of BST elements and give the required k most frequently elements of BST tree.  Time complexity (nlogn) Space complexity O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"As the question said, \"in this BST we can have leftnode<=rootnode<=rightnode.\". It implies that one node in this BST may have nodes of same value in its right child node or left child node or both.  So, I use post-order traversal for this BST. In each steps in recursion, we first count the most frequently value of nodes in left child nodes and right child nodes of current node. Also, count the node which has the same value of current node. After that, comparing the counts of most frequently values in both left and right child nodes with the counts of current node value. After comparison, this node return an array to his parent node which contains three elements: result=[counts of value in parent node, count of most frequently value in this sub BST,  count of most frequently value in this sub BST]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can use inorder traverse first and store all of the nodes in an array, and then traverse the array again from left to right. Since we have a BST, I think when we use the inorder traverse we can create an sorted array. Then we just need to count the elements and find out the most frequently occurring one. I think time complexity is O(n) since we need to traverse twice. Space is O(n) since we need to use an array to store all elements. For the better algorthim we can use probably O(1) space, which means we can check and count the element while we traversing the tree. Code in C#:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A simpler and more efficient recursive solution, written in Python (but any OO language would do, with a few tricks to wrap multiple return values). This solution is O(n) for time and O(1) for space [O(h), where h is max the height of the tree, if we consider the space required by the stack].  Even if both left and right subtrees might contain the same value as their parent, for a given node either its left [right] child holds the same value, or that value won't be found in its left subtree. So for each node the number of occurrencies of its value in the subtree rooted in that node is equal to 1 plus the sum of the occurrencies of that value in the left subtree (either 0 if node->left->value != node->value or the number of occurrencies for left subtree otherwise) plus the occurrencies of the same value in the right subtree:  freq(node) = 1 + (node->left->value == node->value ? freq(node->left) : 0) + (node->right->value == node->value ? freq(node->right) : 0)  Using recursion when we compute freq(node) we take advantage of the values of freq() already computed for left and right subtrees."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Choices - O(1) space + O(n**2) time OR O(n) in both"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int maxfreq,maxcount=0,count=0,freq; \nvoid freqNode(node *root){ \n     if(!root) \n              return; \n     static node *inpred=NULL; \n     freqNode(root->left); \n     if(!inpred){ \n                freq=root->data; \n                count=1; \n     } \n     else{ \n          if(inpred->data==root->data) \n                                      count++; \n          else{ \n               if(maxcountdata; \n               count=1; \n          } \n     } \n     inpred=root; \n     freqNode(root->right); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Minor Doubt:  most frequently occurring number means same number is repeating in Binary Search Tree. Here my doubt is if we have 10,10,10 to insert in BST  we will insert first 10 as a root then will process second 10 and will match with first 10  10 not< 10   10 not>10 so we can not insert second 10 in left or right as per these 2 above rule Is there any rule for 10==10 to insert in BST  ???"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16917698","download_status":"DOWNLOAD_DONE","votes":"3","answersCount":"25","title":"Write a function which returns kth element from the tail in a linked list.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"15","title":"Use two pointers both pointing to the head of the linked list. Move one  of the pointers k ahead. Now move both of the pointers one node ahead at a time. When the first one reaches the end the second one would be k nodes behind it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Just have two references/pointers. Ref1 and Ref2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nint findkthreverseelement(const std::list& elements, int k) { \n        std::list::const_iterator front = elements.begin(); \n        std::list::const_iterator back = front; \n \n        for (int i = 1; i <= k; i++) ++front; \n \n        while (front != elements.end()) { \n                ++front; \n                ++back; \n        } \n        return *back; \n} \n \nint main() { \n \n        std::list elements; \n        int input=0; \n        int k; \n        std::cout << \"Enter k\\n\"; \n        std::cin >> k; \n        std::cout << \"Enter elements\\n\"; \n        while (std::cin >> input) { \n                elements.push_back(input); \n        } \n \n        for(std::list::iterator it = elements.begin(); it != elements.end(); ++it) { \n                std::cout << *it << \" \"; \n        } \n \n \n        int result = findkthreverseelement(elements, k); \n        std::cout << \"answer is \" << result << \"\\n\"; \n \n        return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can be done in O(n) time. Travel the list in O(n) time. This will give you the length of the list - lets say 'n'.  SUbtract k from the length and 1 in it.  (n-k)+1 Once again travel from beginning and n-k+1 is the kth element from the tail."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think your missing an important fact that could partition to n/2, just by adding a counter to the list you will know where to start if from head or tail..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"With Size given problem will be too simple to solve so i will try solving without the Size 1.Have two pointers both of them pointing to head at first assume P1 and P2  2.move p2 to k times in the list(assuming the question is kth to last )"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If size is not a constraint, then for finding length traverse through the list  and at the same time copy the data into a array. Now you can directly get the kth data in single shot. total time complexity is O(N) for getting length, and O(1) for getting kth element."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node find() { \n  Node next = this.head(); \n  Node prev =this.head(); \n  for (int i = 0 ; i < k ; i++) { \n   next = next.nextNode(); \n   if (next == null) \n    return null; \n  } \n  while( next!= null) { \n   next = next.nextNode(); \n   prev = prev.nextNoce(); \n  } \n  return prev; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"take a pointer say k = head 1. increment it k times,  2. now increment both head and k till k reaches last,      the element head points to is the kth from last :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"An answer below this question uses two pointers which has the distance k. Move them simultaneously. When the first pointer catch the last one, the second pointer reach to kth element from the tail.  There is a trick, this method have to move 2 * length in the whole. So there is an more efficient method.  Just as the answer mentioned above, we have: first pointer second pointer  second pointer points to the head, while first pointer points to kth element in the linked list  You can simply move first pointer k(sometimes less than k times, because maybe list has not enough elements to traverse) times every single loop, remember the times to T, after every k times movement, check whether first pointer reach the end. If not, let second pointer point to the position which first pointer points when this loop begins, and go on. If so, move second pointer T times and this is the kth element from the tail in the linked list.    Now i just use k to be the number of moves for first pointer every single loop. When k is much smaller than the linked list length, this method seems not more efficient than traditional one. So how to makes this method most efficient? With my glance, I think we could choose the number of moves every single loop dynamically. The best number is related to k and length of linked list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static Node GetTheKthFromTailNode(Node head, int k) \n  { \n   Node runner = head; \n   while (--k != 0 && runner != null) \n   { \n    runner = runner.Next; \n   } \n \n   if (runner == null) return null; \n \n   Node result = head; \n   while (runner.Next != null) \n   { \n    runner = runner.Next; \n    result = result.Next; \n   } \n \n   return result; \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"function item findElemFromTail(LinkedList list, int k) { \n   item* p = list->head;    \n   item* elem = NULL; \n   int k = ; \n   int i = 0; \n   while(p!=null) { \n        if(i == k) { \n           elem = p; \n        }       \n        if (item!=null) item = item->next; \n        p = p->next; \n        i++; \n   } \n \n   return elem; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"xx: temp=head; for(i=0;i{  temp->temp->next; } if(temp->next==NULL) {  return(head->no); } else {  head=head->next;  goto xx; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Either hold last k seen nodes (time compexity O(n), space O(k)), or traverse the list twice (O(n) / O(1))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"If you know the length of the given linked list, just subtract from the length and do one traversal to get it from the \"front\" of the list:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"In Java"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"import java.util.Scanner; \n \npublic class LinkedInsert { \n static Node[] newNode; \n static int numberOfNode; \n \n public static void main(String args[]) { \n  Node head = null; \n  System.out.print(\"Enter Number of Node:\"); \n  numberOfNode = new Scanner(System.in).nextInt(); \n  newNode = new Node[numberOfNode]; \n  for (int i = 0; i < numberOfNode; i++) { \n   int d = new Scanner(System.in).nextInt(); \n   newNode[i] = new Node(d); \n   if (i == 0) { \n    head = newNode[i]; \n   } \n \n   else { \n    head.nextNode = newNode[i]; \n    head = newNode[i]; \n   } \n \n  } \n \n \n  System.out.print(\"Enter Find Data:\"); \n  int find = new Scanner(System.in).nextInt(); \n  getSpecificElementFromTailOfStack(find); \n } \n \n private static void getSpecificElementFromTailOfStack(int find) { \n  // TODO Auto-generated method stub \n  int f = numberOfNode - find; \n  System.out.print(\"Data:\" + newNode[f].data); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"convert the linked list into a min-heap and return the kth element"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#include using namespace std; struct node{  int data;  node *next; };  int my_func(node *new_list,int m) {  node *bptr;int count=0,count1=0,count2=0;     bptr=new_list;     while((bptr->next)!=NULL)  {   bptr=bptr->next;   count1++;     }  count2=count1-m+1;  bptr=new_list;  while((count2>0))  {   bptr=bptr->next;   count2--;  }    int h=bptr->data;  return h;     } int main() {     node *list,*nptr,*tptr;  int item,n,i;  list=NULL;    cout<<\"PLEASE.......Type how many nodes that you want    \";  cin>>n;  for(i=1;i<=n;i++)  {   cout<<\"Type your \"<<<\" node item  \";   cin>>item;   nptr=new(node);   nptr->data=item;   nptr->next=NULL;   if(list==NULL)   {    list=nptr;    tptr=nptr;   }   else   {    tptr->next=nptr;    tptr=nptr;   }  }  tptr=list;  for(i=1;i<=n;i++)  {   cout<  cout<data<<\"    \";   tptr=tptr->next;     }  cout< cout<<\"Enter your node number from the tail in a linked list  \";     cin>>item;    int data_new=my_func(list,item);    cout<<\" \\n\\n\"<<<\" element from the tail in a linked list= \"<<< return 0;       }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"void printKthElementReverse(int nPos) {  if(pHead == NULL)  {   std::cout<<\"No Element Found  at \"<<<\" position\";   return;  }  int count = 0;  stList* pCurr = pHead;  stList* pKthElem = pHead;  stList* pPrev = NULL;  while(count < nPos)  {   pPrev = pKthElem;   if(NULL == pKthElem)    break;   pKthElem = pKthElem->pNList;   count++;  }   if(pPrev == NULL || count < nPos)  {   std::cout<<\"No Element Found  at \"<<<\" position\";   return;  }   stList* pCurPrev = NULL;  while(pPrev != NULL)  {   pCurPrev = pCurr;   pPrev = pPrev->pNList;   pCurr = pCurr->pNList;  }   std::cout<<<\" Element from Reverse is \"<data; }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16910673","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"9","title":"Implement Iterator class with peek() functionality in Java.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Good coding question for an interview."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Iterator is an interface which each of the collection classes implement in their own way which includes the implementation of the 3 methods mentioned. It appears like you are being asked to create your own collection type because unless you know what your collection looks like, it doesnt make sense to implement these methods. Please correct me if I'm wrong."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Same as the previous() method in the Java list iterators."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"could you please explain the significance of"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"and"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16759664","download_status":"DOWNLOAD_DONE","votes":"19","answersCount":"65","title":"You have k lists of sorted integers. Find the smallest range that includes at least one number from each of the k lists.  For example,  List 1: [4, 10, 15, 24, 26] List 2: [0, 9, 12, 20] List 3: [5, 18, 22, 30]  The smallest range here would be [20, 24] as it contains 24 from list 1, 20 from list 2, and 22 from list 3.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"26","title":"There are k lists of sorted integers. Make a min heap of size k containing 1 element from each list. Keep track of min and max element and calculate the range.  In min heap, minimum element is at top. Delete the minimum element and another element instead of that from the same list to which minimum element belong. Repeat the process till any one of the k list gets empty.  Keep track of minimum range.  For eg.  List 1: [4, 10, 15, 24, 26]  List 2: [0, 9, 12, 20]  List 3: [5, 18, 22, 30]   Min heap of size 3. containing 1 element of each list Heap [0, 4, 5] Range - 6  Remove 0 and add 9 Heap [4, 9, 5] Range - 6  Remove 4 and add 10 Heap [5, 9, 10] Range - 6  and so on....  Finally you will yield the result."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"This can be solved easily as below. 1. initialize smallest_range as MAX_INT 2. keep 3 pointers/index p1, p2 and p3 which points to the first elements of lists L1, L2 and L3 respectively. 3. find the max value and min value pointed/indexed by p1, p2 and p3 4. difference of max value and min value discovered in step 3 is the current range. compare it with smallest_range and update it, if found smaller. 5. increment the pointer/index of min value found in step 3. 6. repeat step 3 to 5 until the pointer/index of min value is in range.  constant space and O(n) time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"First, combine all lists into one big list, for each item keeping track of the list it's from and the value of the item. You get a data structure that (conceptually) looks like this:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"since list are already ordered, you can in generate the sorted list of all of them fast, and keep an additional array with the original list they belonged to:  In the example"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Keep three pointers to the beginning of each of the lists and advance the pointer on the list that has the next smallest value until you reach the end of one of the lists that has the lowest number out of the three. Store the smallest range along the way. So the iterations become (the current index of the pointer is shown in parentheses)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"1 4 7 100 200 300 500 2 5 8 125 225 325 525 3 6 9 150 250 350 550  All of u guys, both who r starting from the begining of the list and those who r starting frm the end of the list jst check ur algo. for the above example and comment the correctness of ur algo...!!!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.Do a k-way merge. Use k pointers to point to the start of each list. 2.Find the min and max elements among these k elements and find the difference as range (min and max are elements of range). If range is less than previous range, update it 3.Move to the next index in the list having the minimum value. Go to step 2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#!/usr/bin/env python \n# lrange.py - Find the smallest range of numbers that would include at \n#             least one item from each input list Ki. All lists are \n#             sorted. \n#             Program reads one list per line with items separated by \n#             space. \n \nimport sys \n \n# K[i][j] is the jth item of the ith list \nK = [[int(x) for x in l.strip().split()] for l in sys.stdin] \n \n# M[i] is an index to K[i] \nM = [0] * len(K) \n \n# minI is an index to M for the smallest K[i][M[i]] for all i \nminI = min(((i, K[i][M[i]]) for i in xrange(len(K))), key=lambda x: x[1])[0] \n \n# maxI is an index to M for the largest K[i][M[i]] for all i \nmaxI = max(((i, K[i][M[i]]) for i in xrange(len(K))), key=lambda x: x[1])[0] \n \nRl = K[minI][M[minI]] \nRh = K[maxI][M[maxI]] \n \nwhile M[minI] < len(K[minI]) - 1: \n \n  # Try to reduce the range by proceeding to next element in the K list \n  # with lowest value M[i] is pointing at. \n \n  M[minI] += 1 \n  oldMinI = minI \n \n  # To get 'n log k' performance, maintain a heap for minI \n \n  minI = min(((i, K[i][M[i]]) for i in xrange(len(K))), key=lambda x: x[1])[0] \n \n  if K[oldMinI][M[oldMinI]] > K[maxI][M[maxI]]: \n    maxI = oldMinI \n \n  # If the new range is smaller than the current one, replace \n \n  if K[maxI][M[maxI]] - K[minI][M[minI]] < Rh - Rl: \n    Rl = K[minI][M[minI]] \n    Rh = K[maxI][M[maxI]] \n \nprint 'Range: %d - %d incl.' % (Rl, Rh)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct ArrayElementIndirectCompare  \n{ \npublic: \n    ArrayElementIndirectCompare(const vector > &v) : v_(v) {} \n \n    bool operator()(pair one, pair two) \n    { \n        return v_[one.first][one.second] > v_[two.first][two.second]; \n    } \n \nprivate: \n    const vector > &v_; \n}; \n \nvoid \nSmallestMutualRange(const vector > &v, int &lo, int &hi) \n{ \n    lo = numeric_limits::max(); \n    hi = numeric_limits::min(); \n \n    int K = v.size(); \n \n    ArrayElementIndirectCompare comp(v);  \n    vector > heap; // heap of pairs  \n    for (int i = 0; i < K; i++) { \n        heap.push_back(pair(i, 0)); \n        if (v[i][0] < lo) { \n            lo = v[i][0]; \n        } \n        if (v[i][0] > hi) { \n            hi = v[i][0]; \n        } \n    } \n    make_heap(heap.begin(), heap.end(), comp); \n \n    int curr_lo = lo; \n    int curr_hi = hi; \n \n    while (true) { \n        pop_heap(heap.begin(), heap.end(), comp); \n        pair p = heap.back(); \n        if ((p.second + 1) >= v[p.first].size()) { \n            break; \n        } \n        int added = v[p.first][p.second + 1]; \n        if (added > curr_hi) { \n            curr_hi = added; \n        } \n        heap.back() = pair(p.first, p.second + 1); \n        push_heap(heap.begin(), heap.end(), comp); \n        p = heap.front(); \n        curr_lo = v[p.first][p.second]; \n \n        if ((curr_hi - curr_lo) < (hi - lo)) { \n            lo = curr_lo; \n            hi = curr_hi; \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The merging and coloring solution is the general correct approach. Here's my implementation in Java, it takes O(n*log(k)) i believe, where n is the total number of elements in all k lists."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This problem can be solved in O(nlogk)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Working solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"size_t findHighBorder( const size_t value, size_t* arr, const size_t length ) \n    { \n        for( size_t i = 0; i < length; i++ ) \n        { \n            if( value < arr[i] ) \n            { \n                return arr[i]; \n            } \n        } \n        return value; \n    } \n \nvoid Test16759664() \n    { \n        size_t L1[] = {4, 10, 15, 24, 26}; \n        size_t L2[] = {0, 9, 12, 20}; \n        size_t L3[] = {5, 18, 22, 30}; \n \n        map  keyer; \n \n        keyer[ L1[0] ] = L1[ _countof(L1)-1  ]; \n        keyer[ L2[0] ] = L2[ _countof(L2)-1  ]; \n        keyer[ L3[0] ] = L3[ _countof(L3)-1  ]; \n \n        const size_t lowerBorder = (*keyer.begin()).second; \n \n        std::set higher; \n \n        higher.insert( findHighBorder( lowerBorder, L1, _countof(L1) ) ); \n        higher.insert( findHighBorder( lowerBorder, L2, _countof(L2) ) ); \n        higher.insert( findHighBorder( lowerBorder, L3, _countof(L3) ) ); \n \n        size_t higherBorder = (*higher.rbegin()); \n \n        for( std::set::iterator iter = higher.begin(); iter != higher.end(); ++iter ) \n        { \n            if( *iter != lowerBorder ) \n            { \n                higherBorder = *iter; \n                break; \n            } \n        } \n        std::cout << \"range is (\" << lowerBorder << \" - \" << higherBorder << \")\\n\"; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def minRange(a, b, c): \n    mr = sys.maxint \n    i = j = k = 0 \n    while i < len(a) and j < len(b) and k < len(c): \n        cMax, cMin = max(a[i], b[j], c[k]), min(a[i], b[j], c[k]) \n        range = cMax - cMin \n        if range < mr: \n            mr = range \n        i, j, k = i + (cMin in a), j + (cMin in b), k + (cMin in c) \n    return mr"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package ArrayImpl; \n \nimport java.util.Arrays; \n \npublic class FindRangeAcrossArrays { \n \n /** \n  * You have k lists of sorted integers. Find the smallest range that includes at least one number from each of the k lists. \n \n  For example, \n  List 1: [4, 10, 15, 24, 26] \n  List 2: [0, 9, 12, 20] \n  List 3: [5, 18, 22, 30]   \n  The smallest range here would be [20, 24] as it contains 24 from list 1,  \n  20 from list 2, and 22 from list 3. \n  * @param args \n  * Look at the ranges like this \n  *(4,0,5),(4,9,5),(10,9,5),(10,9,18),(10,12,18),(15,12,18),(15,20,18),(15,20,22),(24,20,22); \n  */ \n public static void main(String[] args) { \n  // TODO Auto-generated method stub \n   \n  int lst1[] = { 4, 10, 15, 24, 26}; \n  int lst2[] = { 0, 9, 12, 20}; \n  int lst3[] = { 5, 18, 22, 30}; \n   \n  int result[] = {lst1[0], lst2[0], lst3[0]}; \n  int positionResult[] = {0,0,0}; \n  int whichlist = 0; \n  int minRangeFound = Integer.MAX_VALUE, rangeValue = 0; \n  for (int i = 0, j = 0, k = 0; i < lst1.length  && j < lst2.length  && k <= lst3.length;) \n  {  \n   rangeValue = findMaximumNumber(result) - findMinimumNumber(result); \n   if(rangeValue < minRangeFound) \n   { \n    positionResult[0] = i; \n    positionResult[1] = j; \n    positionResult[2] = k; \n    minRangeFound = rangeValue; \n   } \n   whichlist = findMinimumNumberIndex(result); \n   //System.out.println(whichlist + \" i = \" + i + \", j = \" + j + \", k = \" + k); \n   if(whichlist == 0) \n    result[0] = ++i < lst1.length? lst1[i]: result[0]; \n   else if (whichlist == 1) \n    result[1] = ++j < lst2.length? lst2[j]: result[1]; \n   else \n    result[2] = ++k < lst3.length? lst3[k]: result[2]; \n    \n   //System.out.println(Arrays.toString(result)); \n   //System.out.println(Arrays.toString(positionResult)); \n  } \n  result[0] = lst1[positionResult[0]]; \n  result[1] = lst2[positionResult[1]]; \n  result[2] = lst3[positionResult[2]]; \n  System.out.println(\"Minimum Range Found is [\" + findMinimumNumber(result)  \n                     + \" , \" + findMaximumNumber(result) + \"]\"); \n } \n  \n public static int findMinimumNumberIndex(int x[]) \n { \n  if(x[0] < x[1] && x[0] < x[2]) \n   return 0; \n  else if (x[1] < x[0] && x[1] < x[2]) \n   return 1; \n  else \n   return 2;   \n } \n  \n public static int findMinimumNumber(int x[]) \n { \n  if(x[0] < x[1] && x[0] < x[2]) \n   return x[0]; \n  else if (x[1] < x[0] && x[1] < x[2]) \n   return x[1]; \n  else \n   return x[2];   \n } \n   \n public static int findMaximumNumber(int x[]) \n { \n  if(x[0] > x[1] && x[0] > x[2]) \n   return x[0]; \n  else if (x[1] > x[0] && x[1] > x[2]) \n   return x[1]; \n  else \n   return x[2];   \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I've not gone through all the solutions here but, but the ones I have gone through seem to be doing unnecessary things. Here's my solution, feel free to point out the error:  Find the minimum element from the list of last elements in each list. [20,26,30] minimum is 20. You can bet that 20 is the start of that smallest range (Range that we seek).  Now just find out the next element in the all other lists that are bigger than 20. Candidates are [22, 24] Maximum of this [22, 24] is the end of the smallest range.  so answer becomes [22, 24].  This is how you make use of the fact that lists are sorted already"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We do not need to start from the beginning, as suggested here. Instead, start at tails. The smallest of the tails is the lower bound of the range guaranteed. The issue is to find the upper bound. Of course the upper bound cannot be more than the max of all tails.   So start with the max of tails as upper bound. To best this estimation, compare the next smaller number than this tail (in the same list as the max of tails, of course). If this number is greater than lower bound (which is fixed), then continue looking. Stop when your number is smaller than lower bound.   This way, you don't need search all the K lists. Here is the pseudo code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Python code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my solution written in C#"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class MinRangeFinder \n    { \n        /* \n         * {1,4,7,9,10,34,48} \n         * {23,24,25,26,27,28,29,33,111,222} \n         * {7,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33} \n         * solution: {34,33,33} \n        */ \n        public static int[] FindMinRange(int[] a, int[] b, int[] c) \n        { \n            // keep track of the min range \n            int[] minRange = new int[3] { a[0], b[0], c[0] }; \n            int minRangeValue = GetRange(a[0], b[0], c[0]); \n \n            // arrays \n            int[][] arrays = new int[][] { a, b, c }; \n            int[] indices = new int[] { 0, 0, 0 }; \n \n            while (TryAdvanceToNextMin(arrays, indices)) \n            { \n                int rangeValue = GetRange(a[indices[0]], b[indices[1]], c[indices[2]]); \n                if (rangeValue < minRangeValue) \n                { \n                    minRange = new int[] { a[indices[0]], b[indices[1]], c[indices[2]] }; \n                    minRangeValue = rangeValue; \n                } \n            } \n \n            return minRange; \n        } \n \n        private static int GetRange(int x, int y, int z) \n        { \n            return Math.Max(Math.Max(x, y), z) - Math.Min(Math.Min(x, y), z); \n        } \n \n        private static bool TryAdvanceToNextMin(int[][] arrays, int[] indices) \n        { \n            int arrayIndexToAdvance = -1; \n            int minVal = int.MaxValue; \n            for (int i = 0; i < arrays.Length; i++) \n            { \n                if (arrays[i].Length > indices[i] + 1) \n                { \n                    if (arrays[i][indices[i] + 1] < minVal) \n                    { \n                        arrayIndexToAdvance = i; \n                        minVal = arrays[i][indices[i] + 1]; \n                    } \n                } \n            } \n \n            if (arrayIndexToAdvance > -1) \n            { \n                indices[arrayIndexToAdvance]++; \n                return true; \n            } \n \n            return false; \n        } \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My idea is that the range's lower bound is the minimum of the largest element in the k lists, so it is range_lower_bound = min( 26, 20, 30 ) in the example. Then we try to find a set(call it smallest_larger_than_lower_bound_set, ={ 24, 22 } in the example ) of elements, who is the smallest element that is larger than the range_lower_bound in every array, if we find that the array contains range_lower_bound, we emit the array because it means the range will contain at least one element of the array(the range_lower_bound, actually), then range_upper_bound = max( smallest_larger_than_lower_bound_set ). The proof is simple, if lower bound v > range_lower_bound, then array that contains the range_lower_bound as largest element will not have a element in the range, so range_lower_bound is the optimal lower bound; if the upper bound v < range_upper_bound, and obviously v >= range_lower_bound, and the array contains the range_upper_bound will not have a element in the range, because the there're only two kinds of element in the array: elements < range_lower_bound and elements >= range_upper_bound > v, so no elements in the array will occurs in the range.  And here is my code in C++, the time complexity is O(kn), where k is the number of lists, and n is the number of elements in the list:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just simple O(N) space and O(N) time can work. 1. Merge these array into one in O(N) time, 2. Initial two pointer L,R to cover first K minimum numbers. 4. Calculate the \"Range\". 3. Delete pointer L's number which belong to X array(we suppose), move R to right until meet a number also belong to X array. 5. repeat 3-4 until R beyond range  It's the idea of \"window move\". And it's O(N) time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def smallest(lists): \n    minRange=float(\"inf\") \n    minListIndex=0 \n    maxList=0 \n    minimum=float(\"inf\") \n    maximum=0 \n    index=0 \n    localMinRange=0 \n    inRange=[] \n    for i in range(0,len(lists)): \n        inRange.append(lists[i][0]) \n        if(lists[i][0]maximum): \n            maximum=lists[i][0] \n \n    minRange=maximum-minimum \n    minList=[] \n     \n    index=lists[minListIndex].index(minimum) \n    while True: \n        index=lists[minListIndex].index(minimum) \n        if index+1>len(lists[minListIndex])-1: \n            break \n        else: \n            inRange.insert(minListIndex,lists[minListIndex][index+1]) \n            inRange.remove(lists[minListIndex][index]) \n             \n            minListIndex=inRange.index(min(inRange)) \n             \n            minimum=min(inRange) \n            localMinRange=(max(inRange)-min(inRange)) \n            if localMinRange"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; \nimport java.util.HashMap; \nimport java.util.List; \nimport java.util.Map; \nimport java.util.PriorityQueue; \nimport java.util.Queue; \n \npublic class KListsSmallestRange { \n    public static void main(String[] args) \n    { \n        int[][] arr = new int[][]{{4, 10, 15, 24, 26},{0, 9, 12, 20},{5,13, 18, 22, 30}}; \n         \n        findRange(arr); \n    } \n     \n    public static void findRange(int[][] arr) \n    { \n         \n        Queue min = new PriorityQueue(arr.length); \n        Map rows = new HashMap(); \n        Map cols = new HashMap(); \n        Map maxCols = new HashMap(); \n        List allCom = new ArrayList(); \n        int minRange = 0; \n        int minRangeIndex = 0; \n        boolean looping = true; \n        int minVal = Integer.MAX_VALUE; \n        int maxVal = Integer.MIN_VALUE; \n        List cCom = new ArrayList(); \n         \n        for(int i=0;imaxVal) \n                maxVal = value; \n \n            min.add(value); \n            rows.put(value, i); \n            cols.put(value, 0); \n            cCom.add(value); \n            maxCols.put(i, arr[i].length); \n        } \n         \n        minRange = maxVal - minVal; \n        minRangeIndex = 0; \n        allCom.add(cCom); \n         \n        while(looping) \n        { \n            minVal = Integer.MAX_VALUE; \n            maxVal = Integer.MIN_VALUE; \n             \n            List ncList = allCom.get(allCom.size()-1); \n             \n            int cMin = min.poll(); \n            int cRow = rows.get(cMin); \n            int cCol = cols.get(cMin); \n            if(cCol == maxCols.get(cRow)-1) \n                looping = false; \n            else \n            { \n                List nList = new ArrayList(); \n                for(int k=0;kmaxVal) \n                        maxVal = lVal; \n                } \n                int newRange = maxVal - minVal; \n                if(newRange < minRange) \n                { \n                    minRange = newRange; \n                    minRangeIndex  = allCom.size(); \n                } \n                allCom.add(nList); \n            } \n        } \n         \n        System.out.println(\"Min Range:\"+minRange); \n        System.out.println(\"Min range set:\"+allCom.get(minRangeIndex)); \n         \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Im not sure this is bugfree.... L(i) is the shorted list, then for each element in L(i), find the nearest element in other list, memory this range, then loop for other element in L(i). then according to the memory, find the shortest range"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution: 1) Find the list with the least number of elements. Let's call that list K. 2) Loop through all elements of list K 3) For each element of K[i], find the closest range that can include K[i], using numbers from other lists.  4) Compare all the ranges we found in step 3: best range for K[0], best range for K[1],... . Pick the best range out of them all.  Example List 1: [4, 10, 15, 24, 26]  List 2: [0, 9, 12, 20]  List 3: [5, 18, 22, 30]   1) List 2 and List 3 both have same number of elems. We can pick List as the seed List. 2) Loop through all elements of List 2 3)  For '0': best range that can represent '0' is [0,5] For '9':  best range that can represent '9' is [5,10] For '12': best range that can represent '12' is [12,18] For '20': best range that can represent '20' is [20,24]  Out of those 4 ranges, [20,24] is the best"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"JavaScript Solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For each integer in any list between the biggest small number and the largest number find the nearest number in each list and compute the range. You might of course find multiple solutions."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Another js solution, does bruteforce, not optimal but works."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution: 1. Create an Item object for every value containing a min value, max value, and referenced lists 2. For every Item object, compare every list.  - If the list is already referenced, return   - If the value within the range of min & max, add this list as reference and return   - If the value is greater than a temporary max for this item, update temporary max and continue   - Update maxValue for item and reference this list, continue 3. For every item, call GetRange() and compare with temporary range, if its smaller, make it new temp  Here's my code in c#:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution in C++, based on aasshishh idea. I use C++ STL priority_queue to maintain the smallest element."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"1)Find the minimum of all list's last index List 1: [4, 10, 15, 24, 26] List 2: [0, 9, 12, 20] List 3: [5, 18, 22, 30] which is 20 from List 2, take it as lower range. 2)Binary search in List 1 and List 3, and find its immediate greater value, which is 24 in List 1, and 22 in List 3.   3)Take the maximum of these two values as upper range(Which is 24). 4)Hence [20-24] is the required range."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"1)Find the minimum of all list's last index List 1: [4, 10, 15, 24, 26] List 2: [0, 9, 12, 20] List 3: [5, 18, 22, 30] which is 20 from List 2, take it as lower range. 2)Binary search in List 1 and List 3, and find its immediate greater value, which is 24 in List 1, and 22 in List 3. 3)Take the maximum of these two values as upper range(Which is 24). 4)Hence [20-24] is the required range. Kindly correct me, if i am wrong."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16608667","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"7","title":"What is the difference between a computers heap and it's stack?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"18","title":"Physically stack and heap both are allocated on RAM and their implementation varies from language, compiler and run time  Stack is used for local variables of functions and to track function calling sequences. Heap is used for allocating dynamically created variables using malloc, calloc or new.  Stack memory is freed whenever the function completes execution but the heap memory needs to be freed explicitly using delete, free or by garbage collector of the language.  Stack memory of a process is fixed size and heap is variable memory.  Stack is faster than heap as allocating memory on stack is simpler just moving stack pointer up.  In case of multi threading, each thread of process will have a different stack but all threads share single heap"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Basically Heap and stack both are memory partition done on RAM to store the variables value and methods respectively."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Stack size can be changed too using alloca() system call, but it is discouraged to use it since it can cause stack overflow problem but overwriting some program's data.  Also there can be holes in Heap but no holes in Stack!"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16521662","download_status":"DOWNLOAD_DONE","votes":"-6","answersCount":"16","title":"Blacklist all the nodes in a B-tree, when viewed from all 4 directions.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"pls explain me the question i couldn't get it...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"1) Blacklist root 2) Traverse all leftmost nodes and blacklist them - O(Log N) 3) Traverse all rightmost nodes and blacklist them - O(Log N) 4) Traverse the tree(any BFS or DFS) and blacklist all leaves - O(N)  Time Complexity - O(N)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can u explain the question in detail."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A B-Tree is not a binary tree, its a Bayer's Tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Though the question talks about B tree, basic idea should remain the same. Consider this tree:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Blacklist the question"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16482663","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"34","title":"Sort a singly-linked list of unknown size using constant space.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"10","title":"The question says \"unknown size\" so merge sort, quick sort and bubble sort wont work as some of the answers here say.  Insertion sort however can be applied in this case. The loop invariant to maintain here will be a sorted linked list. In the body of the loop a node will be scanned and added to the sorted linked list. Since we are only manipulating pointers, memory requirement is still O(1). Time req. O(n^2)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"It can easily be done using bubble sort"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Merge sort seems the best answer for this problem because it takes care of the O(1) memory requirement.  This can be done because rather than creating sets of temporary lists to merge back the results, the list pointers can be re-arranged themselves."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"MergeSort as mentioned by kbk and others is a good answer. However, it has to be done iteratively in bottom up way to avoid the space overhead of stack frames."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Merge sort cannot be applied as question categorically says to maintain constant space!  Use selection sort!."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. traverse list .......... one by by........ breack one node at time  2 use four pointer ....... 3 create new sorted list..... 4 inseart each node at exact position in newly created list.......  worst case time O(n^2) if n number of node ........"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Quick sort should achieve the in-place sorting."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a merge-sort solution, pardon the messiness. You just split and stick together the linked list at the different steps. Since the size is unknown the algorithm has to split by counting size and then splitting so it takes an extra O(N) in the log(N) sort/merges, but it's still O(N*log(N)). Still, for smaller arrays bubble sort would probably be faster."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"-We cant apply quick sort because traversing in reverse direction is quite costlier  -Bubble sort will give sol. but time complexity will be very high  -Merge sort is best:  -take a m size of array (as we can use cont size of memory) -copy first m element into the array[m] -sort the array -place back the sorted array in the list -now we have sorted linked list upto m size -copy next m element from the linked list (m to 2m) into the array -sort array -now start applying merge sort in array and first m element of linked list -now in case array element is needed to add in list as part of merge sort, traverse m to 2m elements of linked list and get the node reference say (*ptr) -now traverse the first m element of linked list and get the node say (*insertAfter) either equal or just less then the *ptr node's content -break the link after node (*insertAfter) and add (*ptr) node  for ex:  we have a  linked list 1 5 3  2 6 4 8 ...... create a m=3 size of array copy 3 element from list to array array = 1 5 3 sort array 1 3 5 [complexity=mlogm] copy next m=3 element from list (3 to 6)  array  = 2 6 4 sort array 2 4 6 [complexity=mlogm] apply insert sort b/z array [2 4 6] and first m=3 element of list [1 3 5] as part of merge sort we have to add 1 at fist place of list traverse list from m=3 to m=6 and get element 1's node reference break the head of link list linking and make head point to 1 and 1 point to 2 same as we can insert 3 after 2 by just breaking linking b/w 2 and 4 and insert 3 in mid so that 2 will point to 3 and 3 will point to 4  after getting sorted 2m element of list again take next m element from list sort it apply merge sort with sorted 2m elements and so on..............."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"typedef struct node \n{ \n   int data; \n    \n   struct node *next; \n} node; \n  \nnode *InsertNode(int data,node *p) \n{ \n   if(!p) \n { \n   p=(node*)malloc(sizeof(node)); \n   p->data=data; \n   p->next=NULL; \n \n   return(p); \n    } \n     node *k =NULL; \n     k=(node*)malloc(sizeof(node));   \n     k->data=data; \n     k->next=NULL; \n     p->next = k; \n \n return(k); \n } \n \nvoid print(node *p) \n{printf(\"\\n\"); \n     while(p != NULL) \n     { \n          printf(\" %d \", p->data); \n          p = p->next;  \n     } \n} \n \n \nvoid function( int inputs[], int size) \n{ \n      int i=0; \n      node *point =NULL;//create(point); \n      node *first =NULL; \n      node *newFirst =NULL;//create(newFirst); \n      node *tempPoint =NULL;//create(tempPoint); \n      //printf(\" %d \", sizeof(inputs)/sizeof(int)); \n      for(i=0 ; inext != NULL || first != NULL ) \n             { \n                    point = first; \n                    first = first->next; \n             }else \n             { \n                    break;       \n             } \n              \n             tempPoint  = newFirst; \n             do \n             { \n                if(newFirst == NULL) \n                { \n                    newFirst=point; \n                    point->next = NULL; \n                    tempPoint  = newFirst; \n                }else if(tempPoint->data < point->data && (tempPoint->next == NULL || tempPoint->next->data > point->data )) \n                { \n                    point->next = tempPoint->next; \n                    tempPoint->next =point; \n                    break;  \n                }else if(tempPoint->data > point->data) \n                { \n                      point->next = tempPoint; \n                      newFirst=point; \n                      break; \n                }else \n                { \n                     tempPoint = tempPoint->next; \n                } \n                   \n               \n             }while(tempPoint->next !=NULL); \n             print(newFirst); \n             getchar(); \n      } \n       \n       \n       \n       \n       \n      \n} \n  \nint main() \n{ \n     \n      int inputs[5]={5,2,3,4,1}; \n      int size = sizeof(inputs)/sizeof(int); \n      function(inputs, size); \n     \n     \n     \n    getchar(); \n    return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Insertion sort is what needs to be used here. Even though with insertion sort we will have O(n-square) complexity. Here is how I see the implementation:  1. Create a new empty list 2. Traverse the original list node by node and insert the new node in the newly created list but in the right order. Meaning, we need to have another function ReturnIndex(Node head, int number), which well return the index where the new number needs to be inserted in the linked list with head \"head\". 3. Once we get that index, we insert it right there.  Very elegant implementation of insertion sort can be found on Wikipedia."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"anandtechblog.blogspot.com/2012/09/faq-sort-linked-list.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"anandtechblog.blogspot.com/2012/09/faq-sort-linked-list.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Convert the LL into a binary tree and again convert the binary tree to linklist following InOrder traversal."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"External mergesort is the answer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"quick sort swap data only, not node itself"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16095689","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"10","title":"You are trying to to daemonize an unknown, black-box binary executable.  The binary executable returns no output to STDOUT or STDERR.  Assume that the mystery binary return code is non-zero.  What troubleshooting steps might you take to learn more about what the binary is supposed to do, and why it is failing?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Trace all system calls with the appropriate tool (strace/trace/truss, depending on your OS) and look for system calls returning error conditions (missing file or directory, insufficient permissions, network connection refused, ...)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"1> Turn on all the system level log, and see if there is any error message. 2> objdump the binary and see if it is calling some API of other dynamical library, replace those library with debug version and see if it will output any errors.  3> You can also replace the system level library such memory allocation clib with debug version, and dump more information out.  4> Finally you can run the binary in some virtual machine and dump its execution sequence (API call sequence with parameters), and see if it would give you some idea of what is going on."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"1. Look at the logs 2. lsof to see which files, sockets, pipes it has open 3. Run it in the dbugger and see where it core dumps ..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use strace and look at the /proc/processid directory for the runtime execution commands and all the resources, the HEAP and Stack and file handle contents."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use ldd to find the shared libraries used by the program"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Plus you could also use a decompiler (if you really wanted to know what was going on and what it was doing) and debugger to walk yourself through the entire thing."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A program can only exit in a few ways.  abort(); exit(_N) /_exit / _Exit return _N or signaled kills.  abort is obvious signals encode information in their return codes: 128 + signumber, if you see a number this high it is usually not a programmer manually setting.  All of this is just /hints/ at the solution.  If you can run the program in a debugger you can run:  gdb ./program break _exit  (note, not `exit` since this signal is not caught on _exit calls) run .... yadda yadda... bt  For a function which exited in an exit or _exit call: #0  0x00007ffff72d0af0 in _exit () from /usr/lib/libc.so.6 #1  0x00007ffff7250e2b in __run_exit_handlers () from /usr/lib/libc.so.6 #2  0x00007ffff7250eb5 in exit () from /usr/lib/libc.so.6 #3  0x000000000040065a in test() ()  For a function which exited in a return code: #0  0x00007ffff72d0af0 in _exit () from /usr/lib/libc.so.6 #1  0x00007ffff7250e2b in __run_exit_handlers () from /usr/lib/libc.so.6 #2  0x00007ffff7250eb5 in exit () from /usr/lib/libc.so.6 #3  0x00007ffff723ab0c in __libc_start_main () from /usr/lib/libc.so.6"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This is what I would do: 1. App logs (windows) 2. system level logs 3. Create a process dump and analyze 4. look for documentation. 5. Google the mystery exit code for more help"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16340666","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"4","title":"During boot, after the BIOS performs a successful power-on-self-test, describe everything that occurs until the console is presented to the user.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"This is in no way a complete answer  PCI device tree is formed  BIOS loads the MBR MBR points to the kernel image stored which is then loaded Kernel boots with one process with pid 1 Kernel imports the PCI device tree and based on PCI IDs loads the corresponding modules. Now the kernel is able to do DMA by itself (either over disk or network)   After this comes the init levels which I am not really sure about. Here's a skeletal idea. The first level is single user mode Then a multi-user mode and a shell is spawned. Then X is launched if configured."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16359670","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"15","title":"How do you make sure an API does not leak memory?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Well I guess there are couple of ways we can approach this   1> Design API such that it only Process the functionality and no memory allocation within it. 2> Use the Smart pointer concept for every pointer usage within the API. 3> Can make  API's  so that for every allocation there must be the deallocation called in. for every condition."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Run your application within a profiler such as `valgrind`.  A profiler can provide observations about the amount of memory used, and, more importantly, about possible memory leaks in your program."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Ensure, the memory for the output is provided by the caller. Api doesn't do any malloc/new. It simply does the processing on input, and copies the output into the output buffer as specified by the caller as a parameter."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"1) Determine input data set that achieves 100% code coverage. If profiling is possible: 2) Call instrumented API with this data set 3) Observe leak reports If profiling is not possible: 2) Call API repeatedly (i.e. in a loop) with this data set 3) Measure memory usage of process over time If memory measurements are not possible: 2) Call API repeatedly in a loop for extended periods of time 3) Run other applications on host system to evaluate impact of API"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"As the author of the API, we ensure no memory leak by 1. making object ownerships clear. 2. protecting heap allocation with smart pointers. 3. output arguments should be provided from caller or use sharedptr. As a user of the API, we can do some test. 1. use tools with memory leak detection, i.e. valgrind. 2. limit the heap memory of the program and simply try to amplify possible memory leak by repeatedbly calling the API."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"As the scope of API finish,try to unregister all the variable and dynamic memory that is created during API.its like the funtion to perform destructor aftr the funtion call.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Write some wrapper function for malloc/free etc dynamic memory allocation API, and add some statistics based on the time-stamp and thread ID in there. Each time before call the API, get a snapshot of the current memory usage of that thread, and after call the API, check its current thread related memory usage is the same of the snapshot taken before the API call, fatal if they are different unless you know that the API itself will need to allocate the memory."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Inside the API use a local variable. Increment it when there is allocation and decrement it  when some location is freed.This way ensures individual API not creating Mem leak.. But some times freeing can happen in some other APIs. In those cases increment/decrement should not be done. But to track them an ID of the API can be appended to malloc() structure."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A good API design should involve the following: 1. No state management. Push all state management to client code.  2. Idempotent. Same input will always provide the same output. 3. No Transaction management. Again, push it to client code.  4. Service oriented - meaning, provide a specific elemental service  When you apply all these design principles, your API code will automatically become lean. From that perspective, everything you will do becomes 'disposable' - all objects and primitive variables that you will use to service a certain request will become disposable.   Then comes the bloody internals. Ensure no loitering, reset your collections references to null etc.   But I believe that a good overall design principle are must for eliminating conditions for memory leaks."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The API should create a mempool and use objects from the mempool. After the API call is completed, you can check for allocated but not freed objects in the mempool."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16148684","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"57","title":"You are given a dictionary, in the form of a file that contains one word per line. E.g.,  abacus  deltoid  gaff  giraffe  microphone  reef  qar You are also given a collection of letters. E.g., {a, e, f, f, g, i, r, q}. The task is to find the longest word in the dictionary that can be spelled with the collection of letters. For example, the correct answer for the example values above is ??£þgiraffe???. (Note that ??£þreef??? is not a possible answer, because the set of letters contains only one ??£þe???.)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"10","title":"Create a vector V[], where V[e] contains the number of ocorrences letter e in the given set. For each word s, compute a vector Ws[], where Ws[e]  contains the number of repetitions of letter e in the word (compute size of the word too).  return the max size word  s such that  Ws[e] <= V[e], for all letters e."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"9","title":"we take an array of size=26 and initialize it by first 26 prime no. eg: 2 , 3, 5, 7,........ now these prime nos. will represent alphabet  i.e   a=2,b=3,c=5...... pro=a* e* f* f* g*  r* q=2*11*13*13.....  now we can check with every dictionary word  1)  p= product of every letter of a dictionary word       eg:  reef=61 * 11 * 11 * 13 2) if  pro % p == 0        store l = length(word); and index  // if l is greater than previous value 3)finally index will give the result of location of word"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"If we can pre-process the data, I would like to store all the dictionary words in a TRIE. While searching for the longest possible word that can be form out of given characters, we will keep refining the options available and check all the options.   If we are not allowed to pre-preprocess the dictionary data, then we can maintain two arrays.  First array : Total number of a character in the given set of characters. Then we will have to check for the presence of each dictionary word.  Second array : Initialized as a copy of first array for each new word. For each character in the word, its count in second array should be greater than zero. If yes, decrease the count by one and move to second character else move to next word. Keep the record of longest word found."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"May not be the best algorithm but something that I came up quick."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simple solution :  Let A[1 to 26] is array where all entries are zero except the one given as input. and if some char repeat then the corresponding entry tell the number. for example here f's entry will be 2 but a's entry will be 1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if we play with data structure, for exemple a table of 26 case representing 26 letters and the case value represent number of a letter appeared in a word or collection, we can have a memory and time complexity of O(1) to add or compare the collection with a word"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Most of the algorithms posted here are useless. Here's mine:  1) Sort the letters of every word in the dictionary 2) Build a trie out of them 3) Sort the letters in the query set 4) int canbeskipped=0; 5) Descend the trie and skip at most canbeskipped 6) If a word is found return it, otherwise decrement the int a jump to step 5"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Brute-force approach, C code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If we can preprocess the dictionary, I think at least we can sort the dict by the length of word, so that we can check from the longest word."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"More straight C but with additional features - ordering of input words to be able to skip words that are too long and end the search on the first hit - use simple data structures and memory operations for caching - thorough input validation"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A basic c++ implementation using containers  #include #include #include #include #include  using namespace std;  // Use quick sort to sort the strings. void quicksort(string& str, int low, int high) { char pivot = str[(low+high)/2]; int i = low; int j = high; while (i <= j) { while (str[j] > pivot) j--;  while(str[i] < pivot) i++;  if(i <= j) { char temp; temp = str[i]; str[i] = str[j]; str[j] = temp; i++; j--; } }  if (j > low) quicksort(str, low, j); if (i < high) quicksort(str,i,high); }   // Longest match algotithm. void longestmatch(map& mymap) { string matcher(\"aeffgirq\"); vector final_list; map::iterator it; for (it = mymap.begin(); it != mymap.end(); ++it) { string str = it->second; int i = 0; int j = 0; bool is_match = false; while(true) { if((i == matcher.length()) && (j < str.length())) break;  if (matcher[i] == str[j]) { i++; j++; } else { i++; }  if (j == str.length()) { is_match = true; break; } } if (is_match) { string first = it->first; final_list.push_back(first); } }  // Iterator over the final list of all the words that // match our criterion and then print the one with // highest length vector::iterator it1; int maxlength = 0; string final_string; for(it1 = final_list.begin();it1 != final_list.end();++it1) { string tmp = *it1; int length = tmp.length(); if (length > maxlength) { final_string.replace(final_string.begin(), final_string.end(), tmp); } }  cout << \"The longest string:\" << final_string << '\\n'; }  int main() { vector list; ifstream in_stream; string line; in_stream.open(\"file.txt\"); map my_map;  // Read the words into a vector while(in_stream.is_open()) { while (in_stream.good()) { getline(in_stream, line); list.push_back(line); } in_stream.close(); }  // Sort the words in the vector and put the sorted // words in a map with their keys as original words. vector::iterator it; for (it=list.begin();it!=list.end(); ++it) { string str = *it; string sorted_str = *it; int length = str.length(); quicksort(sorted_str,0,length-1); my_map[str] = sorted_str; }  // Clear this memory. No use now. list.clear();  // Get the longest match. longestmatch(my_map);  // clear the map my_map.clear(); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.List; \nimport java.util.Arrays; \nimport java.util.ArrayList; \n \npublic class LargestWord { \n    public static void main(String[] args) { \n         String maxStr = \"\"; \n          int maxLength = Integer.MIN_VALUE; \n          List words = Arrays.asList(\"abacus\", \"deltoid\", \"gaff\", \"giraffe\", \"microphone\", \"reef\", \"qar\"); \n          for (String w : words) { \n                  List check = new ArrayList(Arrays.asList('a', 'e', 'f', 'f', 'g', 'i', 'r', 'q')); \n                  boolean flag = true; \n                  for (char c : w.toCharArray()) {   \n                        if (check.indexOf(c) != -1) { \n                               check.remove(Character.valueOf(c)); \n                        } \n                       else { \n                                flag = false; \n                                break; \n                        } \n                   } \n                  if (flag && w.length() > maxLength) { \n                      maxStr = w; \n                      maxLength = w.length(); \n                  } \n           }   \n           System.out.println(maxStr);          \n      } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution in python, which is very close to thiago's vector answer:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sweet Solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"----------------------------------------------------------------------------------------------------------------------------- Following is programme snippet for the above problem.  First it read each line from the file and keep in array of dictionary in a sorted manner. later it reads the characters need to be matched and stores in another array and matches with dictionary word. Here the sorting is done as per the numeric value of character.  This programme assumes dictinary and input is having only lowercase alphabets. To extend to all characters and mumerals 26 should be replaced with 256.   -----------------------------------------------------------------------------------------------------------------------------"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is like to build a reverse index for each character. However for duplicated characters in a word, we have to do some extra work.  for example to index the fourth word"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about constructing a Trie of the dictionary and for every letter in the Set follow the Trie structure of the words. If you found in the trie path a letter that doesn't belong to the set stop and start over again with the next letter with the set. And so on. This solution is order O(k^2) and its not a function of the size of the dictionary."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def longestword(src, lst): \n    maxlen = 0 \n    for elem in lst: \n        word = list(elem) \n        word.sort() \n        if issublist(word, src): \n            if len(word) > maxlen: \n                maxlen = len(word) \n                maxword = elem \n    return maxword \n \ndef issublist(sub, lst): \n    if not sub: \n        return True \n    try: \n        idx = lst.index(sub[0]) \n        return issublist(sub[1:], lst[idx + 1:]) \n    except ValueError: \n        return False \n \nsrc = ['a', 'e', 'f', 'f', 'g', 'i', 'r', 'q'] \nlst = ['abacus', 'deltoid', 'gaff', 'giraffe', 'microphone', 'reef', 'qar'] \nprint longestword(src, lst)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// just check if"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"1. Associate a key with each word of the dictionary. The key would be the alphabetically sorted word.. i.e. abacus will  be aabcsu, microphone will be cehimnoopr and so on.. 2. If inputs provided then sort the dictionary based on the new key. 3. Sort the letter array alphabetically. 4. Search this letter array in the dictionary.  - Preprocessing complexity is O(nlogn). - Searching is done in O(logn). - If you need to search only once, then dont sort the initial array and just search for a total complexity of O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Step -1 - Get the sum of the ASCI values of the collection {a, e, f, f, g, i, r, q} Step -2 - In dictionary get the sum of ASCII value of each chars in a word and compare it with the sum of collection."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15858666","download_status":"DOWNLOAD_DONE","votes":"-10","answersCount":"9","title":"Input is a number of words. Construct a listing of valid 6-letter words. You have access to bool IsValid(const string& word);  Implement Insert() and Get() for this listing.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Write a method to get the next string in the alphabetic order from the current string:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can the question be clarified?  what exactly is the input, an array of strings?  and what is the expected out, an array of strings?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"yes, the question is in't  clear. Plz elaborate."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"prolly implementation of a hashmap is wat the interviewer was getting at acc to the operations insert and get..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#include #include #include #include #include  using namespace std;  // Use quick sort to sort the strings. void quicksort(string& str, int low, int high) {   char pivot = str[(low+high)/2];   int i = low;   int j = high;   while (i <= j) {     while (str[j] > pivot)       j--;      while(str[i] < pivot)      i++;      if(i <= j) {       char temp;       temp = str[i];       str[i] = str[j];       str[j] = temp;       i++;       j--;     }   }    if (j > low)     quicksort(str, low, j);   if (i < high)     quicksort(str,i,high); }   // Longest match algotithm. void longestmatch(map& mymap) {   string matcher(\"aeffgirq\");   vector final_list;   map::iterator it;   for (it = mymap.begin(); it != mymap.end(); ++it) {     string str = it->second;     int i = 0;     int j = 0;     bool is_match = false;     while(true) {       if((i == matcher.length()) && (j < str.length()))         break;        if (matcher[i] == str[j]) {         i++;         j++;       } else {         i++;       }        if (j == str.length()) {         is_match = true;         break;       }     }     if (is_match) {       string first = it->first;       final_list.push_back(first);     }   }    // Iterator over the final list of all the words that   // match our criterion and then print the one with   // highest length   vector::iterator it1;   int maxlength = 0;   string final_string;   for(it1 = final_list.begin();it1 != final_list.end();++it1) {     string tmp = *it1;     int length = tmp.length();     if (length > maxlength) {       final_string.replace(final_string.begin(), final_string.end(), tmp);     }   }    cout << \"The longest string:\" << final_string << '\\n'; }  int main() {   vector list;   ifstream in_stream;   string line;   in_stream.open(\"file.txt\");   map my_map;    // Read the words into a vector   while(in_stream.is_open())   {     while (in_stream.good()) {      getline(in_stream, line);      list.push_back(line);     }     in_stream.close();   }    // Sort the words in the vector and put the sorted   // words in a map with their keys as original words.   vector::iterator it;   for (it=list.begin();it!=list.end(); ++it) {     string str = *it;     string sorted_str = *it;     int length = str.length();     quicksort(sorted_str,0,length-1);     my_map[str] = sorted_str;   }    // Clear this memory. No use now.   list.clear();    // Get the longest match.   longestmatch(my_map);    // clear the map   my_map.clear(); }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15832681","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"10","title":"Escape strings. Convert special ASCII characters to form of ??\\ooo??, where ??ooo?? is oct digit of the corresponding  special character.  The ascii characters that smaller than space are regarded as special characters.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"#include  \n#include  \n#include  \n#include  \n \nusing namespace std; \n \nstring convert(const string &s){ \n stringstream o; \n \n   for(char i : s){ \n      if(i < ' ') \n         o << \"\\\\\" << setw(3) << setfill('0') << oct << (int)i; \n      else \n         o << i; \n   } \n   return o.str(); \n} \n \nint main(int argc, char *argv[]) { \n   cout << convert(\"A\\tB\") << endl; \n   return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Use a lookup table for the 32 special ASCII characters and then simply search and replace.   public class OctalEscape {   public static void main(String args[]) {   System.out.println(escape(\"\\000sdjfj k\\004ljf lafj   \\100\\040\\100 asdfj akl\\010jsdfklf\"));  }    static String lookup[];  static {   buildLookupTable();  }    static void buildLookupTable() {   lookup = new String['0'];   char octal[] = new char[] {'0','0','0'};   int c = 0;   for (char i = '0'; i <= '7'; ++i) {    octal[0] = i;    for (char j = '0'; j <= '7'; ++j) {     octal[1] = j;     for (char k = '0'; k <= '7'; ++k) {      octal[2] = k;      lookup[c++] = \"\\\\\" + octal[0] + octal[1] + octal[2];      if (c == ' ') {       return;      }     }    }   }  }    static String escape(String s) {   StringBuffer result = new StringBuffer();   char sArray[] = s.toCharArray();   for (char c : sArray) {    if (c < ' ') {     result.append(lookup[c]);    }    else {     result.append(c);    }   }   return result.toString();  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi  Can you please elaborate ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi, basically, nothing should be modified for the original string, since the new char '\\ooo' would be the same as the previous char."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"So if I understand you correctly if the input string is: \"A#B\" output should be \"A\\043B\" as ascii character '#' maps to decimal 35 and octodecimal 43. Right?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16049662","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"19","title":"Suppose we use binary search tree to implement set, design an algorithm that we can get an random element from the set, while            maintain all the other set operations have same complexities.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"Here is my thought: all we need is an API which will find the kth element in the tree, such as tree.find(int k). For the kth element, we can achieve O(n) time complexity using normal binary search tree itself. If we want better, we can store some counts of child elements in the node, and so the delete and insert operation would need to update the count of all its Ancestors. The final performance of search would depend on the snap shot of tree at the time. If it is more like balanced binary search tree, you got the O(log(n)). If it is more like a list, it is O(n). But it will all guarantee the uniform probability distribution at any snapshot of the tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"What should be the distribution? If not specified, we can start in root and decide randomly in each node whether to continue to left or to right. If uniform, we need to maintain weights of left or righ subtree in each node. Than, start in root and decide in every node in the following way: if weight of left subtree is L and right is R, then D = random (1, L+R); if D < L then go left; else go right."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Traverse the tree once and record the size (i.e. the number of nodes) of each subtree at each node. Then, starting from the root, do the following:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"If we know the size of the subtree rooted at each node of the tree (and hence of the whole tree) we could get a random element in O(log n) time (assuming the tree is balanced and its height is log n, O(h) in the general case)  Check the root and see how many elements are in the tree, say n. Then generate a random int k between 0 and n. We just have to select the k-th element: but we know how many elements there are in each subtree, and we can use a recursive function. So if size(root->left) == k-1 we return the root, if size(root->left) < k - 1 we can return the (k - size(root->left) - 1)-th element of the right tree, otherwise we return the k-th element of the left subtree. No more than O(h) calls are needed"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We could also use an order-statistic tree, which is a balanced-BST.  So, if  we keep count of   the total nodes in the tree,then we can call  index into the K'th node in the list, in O(logn) time. .. the index being generated by random number generator from (0,K-1) ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how does this sound? Assume that height of the tree is always known to us. In that case we select a random int < height of the tree. Then we travel that deep and at each level we make a random decision of whether to go left or right.   We might have to store height of the subtree at each node if the tree is highly skewed and take the height of the subtree into account too whenever we make decision on left/right child."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"since this is a BST, we can search the k highest node. assuming we know the size of the tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"augment the data structure to include # of nodes. and return k = rand() % size + 1, and return kth smallest element"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16074662","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"15","title":"Return a shortest prefix of word that is not a prefix of any word in the list  e.g.  word: cat, it has 4 prefixes: ??£þ???, ??£þc???, ??£þca???, ??£þcat??? list: alpha, beta, cotton, delta, camera    Result is ??£þcat???","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"11","title":"1> build a prefix tree of the lists. 2> Go though the tree using the each character of the word in order until if hit a dead end,then it is the shortest prefix you wants.  Otherwise the word is the prefix of some word in the list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"We only need to compare the word against the beginning of each item in the list, keeping track of the longest match. The result is max + 1, unless the entire prefix matched some word, in which case we can exit early and there is no solution (return null).  The prefix \"\" can never be a result since it matches everything.  Complexity is O(N*m) since we iterate through the list once, comparing m characters (m is the length of word). This is the best we can do since we must compare the prefix against every word."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Why not insert the word(e.g. CCD) to that list, and sort it, then compare the one before CCD and the one after CCD? O(nlgn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this should do it.  Iterate through the input string character by character. Maintain a set which stores the indices of all the strings in the array of strings to check against. For every character, check if the corresponding character in all the remaining strings is the same or not. If it is not the same, or if the string has ended, remove that string's index from the set. Otherwise keep it. If at the end of checking through the array there are no more elements in the set, it means we are past all the string-prefixes and can hence return a substring containing the chars from 0 to charAt. If we run through all characters and have at least one string that always matches, after the loop we return null because no substring that is not a substring exists. Code below."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package org.com; \n \nimport java.util.ArrayList; \n \npublic class SuffixChecking { \n  \n private String first; \n private ArrayList list = null; \n  \n public SuffixChecking(String a, ArrayList l){ \n  first = a; \n  list = l; \n } \n \n public void generateSuffix(){ \n  String suffix = null; \n  boolean found = false; \n  for(int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class ShortestPrefix { \n \n String[] dict; \n \n public ShortestPrefix(String[] dict) { \n  this.dict = dict; \n } \n \n public String unusedShortestPrefix(String prefix) { \n  if (prefix == null || prefix.isEmpty()) { \n   return null; \n  } \n \n  // add +1 more to the size of array to \n  // allow returning null when we have used \n  // all the prefixes \n   \n  String [] prefixes = new String[prefix.length()+1]; \n   \n  // marker to keep track of next available prefixes in the \n  // array as we may use this to skip discarded prefixes \n  // \n  int prefixStart = 0; \n   \n   \n  // prepare all the possible prefixes \n  for (int i = 0; i < prefix.length(); i++) { \n   prefixes[i] = prefix.substring(0, i+1); \n  } \n   \n  for (int i = 0; i < dict.length; i++) { \n   String word = dict[i]; \n  \n   for(int j = prefixStart; j < prefixes.length-1; j++) { \n    if (!word.startsWith(prefixes[j])) { \n     // ignore \n     break; \n    } \n     \n    // current prefix matched \n    // discard the prefix and update the prefix start index \n    prefixStart++; \n     \n     \n    // continue to check with the next prefix \n   } \n    \n   // all prefixes are used - no unmatched prefix \n   // abort \n   if (prefixStart == prefixes.length) { \n    break; \n   } \n  } \n \n  // the first unmatched prefix or no unmatched prefix [ null ] \n  return (prefixes[prefixStart]);  \n } \n  \n  \n \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n  String[] dict = { \"alpha\",  \"beta\", \"cotton\", \"delta\", \"camera\" }; \n \n  ShortestPrefix sp = new ShortestPrefix(dict); \n \n  String prefixString = \"cat\"; \n \n  String shortestPrefix = sp.unusedShortestPrefix(prefixString); \n \n  System.out.println(shortestPrefix); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@stevenh47 Your solution may work but it will more complex than O(n*m)  unless m is very large. Also, sorting a string list takes longer than O(n log n) because string comparisons take longer than O(1) ."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15556758","download_status":"DOWNLOAD_DONE","votes":"13","answersCount":"65","title":"There is an island which is represented by square matrix NxN.  A person on the island is standing at any given co-ordinates (x,y). He can move in any direction one step right, left, up, down on the island. If he steps outside the island, he dies.  Let island is represented as (0,0) to (N-1,N-1) (i.e NxN matrix) & person is standing at given co-ordinates (x,y). He is allowed to move n steps on the island (along the matrix). What is the probability that he is alive after he walks n steps on the island?  Write a psuedocode & then full code for function  \" float probabilityofalive(int x,int y, int n) \".","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"15","title":"I presume that the probabilities of move up/donw/left/right are equal(0.25). Then P(x, y, n, step) = (P(x-1, y, n, step-1) + P(x+1, y, n, step-1) + P(x, y-1, n, step-1) + P(x, y+1, n, step-1)) / 4. (x, y) is the position. (n) is the size of island. (step) is the remaining step. The following code is my Java implementation with some simple tests. Dynamic Programming is also used."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"1. Generate NxN probability matrix P(x,y,1) for all (x, y) coordinates (x & y ranges from 0 to N-1). P(x,y,1) is the probability of staying alive after taking 1 step 2. Now using this, we need to calculate the NxN probability matrix P(x,y,2) for all x and y - will be P(x,y,1) * { {Valid among P(x+1, y, 1) + P(x, y+1, 1) + P(x-1, y, 1) + P(x, y-1, 1) } / num of valid adjascent slots }. Now we have P(x,y,2) probability matrix. 3. Using induction, we can calculate P(x, y, k) using P(x, y, k-1). Repeat this N times, we have our probability matrix after N steps"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Efficient Solution in Python (with tests)  This is a DP solution that only computes one octant of the matrix, since all the other octants are just reflections.  It also defers dividing by powers of four until the end."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public float prob(int x, int y, int n) { \n if ((x<0)||(y<0)||(x>=n)||(y>=n)) \n  return 0; \n else if (n==1) \n  return 1; \n return (prob(x-1, y, n-1)+prob(x, y-1, n-1)+ \n  prob(x+1, y, n-1)+prob(x, y+1, n-1))/4; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"#include  \n#include  \nusing namespace std; \n \n#define N 5 \n \nfloat probabilityofalive(int x,int y, int n){ \n assert( x>=0 && x=0 && y"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Psuedocode for probabilityofdead :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A DP problem. Let's say the person is at (x0, y0) initially(instead of (x, y) in the question) Build a table W(n, N, N) whose entry W(k, x, y) is the number of ways to get to (x, y) from initial location(x0, y0) after k steps. Now, without considering the border,"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be solved using DP"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def probDeadHelper(x,y,n,N,deadAlive): \n    if n==0: \n        deadAlive[1] = deadAlive[1]+1 \n        return \n    if (x<0 or x >=N or y <0 or y >=N): \n        deadAlive[0] = deadAlive[0] +1 \n        return \n    probDeadHelper(x-1,y,n-1,N,deadAlive) \n    probDeadHelper(x+1,y,n-1,N,deadAlive) \n    probDeadHelper(x,y-1,n-1,N,deadAlive) \n    probDeadHelper(x,y+1,n-1,N,deadAlive) \ndef probDead(x,y,n,N): \n    deadAlive = [0,0] \n    probDeadHelper(x,y,n,N,deadAlive) \n    dead = deadAlive[0] \n    alive = deadAlive[1] \n    return (alive/(alive+dead))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Pseudo code  - Add x, y, N-x, N-y into sorted array - assume highest to lowest order is N-x, y, N-y, x for now - if n > N-x return 1 (means if person moves n steps at all any direction he will be dead) - if n < x return 0 ( means if person moves n steps any dir he will be alive) - if n is between N-x and y return .75 And so on"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My Idea :  1> For area outside the NXM, the death Prob is 1, what ever the step is. (step>=0)  2> For area inside the NxM and step=0, death Prob is zero.  3> For Other x, y, and step, probDeath(x,y,step)=1/4*(probDeath(x-1,y, step-1) + probDeath(x+1,y, step-1)+probDeath(x,y-1, step-1) +probDeath(x,y+1, step01)). Assume the person runs randomly.  4> The logic above also added a array to store the shared calculated result (as does dynamic programming) to save the computation time during the recursive call.  5> ProbLive(x,y, step)=1-ProbDeath(x,y,step).  My Code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def deadprobability(n, N, x0, y0): \n    waystodie = 0 \n    W = [[[0 for y in range(0, N)] for x in range(0, N)] for k in range(0, n + 1)] \n    W[0][x0][y0] = 1 \n \n    for k in range(1, n + 1): \n        for x in range(0, N): \n            for y in range(0, N): \n                if x == 0: \n                    waystodie +=  W[k - 1][x][y] \n                if x == N - 1: \n                    waystodie += W[k - 1][x][y] \n                if y == 0: \n                    waystodie += W[k - 1][x][y] \n                if y == N - 1: \n                    waystodie += W[k - 1][x][y] \n                if x > 0: \n                    W[k][x][y] += W[k - 1][x - 1][y] \n                if x < N - 1: \n                    W[k][x][y] += W[k - 1][x + 1][y] \n                if y > 0: \n                    W[k][x][y] += W[k - 1][x][y - 1] \n                if y < N - 1: \n                    W[k][x][y] += W[k - 1][x][y + 1] \n        print str(W) \n \n    waysalive = 0 \n    for x in range(0, N): \n        for y in range(0, N): \n            waysalive += W[n][x][y] \n \n    probalive = 1.0 - waystodie / ((waystodie + waysalive) * 1.0) \n    print waystodie, waysalive, probalive \n \ndef test(n, N, x0, y0): \n    print 'Initial at (%d, %d) in %dx%d island, after %d steps'%(x0, y0, N, N, n) \n    deadprobability(n, N, x0, y0) \n \ntest(1, 1, 0, 0) \ntest(2, 1, 0, 0) \ntest(2, 2, 0, 0) \ntest(2, 3, 1, 1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \nbool isDead(unsigned int N, int x, int y) \n{ \n    if (x < 0 || x >= N || y < 0 || y >= N) \n    { \n        return true; \n    } \n    return false; \n} \n \nstatic unsigned int deadCount = 0; \nstatic unsigned int overallCount = 0; \n \nvoid computeAllPaths(int x, int y, int n, int N) \n{ \n    if (isDead(N, x, y)) \n    { \n        deadCount += 1; \n        overallCount += 1; \n    } \n    else \n    { \n        if ( n > 0) \n        { \n            computeAllPaths(x-1, y, n-1, N); \n            computeAllPaths(x + 1, y, n-1, N); \n            computeAllPaths(x, y - 1, n-1, N); \n            computeAllPaths(x, y + 1, n-1, N); \n        } \n        else \n        { \n            overallCount += 1; \n        } \n    } \n} \n \nfloat probabilityofalive(int x, int y, int n, int N) \n{ \n    if (x >= 0 && x < N && y >=0 && y< N) \n    { \n        deadCount = 0; \n        overallCount = 0; \n \n        computeAllPaths(x, y, n, N); \n \n        return (float) deadCount / (float) overallCount; \n \n    } \n \n    return 1.0; \n} \n \nvoid main() \n{ \n    int x = 4; \n    int y = 4; \n    int n = 5; \n    int N = 6; \n    printf(\"probability (x:%d, y:%d, N:%d, n:%d) = %f\", x, y, N, n, probabilityofalive(x,y,n,N)); \n \n    getchar(); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static double prop2Alive(int x,int y, int N,int step){   if(x<0 ||y<0||x>=N||y>=N) return 0;   else {    if(step==0) return 1;        return (prop2Alive(x-1,y,N,step-1)+prop2Alive(x,y-1,N,step-1)+prop2Alive(x+1,y,N,step-1)+prop2Alive(x,y+1,N,step-1))/4;   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is my code, it could be optimized by only calling checkBoundary on the borders and exiting the main loop once you reach i==x && j==y && steps == n, but i was going for simplicity of the code here."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For below method, k: number steps. N: size of square matrix island.  Considering array alive[N][N][2], where each element in alive[i][j][steps%2] will keep count of the favourable cases. To calculate this count we just need the result from previous steps, i.e.,   top   = alive[i-1][j][(steps-1)%2];  down  = alive[i+1][j][(steps-1)%2];  left  = alive[i][j-1][(steps-1)%2];  right = alive[i][j+1][(steps-1)%2];   So, favourable cases for alive[i][j][steps%2] = up + down + left + right;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Model it as a graph search see how many nodes you visited and how many times you result in a death {{   def probabilityalive(x,y,nmoves,N):  deaths,moves = getprob((x,y),nmoves,N,0,set())  return 1 - deaths/(1.0 * (moves - 1))   def getprob(xy,nmoves,N,depth,visited):  if xy in visited or depth > nmoves: return 0,0  deaths = 0  x,y = xy  if xy[0] > N-1 or xy[0] < 0 or xy[1] > N-1 or xy[1] < 0:   return 1,1  moves = 1  visited.add(xy)  successors = [(x,y+1),(x,y-1),(x-1,y),(x+1,y)]  for s in successors:   d,m = getprob(s,nmoves,N,depth+1,visited)   deaths += d   moves += m  return deaths,moves   print probabilityalive(5,5,10,10)*100  }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def probabilityalive(x,y,nmoves,N): \n deaths,moves = getprob((x,y),nmoves,N,0,set()) \n return 1 - deaths/(1.0 * (moves - 1)) \n  \ndef getprob(xy,nmoves,N,depth,visited): \n if xy in visited or depth > nmoves: return 0,0 \n deaths = 0 \n x,y = xy \n if xy[0] > N-1 or xy[0] < 0 or xy[1] > N-1 or xy[1] < 0: \n  return 1,1 \n moves = 1 \n visited.add(xy) \n successors = [(x,y+1),(x,y-1),(x-1,y),(x+1,y)] \n for s in successors: \n  d,m = getprob(s,nmoves,N,depth+1,visited) \n  deaths += d \n  moves += m \n return deaths,moves \n  \nprint probabilityalive(5,5,10,10)*100"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#!/usr/bin/env python \n \nfrom collections import defaultdict \n \ncalc_table = defaultdict(lambda : 1.0) \n \ndef p(n, steps, si, sj): \n \n    for k in range(1, steps+1): \n        for i in range(n): \n            for j in range(n): \n                calc_table[(n, k, i, j)] = 0 \n                if i-1 >= 0: \n                    calc_table[(n, k, i, j)] += calc_table[(n, k-1, i-1, j)] \n                if i+1 < n: \n                    calc_table[(n, k, i, j)] += calc_table[(n, k-1, i+1, j)] \n                if j-1 >= 0: \n                    calc_table[(n, k, i, j)] += calc_table[(n, k-1, i, j-1)] \n                if j+1 < n: \n                    calc_table[(n, k, i, j)] += calc_table[(n, k-1, i, j+1)] \n                calc_table[(n, k, i, j)] /= 4.0 \n \n    return calc_table[(n, steps, si, sj)] \n \nif __name__ == \"__main__\": \n    print p(4, 4, 0, 0) \n    print p(4, 4, 1, 1) \n    print p(4, 4, 2, 2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Create a quadrant decision tree from the current co-ordinate with depth = n. While you are constructing the tree, if a branch reached an out of bound condition, increase  deadly branches count by 1. And then move backwards using recursion to construct the next branch and so on. The final count of the bad branches/ the total number of branches is your probability. This is similar to what is used in gaming."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Island {  private int islandSize = N;  public float getSurvivalProbability(int x, int y, int n) {   if ( x < 0 || x > N - 1 || y < 0 || y > N - 1) {    return 0;   }   else if (n == 0) {     return = 1;    }     else {     return      0.25 * getSurvivalProbability(x - 1, y, n -1) +     0.25 * getSurvivalProbability(x, y - 1, n -1) +     0.25 * getSurvivalProbability(x, y + 1, n -1) +     0.25 * getSurvivalProbability(x + 1, y, n -1);   }  }  public float getDeathProbability(int x, int y, int n) {   return 1 - getSurvivalProbability(x, y);  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"double solve(int x, int y, int k) \n   { \n            if (x < 0 || x > n || y < 0 || y > n) return 0; \n            if (k == 0) return 1.0; \n            double ret(0.0); \n            if (x+1 < n) ret += solve(x+1, y, k-1); \n            if (x-1 >=0) ret += solve(x-1, y, k-1); \n            if (y-1 >=0 ) ret += solve(x, y-1, k-1); \n            if (y+1 < n) ret += solve(x, y+1, k-1); \n            return 0.25 * ret;  \n   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be easily done using BFS. The equation I followed is as below: ProbAlive(after N steps) = ProbAlive(after 1 step)                                           * ProbAlive(after 2 steps, given alive after 1 step) *                                           * ...                                           * ProbAlive(after N steps, given alive after N-1 steps)  To compute the term ProbAlive(after K steps, given alive after K-1 steps), BFS is used. When the BFS queue has only elements with positions for kth step, sample space is the queue-size. Iterate through all elements in the queue and if position is valid, add a probability of 1/queue-size to ProbAliveCurStep. During that time, enqueue all subsequent positions with step marked as k+1. Before processing queue with positions marked as k+1, update ProbAlive = ProbAlive * ProbAliveCurStep and reset ProbAliveCurStep.  e.g. For a 4x4 Matrix, max_step 2 and initial pos 0, 0 Iteration 1: Queue Contents: (x: 0, y: 0, step: 0) Pop Element: (0, 0, 0) Sample Space = 0; // Initial position is ignored for probability computation ProbAliveCurStep = 0; Enqueue Neighbours  Iteration 2: Queue Contents: (1, 0, 1), (-1, 0, 1), (0, 1, 1), and (0, -1, 1) Pop Element: (1, 0, 1) // Valid element, proceed Sample Space = 4 ProbAliveCurStep = 0.25 Enqueue Neighbours  Iteration 3: Queue Contents: (-1, 0, 1), (0, 1, 1) and (0, -1, 1) Pop Element: (-1, 0, 1) // Invalid element, continue ... ... After 13 iterations, ProbAliveCurStep for Step 1 = 0.5, ProbAliveCurStep for Step 2 = 0.75 ProbAlive = 0.357"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution in C++. We fill a matrix of size n*N*N in O(n*N^2) time :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Heres my attempt, not sure if its completely sound. Any advice would be greatly appreciated :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Island { \n private int[][] fields; \n \n public Island(int size) { \n  this.fields = new int[size][size]; \n } \n \n public boolean isInRange(int x, int y) { \n  return x >= 0 && y >= 0 && x < size() && y < size(); \n } \n \n public int size() { \n  return fields.length; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Here is an O(1) solution:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15542726","download_status":"DOWNLOAD_DONE","votes":"3","answersCount":"46","title":"Given the English alphabet, 'a' through 'z' (lowercase), and an imaginary onscreen keyboard with the letters laid out in 6 rows and 5 columns:","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"If we observe the 2D matrix[6][5], we have integer values as (intVal) : a -> 0 b -> 1 e -> 4 f -> 5 . . . z -> 25 ===================== Map these 1D values to 2D index values.  Let [ _i ] [ _j ] be current position of cursor on matrix.  Let i be a row_no and j be col_no.     ROW = 6;     COL = 5;  for any alphabet 'input', find [i][j] like this i = intVal(input) / COL; j = intVal(input) % COL;  now first move (i - _i) horizontal steps, then move (j - _j) vertical steps. This can be printed also. After reaching to [i][j], print '!' (OK button), then update values of [ _i ] [ _j ] equal to [i][j]."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Where can we assume the initial position of cursor?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"16 #include  \n 17 #include  \n 18 void print_path(int src,int dst){ \n 19    \n 20   while(dst!=src) { \n 21     if(dst%5 > src%5) {printf(\"r\");src+=1;} \n 22     else if(dst%5 < src%5) {printf(\"l\");src-=1;} \n 23     else{  \n 24       if(dst>src) {printf(\"d\"); src+=5;} \n 25       else {printf(\"u\");src-=5;} \n 26     } \n 27   }  \n 28     printf(\"!\"); \n 29 } \n 30  \n 31 //assume lower case \n 32 void remote(char *str, int len){ \n 33   int cur=0; \n 34   int src; \n 35   int dst; \n 36    \n 37   while(cur!=len-1){ \n 38     src=str[cur]-'a'; //convert to 0-25 \n 39     dst=str[cur+1]-'a'; \n 40     print_path(src,dst); \n 41     cur++; \n 42   }  \n 43 }  \n 44  \n 45 int main(int argc, char *argv[]){ \n 46   char *in; \n 47   if(argc<2) \n 48     in=\"balamark\"; \n 49   else \n 50     in=argv[1]; \n 51  \n 52   remote(in, strlen(in)); \n 53   return 0; \n 54 }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There can be multiple sequences. Do they want all such path or anyone?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we can map each alphabet to a coordinate.....create a list of coordinates and then apply djikstra to get to the next alphabet."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think there will also be a special case for letter 'z'. There is only \"up\" direction possible from that location."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"my approach 1. Maintain a hashtable which stores char --> address 2. As there is no diagonal moment possible, the shortest distance from the current point to the target would be moving horizontally till we reach the column containing the target and moving vertically to the row containing the target.(increase/decrease x and increase/decrease y) 3. print out the sequence while moving and print ! once you reach the target."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"char *getCommand(char *word) \n{ \n \n    int index = 0; \n \n    int prevX = -1; \n    int prevY = -1; \n \n    std::string result; \n \n    while (word[index] != '\\0') \n    { \n        int offset = word[index] - 'a'; \n \n        int x = offset % 5; \n        int y = offset / 5; \n \n        if (prevX == -1) \n        { \n            prevX = x; \n            prevY = y; \n        } \n        else \n        { \n            if (x - prevX > 0) \n            { \n                for(int e=prevX; e 0) \n            { \n                for(int e=prevY; e < y;++e) \n                { \n                    result.append(\"d\"); \n                } \n            } \n            else \n            { \n                for(int e = y; e"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class Solution \n{ \n/* return the position of the char c in alphabet. example position a = 0, position b = 1 */ \npublic static int getPosition( char c ) \n{ \n int n = (int)c; \n return n - 96 ; \n} \n/* from the position of a char, determine it's x coordinate in the keyboard */ \npublic static int getX(int position ) \n{ \n return position / 5 ; \n} \n/* from the position of a char, determine it's y coordinate in the keyboard */ \npublic static int getY(int position) \n{ \n return position % 5 ; \n} \n \n/* make an print the combination that writes the word */ \npublic static void makeCombination(String word) \n{ \n int size = word.length(); \n int pos = 0; \n char prev = '`';  /*  has acii = 96. make sure we start at (0,0) */ \n char next ; \n StringBuilder comb = new StringBuilder(); \n while( pos < size ) \n { \n   \n  next = word.charAt(pos++);   \n  int prev_pos = getPosition(prev); \n  int next_pos = getPosition(next); \n  comb.append( genMove( getX(prev_pos), getY(prev_pos), \n   getX(next_pos),  getY(next_pos)));  /* combination for prev -> next in kb */ \n  prev = next; \n } \n System.out.println(comb); \n} \n \n \npublic static String genMove(int i , int j , int m , int n) \n{ \n /* instead of djikstra or else to find the shortest path */ \n /* it's more efficient to just go up and down. pretty simple too */ \n /* though i agree if this program is to be use in the long run, moves must be  \n precomputed and stored somewhere so we don't have to do this every time */ \n StringBuilder move = new StringBuilder(); \n \n if( i < m ) \n { \n  /* move down on the keyboard */ \n  int cnt = 0; \n  while(cnt++ < m - i ) \n  { \n   move.append('d'); \n  } \n } \n if( i > m ) \n { \n  /* move up on keyboard */ \n  int cnt = 0; \n  while(cnt++ < i - m ) \n  { \n   move.append('u'); \n  } \n } \n if( j < n ) \n { \n  /* then move right */ \n  int cnt = 0; \n  while(cnt++ < n - j ) \n  { \n   move.append('r'); \n  } \n } \n \n if( j > n ) \n { \n  /* then move left */ \n  int cnt = 0; \n  while(cnt++ < n - j ) \n  { \n   move.append('l'); \n  } \n } \n move.append('!'); /* found the letter sought*/ \n return move.toString(); \n} \npublic static void main(String arg[]) \n{ \n /* run example */ \n String string = new String(\"vaiejoahvuhpae\"); \n makeCombination(string); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"refer to my earlier reply for the approach"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First , I will put all alphabets in a two dimensional array , say , alphabets[6][5] , thus , alphabets[0][0] becomes 'a'  and so on. Now , I will create a hashmap for all 26 alphabets mapping there location on two dimension array . I can do that by creating a class say ,Coordinates , having two instance variables int row and int column . So , it can be written like this ,               Map keys = new HashMap;               Coordinate aobj = new Coordinate(0,0); // create obj for 'a', with row =0 , col =0               keys.put('a',aobj);  Or , we can simply put two digit integer and later retrieve the column and row from unit place and tens place respectively.     Now , lets say we have to write sequence for a  word say 'word'  ,        By using hashmap we will find location of 'w' is 4,2 and location of o is 2, 4         Travelling from 4,2  to 2,4 can be done in various ways , one way is to first traverse the difference in rows vertically , if difference of first-second is positive then upwards otherwise downwards  , in this case ,4- 2=2 so two  rows upwards ,  similarly for the columns can be done."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the qns is same as that of finding a word in a given 2-D array. Use recursion and whenever we recurr for up, left. right or down print \"up - 'u', down 'd', left 'l', right 'r' and enter '!\" accordingly as per the call. This will give the complete sequence of moves."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In C# --------"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public List findSteps(String input_) { \n    char[] letters = input_.toCharArray(); \n    List sequence = new ArrayList(); \n    int currentRow = 0; // start at top left \n    int currentCol = 0; \n    for (char letter : letters) { \n      // find the row/column in the matrix where this letter will be \n      int diff = letter - 'a'; \n      int row = diff / 5; \n      int col = diff % 5; \n \n      // find where the new row/column is in relation to our existing position \n \n      // row movement \n      if (row < currentRow) { \n        // need to move up by this may rows \n        for (int i = row; i < currentRow; i++) { \n          sequence.add(\"u\"); \n        } \n      } else if (row > currentRow) { \n        // need to move down by this may rows \n        for (int i = currentRow; i < row; i++) { \n          sequence.add(\"d\"); \n        } \n      } \n \n      // column movement \n      if (col < currentCol) { \n        // need to move left by this many columns \n        for (int i = col; i < currentCol; i++) { \n          sequence.add(\"l\"); \n        } \n      } else if (col > currentRow) { \n        // need to move right by this many columns \n        for (int i = currentCol; i < col; i++) { \n          sequence.add(\"r\"); \n        } \n      } \n       \n      // update position \n      currentRow = row; \n      currentCol = col; \n    } \n    sequence.add(\"!\"); // enter \n    return sequence; \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \n \nusing namespace std; \n \nstruct Pos { \n Pos () \n : x(0), y(0) \n {} \n \n int x; \n int y; \n}; \n \nPos getDistance(Pos &a, Pos &b) \n{ \n  Pos distance; \n  distance.x = b.x - a.x; \n  distance.y = b.y - a.y; \n \n  return distance; \n} \n \nenum Moves { \n  UP  = 'u', \n  DOWN = 'd', \n  LEFT = 'l', \n  RIGHT = 'r', \n  ENTER = '!' \n}; \n \nmap positions; \nPos getNextPos(Pos p1, char letter) \n{ \n Pos absPos = positions[letter]; \n return getDistance(p1, absPos); \n} \n \nstring generateSequence(string word) \n{ \n Pos curPos; \n string sequence; \n for(unsigned int i = 0; i < word.size(); ++i) \n { \n     Pos next; \n     if (i == 0 && curPos.x == 0 && curPos.y == 0) \n       next = positions[word[i]]; \n     else \n       next = getNextPos(curPos, word[i]); \n \n     curPos = positions[word[i]]; \n     if (next.x > 0) \n   while(next.x-- > 0) \n     sequence += DOWN; \n     else \n   while(next.x++ < 0) \n     sequence += UP; \n \n     if (next.y != 0) \n     { \n   if (next.y > 0) \n    while(next.y-- >= 0) \n     sequence += RIGHT; \n   else \n    while(next.y++ <= 0) \n     sequence += LEFT; \n     } \n \n     sequence += '!'; \n } \n \n return sequence; \n} \n \nint main() \n{ \n  int count = 97; \n  for (int i = 0; i < 6; i++) \n  { \n    for (int j = 0; j < 5; j++) \n    { \n      Pos p; \n      p.x = i+1; \n      p.y = j; \n      positions[count++] = p; \n    } \n  } \n \n  cout << generateSequence(\"zztop\") << endl; \n \n  return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \n#include  \n#include  \nusing namespace std; \n \n// a b c d e \n// f g h i j \n// k l m n o  \n// p q r s t \n// u v w x y \n// z \n \n//helper function that takes a map of coordinates and print out the path of instructions \nvoid print_instructions( vector< pair >& ); \n//print out path \nvoid printout(int, int ,int ,int ); \n \n \n \nint main(int argc, char* argv[]) \n{ \n  if(argc!=2) { \n    cout<<\"Please provide one input argument!\"< > map; \n   \n \n  for(string::const_iterator p = word.begin();p!=word.end();p++){ \n    // position from 1-26 \n    int position = int(*p)-int('a')+1; \n    //convert position to X-Y coordiates \n    int X_cor = ceil(double(position)/5.0); \n    int Y_cor = position % 5; \n    if(Y_cor==0) Y_cor=5; \n     \n    map.push_back( make_pair(X_cor,Y_cor) );     \n \n  } \n   \n \n \n  print_instructions(map); \n   \n \n \n  return 0; \n   \n} \n \n \n//helper function that takes a map of coordinates and print out the path of instructions \nvoid print_instructions( vector< pair >& map ) \n{ \n \n  //assume the current cursor is at [1,1] == 'a' \n  printout(map[0].first,1,map[0].second,1); \n \n \n  for(vector< pair >::const_iterator p = map.begin();p!=map.end();p++){ \n    vector< pair >::const_iterator next = p+1; \n    if(next==map.end()) continue; \n    int x_next = next->first; \n    int x =p->first; \n    int y_next = next->second; \n    int y =p->second; \n \n    printout(x_next,x,y_next,y); \n     \n \n  }// loop over all coordinate elements in map \n   \n \n \n \n} \n \n//print out path \nvoid printout(int x_next, int x,int y_next,int y) \n{ \n \n //X direction     \n    if(x_next >= x){ \n      for(int i=0;i< (x_next-x);i++){ \n        cout<<\"D\"; \n      } \n    } \n     \n    else{ \n      for(int i=0;i< (x-x_next);i++){ \n        cout<<\"U\"; \n      } \n    } \n     \n \n    //Y direction \n    if(y_next >= y){ \n      for(int i=0;i< (y_next-y);i++){ \n        cout<<\"R\"; \n      } \n    } \n     \n    else{ \n      for(int i=0;i< (y-y_next);i++){ \n        cout<<\"L\"; \n      } \n    }     \n \n    cout<<\"!\"; \n     \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#python # I do not use any array I simply calculate the location #I I assume we stat in the top left ('a') def cinst(c,p):     nc=ord(c)-97     np=ord(p)-97     y=(nc/5)-(np/5)     x=(nc%5)-(np%5)     print \"c=%s p=%s nc=%d np=%d x=%d y=%d\"%(c,p,nc,np,x,y)     if y>0:         for i in range(abs(y)):             print 'D'     else:         for i in range(abs(y)):             print 'U'     if x>0:         for i in range(abs(x)):             print 'R'     else:         for i in range(abs(x)):             print 'L'     print 'Enter'      def get_word_sec(word):     p='a'     for c in word:         cinst(c,p)         p=c"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Position of a given letter 'w' in the matrix will be:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  #include  #include  using namespace std;   string wordPressed(string input) {     string output;     pair key_pos(0,0);     for(int i=0;i    {         int x = (input[i]-'a')%5;         int y = (input[i]-'a')/5;         int move_x = x-key_pos.first;         if(move_x<0)             output.insert(output.end(), abs(move_x), 'i');         else             if(move_x>0)                output.insert(output.end(), abs(move_x), 'r');          int move_y = y-key_pos.second;         if(move_y<0)             output.insert(output.end(), abs(move_y), 'u');         else             if(move_y>0)                 output.insert(output.end(), abs(move_y), 'd');         output.insert(output.end(), 1, '!');         key_pos = pair(x,y);     }     return output; }   int main() {     string output = wordPressed(\"kkndkkndk\");     cout<}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"string sequence(const string &word, char &cur, int &index) { \n string ret = ??£þ???; \n if (word.length() == 0) \n  return ret; \n if (index >= word.length()) \n  return ret; \n if (cur == word[index]) \n  ret += ??!??; \n else { \n  int curValue = (int)(cur-??a??+1); \n  int destValue = (int)(word[index]-??a??+1); \n  ret += string((curValue/5-destValue/5)>0 ? ??u?? : ??d??, (curValue/5-destValue/5)); \n  ret += string((curValue%5-destValue%5)>0 ? ??l?? : ??r??, (curValue%5-destValue%5)); \n  ret += ??!??; \n } \n cur = word[index]; \n index ++; \n if (index >= word.length()) \n  return ret; \n else return ret+sequence(word, cur, index);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Another similar version with the C code above  #include  #include   void print_path(int src, int dst){         while(src != dst){                 if(src%5 < dst%5){                         src ++;                         putchar('r');                 }                 else if(src/5 < dst/5){                         src +=5;                         putchar('d');                 }                 else if(src%5 > dst%5){                         src --;                         putchar('l');                 }                 else if(src/5 > dst/5){                         src -=5;                         putchar('u');                 }         }          putchar('!');         putchar('\\n');  }  void main(int argc, char *argv[]){          char *x;         if(argc < 2){                 x = \"test\";         }         else{                 x = argv[1];         }         int src = 0;         int dst = 0;         while(*x != '\\0'){                 putchar(*x);                 putchar(':');                 dst = *x - 'a';                 print_path(src, dst);                 src = dst;                 x ++;         }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Looks like a graph, with each letter being a node. And we need to find the path from one node to the other using breadth first search and the nodes being the subsequent letters. Meaning if have a word \"hello\", we need to find the following paths: 1. \"h\" to \"e\" 2. \"e\" to \"l\" 3. \"l\" to \"o\"  Each node may have up to 4 children."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class RemoteLogic { \n \n private char[][] keyBoard = new char[6][5]; \n \n public RemoteLogic(char[][] keyBoard) { \n  this.keyBoard = keyBoard; \n } \n \n// Function writes a word in form of u,d,l,r,! \n public void writeWord(String wordToDisplay) { \n  //last row position of the cursor \n  int lastrowpos = 0; \n  //last column position of the cursor \n  int lastcolpos = 0; \n  for (int i = 0; i <= wordToDisplay.length() - 1; i++) { \n   // Convert each character in the word to ascii code \n   char c = wordToDisplay.charAt(i); \n   //Convert to zero based index for easier handling \n   int cint = (int) c - 97; \n   //Store current row and column position \n   int currrowpos = cint / 5; \n   int currcolpos = cint % 5; \n    \n   moveCursor(currrowpos, currcolpos, lastrowpos, lastcolpos); \n \n   lastrowpos = currrowpos; \n   lastcolpos = currcolpos; \n   System.out.println(\"!\"); \n \n  } \n \n } \n  \n //Gets the current and the last position of the cursor and moves the cursor accordingly \n private void moveCursor(int currrowpos, int currcolpos, int lastrowpos, \n   int lastcolpos) { \n  //If on the same character , just press enter \n  if (currcolpos == lastcolpos && currrowpos == lastrowpos) { \n   System.out.println(\"!\"); \n  } \n   \n  //first move within a column \n  if (currcolpos < lastcolpos) { \n   printMoves(lastcolpos - currcolpos, \"l\"); \n  } \n  //then move between rows \n  if (currrowpos < lastrowpos) { \n   printMoves(lastrowpos - currrowpos, \"u\"); \n  } \n   \n  if (currcolpos > lastcolpos) { \n   printMoves(currcolpos - lastcolpos, \"r\"); \n  } \n \n  if (currrowpos > lastrowpos) { \n   printMoves(currrowpos - lastrowpos, \"d\"); \n  } \n } \n  \n //Print number of moves  \n private void printMoves(int i, String string) { \n  for (int x = 1; x <= i; x++) { \n   System.out.print(string); \n  } \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"string getSequence(string target){ \n    int curRow = 0, curCol = 0; \n    string ans = \"\"; \n    for(int i=0; i row){ \n  curRow--; \n  ans += 'u'; \n     }else{ \n  curRow++; \n  ans += 'd'; \n     } \n } \n while(curCol != col){ \n     if(curCol > col){ \n  curCol--; \n  ans += 'l'; \n     }else{ \n  curCol++; \n  ans += 'r'; \n     }   \n } \n ans += '!'; \n    } \n    return ans; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Remote \n    { \n        private StringBuilder sb; \n \n        public string GetPatternForWord(string word) \n        { \n            sb = new StringBuilder(); \n            char currentChar = 'a';  // begin here \n            foreach (char c in word) \n            { \n                GetPatternForChar(lineNo(currentChar), currentChar, lineNo(c), c); \n \n                // by this time the cursor should be at the destination \n                currentChar = c; \n            } \n \n            return sb.ToString(); \n        } \n \n        private void GetPatternForChar(int currLineNo, char currChar, int destLineNo, char destChar) \n        { \n            if (currChar == destChar) \n            { \n                return; \n            } \n \n            if (destLineNo == currLineNo) \n            { \n                if (currChar < destChar) \n                { \n                    sb.Append('r'); \n                    GetPatternForChar(currLineNo, next(currChar), destLineNo, destChar); \n                } \n                else \n                { \n                    sb.Append('l'); \n                    GetPatternForChar(currLineNo, prev(currChar), destLineNo, destChar); \n                } \n            } \n            else if (destLineNo > currLineNo) \n            { \n                sb.Append('d'); \n                GetPatternForChar(currLineNo + 1, down(currChar), destLineNo, destChar); \n            } \n            else \n            { \n                sb.Append('u'); \n                GetPatternForChar(currLineNo - 1, up(currChar), destLineNo, destChar); \n            } \n        } \n \n        char prev(char c) \n        { \n            return (char)(c - 1); \n        } \n \n        char next(char c) \n        { \n            return (char)(c + 1); \n        } \n \n        char up(char c) \n        { \n            return (char)(c - 5); \n        } \n \n        char down(char c) \n        { \n            if (c > 't') \n            { \n                return 'z'; \n            } \n \n            return (char)(c + 5); \n        } \n \n        int lineNo(char c) \n        { \n            if (c <= 'e') \n                return 1; \n \n            if (c <= 'j') \n                return 2; \n \n            if (c <= 'o') \n                return 3; \n \n            if (c <= 't') \n                return 4; \n \n            if (c <= 'y') \n                return 5; \n \n            return 6; \n        } \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n#include \n#include \n \nusing std::cout; \nusing std::endl; \nusing std::map; \nusing std::string; \n \nvoid getIndex(int n, int& a, int& b) { \n a = n/5; \n b = n - 5*a; \n} \n \nstring getKeyStrokes(const string& s) { \n \n if(s.empty()) \n  return s; \n  \n static map keyboard; \n keyboard['a'] = 0; keyboard['b'] = 1; keyboard['c'] = 2; \n keyboard['d'] = 3; keyboard['e'] = 4; keyboard['f'] = 5; \n keyboard['g'] = 6; keyboard['h'] = 7; keyboard['i'] = 8; \n keyboard['j'] = 9; keyboard['k'] = 10; keyboard['l'] = 11; \n keyboard['m'] = 12; keyboard['n'] = 13; keyboard['o'] = 14; \n keyboard['p'] = 15; keyboard['q'] = 16; keyboard['r'] = 17; \n keyboard['s'] = 18; keyboard['t'] = 19; keyboard['u'] = 20; \n keyboard['v'] = 21; keyboard['w'] = 22; keyboard['x'] = 23; \n keyboard['y'] = 24; keyboard['z'] = 25; \n  \n string ret; \n // go from (a1, b1) to (a2, b2) \n int a1, b1, a2, b2, d1, d2; \n // assume the remote starts at the letter \"a\" \n getIndex(keyboard['a'], a1, b1); \n for(string::size_type k = 0; k != s.size(); ++k) { \n  getIndex(keyboard[s[k]], a2, b2); \n  d1 = a2 - a1; \n  d2 = b2 - b1; \n  if(d2 < 0) \n   ret += string(-d2, 'l'); \n  if(d1 > 0) \n   ret += string(d1, 'd'); \n  if(d1 < 0) \n   ret += string(-d1, 'u'); \n  if(d2 > 0) \n   ret += string(d2, 'r'); \n  ret += '!';  \n  a1 = a2; b1 = b2; \n } \n return ret; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I thin the question is not very difficult, and here is the code and it is self-explanatory:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Given the map is 6*5 , given any character , you can find out which row/col it resides in, in O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Solution(){   public String getAction(String str){     int len = str.length();     str = str.toLowerCase();     StringBuffer buf = new StringBuffer();     int x = 0 , y = 0;     for(int i = 0 ; i < len ; i++){         int t = str.charAt(i) - 'a';         int row = t/5;         int col = t%5;         while(row > y) {           buf.append('u');           y++;         }         while(row < y) {           buf.append('d');           y--;         }         while(col > x) {           buf.append('r');           x++;         }         while(col < x) {           buf.append('l');           x--;         }         buf.append('!');     }     return buf.toString();   } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def get_path(ipstr, width): \n prev = None \n for i in ipstr: \n  if prev: \n   prev_pos = get_postion(prev, width) \n   current_pos = get_postion(i, width) \n   rows_moved = current_pos[0] - prev_pos[0] \n   cols_moved = current_pos[1] - prev_pos[1] \n   output_str = '' \n   if rows_moved: \n    move_str = '%d move(s) up' % abs(rows_moved) if rows_moved < 0 else '%d move(s) down' % (rows_moved) \n    output_str = output_str + move_str \n   if cols_moved: \n    move_str = ', %d move(s) left' % abs(cols_moved) if cols_moved < 0 else ', %d move(s) right' % (cols_moved) \n    output_str = output_str + move_str \n   print output_str \n  prev = i \n \ndef get_postion(ch, width): \n lin_pos = 25 - (ord('z') - ord(ch)) \n row = lin_pos // width \n col = lin_pos % width \n return (row, col) \n \nSample Usage: \n \n>>> get_path('papajohns', 5) \n \n3 moves up \n3 moves down \n3 moves up \n1 moves down, 4 moves right \n1 moves down \n1 moves up, 2 moves left \n1 moves down, 1 moves right \n1 moves down"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"{ \nstring s; \nchar c[6][5]={{a,b,c,d,e} \n       {f,g,h,i,j} \n       {k,l,m,n,o} \n       {p,q,r,s,t} \n       {v,u,w,x,y} \n       {z}} \n s=\"a\";//present at 0,0 position \n char c; \nstatic int i=0,j=0; \n system.out.println(\"press the keys u d r l /n\"); \n scanner s=new scanner(syste.in); \n c=s.next(); \n        while(c!=\"/n\")//press enter loop will terminate \n { \n  switch(c) \n  { \n   case 'u':up(); \n     break; \n   case 'd':down(); \n     break; \n   case 'r':right(); \n     break; \n   case 'l':left(); \n     break; \n   default: \n    break; \n  } \n } \n//select the upper element of the current position \npublic void up() \n{ \n if(i==0) \n { \n  i=5; \n`  s=s+a[i][j]; \n } \n else \n { \n  i=i-1; \n  s=s+a[i][j]; \n } \n} \n//select the below element of the current position \npublic void down() \n{ \n if(i==5) \n { \n  i=0; \n  s=s+a[i][j]; \n } \n else \n { \n  i=i+1; \n  s=s+a[i][j]; \n } \n} \n//select the right side element of the current position \npublic void rigth() \n \n{ \n if(j==4) \n { \n  j=0; \n  s=s+a[i][j]; \n } \n else \n { \n  j=j+1; \n  s=s+a[i][j]; \n } \n} \n//select the left side element of the current element \npublic void left() \n{ \n if(j==0) \n { \n  j=4; \n  s=s+a[i][j]; \n } \n else \n { \n  j=j-1; \n  s=s+a[i][j]; \n } \n} \nsystem.out.println(\"the selcted string is :%s\",s);//it will print total u selected string \n} \no/p: \nstrating position at 'a' \nu u l u l d r  enter \nstring is:\"azvytsxy\""}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15549711","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"29","title":"given sorted int[] A, int[] B. How would you find the maiden that would have been if both were combined to one big sorted array? Use divide and conqure recurssion. please write method \"GetMutualMaiden\" and explaint it's time and space complexity","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"10","title":"Do you mean median?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"Assumption before solving the problem: Definition of Median: if the size of array is odd, such as {1, 2, 3, 4, 5}, 3 is the median number; if the size of array is even, such as {1, 2, 3, 4, 5, 6}, I will assume that either 3 or 4 is median.  Basic Idea:  suppose we have two arrays: A = {2, 4, 6, 8, 10} B = {1, 3, 5, 7, 9, 11, 13}  We compare the two median number, Median(A) = 6, and Median(B) = 7. since Median(A) < Median(B), we can remove the first half of A, that is {2, 4}, and the second half of B, that is {9, 11, 13}, because the mutual median number cannot be in these two parts. In order to keep the mutual median number unchanged, in this case, we can remove {2, 4} and {11, 13}. As we remove two elements that are less than mutual median and two elements that are larger than mutual median, the original mutual median will remain same.  So that after removal, A and B changed to be: A = {6, 8, 10} B = {1, 3, 5, 7, 9}  We can continue using this method until we find the mutual median number, below is the implementation in Java (may have some small bugs in the code)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"JAVA: The code is a bit clogged because I took care of the scenario where you need to take the average of both middle values if you get an even number of integers when merging both arrays. Any ways to make it a bit cleaner? (Aside from putting the code replicate in another function), something actually clever..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algorithm GetMutualMedian(A[m], B[n])  Input: sorted array A[m] and B[n] Output: return the median of the combined array C[m+n]  if m=1, n=1 return A[m] or B[n]  if A[m/2] < B[n/2]: upper half of B is larger than lower half of B and lower half of A, thus upper half of B    should be larger than (m+n)/2 elements, recursively call GetMutualMedian(A[m], B[1-n/2])   if A[m/2] > B[n/2]: upper half of A is larger than lower half of A and lower half of B, thus upper half of A    should be larger than (m+n)/2 elements, recursively call GetMutualMedian(A[1-m/2], B[n])  if A[m/2] == B[n/2]: return A[m/2] or B[n/2]   Time complexity = log(m)+log(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A little more challenging questions would look like this:  You are given two sorted lists of size m and n. Give an O(log m + log n) time algorithm for computing the kth smallest element in the union of the two lists."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First and foremost, I would try to find the Nth element among the lists, not the medians, and then I'd treat the median as a special case.  If constant time you can determine if Amax < Bmin or Bmax < Amin, and then you can find the Nth element in constant time as well.  If the size of both lists are small (say < 10), then simply merge them to find the Nth element.  If we have two large overlapping lists, then consider where the Nth element could be.  Suppose size(A) = 13, size(B) = 30, and N=19.  It's possible for any element of A to be the 19th element among the two lists, but it's clear that the first 6 elements of B have to be less than the 19th element, since at max 12 elements of A could be less than the 6th element of B. So we can recurse on finding the 13th element among all A and among 24 elements of B.  For small values of N you can trim the larger list on the right using similar reasoning.  This problem is far from trivial to do efficiently, and it has lots of fiddly cases to deal with, but it's definitely amenable to some level of divide and conquer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I'm not sure this captures every edge case, but it's a sketch of divide-and-conquer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int GetMutualMedian(int *A, int *B, int n, int m, int pos) { \n  \nif (n == -1) return B[pos]; \nif (m == -1) return A[pos]; \n \nint amid = pos/2 > n ? n : pos/2; \n int bmid = pos/2 > m ? m : pos/2; \n if (A[amid] > B[bmid]) { \n  if (bmid == m) return GetMutualMedian(A, B, n, -1, pos-bmid); \n  else return GetMutualMedian(A, B+bmid, amid, m-bmid, pos/2); \n} \n else if (A[amid] < B[bmid]) { \n  if (amid == n) return GetMutualMedian(A, B, -1, m, pos-amid); \n  else return GetMutualMedian(A+amid, B, n-amid, bmid, pos/2); \n} \n else { \n  if (n >= pos/2 && m >= pos/2) return A[amid]; \n  else if (pos/2 > n) return GetMutualMedian(A, B, -1, m, pos-n); \n  else (pos/2 > m) return GetMutualMedian(A, B, n, -1, pos-m); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My answer is wrong. I assume b[0] > a[m-2]. Anyway, keep it. my solution is O(1). assume a has m elements, b has n elements.  assume m <= n. The question is to find the (m+n)/2 in the combined array, (m+n)/2 is bigger than m.The miracle happens when we compare the b[(m+n)/2 - m ] and a[m-1]:  if b[(m+n)/2-m] >= a[m-1] return b[(m+n)/2 - m]; else   return a[m-1] >= b[(m+n)/2-m+1] ? b[(m+n)/2-m+1] : a[m-1];  for example  a[] = { 1, 2, 5, 9} b[] = { 8, 13 ,15 ,20, 21} we want c[4] in combined array c. compare b[0] = 8 and a[3] = 9 b[0] < a[3] then compare b[1] and a[3], b[1] > a[3] then the result c[4] = a[3] = 9."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Divide-and-conquer algorithms don't need to divide the problem in half each time. From chapter 4 (Divide-and-Conquer) of CLR:  \"Subproblems are not necessarily constrained to being a constant fraction of the original problem size. For example, a recursive version of linear search would create just one subproblem containing only one element fewer than the original problem.\"  This divide-and-conquer algorithm simply pops the smaller value off the head of one of the lists and recurses on the rest of the problem.  Pseudocode:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int findKSmallest(int a[], int n, int b[], int m, int k) \n    { \n             if (n > m) return finKSmallest(b, m, a, n); \n             if (n==0) return b[k-1];  \n             if (k==1) return min(a[0], b[0]); \n             int na = min(n, k/2); \n             int nb = m-na; \n             if (a[na-1] <= b[nb-1]) return findKSmallest(a, n-na, b, m, k-na); \n             else return findKSmallest(a, n, b, m-nb, k-nb);  \n              \n    } \n    int median(int a[], int n, int b[], int m) \n    { \n             int size = n+m; \n             if (size&1) return findKSmallest(a, n, b, m, size/2+1); \n             else return (findKSmallest(a, n, b, m, size/2+1) + findKSmallest(a, n, b, m, size/2) ; )/2.0; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Isn't the problem too trivial if the arrays are already sorted? It sounds like you only to apply a fraction of what is needed in the standard merge sort algorithm. Basically, you could retrieve the total number of element and divide that by 2, then you can do the simple loop where as long as you haven't reached the end of your left and right array you increment the pointer on the array on which the current element is the lowest, when you have counted to total size / 2, return that value. That is, if you are looking for the Median..."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15555705","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"31","title":"Sort the input character array based on the dictionary given.  For eg:, If input word is ??£þSHEEP??£þ, sorting will make it as ??£þEEHPS??£þ.  But in the dictionary, E may not be at first. As per the dictionary, if P is first, S followed and E later and finally H.  Then sorted array is ??£þPSEEH??£þ.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"Java: ====================="},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"string sort_by_dict(const string & str, const string & dict) {  int map[256] = {0};  for(int i = 0; i < str.length(); i++)   map[str[i]]++;  string result = str;  int index = 0;  for(int i = 0; i < dict.length(); i++)  {   char c = dict[i];   while(map[c] > 0)   {    result[index++] = c;    map[c] --;   }  }  return result; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"A very elegant way of doing this is to substitute 'a' for the letter that comes first as per the dictionary, 'b' for the letter that comes second, and so on. Then sort normally by lexicographical order (possibly using an existing library). Then, reverse the letter substitution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int array [26]; //assuming we are only using characters...this can be easily extended to any character for(int i=0;i int shiftValue = str.charAt(i) - 'a';  array[shiftValue] +=1; } //assuming dictonary is also an String and is sorted according to the rule for(int i=0;i int findValue = dict.charAt(i) - 'a'  if (array[findValue] > 0){   syso ( (char) (array[findValue] + 'a');  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Better approach would be to create a two dimensional ordering table from dictionary, and use that table for comparing two characters when sorting.  For example      a    b ----------- a | 0    1 b | 0    0 when compare(a,b) is required, we will return the corresponding value (1 in this case) to the sorting fuction."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  using namespace std;   int main() {   //sort 26 chats from A-Z using \"counting sort\"   //time complexity O(n)      string input(\"SHEEP\");   string ruler(\"PSEH\");   vector C(256,0), C_prime(256,0);//use ASCII code as index for counting array   string  result=input;      //create counting auxilliary array called \"C\", it counts frequencies for each char   for(string::const_iterator p=input.begin();p!=input.end();p++){     C[int(*p)]++;   }      //convert C to C_prime (Auxilliary array)   int count=0;   for(string::const_iterator p=ruler.begin();p!=ruler.end();p++ ){     count += C[int(*p)];     C_prime[int(*p)]=count;   }      // input --> C_prime --> result mapping   for(string::const_iterator p = input.end()-1;p>=input.begin();p--){     result[C_prime[int(*p)]-1] = *p;     C_prime[int(*p)]--;   }      // output the sorted array  : \"PSEEH\"   cout<<   return 0;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My idea is that we just use modified count sorting algorithm: Just change the accumulating processing according to the order of dictionary, not by the alphabet order. The following code would assume the string is 'a'-'z' and 'A'-'Z', and the Dict should contains all the alphabet char existing in the input strings.  Here is the code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"inputString = 'SHEEP' \nsortDict = 'PSHE' \n \nfor sortChar in sortDict: \n for char in inputString: \n  if char == sortChar: \n   print char"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why cant we just reuse normal sorting and overload the comparator to compare according to the new dictionary ??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In C#"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#define SIZEOF(a) sizeof(a) / sizeof((a)[0]) \n \nchar order[26]; \n \nvoid generateOrder(char dict[]) \n{ \n    int i=0; \n    for(i=0;i<26;i++) \n    { \n        order[ dict[i] - 'a' ] = i; \n    } \n} \nint position(char x) \n{ \n    return order[x-'a']; \n} \nint compare(void *a,void *b) \n{ \n    return position( *(char *)a) -  position (*(char *)b ); \n} \nint main(void) { \n     \n char dict[26] = {      'p','a','b','d','e', \n                           'f','g','h','i','j', \n                           'k','l','m','n','o', \n                           'c','q','r','s','t', \n                           'u','v','w','x','y', \n                           'z'}; \n  \n     \n    generateOrder(dict); \n     \n    char str[6] = \"sheep\"; \n    qsort(str,SIZEOF(str),sizeof(char),compare); \n    printf(\"%s\",str); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void sortString(string &word, const string &dictionary) { \n \n map m; \n for (int i=0; i::iterator it = map.find(word[i]); \n if (it == map.end()) word.insert(pair(word[i], 1)); \n else it->second += 1; \n} \nint k = 0; \nfor (int i=0;i::iterator it = map.find(dictionary[i]); \n if (it != map.end()) { \n  word.replace(word.begin()+k, it->second, dictionary[i]); \n  k += it->second; \n} \n} \nreturn; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"inputString = 'SHEEP' \nsortDict = 'PSHE' \n \nfrom collections import Counter \n \ncount_str = Counter(inputString) \nb='' \nfor c in sortDict: \n b = count_str[c] * c \n \nreturn b"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Test {    public static void main(String[] args){   String input = \"sheep\";      char[] arr = input.toCharArray();    char temp;    for(int i=0;i     for(int j=i+1;j       if(arr[i] > arr[j]){          temp = arr[i];     arr[i] = arr[j];     arr[j] = temp;         }   }  }  for(int i=0;i System.out.println(arr[i]);  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What do you guys think about this: public String sortByString(String input, String sortBy) {  if (input == null)   return \"\";//Maybe throw exception here?  if (sortBy == null)   return \"\";//Maybe throw exception  HashMap hashMap = new HashMap();  String stringToReturn = \"\";  for (int i = 0; i < input.length(); i++) {   if (hashMap.get(input[i]))//already in so increment the value    hashMap.put(input[i], hashMap.get(input[i]) + 1);   else    hashMap.put(input[i], 1);  }  for (int i = 0; i < sortBy.length(); i++) {   if (hashSet.get(sortBy[i]))    for (int j = 0; j < hashSet.get(sortBy[i]); j++)     stringToReturn += sortBy[i];  }  return stringToReturn; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public String sortByString(String input, String sortBy) { \n if (input == null) \n  return \"\";//Maybe throw exception here? \n if (sortBy == null) \n  return \"\";//Maybe throw exception \n HashMap hashMap = new HashMap(); \n String stringToReturn = \"\"; \n for (int i = 0; i < input.length(); i++) { \n  if (hashMap.get(input[i]))//already in so increment the value \n   hashMap.put(input[i], hashMap.get(input[i]) + 1); \n  else \n   hashMap.put(input[i], 1); \n } \n for (int i = 0; i < sortBy.length(); i++) { \n  if (hashSet.get(sortBy[i])) \n   for (int j = 0; j < hashSet.get(sortBy[i]); j++) \n    stringToReturn += sortBy[i]; \n } \n return stringToReturn; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15523775","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"28","title":"how would you implement a secondary sorting. Meaning sorting by Category A, and then sub sorting by category B?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"Three approaches come to mind. 1) Sort on A, then scan the list for runs of elements with the same value for A, then sort each sublist for field B. 2) Sort on A/B simultaneously by using a compare function or key function that uses both fields. 3) Sort the list on B, then stable-sort the list on A.  A nice feature of approach #1 is that you can do it lazily, i.e. only sort the sublists when the second field is queried."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Maybe this (in python):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Bucket sort by category A and the use any sorting mechanism for each bucket."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Use any stable sort that would be our easiest bet. Merge sort."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I think this is simple?? Why do we need to consider stable sort or blablabla..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You mean let's say given:  {(4, 2), (3, 3), (3, 2)}  sort by using A  without using B gives you: {(3, 3), (3,2), (4,2)} and using A and B gives you: {(3,2), (3, 3), (4, 2)}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sort on B first and then sort on A, it is a radix sorting"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package com; \n \nimport java.util.Comparator; \nimport java.util.List; \n \npublic class MultiSort implements Comparator{ \n \n private List> comparators; \n public  MultiSort(List> comparators){ \n  this.comparators = comparators; \n } \n  \n @Override \n public int compare(T t1, T t2) { \n  int i=0; \n  int r=0; \n  Comparator c; \n  while(i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Isn't it bucket sort - en.wikipedia.org/wiki/Bucket_sort ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"stable sort .. stable_sort(a.begin(), a.end(), ACmp); stable_sort(a.begin(), a.end(), BCmp);   or  bool operator(const Item& x, const Item& y) {          if (x.A == y.A)                     return x.B < y.B;          return x.A < y.A;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; \nimport java.util.Arrays; \nimport java.util.Comparator; \nimport java.util.List; \n \n \nclass MultiSort implements Comparator>{ \n \n private List>> comparators; \n public  MultiSort(List>> comparators){ \n  this.comparators = comparators; \n } \n  \n @Override \n public int compare(Item t1, Item t2) { \n  // Compare surnames \n  boolean ret = t1.a.equals( t2.a ); \n  if( ret == true ){ //Compare givennames if surnames are the same \n  ret = t1.b.equals( t2.b ); \n  } \n  if(ret) \n   return 0; \n  else \n   return -1; \n } \n \n \n} \n \nclass Item \n{ \n T a; \n T b; \n  \n public Item(T a, T b) \n { \n  this.a = a; \n  this.b = b; \n } \n  \n public String toString() \n { \n  return \"(\" + a + \", \" + b  + \")\"; \n } \n} \n \npublic class Subsorting { \n public static void main(String[] args) \n { \n  //List> list = new ArrayList>();//{(4, 2), (3, 3), (3, 2)} \n   \n  Item item1 = new Item (4, 2); \n  Item  item2 = new Item (3, 3); \n  Item  item3 = new Item (3, 2); \n   \n  //list.add(item1); \n  //list.add(item2); \n  //list.add(item3); \n   \n  Item[] items = {item1, item2, item3}; \n   \n  Arrays.sort(items, new MultiSort(list)); \n   \n  for(Item item : items) \n   System.out.println(item.toString()); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Sort lexicographic by (Category A, Category B)."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15519765","download_status":"DOWNLOAD_DONE","votes":"3","answersCount":"60","title":"Given an array A of N integers, we draw N discs in a 2D plane such that the I-th disc is centered on (0,I) and has a radius of A[I]. We say that the J-th disc and K-th disc intersect if J ?? K and J-th and K-th discs have at least one common point. Write a function: int number_of_disc_intersections(int A[], int N); that, given an array A describing N discs as explained above, returns the number of pairs of intersecting discs. For example, given N=6 and: A[0] = 1  A[1] = 5  A[2] = 2  A[3] = 1  A[4] = 4  A[5] = 0   intersecting discs appear in eleven pairs of elements: 0 and 1, 0 and 2, 0 and 4, 1 and 2, 1 and 3, 1 and 4, 1 and 5, 2 and 3, 2 and 4, 3 and 4, 4 and 5. so the function should return 11. The function should return ?1 if the number of intersecting pairs exceeds 10,000,000. Assume that: N is an integer within the range [0..10,000,000]; each element of array A is an integer within the range [0..2147483647]. Complexity: expected worst-case time complexity is O(N*log(N)); expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments). Elements of input arrays can be modified.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"9","title":"rearrange them in the format of interval: [-1,1] [-4,6] ... then the problem becomes checking overlapping intervals. just sort them on the base of starting point and binary search each end point in the sorted list"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"This solution occupies O(n) extra space and works in O(logn), Does it sound correct?:  I write down the max and min points of the circles and store them in an array using a data structure to identify the index of each point. Then, I sort them in nlogn.   Next I iterate through the array keeping note of circle starts and ends using a hashmap and whenver a circle ends, all the circles which are enveloping it add to the number of intersections. Hence, I add them up."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"1. merge start / end of all intervals in ONE array, keeping a flag that marks whether it's a start or an end. 2. sort it. 3. scan the sorted array by updating two variables, i for open intervals and c for intersection count.    - if we meet a start point, count+=i and i++    - if we meet an end point, i--.  There you go.  For the example in the question, we get a sorted array of the intervals and scan/update like this"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"namespace ConsoleApplication1 \n{ \n    class Program \n    { \n \n        public class Interval : IComparable \n        { \n            public int start; \n            public int end; \n            public Interval(int start, int end) \n            { \n                this.start = start; \n                this.end = end; \n            } \n \n            public int CompareTo(Interval interval) \n            { \n                return this.start.CompareTo(interval.start); \n            } \n        } \n \n \n        public static Interval[] IntArrayToIntervalArray(int[] A) \n        { \n            Interval[] newArray = new Interval[A.Length]; \n            for (int i = 0; i < A.Length; i++) \n            { \n                newArray[i] = new Interval(i - A[i], i + A[i]); \n            } \n \n            Array.Sort(newArray); \n            return newArray; \n        } \n \n        public static int NumberOfDiscIntersections(int[] A) \n        { \n            Interval[] newArray = IntArrayToIntervalArray(A); \n            int count = 0; \n            for (int i = 0; i < A.Length; i++) \n            { \n                count += BinarySearchGetNumberOfIntersectingIntervals(newArray, i + 1, A.Length - 1, newArray[i]); \n            } \n            return count; \n        } \n \n        public static int BinarySearchGetNumberOfIntersectingIntervals(Interval[] A, int p, int r, Interval Int) \n        { \n            if (p <= r) \n            { \n                decimal x = (p + r) / 2; \n                int q = (int)Math.Floor(x); \n                if (A[(int)q].start < Int.end) \n                { \n                    return (q - p + 1) + BinarySearchGetNumberOfIntersectingIntervals(A, q + 1, r, Int); \n                } \n            } \n \n            return 0; \n \n        } \n \n \n        static void Main(string[] args) \n        { \n            int[] A = new int[] {1,5,2,1,4,0}; \n \n            Console.WriteLine(NumberOfDiscIntersections(A)); \n            Console.ReadLine(); \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How can the expected complexity (assuming the expectation is taken over the draw of random numbers in your algorithm and not some sort of a random draw of discs) be O(n log n), when the size of the output for some trivial cases is O(n^2)?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Program:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use stl, and it is much more convenient:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use Interval trees. Search the page on Interval trees on Wikipedia."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My idea: a> Build an array containing left point and right point of each pixel. Each left point or right point consume on item in the array. Here is some extra trick, shift the original (left, right) ==> (left*2-1, right*2). The extra logic is making sure we can sort easily for the case that left value of some point is the same right value of some point (or even same point, in which its range is zero), in which case we need to be sure left value should be put before the right value(single point contact is till contact).  And also we need to know if it is left /right value according to its value, easily.  b> merge sort the array. We need to use merge sort because worse case of quicksort is bigger than O(nlogn). The array's len is 2N, (left +right), so the merge sort will have O(2NLOG(2N)), still O(NLOGN) c> Go through the sorted array, if it is left value, which means we found start of a new disk, so we can add preexisted disk number as total number of overlappled pair number and then increased of preexisted disk number. If it is right value, which means we found end of a new disk, we need to delete the preexisted disk number.  d> This logic bellow does not care the number limiting issue. (such 10,000,000).  Some extra logic could be added for that.  e> Time complexity is O(NLOGN)+2N , still O(NLOGN). Space complexity, 2N for array, N for mergeSort, so still O(N)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I like zyfo2's answer but it's a little terse so I'll offer my elaboration:  1. We are given a list of discs already sorted by the location of the center of disc. Create a second list of discs that is sorted by the location of the top of the disc. If we use mergesort, this operation will take O(N log N) in the worst case and O(N) space complexity in the worst case.  2. Iterate through the entire given list of discs. For every disc i, search the second list (sorted by top of disc) for the first disc whose top is located at or below the center of disc i. This is the first intersecting disk.  3. Then search for the last disc whose top is located at or above the bottom of disc i (computed as i+A[i]). This is the last intersecting disc. Both searches take O(log N) so we haven't increased the complexity.  4. The difference between the first and last disc (plus one) is the number of discs intersecting with disc i. Add this to a running total.  When we reach the end of the list, the running total will contain the solution. Note that since we are only looking for discs below disc i, we'll never count the same intersection twice."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's my solution:  1. Sort the circles by their bottom point (center - radius). 2. Initialize a min-heap that will be used to hold circles with their top point (center+radius) as key. 3. For each circle in the sorted list, compare its bottom value with the min circle on the heap, and pop from the heap all circles that their top point is lower than the current circle's bottom. The rmaining circles in the heap intersect the current circle, since their bottom point is lower than the current circle's bottom point, and their point is higher than the current circles bottom. So add the size of the heap to the count of intersecting circles. Push the current circle onto the heap. 4. Repeat step 3 for all the circles."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's my solution:  1. Sort the circles by their bottom point (center - radius).  2. Initialize a min-heap that will be used to hold circles with their top point (center+radius) as key.  3. For each circle in the sorted list, compare its bottom value with the min circle on the heap, and pop from the heap all circles that their top point is lower than the current circle's bottom. The rmaining circles in the heap intersect the current circle, since their bottom point is lower than the current circle's bottom point, and their point is higher than the current circles bottom. So add the size of the heap to the count of intersecting circles. Push the current circle onto the heap.  4. Repeat step 3 for all the circles."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I got a similar question on my Google interview... and blew it. I wish I had spent more time solving this problem. Ironically, I figured out the optimal solution the next day while walking my dog. It uses DP and goes like this:  1. Sort the discs by top 2. Keep a \"meta-disc\" in memory and initialize it to the first disc in the sorted list. The meta-disc represents the preceding series of discs that overlap. 3. Iterate through the sorted list, from disc 2 to disc n. 4. If the top of disc i is below the bottom of the meta disc (i.e. we found a gap) re-initialize the meta-disc to disc i and proceed to the next disc. 5. However if the top of disc i is within the meta-disc, it must overlap with one of the preceding discs and we increment the overlap count. 6. Also, if the bottom of disc i is below the bottom of the meta-disc, enlarge the meta-disc by setting it's bottom to the bottom of disc i.  The meta-disc is our DP subproblem-holder. It saves us from checking every disc or searching for particular discs.  The complexity is O(n log n) due to the sort. The iterations take O(n) and don't require a binary search so each iteration takes O(1)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how about this? Create another array of size N. Now for each point from 0 to N, find out how many discs reach that point. (So we init the array to 0 and for all discs d, we increment values from arr[d] to arr[d-radius(d)] and arr[d] to arr[d+radius(d)]. Now the number of overlaps at any point p = arr[p]C2 (arr[p] Choose 2)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can some one explain how A[0] and A[1] intersect?? A[0] spans from (-1,1), and A[1] goes from (-4,6). How can these two intersect when A[0] is completely inside A[1]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Two Arrays, one with starting, one with ending points. Sort both O N * log N Iterate on both count the number of intersections O N.    Uses exactly O(N) extra memory and O (n * log n ) computationally."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Sounds like a programming contest question. Is it really google onsite question?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This solution has some drawbacks as mentioned by others. So, I remove it no to confuse anyone."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"# include  \n# include  \n \nint max(int a , int b){ \n    if (a>=b) return a; \n    else return b; \n} \n \n \nint main(){ \n    int inp[7] = {2,4,0,1,6,5,3}; \n    int i,j, ctr=0; \n    for(i = 0; i<=6; i++) \n       for(j = i+1; j<=6; j++) \n          if( max(inp[i], inp[j]) >= (j-i))  \n                ctr++; \n \n               \n    printf(\"%d\", ctr);  \n    getch(); \n }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15503772","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"5","title":"Write a method that generates a random sequence of numbers of specific percentages","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Seems straight forward to me.  Fill an array with your \"specific\" percentages, then pick uniformly across the elements of the array.  Or maybe the interviewer is just asking you to take a basic random number generator and force the output into the percentage range [0.0-1.0] or [0 - 100].  However, the problem is that there are multiple possible random number generators (drand48, rand, etc.), so you may have to assume about the range or the output.  Yet, you can discuss it generally in terms of the _initial_ and _final_ elements of the range (rand()-init)/(final-init).  (Multiplied by 100.0 if you want the second range.)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Do you mean to say that you want to generate random samples with a given distribution?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Could you elaborate Question?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"I guess this is the case of knuth shuffle."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15519757","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"19","title":"The diameter of a tree is the number of nodes on the longest path between two leaves in the tree. The diagram below shows a tree with diameter nine, the leaves that form the ends of a longest path are shaded (note that there is more than one path in each tree of length nine, but no path longer than nine nodes).    In particular, note that the diameter of a tree T is the largest of the following quantities:  the diameter of T's left subtree the diameter of T's right subtree the longest path between leaves that goes through the root of T  Given the root node of the tree, return the diameter of the tree","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Write a function that returns a tuple/struct of two values for a given tree.  The first value is the height, and the second value is the diameter length.  The terminating case is a an empty tree, which returns 0,0.  The recursive calculations are these:  height = max(height(left), height(left)) + 1 diameter = max(diameter(left), diameter(right), height(left)+height(right)+1)  To fully complete the exercise, have a helper function that calls the other function and returns only the diameter as the final answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"#include  using namespace std; #include  #include     /* A binary tree node has data, pointer to left child    and a pointer to right child */  class node { public:   node(int dat){ data = dat; left = NULL; right=NULL; }   int data;   node* left;   node* right; };      /* returns max of two integers */ int max(int a, int b);   /* function to Compute height of a tree. */ int height(node* node);   /* Function to get diameter of a binary tree */ int diameter(node * tree) {    /* base case where tree is empty */    if (tree == 0) return 0;     /* get the height of left and right sub-trees */    int lheight = height(tree->left);    int rheight = height(tree->right);      /* get the diameter of left and right sub-trees */    int ldiameter = diameter(tree->left);    int rdiameter = diameter(tree->right);     /* Return max of following three    1) Diameter of left subtree    2) Diameter of right subtree    3) Height of left subtree + height of right subtree + 1 */      cout<< lheight + rheight + 1 <<\" \"<< ldiameter << \" \"<< rdiameter <         return max(lheight + rheight + 1, max(ldiameter, rdiameter)); }   /* UTILITY FUNCTIONS TO TEST diameter() FUNCTION */   /*  The function Compute the \"height\" of a tree. Height is the     number f nodes along the longest path from the root node     down to the farthest leaf node.*/ int height(node* node) {   /* base case tree is empty */   if(node == NULL) return 0;       /* If tree is not empty then height = 1 + max of left       height and right heights */     return 1 + max(height(node->left), height(node->right)); }  /* Helper function that allocates a new node with the    given data and NULL left and right pointers. */  /* returns maximum of two integers */ int max(int a, int b) {   return (a >= b)? a: b; }      /* Driver program to test above functions*/ int main() {     /* Constructed binary tree is             1           /   \\         2      3       /  \\     4     5    /      \\   6       7   */   node *root = new node(1);   root->left        = new node(2);   root->right       = new node(3);   root->left->left  = new node(4);   root->left->right = new node(5);   root->left->left->left  = new node(6);   root->left->right->right = new node(7);      printf(\"Diameter of the given binary tree is %d\\n\", diameter(root));    cout<< \"node 1 has height \"<< height(root)<       return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"{cs.duke. edu/courses/spring00/cps100/assign/trees/diameter.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just iterate through all the nodes   for each node find x = height of right subtree + height of left subtree + 2 if both subtrees r not null if any1 of them is null x = height (right or left subtree ) + 1 else 0  and diameter = max(x) when u calculate x for each node"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int height(mynode *ptr)  //supporting height function {   int lheight=0,rheight=0;    if(ptr == NULL)     return 0;    lheight = height(ptr->left);   rheight = height(ptr->right);    if(lheight >= rheight)     return (lheight+1);   else     return (rheight+1);}  int max(int a, int b){ //supporting max function   if(a>b)     return a;   else     return b;}  int Diameter(mynode *root){   if(root == NULL)    return 0;    int lheight = height(root->left);   int rheight = height(root->right);    int ldiam = Diameter(root->left);  //calculate left subtree diam   int rdiam = Diameter(root->right); //calculate right subtree diam    return max(lheight+rheight+1, max(ldiam,rdiam)); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Recursive single-pass Python solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"please don't use two recursion:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"No recursion solution, use post-order traversal:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Does the code below sound right ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this one ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"2 lines of code"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15503766","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"24","title":"write the most efficient (in terms of time complexity) function getNumberOfPrimes which takes in an integer N as its parameter.   to return the number of prime numbers that are less than N  Sample Testcases: Input #00: 100 Output #00: 25  Input #01: 1000000 Output #01: 78498","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"Use Sieve of Erasthotenes"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Maintain an ordered list of upcoming prime multiples.   When n=20, your list will look like this:   (21, 3) (21, 7) (22, 2) (22, 11) (25, 5) (26, 13) (34, 17) (38,19)  Pop off the top of the list, and now you know that 21 is composite.  Push (24,3) on to the list:  (21, 7) (22, 2) (22, 11) (24, 3) (25, 5) (26, 13) (34, 17) (38,19)  Pop off the top of the list again.  21 is a duplicate, so no new info on composites/primes here, but you can update the list:  (22, 2) (22, 11) (24, 3) (25, 5) (26, 13) (28,7) (34, 17) (38,19)  Pop off  (22,2) and push (24,2):  (22, 11) (24, 2) (24, 3) (22, 11) (25, 5) (26, 13) (28,7) (34, 17) (38,19)  Pop off (22,11) and push (33,11)  (24, 2) (24, 3) (25, 5) (26, 13) (28,7) (33, 11) (34, 17) (38,19)  Next pop off (24,2).  You know your last composite was 22, and your newest composite is 24, so you just found a prime!  Now you push two values into the list:  (24, 3) (25, 5) (26, 2) # next multiple of 2 (26, 13) (28,7) (33, 11) (34, 17) (38,19) (46, 23) # next multiple of 23  Hopefully you get the idea by now.  An easy optimization is to only deal with odd numbers, since all even numbers are composite.  When excluding evens, your list would look like this after 30:  (33, 3) (33, 11) (35, 5) (35, 7) (39, 13) (51, 17) (57, 19) (69, 23) (87, 29)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"yes we have to use Sieve of Eratoshtenes algo but  we can discard even number as we will start from 3 so allocate space for  only odd number and start from 3 int size=floor(0.5 +(n-3) +1); 0.5 for only odd number n-3 start from 3 and +1 for 2  vectorprimes ; //store all prime number vector is_prime(size,true); //initialize all true; for(int i=0;i{   if(is_prime[i])   {    int p=(i <<1) +3 //2i +3    for(int j=((1 *i) <<1)+6*i +3; j    is_prime[j]=false;    }  }    now traverse the is_prime vector and count the true and return the count;  Any optimal solution (i.e counting the true in is_prime vector) most welcome...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Storage-efficient C Sieve.  This code conserves memory (for large N) by applying the sieve to only 1000 numbers at a time.  It also skips even numbers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int primeNumcounter(int n){   if(n == 0){         if( (i%primeN) == 0 ){             isPrime=false;             break;         }      return 0;  } if(n ==1){     return 1; }  Map numMap=new LinkedHashMap<>(); numMap.put(1,1);  for(int i=2;i   boolean isPrime=true;    for(int primeN : numMap.keySet()){ } if(isPrime){      numMap.put(i,i);  }  return numMap.size(); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ops the above comment was pasted wrong, that's what I wanted to write:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  #include  using namespace std;  int main(int argc, char* argv[]){    int N = atoi(argv[1]);         vector flags(N,true);         for(int i=2;i<=sqrt(N);i++){     if(flags[i-1]==true){       for(int j=i*i;j<=N;){         flags[j-1]=false;         j+=i;       }//inner for     }//if        }//outer for      int count=0;   for(int ii=1;ii  {     if(flags[ii]==true) count++;   }      cout<<   return 0;     }     0:56#hepc1 ./a.out 100 25 0:56#hepc1  0:56#hepc1 ./a.out 1000000 78498"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"0 1 2 3 4 5 6 7 8  \n6 7 8 9 1 2 3 4 5 \n^          ^          ^ \n^    ^    ^ \n      ^ ^  ^ \n      ^ ^ \nint find_turning_point(int *a, int n) { \n    int start = 0; \n    int end = n ??C 1; \n    while (start < end) { \n        if (a[start] <= a[end])  { \n            return end; \n        } \n        int mid = (start + end) / 2; \n \n        if (a[start] > a[mid]) { \n             end = mid; \n        } else { \n             start = mid; \n        } \n    } \n    return start; \n} \n \nint bsearch(int *a, int n, int key, bool ascend) { \n     int start = 0; \n     int end = n ??C 1; \n     while (start < end) { \n          int mid = (start + end) / 2; \n          if (a[mid] == key) { \n               return mid; \n          } \n \n          if (a[mid] < key && ascend) { \n              start = mid +1; \n          } else { \n              end = mid ??C 1; \n          } \n     } \n \n     return -1; \n} \n \nint rotate_search(int *a, int n, int key)  \n{ \n     int rotate_pos =  find_turning_point(a, n); \n \n     int pos = bsearch(a, rotate_pos); \n     if (pos != -1) return pos; \n   pos = bsearch(a + rotate_pos, n ??C rotate_pos); \n   if (pos == -1) return -1; \n   return pos + rotate_pos; \n} \n \n \nclass PrimeNumbers \n{ \nprivate: \n      int  *primes = NULL; \n      int capacity = 0; \n      int  n = 0; \n      int max_query = 0; \nprivate: \n     void PrepareTill(int num) { \n             if (max_query >= num) { \n                  return; \n             } \n             max_query = num; \n             if (primes == NULL) { \n                  capacity = 10; \n                  primes = malloc(sizeof(int) * capacity); \n                  primes[n++] = 2; \n                  primes[n++] = 3; \n             } \n             for (I = primes[n-1]; i<= num; i+=2)  \n                    bool is_prime = true; \n                    for (j = 1; j <= sqrt(i); ++j) { \n                          if (I % primes[j] == 0) { \n                              is_prime = false; \n                              break; \n                          } \n                    } \n                    if (is_prime) { \n                        if (n == capacity) { \n                            capacity *= 2; \n                            realloc(primes, sizeof(int) * capacity); \n                        } \n                        primes[n++] = I; \n                    } \n             } \n     } \npublic: \n      int GetPrimeTill(int num) { \n           PrepareTill(num); \n           int I = -1;  // a[i] <= key; \n           int j = n; // a[j] > key; \n           while (j ??C I > 1) { \n                 int mid = (i+j)/2; \n              if (mid > num) { \n                   j = mid; \n              } else { \n                   I = mid; \n              } \n           } \n           return i; \n      } \n};"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"If it's only time you care about - why not just hardcode in a giant array the number of primes for that index. i.e. array[100] = 25."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"There is a neat  trick to reduce number of calculations All Prime Numbers > 6 will be of the form 6n+1 or 6n - 1.  So check for only these numbers"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15500777","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"12","title":"longest common subsequnce: given two lists, find the longest sublist (in order) that is the same","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This is a sub-sequence problem, instead of sub-string, I think the right algorithm to use should be \"building a prefix table\" using dynamic programming."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"fill a[i][i] = with list of starting position a[i] exists in b.  a[i][j] = list of all starting positions from a[i][k]  such that a[i][k] + 1 = any starting position from a[k][j]  like in q(1) - find max."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"consecutive or not?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use suffix tree. lengh m, n. O((m+n)n) time. O(min(m, n)^2) space"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Python Lazy Dictionary Approach.  We lazily build a dictionary of words from s1 as we try to find matches in s2."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think me all missed something. Its a common subsequence problem not common substring."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"string longestCommonSubsequence(string s1, string s2) { \n \n multimap suffixTree; \n int longest = 0; \n string lstr = ??£þ???: \n for (int i=0; i(s1[i], s1.substr(i))); \n} \nmultimap::iterator it; \nfor (int i=0; i::iterator, multimap::iterator> range = suffixTree.equal_range(s2[i])); \n  \n for (it = range.first; it != range.second; it++) { \n int p=0, q=i; \n while(psecond.length() && qsecond[p] != s2[q]) break; \n  p++; q++; \n} \nif (longest < p) { longest = p; lstr = it->second.substr(0, p);} \n}  \n} \nreturn lstr; \n} \n \nOnce I got this done, I found that it was possible to get using dynamic programming with the following formula.  \n M[i, j] = max(M[i-1, j-1], M[i+1, j], M[i, j+1]) if (S1[i] == S2[j])  \n    = max(M[i+1, j], M[i, j+1]) if (S1[i] != S2[j]) \n M[i, j] refers to the ith position of S1 and jth position of S2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \n \nusing namespace std; \n \nint main() { \n string str1(\"abcdefg\"), str2(\"defghig\"); \n \n vector > arr;   \n int maxLen = 0; \n string comStr; \n for (int i = 0; i < str1.size(); ++i) { \n  vector row(str2.size(), 0); \n  arr.push_back(row); \n  for (int j = 0; j < str2.size(); ++j) { \n   if (str1[i] == str2[j]) { \n    if (i == 0 || j == 0) { \n     arr[i][j] = 1; \n    } \n    else { \n     arr[i][j] = arr[i - 1][j - 1] + 1; \n     } \n    if (arr[i][j] > maxLen) { \n     maxLen = arr[i][j]; \n     comStr = str1.substr(i - maxLen + 1, maxLen); \n    } \n   } \n   else { \n    arr[i][j] = 0; \n   } \n  } \n } \n \n cout << \"common string: \" << comStr << \", with max lengh of \" << maxLen << endl; \n cin.get(); \n return 0; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15496742","download_status":"DOWNLOAD_DONE","votes":"-2","answersCount":"4","title":"enumurate all phone numbers by the digit dial on the phone keypad","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Please state question clearly.   What is given?  What is expected?  What is allowed/ not-allowed?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use trie structure to store number and while typing the number traverse through all the nodes till all the leaves."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how about using a prefix tree (trie) data structure: key #1 (1,2,3) key #2 (4,5,6) key #3 (7,8,9) key #4 (0) if dial 415-6789-5432 then dial 212-233... with automatic completion provided"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"void phoneNumbers(const string &dialString, string prefix) { \n \n if (diaString.length() == prefix.length()) { \n  std::cout<<"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15496741","download_status":"DOWNLOAD_DONE","votes":"3","answersCount":"14","title":"Given a string and a dictionary. Break the string into meaningful words.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"can it be done with DP? maybe a[i][j] keeps all lists of possible breaking points?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think there can be words of size 1 to n. So big Oh of this is polynomial time. Algorithm/sudo code,  for i in 1 to 10 { //search all words of size i in the entire string find_words(int size,String inputString) }  Followup question could be how would you optimize it. Ans : We can run find_words across n threads OR n map-reduce jobs. I am not saying map reduce just because its google, but this is perfect candidate for map reduce."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we can start from the dictionary. Basically, we would build a word tree that consists of all the dictionary words, and then go from our string to find whether there is a path in the word tree and the end of our string is actually an end of a dictionary word."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Let say A[k] is a boolean that tells us if string{0..k} can be broken into a set of valid words. Here A[k] would be true iff there is any j < k exists such that A[j] is true and string{j+1, k} is a valid word(validity can be check by keeping all the valid words in a hashtable).  A[n] will just give us if we can break the string into valid words but to know the words we can keep the starting point of the string along with the boolean in each A[k] and by back tracing we can find all the words. However this will give only one possible sequence of words, we can keep record of all the valid starting points of the string along with boolean in each A[k].  A[k]  = OR { A[i] AND IsValid(String {i+1...k}) } for all i < k & i > 0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"python code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool is_word(char* s, int len) \n{ \n    //assume provided. \n    return true; \n} \n \nvoid split_str_to_words(char* s, int len) \n{ \n    int i; \n \n    if (s == NULL || len <= 0) { \n        return; \n    } \n \n    for(i = 1; i <= len; i++) { \n        if (is_word(s, i)) { \n            //printstring(s, i); \n        } \n        if (i < len && is_word(s + i, len - i)) { \n            //printstring(s + i, len - i); \n        } \n    } \n    split_str_to_words(s + 1, len - 2); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"solution using dynamic programming"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"this can be done in n^2 time...  \n \nex: googlesearchengine \n \n1. for i=0 to n, look for all words till i to n i.e.. \n  start, end indexes \ng  0, 0 \ngo  0, 1 \ngoo  0, 2 \ngoog 0, 3 \ngoogl 0, 4 \ngoogle 0, 5 \ngoogles 0, 6   ... do this till end of sentence \n. \n. \no  1, 1 \noo  1, 2 \noog  1, 3 \noogle 1, 4 \noogle 1, 5  ... do this till end of sentence \n. \n. \ns  6, 6  \nse  6, 7 \nsea  6, 8 \nsear  6, 9 \nsearc 6, 10 \nsearch 6, 11 \nsearche 6, 12 ... do this till end of sentence \n. \n. \n. \ne  12, 12 \nen  12, 13 \neng  12, 14 \nengi  12, 15 \nengin 12, 16 \nengine 12, 17 \n--------------- \nhere existing words in dictionary are \ngo  0, 1 \ngoogle 0, 5 \nsea  6, 8 \nsearch 6, 11 \near  7, 9 \na  8, 8 \narc  8, 10 \nhen  11, 13 \nengine 12, 17 \n \nhere for existing words in dictionary, hash all the starting indexes as keys and ending indexes as data in hash table. \n \n1. now start from 0 key in hash table \nhash key  hash data \n0   1   \nso there exists word from 0-1 index, if this is valid word then next word should start from index 2 that is previous hash data+1 \nnow look for key 2 in hash table, this is not exist so previous word is not valid \n \n2. now try for hash key 0 and hash data 5, there exists word (0-5), \nnow look for 6 key in hash, this exists and data is 11, there exists word (6-11) \nnow look for 12 key in hash, this exists and data is 17, there exists word (12-17) and end of sentence \n----------------------- \n \nthis also can be done with 2D array of nxn... n is sentence length"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"google \"google interview word break\""}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15489746","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"10","title":"write a function to sum two single linked lists that represents binaries numbers","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Let L1 and L2 are two singly linked list.Let we store sum in L3 an another linked list. First Step :  Reverse both L1 and L2 by following code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I not quite understand questions. Are the LinkeLists store binary number in theirs cells or  the two linklists represent  two binary number and each cell of them store a 1 or 0 number.  For the first situation how about the code below:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"# You can simulate linked lists in Python with tuples. \n# You want the least significant bit to be the head of \n# the list. \ndef test(): \n    one = (1, None) \n    two = (0, (1, None)) \n    three = (1, (1, None)) \n    six = (0, (1, (1, None))) \n    seven = (1, (1, (1, None))) \n    thirteen = (1, (0, (1, (1, None)))) \n    assert three ==  sum(one, two) \n    assert thirteen == sum(six, seven) \n    assert 15 == to_decimal(sum(two, sum(six, seven))) \n \ndef sum(lst1, lst2, carry=0): \n    if lst1 is None and lst2 is None: \n        if carry: \n            return (1, None) \n        else: \n            return None \n    if lst1 is None: \n        b1, lst1 = 0, None \n    else: \n        b1, lst1 = lst1 \n    if lst2 is None: \n        b2, lst2 = 0, None \n    else: \n        b2, lst2 = lst2 \n    b = b1 + b2 + carry \n    if b >= 2: \n        return (b-2, sum(lst1, lst2, 1)) \n    else: \n        return (b, sum(lst1, lst2, 0)) \n     \ndef to_decimal(lst): \n    if lst is None: \n        return 0 \n    b, rest = lst \n    return b + 2 * to_decimal(rest) \n \ntest()"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The problem did not specify how the result to be presented, a regular integer or a LinkedList of the same style as the two list given. They lead to different solutions."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1 ] Reverse the two lists  using this function :   struct node* Recurse_binary_Add(struct node* resultlist ,struct node* list1,struct node* list2) {    struct node*  newnode = createNode(0);    if(list1 != NULL || list2 != NULL)   {          if(list1 != NULL && list2 != NULL)         Recurse_binary_Add(newnode,list1->next, list2->next);      if(list1 != NULL)                  Recurse_binary_Add(newnode,list1->next,NULL);       else            Recurse_binary_Add(newnode,NULL,list2);     }  2 ] Then find binary addition using this :  struct node* Iterative_binary_Add(struct node** resultlist ,struct node* list1,struct node* list2) {       int reminder = 0, data = 0;     while(list1 != NULL || list2 != NULL)    {            if(list1 != NULL && list2 != NULL)   {         data = (list1->data + list2->data + reminder ) % 2;     list1 = list1->next;    list2 = list2->next;   }   else   {    if(list1 != NULL)      {           data = (list1->data + reminder ) %2;     list1 = list1->next;    }          else          {           data = (list2->data + reminder ) % 2;     list2 = list2->next;    }   }    reminder = (data == 0 )? 1 : 0 ;    struct node*  newnode = createNode(data);     if(*resultlist == NULL)     *resultlist = newnode;     else      {      struct node* tempResultPointer = *resultlist;     while(tempResultPointer->next!=NULL)     tempResultPointer = tempResultPointer->next;     tempResultPointer->next = newnode;      }       }    return *resultlist; }  Then reverse the result list"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In C:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First you need to reverse the two linked lists, unless the heads that are given point to least significant bits of both numbers. Most likely that is not the case.  After the two linked lists are reversed, we scan both of the heads forward and sum them. We can either get 0 or 1. If it's a 1, it gets carried over, if not you just move forward. If either of the heads becomes null, we stop its traversal and keep traversing the head that is not null. Once we reach the end and we still have a carry-over bit 1, we need to prepend a new head with value 1. Reverse the resulted linked list and return its head."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about using three stacks? Let's assumed that the linked list sore the binary numbers 1102 as 1->1->1->0->2 then the algorithm are:  1. store linkedlist1 to stack1 and linkedlist2 to stack2, element by element 2. create stack3 3. pop data from stack1 and stac2 at the same time, sum them up and add to stack3, record carry if it happens and use it at the next round. 4. Create linkedlist3 to append element popped out from stack3  This algorithm reply on the FILO characteristic to operate the sum in correct order.  Weakness is the space complexity, the speed is O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ListNode* add(ListNode* head1, ListNode* head) \n{ \n     rev(head1); \n     rev(head2); \n     ListNode* head(NULL), tail(NULL); \n     int d, c(0);  \n     while (head1 || head2 || c) \n     { \n                d = (head1 ? head1->val : 0) + (head2 ? head2->val : 0) + c; \n                if (head == NULL) \n                       head = tail = new ListNode(d%2); \n                else \n                        tail = tail->next = new ListNode(d%2);  \n                c = d/2;  \n     } \n     rev(head); \n     return head; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15488746","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"17","title":"explain and write algorithm that implements and infinite binary counter, where add() takes O(1) time complexity","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"we keep an aggregation on consecutive 1 or 0.  meaning 111000111 is <3,1> <3,0> <3,1>  1) if the first bulk is of 1's. it turns to bulk of 0`s and turn the very next 0 to 1.  we now check if we can aggregate bulks of 1's.  2) if the first bulk is of 0's, we make the first digit 1. and see if we can aggregate 1's."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Why not just use grey code?  It is designed in such a way so as to only need a single bit flip between consecutive numbers.  The question never needed a constant time algorithm for reading the number, only adding."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is not for the faint of heart. :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can some provide an implementation in Java please?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15500735","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"52","title":"Implement a set that supports insert, remove and getRandomElement() operations.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"12","title":"this can be solved using hash table + array implementation  hash data ---- index to array 40 -------------- 0 10 -------------- 1 20 -------------- 2 30 -------------- 3  array index -- 0 1 2 3 4 data  ---------- 40 10 20 30   initially index = 0;  insert(data) 1. insert the data into hash table if it is not available 2. enter the index to the hash associated to the key (data) 3. enter the data into array[index] location 4. increment the index by 1 i.e.. index++;  delete(data) 1. verify the data is available in hash table if yes then get the index of the data              i = get_index(data)             // index 2. move data from array in location index-1 to i           a[i] = a[index-1]; 3. data in a[i] is changed now, so change the index of a[i] in hash table to i 4. decrement index by 1 i.e.. index--; 5. delete the data from the hash table...delete_hash(data)  get_random() 1.  generate a random number 0 - (index-1)         r = rand() % index; 2. return array[r]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"hi Epic coder, After reading the question the first doubt that comes to my mind is, what would be arguments with insert(),remove(),get_random(). In case there is no argument then we can assume to operate on top most element as in your case. But, suppose if the index is given then though it can still be done in O(1), itsnt there a need to rearrange the elements in our array after every remove() ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public class RandHashAccess \n{ \n private Map elementMap; \n private List elementArr; \n \n  public RandHashAccess() \n{ \n   elementMap =  new HashMap(); \n   elementArr = new ArrayList(); \n} \n \npublic void Insert(T element) \n{ \n  int arrLength = elementArr.size(); \n  elementArr.add(element); \n  elementMap.put(element, arrLength); \n} \n \npublic void Remove(T element) \n{ \n    Integer eleArrIndex = elementMap.get(element); \n     \n   if(eleArrIndex != null) \n   { \n         /* swap the element in cur position with nth element and \n            remove the last element from the array */ \n         int arrSize = elementArr.size(); \n         T eleNth =  elementArr.get(arrSize-1); \n         elementArr.set(eleArrIndex, eleNth); \n         elementArr.remove(arrSize-1); \n        \n        /* adjust the nth element array order in the map, since it is swapped with cur element position */ \n        elementMap.put(eleNth, eleArrIndex); \n        elementMap.remove(element); \n} \npublic T get_random() \n{ \n int randElePos =  Math.random(0, elementArr.size() -1); \n return elementArr.get(randElePos); \n} \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"So the answer here is a hash table because you can insert and remove in O(1).  The tough part was the get_random() function because if you just try to generate random numbers until you get an index that actually has a value you will not get constant time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class HashTable { \n    private DataItem [] data; \n    private int size; \n    private int [] keys; \n    private int numKeys; \n     \n    private class DataItem { \n        public int keyIndex; \n        public object data; \n         \n        public DataItem(int k, object d) { \n            keyIndex = k; \n            data = d; \n        } \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I never like the idea of suggesting hash table for such problems because implementing a hashtable that gives you O(1) insertion and deletion is a big problem in itself. In this problem we are not required to lookup the element in O(1) time and we should exploit that fact. My idea is to use a very large array and use it to implement a stack using this array. So  1. you can insert only at the top, O(1) time,  2. you can delete only from the top again O(1) time and  3. for finding random element, suppose that we have n elements in the array at the instant we have to generate a random number. Random number would be rand(n)th element of the array, where rand(n) is a random number generator between 0 and n-1. Again O(1) time.  Note that there is always a possibility of running out of space and in that case we'll have to expand the array(which could be visualized as equivalent of rehashing in hash tables)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hashtable + a vector for quickly getting random elements seems an appropriate solution, with the following additions: * keep the index of the array in the hash table, for fast deletions from the array * delete from the array by swapping with the last element and then deleting last element, to make this operation o(1)  C++ solution is below.  * Assuming the elements you are storing are integers. * Variable names could have been better. * Handle collisions by \"chaining\" in a vector (easier to implement than linked list)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \n \nstruct link_node \n{ \n struct link_node *next; \n int index; \n int data; \n}; \n \nclass RequiredDataStructure \n{ \nprivate: \n static const int hash_bits = 14; \n struct link_node **hash_table; \n int arr_ind; \n int arr_size; \n int *arr; \n \n int fibnocci_hash(int a, int bits) \n { \n  return (int)(((long long)a * 11400714819323198485ULL) >> (64 - bits)); \n } \npublic: \n RequiredDataStructure() \n { \n  hash_table = (struct link_node **)malloc(sizeof(struct link_node *) * (1<data = data; \n  node->index = arr_ind++; \n  int hash = fibnocci_hash(data, hash_bits); \n  node->next = hash_table[hash]; \n  hash_table[hash] = node; \n } \n \n void Remove(int data)  \n { \n  int hash = fibnocci_hash(data, hash_bits); \n  int index; \n  struct link_node *curr, *prev = NULL; \n  for (curr = hash_table[hash]; curr != NULL; prev  = curr, curr = curr->next) { \n   if (curr->data == data) { \n    break; \n   } \n  } \n \n  /* only deleting if exists. */ \n  if (curr != NULL) { \n   if (prev != NULL) { \n    prev->next = curr->next; \n   } else { \n    hash_table[hash] = curr->next; \n   } \n   // remove element at curr->index \n   --arr_ind; \n   if (curr->index != arr_ind) { \n    index = curr->index; \n    arr[index] = arr[arr_ind]; \n    data = arr[index]; \n    hash = fibnocci_hash(data, hash_bits); \n    for (curr = hash_table[hash]; curr != NULL; curr->next) { \n     if (curr->data == data && curr->index == arr_ind) { \n      curr->index = index; \n      break; \n     } \n    } \n   } \n   free(curr); \n  } \n } \n \n bool GetRandom(int *ran) { \n  if (arr_ind != 0) { \n   *ran = arr[rand() % arr_ind]; \n   return true; \n  } \n  return false; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Second vincent, expanding on the same idea. DS: hashmap (unordered) + DL.  (maintaing head pointer).  generate_random: map.size() gives us number of elelments at any given instance. Exploit this fact and access node such as: (rand() % size) from the head pointer.   DL should provide O(1) insertion and O(1) deletion. Furthe, for O(1) random number generation cache the node access and apply rand() function to generate new random node to access, such as:  first time:  return head_; // store this pointer.   second time: return lastAccess +/- rand()%5 based on pointer location."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Class Set{ \nArrayList al; \nRandom r; \npublic Set(){ \nal=new ArrayList(); \nr=new Random(); \n} \npublic add(T element){ \nif(!al.contain(element)){ \nal.add(element); \n} \n} \npublic remove(T element){ \nif(al.contain(element){ \nal.remove(element) \n} \n \npublic T getRandomElement(){ \nint temp= r.nextInt( al.size()); \nreturn al.get(temp); \n \n \n} \n} \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"algos solution is good. But to optimize insert and add to O(1) we have to implment our own hash. So it will be array of size (lets say 65535). For any elemtent array index K will be key an value will be array[K]  In that case we need our own hash function, for which we can use md5. So add and remove remains O(1) and getRandom can be pure random by fetching any value of rand(size of array)  We can have array of size 65535.  hash function => decimal value of ( last 4 bytes of md5 ) // maximum will be FFFF which is 65535.  For hash function collision, we can use chaining. So each array element will be linked list of data. If array index chosen by random function has more than 1 element, we can again choose rand(size of linked-list) to get Nth element in that linked list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package cc.goog; \n \nimport java.util.HashMap; \nimport java.util.Map; \nimport java.util.Random; \n \npublic class SpecialSet { \n  \n private Map elementVsIndex = new HashMap(); \n private Map indexVsElement = new HashMap(); \n private Random r = new Random(); \n  \n public void insert(T t) { \n  if (elementVsIndex.containsKey(t)) \n   return; \n  int maxIndex = elementVsIndex.size(); \n  elementVsIndex.put(t, maxIndex); \n  indexVsElement.put(maxIndex, t); \n } \n  \n public void remove(T t) { \n  int maxIndex = elementVsIndex.size() - 1; \n  Integer removedIndex = elementVsIndex.remove(t); \n  if (removedIndex != null) { \n   T e = indexVsElement.remove(maxIndex); \n   if (e != null) { \n    elementVsIndex.put(e, removedIndex); \n    indexVsElement.put(removedIndex, e); \n   } \n  } \n } \n  \n public T getRandomElement() { \n  int maxIndex = elementVsIndex.size(); \n  int randomIndex = r.nextInt(maxIndex); \n  return indexVsElement.get(randomIndex); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"I think hashtable + double linked list is a solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-6","title":"void main() { printf(\"You all are fools\"); }"}]}}]