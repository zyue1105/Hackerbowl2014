[{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13556672","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"46","title":"Q3. Written Exam Amazon(Bangalore)  Given a singly linked list which may or may not contain loop and loop may or may not start from the head node. Count the number of elements in the linked list.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"EDIT: The previous algo failed for some input cases. Thanks to @ buckCherry for pointing it out. Below is the fresh algo.  Find the start of the cycle through Floyd cycle detection algorithm.  The total number of nodes is the count of nodes that form cycle and count of nodes that are not part of cycle. If the list doesn't contain cycle, count of nodes that are part of cycle is zero. 1. Maintain two pointers called hare & tortoise. 2. move hare two steps &  tortoise one step until either both become equal or hare reaches NULL. 3. Move tortoise to the start of the list. Move tortoise  and hare step by step until their next node don't point to the same node( in case there is no cycle , hare will point to NULL. Ignore step#4 in this case). This next node is the starting node of the cycle. Meanwhile count the number of nodes that are not part of the cycle.  e.g. A->B->C->D->E->D The number of nodes that don't form cycle is 3.  4. Count the number of nodes in the cycle. Start tortoise from the starting node of the cycle and keep on moving until it doesn't reach its initial position. In the example explained in step#3, the number of nodes in the cycle is 2.  5. The answer is count in step#3 + count in step#4."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Traverse through the linked list. while traversing the linked list insert address(key) of each node into a hashmap.If it already exists in the hashmap then the linked list contains the loop. Maintain a counter to know the number of elements of the list while traversing..  Timecomplexity-O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"you can first find if there is cycle in linklist or not(Using 2 pointer floyd theorm) in O(n) time     (i)If it is present then that node(ie. start node for cycle) will be your check point.    while counting you need to look at.   otherwise it is a normal link list"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"you can first find if there is cycle in linklist or not(Using 2 pointer floyd theorm) in O(n) time     (i)If it is present then that node(ie. start node for cycle) will be your check point.    while counting you need to look at.   otherwise it is a normal link list"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"first check if der is a loop wid o(n) complexity floyds theorem.. if loop is der,mark the starting node of loop wid pointr p.now tak a pointr k pointing to first node of lnkd list.traverse it until u rech p,increment countr til dat.after dis loop,point k to the next sequential node.. again run loop and increment counter untill p is rechd.. counter is the no. of nodes we wanted.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"such looping in list is solved using 2 pointers. one is ptr->next and the other is ptr->next->next. at 1 point they both meet and there your counting ends. when there is no looping you can just go to the end of the list incrementing the count."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"such looping in list is solved using 2 pointers. one is ptr->next and the other is ptr->next->next. at 1 point they both meet and there your counting ends. when there is no looping you can just go to the end of the list incrementing the count."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"such looping in list is solved using 2 pointers. one is ptr->next and the other is ptr->next->next. at 1 point they both meet and there your counting ends. when there is no looping you can just go till the end of the list incrementing the count."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"such looping in list is solved using 2 pointers. one is ptr->next and the other is ptr->next->next. at 1 point they both meet and there your counting ends. when there is no looping you can just go till the end of the list incrementing the count."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"in the question it is specified that we may be given a link list which may or may not have a loop , and it may not start from the head. Now consider that we were given a list which does not cointain loop (singly linked list) and we did not start form the head , then starting from the point or node given to us there might be a possibility that there were nodes behind then how can we count them when finding the no. of elements in the list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"in the question it is specified that we may be given a link list which may or may not have a loop , and it may not start from the head. Now consider that we were given a list which does not cointain loop (singly linked list) and we did not start form the head , then starting from the point or node given to us there might be a possibility that there were nodes behind then how can we count them when finding the no. of elements in the list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"LinkedListNode FindBeginning(LinkedListNode head) {   LinkedListNode n1 = head;   LinkedListNode n2 = head;       // Find meeting point   while (n2.next != null) {     n1 = n1.next;     n2 = n2.next.next;     if (n1 == n2) {      break;     }   }   // Error check - there is no meeting point, and therefore no loop   if (n2.next == null) {    return null;   }   /* Move n1 to Head. Keep n2 at Meeting Point.  Each are k steps   /* from the Loop Start. If they move at the same pace, they must    * meet at Loop Start. */   n1 = head;    while (n1 != n2) {     n1 = n1.next;     n2 = n2.next;    }   // Now n2 points to the start of the loop.   return n2; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is an idea --  maintain three pointers: a) head -- start of the given list b) first -- jumps one step in iteration c) second -- jumps two step in iteration  Start first and second pointers from the head and continue till both become equal (in case of loop) or second traverses the list completely and reaches  the end(in case of linear list).  If the list is linear, number of nodes can be counted by traversing the list starting from head.  If the list contains a loop, notice the node where first and second becomes equal, store this new pointer tempPointer.  At this point, break the loop between tempPointer and tempPointer->next  by using code below:  head2 = tempPointer->next; tempPointer->next = null   Suppose the original list with loop was like:   head - a - b- c- d- e - f - g - h                                  |              |                                 l -k  - j  - i  Suppose the loop is broken between f and g and null pointer is introduced:   then g becomes head2 and f->next is set to null:  head  - a - b- c- d- e - f --> null                                  |                                                 l - k  - j  - i - h - g (head2)  now we can traverse from head to null (first list) and head2 to null (second list)  These two lists are merged at node e.  Count the number of nodes in first list -- count1 Count the number of nodes in second list -- count2  suppose count1 is greater than count2 (take whichever is greater)  then traverse first list by (count1 - count2) starting from head. Then start traversing two lists together till you reach at merging point. Suppose you traverse M nodes together to reach merging point.  Then traverse the merged list.  The sum of nodes in both lists = number of nodes in first list + M"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how cycle is detected using hare & tortouse algo?? can u please explain??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Mark the nodes and then count"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Find the loop using floyd's algo, then clacualte thenumber of nodes in the loop by fixing one pointer inside the loop and shifting another pointer in the loop untill bth of them become equal again, lets the number be m now take a pointer pointing to the head and go to mth node now move the pinter to the head and the pointer pointing to the mth node step by step until the bcome equal and now you the node at which the loop starts"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using double pointers only, will not solve this problem. There two types elements in the list; first are say, X which are not in loop and other say, Y, which belongs to loop. let number of X are x. and number of Y are y. And we need to calculate the x + y.   I will go with this approach: First reverse the linked list and increment a counter, counter will be give you the value of 2x + y. Now, using floyd cycle detection algo to find any Y. Calculate the value of y by just traversing the loop once starting from Y. Calculate x + y, using prior equations.  Reverse again the linked list to give its original shape. Total complexity should be O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What exactly does \"may or may not start from the head mean\" ?? We certainly cannot backtrack in a singly linked list unless its circular. Maybe i am not clear with the question. Please explain."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"'shodnik' and 'Anonymous' have already provided solutions which I'm not fully convinced untill I receive some response against my asks to them. In the mean time here is my solution in O(n) time and with fixed additional memory. The only drawbacks of my algorithm is that it requires changing the structure of the list whereas both of the solutions from them does not. Note that the solution given by 'Anonymous' does a change of list structure but it can be avoided.  Anyway here is mine."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node slow = head; \n Node fast = head; \n while (slow != null && fast != null && slow != fast){ \n  slow = slow.next; \n  if (fast.next== null) \n   break; \n  fast = fast.next.next;  \n } \n int size = 0; \n if (slow == null ||fast == null || fast.next == null){ // there is no loop \n  Node temp = head; \n  \n  while (temp != null) \n   count++; \n  return count; \n } \n //now we want to find the head of the cycle \n slow = head; \n while (slow != fast){ \n  slow = slow.next; \n  fast = fast.next; \n } \n //now fast/slow is the head of the loop \n Node current1 = head; \n Node current2 = slow.next; \n while (current1 != slow){ \n  size++; \n  current1 = current1.next; \n } \n while (current2 != slow){ \n  size++; \n  current2 = current2.next; \n } \n return size + 1; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=245679","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"143","title":"find the longest palindrome in a string?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"detalied explanation can be found at  www.math.tau.ac.il/~haimk/seminar02/suffixtrees.ppt"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"This can be solved using \"Suffix Tree\"."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Actually, the most efficient algorithm is O(n) and is based on dynamic programming.   Let str be the string of length n. Let us define: len[i] = length of the longest palindrome in substring having characters str[0],str[1],...,str[i]. beginIndex[i] = beginning index of the longest palindrome in substring having characters str[0],str[1],...,str[i].  len[0] = 1; beginIndex[0] = 0;   Now, try to find out len[i] in terms of len[i-1] and beginIndex[i] in terms of beginIndex[i-1] - during this we should leglect the special case when all characters in palindromes are same. We should find maximum length palindrome of this type.  We should deal with the special case where all characters in palindromes are same separately and find the maximum length palindrome of such type.   Out of above two, we should pick the longer palindrome. More than enough to solve it.   In any case, full code is below:   public static String longestPalindrome(String str)  {   String result = \"\";      int[] bIndex = new int[str.length()];   int[] len = new int[str.length()];      int i = 0, j = 0, index = 0;   bIndex[0] = 0;   len[0] = 1;   if(str.charAt(0) == str.charAt(1))   {    bIndex[1] = 0;    len[1] = 2;   }   else   {    bIndex[1] = 1;    len[1] = 1;   }      int maxLen = 0, bIndexMax = -1;   char c;      for(i = 0; i < str.length(); i = j)   {    c = str.charAt(i);    for(j = i+1; j < str.length() && str.charAt(j) == c; j++);    if(maxLen < j-i)    {     maxLen = j-i;     bIndexMax = i;    }   }      for(i = 2; i < bIndex.length; i++)   {    index = bIndex[i-1];    if( index == i-1)    {     if(str.charAt(i-2) == str.charAt(i))     { // check for odd length palindrome      bIndex[i] = i-2;      len[i] = 3;     }     else if(str.charAt(i-1) == str.charAt(i))     {      bIndex[i] = i-1;      len[i] = 2;     }     else     {      bIndex[i] = i;      len[i] = 1;     }    }    else    {     if(index-1 < 0)     {      bIndex[i] = i;      len[i] = 1;     }     else if(str.charAt(index-1) == str.charAt(i))     {      bIndex[i] = index-1;      len[i] = len[i-1] + 2;     }     else      bIndex[i] = i;    }   }      for(i = 0; i < len.length; i++)   {    if(maxLen < len[i])    {     maxLen = len[i];     bIndexMax = bIndex[i];    }   }         return str.substring(bIndexMax,bIndexMax + maxLen);     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"This self-contained C program will print out all of the palindrome lengths for all possible centers, and it will do it in O(n) time. It is a port of the algorithm in Haskell authored by Johan Jeuring here: johanjeuring.blogspot.com/2007/08/finding-palindromes.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Yes, LC String does not work. Ex: string:abcdecba    reverse:abcedcba        LCS:abc/cba"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"find palindrome in string A  reverse A as A', so it's equivallent to find longest common substring between A and A'?  if so, we can use prefix array method to do this as the \"pearls\" book suggested?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can use suffix tree or suffix array.  for(i=0;ic[i]=&A[i]; for(i=0;ic'[i]=&A'[i];  for(i=0;i{ get the longest common substring from the head of c[i],c'[n-i-1] c[i+1],c'[n-i-1] }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a problem of finding the LCS(longest common subsequence ) between the string and the its reverse."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is Longest Common Substring (Need to be contiguous)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"01234567890010987654321 will return 123456789"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Original string is A 2. Reverse string is B 3. Find common strings are C, D, E .... 4. Find palindromic strings in step 3, suppose C, D. 5. Find the max length of strings in step 4. Return."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's a solution in C++ (may not be the most effective, though). Basically it checks if the given string \"s\" is a palindrome. If it is, then that's the longest we can find.  If not a palindrome, look in s.substr(0, len - 1) and in s.substr(1, len - 1) and return the longest result."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"http://wiki.answers.com/Q/Is_there_any_way_to_find_the_largest_palindrome_in_a_string"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Naive algorithm finds he solution for the problem in O(n3) time. Select two ends to define a substring and check in linear time whether it is a palindrome.  2)Enhancement can be done to the naive algorithm to make it work in O(n2) time and O(n) space. Consider two strings  S and S(reverse).  for each character in first string: for each subpattern in first string match the pattern in second string by KMP algorithm to find longest common string in both in linear time O(n+n) and O(n) space(this will be the palindrome). overall runtime O(n2) and O(n) space.  3)The optimized version of the algorithm runs in O(n) time with suffix trees."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i think we can solve this using dynamic programing...  n is the length of str if(istr[i]==str[n] i++,n--;store i,n; else call func with i+1,n call func with i,n-1 }  i think u got my sol.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"DP solution:   int F(char* a, int n) {   if(n==1) return 1;      int k = F(a, n-1);   if(IsPalindrom(a, n-2k-2, n))     k++;    return k; }  thoughts?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just have an idea to reduce few calculations .. 1. Maintain a hash table..keep track of all characters which appear more den once .( store their indices ) 2.You can chek for all these indices ..this will possible reduce chekin for all the possibilities ..waitin for a better soln :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Agreed with sameerud, but essential addition: there are 2 types of palindromes: something like 'aba' and 'abba'.  So for every symbol we should test those two possibilities, not only the first one."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Agreed with sameerud, but essential addition: there are 2 types of palindromes: something like 'aba' and 'abba'.  So for every symbol we should test those two possibilities, not only the first one."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Input String is s1, Reverse the string to s2. Use Dynamic Programming to find the longest common substring. That gives u the result!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(size(s1)+size(s2)) it is!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I kind of disagree from sameerud, because take an example of a string abcaba,,, so as i understand his algo. won't be able to find the pallindrome aba,,  So, i there is one another algo  char *lar_pal = NULL;  char *str = /*some string*/ for(int i=0;i    for(int j=i+1;j        }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorry for previous reply,, pressed enter by mistake  I kind of disagree from sameerud, because take an example of a string abcaba,,, so as i understand his algo. won't be able to find the pallindrome aba,,  So, i there is one another algo. (I should write sudo code)  1) Start from the first element i in the string and compare it will all other element j in the     string //for(j=i+1;j   a) if string[i] == string[j]             if(pallindrome(somestr,i,j)){                  //the substring is from i - j index             }     pallindrome(char *someStr, int i, int j) 1) if someStr[i+1] == someStr[j-1]       if(i==j || i+1 == j)                    //aba,,,,abba              return true       aii) else                 i+=1;j-=1;                 pallindrome(someStr,i,j)    else        return false"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"reverse + LCSubstring"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a Longest Common Substring Problem,we basically construct the generalized suffix tree for the give string and its reverse.From the constructed tree it would be possible to find the longest Palindrome by traversing the tree.The construction of the tree would take O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My views:  1. Start with the middle element in the String (len/2).  2. Have two pointers (i and j): i goes back till 0, j goes forward till n. 3. whenever this fails : you have your longest palindrome.   This can be done other way too:  1. Have two pointers i and j at the beginning and at the end.   Like wise. Any takers?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I guess this is one of the best possible solution... But, usually this problem is coupled with another objective to find all the palindromes in a string and also to find the longest palindrome..in this case instead we can use a static variable and find the longest palindrome..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@particularraj: your algorithm works by the assumption that the palindrome starts in the middle of the string. It doesn't consider palindromes that at other places in the string. For example, consider the string ABMOCECXYYZ  Here according to your algorithm, you will start at 'E' moving i backward and j forward. When i reaches 'O' and j reaches 'X', the algorithm stops and concludes that 'CEC' is the longest palindrome. But 'XYYZ' is the longest palindrome in the above mentioned string."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The example string should be 'ABMOCECXYYX'."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Nice comment KB. Then I guess I have no choice but to iterate it 'N' times and update a static variable, so that we access and get the longest palindrome.   What do you think?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Create suffix trees of the original and reversed strings. Sort the suffixes separately. Find max length between suffix array from one string to that of the reversed."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is there any O(n) solution other than suffix tree. I dont think the interviewer would ask you to construct a suffix tree during the interview."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Suffix trees has O(n) time to look."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Suffix tree will give a very good solution, but it is difficult to come up in a interview. I would go with a dynamic programming approach,  Suppose we have the given string as,  InputString = \"abaccabadefg\"  Here there are 4 palindrome strings, aba - length 3 cc - length 2 aba - length 3 abaccaba - length 8  Now the output should be abaccaba  In order to find that, reverse the input string, ReverseString = \"gfedabaccaba\"  Now create a 2 dimensional matrix of NxN and follow a dynamic program approach to get the length on the longest palindrome and display it. Heart of the solution is,  A[i,j] = Max (a[i-1, j], a[i,j-1] if InputString[i] != ReverseString[j]        = a[i-1,j-1] + 1, if InputString[i] == ReverseString[j]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about having two pointers, one at the start and one at the end of the string.  For each character in the string, you will traverse backwards from the tail and try to find the largest possible palindrome matching with the start of the strong, if any.  You keep doing for every character, this until you find one, any palindrome.  Each time you do this loop for a character from the head, your largest palindrom will be s-n, where s is the original string length, and n is the number of iterations you've done this.  When you do find a palindrome, any palindrome, you will know that if the largest palindrome, it will be at between size (curr palindrom size) and (s-n).  Armed with this knowledge, you can then write a function that is optimized to only process the remainder of the array for strings that meet the stringlength described above.  And of course, this could be done elegantly using recursion, and fine tuning it with the logic similar to the above once you have confirmed at least one palindrome.  This of course is going to be a resource hog but the code will be easier to read and manage.    :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Find the reverse string 2. Find longest common substring  Will this work? I think dynamic programming approach that you mentioned is same as this."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My cents:  Building suffix trees is not a bad idea. We can get that in O(nlogn) time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Take a string  1. Reverse the string 2. XOR with the Original String 3. Find the longest sequence of 0s in the XORed result which will be the corresponding  answer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"start with the first character. try to lookup the same character from the bak. on finding the same character from the back check if the substring is palindrome or not. keep on finding the same character until u reach the index of the first character.  keep on doing the same for all the characters. ....O(n^2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just reverse the string and find the largest substring in both the strings. O(n^2)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"finding the longest substring of the string and it's reverse won't work.  Consider abcdefgHELLOWORLDgfedcba  The longest palindrome is actually LL, that method would return abcdefggfedcba"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Keep a current pointer on the second element a(1). place two other pointers at current-1 and current+1. check if curr-1 and curr+1 are equal. then move current pointer ahead. again set curr-1 and curr1 and check for: If curr is at ith position: while(i>0) { if (curr-1 == curr+1)  {    (curr+1)++;    (curr-1)--;     i--; } else break; }  keep tack of the largest one by storing the value of current for which the length of palindrome was max. also keep track of it's length for each i. Then u can print the longest palindrome."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@gagdeep what does the 'i' signify ??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can you show the working code by which you arrived O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think we cannot solve this question in less than O(n^3) complexity........as ideally there are n*n different string that can be created using a string of length n......For example there are 1 string of length n that can be formed from given string and there are 2 string of length n-1 that can be formed using a string of lenght n-1 and there are n string of length 1.  So if you sum it all, there are 1+2+ ........+ n-1 + n strings = O(n*n)........  We know how to check for one string in O(n) time, so I think we can just repeat the loop by checking string of length n to 1 and stop whenever we find any palindrome.....  Seriously, I don't think we can solve this question in less than this time, because we have to check for string of each length and in worst case there might not be any palindrome in string and so we might end up with generating palindrome on length 1 i.e . character itself, if you consider that to be a palindrome.....  Please share your thoughts, I would be happy to hear from anyone....who can help me in improve on this solution..........."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"maxindex = 1; \nmaxlen = 1; \nfor(index = 1 to str.length) { \n  for(cur = 1 to min(index, abs(str.length - index))) { \n    if(str[index + cur] == str[index - cur]) { \n      if(cur < maxlen) continue; \n      maxlen = cur; \n      maxindex = index; \n    } \n  } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am not sure about suffix tree, as I have not read those yet, but I don't think we can solve this question iteratively in less than O(n^3) and I don't think dynamic programming will work too as we cannot use the result that I got in previous iteration because if I have two strings that are palindrome then I cannot say that if I merge both string then those will be palindrome also...  Here is my solution using O(n^3) complexity.  There are n*n different string that can be created using a string of length n......For example there are 1 string of length n that can be formed from given string and there are 2 string of length n-1 that can be formed using a string of lenght n-1 and there are n string of length 1.  So if you sum it all, there are 1+2+ ........+ n-1 + n strings = O(n*n)........  We know how to check for one string in O(n) time, so I think we can just repeat the loop by checking string of length n to 1 and stop whenever we find any palindrome.....  Seriously, I don't think we can solve this question in less than this time, because we have to check for string of each length and in worst case there might not be any palindrome in string and so we might end up with generating palindrome on length 1 i.e . character itself, if you consider that to be a palindrome.....  Please share your thoughts, I would be happy to hear from anyone....who can help me in improve on this solution..........."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A working solution. O(n*n*n) complexity but good for an interview."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Not sure what happened to the white space.  Here is a quick test I used."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this way: 1. define stringbulder variable called sb and an int called numberOfChars and max 2. for each character in the string  3. add the character to sb, and set numberOfChars to 1.      4. for each remaining character in the string 5. append the character to sb and increment numberOfChars by 1.      6. if the character is the same as the character read in step 2, then what we have in sb is a potential palindrom so, call a helper funtion called IsPalindrome with the value in sb as an argument. 7. If step 6 returns true, then add the content of sb to a dictionary with sb as a key and numberOfChars as a value---you can have duplicate checks 8. inner loop ends here 9. if numberOfChars > max then reset max to numberOfChars and clear sb 9. loop to the first loop. 10. Now, all possible palindrome strings are in your dictionary. Return a key with value equal to max.  Note that: The algorithm generates all possible palindroms but, i think there might be a better way of doing it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Longest thread of answers to Longest palindrome finding :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"could not post the link. google for this. the first link has a good solution  finding-the-longest-palindromic-substring-in-linear-time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It's awesome to see people using suffix tree and O(nlogn) at the same time !!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My suggestion is that any approach of O(n^2) time and O(1) space that can be well explained and you can write working code during an interview would suffice!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Reverse the string and find biggest substring."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"No need for such complex algorithms !!!  I was asked this question, I proposed trying all combination (O(n^2) I think) he looked convinced with that approach."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Example: ================ Str1=abcbabcmoms  Str2=abcba   ALGO: ================ 1.a          take A[i]==A[j] , decrement J-- till i                  if A[i]==A[j]                 take paldromeindex=i                 and increment i and decrement j till i=j                 RANGE[k]=J-I                  1.b          sort range and return the longest one  CODE: ================  private string LongestPalindrom(Str S1,int size) { int maxrange =0;                  For(int i=0;i                {                 char ch1=s1[i];                                                                  FOR(INT J=SIZE; J>0;J--)                                                 {                                 char ch2=s1[j];                                                  IF(CH1==CH2 && i!=j)                                                 {                                                  int range= j-i;                                                  i++;                                                  ch1=s1[i];                                                 }                                 }                                  IF(MAXRANGE                                {                                 int maxrange =range;                         int maxindex=i                                 }                 }                  FOR(k=maxindex;k                                {                                  Console.writeline(Str[k]);                                            }  }    TEST HARNESS: ================ using system;  namespace problem {                 class Solution                 {                    static void Main(string[] args)                 {                                  String Pal1 =\"abcbabcmoms\"                                  String Result;                                  Result= Longestpalindrom(Pal1,11); }}}  ORDER: ================ O(N^2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Tarun, Nice try but you need more temp variables to save indexes and values. Try this string and you will find a bunch of bugs in ur code. \"BBABTENETTENEB\".  This is is the code i came up with, can you guys please review it:  void longestPalindrome(char* str, int size, int* begin, int* range){      *begin = 0;      *range = 0;      int i, j, pali, tempRange = 0;      for(i = 0; i < size; i++){            *begin = pali = i;            for(j = size - 1; j >= pali; j--){                  tempRange = j - *begin;                  if(str[pali] == str[j]){                       pali++;                  }else{                       tempRange = 0;                       if(pali != *begin){                           break;                           }                   }                  }            if(*range < tempRange){                *range = tempRange;                            }            } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int main() \n{ \nchar a[]=\"abcdaeeadabb\"; \nchar *p,*q,*r,*found; \nint i=0; \nint max=0; \nfor(p=a;*p!='\\0';p++) \n{ \nq=p; r=a+strlen(a); \n    while(qmax) {max=i; found=p;} \n} \nif(q==r) max=max+1; \nstd::cout<<<*found; \nreturn 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void longestPalindrome(char *str, int n) \n \n{ \n \n    int i=0, j=0, start = 0, end = 0, range = 0, maxstart = 0,maxend = 0; \n \n    while(i < n && j < n) \n \n    { \n \n        start = i; end = j; \n \n        while((str[start] == str[end]) && (start >=0) && (end <= n)) \n \n        { \n \n            if((maxEnd - maxStart) < (end-start)) \n \n            { \n \n                maxEnd = end; \n \n                maxStart = start; \n \n            } \n \n            end++; \n \n            start--; \n \n        } \n \n        start++; \n \n        end++; \n \n    } \n \n \n    for(int i = maxStart; i <= maxEnd; i++) \n \n        printf(\"%c\", str[i]); \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is indeed a Dynamic Programming problem as Gopal Krishna has indicated but I can't think of a a solution that can solve this in less than O(n2).  My O(n2) solution was to take the string and its reverse (i.e. output of strrev(string)) and do a longest sub-string match using dynamic programing. The largest sub-string match is the longest palindrome in the given string."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Collections;  class Program { static void Main(string[] args) { Program p = new Program(); Console.WriteLine(p.LargestPalindrome(\"abbac\"); }    public String LargestPalindrome(String str)         {             int[] ar = new int[str.Length];             for (int i = 0; i < str.Length; i++)             {                 int start = i;                 for (int j = str.Length - 1; j >= i; j--)                 {                     int end = j;                     int cnt = 0;                     while (start <= end)                     {                         if (str[start] == str[end])                         {                             if (start != end)                                 cnt += 2;                             else                                 cnt++;                             start++; end--;                         }                         else                         {                             cnt = 0;                             break;                         }                                             }                     if (ar[i] < cnt)                         ar[i] = cnt;                 }             }             int max = 0;             for (int i = 1; i < ar.Length; i++)             {                 if (ar[i] > ar[max])                     max = i;             }              return str.Substring(max, ar[max]);         } }1 2 10 42 11"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int _tmain(int argc, _TCHAR* argv[]) {  char p[500],*temp;  int i,j,str_len,k;  printf(\"\\n Enter the string \");  gets(p);  if (palendrome(p) == 0) {   printf(\"\\n String is a palendrome\");   return 1;  }  else   printf(\"\\n Not a palendrome\");    str_len = strlen(p);  int largest_palindrome = 0;  char q[100];  for(i=0;i {   temp = p+i;   for(j=2;j<=str_len-i;j++)   {    if(palendrome_substring(temp,j) == 0)    {     if (j > largest_palindrome){      largest_palindrome = j;      memcpy(q,temp,j);      q[j] = '\\0';     }    }   }  }  printf(\"\\n largest palendrome %s\",q);  return 0; } int palendrome(char *p) {  int str_len = 0,i;  if (!p ) return -1;  str_len = strlen(p);  if(str_len < 2)return 1;  for(i=0;i<(str_len/2);i++)  {   if (p[i] != p[str_len - i - 1])    return 1;  }  return 0; }  int palendrome_substring(char *p, int size) {  int str_len = 0,i;  if(!p || !size) return -1;   str_len = size;  for(i=0;i<(str_len/2);i++)  {   if (p[i] != p[str_len - i - 1])    return 1;  }  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"N^2 solution - Dynamic Programming. Should be good for interview. \nisPalindrome[i,j] = isPalindrome[i+1, j-1], if str[i] == str[j] \n                  = false, if str[i]!= str[j] \n                  = true,  if i == j //single character \n \nAfter the matrix is filled, traverse diagonally to find the longest palindrome"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"small change in previous program: \n \nchar * fndlong (char *str) \n{ \n char * pointpal, *longestpal; \n int length, longest=0; \n while(*str) \n {int i=1; \n \n  if(*str==*(str+i)||*(str-i)==*(str+i)) \n  { \n   if (*(str-i)==*(str+i)) \n    pointpal=str-i; \n   else \n    pointpal=str; \n   i++; \n   length=0; \n   while(*(str-(i-1))==*(str+i)||(*str-i)==*(str+i)) \n   { \n    pointpal--; \n    i++; \n    length=+ 2; \n   } \n  } \n  if(longest==0 || length>longest) \n  {  \n   longest=length; \n   longestpal=pointpal; \n  } \n  str++; \n } \n return longestpal; \n} \n \nint main() \n{ \n char * str1=\"ABMABCDDCBAOCECXYYXOPQR\"; \n char * longestpal= fndlong(str1); \n char * point=longestpal; \n int loop=1; \n \n while(loop) \n { \n  cout<<*longestpal; \n  longestpal++; \n  if (point==longestpal) \n  { \n   loop=0; \n  } \n  if(*point==*longestpal) \n   point=longestpal+1; \n } \n cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"program to find longest palindrome: int main() {  int i,j,count=0,check=0,loc=0,pos=0;  string str;  cout<<\"enter string\"< cin>>str;  for(i=1;i {   for(j=i;j  {    if(j-1<0 || j+1>=str.length())     break;    if(str[j-1]==str[j+1])    {     count++;     loc=j;    }    else     break;   }   if (count>check)   {    check=count;    pos=loc;   }  }  for(int k=(pos-check);k<=(pos+check);k++)   cout<}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A very good O(n2) easy to follow code is available in technicalypto.com/2010/02/find-all-possible-palindromes-in-string"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The idea is to go left and right from each element until left will be the beginning, or right will be the end. \nThe initial length of each possible palindrome is 1. \nWe need to distinguish 2 cases: \n \n1). \"Odd\" case, like \"abcdcba\" \n2). \"Even\" case, like \"dcbaabcd\" \n \nIn \"even\" case, we need to shift our \"right\" pointer to one position right and to increasr the current length. \n \nDuring each next move, we increase our current palindrome length on 2, if the left and the right characters are the same. \nWhen palindome stops (we reach the array borders, or our left and right characters are not the same any more), \nwe compare our current palindrome length with the previous maximal length. \n \nvoid FindLongestPalindrome(char Arr[]) \n{ \n char* pCurr; // moving through our string \n char* pBegin; // the beginning of the string \n char* pEnd; // the end of the string \n char* pLeft; // to go left from the current character \n char*pRight; // to go right from the current character \n \n int iMaxIndex=0; \n int iCurIndex=0;  \n int iMaxLength=1; \n int iLength; \n \n pCurr=pBegin=&Arr[0]; \n pEnd=pBegin; \n  \n while(1) \n { \n pEnd++; \n if(*pEnd=='\\0') break; \n } \n    // now pEnd points to the end of our array  \n \n while(1) // go through the array \n { \n  iLength=1; \n \n  //Odd case: \n  pLeft=pRight=pCurr; \n  //even case: \n  if((*pLeft)==(*pRight+1)) \n  { \n   pRight++; \n   iLength++; \n   if(pRight>pEnd) break; \n  } \n \n  while(1) \n  { \n           if((*pRight) != (*pLeft)) break; \n      \n     pLeft--; \n     pRight++; \n     if((pLeftpEnd)) break; \n \n     iLength = iLength+2; // because we add characters from the left and from the right \n  } \n \n  if(iLength > iMaxLength) \n  { \n           iMaxLength = iLength; \n     iMaxIndex = iCurIndex; \n  } \n   \n  pCurr++; \n  if(pCurr>pEnd) break; \n  iCurIndex++; \n } \n \n // Now we have iMaxIndex as the beginning of longest palindrome, and iMaxLength as it's length \n     \n for(int i=iMaxIndex; i<=iMaxIndex+iMaxLength; i++) \n printf(\"%c\", Arr[i]); \n printf(\"\\n\"); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Reverse the string and compare using a shifting window."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def updateMax(palinIndex, palinLen, maxPalinLen, maxPalinIndex, i): \n    if palinLen>maxPalinLen: \n        maxPalinLen=palinLen \n        maxPalinIndex=palinIndex \n    palinLen=0 \n    palinIndex=i \n    return palinIndex, palinLen, maxPalinLen, maxPalinIndex \n         \ndef longestPalindrome(s): \n    pi=0 #Palindrome Index \n    pl=0 #Palindrome Length \n    lpl = -1 #Longest Palindrome Index \n    lpi = -1 #Longest Palindrome Length \n     \n    for i, c in enumerate(s): \n        if i==0: \n            continue \n        if s[pi]==c: \n            if (pi>0): \n                pi-=1 \n                pl+=2 \n            else: \n                pi, pl, lpl, lpi=updateMax(pi, pl, lpl, lpi, i) \n        else: \n            pi, pl, lpl, lpi=updateMax(pi, pl, lpl, lpi, i) \n    pi, pl, lpl, lpi=updateMax(pi, pl, lpl, lpi, i) \n    return s[lpi+1:lpi+lpl+1] \n \ns=\"ldsfkjoeiwrjwelskzdjfsdaasdfgfdfghjkllkjhgfdlkfherqriuthekdfsnvgkjwnoirjsefdq\" \nprint longestPalindrome(s)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Read about Manacher's Algorithm"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Whaqt about below solution, let me know if any bug is there, inputs tested are  LongestPalindrome(\"aabcbcdab\");           LongestPalindrome(\"aaaaa\");            LongestPalindrome(\"abbba\");            LongestPalindrome(\"this is a a uyt this is a a si si\");            LongestPalindrome(\"abeeddddeabe\");    public static void LongestPalindrome(string a)         {              string isPalindrome = \"\";             string largestPalindrome = \"\";             int j, k;             for (int i = 0; i < a.Length - 1;i++)             {                 k = i + 1;                 j = i - 1;                       if (j >= 0 && k < a.Length)                 {                     if (a[i] == a[j] && a[i] == a[k])                     {                         j--; k++;                     }                 }                  if (j > 0 && k < a.Length)                 {                      if (a[i] == a[j])                         j--;                     else if (a[i] == a[j])                     {                         k++;                     }                 }                 while (j >= 0 && k < a.Length)                 {                     if (a[j] != a[k])                         break;                     else                     {                         j--;                         k++;                     }                     isPalindrome = a.Substring(j + 1, k - j - 1);                     if (isPalindrome.Length > largestPalindrome.Length)                     {                         largestPalindrome = isPalindrome;                     }                 }             }             Console.WriteLine(largestPalindrome);            }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int[] getLongest(String str){ \n  char[] data = str.toCharArray(); \n  int[] index = new int[data.length]; \n  int[] buffer = new int[256]; //store pre index \n  int max = 0; \n  int[] span = new int[2]; \n   \n  for(int i = data.length - 1; i >= 0; i--){ \n   index[i] = buffer[data[i]] == 0 ? -1 : buffer[data[i]]; \n   buffer[data[i]] = i; \n  } \n    \n  for(int i = 0; i < index.length && index[i] != -1 ; i++){ \n   int cur = i; \n   int j = index[i]; \n   while(j != -1){ \n    for(; j != -1; j = index[j]){ \n     if(isPaloindromes(data,cur,j) == true){ \n      if(max < j - cur + 1){ \n       max = j - cur + 1; \n       span[0] = cur; \n       span[1] = j; \n      } \n     } \n    } \n    int tmp = cur; \n    index[tmp] = -1; \n    cur = index[cur]; \n    j = cur == -1 ? -1 : index[cur]; \n   } \n  } \n  return span; \n } \n  \n public static boolean isPaloindromes(char[] data, int i, int j){ \n  int mid = (i + j) / 2; \n  for(int k = 0; k < mid; k++){ \n   if(data[i + k] != data[j - k]) \n    return false; \n  } \n  return true; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I choose maintainability over performance until performance testing shows the code to be a bottleneck."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"{{package mic01;  public class LongestPalindrome {   public static void main(String[] args) {      String dummy = \"AAABBGFF ili ollo benmio ooloo eo sadkjansd evbnbve eikdo ooooooooookoooooooooo\";      System.out.println(letsDoThis(dummy));      }   private static String letsDoThis(String dummy) {   String result = null;   int max = 0;   String[] a = dummy.split(\" \");   for(int i=0; i   if(isPalindrome(a[i])){     if(a[i].length() > max)      result = a[i];    }   }   return result;  }   private static boolean isPalindrome(String string) {    int length = string.length();   if(length % 2 == 0)    return false;   else{    for(int i=0; i    if(string.charAt(i) != string.charAt(length-i-1)){      return false;     }    }   }    return true;  }  }  }}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13575664","download_status":"DOWNLOAD_DONE","votes":"3","answersCount":"82","title":"Q1.- Written exam (Amazon, Bangalore)  Given a singly link list and a number 'K', swap the Kth node from the start with the Kth node from the last. Check all the edge cases.  Sample Input: 1->2->3->4->5->6->7->8 and K = 3 Sample Output : 1->2->6->4->5->3->7->8  Sample Input: 1->2->3->4->5->6->7->8 and K = 10 Sample Output: print error \"LIST IS OF LESSER SIZE\".","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"18","title":"This can be done in line without first completely traversing the list to check the size. This can be done with 3 pointers.   One pointer is for the first element which is k from the start the second pointer is for the element which is k from the end the last pointer is to find the end.  Then you traverse the list save the pointers and do the swap at the end, you don't even have to mess with the links when swapping, just swap the values from the pointers you have saved from above."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"We need to handle a few test cases. 1. Both nodes are end nodes. 2. Both nodes are adjacent. 3. Both nodes are somewhere else. 4. Both node are same. 5. kth node doesn't exist.  I prefer swapping the nodes rather than values. It is always advisable to swap the nodes as in general, nodes may contain several data. So, it will be overhead to swap the values.  Steps: Find the kth node[p] from the beginning. If no kth node, return. Take another pointer[q] & move it at head. Move it & the kth node one step at a time until kth node is null.   q is the kth node from the last.  We need to swap p & q.  The part of linked list found is: t1->p->t2   and t3->q->t4 Just swap the nodes based on links & handle the corner cases mentioned above. Here is the code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Take 3 pointers to the starting point of the list - P1, P2 & P3.  Start moving P1 & P3 till you have moved 'K'  nodes. If the list ends before P1 reaches the End, give the error message \"LIST IS OF LESSER SIZE\". Once you have reached the Kth node, move P1 and P2 pointers to the next node one by one till P1 reaches the end.  At this point P2 points to the Kth element from the last. Now simply swap the values of P2 & P3.  Job done."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public static void swap(LinkedList ll,int k){ \n  int size = ll.size(); \n  if(1<=k&&k<=size){ \n   int firstK = ll.get(k-1); \n   int lastK=ll.get(size-k); \n   ll.set(k-1, lastK); \n   ll.set(size-k, firstK); \n   System.out.println(ll); \n  }else{ \n   System.out.println(\"ERROR\"); \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algorithm: 1.Get the linked list lenghth. If it is less than 'K' print the error message. O(N) 2.Traverse to the 'K' the element from the beginning. O(N) 3.Traverse to the N-Kth element from the beginning. O(N) 4. Swap them.O(1) 5.End of Algorithm  Complexity: O(N)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Find Kth Element from Beginning. Store the pointer. 2. Using Kth Element, find kth element from last(two pointers) 3. Swap these pointers. 4. At every step, check for length traversed till is < n, otherwise raise error"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node* SwapList(Node* head, int k) \n{ \n if (head == NULL || head->next == NULL) \n { \n  return head; \n } \n  \n Node* current = head->next; \n Node* prev = head; \n int currentCount = 2; \n  \n Node* kth = NULL; \n Node* kthPrev = NULL; \n Node* kthLast = NULL; \n Node* kthLastPrev = NULL; \n  \n while (current != NULL) \n { \n  if (currentCount == k) \n  { \n   kth = current; \n   kthPrev = prev; \n  } \n   \n  if (kthLast != NULL) \n  { \n   kthLastPrev = kthLast; \n   kthLast = kthLast->next; \n  } \n  else if (kth != NULL) \n  { \n   kthLast = head; \n  } \n   \n  prev = current; \n  current = current -> next; \n } \n  \n if (kth == NULL) return head; // kth node does not exist in list \n if (kth == head) // k == 1 \n { \n  kthLast->next = kth->next \n  kth->next = NULL; \n  kthLastPrev->next = kth; \n  return kthLast; // this becomes new head \n } \n  \n  \n if (kthLast == head) \n { \n  kth->next = kthLast->next; \n  kthprev->next = kthLast; \n  kthLast->next = NULL; \n  return kth; \n } \n  \n Node* temp = kth->next; \n kth->next = kthLast->next; \n kthLast->next = temp; \n kthLastPrev->next = kth; \n kthPrev->next = kthLast; \n return head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node* SwapList(Node* head, int k) \n{ \n if (head == NULL || head->next == NULL) \n { \n  return head; \n } \n  \n Node* current = head->next; \n Node* prev = head; \n int currentCount = 2; \n  \n Node* kth = NULL; \n Node* kthPrev = NULL; \n Node* kthLast = NULL; \n Node* kthLastPrev = NULL; \n  \n while (current != NULL) \n { \n  if (currentCount == k) \n  { \n   kth = current; \n   kthPrev = prev; \n  } \n   \n  if (kthLast != NULL) \n  { \n   kthLastPrev = kthLast; \n   kthLast = kthLast->next; \n  } \n  else if (kth != NULL) \n  { \n   kthLast = head; \n  } \n   \n  prev = current; \n  current = current -> next; \n } \n  \n if (kth == NULL) return head; // kth node does not exist in list \n if (kth == head) // k == 1 \n { \n  kthLast->next = kth->next \n  kth->next = NULL; \n  kthLastPrev->next = kth; \n  return kthLast; // this becomes new head \n } \n  \n  \n if (kthLast == head) \n { \n  kth->next = kthLast->next; \n  kthprev->next = kthLast; \n  kthLast->next = NULL; \n  return kth; \n } \n  \n Node* temp = kth->next; \n kth->next = kthLast->next; \n kthLast->next = temp; \n kthLastPrev->next = kth; \n kthPrev->next = kthLast; \n return head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node* SwapList(Node* head, int k) \n{ \n if (head == NULL || head->next == NULL) \n { \n  return head; \n } \n  \n Node* current = head->next; \n Node* prev = head; \n int currentCount = 2; \n  \n Node* kth = NULL; \n Node* kthPrev = NULL; \n Node* kthLast = NULL; \n Node* kthLastPrev = NULL; \n  \n while (current != NULL) \n { \n  if (currentCount == k) \n  { \n   kth = current; \n   kthPrev = prev; \n  } \n   \n  if (kthLast != NULL) \n  { \n   kthLastPrev = kthLast; \n   kthLast = kthLast->next; \n  } \n  else if (kth != NULL) \n  { \n   kthLast = head; \n  } \n   \n  prev = current; \n  current = current -> next; \n } \n  \n if (kth == NULL) return head; // kth node does not exist in list \n if (kth == head) // k == 1 \n { \n  kthLast->next = kth->next \n  kth->next = NULL; \n  kthLastPrev->next = kth; \n  return kthLast; // this becomes new head \n } \n  \n  \n if (kthLast == head) \n { \n  kth->next = kthLast->next; \n  kthprev->next = kthLast; \n  kthLast->next = NULL; \n  return kth; \n } \n  \n Node* temp = kth->next; \n kth->next = kthLast->next; \n kthLast->next = temp; \n kthLastPrev->next = kth; \n kthPrev->next = kthLast; \n return head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node* SwapList(Node* head, int k) \n{ \n if (head == NULL || head->next == NULL) \n { \n  return head; \n } \n  \n Node* current = head->next; \n Node* prev = head; \n int currentCount = 2; \n  \n Node* kth = NULL; \n Node* kthPrev = NULL; \n Node* kthLast = NULL; \n Node* kthLastPrev = NULL; \n  \n while (current != NULL) \n { \n  if (currentCount == k) \n  { \n   kth = current; \n   kthPrev = prev; \n  } \n   \n  if (kthLast != NULL) \n  { \n   kthLastPrev = kthLast; \n   kthLast = kthLast->next; \n  } \n  else if (kth != NULL) \n  { \n   kthLast = head; \n  } \n   \n  prev = current; \n  current = current -> next; \n } \n  \n if (kth == NULL) return head; // kth node does not exist in list \n if (kth == head) // k == 1 \n { \n  kthLast->next = kth->next \n  kth->next = NULL; \n  kthLastPrev->next = kth; \n  return kthLast; // this becomes new head \n } \n  \n  \n if (kthLast == head) \n { \n  kth->next = kthLast->next; \n  kthprev->next = kthLast; \n  kthLast->next = NULL; \n  return kth; \n } \n  \n Node* temp = kth->next; \n kth->next = kthLast->next; \n kthLast->next = temp; \n kthLastPrev->next = kth; \n kthPrev->next = kthLast; \n return head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void swapElementsInLinkedList(int k){   if(k<0 || k> getSize() ){    throw new InvalifIndexException(\"LIST IS OF LESSER SIZE/LIST SIZE CANT BE NEGATIVE\");   }   temp = head ;   LinkedListNode KthnodeFromRear = null;   int newValueForK = (getSize()-k)+1;   int counter = 1;   int firstStop = 0;   int lastStop = 0;   if(k   firstStop = k;    lastStop = newValueForK;   }   else{    firstStop = newValueForK;    lastStop = k;   }     while(counter != firstStop){         counter ++;         temp=temp.getNext();          }       KthnodeFromRear = temp;     while(counter!=lastStop){         counter ++ ;         KthnodeFromRear = KthnodeFromRear.getNext();         }         swap(temp,KthnodeFromRear);          }      private void swap(LinkedListNode first, LinkedListNode last) {   Integer data = first.getData();   first.setData(last.getData());   last.setData(data);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void replace_node(struct node **head,int pos) \n{ \n        int count = 1; \n        int tmp =0; \n        myNode *curr = *head; \n        myNode *one = curr; \n        myNode *two = curr; \n        while(two != NULL && two->next !=NULL && count next; \n                count++; \n        } \n        curr = two; \n        while(one!=NULL &&one->next!=NULL&& two->next!=NULL) \n        { \n                one = one->next; \n                two = two->next; \n        } \n        tmp = curr->value; \n        curr->value = one->value; \n        curr = one; \n        curr->value = tmp; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void replace_node(struct node **head,int pos) \n{ \n        int count = 1; \n        int tmp =0; \n        myNode *curr = *head; \n        myNode *one = curr; \n        myNode *two = curr; \n        while(two != NULL && two->next !=NULL && count next; \n                count++; \n        } \n        curr = two; \n        while(one!=NULL &&one->next!=NULL&& two->next!=NULL) \n        { \n                one = one->next; \n                two = two->next; \n        } \n        tmp = curr->value; \n        curr->value = one->value; \n        curr = one; \n        curr->value = tmp; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int kthnodeswap (node*& head, int k) \n{ \n \n    if (k<=0) //invalid node given \n        return -1; \n    else \n    { \n        if (k==1) //swap head node and last when index = 1 \n        { \n            node *trav = head; \n \n            //move till the end of the list \n            while (trav->next!=NULL) \n                trav = trav->next; \n \n            //swap head and last node \n            int temp = head->data; \n            head->data = trav->data; \n            trav->data = temp; \n            return 1; \n        } \n        else \n        { \n            node *trav = head; //pointer to traverse the list \n            node *swap1 = trav; //pointer which will point to the kth node from beginning \n            node *swap2 = trav; //pointer which will point to the kth node from end \n \n            //advance both traverse pointer and the beginning pointer till kth node \n            for (int i = 2; i <= k ; i++) //index starts at 2 since 1st node is head \n            { \n                trav = trav->next; \n                if (trav == NULL) return 0; //list is of lesser size \n                swap1 = trav; //advance two pointers to the same location \n            } \n \n            //after reaching the kth node from beginning advance the traverse pointer and end pointer \n            while (trav->next != NULL) \n            { \n                trav = trav->next; \n                swap2 = swap2->next; \n            } \n \n            //swap the data pointed by beginning pointer and end pointer \n            int temp = swap1->data; \n            swap1->data = swap2->data; \n            swap2->data = temp; \n            return 1; \n \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int list_swap(snode *head,int pos) \n{ \n    snode *tmp; \n    int ll=0; \n    int cnt=1; \n    snode *curr    =    NULL; \n \n    for(tmp = head;tmp;tmp=tmp->next)  \n            ll++; \n     \n    for(tmp = head;cnt < pos;cnt++)  \n            tmp=tmp->next; \n \n    /*Found from head node*/ \n     \n    curr    =    tmp; \n    while((ll-cnt) != pos-1) \n    { \n        tmp    =    tmp->next; \n        cnt++; \n    } \n    /*Now swapping the data part*/ \n    cnt    =    tmp->data; \n    tmp->data    =    curr->data; \n    curr->data    =    cnt; \n    return(0);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void swaplist(Node** list,int K) \n{ \n if (K<1)  \n  return; \n int count=1; \n Node* first=*list; \n while (count++next; \n if (first==0) { \n  cout << \"not available\\n\"; \n  return; \n } \n Node* tmp=first; \n first=first->next; \n Node* second=*list; \n while (first) { \n  first=first->next; \n  second=second->next; \n } \n swap(tmp1,second);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is working code and covers almost all the cases and boundries:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Fellas.. this ain't a Big Complex Code.. Its tricky question...  Algo. 1> Get kth Node from last and kth node from beginning. 2> Hold one pointer each to these nodes. 3> Swap their values.. :D   Code               struct Node* Swapkth(struct Node * node,int k)               {                 struct Node *temp1,*temp2,*temp3;                 temp1=node;                   while(k!=0) {                                           node=node->next;                        }                     temp2=node;// this is kth node from first                                         while(node->next!=NULL) {                                node=node->next;                                temp1=temp1->next;                           }                    //Finally when loop exits temp1 will be  pointing to the kth node from the last.                  temp3=temp1;                  temp1->data=temp2->data;                  temp2->data=temp3->data;               free(temp1);               free(temp2);               free(temp3);              }   This is all U need... No Swapping No Complex Code.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Fellas.. this ain't a Big Complex Code.. Its tricky question...  Algo. 1> Get kth Node from last and kth node from beginning. 2> Hold one pointer each to these nodes. 3> Swap their values.. :D   Code               struct Node* Swapkth(struct Node * node,int k)               {                 struct Node *temp1,*temp2,*temp3;                 temp1=node;                   while(k!=0) {                                           node=node->next;                        }                     temp2=node;// this is kth node from first                                         while(node->next!=NULL) {                                node=node->next;                                temp1=temp1->next;                           }                    //Finally when loop exits temp1 will be  pointing to the kth node from the last.                  temp3=temp1;                  temp1->data=temp2->data;                  temp2->data=temp3->data;               free(temp1);               free(temp2);               free(temp3);              }   This is all U need... No Swapping No Complex Code.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/*Q1.- Written exam (Amazon, Bangalore)  Given a singly link list and a number 'K', swap the Kth node from the start with the Kth node from the last. Check all the edge cases.  Sample Input: 1->2->3->4->5->6->7->8 and K = 3 Sample Output : 1->2->6->4->5->3->7->8  Sample Input: 1->2->3->4->5->6->7->8 and K = 10 Sample Output: print error \"LIST IS OF LESSER SIZE\"*/ #include #include struct node *recursion(struct node *,int ); /* void append(struct node **,int ); void display(struct node *);  here is problem is that void  you will get warning warning: ??struct node?? declared inside parameter list [enabled by default] amazon1.c:12:20: warning: its scope is only this definition or declaration, which is probably not what you want [enabled by default] amazon1.c:13:21: warning: ??struct node?? declared inside parameter list [enabled by default] */ struct node  {   int data;   struct node *link; }; int main() {   struct node *start;   start=NULL;   int n,i=0,item,k;   printf(\"Enter the no of node\\n\");   scanf(\"%d\",&n);   while(i++  {    printf(\"Enter node value\\n\");    scanf(\"%d\",&item);    append(&start,item);      }   display(start);   printf(\"Enter the number k for swaping kth from the fast and kth from last\\n\");   scanf(\"%d\",&k);   swap(start,k,n);   printf(\"\\n\");   display(start); }  append(struct node **t,int b) {   struct node *r,*temp;   r=*t;     if(r==NULL)     {         r=(struct node*)malloc(sizeof(struct node));         *t=r;     }   else     {          while(r!=NULL)         {           temp=r;           r=r->link;         }         temp->link=(struct node *)malloc(sizeof(struct node));         r=temp->link;         /*            If you write like this r=(struct node *)malloc(sizeof(struct node)); then you are creating indepent node which are not connected            to it's previous node.r=NULL then r(struct node *)malloc(sizeof(struct node)); it will not link to the previous node .          */     }      r->data=b;     r->link=NULL;      }  display(struct node *q) {     while(q!=NULL)     {      printf(\"%d-> \",q->data);      q=q->link;     } } swap(struct node *fast,int k,int n) {     struct node *Kth_fast,*Kth_last;     int temp;     if(k>n)        printf(\"Swaping is not possible you enter the number greater than number of element of linklist\\n\");     else     {        Kth_fast=recursion(fast,k);        Kth_last=recursion(fast,n-k+1);     }     temp=Kth_last->data;     Kth_last->data=Kth_fast->data;     Kth_fast->data=temp;   } struct node *recursion(struct node *p,int K) {     int i=1;     while(i++    {       p=p->link;     }      return p; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Complexity: O(n) Space: O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Complexity: O(n) Space: O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapKth(Node *head,int k) \n{ \n  int counter=0; \n  Node *kth=head,*kth_end=head; \n  while(kth && counter++next; \n  if(!kth) return false; \n  counter=0; \n  while(counter ++next; \n  while(head) {head=head->next;kth_end=kth_end->next;} \n  swap(kth->data,kth_end->data); \n  return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapKth(Node *head,int k) \n{ \n  int counter=0; \n  Node *kth=head,*kth_end=head; \n  while(kth && counter++next; \n  if(!kth) return false; \n  counter=0; \n  while(counter ++next; \n  while(head) {head=head->next;kth_end=kth_end->next;} \n  swap(kth->data,kth_end->data); \n  return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapKth(Node *head,int k) \n{ \n  int counter=0; \n  Node *kth=head,*kth_end=head; \n  while(kth && counter++next; \n  if(!kth) return false; \n  counter=0; \n  while(counter ++next; \n  while(head) {head=head->next;kth_end=kth_end->next;} \n  swap(kth->data,kth_end->data); \n  return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapKth(Node *head,int k) \n{ \n  int counter=0; \n  Node *kth=head,*kth_end=head; \n  while(kth && counter++next; \n  if(!kth) return false; \n  counter=0; \n  while(counter ++next; \n  while(head) {head=head->next;kth_end=kth_end->next;} \n  swap(kth->data,kth_end->data); \n  return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapKth(Node *head,int k) \n{ \n  int counter=0; \n  Node *kth=head,*kth_end=head; \n  while(kth && counter++next; \n  if(!kth) return false; \n  counter=0; \n  while(counter ++next; \n  while(head) {head=head->next;kth_end=kth_end->next;} \n  swap(kth->data,kth_end->data); \n  return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapKth(Node *head,int k) \n{ \n  int counter=0; \n  Node *kth=head,*kth_end=head; \n  while(kth && counter++next; \n  if(!kth) return false; \n  counter=0; \n  while(counter ++next; \n  while(head) {head=head->next;kth_end=kth_end->next;} \n  swap(kth->data,kth_end->data); \n  return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"you can just reverse the value."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if (indexToBeSwapped < 0 || indexToBeSwapped > inputList.Count - 1)                 return;             int indexFromLast = inputList.Count - indexToBeSwapped;             int temp = inputList[indexToBeSwapped];             inputList[indexToBeSwapped] = inputList[indexFromLast];             inputList[indexFromLast] = temp;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There is no need to swap the node. Just swap the value. That's it,"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapList(Node* head, int k) {     int count = 0;     Node *p1, *p2, *end;     p1 = p2 = end = head;      while (count < k-1)     {         if (0 != end->next)         {             end = end->next;             count++;         }         else         {             return false;         }     }      p1 = end; // fix the first pointer      while (0 != end->next)     {         end = end->next;         p2 = p2->next;     }// fix the position of second pointer      // swap the data values in the two pointer p1 and p2     p1->data = p1->data + p2->data;     p2->data = p1->data - p2->data;     p1->data = p1->data - p2->data;      p1 = p2 = end = 0;     return true; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapList(Node* head, int k) \n{ \n    int count = 0; \n    Node *p1, *p2, *end; \n    p1 = p2 = end = head; \n \n    while (count < k-1) \n    { \n        if (0 != end->next) \n        { \n            end = end->next; \n            count++; \n        } \n        else \n        { \n            return false; \n        } \n    } \n \n    p1 = end; // fix the first pointer \n \n    while (0 != end->next) \n    { \n        end = end->next; \n        p2 = p2->next; \n    }// fix the position of second pointer \n \n    // swap the data values in the two pointer p1 and p2 \n    p1->data = p1->data + p2->data; \n    p2->data = p1->data - p2->data; \n    p1->data = p1->data - p2->data; \n \n    p1 = p2 = end = 0; \n    return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have written and tested the following code ... its working"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hi guys , below is the code with 2 pointers..difference between pointers is k... slow  pointer is behind k positions of fast pointers.  There is a check before getting the k(th) element from the first and k(th) element from the last..which you can see in the following loop:           for( i = 1; i< k; i++){    fast = fast.getNext();    if(fast == null){     System.out.println(\"List is of size:: \" + i + \"  which is lesser then::\" + k);     return;    }   }     Please find the code below , this is a method in a linked list class, which access the head of the list using this.getHead() method.  and swaps the values in the last..  public void replaceKthCharacter(int k){      Node  kthElementFromStart,slow , fast;   slow =  fast = this.getHEAD();      if(slow == null || fast == null){    System.out.println(\"List is empty..\");    return;   }      int i;      for( i = 1; i< k; i++){    fast = fast.getNext();    if(fast == null){     System.out.println(\"List is of size:: \" + i + \"  which is lesser then::\" + k);     return;    }   }       kthElementFromStart = fast ;      while(fast != null && fast.getNext() != null){    fast = fast.getNext();    slow = slow.getNext();   }      String tmpKey = kthElementFromStart.getKey();   kthElementFromStart.setKey(slow.getKey());   slow.setKey(tmpKey);        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Its Easy, please do as explained below.  1.take 2 pinters say ptr1 and ptr2 and assign the root node address. 2.Move the ptr2 for the k times,this the pointer you have to swap keep the address with you. 3.Now move the both the pointer ptr1 and ptr2 both at time, the moment ptr2 reach to null, note down the ptr1. 4.swap the ptr1 and once node which you have restored before.  complexity is O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nstruct node \n{ \n    int info; \n    struct node *link; \n}; \nstruct node *create(struct node *start, int data); \nvoid exchange(struct node *start, int k); \nvoid display(struct node *start); \n \nint main() \n{ \n  int data,ans,k; \n  struct node *start=NULL; \n  do \n  { \n       cout<<\"Enter the value\"<>data; \n         start=create(start,data); \n         cout<<\"do you want to add another node?\"<>ans; \n    }while(ans==1); \n    display(start); \n    cout<<\"enter the position\"; \n    cin>>k; \n    exchange(start,k); \n    display(start); \n  getch(); \n  return 0; \n} \n \nvoid exchange(struct node *start, int k) \n{ \n   int count=0,s,i; \n   struct node *p,*q,*p1,*q1,*temp; \n   p=start; \n   q=p; \n   while(p!=NULL) \n   { \n          count++; \n          p=p->link; \n     } \n     try \n     { \n       if(k>count) \n         throw k; \n     //cout<<<<\" is the count\"<link; \n     } \n     s=count-k; \n     for(i=0;ilink; \n     } \n     if(p==q1) \n     { \n     int swap; \n     swap=p->info; \n     p->info=q->info; \n     q->info=swap; \n     return; \n     } \n     temp=q->link; \n     p1->link=q; \n     q->link=p->link; \n     q1->link=p; \n     p->link=temp; \n      \n     } \n     catch(int) \n     { \n     cout<<\"out of bounds\"<info=data; \n          start->link=NULL; \n          return start; \n  } \n  while(p->link!=NULL) \n  { \n          p=p->link; \n     } \n     temp=new node; \n     temp->info=data; \n     temp->link=NULL; \n     p->link=temp; \n     return start; \n} \n \nvoid display(struct node *start) \n{ \n   struct node *p=start; \n   while(p!=NULL) \n   { \n   cout<info; \n   if(p->link!=NULL) \n     cout<<\"->\"; \n   p=p->link; \n     } \n     cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"swapKthNode(node *head){ \n    temp=head \n    while(k!=1){ \n        if (head == NULL) return \"ERROR\"; \n        head = head->next; \n        k--; \n    } \n    first_node=head; \n    while(head->next!=NULL){ \n        head = head->next; \n        temp = temp->next; \n    } \n    second_node = temp; \n    swap(first_node->data, second_node->data) \n \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// (assuming k=0 means swap root and tail) \nNode* swapK (Node* head, int k) { \n \n Node* p1, p2, temp; \n int n = 1; \n  \n // no list, nothing to swap..  \n if (head == null || head->next = null) \n  return head; \n  \n // count length of list \n // optimized here to save time for k=0 below \n p1 = head; \n while(p1->next != null) { \n  p1 = p1->next; \n  n++; \n } \n  \n // negative values of k and k greater \n // then length of list are not valid \n if (k < 0 || k > n) \n  return NULL; // should actually throw error here \n \n // normalize k \n if (k > n/2) \n  k = n-k; \n   \n // special case if k=0 or k=n \n if (k == 0) { \n  // set p1 = 2nd to last node \n  p1 = head; \n  for (int i = 1; i < n-1; i++) \n   p1 = p1->next; \n  // set p2 = last node \n  p2 = p1->next; \n   \n  // set last node to point to 2nd node \n  p2->next = head->next; \n  // set 2nd to last node to point to head \n  p1->next = head; \n  // set head to point to nothing (it is now the last node) \n  head->next = null; \n   \n  // return the new head (p2) \n  return p2; \n } \n   \n // set p1 to (k-1)th node \n p1 = head; \n for (int i = 1; i < k; i++) { \n  p1 = p1->next; \n } \n // set p2 to (n-k-1)th node \n p2 = p1->next; \n for (int i = k; i < n-2k; i++) { \n  p2 = p2->next; \n } \n  \n // swap p1's next and p2's next \n temp = p1->next; \n p1->next = p2->next; \n p2->next = p1->next; \n // swap p1 next's next and p2 next's next \n temp = p1->next->next; \n p1->next->next = p2->next->next; \n p2->next->next = p1->next->next; \n  \n return head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void fn(node * start) \n  { \n     if(K>N)// if n given else traverse inO(n) to find the length \n       printf(\"ARRAY IS OF LESSER  SIZE\") \n    else \n   { \n        int traverse=0,count=0; \n        if(K>N-K) \n          traverse=N-K; \n       else traverse=K; \n      node * one ,*two; \n      one=start; \n      while(count++!=traverse) \n         one=one->next; \n      two=one; \n     traverse=abs(2*K-N) \n     count=0 \n     while(count++!=traverse)two=two->next \n     swap(one->data,two->data); \n     } \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void move_the_node(struct link_list **node, int mov) {         struct link_list *start_ptr, *end_ptr, *length_ptr;         int i=0,j;         if((*node)->next == NULL)         printf(\"No swapping..since list is empty\\n\");         else         {                 length_ptr = (*node);                 while(length_ptr)                 {                         i++;                         length_ptr = length_ptr->next;                 }                 if(i <= mov)                 printf(\"Cant swap..since no enough nodes\\n\");                 else{                 end_ptr = start_ptr = (*node);                 for(j=0; j                start_ptr = start_ptr->next;                 for(j=0; j<(i-mov-1); j++)                 end_ptr = end_ptr->next;                 i = end_ptr->data;                 end_ptr->data = start_ptr->data;                 start_ptr->data = i;                 }         } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"don't u think the question is too easy.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void swapListNodes(int swapPosition)             {                 Node advPointer = first;                 Node normalPointer = first;                 Node tempNode = first;                 Node iterator = first;                 int tempdata = 0;                 int loop = 1;                  if (swapPosition > count) return;                                while (loop < swapPosition)                 {                     if (iterator.next != null)                     {                         advPointer = iterator.next;                         iterator = iterator.next;                         loop++;                     }                 }                  tempNode = advPointer;  // at 3rd position from start                  while (advPointer.next != null)                 {                     advPointer = advPointer.next;                     normalPointer = normalPointer.next;                 }                                   tempdata = normalPointer.data;                 normalPointer.data = tempNode.data;                 tempNode.data = tempdata;             }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void swapkelement(struct list **l,int k) { struct list *x = *l; struct list *y; struct list *z = *l; int i; for(i=0 ; i < k  ; i++) { if(x == NULL) {  printf(\"LIST IS OF LESSER SIZE\");  return; } if(i == k-1) y = x; x = x->next; }  while(NULL != x) { z = z->next; x = x->next; }  i = y->data; y->data = z->data; z->data = i; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hey guys pls let me know if this is correct solution.....  void swap(nd *start,int val) { nd *temp; int count=0,j,i=0;  temp=start; while(temp->next!=NULL) { temp=temp->next; count++; } if(count>val) { j=0; temp=start; i=count-val; while(j++<=i) { temp=temp->next; } //p(\"from last %d\\n\",temp->data); count=0; while(count++{ start=start->next; } //p(\"from beg %d\\n\",start->data); //if(start->next==temp)                    //if both elements are adjacent to each other.... //{ int var; var=start->data; start->data=temp->data; temp->data=var; //p(\"list changed...\\n\");  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nint k,t1,t2; \nint x; \nvoid insert1(); \nvoid swap1(); \nvoid swap(); \nstruct Node1 \n{ \n int info1; \n Node1 *next1; \n}; \nNode1 *ptr1,*start1=NULL,*rear1,*save1; \nmain() \n{ \n cout<<\"How many nodes in list\\n\"; \n  \n cin>>x; \n for(int i=0;i>k; \n swap1(); \n //swap(); \n} \nvoid insert1() \n{ \n ptr1=new Node1; \n  \n if(start1==NULL) \n { \n  cout<<\"Enter info\\n\"; \n        cin>>ptr1->info1; \n  start1=ptr1; \n  ptr1->next1=NULL; \n  rear1=ptr1; \n } \n else \n { \n  cout<<\"Enter info\\n\"; \n        cin>>ptr1->info1; \n  rear1->next1=ptr1; \n  ptr1->next1=NULL; \n  rear1=ptr1; \n } \n} \nvoid swap1() \n{ \n int cnt=0; \n save1=start1; \n while(save1) \n { \n  cnt=cnt+1; \n  cout<<\"\\n\"<<\"COUNT HERE\\n\"; \n  cout<<\"\\n\"<info1; \n   \n  } \n   //save1=save1->next1; \n  if(cnt==(x-k) ) \n  { \n   t2=save1->info1; \n    \n  } \n  save1=save1->next1; \n   \n } \n int temp; \n temp=t1; \n t1=t2; \n t2=temp; \n cout<<\"VALUES INTERCHANGED\\n\\n\\n\"<<<\"\\t\"<info1; \n while(save1) \n { \n  save1=save1->next1; \n  cout<<\"\\n\"<info1; \n } \n} \nvoid swap() \n{ \n  \n}*/ \n      \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void swapindex(list L,int index){ List lst=new LinkedList(L); swap(lst,lst.get(index),lst.get(lst.size()-index)); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The running time is O(N) and hardly any space complexity .. the only trick here is to maintain the height of the node in the node object and the length of the linked list in the linkedlist instance   Here is the python implementation"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I simply did this by getting the two nodes from the get node function and then swapped the two. i got the answer correctly.   public LinkedListNode getNode(int index){   String str;   LinkedListNode prevnode = first.getNext();   for(int i=0;i   prevnode = prevnode.getNext();  // reaching the index node.   }   return prevnode;  }    // Swapping the Kth node from first and last alike.  public void specialSwap(int index){   LinkedListNode frontnode = first.getNext();   LinkedListNode lastnode = first.getNext();   frontnode = getNode(index);    // obtain the first node   lastnode = getNode(size()-index+1);  // obtain the last node      // Swap the Nodes values. no need  of breaking the nodes.   String temp = frontnode.getName();   frontnode.setName(lastnode.getName());   lastnode.setName(temp);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nusing namespace std; \n \nstruct node{ \n int data; \n node *next; \n}; \n \nint main() \n{ \n  \n node *list,*nptr,*tptr; \n int item,n,i; \n list=NULL; \n  \n cout<<\"PLEASE.......Type how many nodes that you want    \"; \n cin>>n; \n for(i=1;i<=n;i++) \n { \n  cout<<\"Type your \"<<<\" node item  \"; \n  cin>>item; \n  nptr=new(node); \n  nptr->data=item; \n  nptr->next=NULL; \n  if(list==NULL) \n  { \n   list=nptr; \n   tptr=nptr; \n  } \n  else \n  { \n   tptr->next=nptr; \n   tptr=nptr; \n  } \n } \n tptr=list; \n for(i=1;i<=n;i++) \n { \n   \n  cout<data<<\"    \"; \n  tptr=tptr->next; \n   \n } \n cout<<>k; \n tptr=list; \n first=k-1; \n last=(n-k); \n int mid=(n-k+2); \n node *pptr,*sptr,*wptr=NULL,*temp2=NULL,*temp1=NULL; \n int count=1; \n tptr=list; \n for(i=1;i<=n;i++) \n { \n   \n  if(count==first) \n  { \n   pptr=tptr; \n   temp2=pptr->next; \n  } \n  else if(count==last) \n  { \n   sptr=tptr; \n   temp1=sptr->next; \n    \n  } \n  else if(count==mid) \n  { \n   wptr=tptr; \n    \n  } \n  tptr=tptr->next; \n  count++; \n   \n   \n } \n int d; \n d=(n/2); \n if(d!=k) \n { \n   \n  temp1->next=pptr->next->next; \n   \n   \n  pptr->next=temp1; \n   \n   \n   \n  sptr->next=temp2; \n   \n   \n  temp2->next=wptr; \n } \n  \n else  \n { \n  pptr->next=temp1; \n  temp1->next=sptr; \n  sptr->next=wptr; \n } \n  \n  \n int g; \n  \n for(g=1;g<=n;g++) \n { \n  cout<data<<\"   \"; \n  tptr=tptr->next; \n   \n } \n  \n    cout<<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void mainwork() \n { \n//initialise to start. \n//count is the length of link list \n//n is the position at which swap needs to be made. \n temp=p; \n int count=0; \n while(temp!=NULL) \n { \n count++; \n temp=temp->link; \n } \n int n=4; \n prev=p; \n curr=prev->link; \n next=curr->link; \n for(int i=0;ilink; \n  curr=curr->link; \n  next=next->link; \n } \n prev1=p; \n curr1=prev1->link; \n next1=curr1->link; \n for(i=0;ilink; \n  curr1=curr1->link; \n  next1=next1->link; \n } \n //cout<<\"\\n\"<data<<\",\"<data; \n \n if(nlink=curr1; \n curr1->link=next; \n prev1->link=curr; \n curr->link=next1; \n } \nelse \n{ \n \ncout<<\"Cant perform this operation\"; \n \n} \n \n \n \n \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n \nstruct node { \n int data; \n struct node *link; \n}; \n \nint append(struct node **q,int num) { \n struct node *temp, *r; \n temp = *q; \n if(temp == NULL) { \n  temp = (struct node *) malloc(sizeof(struct node)); \n  temp->data = num; \n  temp->link = NULL; \n  *q = temp; \n  return 0; \n } \n while(temp->link != NULL) \n  temp = temp->link; \n r = (struct node *) malloc(sizeof(struct node)); \n r->data = num; \n temp->link = r; \n return 0; \n} \n \nint display(struct node *q) { \n struct node *temp = q; \n while(temp != NULL) { \n  printf(\"data = %d\\n\",temp->data); \n  temp = temp->link; \n } \n return 0; \n} \n \nint sizeofl(struct node *temp) { \n int count = 0; \n struct node *temp1 = temp; \n while(temp1 != NULL) { \n  count++; \n  temp1 = temp1->link; \n } \n return count; \n} \n \nint swap_list(struct node **q,int position) { \n struct node *temp = *q, *ptr1 = *q,*ptr2 = *q; \n int size_list,i,temp_data = 0; \n size_list = sizeofl(temp); \n printf(\"count = %d\\n\",size_list); \n for(i=1; ilink; \n printf(\"ptr1 data = %d\\n\",ptr1->data); \n for(i=0;ilink; \n printf(\"ptr1 data = %d\\n\",ptr2->data); \n temp_data = ptr1->data; \n ptr1->data = ptr2->data; \n ptr2->data = temp_data; \n return 0; \n} \n \nint main() \n{ \n struct node *k = NULL; \n append(&k,1); \n append(&k,2); \n append(&k,3); \n append(&k,4); \n append(&k,5); \n append(&k,6); \n append(&k,7); \n append(&k,8); \n append(&k,9); \n display(k); \n swap_list(&k,3); \n display(k); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void swap(struct node *node1,struct node *node2) {     if(node1 == NULL || node2 == NULL)     {       cout<<\"LIST IS OF LESSER SIZE\"<      return;     }     int temp_data = 0;     temp_data = node1->data;     node1->data = node2->data;     node2->data = temp_data;     struct node *temp = start;     while(temp->next != NULL)     {        cout<data<<\"->\";        temp = temp->next;     }     cout<data<}  void trav_swap(int K) {     int curr = 1;      struct node *temp = start;     struct node * node1 = NULL, *node2 = NULL;     if(K == 0)     {       cout<<\"INVALID INPUT\"<      return;     }     while(temp != NULL && curr != K)     {                temp = temp->next;                curr++;     }     if(curr == K)     {         node1 = temp;         node2 = start;         while(temp->next != NULL)         {            temp = temp->next;            node2 = node2->next;         }     }     swap(node1,node2);      }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void swap(struct node *node1,struct node *node2) \n{ \n    if(node1 == NULL || node2 == NULL) \n    { \n      cout<<\"LIST IS OF LESSER SIZE\"<data; \n    node1->data = node2->data; \n    node2->data = temp_data; \n    struct node *temp = start; \n    while(temp->next != NULL) \n    { \n       cout<data<<\"->\"; \n       temp = temp->next; \n    } \n    cout<data<next; \n               curr++; \n    } \n    if(curr == K) \n    { \n        node1 = temp; \n        node2 = start; \n        while(temp->next != NULL) \n        { \n           temp = temp->next; \n           node2 = node2->next; \n        } \n    } \n    swap(node1,node2); \n     \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use double linked list & two pointers,one from first till our k value and another from last till our k value then exchange the values"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"check skillgun.com for free online tests with java interview questions"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Algorithm: 1.Get the linked list lenghth. If it is less than 'K' print the error message. O(N) 2.Traverse to the 'K' the element from the beginning. O(N) 3.Traverse to the N-Kth element from the beginning. O(N) 4. Swap them.O(1) 5.End of Algorithm  Complexity: O(N)."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13579663","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"47","title":"Q2. F2F Round-1, Amazon(Bangalore)  Given an array of integers having the property that first that array is strictly increasing then it is strictly decreasing, You have to search for a given number.  Constraint: Minimize the complexity","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"since the array is strictly increasing first then strictly decreasing, therefore for the increasing part of the array if, i+1=j then definitely a[i] we can use modified binary search to search the array.  consider the array int[] arr = new int[] {1,3,5,7,19,221,132,56,8,6,4,2,1,-3,-17};  here we need to find k such that, for three consecutive elements i, k, j, a[i] a[j]  step 1 :   so, first we need to find the ending of increasing part of the array, lets the end index of increasing part as k.  use a modified binary search to find k"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Find the maximum elements in array - O(logn)  Now if element  > max - Not found  Form two sorted array and do binary search.  Total time O(logn)+O(logx)+O(logn-x)~ OLog(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This question is same as searching in a rotated sorted array"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.iterate over array to find the max by comparing arr[i] and arr[i+1] where arr[i] >arr[i+1] 2.if key is greater than arr[i] then search in upper index  of array 3.else search in lower index"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.iterate over array to find the max by comparing arr[i] and arr[i+1] where arr[i] >arr[i+1] 2.if key is greater than arr[i] then search in upper index  of array 3.else search in lower index"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"find out the critical point and then recursively search in both part"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"find out the critical point and apply binary search"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we can reduce the complexity to O(logn) by finding our the highest number also by using binary search..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"two points at a time first and the last  step 1:if(arr[start+i]==k || arr[end-i]==k) found k; else recurse(arr,start+i,end-i)  O(lgn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"two points at a time first and the last  for i 0 to len/2 step 1:if(arr[start+i]==k || arr[end-i]==k) found k; else recurse(arr,start+i,end-i)  O(lgn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int getMaxFromRotatedSortedList(int [] array){   int start = 0;   int end = array.length -1;   while(start<=end){    int mid = (start+end)/2;       if(array[mid]>array[mid+1]&&array[mid]>array[mid-1])     return mid ;     if(array[mid]     start = mid+1;      }else {      end = mid -1;     }    }    return -1 ;  }   public static int orderbinarySearch(int[]array, int start, int end,int key,boolean order){   while(start   int mid =(start+end)/2;    if(array[mid]==key)     return mid;    if(order){       if(key    end = mid;       else     start = mid +1;    }else{       if(key>array[mid])     end = mid;       else     start = mid +1;       }}   return -1;    }   public static void main(String [] args){   int [] newArray ={1,2,3,4,5,6,7,8,43,100,107,111,120,89,78,67,56,34,23,10};   int maxElementIndex = getMaxFromRotatedSortedList(newArray);   System.out.println(\"max element is\"+getMaxFromRotatedSortedList(newArray));   int c = orderbinarySearch(newArray,0,maxElementIndex,23,true);   boolean found = false;   if(c==-1){    c = orderbinarySearch(newArray,maxElementIndex,newArray.length-1,23,false);    if (c!=-1) found = true ;   }else{    found = true;   }     if(found){     System.out.println(\"the index of the key is\"+c);   }else {    System.out.println(\"key is not present \");   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int getMaxFromRotatedSortedList(int [] array){   int start = 0;   int end = array.length -1;   while(start<=end){    int mid = (start+end)/2;       if(array[mid]>array[mid+1]&&array[mid]>array[mid-1])     return mid ;     if(array[mid]     start = mid+1;      }else {      end = mid -1;     }    }    return -1 ;  }   public static int orderbinarySearch(int[]array, int start, int end,int key,boolean order){   while(start   int mid =(start+end)/2;    if(array[mid]==key)     return mid;    if(order){       if(key    end = mid;       else     start = mid +1;    }else{       if(key>array[mid])     end = mid;       else     start = mid +1;       }}   return -1;    }   public static void main(String [] args){   int [] newArray ={1,2,3,4,5,6,7,8,43,100,107,111,120,89,78,67,56,34,23,10};   int maxElementIndex = getMaxFromRotatedSortedList(newArray);   System.out.println(\"max element is\"+getMaxFromRotatedSortedList(newArray));   int c = orderbinarySearch(newArray,0,maxElementIndex,23,true);   boolean found = false;   if(c==-1){    c = orderbinarySearch(newArray,maxElementIndex,newArray.length-1,23,false);    if (c!=-1) found = true ;   }else{    found = true;   }     if(found){     System.out.println(\"the index of the key is\"+c);   }else {    System.out.println(\"key is not present \");   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the problem complexity is o(log n) the problem is divided into 2 parts. 1)finding maximum point 2)applying binary search on each side of maximum index. to find maximum point: divide the array into 3 parts using n/3 and 2n/3 as indexes. if(a[n/3]then maximum present in the a[n/3] to a[n]; else the maximum present in a[1] to a[2n/3] repeat the  process the complexity for this is o(log n) because the array size is decrimented each time by 1/3rd. now apply binary search on both sides of maximum element..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algo to find the point of inflection, once you get it do binary search in individual parts of the array, time complexity is O(log(n))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algo to find the point of inflection, once you get it do binary search in individual parts of the array, time complexity is O(log(n))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can be done in order of logn  first find point of inflection using a method similar to binary search then call binary search on the left list differently and call binary search on the right list differently"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can be done in order of logn  first find point of inflection using a method similar to binary search then call binary search on the left list differently and call binary search on the right list differently"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is a Bitonic Sequence. Let Mid = (start + end)/2, divides the array in two halves. In this case two cases could happen:  1. The Array is Exactly Increasing/Decreasing in first half and Exactly Decreasing/Increasing in the second half.  2. The Array is Decreasing/Increasing in one half and it is again Bitonic in the other half.  So basically we perform Binary search in the Monotonic sequence and perform Sequential search in the  Bitonic sequence.  Best Case Order : O(log n/2)) + O(log (log n/2)) i.e., Binary search in both halves (Case 1) Worst Case :  O(log n/2) + O(n/2) (Case 2: Which again can be checked recursively and search can be minimized)  Now Major part is to check if the Half is Strictly Increasing or decreasing :  isFirstHalfIncreasing = A[start]< A[mid-1] && A[mid-1][mid] isFirstHalfDecreasing = A[start] > A[mid-1] && A[mid-1] > A[mid] isSecondHalfIncreasing = A[mid] < A[mid+1] && A[mid+1] < A[end] isSecondHalfDecreasing = A[mid] > A[mid+1] && A[mid+1] > A[end]   Algorithm is:  Boolean Sequential_Search(A,start,end,element) {                              if(start == end ) return A[start]==element;            mid = (start+end)/2;            if(A[mid == element]) return true;            return ( isFirstHalfIncreasing OR isFirstHalfDecreasing                                            ?  Binary_Search(A,start,mid-1,element)                                            || Sequential_Search(A,start,mid-1,element) )                   OR (isSecondHalfDecreasing || isSecongHalfIncreasing                                           ? Binary_Search(A,mid+1,end,element)                                          || Sequential_Search(A,mid+1,end,element))  } //End of Sequential Search..  Boolean Binary_Search(A,start,end,element) {                if(start == end ) return A[start]==element;               mid = (start+end)/2;               if(A[mid == element]) return true;             return Binary_Search(A,start,mid-1,element)   ||                                                              Binary_Search(A,mid+1,end,element)   } // End of Binary Search..     Please Correct me if I am wrong. Also please if some one could caluclate the average case, that would be great"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Find the maximum elements in array - O(logn)  Now if element  > max - Not found  Form two sorted array and do binary search.  Total time O(logn)+O(logx)+O(logn-x)~ OLog(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it can be done in O(logn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it can be done in O(log n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class ArrayExample1 { \n \n int[] arr=new int[]{1,2,3,4,5,77,88,90,-56,-45,-23}; \n  \n public void showElements(){ \n  int no=0; \n  for(int i=0, j=1;j"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Store the complete array in hashtable..with numbers. By using Contains value check if the given number exists.. Storing elements in hashtable takes o(n).and..hashtable lookup is o(1)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My idea is same as everyone else: (1) Find the position of the maximum with modified binary search. Call this the \"climax\". (2) Perform binary search from beginning to climax (3) Perform binary search from climax to end  Each is O(logn) so altogether still O(logn). Note that I am also accommodating for the case when the climax is at the beginning or end of the array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #include   int main() {      int arr[] = {10,12,14,17,18,16,11,9,8};     int low = 0,         mid ,         high = lengthof(arr),  // length of array         low1,         low2,         high1,         high2;     int k ;      int temp_low = low,         temp_high = high;      int find = 0;      printf(\"please enter the number to search \\n\");     scanf(\"%d\",&k);      mid = (low + high)/2;      while( low < high)      {                  mid = (low + high) /2;         if ((arr[mid -1] < arr[mid]) && (arr[mid] < arr[mid + 1]))         {            low = mid + 1;         }         else         {            if ((arr[mid -1] > arr[mid]) && (arr[mid] > arr[mid + 1]))            {                 high = mid + 1;            }            else            {               if ((arr[mid -1 ] > arr[mid]) && (arr[mid] < arr[mid + 1]))               {                   high1 = mid;                   low1  = temp_low;                    high2 = temp_high;//This is for descedning order                   low2  = mid + 1;                   break;               }               else               {                   high2 = temp_high;                   low2  = mid + 1;                    high1 = mid;                   low1  = temp_low;                   break;               }             }          }      }  printf( \"high1 = %d  low1 = %d high2 = %d  low2 = %d\\n\", high1,low1, high2, low2);     /* check the number in ascending part*/    while( (low1 <= high1) && (find == 0))    {         mid = (low1 + high1)/2;       if(arr[mid] == k)       {         find = 1;         break;       }       else if (arr[mid] > k)       {         high1 = mid - 1;       }       else if(arr[mid] < k)       {         low1 = mid + 1;       }    }   /* check the num in desc part*/    while ((low2 <= high2) && (find == 0))    {        mid = (low2 + high2) / 2;         if (arr[mid] == k)        {          find = 1;          break;        }        else if (arr[mid] > k)        {           low2 = mid + 1;        }        else if (arr[mid] < k)        {           high2 = mid - 1;        }    }      if (find != 0)    {       printf(\"find postion is : %d \\n\", mid);    }    else    {       printf(\"%d is not present in the array\\n\", k);    }     return(0);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"How about this approach:  1. First find the highest element; If there are elements i,j such that a[i]>a[j], obviously 'i' marked the end of the first list. O(n); 2. Do a binary search on these elements. If it is found, return it. [O(logn)].  3. If it is not there, then search in the decreasing part; For this multiply the numbers 'i+1' till last element with -1 and also the key with -1; O(n) 4. Search using binary search for the key; O(log n); 5. If found, return else terminate with a message saying that the key is not found. So, overall complexity is O(n) + O(log n ) + O(n) + O(log n ) ; 6. Final complexity, is O( n );  If you feel that I need to include anything here, do let me know.  thanks, Pavan"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public static int MaxElementPosition(int[] input, int search)         {             int start = 0, end = input.Length - 1;             int maxPosition = 0;             while (true)             {                 int n = end - start + 1;                  // only 2 elements                 if (n <= 2)                 {                     if (input[end] > input[start])                     {                         maxPosition = end;                     }                     else                     {                         maxPosition = start;                     }                     break;                 }                  if (input[start + n / 3] <= input[start + 2 * n / 3])                 {                     start += n / 3;                     end = start + n - 1;                 }                 else                 {                     end = start + 2 * n / 3 - 1;                 }             }              return input[maxPosition];         }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4846025567109120","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"37","title":"Given a number in an array form, Come up with an algorithm to push all the zeros to the end. Expectation : O(n) solution","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"the original order/arrangement of zeroes is not conserved once they have been pushed to the end."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"void movezeros(int arr[],int n) {       int i,end=n-1;      for(i=0;i    {        if(arr[end]==0)  {   end--;   continue;  }  if(arr[i]==0)  {   arr[i]=arr[i]+arr[end];   arr[end]=arr[i]-arr[end];   arr[i]=arr[i]-arr[end];   i++;  }        } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"here my c++ solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void removeZeros(int arr[], int n) \n{ \n    int i, pos = 0; \n    //copy nonzero numbers to the front \n    for(i = 0; i < n; ++i){ \n        if(arr[i] != 0) arr[pos++] = arr[i]; \n    } \n    //fill tail with zeros \n    for(i = pos; i < n; ++i) arr[i] = 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If one of the array element contains say 10 or 300?? int[] arr = {10, 300, 20, 4}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This O(n) solution iterates over the array with two indexes. If an element is not 0, we copy it to the position of the first index (and advance both indexes), if it is a 0 then we only advance the second index, counting the 0s encountered. When the second index gets to the end, we will have filled up the non-zero digits at the beginning, so we just need to make sure to fill the remaining elements at the end with 0s."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args){ \n  int[] noArrayform = {0,2,0,1,4,5,6,7,0,1,2,3,4,5,0,0,1,4,0}; \n  int[] outputArray = new int[noArrayform.length]; \n  int loopCount = 0; \n  int outputLength = 0; \n \n   \n  //copy the non zero values to the new output array \n  while(loopCount"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would use partition idea in the quick sort. A pointer at the beginning and a pointer at the end. Whenever the beginning pointer encounters a zero, swap the first pointers value with the second one. Then while there is an immediate zero before the second pointer move the second pointer back. Do it while (first pointer < second pointer)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class PushZero { public static void main(String...v){   ArrayDeque num = new ArrayDeque<>();      int arr[] = {1,3,5,0,0,4,6,0};   for(int i=0;i   if(arr[i]==0){     num.addLast(arr[i]);    }    else{     num.addFirst(arr[i]);    }   }   System.out.println(num.size());   for(Iterator itr = num.iterator();itr.hasNext();)  {       System.out.println(itr.next());     } } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void pushZero(int *array, int length) { \n    int zerocount = 0; // var to hold the num of Zeros in the given string \n    //Loop through all the elements of the array \n     \n    for (int i = 0; i < length; i++) { \n        // if element = 0, do nothing, just increment the count \n        if (0 == array[i]) { \n         zerocount++; \n      continue; \n     } \n         \n        //if not, then based on the zerocount, swap the elements \n     if (0 != zerocount) { \n      array[i - zerocount] = array[i]; \n      array[i] = 0; \n     } // end if \n    } // end for \n} // end pushZero()"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can use Partition, which uses \"n - 1\" comparisons and at most \"n - 1\" swaps using a customized comparator which assumes \"0\" is the largest number. Comparator code follows:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/** * Manuel. * Assuming there are 13 integers. Btw: I think the complexity reamins O(n) although I  * have outer loop here. */ #include   void inline swap(int *a, int *b); void pushZeros(int (&arr)[13]); void printArr(int (&arr)[13]);  int main() { int size= 13;  int arr[13]={1,2,3,0,0,0,-3,-4,0,0,1,0,0};  printArr(arr);  std::cout<<\"After pushing the zeros\"<<'\\n';  pushZeros(arr); printArr(arr);   return -1;  }  void printArr(int (&arr)[13]) {  for(int i=0; i < 13 ; i++)  {   std::cout<<\" \"< } }   void pushZeros(int (&arr)[13]) {    int *ptr1= arr;  int *ptr2= arr+ 13 -1;       while(ptr1 < ptr2)  {   while(*ptr1!=0 ) ptr1++;   while(*ptr2==0)  ptr2--;   if(ptr1 < ptr2) swap(ptr1, ptr2);   else break;    ptr1++;   ptr2--;   }    }  void inline swap(int *a, int *b) {  int c= *a;  *a= *b;   *b= c;   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args)  {   int[] array={1,2,0,3,4,0,3};   int length = array.length;   int multiplier = (int)Math.pow(10, length-1);   int num = 0;   for(int i=0;i   num = num + multiplier*array[i];    if(array[i]!=0)     multiplier=multiplier/10;   }   System.out.println(num);    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(int[] array)  {    int length = array.length;   int multiplier = (int)Math.pow(10, length-1);   int num = 0;   for(int i=0;i {    num = num + multiplier*array[i];    if(array[i]!=0)   multiplier=multiplier/10;   }  System.out.println(num);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this is a variant of dutch national flag problem. The solution is simple and can be achieved in o(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  //WAP to shift all zeroes to the end of the array using namespace std;  void sift(int a[],int n) {      int i=0,j=n-1,t;      while(i     {                 while(a[j]==0)                 {                            j--;                 }                   while(a[i]!=0)                  {                  i++;                                    }                  if(i                 {                     t=a[i];                     a[i]=a[j];                     a[j]=t;                  }      }      cout<<\"\\nArray is now:\";      for(int k=0;k       cout<}                                                                               int main() {      int a[100],n;      cout<<\"\\nEnter the number of elements:\";      cin>>n;      for(int i=0;i      cin>>a[i];       sift(a,n);       getch();       return 0;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \nusing namespace std; \n \nvoid moveZeroToEnd( int * data,size_t size) \n{ \n    if(!size) return; \n    size_t lastNonZeroPosition=size-1; \n    while(lastNonZeroPosition&&(!data[lastNonZeroPosition])) lastNonZeroPosition-- ; \n \n    for(size_t i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"j = len(a)  for i in range(j):  while (a[j-1] ==0):   j = j-1  if i == j:   break  if a[i] == 0 and a[j-1] !=0:   temp = a[i]   a[i] = a[j-1]   a[j-1] = temp   j = j-1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// Given a number in an array form, Come up with an algorithm to push all the zeros to the end.  \n// Expectation: O(n) solution \n \n#include  \n \nvoid print(int *arr, size_t size) \n{ \n using namespace std; \n \n for (size_t i = 0; i < size; ++i) \n  cout << arr[i] << ' '; \n cout << endl; \n} \n \nvoid pushZeroToEnd(int *arr, size_t size) \n{ \n int *start = arr; \n int *end = arr + size - 1; \n \n while (start < end) \n { \n  // Find first zero \n  while (*start != 0) ++start; \n \n  // Find last not zero \n  while (*end == 0) --end; \n \n  // Swap \n  *start++ = *end; \n  *end-- = 0; \n } \n} \n \nint main() \n{ \n int arr[] = { 1, 3, 0, 0, 0, 2, 0, 5, 4, 0, 3, 9, 0, 8, 0, 0 }; \n \n size_t size = sizeof(arr) / sizeof(int); \n \n print(arr, size); \n pushZeroToEnd(arr, size); \n print(arr, size); \n \n std::cin.get(); \n \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) \n{ \n int[] input = new int[]{ 0,5,6,0,0,2,4,0}; \n int nzpos = 0; //non-zero-position \n        int DigitToPush = 0; \n for(int i = 0 ; i < input.length; i++) \n { \n  if(arr[i] == DigitToPush)  \n   continue; \n  else \n   input[nzpos++] = input[i]; \n } \n // by this time all nonzero are at correct place; now fill-out rest of zeroes \n for(int j = nzpoz; j < input.length() ; j++) \n {  \n  input[j] = DigitToPush; \n } \n \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void swap(int[] a) {  int i = 0;  int j = a.length() - 1;  //[1,2,0,3,0,5,6,0,8,0]  while(j>i) {   if(a[i] == 0) {    while(j>i) {     if(a[j] != 0) {      int temp = a[j];      a[j] = a[i];      a[i] = temp;      break;     }     j--;    }   }   i++;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void swap(int[] a) {  int i = 0;  int j = a.length() - 1;  //[1,2,0,3,0,5,6,0,8,0]  while(j>i) {   if(a[i] == 0) {    while(j>i) {     if(a[j] != 0) {      int temp = a[j];      a[j] = a[i];      a[i] = temp;      break;     }     j--;    }   }   i++;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void swap(int[] a) {  int i = 0;  int j = a.length() - 1;  //[1,2,0,3,0,5,6,0,8,0]  while(j>i) {   if(a[i] == 0) {    while(j>i) {     if(a[j] != 0) {      int temp = a[j];      a[j] = a[i];      a[i] = temp;      break;     }     j--;    }   }   i++;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void swap(int[] a) {  int i = 0;  int j = a.length() - 1;  //[1,2,0,3,0,5,6,0,8,0]  while(j>i) {   if(a[i] == 0) {    while(j>i) {     if(a[j] != 0) {      int temp = a[j];      a[j] = a[i];      a[i] = temp;      break;     }     j--;    }   }   i++;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do a naive quiqsort implementation"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void PushZereosToEnd(int* arr,int len) {  int posZero = -1;   for(int i = 0; i < len; i++)  {   if(arr[i] == 0 && posZero == -1) //this is the zero index fisrt time    posZero = i;    else if(arr[i] != 0 && posZero != -1) //need to swap   {    int temp = arr[i];    arr[i] = arr[posZero];    arr[posZero] = temp;    posZero++;   }  }   for(int i = 0; i < len; i++)   std::cout<}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int size = (sizeof(arr) / sizeof(int) ) - 1;   for(int i = size,  j = size; i >=0 ;  i--){        if(a[i] == 0){            for(int k = i; k != j; k++){                a[k] = a[k+1];            }            a[j] = 0;            j--;        }    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void zeromove(int *a, int len) \n{ \n        int zero_start = 0; \n        int nonzero_pos = 0; \n \n        while(nonzero_pos < len) { \n                if (a[zero_start]) { \n                        zero_start++; \n                        nonzero_pos++; \n                } else if (!a[nonzero_pos]) { \n                        nonzero_pos++; \n                } else { \n                        swap(a[zero_start++], a[nonzero_pos++]); \n                } \n        } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"void moveZero(int a[]) {  int arrSize = sizeof(a)/sizeof(int);  int end = arrSize - 1;   for (int i = 0; i < arrSize; i++)  {   if ( a[i] == 0 )   {    std::swap(a[i], a[end]);    end--;   }   if (i == end)    break;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"void moveZero(int a[]) {  int arrSize = sizeof(a)/sizeof(int);  int end = arrSize - 1;   for (int i = 0; i < arrSize; i++)  {   if ( a[i] == 0 )   {    std::swap(a[i], a[end]);    end--;   }   if (i == end)    break;  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13580661","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"39","title":"Q1. F2F Round 1 Amazon(Bangalore)  Given a character array as input. Array contains only three types of characters 'R', 'G' and 'B'. Sort the array such that all 'R's comes before 'G's and all 'G's comes before 'B's.  Constraint :- No extra space allowed(except O(1) space like variables) and minimize the time complexity. You can only traverse the array once.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"13","title":"en.wikipedia.org/wiki/Dutch_national_flag_problem"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"threeWayPartition(char data[], int size) \n{ \n   int p = 0; \n   int q = size-1; \n   int i ; \n \n  char t; \n        for ( i = 0; i <= q;) \n        { \n                if (data[i] == 'R') \n                { \n                      t = data[i]; \n                        data[i] = data[p]; \n                        data[p] = t; \n                        ++p; \n                        ++i; \n                } \n \n                else if (data[i] == 'G') \n                { \n                        t = data[i]; \n                        data[i] = data[q]; \n                        data[q] =t; \n                        --q; \n                } \n                else \n                { \n                        ++i; \n                } \n        } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Just maintain count of R, G, and B. And then overwrite whole array. Some thing like below"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"int main() {     int r,g,b,i; char x[] = {'r','r','g','g','b','r','r','r','g','g','b','b','b','g','g','r'} for (i = 0;r = 0,g=0,b=0; x[i] != '\\0' ;} {    if(x[i] == 'r')            r++;    else if(x[i] == 'g')         g++;    else        b++;                  } memset(x,'r',r); memset(x+r,'g',g); memset(x+r+g,'b',b); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void sortAnArrayInParticularOrder(char [] array){   int indexOfR = 0;   int indexOfB = array.length-1;       for(int i=0;i<=indexOfB;){        if(array[i]=='R'){         swap(i,indexOfR,array);         indexOfR ++;         i++;       } else if (array[i]=='B'){         swap(i,indexOfB,array);         indexOfB --;        }else{         i++;        }       }            for(char c:array){     System.out.println(c);    }       }   private static void swap(int i, int j, char[] array) {   char temp = array[i];   array[i]=array[j];   array[j]=temp;     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int begin=0; int end=n-1; while(begin{  if (A[begin]=='G')  {   temp=begin+1;   while(A[temp]=='G')    temp++;   if(temp==end)    return;   else   {    swap(A[temp], A[begin])   }     }  if(A[begin]=='B')  {   swap(A[begin],A[end])  }  if(A[begin]=='R')  {   begin++;  }   if(A[end]=='G')  {   temp=end-1;   while(A[temp]=='G')    temp--;   if(temp==begin)    return;   else   {    swap(A[temp], A[end])   }  }  if(A[end]=='R')  {   swap(A[end],A[begin])  }  if(A[end]=='B')  {   end--;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int begin=0; int end=n-1; while(begin{  if (A[begin]=='G')  {   temp=begin+1;   while(A[temp]=='G')    temp++;   if(temp==end)    return;   else   {    swap(A[temp], A[begin])   }     }  if(A[begin]=='B')  {   swap(A[begin],A[end])  }  if(A[begin]=='R')  {   begin++;  }   if(A[end]=='G')  {   temp=end-1;   while(A[temp]=='G')    temp--;   if(temp==begin)    return;   else   {    swap(A[temp], A[end])   }  }  if(A[end]=='R')  {   swap(A[end],A[begin])  }  if(A[end]=='B')  {   end--;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"3-way quick sort with G as pivot."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"3-way quick sort with G as pivot."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"That took longer than it should have.  C#  The 'trick' was that you can only traverse once, but you don't necessarily need to increment your enumerator."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void swap(char * to,char *from) {      char t = *to;      *to = *from;      *from = t; }  void arrange(char  str[] ) {     //if(!str) return ;    cout<<\"before :\"<<   int n = strlen(str);    int last[3]= {0,0,n-1};      for(int i=0;i   {       if(str[i] == 'R' )        {          swap(&str[last[0]],&str[i]);          ++last[0] ;       }       else if(str[i] == 'B' && i      {          swap(&str[i],&str[last[2]]);          --last[2];       }       else if(str[i] == 'G' )       {           last[1]=i ;         }       cout<<\"Iteration :\"<<<\" \"<   }         cout<<\"after :\"<<}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nusing namespace std; \n \nvoid swap(char *x, char *y) \n{ \n cout<<\"Entered swap\"; \n char temp; \n temp = *x; \n *x=*y; \n *y=temp; \n cout<<\"Finished swap\"; \n} \n \nint main() \n{ \n char a[]=\"RRRRGGGGBBBB\"; // Desired output RGBRGBRGBRGB \n int size = sizeof(a)/sizeof(a[0]); \n  \n int low =0; \n int mid =0; \n int high = size-2; \n cout<<<<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void rearrange(char *s) \n{ \n    int i; \n    int length = strlen(s); \n    int firstp=0; \n    int lastp=length-1; \n    int flag = 0; \n    if(length>1) \n    { \n        while (firstp = 0 && s[lastp] == 'B') \n            lastp--; \n        i=firstp; \n        while (i<=lastp)  \n        { \n            i = i < firstp? firstp: i; \n            if(s[i] == 'R') \n            { \n                s[i] = s[firstp]; \n                s[firstp] = 'R'; \n            } \n            else if (s[i] == 'B')  \n            { \n                s[i] = s[lastp]; \n                s[lastp] = 'B'; \n            } \n            else \n                i++; \n            while (firstp = 0 && s[lastp] == 'B') \n                lastp--; \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"keep a red pointer from start, and blue pointer from end. Move the red pointer forward until you fing a non R character. Move the blue pointer backwards until you find a non B character. Initialize a green character from the current red position and keep moving until you find R/B. if you find R/B swap them and increase/decrease the corresponding pointer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about an in-place Merge sort?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"low=0; \n    high=n;//size of array; \n    for(i=0;i='G') \n              swap(arr[i],arr[high--]); \n           else i++; \n               \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void threeWayPartition(int data[], int size, int low, int high) {   int p = -1;   int q = size;   for (int i = 0; i < q;) {     if (data[i] < low) {       swap(data[i], data[++p]);       ++i;     } else if (data[i] >= high) {       swap(data[i], data[--q]);     } else {       ++i;     }   } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  int main()  {  char data[] = \"BRBRBRBGRGRGRRGRGRGRBRBRBR\";  int size = sizeof(data)/sizeof(data[0]);  int index= 0;   int gFirstPosition;  int bFirstPosition;   int gVisit= 0;  int bVisit= 0;    printf(\"input:  %s\\n\", data);   while (index < size)  {   if (data[index] == 'R')   {    if (gVisit == 1 && bVisit == 1)    {     data[gFirstPosition]= 'R';     data[bFirstPosition]= 'G';     data[index]= 'B';     gFirstPosition++;     bFirstPosition++;    }    else if (gVisit == 1 && bVisit == 0)    {     data[gFirstPosition]= 'R';     data[index]= 'G';     gFirstPosition++;    }    else if (gVisit == 0 && bVisit == 1)    {     data[bFirstPosition]= 'R';     data[index]= 'B';     bFirstPosition++;    }     }   else if  (data[index] == 'G')   {    if (gVisit == 0)    {     gFirstPosition= index;     gVisit= 1;    }        if (bVisit == 1)    {     data[bFirstPosition]= 'G';     data[index]= 'B';     if (gFirstPosition > bFirstPosition)      gFirstPosition= bFirstPosition;      bFirstPosition++;    }       }   else if  (data[index] == 'B')   {    if (bVisit == 0)    {     bFirstPosition= index;     bVisit= 1;    }   }   index++;  }    printf(\"output: %s\\n\", data);   return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Arrays;   public class SortRGB {      public static void main(String[]args){   char[]arr={'R','G','B','R','B','R','R','B','R','G','B','B','B','R','R','G','B'};      sortRGB(arr,'G','G');   System.out.println(Arrays.toString(arr));  }   private static void sortRGB(char[] arr, char key1, char key2) {   int p=0;   int size=arr.length-1;   int q=size;   for(int i=0;i<=q;){    if(arr[i]>key1){          swap(arr,p,i);     p++;     i++;    }    else if(arr[i]         swap(arr,i,q);     q--;    }    else{     i++;    }   }     }   private static void swap(char[] arr, int p, int q) {   char temp=arr[p];   arr[p]=arr[q];   arr[q]=temp;     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n \nint main() \n{ \n char c[] = {'r','g','b','g','b','g','b','r','r','b','g','r','r','b','b','g','r'},temp; \n int r=0,g=0,b=0,i; \n for(i=0;i<(sizeof(c)/sizeof(c[0]));i++) { \n  if(c[i] == 'r') { \n   temp = c[r]; \n   c[r] = c[i]; \n   c[i] = temp; \n   r++; \n   g++; \n   b++; \n  } \n  else if(c[i] == 'g') { \n   temp = c[g]; \n   c[g] = c[i]; \n   c[i] = temp; \n   g++; \n   b++; \n  } \n  else if(c[i] == 'b') { \n   temp = c[b]; \n   c[b] = c[i]; \n   c[i] = temp; \n   b++; \n  } \n } \n for(i=0;i<(sizeof(c)/sizeof(c[0]));i++)  \n  printf(\"%c\",c[i]); \n printf(\"\\n\"); \n return 0;   \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"yup similar to sort 0,1,2 or dutch national flag algo."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"yup similar to sort 0,1,2 or dutch national flag algo."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"yup similar to sort 0,1,2 or dutch national flag algo."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15069916","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"42","title":"Given a String \"abcxrrxabcrr\" Find the first repeated string with minimum 3 character?  Answer is \"abc\" min 3 characters.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"10","title":"I am assuming in case of \"aaaa\" . \"aaa\" is repeated string"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about using a suffix array?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For string \"abcabcabcabc\" is the first repeated string 'abc' or 'abcabc' ??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Tries should be the way to go about it . HashMap will not solve the problem as question says min 3 chars and not exactly 3 chars"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Maintain a Map  loop through the the characters in the string, keep adding them one by one to the map such that the key is the character and the value is it's position within the string.  for all characters beyond the third character in the string, check to see if the character exists in the map.  if so, get it's position and start comparing the characters after that position. In the above example 'a' occurs at 0 and 7. So basically, you have to check to see if the next two characters after that position match or not.  Was this a phone interview? Or on-site?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Amazon2 { \n public static void main(String []args) \n { \n  String input = \"edabcxedrrxedabcrr\"; \n  for(int i = 0;i < input.length();i++) \n  { \n   if(input.charAt(i) != input.charAt(i+1) && input.charAt(i) != input.charAt(i+2)) \n   { \n    for(int j = i + 3;j < input.length();j++) \n    { \n     if(input.charAt(j) == input.charAt(i) && input.charAt(j + 1) == input.charAt(i + 1) && input.charAt(j + 2) == input.charAt(i + 2) ) \n      { \n       System.out.println(input.charAt(j) +\"\"+ input.charAt(j+1)+\"\"+ input.charAt(j+2)); \n       System.exit(0); \n      } \n       \n    } \n   } \n  } \n  System.out.println(\"None found\"); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static String findRep(String str)  {   int len=str.length();//computes length of string   for(int j=len/2;j>=3;j--)//start comparing with len/2 character length   {    for( int i=0;(i+2*j)<=len;i++)//check whether substring can be found    {     String source=str.substring(i,i+j);     String target=str.substring(i+j,len);     if(target.contains(source))      return source;//repeated string is found    }    }   return null;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void First(string str) \n        { \n            string Org = str; \n            char[] cArr = str.ToCharArray(); \n            int count = 0; \n            for (int i = 0; i < cArr.Length && count < 1; i++) \n            { \n                if ((i + 2) < cArr.Length) \n                { \n                    for (int j = i + 3; j < cArr.Length; j++) \n                    { \n                        if ((j + 2) < cArr.Length) \n                        { \n                            if ((cArr[i].Equals(cArr[j])) && (cArr[i + 1].Equals(cArr[j + 1])) && (cArr[i + 2].Equals(cArr[j + 2]))) \n                            { \n                                Console.WriteLine(\"{0}, {1}, {2}\", cArr[i], cArr[i+1], cArr[i+2]); \n                                count++; \n                                break; \n                            } \n                        } \n                    } \n                } \n            } \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class FindFirstRepeatedString {  public static void main(String args[]) {   String main=\"abcxrrxcdrrxabcxrr\";   String min3String=\"\";   TreeMap loca = new TreeMap();   for(int i=0;i   min3String=main.substring(i,i+3);    if(main.substring(i+1).contains(min3String))     loca.put(i+1+main.substring(i+1).indexOf(min3String), min3String);    else      min3String=\"\";   }   if(!loca.isEmpty()) {    System.out.println(\"the first repeated String : \"+loca.firstEntry().getValue());   } else {    System.out.println(\"No String found\");   }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) { \n  String str = \"cccc\"; \n  Set set = new HashSet(); \n   \n   \n  for(int i = 0; i <= str.length() - 3; i++){ \n   System.out.println(str.substring(i,i+3)); \n   if(!set.add(str.substring(i,i+3))){ \n    System.out.println(\"Answer is \" + str.substring(i,i+3)); \n    break; \n   } \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"\"xababcabcxab\" in this case what is the expected output...is it \"abc\"..since it is repeated first or is it xab since it appears first in the string"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"firstRepeatedStringWithMinimumNChar(int n) {   String s = \"abcxrrxabcxr\";   HashMap map = new HashMap<>();   int i = 0, j = 0;   while (i < s.length()) {    j = i + n;    while (j < s.length()) {     String s1 = s.substring(i, j);     if (map.containsKey(s1)) {      System.out.println(s1);      return;     }     map.put(s1, null);     j++;    }    i++;   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The simplest way IMHO is comparing neighbor strings of suffix array using inverted suffix array for ordering search"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #include using namespace std; void find(string str,int p); int main() {     int p;     string str,str3;     cin>>str;     p=str.length();     find(str,p);     getch();     return 0; } void find(string str,int p) {      string str1,str2;      int i,j,k,flag,t;      if(p>3)      {             for(i=0; i            {                      str1=str.substr(i,3);                      j=i+1;                      for(k=j; k                     {                               str2=str.substr(k,3);                               if(str1==str2)                               {                                  cout<                                 flag=1;                                  break;                               }                      }                      if(flag==1) break;               }             if(flag==0)  cout<<\"no repeatition\";      }      else  cout<<\"string length is too less to find\";   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Repeating3DigitCharacter { \n  \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n  String str = \"abcrxabcxrxabcbcraaaa\"; \n  int start = 0; \n  int repatingCharacteres = 3; \n  HashMap hm = new HashMap(); \n  System.out.println(\"str==>\" + str.length()); \n   \n  while (start + repatingCharacteres <= str.length()) { \n   // System.out.println(start); \n   String substr = str.substring(start, start + repatingCharacteres); \n   if (hm.containsKey(substr)) { \n    hm.put(substr, hm.get(substr) + 1); \n    System.out.println(hm.get(substr) + \"=\" + substr); \n   } else { \n    hm.put(substr, 1); \n   } \n    \n   start++; \n  } \n   \n } \n  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Scala :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why use hashes and all that. Straight forward I can doo"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"No HashMap and no trie : This one is a simple DP. Lol that rhymed. Its elegent, but still not elegant enouth in that i'm having to write one more for loop at the end, only for one stupid condition when the repeated word appears at the far end. If some one can push it inside, I guess it would be perfect."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Two methods: 1. Regard the input string as a very big number, compare them by integer number with groups (XOR can be used for comparation).     This is for the sake of CPU consuming. 2. Pick the 3 chars in sequence, suppose it is \"abc\", use the remaining chars to match the group \"abc\", record the current matching index for \"abc\", if the current char could not match the next char indicated by matching index, then reset the matching index."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15920664","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"33","title":"Write a program to sort an array of strings so that all anagrams are next to each other  ex input {god, dog, abc, cab, man} output {abc, cab, dog, god, man}","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"use a hash table, the key is sorted string, and all the string combined by these character is in one block. for example hashtable[abc]={abc,cab}, hashtable[dgo]={dog,god}. And then sort it by the order of the first character of each key."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Short and Sweet:  import java.util.Arrays; import java.util.Comparator;  public class StrAnaSort {   public static void main(String[] args)   {   String[] strArr =  {\"god\",\"dog\", \"abc\", \"cab\", \"man\"};   Arrays.sort(strArr, new AnagramComparator());   for(String str:strArr)   {    System.out.print(str+\" \");   }  } }  class AnagramComparator implements Comparator {   @Override  public int compare(String str1, String str2)   {   return sumLetters(str1)-sumLetters(str2);  }    private int sumLetters(String str)  {   int sum = 0;   for(int ch:str.toCharArray())   {    sum+=ch;   }   return sum;  }   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"write the sort compare criteria of two strings (str1, str2) as bellow 1> build two arrays p1[256], p2[256], set to zero in the begging. 2> for each character c in str1, let p1[a]++ 3> for each character d in str2, let p2[d]++; 4> check count from 1 to 255,      4.1> if p1[count]>p2[count],           4.1.1>  If there exist one count2 >count that p2[count2]>0 , then str1 < str2,                       for case str1=\"aaaacdefdg\", str2=\"aaab\"           4.1.2> if for all count2 >count, p2[count2]=0 then str1>str2                     for case str1=\"aaaacdefdg\", str2=\"aaa\"     4.2> if p1[count]          4.2.1> if there is count2 >count, p1[count2]>0, then str1>str2                    symmetric as 4.1.1.           4.2.2> if for all count2> count, p1[count2]=0, then str1                   symmetric as 4.1.2. 5> if all p[count]=0, then using strcmp to find which str is bigger.  then people could use the quick sort to perform the sorting, by copying the str address but not the whole string while doing the swapping."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Concatenate sorted string and original string. Then sort god->dgogod dog->dgodog"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just override the comparator.. that should do it.. This works in Java. For other's I don't know."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just need to keep track the min element for each anagrams set in order to compare correctly."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def radixsort(array): \n    maxlen = len(max(array,key = lambda x: len(x))) \n    i = maxlen - 1 \n    while i >= 0: \n        array = sorted(array,key=lambda x:x[i] if i < len(x) else 0) \n        i -= 1 \n    return array"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// first pass insert all strings into a hash table, key = string, value = sorted key  now call bubble sort or any other sort with following a Compare function which compares first the value of the string and then then key if needed."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; \nimport java.util.HashMap; \nimport java.util.List; \nimport java.util.Map; \n \n \npublic class wordSequence { \n /** \n  * @author: Amarkant kumar ,DUCS \n  */ \n public static void main(String[] args) { \n  // TODO Auto-generated method stub \n  String[] data = {\"cat\",\"dog\",\"act\",\"god\",\"tac\"};  \n  processData(data); \n } \n \n private static void processData(String[] data) { \n   \n  Map> obj = new HashMap<>(); \n  for(int i=0;i()); \n    obj.get(a).add(data[i]); \n   } \n   else \n   { \n    if(obj.get(a) == null) \n    { \n     obj.put(a, new ArrayList()); \n     obj.get(a).add(data[i]); \n    } \n    else \n    { \n     obj.get(a).add(data[i]); \n    } \n   }  \n  } \n  System.out.println(obj.values()); \n   \n } \n} \n \n/* \n * Output: [[cat, act, tac], [dog, god]] \n *  \n * */"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Python Solution Using Key Function:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def sort_words(a) \n  swapped = true \n  while swapped \n   swapped = false \n   0.upto(a.size - 2) do |i| \n     if a[i][0] > a[i+1][0] \n      a[i], a[i+1] = a[i+1], a[i] \n      swapped = true \n     end \n   end \n  end \n  a \nend"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.*; \n \npublic class SortAnagramsNext { \n \n   public static List sortWithAnagramsTogether(List elements) { \n      List sortedElements = sort(elements); \n      Map> anagramMap = new LinkedHashMap>(); \n      for (String element : sortedElements) { \n         String sortedElement = sortChars(element); \n         if (anagramMap.get(sortedElement) == null) { \n            anagramMap.put(sortedElement, new ArrayList()); \n         } \n         anagramMap.get(sortedElement).add(element); \n      } \n      Map> tmpMap = new LinkedHashMap>(); \n      for (String key : anagramMap.keySet()) { \n         tmpMap.put(anagramMap.get(key).get(0), anagramMap.get(key)); \n      } \n      anagramMap = tmpMap; \n      List sortedWithAnagrams = new ArrayList(); \n      List mapKeys = new ArrayList(anagramMap.keySet()); \n      Collections.sort(mapKeys); \n      for (String mapKey : mapKeys) { \n         for (String element : anagramMap.get(mapKey)) { \n            sortedWithAnagrams.add(element); \n         } \n      } \n      return sortedWithAnagrams; \n   } \n \n   public static String sortChars(String str) { \n      char[] strChars = str.toCharArray(); \n      Arrays.sort(strChars); \n      return String.valueOf(strChars); \n   } \n \n   public static List sort(List elements) { \n      List sortedElements = new ArrayList(elements); \n      Collections.sort(sortedElements); \n      return sortedElements; \n   } \n \n   public static void main(String[] args) { \n      List elements = Arrays.asList(\"god\", \"dog\", \"abc\", \"cab\", \"man\"); \n      List sortedElements = sortWithAnagramsTogether(elements); \n      System.out.println(sortedElements); \n   } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static String sortString(String x) \n { \n  char[] ar = x.toCharArray(); \n  Arrays.sort(ar); \n  String sorted = String.valueOf(ar); \n   \n  return sorted; \n } \n  \n static String[] q5(String[] x) \n { \n  HashMap> y=new HashMap>(); \n   \n  for(int i=0;i()); \n   y.get(sortString(x[i])).add(x[i]); \n  } \n   \n  int count=0; \n  String[] result=new String[x.length]; \n   \n  for (ArrayList z:y.values()) \n  { \n   for (String a:z) \n   { \n    result[count++]=a; \n   } \n  } \n  return result; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \nusing namespace std; \nbool compare_anagram (string first, string second) \n{ \n  sort(first.begin(), first.end()); \n  sort(second.begin(), second.end()); \n  return (first < second); \n} \nint main() { \n list inputList = {\"agodz\", \"zadog\", \"abc\", \"az\", \"za\",\"cab\", \"man\"}; \n inputList.sort(compare_anagram); \n// inputList.sort(); \n for(list::iterator it = inputList.begin(); it != inputList.end(); ++it) { \n  cout << endl << *it; \n } \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi I'm getting anagrams sorted. But the overall alphabetical sorting isn't happening"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \n#include  \n \ntypedef std::map AnagramStringMap; \ntypedef AnagramStringMap::iterator AnagramStringMapIter; \ntypedef std::vector StringVector; \ntypedef StringVector::iterator StringVectorIter; \n \nvoid AnagramSort(StringVector& vInput) \n{ \n    std::sort(vInput.begin(), vInput.end());                // sort with complexity n * log(n) \n    AnagramStringMap anagramMap; \n    for (StringVectorIter it = vInput.begin(); it != vInput.end(); ++it) \n    { \n        std::string s(it->rbegin(), it->rend());            // anagram of current string \n        AnagramStringMapIter mapIt = anagramMap.find(s);    // find it in map (log(n)) \n        if (mapIt != anagramMap.end()) \n            mapIt->second = *it;                            // if already exists set current string as value \n        else \n            anagramMap.insert(std::make_pair(*it, \"\"));     // else insert it as a new key (log(n)) \n    } \n    AnagramStringMapIter mapIt = anagramMap.begin(); \n    StringVectorIter it = vInput.begin(); \n    for (; mapIt != anagramMap.end(); ++mapIt, ++it) \n    { \n        *it = mapIt->first;                                 // copy value to array \n        if (!mapIt->second.empty())                         // if word has anagram then copy it to the next index \n        { \n            ++it; \n            *it = mapIt->second; \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String args[]) {  String []a = {\"god\", \"dog\", \"abc\", \"cba\", \"man\",\"nam\"};  Map b = new TreeMap();  for (int i=0;i {   b.put(a[i], a[i]);  }     for (Entry e : b.entrySet())  {   System.out.println(e.getValue());  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String args[])  {   String []a = {\"god\", \"dog\", \"abc\", \"cba\", \"man\",\"nam\"};   Map b = new TreeMap();   for (int i=0;i  {    b.put(a[i], a[i]);   }      for (Entry e : b.entrySet())   {    System.out.println(e.getValue());   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \n \nusing namespace std; \n \nvoid anagram_sort(vector& words) { \n    sort(begin(words), end(words), [](const string& x, const string& y) \n    { \n        if (x.length() != y.length()) \n            return x.length() < y.length(); \n        else { \n            string xx(x), yy(y); \n            sort(begin(xx), end(xx)); \n            sort(begin(yy), end(yy)); \n            return xx < yy; \n        } \n    }); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package string; import java.util.*; import java.lang.StringBuffer; import java.util.Arrays;  public class WordSequence {  public HashMap check=new HashMap();  public HashMap store=new HashMap();  public void storeInHashMap(String[] str){   for(String st:str){    check.put(st, 1);    }   for(String st:str){    String reverse=new StringBuffer(st).reverse().toString();    if(check.containsKey(reverse)){     if(st.compareTo(reverse)<0){      store.put(st, st+\",\"+reverse);     }else{      store.put(reverse, reverse+\",\"+st);     }    }else{     store.put(st, st);    }       }   sortWord();  }  public void sortWord(){   String[] str= (String[]) store.keySet().toArray(new String[0]);   Arrays.sort(str);   for(String st:str){    System.out.println(store.get(st));   }  }  public static void main(String[] args){   String[] data = {\"cat\",\"dog\",\"act\",\"god\",\"tac\"};    new WordSequence().storeInHashMap(data);  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First, group the anagrams by sorting the letters of each word, and using the word that these sorted letters form as a key for a dictionary.  For example, groups['abc'] = ['abc', 'cab'] Then, take the first word from each of these lists, sort them, then insert the other anagrams accordingly."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I keep a hash with the sorted word as key.To sort a word i use an array of 26 elements, each representing a letter."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"So the key would essentially be the ascii value of the string  i.e"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"why we are not using"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13578662","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"27","title":"Q4. Written Exam Amazon(Bangalore)  Given an array of integers A[1....n-1] where 'N' is the length of array A[ ]. Construct an array B such that B[i] = min(A[i], A[i+1], ......., A[i-K+1]), where K will be given. Array B will have N-K+1 elements.  Constraint: Extra space allowed O(K) and time complexity allowed O(N.K) or lower.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"10","title":"Looks like below is not correct B[i] = min(A[i], A[i+1], ......., A[i-K+1]), where K will be given.  here A[i-K+1] should be A[i+k-1]  if i=0, and k=4 then i-K+1 will be negative, which is not correct"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"the algo could go on like this.... 1.scan the array in reverse order and create a min heap of k elements. 2.the element B[i] would be the element at the root of min heap. 3. now delete the element at A[K+i -1] and insert the element A[i-1] 4.reheapify the heap. TC-O(nlogk)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Is it not a sliding window problem ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"yes it should be i+k -1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"segment tree concept will be used"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"segment tree concept will be used"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"segment tree concept will be used"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think question is that k is some given number and length of B is N-k+1,  So can be done in O(n) Time Complexity  Traverse the array from  i=N-k+1 to i=0{ keep one min variable if(a[i]b[i]=min; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the algo could go on like this.... 1.scan the array in reverse order and create a min heap of k elements. 2.the element B[i] would be the element at the root of min heap. 3. now delete the element at A[K+i -1] and insert the element A[i-1] 4.reheapify the heap. TC-O(nlogk)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we can use selection to find the min. number and complexy will be o(n)  and space used will be o(1)....."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution: O(n) time and excluding the result space + O(1) space if there are no duplicates (if there are duplicates we can move them to the end of the array and use extra HashMap to count the duplicates) Here is the java code for nonDuplicate version (can be easyly modified for duplicates) :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can use binary search for it. Step-1: Add 1st k elements to bst tree. Step-2: Print the min element from bst tree Step-3: Print min element and Remove the ith element Step-4: Add the i+k+1 th element..i++ Step-5: Repeat Step-2,3,4 until no more elements"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using queue."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"can be done in O(N)  1.b[0] = the minimum of (0,1,K-1) 2. b[1] = min(b[0], a[k] 3. b[2] = min(b[1], a[k+1]"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=21240663","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"26","title":"Write a function that given an array of integer and a number k returns true if there is 2 numbers which sum equals to k and false otherwise","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"This question is asked before, so if you search you can find the implementations as well. You can do this in two different ways Method 1 1. Sort the number array A => A' 2. Keep two pointers start and end. start points to the first element and end points to the last element 3. while start < end, add sum = A'[start] + A'[end] 3.a. if sum == k return true 3.b. if sum < k, start++ 3.c. if sum > k, end-- 4. return false at the end (no match found at this point) This is O(n log n) time due to sorting, and O(1) time  Method 2 1. First pass, put all the elements in the hashtable. the key is the number, the value is the frequency of the number in the array 2. second pass, calculate diff = k - A[i] and check if the key is in the hashtable 2.a. if diff is in the hashtable  2.a.a. special case (if diff == A[i])   check if the frequency is >2, then return true, else continue  2.a.b. return true (diff exists in hashtable and diff != A[i]) 3. return false at he end (no match found at this point) O(n) time, and O(n) space"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"void find_sum(int[] arr , int sum){ \n Arrays.sort(arr); \n int left = 0; \n int right = arr.length - 1; \n while (left < right){ \n  if (arr[left] + arr[right] > sum) \n   right--; \n  else if (arr[left] + arr[right] < sum) \n   left++; \n  else{ \n   System.out.println(arr[left] + \" : \" + arr[right]); \n   return;  \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Create a hashmap of the objects in the array. Then for each key ki in the hashmap check if a key (k - ki) is present in the hashmap. if any such ki exists return true. If all the keys are checked then return false."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include main() {  int a[10],i,j,sum,count=0;  printf(\"enter the sum you want to check : \\n\");  scanf(\"%d\",??);  printf(\"enter the element of array : \\n\");  for(i=0;i<10;i++)  scanf(\"%d\",&a[i]);  for(i=0;i<10;i++)  {   for(j=0;j<10;j++)   {    if((i!=j) && (a[i] + a[j] == sum))    count++;   }  }  if(count>0)  printf(\"True\\n\");  else  printf(\"False\\n\"); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"create the function and put that code into it .. !!! Thanking You"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1)merge sort the array in o(nlgn). 2)for(i=0;i{     binary search k-array[i] in array in it. (o(lgn))     if there then return true     otherwise then return false } so total time taken=o(nlgn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1)Sort the array       -O(n log n) 2)for each element A at ith index      n * O(log n) = O(n log n)   {      binary search for k-A     --O(log n)  }         so overall O(n log n) time algo"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How many times?!?!?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if the array contains a range of numbers...(i......N) then we can do it in O(n)  time as well space complexty otherwise we need to sort the array first and follow two index(start index and end index approch) solution for array having a range of..... #include #include #define MAX 800  main()  {   int a[]={1,34,6,78,44,788,33,56,4,,456,600,304};   int size=12;      if(haspair(a,size,792))    printf(\"Has pair::\");   else     printf(\"No pair::\");    } int haspair(int *a,int size,int x)  {   int i;   int B[MAX]={0};   for(i=0;i  {    if(x-a[i]>=0 &&B[x-a[i]==1)     {      return true;      }     else      B[a[i]]=1;     }   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"add \"\"return  false\"\" at the end if no match found"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public boolean twoSumToK(int[] array, int k) { \n  for (int i = 0; i < array.length; i++) { \n   for (int j = i + 1; j < array.length; j++) { \n    if (array[i] + array[j] == k) { return true; } \n   } \n  } \n \n  return false;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \nusing namespace std; \n \nbool func(int arr[],int sum,int size); \n \nvoid print_sum(int arr[],int sum,int size) \n{ \n int count = 0; \n for (int i = 0;i < size; i++) \n { \n  for(int j = 0;j < (size - i - 1); j++) \n  { \n   int temp_size = arr[i] + arr[i + j + 1]; \n   if(temp_size == sum) \n    printf(\"(%d) Sum Found  [%d] + [%d] = [%d]\\n\",++count,arr[i],arr[i + j + 1],sum); \n  } \n } \n} \n \nint main() \n{ \n int arr[5] = {2,3,4,5,2}; \n int sum = 7; \n int size = sizeof(arr)/sizeof(arr[0]); \n bool result = func(arr,sum,size); \n print_sum(arr,sum,size); \n return 0; \n} \nbool func(int arr[],int sum,int size) \n{ \n for (int i = 0;i < size; i++) \n { \n  for(int j = 0;j < (size - i - 1); j++) \n  { \n   int temp_size = arr[i] + arr[i + j + 1]; \n   if(temp_size == sum) \n    return true; \n  } \n } \n return false; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"following the 1st method, what if the function should return the two integer whose sum is closest to K? please explain Also,can anyone provide the code for the 2nd method?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"RIP English"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5857232122019840","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"19","title":"Question 1 / 3 (Odd even level difference) You are given a function calcDifference which takes in the root pointer of a binary tree as it's input. Complete the function to return the sum of values of nodes at odd height - sum of values of node at even height. Consider the root node is at height 1  Sample Input:  Sample Output -74  Explanation: [ (1 + 4 + 5 + 6 + 7 ) ? (2 + 3 + 8 + 9 + 10 + 11 + 12 + 13  + 14 + 15)   = -74 ]","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"int CalculateDifference(Node n){ \n  int sum = 0, flip = 1, size; \n   \n  if(null == n) { \n   return sum; \n  } \n   \n  q.add(n); \n  size = q.size(); \n  while(size != 0) { \n    \n   for(int i = 0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"GLOBAL VARS: h=0, even, odd  //wrapper for other function sum( node)  {        even=odd=0   // reset sums        h=0   // not really needed ( rec_sum will unwind it to 0 )        rec_sum(node)           return  even, odd }  rec_sum( node ) {     if( node == nil) return;       if(h%2==0)              even+= node.val      else               odd+= node.val            ++h   // increment height value for my children      sum(Node.left)       sum(Node.right)       --h     // unwind height  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Here you go in C#: int SumEvenOdd(Tree root) {  return SumEvenOdd(root, true); }  int SumEvenOdd(Tree root, bool isPositive) {  if (root == null)  {   return 0;  }   int a = 1;  if (isPositive)  {   a = -1;  }   return root.Value * a + SumEvenOdd(root.Left, !isPositive) + SumEvenOdd(root.Right, !isPositive); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sample Function In Java"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int sumofNodes(TreeNode node, boolean oddLevel) {       if (node == null)      return 0;     int sum=sumofNodes(node.leftchild, !oddLevel)       + sumofNodes(node.rightchild, !oddLevel);     if (oddLevel)      return node.data + sum;     else      return sum;   }  public void oddEvenDifference(TreeNode node) {  System.out.println(Math.abs(sumofNodes(node, true) - sumofNodes(node, false)));  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int EvenSum=0,OddSum=0; \nvoid SumEveOddLevels(struct tree *root,int level) \n{ \n if(root) \n { \n  if(level%2) \n   OddSum+=root->data; \n  else \n   EvenSum+=root->data; \n  SumEveOddLevels(root->left,level+1); \n  SumEveOddLevels(root->right,level+1);  \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \nstruct node { \n    int val; \n    struct node* left; \n    struct node* right; \n}; \n \nvoid rec_calcDiff(struct node* root, int height, long int* evenSum, long int* oddSum) { \n    if(root == NULL) \n        return; \n    rec_calcDiff(root->left, height+1, evenSum, oddSum); \n    rec_calcDiff(root->right, height+1, evenSum, oddSum); \n    if(height%2 == 0) \n        *evenSum += root->val; \n    else \n        *oddSum += root->val; \n    return; \n} \n \nlong int calcDiff(struct node* root) { \n    int height=1; \n    long int evenSum=0, oddSum=0; \n    rec_calcDiff(root, height, &evenSum, &oddSum); \n    return (oddSum - evenSum); \n} \n \nstruct node* createNode(int val) { \n    struct node* newNode = (struct node*) malloc(sizeof(struct node));  \n    newNode->val = val; \n    newNode->left = NULL; \n    newNode->right = NULL; \n    return newNode; \n} \n \nmain() \n{ \n    struct node* root = createNode(7); \n    root->left = createNode(8); \n    root->right = createNode(4); \n    root->left->left = createNode(33); \n    root->left->right = createNode(77); \n    root->right->right = createNode(3); \n    printf(\"%ld\\n\", calcDiff(root)); \n    return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why is itjt's answers downvoted? it works! template<> int tree:: oddevensum() {  deque* > myq1;  deque* > myq2;  node* temp;  int sum=0;  myq1.push_back(root);    while(!(myq1.empty()) || !(myq2.empty()))  {   //odd levels   while( !(myq1.empty()) )   {      temp=myq1.front();    sum+= temp->val;    if(temp->left) myq2.push_back( temp->left );    if(temp->right) myq2.push_back( temp->right );    myq1.pop_front();   }    while( !(myq2.empty()) )   {      temp=myq2.front();    sum-= temp->val;    if(temp->left) myq1.push_back( temp->left );    if(temp->right) myq1.push_back( temp->right );    myq2.pop_front();   }  }  return sum; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Typical level order or breath first traversal to figure out the even and the odd sums. You only need a single queue and boolean flag toggling between even and odd. You can sum up the odd and even values using BFS and then print the difference."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"int sum(node root){ \n  \n  if(!root) return0; \n  return  \n  root.data - sum(root.left) - sum(root.right); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"int total = getChildTotal(root, 1, root.value) \n \nint getChildTotal(Node* node, int level, int total) { \n    if (node == NULL) { \n        return total; \n    } else { \n        childTotal = (node->left == NULL?) 0 : node->left.value + (node->right == NULL)? 0 : node->right.value; \n        if (level%2 == 0) { \n            // current node is at even height. so children are at odd height \n            childTotal = -childTotal; \n        } \n        total = total + childTotal; \n        total = getChildTotal(node->left, level+1, total); \n        total = getChildTotal(node->right, level+1, total); \n        return total; \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Pseudocode:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I guess we do not need to keep track of odd and even levels. Recursion would take care of it for us.  int calcDifference(node *root) {  return root ? (root->value - (calcDifference(root->left) + calcDifference(root->right))) : 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"You could traverse the tree breadth first. Maintain two queues: an odd queue and an even queue. Enqueue the children of odd queue elements in the even queue and vice versa. You could use a signed diff variable and add to or subtract from it depending on whether it's an odd or even element."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=11196688","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"18","title":"Given a 2D array which has elements sorted both row-wise and column wise, find an efficient way to search a given key.  Ex: a1 a2 a3 a4     b1 b2 b3 b4     c1 c2 c3 c4  a1a1 \n   \n   - Avinash on October 15, 2011 in India   \n   Edit | Report Duplicate | Flag","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Start with top right element \nLoop:  \n     Compare this element e with x \n     i) if they are equal then return its position \n    ii) e < x then move it to down \n   iii) e > x then move it to left \n   Repeat above 3 steps till you find element \nIf not found return false"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"The code in Java is as follows:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Given input x, using binary search find the largest first element which is smaller than input. Then use binary search in row to see if there is an element that matches x."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool search2D(int ele, int **mat, unsigned row, unsigned col, unsigned &oRow, unsigned &oCol) {    unsigned i = 0;    unsigned j = row;     if ((ele > mat[row][col]) || (ele < mat[0][0]))    {       return false;    }     while (i   {       unsigned k = (i+j)/2;       if (mat[k][col] > ele)       {          j = k;       }       else if (mat[k][col] < ele)       {          i = k+1;       }       else       {          oRow = k;          oCol = col;          return true;       }    }     oRow = i;     if (mat[oRow][col] == ele)    {       oCol = col;       return true;    }     for (i=0,j=col; i   {       unsigned k = (i+j)/2;       if (mat[oRow][k] > ele)       {          j = k;       }       else if (mat[oRow][k] < ele)       {          i = k+1;       }       else       {          oCol = k;          return true;       }    }     if (mat[oRow][i] == ele)    {       oCol = i;       return true;    }     return false; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"mng soln seems to be appropriate"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"An approach with O(m log n) complexity would be to perform binary search on every row... Can we do better than this?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class point \n        { \n            public int X {set; get; } \n            public int Y {set; get; } \n            public point(int x, int y) \n            { \n                this.X = x; \n                this.Y = y; \n            } \n        } \n    class Searching \n    { \n        public static point SearchIn2DSortedArray(int[,] arr, int Key) \n        { \n            int MaxX = arr.GetLength(1) - 1; \n            int MaxY = arr.GetLength(0) - 1; \n \n            if (MaxY < 1 || MaxX < 1) \n                goto RETURN_KEY_NOT_FOUND; \n            if(Key < arr[0,0] || Key > arr[MaxY, MaxX]) \n                goto RETURN_KEY_NOT_FOUND; \n \n            int X = MaxX; \n            int Y = 0; \n \n            while (X >= 0 && Y <= MaxY) \n            { \n                if (Key == arr[Y, X]) \n                    return new point(Y, X); \n                 \n                if(Key < arr[Y, X]) \n                {                     \n                    X--; \n                    continue; \n                } \n \n                if(Key > arr[Y, X]) \n                { \n                    Y++; \n                    continue; \n                } \n            } \n        RETURN_KEY_NOT_FOUND: \n            return new point(-1, -1); \n        } \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class point \n        { \n            public int X {set; get; } \n            public int Y {set; get; } \n            public point(int x, int y) \n            { \n                this.X = x; \n                this.Y = y; \n            } \n        } \n    class Searching \n    { \n        public static point SearchIn2DSortedArray(int[,] arr, int Key) \n        { \n            int MaxX = arr.GetLength(1) - 1; \n            int MaxY = arr.GetLength(0) - 1; \n \n            if (MaxY < 1 || MaxX < 1) \n                goto RETURN_KEY_NOT_FOUND; \n            if(Key < arr[0,0] || Key > arr[MaxY, MaxX]) \n                goto RETURN_KEY_NOT_FOUND; \n \n            int X = MaxX; \n            int Y = 0; \n \n            while (X >= 0 && Y <= MaxY) \n            { \n                if (Key == arr[Y, X]) \n                    return new point(Y, X); \n                 \n                if(Key < arr[Y, X]) \n                {                     \n                    X--; \n                    continue; \n                } \n \n                if(Key > arr[Y, X]) \n                { \n                    Y++; \n                    continue; \n                } \n            } \n        RETURN_KEY_NOT_FOUND: \n            return new point(-1, -1); \n        } \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class point \n        { \n            public int X {set; get; } \n            public int Y {set; get; } \n            public point(int x, int y) \n            { \n                this.X = x; \n                this.Y = y; \n            } \n        } \n    class Searching \n    { \n        public static point SearchIn2DSortedArray(int[,] arr, int Key) \n        { \n            int MaxX = arr.GetLength(1) - 1; \n            int MaxY = arr.GetLength(0) - 1; \n \n            if (MaxY < 1 || MaxX < 1) \n                goto RETURN_KEY_NOT_FOUND; \n            if(Key < arr[0,0] || Key > arr[MaxY, MaxX]) \n                goto RETURN_KEY_NOT_FOUND; \n \n            int X = MaxX; \n            int Y = 0; \n \n            while (X >= 0 && Y <= MaxY) \n            { \n                if (Key == arr[Y, X]) \n                    return new point(Y, X); \n                 \n                if(Key < arr[Y, X]) \n                {                     \n                    X--; \n                    continue; \n                } \n \n                if(Key > arr[Y, X]) \n                { \n                    Y++; \n                    continue; \n                } \n            } \n        RETURN_KEY_NOT_FOUND: \n            return new point(-1, -1); \n        } \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Suppose we have 2D matrix with bottom left corner as starting point. Now compare the last element of first column and last row with the matching element. If the last elements are smaller then move to next diagonal element and repeat the above steps. If last element is bigger then we are sure that matching element should be present in current row or column so do binary search to find it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A simple algo can be as below: 1) Given Matrix[i][j] where i and j are the rows and columns of the table. 2) If entered number, E is less than M[0][0] or greater than M[n][n] then print element does not present in matrix. 3) Check element start from first row and then subsequent rows .... E < = M[0][3] then start for 1st row to check whether E=M[0][j] for j = 0,1,2,3 4) Return if you find suitable match or return \"Element is not present in the given matrix\" 5) End"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13243679","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"16","title":"while reading a binary file with over 1 billion unsigned integers, how can you optimize the following code to make it perform better?  int i=0; long sum=0;  ifstream file(\"binary.dat\", ios::in|ios::binary); if(file.is_open()) {  while(!file.eof()) {             file.read(reinterpret_cast(&i), sizeof(unsigned int));    sum += i;   i = 0;   }  } file.close();","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Take the sizeof(int) operator outside the while loop and put into a varibale. this will improve the performance as it will not calculate size of int each time :).  ---Comment if I am wrong"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A major cost in reading the file comes from the time to read the disk. To optimize this, one can prefetch blocks ahead of using them. The 4K buffer read is a kind of prefetch, but I would prefetch more and also before computing the sum.  A second possibility is to take advantage of concurrency. We can have multiple threads so that the sum computation can happen in parallel to the io read. We can have multiple threads for io and computation, if there is a possibility of parallelism on the box.  A third possibility is: do we need the \"i=0\" statement? Isn't i overwritten anyways? This may be a language aspect that I am not familiar with."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Without buffering : inefficient code  try{     File f = new File(\"myFile.txt\");     FileInputStream fis = new FileInputStream(f);    int count = 0;     int b = 0;     while((b = fis.read()) != -1){        if(b== '\\n') {           count  ;        }     }       // fis should be closed in a finally block.       fis.close() ;   } catch(IOException io){}      With Buffering: yields better performance try{     File f = new File(\"myFile.txt\");     FileInputStream fis = new FileInputStream(f);     BufferedInputStream bis = new BufferedInputStream(fis);    int count = 0;     int b = 0 ;     while((b = bis.read()) != -1){        if(b== '\\n') {           count  ;        }     }       //bis should be closed in a finally block.       bis.close() ;   } catch(IOException io){}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have two inputs here for optimization 1)  sizeof(unsigned int) , is the culprit, assign the value to an integer and use it. don't call function in a loop. 2) instead of reinterpret_cast , if you know that all data read is going to be char*.. just use an explicit cast as (char*)&i.. This saves lot of time as well."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In most of cases, sizeof calculation takes place in compile time. And replaced with constant value before compilation. I don't think it will incur overhead in most cases"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In most of cases, sizeof calculation takes place in compile time. And replaced with constant value before compilation. I don't think it will incur overhead in most cases"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) get rid of the size of operator   2) instead of reading one integer at time read a specified set of integers .Disk I/O always takes time ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Dont you know the size of file before you start reading. You might not even need to do interpret cast. Read in multiples of 4 bytes say 64/128 and do the incremental sum in lopp.  There is no C++ specific stuff here."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If it's in binary (as opposed to ASCII) and the entire file is nothing BUT integers, I think this could work - we're using a vector in particular since once we get the size of the file, we know exactly what size to make it and only need one allocation (constant resizing for a vector is terrible, so we want to do this without push_back)  long sum=0;   ifstream file(\"binary.dat\", ios::in|ios::binary);  if(file.is_open())  {  file.seekg(file.end, 0); int numIntegers = file.tellg() / sizeof(int); file.seekg(file.beg, 0);  vector intVec; intVec.resize(numIntegers); file.read(reinterpret_cast(intVec.data()), numIntegers * sizeof(int));  //now that vector is big enough and we know the file size in advance after using tellg, just read everything in one read call  for(int i = 0; i < intVec.size(); ++i) sum += intVec[i];  }  file.close();"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Read into some buffer, that would reduce number of roundtrips to file on disk, something like:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Here is my answer to this question. Comments are welcome.   basicalgos.blogspot.com/2012/04/41-optimize-file-reading.html"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5198021759336448","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"10","title":"Give 2 arrays of size 7 and 3 which are sorted such that the last 3 blocks in first array are empty, merge the arrays in a sorted manner in the most efficient way. E.g:-  a[7] = [4, 10, 11, 20__, __, __] b[3] = [1,3,7]","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"merge sort from right to left, placing the result in \"a\" as you go. return a."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Set two pointers at the very last number of the two arrays. Compare with the two numbers at the pointers, put the bigger one at the end of first array and move that pointer one left. Continue this process until both pointer move at the head of the arrays."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* \na[] is the bigger array;  \nb[] is the smaller array;  \nn is the size of bigger array; \nm is the size of smaller array \n*/ \nmerge(int a[], int b[], int n, int m) \n{ \n int c[n]; \n int i = n-m-1; \n int j = m-1; \n int k = n-1; \n while(i>=0 && j>=0 && k>=0) \n { \n  if(a[i] > b[j]) \n  { \n   c[k] = a[i]; \n   i--; \n  } \n  else \n  { \n   c[k] = b[j]; \n   j--; \n  } \n  k--; \n } \n if(i<0) \n { \n  while(j>=0 && k>=0) \n  { \n   c[k] = b[j]; \n   k--; \n   j--; \n  } \n } \n else if(j<0) \n { \n  while(i>=0 && k>=0) \n  { \n   c[k] = a[i]; \n   k--; \n   i--; \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int[] mergeSortedArray(int[] array1, int sizeA, int[] array2) {  int i=sizeA;  int j = array2.length-1;  int k = array1.length -1;    while(k>=0 && i>=0 && j>=0)  {   if(array1[i] > array2[j])   {    array1[k]=array1[i];    k--;    i--;   }   else   {    if(j>=0)    {    array1[k]=array2[j];    }    k--;    j--;   }     }  return array1; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The empty space in a is equal to the number of element in b, so we can merge from last element without extra space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) \n{ \n int[] arr1=new int[]{7,10,11,20,0,0,0}//0 at the end should be assumed as empty space \n int arr2 = new int[]{1,3,7}; \n  \n int i2=arr2.length() -1; \n int i1 = arr1.length()  -1 - i2; \n int j = arr1.length()-1; \n \n while(i1>0 && i2 > 0 && j > 0) \n { \n  if(arr1[i1] > arr2[i2])   \n    arr[j--] = arr[i1--]; \n  else \n    arr[j--] = arr[i2--]; \n } \n \n if(i2>=0) \n { \n  while(i2>=0) \n  { \n   arr[j--] = arr[i2--] \n  } \n } \n \n if(i1>=0) \n { \n  while(i1>=0) \n  { \n   arr[j--] = arr[i1--] \n  } \n } \n \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static int a[7] = {4, 10, 11, 20, 0, 0, 0}; static int a_len = 4; static int b[3] = {1, 3, 7};  void merge_sort() {         int store_pos = 6;         int a_cur = a_len-1;         int b_cur = 2;         while(a_cur >= 0 && b_cur >= 0) {                 if (a[a_cur] > b[b_cur]) {                         a[store_pos--] = a[a_cur--];                 } else {                         a[store_pos--] = b[b_cur--];                 }         }          if (a_cur < 0) {                 memmove(a, b, (b_cur+1)*sizeof(int));         } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Are we allowed to use O(1) extra space?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13573665","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"10","title":"Q2. Written Exam Amazon(Bangalore)  Given a number in the form of string. Output the binary equivalent of that number.  Sample Input: \"8.5\" Sample Output: 1000.1  Sample Input: \"12.34.23\" Sample Output: \"ERROR\"","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"On questions like these, don't forget to handle cases where there is no binary equivalent."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static String printBinary(String n) {  int intPart = Integer.parseInt(n.substring(0, n.indexOf(??.??)));  double decPart = Double.parseDouble( n.substring(n.indexOf(??.??), n.length()));  String int_string = ?????;  while (intPart > 0) {  int r = intPart % 2;  intPart >>= 1;  int_string = r + int_string;  }  StringBuffer dec_string = new StringBuffer();  while (decPart > 0) {  if (dec_string.length() > 32) return ??ERROR???;  if (decPart == 1) {  dec_string.append((int)decPart);  break;  }  double r = decPart * 2;  if (r >= 1) {  dec_string.append(1);  decPart = r - 1;  } else  {dec_string.append(0);  decPart = r;  }  }  return int_string + ??.??? + dec_string.toString();"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//fraction part i have terminated to 10 digits"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Test cases: Negative number. Positive number. Are white spaces allowed: \"    123.45\"."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my approach. Note that i have not handled the case of negative numbers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i// made decimal point limited to 10"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public static void ConvertToBinary(string inputNumber) \n        { \n            string[] inputDigits = inputNumber.Split('.'); \n            List outputBinaryDigits; \n            bool IsValidInput = true; \n            Console.WriteLine(\"The Decimal Number is {0}\", inputNumber); \n            if (inputDigits.Count() > 2) \n            { \n                Console.WriteLine(\"ERROR\"); \n                IsValidInput = false; \n            } \n            else \n            { \n                outputBinaryDigits = new List(); \n                int parseStatus = 0; \n \n                foreach (string digit in inputDigits) \n                { \n                    int.TryParse(digit, out parseStatus); \n                    if (parseStatus == 0) \n                    { \n                        Console.WriteLine(\"ERROR\"); \n                        IsValidInput = false; \n                        break; \n                    } \n                    else \n                    { \n                        outputBinaryDigits.Add(Convert.ToString(parseStatus, 2)); \n                    } \n                } \n                if (IsValidInput) \n                { \n                    Console.WriteLine(\"The Binary Equivalent is {0}\", string.Join(\".\", outputBinaryDigits)); \n                } \n            } \n        }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5246230074490880","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"14","title":"Question 3 / 3 (Find first unique character) Find the first unique character in a Stream. Please note that you are being provided a stream as a source for these characters.  The stream is guaranteed to eventually terminate (i.e. return false from a call to the hasNext() method), though it could be very long. You will access this stream through the provided interface methods.  A call to hasNext() will return whether the stream contains any more characters to process. A call to getNext() will return the next character to be processed in the stream.  It is not possible to restart the stream.  If there is no unique character, then return the character '#'. # won't be any character in the character stream.  You just have to complete the function getUniqueCharacter() using the functions hasNext() and getNext() which are already defined.  Example:  Input:  aAbBABac  Output:  b  Input:  aBBa  Output:  #","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Use a ASCII array of integer of length 256, it represent the of character of its corresponding index. Initially it contains value -1 as absence of character of corresponding index. Read character from stream and update ASCII array as  If index of corresponding ascii value of character is -1 then update with its position in the stream. If index of corresponding ascii value of character is +ve(char has already came) then update it with -2 (Means Not unique)         Finally after getting all the value from stream, trace the array and get min +ve value and its corresponding ASCII char will be the unique char If array contains only -ve value then # as result"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I would use a HashMap. The keys are the characters. The value is the first position the character occurs or -1 if duplicate. The time complexity is O(n), n being the number of characters in the stream. If we know the range of characters is the ASCII values, we can just use an array instead. If the characters can be any unicode char, then a hash map should be better."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nusing namespace std; \nint main() \n{ \n        char str[1000]; \n        int arr[256],i,j=0; \n        for(i=0;i<256;i++) \n                arr[i]=0; \n        cout<<\"Enter the stream of characters:\"; \n        cin>>str; \n        char* ptr=str; \n        while(*ptr) \n        { \n                if(arr[*ptr]==0) \n                        arr[*ptr++]=++j; \n                else if(arr[*ptr] > 0) \n                        arr[*ptr++]=-arr[*ptr]; \n                else \n                { \n                        ptr++; \n                        j++; \n                } \n        } \n        int min=257; \n        for(i=0;i<256;i++) \n        { \n                if(arr[i] > 0 && arr[i]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am assuming that getNext() and hasNext() is given. Giving only the getUniqueCharacter() Implementation."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In C# .Net  using System; using System.Collections; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks;  namespace UniqueCharacterFromStream {     class Program     {         static void Main(string[] args)         {              CharacterStream stream = new CharacterStream(\"caAaaAAbBcBbd\");              Console.WriteLine(string.Format(\"First Unique Character {0}\",GetFirstUniqueCharacter(stream)));              Console.Read();         }           private static char GetFirstUniqueCharacter(CharacterStream stream)         {             Dictionary characters = new Dictionary();              while(stream.HasNext)             {                 var nextChar = stream.GetNext;                  if(characters.ContainsKey(nextChar))                     characters[nextChar] ++;                 else                     characters.Add(nextChar,0);              }              return characters.FirstOrDefault((data) => data.Value == 0).Key;           }     }       class CharacterStream     {         char[] Characters;         int _CurrentIndex = -1;          public CharacterStream(string characters)         {             this.Characters = characters.ToCharArray();         }          public char GetNext         {             get { return Characters[++ _CurrentIndex];}         }          public bool HasNext         {             get { return ((_CurrentIndex + 1) < Characters.Count()); }         }     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"amazon asking baby questions these days?  or one weak interviewer maybe"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"It s very ques..I dnt knw y amazon asking easy quesns now a days..(is it a fake?)  Any way i m gng 2 tryyyyyy..the qus \"first unique character in a Stream\"  Algorithm:  1)get count of each and every char in string array. 2)use  \"Java - String indexOf() Method\"  to find which element comes first in string array whose count is 1.  ##CODE -SAMPLE:## String str = new String(\"aAbBABac \"); for(i=0;i{ if(str[i]==str[i+1]) { count++;//count of all char }  ex: aAbBABac   count of 'a'=2,'A'=2,'B'=2,'b'=1,'c'=1;  return the char whose count is 1; b,c;  ##now finding the first unique char :##   System.out.println(Str.indexOf( 'b' ));  System.out.println(Str.indexOf( 'c' ));  should return index of both 'b','c':  index of 'b'=2; index of 'c'=7;(chk both)  Here 'b' comes first befre 'c' ;so   OUTPUT: 'b'"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=20167663","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"13","title":"Two files containing large number, one in each. You have only fopen(), int read(fp), fclose(), fwrite(). Add these two numbers and write in third file with the help of given functions only.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Not a bad question - IMHO, about the right level for an interview. I can't believe how complicated in terms of algorithmic development or code some of the questions are here. Under the stress of an interview, I cant believe most people could do many of the questions posed here.   In any case, can we assume the numbers are both positive? If so, read each of the numbers into a vector (using push_back). Equalize the length of the two vectors to simplify the addition. Note that the digits in the vector will be in order, from MSD to LSD, so add on a corresponding number of 0s to the beginning of the smaller to make equal length with the longer. Now that they two are equal length, just iterate over the digits of both (from last to first digit), summing and storing sum mod 10 and propagating forward sum / 10. Oh, make sure sum has length = length of either (since same, equalized now) plus one, to accomodate for additional digit possible due to carry. Now write that sum vector back out, from MSD down to LSD."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Read this 2 files to 2 linked lists. Each node in the linked list will store a digit of the big number. Now we have 2 linked lists representing 2 big numbers. Now the problem became, addition of 2 linked lists and store the result in 3rd list. This can be done in O(M+N) complexity."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Read the numbers as astring from the file. Then iterate over the string and store in a linked list with each node of the linked list containing the digits of the number. Now add the digits in the two linked list to get the sum in another linked list. Need to take care of the MSD and LSD of the numbers. Can store the linked list such that the head points ot the LSD. Also need a carry integer. The final result in the linked list will have to be stored in the output file. Complexity: O(m) where m is the maximum number of digits out of the two input numbers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am java guy, So i coded in Java. Please see code and make comment if not good solution.  import java.io.BufferedReader; import java.io.File; import java.io.FileReader; import java.io.IOException; import java.util.Iterator; import java.util.LinkedList;  /*  * Read two files and store into the link lists and add these link list.  * Complexity O(m+n).   */  public class sumNumbersFromFiles {  public static void main(String[] args) throws IOException {   File file1 = new File(\"number1.txt\");   BufferedReader readFile1 = new BufferedReader(new FileReader(file1));   String s1 = null;   LinkedList list1 = new LinkedList();   while((s1 = readFile1.readLine()) != null ) {    list1.add(s1);   }      s1 = null;   File file2 = new File(\"number2.txt\");   BufferedReader readFile2 = new BufferedReader(new FileReader(file2));   LinkedList list2 = new LinkedList();   while((s1 = readFile2.readLine()) != null ) {    list2.add(s1);   }   //add numebrs from list1 and list2.   LinkedList list3 = new LinkedList();    for(int i = 0 ; i < list1.size(); i++) {    int res = Integer.parseInt(list1.get(i))+Integer.parseInt(list2.get(i));    list3.add(Integer.toString(res));   }      //print final list   Iterator result = list3.iterator();   while(result.hasNext()) {    System.out.println(result.next());   }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sites.google.com/site/spaceofjameschen/home/file-and-iostream/add-these-two-numbers-and-write-in-third-file-with-the-help-of-given-functions-only  void AddTwoLargeNumb(string& outFileName, string& inFileName1, string& inFileName2) {     vector v1;     vector v2;     vector v3;      ReadLargeNumIntoVec(inFileName1, v1);     ReadLargeNumIntoVec(inFileName2, v2);      int minLen = v1.size() < v2.size() ? v1.size() : v2.size();      if(v1.size() > v2.size()){         v1.swap(v2);     }      int i = 0;     unsigned char carry(0);     unsigned char result;     unsigned char num1;     unsigned char num2;     int sum;     while(i < v1.size()){         num1 = v1[i];         num2 = v2[i];         sum = num1 + num2;         sum += carry;          result = sum & 0xFF;         carry = sum >> (sizeof(unsigned char) * 8);          v3.push_back(result);             i++;     }      while(i < v2.size()){         num2 = v2[i];         sum = carry + num2;          result = sum & numeric_limits::max();         carry = sum >> (sizeof(unsigned char) * 8);         v3.push_back(result);         i++;     }      if(carry != 0){         v3.push_back(carry);     }      WriteLargeNumIntoFile(outFileName, v3); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"first reverse the content of both the file by doing following."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=7837664","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"13","title":"implement atoi function.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"here it is in C. it handles leading whitespaces & trailing whitespaces. if characters are found in between numbers, it ignores them. it allows negative numbers, and it detects buffer overflows."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Should be something like this:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"atoi is simple to implement. I was asked itoa by Amazon.. :("},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"atoi is simple to implement. I was asked itoa by Amazon.. :("},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int atoi(char* str){ assert(str!=NULL);//check for null string bool negFlag=false; int i=0; if(str[0]=='-')//check for negative numbers {negFlag=true; i++; } int num=0; while(str[i]!='\\0'){ num*=10; num+=(str[i]-'0');//extract value of number at position i i++; } if(negFlag){ num*=-1; } return num; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In C#  private static string MyItoA(int input)         {             string result = string.Empty;                          var quotient = input;              while (quotient > 0)             {                 var remainder = quotient % 10;                 quotient = quotient / 10;                 char addedNumberString = (char)(remainder + (int)'0'); ;                 result = string.Concat(addedNumberString , result);             }             return result;         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"And here is my itoa function. it issues malloc a single time at the expense of looping an extra log10(n) times to get the number of digits. if anyone has a more elegant solution please share."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"would not it be better to get the malloc of word length first and then doing the needful conversion and then realloc to squeeze in case extra memory has been allocated. This will avoid the loop to count the digits before actually doing the conversion."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15030806","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"11","title":"A log file which has user details(user ID,timestamp) and pages visited in a particular day by that user.The next day -the same kind of log file gets generated.How do you find the probability of users who logged in consecutive days out of the second day - logged in users? The question is simple,but they look for the efficient data structure and time complexity.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Well this pretty much means finding repeating user ids in the second log file.  One must ask how big are these log files or even better how many unique UIDs will it have. If they are big enough to to be held in memory then just parse UIDs from first log file and add them to a HashSet, while parsing the second file check if each uid exists in the set. contains operation in hashset will take O(1) time and so does add operation. Summing up, this program will take O(n+m) time where n is number of users in first log file and m is number of users in second."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"If the data is tooo big that you cannot put it in memory at once, then follow this approach:  1. Apply a hash function h1(k) on the UserLog1 and UserLog2 files and partition the data into smaller chunks so that each of which can fit into memory. 2. Lets suppose that you get m files for UserLog1 and UserLog2 after step 1. 3. Now prepare a in memory hashSet for the first partition of UserLog1 file. 4. Now check for each element of UserLog2 file, if its already there in the hashSet prepared in step 3. If yes, then add it to a different list of duplicateUsers. Else, continue looking for next element until you are done with all the elements. 5. Repeat steps 3, 4 and 5 for second, third and all partitions of UserLog1 and UserLog2 files."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Step1:  awk -F ','  '{print $1}' file1.txt  > file2.txt                             // get ids only Step2:  awk '!x[$1]++' FS=\",\"  file2.txt   > userId.log                    //get distinct id"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"cat day2 | awk -F\",\" '{print$1;}' > UserId2 cat day1 | awk -F\",\" '{print$1;}' > UserId1 comm -13 UserId1 UserId2 >> ans"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"The probability cannot be determined by just looking at the second day log.  Even if a user  had 0 or a million log entries  on second day you must make assumptions about the probability distribution  from day to day to give an answer.  For example assume flipping a coin has a probability distribution or 50-50  heads  versus tails.  One day in N trials it could come up 50-50 heads and tails. The next day the trials  could  wind up being 100% heads.  So based on second day data you would then surmise that probability is 100% heads. And so you answer the first day that 100% heads was probability. But obvoiusly, this is a mistaken conclusion since you are making a faulty assumption about the probability distribution  based on one days data."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"As pointed out previously, this question is about the probability. Even if you assume a prior belief the question by itself does not have enough data to answer the question. I believe the interviewer wants us to ask questions about what is the relation between the users logging in the second day after the first day and so on. if you have enough information then you can do some bayesian inference on it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@bhargav : In that case you can use Arraylist"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think question has asked to find the probability. Can we take small chunk of file for different time stamps like [0-1], [8-9],[16-17] hours and do the hashing stuff."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=10839042","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"11","title":"check whether two strings are rotational equivalent of each other.but u cat not use any linear string matching algorithm like rabin-karp,parse tree etc.still do it in o(n).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"Easy. Append one of those strings with itself; so if I am given to check if vindar and darvin are rotational equivalents, just append vindar to itself. Now i have vindarvindar and ANY rotational equivalent of the string will be a substring of this string!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool rotation(char *str1 , char *str2) {     if(str1 == NULL || str2 == NULL)         return 0;     if(strlen(str1) != strlen(str2))         return 0;      char *temp = new char[sizeof(str1) * 2 + 1];      strcat(temp,str1);     strcat(temp,str1);      char *ptr =strstr(temp,str2);      delete temp;      if(ptr == NULL)         return 0;     else         return 1; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can be done in O(nlgn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I doubt if it was ever asked by an Amazon Interviewer. The OP probably wants to solve it, and formulate the problem as his wish. Then why do people care to pay heed to such questions.  @arindam.mitra2: Isn't it better if you post such problems on Stackoverflow?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool isSubstring(string s1, string s2) {     int j=0;     for (int i=0; i < s1.size(); ++i) {         if (s1[i] == s2[j])             ++j;         else             j=0;          if(j==s2.size()) {return true;}     }     return false; }  bool isRotationallyEquivalent(string &s1, string &s2) {     return isSubstring(s1+s1, s2); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can be done in O(1)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Testcase:  assert (RotationalCheck(\"Stupid Interviewer\", \"Friggin A***ole\") == false);"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=163738","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"10","title":"What is the difference between using Assignment operator and Copy Constructor?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"sample x1=x2; //calls copy constructor sample x1; x1=x2 ; //calls assignment operator"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"They are the same... In the sense both of them perform a shallow copy by default. You can override the default copy constructor or overload the assignment operator for a deep copy."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a copy constructor is created by overloading the assignment operator and we can declare and define in the same expression.. whereas this is not possible through assignment operator"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Copy Constructor is invoked when initializing an object with another (we can make the copy constructor make a deep copy).  An overloaded assignment operator is invoked when object to object assignment is done.(Again we can make sure that this assignment does a deep copy/assignment)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Anonymous' example make it clear along with MJ's explanation..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Assignment operator is used for Shallow Copy by overloading assignment operator. Copy Constructor is used for Deep Copy"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14781667","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"9","title":"Write code for Queue operations add an element to queue and delete an element from queue. Time complexity should be O(1). Queue should be handled using an Array.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"const int QUEUE_SIZE = 1000; \nint push_ix = 0; \nint pop_ix = 0; \nint num_elements = 0; \nint queue[QUEUE_SIZE]; \nvoid push_queue(int val) { \n  if (num_elements == QUEUE_SIZE) return; \n  queue[push_ix] = val; \n  push_ix++; \n  if (push_ix == QUEUE_SIZE) push_ix = 0; \n  num_elements++; \n} \nint pop_queue() { \n  if (num_elements == 0) return -1; \n  int ret_val = queue[pop_ix]; \n  pop_ix++; \n  if (pop_ix == QUEUE_SIZE) pop_ix = 0; \n  num_elements--; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"do amazon really ask such questions?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can have two variable that will hold the index of location from where to pop and from where to push into the queue. We can simulate a cirular queue in this prob."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Its very easy question if its a simple Queue implementation. push() and pop() should be easily doable in O(1). It gets a little tricky when its random element deletion and not the first and last element.  In that case, you can swap the element to be deleted with the first or last element and do the appropriate push or pop operation on it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#include #include using namespace std; template  void print(const queue&); int main() {queueq; print(q); q.push(\"jean\"); print(q); q.push(\"stefan\"); print(q); q.pop(); q.push(\"paul\"); print(q); q.push(\"jessica\"); print(q); q.push(\"david\"); print(q); q.pop();} template  void print(const queue&q) {queueqq=q; cout<<\"size=\"<if(qq.empty())cout<<\";the queue is empty\"; else{cout<<\";front=\"<qq.pop(); while(!qq.empty()) {cout<<\",\"<qq.pop();} cout<<\").\";}cout<<\"\\n\";}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=187770","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"9","title":"Write thread safe getInstance function of Singleton class.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hey is the recruitment going on for freshers in india???"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@megha stop asking this junk question. i've noticed this kinda junk question being asked in many threads, please avoid that. we're here to solve/discuss about the problem at hand. you would be better off asking such questions to your friends."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@megha absolutely correct"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Use double-check pattern with a bool member variable to make it thread safe Instance *getInstance(){   if ( available ){     pthread_lock(mtx);     if ( available ){       _instance = new Singleton();       available = true;        }   } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"typo in the previous post //Use double-check pattern with a bool member variable to make it thread safe Instance *getInstance(){ if ( available ){ pthread_lock(mtx); if ( available ){ _instance = new Singleton(); available = true; } } return _instance; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"IN Java, use synchronised keyword on the static function which returns the singleton object"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bullshit question"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=9077232","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"8","title":"can you call one constructor from another in c++?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"In next C++ standard x10 you will be able to do same as in Java or C#"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Yes but no use, It will create temporary object."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Correct, this can be done.   Simply calling the constructor would create a temporary object, which will be destroyed on the very next line (i.e. the scope of that object would be the line it is getting created)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is covered in C++ faq . Here's the link c++-faq-lite/ctors.html#faq-10.3"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What is the use case for this scenarios when would we do this ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Pre C++11 we can't call a different constructor of the same class , however in C++11, this is allowed which are called delegate constructors."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \nusing namespace std; \n \nclass base{ \n}; \n \nclass der : public base { \npublic: \n der() : base() \n { \n  //base(); \n  cout<<\"hello \"<"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=1734890","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"8","title":"diff between pointer and reference","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Pointers and Reference looks similar but there are some difference between both of them.  POINTER  1) Its not necessary to initialize the pointer at the time of declaration. Like  int a = 10;  int *P = &a; //It is not necessary   Another way is :  int a = 10;  int *P; P = &a;   2) You can create the array of Pointer.  3) You can assign NULL to the pointer like  int *P = NULL; //Valid  4) You can use pointer to pointer.  REFERENCE   1) Its necessary to initialize the Reference at the time of declaration. Like  int &a = 10;  int &a; //Error here but not in case of Pointer.  2) You can not create the Array of reference.  3) You can not assign NULL to the reference like  int &a = NULL; //Error  4) You can not use reference to reference."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In addition to what Bala said, You can never unseat a reference, so  int x,y; int &b = x;  b = y; //Compiler error.  On a more philosophical level, think of pointers as things pointing to chunks of memory, while references are really handles to objects (note that I am using object in the general sense of the word, not c++ objects)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"does amazon ask such trivial questions ??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. A reference must be initialized when it is created but pointers can be initialized at any time. 2. Once a reference is initialized to an object, it cannot be changed to refer to another object but pointers can be pointed to another object at any time. 3. references cannot be NULL but pointers can."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Fundamentally reference can be taken as const pointer. And it is auto de-referenced."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=319707","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"7","title":"implement atoi()","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// to-do: 1.take the first char in str for signed/unsigned check //        2.check for invalid char in str    int my_atoi(const char *str) {     int i=0;     while ( *str )     {         i = (i<<3) + (i<<1) + ((*str) - '0');         ++str;     }      return i; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Thanks Yokuki,  This is one of the most awesome tricks I have ever learned! It made my day.  For those wondering how it works:  You have string \"364\"  Taking chars from left (one by one):  Example: '3'  ('3' - '0') - This gives the actual number in the char.  So i becomes 3. (initially i was 0, therefore bit manipulations resulted in 0)  Then we have to somehow make i from 3 to 30 to left shift the number.  Basically, we want to multiply the number by 10. (i<<3) + (i<<1) does exactly that.   (i<<3) is 8x (i<<1)is 2x  (i<<3) + (i<<1) becomes 10x.  Well, I guess now its clear to every one."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int myatoi(char* input) {         int retVal = 0;         int length = 0;         while(true)         {                 if(input[length] != '\\0')                 {                         int val = input[length] - '0';                         retVal = retVal*10 + val;                         length++;                 }                 else                 {                         break;                 }         }         return retVal; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Twist: Handle negative numbers and out of range case"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#define MIN_INT -2147483648 #define MAX_INT 2147483647  int my_atoi(const char str[]) {     if(str == NULL) return 0;          int len = strlen(str);          if(len <= 0) return 0;      int index = 0;          //skip leading spaces     while(str[index] == ' ') index++;      bool isNeg = str[index] == '-';     int outNum = 0;      if(isNeg)     {         index++;         // skip white space after the sign         while(str[index] == ' ') index++;     }      while(index < len)     {         char currentChar = str[index++];         if(currentChar >= '0' && currentChar <= '9')         {             int oldValue = outNum;             int charVal = currentChar - '0';             outNum *= 10;             outNum += charVal;              //overflow underflow detection             if(outNum < oldValue)             {                 if(isNeg)                     outNum = MIN_INT;                 else                     outNum = MAX_INT;                 return outNum;             }         }         else             break;     }     if(isNeg)         outNum = outNum * -1;     return outNum; }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=7748667","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"6","title":"What difference in behavior you find between Virtual destructors and other virtual functions and why?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Normal virtual function never call base functions where as virtual destructor call base virtual destructor in Epilog."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The virtual destructor invokes the derived class destructor dynamically. After this it calls the immediate base class destructor statically. This sequence of destructors gets called from the the class derivations in the reverse order."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"When derived class object is deleted using the pointer of base class object, both destructor functions of derived class and base class gets invoked. In case of simple virtual function call using base class pointer, only derived class function  gets invoked."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Compilers are responsible for calling destructors as well as constructors when object is deleted or created respectively ). So in case of virtual destructors compiler makes sure both derived class followed by base called descrutors are called i.,e in reverse order of creation. This would ensure cleanup of the object completely and cleanely"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"-Virtual destructor doesn't need V-table creation. -Destructor can't be override in child class. -If you are making it pure virtual, you have to provide definition in base class itself."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4119008","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"5","title":"What is difference between operator overloading and overriding?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"operator overloading allows for natural arithmetic and other expressions when building custom classes. like ,let we want to use sort function and we have two parameters by which sort could be done. let it's a struct node{int des,int cost},we have adjacency list to make a graph and for which we want to sort, first by cost and if cost are equal then sort by diff in ascending order.So here we need to define '<' for sort function as bool operator < (cosnt struct node &a,const struct node &b){if(a.cost!=b.cost)return a.cost< b.cost;return a.des < b.des;} By doing this in the sort function operator '<' will perform mentioned work hence by doing this way we will get our purpose efficiently and effectively.You can find more to here topcoder.com/tc?module=Static&d1=features&d2=060204.  Method overriding, in object oriented programming , is a language feature that allows a subclass or child class to provide a specific implementation of a method that is already provided by one of its superclasses or parent classes.For more details try this one en.wikipedia.org/wiki/Method_overriding"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"By no means, this can be an Amazon interview question."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@blueskin: Thanks for your input. I will wait for that fine day when they will offer me such piece of cake. I am a veteran Amazon applicant/aspirant."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"lol....  y the hell pppl r dying for this company .... there are other good company in this market....check it out or at least \"Google\" it...:P"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16907667","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"1. What is difference between override and overload 2. abstract. when will u use abstract 3. what is an interface 4. what is difference betwwen array and link list 5. what is a tree 6. what is a map\\dictionary 7. Explain (orally) how would you implement a dictionary via a tree","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"1. Override is replacing a method in a subclass with the same signature as a virtual method in the parent class. When called it invokes the subclass's version of the method instead of the parent class. Overload is when you modify the method signature but keep the name to support variants of the same procedure, its a form of parametric polymorphism.  2. Abstract is a partially implemented class that is meant for derivation. It provides base functionality but leaves key implementation details to the user of the class. It is typically used in template-method patterns where the core algorithm does not change but the details of how to get the data are context sensitive.  3. An interface is a completely unimplemented class that serves as a contract for how this abstract type will communicate with other objects. It provides a set of methods with signatures determining what calls this type supports.  4. An array is a block of memory with fast random-access times due to its mechanic for traversing the array (offsetting a pointer from the first element in the array). A linked list is a set of pairs where one element of the pair is a piece of data and the other is either a null link or a link to the next pair. Linked lists do not provide a good way of randomly accessing elements but they excel at insertions and deletions from any point in the list.  5. A tree is an abstract data type that contains elements. It has properties that make it desirable for scenarios where you want to look up data quickly but only if certain properties are maintained.  Properties are: the tree must be balanced, all nodes must be ordered such that every subtree to the left is less than or equal to the root. All nodes to the right of the root must be greater than the root.  6. A map or a dictionary is a data structure that connects arbitrary pieces of data together via a fast lookup mechanism. They are typically implemented with hash-tables but sometimes a balanced binary search tree like Red Black Trees or AVL Trees are used.  7. Implement an AVL tree and make sure that its keys and values can support any type, if its a dynamically typed language then no problem just implement the logic behind rotations, insertions, deletions, etc. If its a statically typed language with a meta-programming mechanism then use that to generate AVL[Int,String] AVL[String, Int] etc..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Override is replacing a method in a subclass with the same signature as a virtual method in the parent class. When called it invokes the subclass's version of the method instead of the parent class. Overload is when you modify the method signature but keep the name to support variants of the same procedure, its a form of parametric polymorphism.  2. Abstract is a partially implemented class that is meant for derivation. It provides base functionality but leaves key implementation details to the user of the class. It is typically used in template-method patterns where the core algorithm does not change but the details of how to get the data are context sensitive.  3. An interface is a completely unimplemented class that serves as a contract for how this abstract type will communicate with other objects. It provides a set of methods with signatures determining what calls this type supports.  4. An array is a block of memory with fast random-access times due to its mechanic for traversing the array (offsetting a pointer from the first element in the array). A linked list is a set of pairs where one element of the pair is a piece of data and the other is either a null link or a link to the next pair. Linked lists do not provide a good way of randomly accessing elements but they excel at insertions and deletions from any point in the list.  5. A tree is an abstract data type that contains elements. It has properties that make it desirable for scenarios where you want to look up data quickly but only if certain properties are maintained.  Properties are: the tree must be balanced, all nodes must be ordered such that every subtree to the left is less than or equal to the root. All nodes to the right of the root must be greater than the root.  6. A map or a dictionary is a data structure that connects arbitrary pieces of data together via a fast lookup mechanism. They are typically implemented with hash-tables but sometimes a balanced binary search tree like Red Black Trees or AVL Trees are used.  7. Implement an AVL tree and make sure that its keys and values can support any type, if its a dynamically typed language then no problem just implement the logic behind rotations, insertions, deletions, etc. If its a statically typed language with a meta-programming mechanism then use that to generate AVL[Int,String] AVL[String, Int] etc..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hooray OOP questions  1. What is difference between override and overload   Override: When a class inherits from another class, any method or value in the superclass that shares a name with the subclass will be overriden, meaning it will be ignored in favor of the subclass's definitions. If superclass contains a method"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"It is a java question rather than C++ question."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16012679","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"Design a Tic Tac Toe Game. Classes Segregation and Code Flow.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"The key thing on this type of question is not to freeze up.  Get something on the whiteboard:  1) You want to draw the board.  Have a DrawBoard class (or function). 2) You have players.  Have a Player class. 3) Players take turns.  Have a GamePlay class. 4) You need to keep track which moves have been made.  Have a Game class. 5) You need to decide if somebody won.  Have a GameEvaluate class.  Get something out there, then work with the interviewer to simplify things.  Do you really need a special GameEvaluate class?  Maybe a Game object can supply the method that says whether a game is over.  Seems like a reasonable responsibility for the game class.  But maybe the actual calculation drives out a simple Matrix class.  The key thing here is to be flexible and brainstorm.  Also, don't let the full complexity of the problem overwhelm you.  Before you figure out how to orchestrate players taking turns, simplify the problem.  Say that you just read the player's answers from a file, fill in the grid, and then say who won.  If you can figure out how to model that, you have a good foundation for the rest of the problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Main Class will be as follows:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Tic Toc game simulation.......... \n#include \n#include \n#include \nchar bord[3][3]={{'1','2','3'},{'4','5','6'},{'7','8','9'}}; \nchar win_status='\\0',turn='\\0'; \nchar win_check(char); \nvoid add_on_board(char); \nvoid print(void); \nvoid main() \n{ \n  \n printf(\"Welcome to Tic Toc Game\\n\"); \n printf(\"Rule-1: Two players, A and B.\\n\"); \n printf(\"Rule-2: A has 'X' and B has 'O' piece on board. \\n\"); \n printf(\"Initial status of board\\n\"); \n  \n print(); \n char e='\\0',f; \n int n=1; \n printf(\"ready to play?(y/n):\"); \n scanf(\"%c\",&f); \n f=getchar(); \n while(win_status=='\\0' && n<5) \n { \n  system(\"clear\"); \n  printf(\"For A ==> X\\nFor B ==> O\\n\\n\"); \n  print(); \n  if(win_status=='\\0') \n  { \n   turn='A'; \n   printf(\"A 's turn: press number:\"); \n   fflush(stdin); \n   //sleep(3); \n   scanf(\"%c\",&e); \n   f=getchar(); \n   //scanf(\"%c\",&f); \n   add_on_board(e); \n   win_status=win_check('X'); \n   print(); \n  } \n  if(win_status=='\\0') \n  { \n   turn='B'; \n   printf(\"B 's turn: press number:\"); \n   fflush(stdin); \n   scanf(\"%c\",&e); \n   f=getchar(); \n   add_on_board(e); \n   win_status=win_check('O'); \n   print(); \n  } \n  n++; \n } \n switch(win_status) \n { \n  case 'A': \n   printf(\"Winner is ---A---\\nCongrates\\n\"); \n   break; \n  case 'B': \n   printf(\"Winner is ---B---\\nCongrates\\n\"); \n   break; \n  default: \n   printf(\"Match draw!\\n\"); \n } \n  \n} \nchar win_check(char p) \n{ \n char temp[3]={'\\0'}; \n int i=0,j=0,k=0; \n for(i=0;i<3;i++) \n { \n  for(j=0;j<3;j++) temp[j]=bord[i][j]; \n   \n  for(k=0;k<3;k++) if(temp[k]!=p) break; \n   \n  if(k==3) return (p=='X'?'A':'B'); \n } \n for(i=0;i<3;i++) \n { \n  for(j=0;j<3;j++) temp[j]=bord[j][i]; \n   \n  for(k=0;k<3;k++) if(temp[k]!=p) break; \n   \n  if(k==3) return (p=='X'?'A':'B'); \n } \n for(i=0;i<3;i++) temp[i]=bord[i][i]; \n  \n for(k=0;k<3;k++) if(temp[k]!=p) break; \n  \n if(k==3) return (p=='X'?'A':'B'); \n  \n for(i=0;i<3;i++) temp[i]=bord[i][2-i]; \n  \n for(k=0;k<3;k++) if(temp[k]!=p) break; \n  \n if(k==3) return (p=='X'?'A':'B'); \n  \n return '\\0'; \n} \nvoid add_on_board(char c) \n{ \n int i=0,j=0; \n for(i=0;i<3;i++) \n { \n  for(j=0;j<3;j++) \n  { \n   if(bord[i][j]==c)  \n   { \n    bord[i][j]=(turn=='A'?'X':'O');  \n    return; \n   } \n  } \n } \n} \nvoid print(void) \n{ \n int i=0,j=0; \n printf(\"\\n\"); \n for(i=0;i<3;i++) \n { \n  for(j=0;j<3;j++) \n  { \n   printf(\"%-4c\",bord[i][j]); \n  } \n  printf(\"\\n\"); \n } \n}"}]}}]