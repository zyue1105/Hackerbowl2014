[{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=9119235","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"87","title":"Consider a series in which 8 teams are participating. each team plays twice with all other teams. 4 of them will go to the semi final.How many matches should a team win, so that it will ensure that it will go to semi finals.?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"15","title":"56 points are distributed to 8 team. In the worst case, team0 loses all the games, he gets 0 point. team1 win two games with team0 and loses all other games, he gets 2 points. In the same way, team2 gets 4 points, team3 gets 6 points. So there are 44 points left which can be distributed to the remaining 4 teams. So the assurance points for a team should be 11 points."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"It's 11: Let number the teams : 1 , 2.. 8, and say 8 beats all 1..7, 7 beats all 1..6 we will have this: 8: 14  7: 12 6: 10 5: 8 4: 6 3: 4 2: 2 1: 0  Ok for now it seams that 8 is a good answer, but is it? Let's make very equilibrated, and make team number 4 closer to the top: 1) Let's assume Team 4 bets team 8 twice: that will result in: 8:12 (14 - 2) 7:12 6:10 5:8 4:8 (6 + 2) 3:4 2:2 1:0  Now it seams that 8 is not good, and it's 9, but is it?  2) Let assume Team5 beats team 8 twice  8:10 (14 - 2 - 2) 7:12 6:10 5:10 ( 8 + 2) 4:8 (6 + 2) 3:4 2:2 1:0  Now it seams that 10 is just perfect , but is it?  3) The final match: Team4 beats Team 7 twice:  8:10 (14 - 2 - 2) 7:10 (12 - 2) 6:10 5:10 ( 8 + 2) 4:10 (6 + 2 + 2) 3:4 2:2 1:0  It seamns that if this would happend 11 is the perfect number Another reason is that the 5 team beats all the team, but still, remains 6 points( beacause there must play Team3 vs Team2 twice, T3 vs T1 and T2 vs T1) and remains 50 points 50/5 = 10 points in the perfect case . and because of that 11 is the number."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"8 teams will play other 7 teams twice, so they would play 14 games in all. Now say 1 game win is 1 point, ideally best team winning all will have 14 points. the next best will have 13,12,11. So worst case when the rank 1-3 teams wins as above, teams need to win at least 11 matches to reach semifinal.  There can be best cases when team rank1 wins 10 matches"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For semi finals teams win min 8 match  ...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why not atleast 11 matches. Let say we have 4 teams A,B,C and D these teams have won all matches with E,F,G and H. So Each team wins 8 Matches. Now A has to play 6 Matches(2 each with B, C and D), lets say A lost 1 match and won 1 match with each B,C and D. Same is the case with B, C and D. So each of A,B,C and D has won 11 matches and they are in semifinal."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"total no. of games can be played are: (8c2)*2. that is 56.so, 56 points can be scored overall if for one win one point is considered. consider one team losses all matches . second team wins 2 matches and 3rd team wins 4 matches. now totally 6 points are csored. now 50 points left for 5 teams. consider remaining five teams score 10 points each. even in that case also tie may happen for all 5 teams. so, you need to score 11 points to be in semi final."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A team will play total of 7*2 = 14 games so 8 games is needed for a team to advance to next stage"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"11."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A team will have to play 7x2 matches. Just for example a team has to play 7 matches with all other team once in home ground and other 7 matches in away ground once.  For an example teams won their home games and lost their away games. That means all the 8 teams will have same points bcoz all the teams won 7 matches each(which is the worst case)  For a team for qualifying semi-final it has to win atleast 8 games."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It has to be 8. Consider the case when every one has on the same number of matches, this is possible when out of 14 each win 7 and lose 7.  so all will have same points 7 right. Then if any team would have won 8 times then his place would be confirm in the semifinals."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Answer is 11, using the formula given above 2*(8c2-4c2).  but for 10 teams, answer should be 15, because only 4 teams are going to play semifinals.  so 2*(10c2-6c2) = 60 matches for all the teams in the semifinal; hence, at least 15 wins are required."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a simplified formula could be 2*(N-M)+(M-1) where, N - total no of teams        M - no of teams to be selected"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"8 games"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think it is 12 games...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"wfchiang - it is incorrect even when you think intuitively - no disrespect though.  Answer = 8 games. Total games played: 8 teams * 14 games = 112 games Games won: 112/2 = 56 games (because when one team wins, other loses - assuming no ties) What is the most competitive situation case: 56 games/8 teams = 7 games won by each team. So when all teams win 7 games each, it means they all have equal place. To get to 1st place, it must be 8, but other team win should be diminished to 6 To get into 2 winning teams, it again must be 8, making 2 other teams win =6 and so forth, until we have 4 teams having 8 wins and 4 teams having 5 wins So, in most competitive situation, you will need 8 wins to get through. If someone has better mathematical explanation, I will appreciate that"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"have to correct myself. All 5 teams beat 3 teams twice. Each team now has 6 points (30 points total) and 8 games to play with other top teams (20 points to split). Should they each win 4 games and lose 4, each of them will have 10 points. Or 50/5=10. To avoid the draw a team has to win 11 games."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"forgot to sign"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"8 wins. Remember IPL? 16 points has been qualification each time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"However in the best case scenario the least no of wins required is 5"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how about 8? prime example is IPL.All 3 seasons 8 wins have been enough.So 11 is wrong."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"11 games."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"IF THR ARE ONLY 1 POINT FOR A MATCH THEN TEAM SHOULD GET ATLEAST 50  POINTS TO GO IN TOP 4 PLACES ....."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"8"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In my view if A team wins all the matches he gets 14 points, the second best team B could get 12 points as B lost to A already and C gets 10 points as he lost to both A and B and D will get 8 points as he wins with the rest. so 8 could be the answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Look at this situation below. 1st 5 teams split 11 wins each (11 * 5 = 55) Total is 56 wins. In that situation, you do need 12 wins to guarantee to get through. Just put that in Excel. So wfchiang is correct I take my words back - 12 wins is the answer  Team    No Wins 1?????? 11 2 11 3 11 4 11 5 11 6 0 7 0 8 0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"To make sure that a particular team makes it to the semi-finals without worrying about other teams performance the team has to win 11 games/points. In a real world there can be a win/lose/draw(tie).   Here is the explanation: Each team plays the other team = (8 X 7) / 2 = 28 games (Divided by 2 as each game has 2 teams  As the teams play each other twice it is 28 X 2 = 56 games in total  To find out a minimum number of games required to qualify, lets assume that there is atleast 1 more team (5th team) competing. Assume the worst case that the remaining 3 teams don't win any matches with the competing top 5 teams.  But those botton 3 teams still play a total of 6 games with each other and would get points for those games.   So from above the top 5 teams get points from the remaining 50 games. Dividing them equally its 10 points or wins each team.   And hence to qualify for sure without considering any other teams performance, any team that wins 11 games or in real world gets 11 points (considering 1 point for a win and half a point for a draw) would qualify for semis.  So the correct answer is 11 points (1 point for a win and 0.5 point for a draw/tie)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think answer is 12.  Each team plays 14 games, and there are 56 games in total.  Let the minimum number of wins to ensure a top 4 finish be X.  The number of wins are closely bunched when the top teams all win X games.  To ensure progress to semi-final, the 5th team (by order of most wins) must not be able to get X wins.  So, we have 56 - (4*X) < X => X > 11.2 So X is 12.  Cases: With X = 11, top 4 teams win 11 each, there are 12 games remaining to be won. The 5th team can still win 11 games. Thus, progress to semifinal is not ensured.  With X = 12, top 4 teams win 12 each, there are 8 games remaining to be won. This ensures 5th team can in no way progress to semifinal."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Full mark would be 14.  if team T got 13, that means it is possible an other team T1 win all the game except losing one to T(there two matches). T and T1 are all at first place with 13 wins.  if team T got 12, that means there are two situations: a > it exists a team T3, wins all game(including the two lost by T), T is the second place. b > it exists two teams, T4 and T5, they won T once, and T4 to T5 once and T5 to T4 once, they got 12 points too. So, will three are at fist place. If team T got 11, that means it lost 3 games: a > it exists a team T6, wins all game, including 2 of T. another team tie T7 to T got 12 points(lost one to T6). b > it exists another 3 teams, all get 11 points. That's the minimum we can accept.  So 11 is the answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Total number of games needed will be (Total_Games_To_Be_Played_By_each_team / 2) - Number_of_Already_qualified_teams  So this number keeps changing as soon as one team reaches 7.  I am dividing by 2 becayse each team needs to play twice against same opponent."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Answer is 10, let us assume there all win same number of matches, where no one goes to semi 8 * number of wins = total matches total matches = 8C2 *2 = 72 number of wins where no one goes to semi's = 9 Inorder for 4 to go, 4 teams have to win above 9 i.e 10 where 4 teams win 10 matches and remaining win 8 matches, you can secure you place in semi's if no of win is more than 10"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@Nikhil Your answer is wrong. The correct answer is if you win 8 you are guaranteed"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"8 is the right answer. Let there are 8 teams A, B, C,D,E, F, G, H. So consider that A has win over all so he has won 14 matches. Let at second place B is coming so B is all ready having a defeat with A so he can win only 12  matches then similarly C can win only ten matches and d can win only 10 matches. So winning 8 matches ensure you in semifinal"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Answer is 13. The tightest score can be A-->10 B-->10 C-->10 D-->10 E-->10 F-->4 G-->2 H--->0 So to make sure the team enters into semi it has to win 11 games"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorry typing mistake Answer is 11 and all of u who are confusing... u have to make sure that team enters in any condition... so answer will be 11 only"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What happens if all teams win 7 matches each???"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"12 wins insures semifinals. informal proof: there are only 56 matches. find minimum value of n wins such that 4 other teams cannot win that many. so 5n<56 n>=12. 5 teams cannot win 12 games because there are not that many matches but 5 teams can win 11 games."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It has to be 11 matches.. 8th team scored 0 wins.. then 7th team have at least 2 wins.. 6th placed team can have at least 4 wins.. so we have 6 wins.. 50 wins left for 5 teams... now each team won 10 of matches.. so we have five teams each won 10 matches an d place in semis depends on run rate.. so if any team won 11 matches will go to semis without consideration of run rate..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Tightest can be 14,14,14,14,0,0,0,0  But the minimum case would be 8,8,8,8,6,6,6,6  Confirming their entry would be \"11\" but I dont think thats the question."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For minimum matches to reach to the semifinals : 14 12 10 4 4 4 4 4  For maximum matches so that unable to reach the semifinals: 10 10 10 10 10 4 2 0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"please don't read this long chain of comments and save ur time .......following solution is correct  answer : 8 explanation :  all team played equally well then following is condition : (team) (matches played) (win) (lose) 1 14 7 7  2 14 7 7 3 14 7 7  4 14 7 7  5 14 7 7  6 14 7 7 7 14 7 7  8 14 7 7  ....................it means that no one can going to semi final or all are going to semi final...it means that answer is bigger than 7.....  Now, consider answer is 8 .....and suppose that 4 team won 8 matches and lose 6 matches out of 14 ..then following situation :  (team) (matches played) (win) (lose) 1 14 8 6  2 14 8 6  3 14 8 6   4 14 8 6  5 14 7 7  6 14 7 7 7 14 7 7  8 14 7 7   ....here we can decide that team 1,2,3,4 can go to semi final ....so answer is 8 !!!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"correcting stupid mistake ................. please don't read this long chain of comments and save ur time .......following solution is correct answer : 8 explanation : all team played equally well then following is condition : (team) (matches played) (win) (lose) 1 14 7 7 2 14 7 7 3 14 7 7 4 14 7 7 5 14 7 7 6 14 7 7 7 14 7 7 8 14 7 7 ....................it means that no one can going to semi final or all are going to semi final...it means that answer is bigger than 7..... Now, consider answer is 8 .....and suppose that 4 team won 8 matches and lose 6 matches out of 14 ..then following situation : (team) (matches played) (win) (lose) 1 14 8 6 2 14 8 6 3 14 8 6 4 14 8 6 5 14 6 8  6 14 6 8  7 14 6 8  8 14 6 8   ....here we can decide that team 1,2,3,4 can go to semi final ....so answer is 8 !!!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There are total 56 matches. In worst case 11, ,11, 11, 11, 12 . So minimum matches  should be 12"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Total no. of points is 56.  max points any team can ge is 14  No. of points someone can make to be sure of a playoff spot is 12. 56/12 = 4, so if 4 teams get 12 points then there are only 8 points left for the others to get into the playoffs which is not possible.  56/11 = 4, so if 4 teams get 11points then there are 12 points left for the other teams to get, thus if one of those teams wins all games against those not making 11 points then it will have 12 points.  thus the minimum amount of points that guarantees a  playoff spot is 12."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The solution is 11 and I think the logic behind is as below: Fact1: there are totally 56 matches, so the total number of winning and the number of losing should be 56. (for each match there should be a winner and a loser) Fact2: each team would have 14 matches with the others, so for each team, the number of winning plus the number of losing should be 14. In order to find the min number of winning times to ensure to get into semi, we assume the first four teams are supposed to get in. We let the number of winning for the first four teams be x, so they number of losing for them is (14-x). If the x is not large enough, we would find at least one team, let's say team 5, have the number of winning more than x. We need to avoid this happen. Let's assume the team 5 be our bottleneck and we let it has the winning as large as possible. We cannot ignore the last three teams at the same time. there are two matches between team 6 and team 7; two matches between team 7 and team 8, so there should be at least four winning time for team 6,7,8. So the first five teams should split at most 52 winnings. So the number of winning left for team 5 is at most 52-4*x. We let 52-4*x10.4, so the solution is 11."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Let's use N represent the number of the matches that a team must win to  ensure semi final.  Let divide the 8 teams into 2 4-team groups: A and  B.  All the teams in group A enter semi final. N is obtained when the  following two conditions are satisfied:  1. Group A wins the most possible points. 2. The points of group A are distributed evenly to all 4 teams.  Condition 1 is satisfied when all teams in group A wins in games against  teams in group B. In such cases, group A has more than 32(4 * 8) points  than group B. Group A also has 12 points for games against each other  within group A. So group A has 44 (32 + 12) points in total. Distribute  44 points evenly to 4 teams. 44/4 is 11. So N is 11 points.  If a much rigorous solution is needed, condition 1 and 2 need to be  proved."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"8"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=7528760","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"158","title":"If [a1,a2,a3...,an,b1,b2...bn] is given input change this to [a1,b1,a2,b2.....an,bn] , solution should be in-place","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"12","title":"Algorithm:    First swap elements in the middle pair  Next swap elements in the middle two pairs  Next swap elements in the middle three pairs   iterate n-1 steps.  Ex: with n = 4. a1 a2 a3 a4 b1 b2 b3 b4 a1 a2 a3 b1 a4 b2 b3 b4 a1 a2 b1 a3 b2 a4 b3 b4 a1 b1 a2 b2 a3 b3 a4 b4"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Anony and Adiser I think there is an O(n) sol for this :) I went thro some examples and the new position of an elt can be given mathematically new id=(2*old id)%N...here N is the final index...not the number of elts...or (no of elts-1) Heres the code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Copies from another similar question asked in this forum  Algorithm:  First swap elements in the middle pair Next swap elements in the middle two pairs Next swap elements in the middle three pairs  iterate n-1 steps.  Ex: with n = 4. a1 a2 a3 a4 b1 b2 b3 b4 a1 a2 a3 b1 a4 b2 b3 b4 a1 a2 b1 a3 b2 a4 b3 b4 a1 b1 a2 b2 a3 b3 a4 b4"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"This is in place array transpose."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Use divide and conquer for n log n. This is faster than O(n) in-place transposes on real hardware because of caching effects. (Yes, I've tried it.)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Input: a1,a2,a3,a4,.....an,b1,b2,b3,b4,.....,bn Output: a1,b1,a2,b2,a3,b3,a4,b4,..........an,bn.  If we notice, there is a pattern for all elements while shuffling. For all elements from 1st half portion (a1 to aN) a[i] is moved to a[2*i] where 0<= i <= n [say array name is a] i.e. a[0] is moved to a[0] (for i=0, i = 2*i =0) a[1] is moved to a[2] a[2] is moved to a[4] a[3] is moved to a[6] ...... .... For 2nd half, same is true from opposite (OR if we see array inverted,b1 to bN behaves same as a's) In other words, keeping array as is, 2nd half of the array (b1 to bN) goes like this  a[i] is moved to a[(n+1)-2*(n-i)] where n/2 < i < 2n i.e. (Assuming 2nd half array starting with index i=7, so total array size 12)  a[7] moved to a[1] a[8] moved to a[3] a[9] moved to a[5]  overall as example: Input a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11] Output: a[0], a[6], a[1], a[7], a[2], a[8], a[3], a[9], a[4], a[10], a[5], a[11]  And I believe it's pretty straightforward to implement this. using only few extra variables [not dependent on array size](Based on implementation). So, O(n) time and O(1) space [IN PLACE].  Alg: [assuming all elements are > 0)  Negate all elements (a[i] = -1 * a[i];) current_index = 0; current_element=A[0]; do     if current_index <= n/2 then            to_index = 2*current_index     else            to_index = (size + 1) - 2*(size - current_index)     end if     current_element = A[to_index];     A[to_index] = -1 * A[current_index];     if current_element > 0 then           to_index = index of next negative element.     current_index = to_index; while A[current_index] < 0  Algo can be modified to check in other cases like when elements can be negative also, OR elements are characters, strings. There can be different ways to track if all elements are processed or not, depending on problem. e.g. if negative elements are also in input then, Add some very very negative no to all elements say -50000 and while assigning it to to_index, adding 50000 If element are characters, string then attach some keyword (prefix or suffix) to each element, while assigning it to to_index, remove the attachment."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void reorder(char[] input, int n) { \n  for (int i = 1; i < input.length; i = i+2) { \n   int replaceElem = (2*n + i - 1)/ 2; \n   char swap = input[replaceElem]; \n   for (int j = replaceElem; j > i; j--) { \n    input[j] = input[j-1]; \n   } \n   input[i] = swap; \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@blueskin: Yes, my algorithm has O(n*n) time complexity but O(1) space complexity. Your algorithm will need additional storage to store the corresponding values.   If we are allowed O(n) space complexity, the simplest thing to do would be to just use two queues. Put values a1 to an in Q1 and b1 to bn in Q2. Now, just dequeue one element from each and keep populating the array. O(n) time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void ReOrder(ArrayList a) {     for(int  i=a.size()/2; i                int finalPos=((i-a.size()/2)+1)*2-1;                 String temp=a.get(i).toString();                 for(int j=i; j>finalPos; j--){                         a.set(j, a.get(j-1));                  }                  a.set(finalPos, temp);         } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If [a1,a2,a3...,an,b1,b2...bn] is given input change this to [a1,b1,a2,b2.....an,bn]  The idea is to move index 2 everytime, starting at 1. swap a[i] with a[len/2+i] - a1,b1,a3,a2,b2,b3. swap a[i+1] with a[len/2+i] - a1,b1,a2,a3,b2,b3.  The idea to start with keep every 2 things in order and move forward."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"lets take a0, a1, a2, a3, a4, b0, b1, b2, b3 ,b4, b5. 1) swap a1 with b0  to get  a0, b0, a2, a3, a4, a1, b1, b2, b3 ,b4.  2) shift a1 to arr[2] to get  a0, b0, a1, a2, a3, a4, b1, b2, b3  b4.  now we reduced problem from 10no.arry to 8no. array. two steps take n/2 swaps. decreasing by 1 with each iteration. so order is O(n2).  otherthan this, i did nt see a better solution. Can any one improve this?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I tried a recursive process of starting at pos1, moving it to its correct place, then moving the element there to its correct place in tunr, once you have done len -1 steps you are done. You wont get any cycles because you are always putting something in its correct place - no 2 elements can be in the same place. Only the first element starts off in its correct place. Not sure if stack for recursion violates in-place though"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Anurag,  how many times does the nested for loop run for each iteration? does nt that change order?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"yup that works :) cool soln. thx satya."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Another O(n) solution based on divide-and-conquer. Recursively divides n by 2, and use the result of two halves to merge the final result.   Examples demonstrate for n = 2^k. When n is not 2^k, we can add some dummy elements, and do the same process, and finally discard those that are dummy."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I took anon's code for making the list but a different approach for arranging it - I believe this is O(n) and satisfies the in-space problem"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(N) ..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \nstruct demo{ \n  char c[3]; \n}; \n \nvoid swap(struct demo *a, struct demo *b) \n{ \n  struct demo temp; \n  temp = *a; \n  *a = *b; \n  *b = temp; \n} \n \nint  main() \n{ \n  int size,i,j,p,x,y; \n  static struct demo ab[10] = {{\"a1\"},{\"a2\"},{\"a3\"},{\"a4\"},{\"a5\"},{\"b1\"},{\"b2\"},{\"b3\"},{\"b4\"},{\"b5\"}}; \n \n  size = sizeof(ab)/sizeof(ab[1]); \n \n  for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// extension of swapping problem   j=n; for(i=1;i{ temp=a[i]; a[i]=a[j]; a[j]=temp; j++; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// extension of swapping problem   j=n; for(i=1;i{ temp=a[i]; a[i]=a[j]; a[j]=temp; j++; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// extension of swapping problem   j=n; for(i=1;i{ temp=a[i]; a[i]=a[j]; a[j]=temp; j++; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@ankur  Please run through the code.I don't think it is correct. REsulting order has to be  a1,b1,a2,b2,a3,b3 ...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Though bad in terms of efficiency, it can be done in way of insertion sort, where pick b1 and insert at 2nd position and  copy a2-an one by one till b1 position"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void printArray(char a[][5],int len) {  int i;  for(i=0;i  printf(\"%s  \",a[i]);  }  printf(\"\\n\"); }  void shuttleArray(char a[][5],int len) {  printArray(a,len);  int count=1; int i,j; int pos=0;  char *newbuf=(char *)malloc(5);  char *oldbuf=(char *)malloc(5); char *tmp;  int *mark=(int *)malloc(sizeof(int)*len);  for(i=0;i  mark[i]=0;  i=1;  strcpy(oldbuf,a[i]);  mark[0]=1;  while(count  if(i   pos=(2*i+1)%len-1;   else    pos=(2*i)%len+1;   strcpy(newbuf,a[pos]);   strcpy(a[pos],oldbuf);   mark[i]=1;   tmp=oldbuf;   oldbuf=newbuf;   newbuf=tmp;   i=pos;   if(mark[i]==1) {    for(j=0;j    if(mark[j]==0)      break;    i=j;    strcpy(oldbuf,a[i]);   }   ++count;  }  printArray(a,len); }  int main(void) {  //puts(\"!!!Hello World!!!\"); /* prints !!!Hello World!!! */  //int a[]={1,2,3,3};  //permutation(a,4,0);  char a[10][5];//={\"a0\",\"a1\",\"a2\",\"a3\",\"a4\",\"b0\",\"b1\",\"b2\",\"b3\",\"b4\"};  int i,pos;  for(i=0;i<5;i++) {   sprintf(a[i],\"a%d\",i);  }  for(i=0;i<5;i++) {   sprintf(a[i+5],\"b%d\",i);  }  int len=10;  for(i=0;i  if(i   pos=(2*i+1)%len-1;   else    pos=(2*i)%len+1;   printf(\"%d   \",pos);  }  printf(\"\\n\");  shuttleArray(a,10);  return EXIT_SUCCESS; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for(i=1,j=n ; j<2n||i<2n; i+=2,j++) {  temp = arr[j];  for(k=j;k>=i;k--)   arr[k]=arr[k-1];  arr[i] = temp; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void printArray(char a[][5],int len) {  int i;  for(i=0;i  printf(\"%s  \",a[i]);  }  printf(\"\\n\"); }  void shuttleArray(char a[][5],int len) {  printArray(a,len);  int count=1; int i; int pos=0;  char *newbuf=(char *)malloc(5);  char *oldbuf=(char *)malloc(5); char *tmp;  i=len/2;  strcpy(oldbuf,a[i]);  while(count  if(i   pos=(2*i+1)%len-1;   else    pos=(2*i)%len+1;   strcpy(newbuf,a[pos]);   strcpy(a[pos],oldbuf);   tmp=oldbuf;   oldbuf=newbuf;   newbuf=tmp;   i=pos;   ++count;  }  printArray(a,len); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void cyclicswap(int *arr1, int *arr2) {      int n = arr2-arr1;      int temp = *arr2;    while(arr2!=arr1)    {      *arr2 = *(arr2-1);                     arr2--;                   }              *arr1 = temp;;             }  void rearrange(int *arr,int n) {      if (n==2)         return;      swap(arr+1, arr+(n/2));              cyclicswap(arr+2,arr+(n/2));        rearrange(arr+2,n-2);          }  main() {      rearrange(arr,sizeof(arr)/sizeof(arr[0]));   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the index i is from 1 to 2n.  if i <= n,   j=2*i-1, //the final place else  j=2*(i-n)  use a loop from 2 to n-1 to put each element into the final place.  void rearrange(int *a, int n) {   for(int i = 1; i < 2*n; ++i)   {    } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"+23          int chars_left = n/2;    +24          for(int position = 1; chars_left != 1; chars_left--,position = position+2)    +25          {    +26                  for(int i = n - chars_left; i > position; i--)    +27                  {    +28                          int temp = c[i];    +29                          c[i] = c[i-1];    +30                          c[i-1] = temp;    +31                  }    +32          }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If N is power of 2, swap the second half of a[i] with the first half of b[i] with O(N/2) operations. Then recursively do rearrange of the first N elements and the second N elements. If N is not power of 2, some spacial handling is needed to decide how many elements to swap each time. But it does not change the complexity. The overall complexity is O(NlgN)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ch.v.Suresh:  Under line high lighted are shift elements.  One shift:  a1 a2 a3 a4 a5 a6 a7 a8  ---> Even postions    --    --    --    -- b1 b2 b3 b4 b5 b6 b7 b8  ---> Odd positions --    --    --    --  Two shift:   a1 b1 a3 b3 a5 b5 a7 b7       -----       ----- a2 b2 a4 b4 a6 b6 a8 b8 -----       -----    Four shift:   a1 b1 a2 b2 a5 b5 a6 b6             -----------  a3 b3 a4 b4 a7 b7 a8 b8 -----------  Result:  a1 b1 a2 b2 a3 b3 a4 b4 a5 b5 a6 b6 a7 b7 a8 b8"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ch.v.Suresh:  Under line high lighted are shift elements.  One shift:  a1 a2 a3 a4 a5 a6 a7 a8 ---> Even positions a2,a4,a6,a8     --   --    --    -- b1 b2 b3 b4 b5 b6 b7 b8 ---> Odd positions b1,b3,b5,b7 --    --    --    --  Two shift:  a1 b1 a3 b3 a5 b5 a7 b7 --> Even positions (a3,b3) , (a7,b7)       -----       ----- --> Odd positions (a2,b2) , (a6,b6) a2 b2 a4 b4 a6 b6 a8 b8 -----       -----  Four shift:  a1 b1 a2 b2 a5 b5 a6 b6   --> Shift (a5,b5,a6,b6) with (a3,b3,a4,b4)             ----------- a3 b3 a4 b4 a7 b7 a8 b8 -----------  Result:  a1 b1 a2 b2 a3 b3 a4 b4 a5 b5 a6 b6 a7 b7 a8 b8"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include /*a1b1a2b2a3b3*/ void set(char a[],int m1,int m2); int main() {     char a[7]={'a','c','e','b','d','f','\\0'};     int m1,m2,len,i;     len=strlen(a);     m1=(len-1)/2;     m2=m1+1;     set(a,m1,m2);     for(i=0;i    printf(\"%c\",a[i]);}     getchar();     getchar();     return 0; } void set(char a[],int m1,int m2) {    int len;    char t;    len=strlen(a);    t=a[m1];    a[m1]=a[m2];    a[m2]=t;    while(m1>1 && (m2<(len-1)))    {      t=a[m1];      a[m1]=a[m1-1];      a[m1-1]=t;      t=a[m2];      a[m2]=a[m2+1];      a[m2+1]=t;      --m1;++m2; }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include /*a1b1a2b2a3b3*/ void set(char a[],int m1,int m2); int main() {     char a[7]={'a','c','e','b','d','f','\\0'};     int m1,m2,len,i;     len=strlen(a);     m1=(len-1)/2;     m2=m1+1;     set(a,m1,m2);     for(i=0;i    printf(\"%c\",a[i]);}     getchar();     getchar();     return 0; } void set(char a[],int m1,int m2) {    int len;    char t;    len=strlen(a);    t=a[m1];    a[m1]=a[m2];    a[m2]=t;    while(m1>1 && (m2<(len-1)))    {      t=a[m1];      a[m1]=a[m1-1];      a[m1-1]=t;      t=a[m2];      a[m2]=a[m2+1];      a[m2+1]=t;      --m1;++m2; }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"input: \"0123456789\" output: \"0516273849\""},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void ArrangeIntegers(int[] numbers)         {             if (numbers != null && numbers.Length > 3)             {                 int n = numbers.Length;                 int ps = 1;                 int pe = (n / 2) - 1;                 int qs = (n / 2);                 int qe = n - 2;                 Queue numque = new Queue();                 numque.Enqueue(numbers[ps]);                 numque.Enqueue(numbers[qe]);                 bool fAlt = true;                  while (ps < qe)                 {                     if (fAlt == true)                     {                         int t1 = numbers[ps];                         numbers[ps] = numbers[qs];                         numbers[qe] = (ps == pe)? t1 : numbers[pe];                         fAlt = false;                         pe--;                         qs++;                     }                     else                     {                         numque.Enqueue(numbers[ps]);                         numque.Enqueue(numbers[qe]);                         numbers[ps] = numque.Dequeue();                         numbers[qe] = numque.Dequeue();                         fAlt = true;                     }                     ps++;                     qe--;                 }             }         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ArrangeIntegers function can also written as generic function to handle the different type of data types. This is function has O(log n) time complexity.  One additional check I missed was to check (numbers.Length % 2 == 0) just to make sure 2n condition holds."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have a O(n) method with O(1) space. Since every element is not in its final position except first and last element, we can randomly pick one element at first, for example the second one(a2), record its posision(currentIndex) and do the following loop until a2 in its final position(currentIndex==2): 1. calculate which element should be in this currentIndex position    if currentIndex is even number, the element should be in this position is a1...an. We use currentIndex/2 to calculate the current position of this element(index)    if currentIndex is odd numver, the element should be in this position is b1...bn. we use (currentIndex-1)/2+n  2. swap arr[currentIndex] and arr[index]. 3. record the current position of a2(currentIndex)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//arr = {a1,a2,a3,...,an,b1,b2,b3...,bn} //array index starts from 0 and goes to arr.length - 1   public static void main(String[] args) {   int i;   int [] arr = {11,12,13,14,15,16,17,1,2,3,4,5,6,7};   //int [] arr = {1,2,3,4,5,6,7,11,12,13,14,15,16,17};   boolean isOdd = (((arr.length /2) % 2) != 0)? true:false;      printArr(arr);   //First Loop   for (i = 1; i < (arr.length /2); i+=2) {    swap(arr,i,(arr.length /2) + i - 1);   }   printArr(arr);   //Second Loop   if(isOdd){    for (i = (arr.length/2)-1; i < arr.length-2; i++) {     swap(arr,i,i+1);    }   }   printArr(arr);   final int N = isOdd? (arr.length-2)/2:arr.length/2;   int itr = N;   int x=0;   for (i = 2; i <2*N && itr < 2*N; i+=2)   {    if(arr[i]> arr[itr])    {     if(i     swap(arr,i,itr);      swap(arr,i+1, itr+1);      x++;      if(x==2)      {       itr+=2;       x=0;      }     }    }    else{     if(i>itr) {      swap(arr,i,itr);      swap(arr,i+1, itr+1);     }    }   }   printArr(arr);  }   static void swap(int[] a, int i, int j) {   int t = a[i];   a[i] = a[j];   a[j] = t;  }  static void printArr(int []arr){   for(int i = 0; i < (arr.length);i++){    System.out.print(arr[i]);    if (i!=arr.length-1)     System.out.print(\",\");   }   System.out.println();  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//----------------REFORMATTED ABOVE----------------------- //arr = {a1,a2,a3,...,an,b1,b2,b3...,bn} //array index starts from 0 and goes to arr.length - 1    public static void main(String[] args) {         int i; //     int [] arr = {1,2,3,4,5,6,7,11,12,13,14,15,16,17};         int [] arr = {11,12,13,14,15,16,17,18,1,2,3,4,5,6,7,8};         boolean isOdd = (((arr.length /2) % 2) != 0)? true:false;            printArr(arr);         //First Loop         for (i = 1; i < (arr.length /2); i+=2) {                 swap(arr,i,(arr.length /2) + i - 1);         }         printArr(arr);         //Second Loop         if(isOdd){                 for (i = (arr.length/2)-1; i < arr.length-2; i++) {                         swap(arr,i,i+1);                 }         }         printArr(arr);         final int N = isOdd? (arr.length-2)/2:arr.length/2;         int itr = N;         int x=0;         for (i = 2; i <2*N && itr < 2*N; i+=2)         {                 if(arr[i]> arr[itr])                 {                         if(i                                swap(arr,i,itr);                                 swap(arr,i+1, itr+1);                                 x++;                                 if(x==2)                                 {                                         itr+=2;                                         x=0;                                 }                         }                 }                 else{                         if(i>itr) {                                 swap(arr,i,itr);                                 swap(arr,i+1, itr+1);                         }                 }         }         printArr(arr); }  static void swap(int[] a, int i, int j) {         int t = a[i];         a[i] = a[j];         a[j] = t; } static void printArr(int []arr){         for(int i = 0; i < (arr.length);i++){                 System.out.print(arr[i]);                 if (i!=arr.length-1)                         System.out.print(\",\");         }         System.out.println(); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ideone.com/P5aiI  Please comment on this"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int a[10]={0,1,2,3,4,5,6,7,8,9};  int i,j;  int temp;  for(i=1, j=5;i<10;i+=2,j++)  {    temp=a[j];    for(int k=j-1;k>=i;k--)     a[k+1]=a[k];    a[i]=temp;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int a[10]={0,1,2,3,4,5,6,7,8,9}; \n int i,j; \n int temp; \n for(i=1, j=5;i<10;i+=2,j++) \n { \n   temp=a[j]; \n   for(int k=j-1;k>=i;k--) \n    a[k+1]=a[k]; \n   a[i]=temp; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include   using namespace std;   void rearrange(int a[],int n,int pos) {      if(pos == n/2) { for (int i=0;i     int k=0;      for(int i=pos;i     {       swap(a[i],a[k++ +(n/2)]);                  }         rearrange(a,n,pos+1); } int main() {     int a[]={1,3,5,7,2,4,6,8};            rearrange(a,8,1);     cin.get();     cin.ignore();     return 1; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void Rearrange(int a[],int n) \n{ \n int i,j; \n for(i=0 ; i < (n/2)-1; i++) \n { \n   int k=0; \n   for(j=0; j<=i; j++) \n   { \n    //calculating postion of elements need to be swapped \n    int pos1 = (n/2)-(i+1)+k; \n    int pos2 = (n/2)-(i)+k; \n    //Swapping \n    int temp = a[pos1]; \n    a[pos1] = a[pos2]; \n    a[pos2] = temp; \n    k=k+2; \n   } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we will  use a function which will take three parameter : 1.[Array](char []a)  2.[index Which need to move in rite position] (int i) 3.[value to place at new position](char c)   we will initiate function as : a=arrangeArray(a,1,a[n]); This function is responsible for move index i value to the deserving place.It also copy the value of new place and call another function to place this value to its deserving place.when all places will be arrange i will become 'n' and the recursion will stop.  the function is:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi,  I got the O(n) solution of this problem:  #include int main() {   int n,t,i,j,t1;  int arr[100];   //n: number of elements in array.  //  scanf(\"%d\",&n);   for(i=0;i {   scanf(\"%d\",&arr[i]);  }  int p,distance,count;  int ni; //new index  count=0;   for (i=1,ni=1;i {   //First find the distance   //based on if number is in first half or second half   //based on distance find the new index of this number.   //   if(ni   distance=ni;    p=2*distance;   }   else{    distance=ni-n/2+1;    p=2*distance-1;   }    //swap arr[i] with arr[p].   //    t=arr[p]; arr[p]=arr[i]; arr[i]=t;      if (i==p){    i=i+2;    ni=i;   }   else    ni=p;  }     printf (\"The output array is:\\n\");  for (i=0;i {   printf (\"%d \", arr[i]);  }     return 0;  }   Logic is: Fix i on 1. Find the new index of this number. swap arr[1] with this new index. Record this new index in ni and this number is on 1. Now find the new index based on ni. and swap arr[1] with this new index. Keep doing this till you have swapped n-2 elements.  Just one trick, after some iterations correct element will come to a[1] then increment index by 2[I don't how did it work, it was just based on example of 10 element array and now I tested it works for any number of elements]."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this looks to me as a very simple question, why the solutions are so long??   bool reorder(int *array,int n) {     if(array && n)     {         for(int i=n;i<2*n;++i)         {             int temp=array[i];              for(int e=i;e>(i-n)*2+1;--e)             {                 array[e]=array[e-1];             }              array[(i-n)*2+1]=temp;         }          return true;     }      return false; }  int main(int argc, char *argv[]) {       int array[]={1,2,3,4,5,6,7,8,9,0};     int n=5;      for(int i=0;i<2*n;++i)         printf(\"%d,\",array[i]);     printf(\"\\n\");      reorder(array,5);      for(int i=0;i<2*n;++i)         printf(\"%d,\",array[i]);     printf(\"\\n\"); }  test input: 1,2,3,4,5,6,7,8,9,0, test output: 1,6,2,7,3,8,4,9,5,0,"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@above what is the run time of your code? it should be O(n). Your code is not O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.create two heaps a1----an,b1----bn by index of element 2.Now delete the root of each and insert it at starting  3.repeat the 1st step again till end"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"complexity will be (nlogn) i think"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Easy to understand code which runs in O(n^2) time"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is one recursive solution I propose : \n \nconsider example a1,a2,a3,a4,b1,b2,b3,b4 \n \n1. if n is even \n    swap second Half of first array with first half of second array \n    so it would be a1,a2,b1,b2,a3,a4,b3,b4 \n    and it  can be solved recursively     \n    so rearrange({a1,a2,a3,a4,b1,b2,b3,b4}) = rearrange({a1,a2,b1,b2}), rearrange({a3,a4,b3,b4}); \n2. if n is odd (a1,a2,a3,a4,a5,b1,b2,b3,b4,b5) \n    swap second Half+1 of first array with first half+1 of second array \n    so it would be a1,a2,b1,b2,b3,a3,a4,a5,b4,b5 \n    swap bolded elements( nth and n+1 th) a1,a2,b1,b2,a3,b3,a4,a5,b4,b5 \n    and it  can be solved recursively by dividing in two sub parts \n    rearrange({a1,a2,a3,a4,a5,b1,b2,b3,b4,b5}) = swap(b3,a3), rearrange({a1,a2,b1,b2}), rearrange({a4,a5,b4,b5}); \n \nlimiting case would be \nif n==2 //since the pair is in required order \nreturn; \n \nTime complexity analysis ( n is size of total array a+b): \n \nT(n) = 2*T(n/2) + n/4   ( n/4 is swapping time of second Half of first array with first half of second array) \n \nT(n) = 2^k T(1) + n/4( 1+1/2+1/4+.......+1/(2^k)) \n= 2^k+n/4( 1-1/(2^k))*2                k = log(n) \n=n+ (n-1)/2 \n=O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This will work if element are of int/char/float types  #define SWAP(X,Y) (X=X^Y;Y=X^Y;X=X^Y;)  arrayChange(int a[]){   int size = sizeof(a)/sizoof(a[0]);   int i = 0;    while(i < size/2){     SWAP(a[i++], a[size-- - 1]);   } }      size--; } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include using namespace std; int main(int argc, char*argv[]) {  int a[] = {1,2,3,4,5,6,11,22,33,44,55,66};  int n = 6;  int temp1 = 0;  int temp2 = 0;  int changed = 2;  for(int i =1;(i {   int start = i;   int oldIndex = i;   int newIndex = 0;   temp1 = a[oldIndex];   while(start!=newIndex)   {    if(oldIndex>=n)    {     newIndex = 2*(oldIndex-n)+1;    }    else    {     newIndex = 2*oldIndex;    }        temp2 = a[newIndex];    a[newIndex] = temp1;    changed++;    temp1 = temp2;    oldIndex = newIndex;   }   //a[start] = temp1;  }  for(int i=0;i<2*n;i++)  {   printf(\"%d \",a[i]);  }  printf(\"\\n\"); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package arrays; \n \npublic class Exchange { \n public static void exchange(int[] a){ \n  exchange(a, (a.length/2) - 1, a.length/2); \n } \n  \n private static void exchange(int[] a,int x,int y){ \n  if(x==0 || y==a.length-1){ \n   return; \n  } \n   \n  for(int i=x;i<=y;i=i+2){ \n   int temp = a[i]; \n   a[i] = a[i+1]; \n   a[i+1] = temp; \n  } \n  exchange(a, x-1, y+1); \n } \n  \n public static void main(String[] args){ \n  int[] a = {1,2,3,4,5,6,7,8,9,10}; \n  exchange(a); \n  for(int i : a){ \n   System.out.print(i + \" \"); \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package arrays; \n \npublic class Exchange { \n public static void exchange(int[] a){ \n  exchange(a, (a.length/2) - 1, a.length/2); \n } \n  \n private static void exchange(int[] a,int x,int y){ \n  if(x==0 || y==a.length-1){ \n   return; \n  } \n   \n  for(int i=x;i<=y;i=i+2){ \n   int temp = a[i]; \n   a[i] = a[i+1]; \n   a[i+1] = temp; \n  } \n  exchange(a, x-1, y+1); \n } \n  \n public static void main(String[] args){ \n  int[] a = {1,2,3,4,5,6,7,8,9,10}; \n  exchange(a); \n  for(int i : a){ \n   System.out.print(i + \" \"); \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//given an array [a1,a2,a3...,an,b1,b2...bn], change it to [a1,b1,a2,b2.....an,bn], solution should be in-place     public static void exchange(int[] array, int n) {         int y = array.length - 1;         for (int x = n - 1; x >= 0; x--, y -= 2) {             int temp = array[x];             int j;             for (j = x + 1; j < y; j++) {                 array[j - 1] = array[j];             }             array[j - 1] = temp;         }     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What do you think guys about this solutions.  Put all the a0 to an in two queues Now remove alternately from queue1 and queue1 and place it in the original array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \"stdafx.h\"  int func(int index,int len) {  if(index  return 2*index;  else   return (2*index-len+1); } int main() {  int a[]={1,2,3,4,5,6,7,8,9,10,11,12};  int count =0,hold=a[1],temp,index=1;  int length = 12;  while(count<(length-2))  {   temp = hold;   hold = a[func(index,length)];   a[func(index,length)] = temp;   index = func(index,length);   count++;   if(index == 1)   {    //temp = hold;    //hold = a[func(index,length)];    //a[func(index,length)] = temp;    index +=(length-count-2);    hold = a[index];    //count++;    }   }  for(index=0;index  printf(\"%d\\t\",a[index]);   return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class TestNumber {   public static void main(String[] args) {   String[] strAr = {\"a1\",\"a2\",\"a3\",\"a4\",\"a5\",\"b1\",\"b2\",\"b3\",\"b4\",\"b5\"};   String[] sortAr = new String[strAr.length];   int j =0;   int k=strAr.length/2;   int m=0;   for(int i=0;i   if(i%2 == 0){     sortAr[j++]=strAr[m++];    }else{     sortAr[j++]=strAr[k++];    }   }      for(String str: sortAr){    System.out.println(str);                 }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n#include \n#include \n \nusing namespace std; \n \nchar str[100] ; \nint l ; \nint global ;  \n \nvoid func(int idx , char ch1 ,char ch2) \n{ \n if(idx == l/2) \n  return ; \n ch1 = str[idx] ;  \n ch2 = str[idx + l/2] ;  \n func(idx + 1 , ch1 , ch2); \n str[global] = ch2 ;  \n str[global -1] = ch1 ;  \n global -= 2 ; \n return ; \n} \n \nint main() \n{ \n scanf(\"%s\",str); \n l = strlen(str); \n global = l - 1; \n \n func(0,'\\0','\\0'); \n \n printf(\"%s\\n\",str); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's my implementation with O(n) in time & space"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's my implementation with O(n) in time & space"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's my implementation with O(n) in time & space"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Meh, O(n^2)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package com.aa.array;  public class SortedOutPut {   /**   * @param args   */  public static void main(String[] args) {   String a [] = new String[] {\"a1\",\"a2\",\"a3\",\"a4\",\"a5\",\"a6\",\"b1\",\"b2\",\"b3\",\"b4\",\"b5\",\"b6\"};      int n= a.length;   int j =n/2;   for(int i=0 ; i < n ; i+=2){    String tmp= a[j];    shift(a,i+1,(j));    a[i+1]=tmp;    j++;   }   for(int i=0 ; i < n ; i++){    System.out.println(a[i]);   }  }   private static void shift(String[] a, int i, int j) {   for(int k = j ; k >=i ; k-- ){    a[k]=a[k-1];   }     }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a very simple method. o(n) time and o(1) space.  assume the array 1. scan through n,n+1,...,2*n to move each bi to the right position. 2. scan through 1,3,5,7,...,2*n-1 to move each ai to the right position. step 1 or 2 need swap n elements, total time o(n)  CODE: void cross_swap(vector &a){  if(a.size()<=0)   return;  assert(a.size()%2==0);  int n=a.size()/2;  int ind=-1;  for(int i=0;i  ind+=2;   swap(a[ind],a[i+n]);  }  int i=0;  char buf[10];  int count=1;  while(i!=a.size()-2){   string tmp=a[i];   tmp=tmp.substr(1);   int num=atoi(tmp.c_str());   if(num!=count)    swap(a[i],a[2*(num-1)]);   else    i+=2,count++;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void do_this(int a[], int n) if (n==0) return ;  for (int i=n; i >=2; i--)         swap(a[i], a[i-1]); do_this(a+2, n-1); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int* algo(int *a,int size) \n{ \n int n=size/2; \n int j=n+1; \n int i=2; \n int temp=0; \n int temp2=0; \n while(i<2*n) \n { \n  temp=j-i; \n  temp2=j; \n  while(temp !=0) \n  { \n   swap(a,temp2,temp2-1); \n   temp2--; \n   temp--; \n  } \n  j++; \n  i=i+2; \n } \n retur"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"s = array.length / 2; for( int i =1; i < s; i++)    swap( array[i], array[n+i-1] )"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; import java.util.Arrays;   public class FindSingleDuplicate {     public static void main(String[] args) {       int[] arr = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20};        System.out.println(\"Before shifting the elements::\" +Arrays.toString(arr));    arr = sort(arr);     System.out.println(\"After shifting the elements::\"+Arrays.toString(arr));  }   private static int[] sort(int[] arr) {       int mid = (arr.length-1)/2;   for(int i=1;i<=mid;i++)   {    int count = 1;        for(int j = -(i-1);count <= i; count++)    {     arr = swap(arr,(mid+j),(mid+j+1));    j+=2;    }       }   return arr;  }   private static int[] swap(int[] arr,int i, int j) {      int temp = arr[i];   arr[i] = arr[j];   arr[j] = temp;      return arr;  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Time complexity for the above is O(n*n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is this solution's time complexity O(n)?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The first technique works fine: Successively keep swapping pairs from the middle."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The first technique works fine: Successively keep swapping pairs from the middle."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The first technique works fine: Successively keep swapping pairs from the middle."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"But a better O(n) solution is that new idx = (old idx * 2)/(num_elements - 1)  //working C++ code"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=245679","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"143","title":"find the longest palindrome in a string?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"detalied explanation can be found at  www.math.tau.ac.il/~haimk/seminar02/suffixtrees.ppt"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"This can be solved using \"Suffix Tree\"."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Actually, the most efficient algorithm is O(n) and is based on dynamic programming.   Let str be the string of length n. Let us define: len[i] = length of the longest palindrome in substring having characters str[0],str[1],...,str[i]. beginIndex[i] = beginning index of the longest palindrome in substring having characters str[0],str[1],...,str[i].  len[0] = 1; beginIndex[0] = 0;   Now, try to find out len[i] in terms of len[i-1] and beginIndex[i] in terms of beginIndex[i-1] - during this we should leglect the special case when all characters in palindromes are same. We should find maximum length palindrome of this type.  We should deal with the special case where all characters in palindromes are same separately and find the maximum length palindrome of such type.   Out of above two, we should pick the longer palindrome. More than enough to solve it.   In any case, full code is below:   public static String longestPalindrome(String str)  {   String result = \"\";      int[] bIndex = new int[str.length()];   int[] len = new int[str.length()];      int i = 0, j = 0, index = 0;   bIndex[0] = 0;   len[0] = 1;   if(str.charAt(0) == str.charAt(1))   {    bIndex[1] = 0;    len[1] = 2;   }   else   {    bIndex[1] = 1;    len[1] = 1;   }      int maxLen = 0, bIndexMax = -1;   char c;      for(i = 0; i < str.length(); i = j)   {    c = str.charAt(i);    for(j = i+1; j < str.length() && str.charAt(j) == c; j++);    if(maxLen < j-i)    {     maxLen = j-i;     bIndexMax = i;    }   }      for(i = 2; i < bIndex.length; i++)   {    index = bIndex[i-1];    if( index == i-1)    {     if(str.charAt(i-2) == str.charAt(i))     { // check for odd length palindrome      bIndex[i] = i-2;      len[i] = 3;     }     else if(str.charAt(i-1) == str.charAt(i))     {      bIndex[i] = i-1;      len[i] = 2;     }     else     {      bIndex[i] = i;      len[i] = 1;     }    }    else    {     if(index-1 < 0)     {      bIndex[i] = i;      len[i] = 1;     }     else if(str.charAt(index-1) == str.charAt(i))     {      bIndex[i] = index-1;      len[i] = len[i-1] + 2;     }     else      bIndex[i] = i;    }   }      for(i = 0; i < len.length; i++)   {    if(maxLen < len[i])    {     maxLen = len[i];     bIndexMax = bIndex[i];    }   }         return str.substring(bIndexMax,bIndexMax + maxLen);     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"This self-contained C program will print out all of the palindrome lengths for all possible centers, and it will do it in O(n) time. It is a port of the algorithm in Haskell authored by Johan Jeuring here: johanjeuring.blogspot.com/2007/08/finding-palindromes.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Yes, LC String does not work. Ex: string:abcdecba    reverse:abcedcba        LCS:abc/cba"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"find palindrome in string A  reverse A as A', so it's equivallent to find longest common substring between A and A'?  if so, we can use prefix array method to do this as the \"pearls\" book suggested?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can use suffix tree or suffix array.  for(i=0;ic[i]=&A[i]; for(i=0;ic'[i]=&A'[i];  for(i=0;i{ get the longest common substring from the head of c[i],c'[n-i-1] c[i+1],c'[n-i-1] }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a problem of finding the LCS(longest common subsequence ) between the string and the its reverse."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is Longest Common Substring (Need to be contiguous)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"01234567890010987654321 will return 123456789"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Original string is A 2. Reverse string is B 3. Find common strings are C, D, E .... 4. Find palindromic strings in step 3, suppose C, D. 5. Find the max length of strings in step 4. Return."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's a solution in C++ (may not be the most effective, though). Basically it checks if the given string \"s\" is a palindrome. If it is, then that's the longest we can find.  If not a palindrome, look in s.substr(0, len - 1) and in s.substr(1, len - 1) and return the longest result."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"http://wiki.answers.com/Q/Is_there_any_way_to_find_the_largest_palindrome_in_a_string"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Naive algorithm finds he solution for the problem in O(n3) time. Select two ends to define a substring and check in linear time whether it is a palindrome.  2)Enhancement can be done to the naive algorithm to make it work in O(n2) time and O(n) space. Consider two strings  S and S(reverse).  for each character in first string: for each subpattern in first string match the pattern in second string by KMP algorithm to find longest common string in both in linear time O(n+n) and O(n) space(this will be the palindrome). overall runtime O(n2) and O(n) space.  3)The optimized version of the algorithm runs in O(n) time with suffix trees."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i think we can solve this using dynamic programing...  n is the length of str if(istr[i]==str[n] i++,n--;store i,n; else call func with i+1,n call func with i,n-1 }  i think u got my sol.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"DP solution:   int F(char* a, int n) {   if(n==1) return 1;      int k = F(a, n-1);   if(IsPalindrom(a, n-2k-2, n))     k++;    return k; }  thoughts?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just have an idea to reduce few calculations .. 1. Maintain a hash table..keep track of all characters which appear more den once .( store their indices ) 2.You can chek for all these indices ..this will possible reduce chekin for all the possibilities ..waitin for a better soln :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Agreed with sameerud, but essential addition: there are 2 types of palindromes: something like 'aba' and 'abba'.  So for every symbol we should test those two possibilities, not only the first one."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Agreed with sameerud, but essential addition: there are 2 types of palindromes: something like 'aba' and 'abba'.  So for every symbol we should test those two possibilities, not only the first one."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Input String is s1, Reverse the string to s2. Use Dynamic Programming to find the longest common substring. That gives u the result!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(size(s1)+size(s2)) it is!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I kind of disagree from sameerud, because take an example of a string abcaba,,, so as i understand his algo. won't be able to find the pallindrome aba,,  So, i there is one another algo  char *lar_pal = NULL;  char *str = /*some string*/ for(int i=0;i    for(int j=i+1;j        }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorry for previous reply,, pressed enter by mistake  I kind of disagree from sameerud, because take an example of a string abcaba,,, so as i understand his algo. won't be able to find the pallindrome aba,,  So, i there is one another algo. (I should write sudo code)  1) Start from the first element i in the string and compare it will all other element j in the     string //for(j=i+1;j   a) if string[i] == string[j]             if(pallindrome(somestr,i,j)){                  //the substring is from i - j index             }     pallindrome(char *someStr, int i, int j) 1) if someStr[i+1] == someStr[j-1]       if(i==j || i+1 == j)                    //aba,,,,abba              return true       aii) else                 i+=1;j-=1;                 pallindrome(someStr,i,j)    else        return false"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"reverse + LCSubstring"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a Longest Common Substring Problem,we basically construct the generalized suffix tree for the give string and its reverse.From the constructed tree it would be possible to find the longest Palindrome by traversing the tree.The construction of the tree would take O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My views:  1. Start with the middle element in the String (len/2).  2. Have two pointers (i and j): i goes back till 0, j goes forward till n. 3. whenever this fails : you have your longest palindrome.   This can be done other way too:  1. Have two pointers i and j at the beginning and at the end.   Like wise. Any takers?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I guess this is one of the best possible solution... But, usually this problem is coupled with another objective to find all the palindromes in a string and also to find the longest palindrome..in this case instead we can use a static variable and find the longest palindrome..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@particularraj: your algorithm works by the assumption that the palindrome starts in the middle of the string. It doesn't consider palindromes that at other places in the string. For example, consider the string ABMOCECXYYZ  Here according to your algorithm, you will start at 'E' moving i backward and j forward. When i reaches 'O' and j reaches 'X', the algorithm stops and concludes that 'CEC' is the longest palindrome. But 'XYYZ' is the longest palindrome in the above mentioned string."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The example string should be 'ABMOCECXYYX'."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Nice comment KB. Then I guess I have no choice but to iterate it 'N' times and update a static variable, so that we access and get the longest palindrome.   What do you think?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Create suffix trees of the original and reversed strings. Sort the suffixes separately. Find max length between suffix array from one string to that of the reversed."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is there any O(n) solution other than suffix tree. I dont think the interviewer would ask you to construct a suffix tree during the interview."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Suffix trees has O(n) time to look."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Suffix tree will give a very good solution, but it is difficult to come up in a interview. I would go with a dynamic programming approach,  Suppose we have the given string as,  InputString = \"abaccabadefg\"  Here there are 4 palindrome strings, aba - length 3 cc - length 2 aba - length 3 abaccaba - length 8  Now the output should be abaccaba  In order to find that, reverse the input string, ReverseString = \"gfedabaccaba\"  Now create a 2 dimensional matrix of NxN and follow a dynamic program approach to get the length on the longest palindrome and display it. Heart of the solution is,  A[i,j] = Max (a[i-1, j], a[i,j-1] if InputString[i] != ReverseString[j]        = a[i-1,j-1] + 1, if InputString[i] == ReverseString[j]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about having two pointers, one at the start and one at the end of the string.  For each character in the string, you will traverse backwards from the tail and try to find the largest possible palindrome matching with the start of the strong, if any.  You keep doing for every character, this until you find one, any palindrome.  Each time you do this loop for a character from the head, your largest palindrom will be s-n, where s is the original string length, and n is the number of iterations you've done this.  When you do find a palindrome, any palindrome, you will know that if the largest palindrome, it will be at between size (curr palindrom size) and (s-n).  Armed with this knowledge, you can then write a function that is optimized to only process the remainder of the array for strings that meet the stringlength described above.  And of course, this could be done elegantly using recursion, and fine tuning it with the logic similar to the above once you have confirmed at least one palindrome.  This of course is going to be a resource hog but the code will be easier to read and manage.    :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Find the reverse string 2. Find longest common substring  Will this work? I think dynamic programming approach that you mentioned is same as this."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My cents:  Building suffix trees is not a bad idea. We can get that in O(nlogn) time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Take a string  1. Reverse the string 2. XOR with the Original String 3. Find the longest sequence of 0s in the XORed result which will be the corresponding  answer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"start with the first character. try to lookup the same character from the bak. on finding the same character from the back check if the substring is palindrome or not. keep on finding the same character until u reach the index of the first character.  keep on doing the same for all the characters. ....O(n^2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just reverse the string and find the largest substring in both the strings. O(n^2)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"finding the longest substring of the string and it's reverse won't work.  Consider abcdefgHELLOWORLDgfedcba  The longest palindrome is actually LL, that method would return abcdefggfedcba"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Keep a current pointer on the second element a(1). place two other pointers at current-1 and current+1. check if curr-1 and curr+1 are equal. then move current pointer ahead. again set curr-1 and curr1 and check for: If curr is at ith position: while(i>0) { if (curr-1 == curr+1)  {    (curr+1)++;    (curr-1)--;     i--; } else break; }  keep tack of the largest one by storing the value of current for which the length of palindrome was max. also keep track of it's length for each i. Then u can print the longest palindrome."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@gagdeep what does the 'i' signify ??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can you show the working code by which you arrived O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think we cannot solve this question in less than O(n^3) complexity........as ideally there are n*n different string that can be created using a string of length n......For example there are 1 string of length n that can be formed from given string and there are 2 string of length n-1 that can be formed using a string of lenght n-1 and there are n string of length 1.  So if you sum it all, there are 1+2+ ........+ n-1 + n strings = O(n*n)........  We know how to check for one string in O(n) time, so I think we can just repeat the loop by checking string of length n to 1 and stop whenever we find any palindrome.....  Seriously, I don't think we can solve this question in less than this time, because we have to check for string of each length and in worst case there might not be any palindrome in string and so we might end up with generating palindrome on length 1 i.e . character itself, if you consider that to be a palindrome.....  Please share your thoughts, I would be happy to hear from anyone....who can help me in improve on this solution..........."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"maxindex = 1; \nmaxlen = 1; \nfor(index = 1 to str.length) { \n  for(cur = 1 to min(index, abs(str.length - index))) { \n    if(str[index + cur] == str[index - cur]) { \n      if(cur < maxlen) continue; \n      maxlen = cur; \n      maxindex = index; \n    } \n  } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am not sure about suffix tree, as I have not read those yet, but I don't think we can solve this question iteratively in less than O(n^3) and I don't think dynamic programming will work too as we cannot use the result that I got in previous iteration because if I have two strings that are palindrome then I cannot say that if I merge both string then those will be palindrome also...  Here is my solution using O(n^3) complexity.  There are n*n different string that can be created using a string of length n......For example there are 1 string of length n that can be formed from given string and there are 2 string of length n-1 that can be formed using a string of lenght n-1 and there are n string of length 1.  So if you sum it all, there are 1+2+ ........+ n-1 + n strings = O(n*n)........  We know how to check for one string in O(n) time, so I think we can just repeat the loop by checking string of length n to 1 and stop whenever we find any palindrome.....  Seriously, I don't think we can solve this question in less than this time, because we have to check for string of each length and in worst case there might not be any palindrome in string and so we might end up with generating palindrome on length 1 i.e . character itself, if you consider that to be a palindrome.....  Please share your thoughts, I would be happy to hear from anyone....who can help me in improve on this solution..........."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A working solution. O(n*n*n) complexity but good for an interview."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Not sure what happened to the white space.  Here is a quick test I used."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this way: 1. define stringbulder variable called sb and an int called numberOfChars and max 2. for each character in the string  3. add the character to sb, and set numberOfChars to 1.      4. for each remaining character in the string 5. append the character to sb and increment numberOfChars by 1.      6. if the character is the same as the character read in step 2, then what we have in sb is a potential palindrom so, call a helper funtion called IsPalindrome with the value in sb as an argument. 7. If step 6 returns true, then add the content of sb to a dictionary with sb as a key and numberOfChars as a value---you can have duplicate checks 8. inner loop ends here 9. if numberOfChars > max then reset max to numberOfChars and clear sb 9. loop to the first loop. 10. Now, all possible palindrome strings are in your dictionary. Return a key with value equal to max.  Note that: The algorithm generates all possible palindroms but, i think there might be a better way of doing it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Longest thread of answers to Longest palindrome finding :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"could not post the link. google for this. the first link has a good solution  finding-the-longest-palindromic-substring-in-linear-time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It's awesome to see people using suffix tree and O(nlogn) at the same time !!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My suggestion is that any approach of O(n^2) time and O(1) space that can be well explained and you can write working code during an interview would suffice!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Reverse the string and find biggest substring."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"No need for such complex algorithms !!!  I was asked this question, I proposed trying all combination (O(n^2) I think) he looked convinced with that approach."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Example: ================ Str1=abcbabcmoms  Str2=abcba   ALGO: ================ 1.a          take A[i]==A[j] , decrement J-- till i                  if A[i]==A[j]                 take paldromeindex=i                 and increment i and decrement j till i=j                 RANGE[k]=J-I                  1.b          sort range and return the longest one  CODE: ================  private string LongestPalindrom(Str S1,int size) { int maxrange =0;                  For(int i=0;i                {                 char ch1=s1[i];                                                                  FOR(INT J=SIZE; J>0;J--)                                                 {                                 char ch2=s1[j];                                                  IF(CH1==CH2 && i!=j)                                                 {                                                  int range= j-i;                                                  i++;                                                  ch1=s1[i];                                                 }                                 }                                  IF(MAXRANGE                                {                                 int maxrange =range;                         int maxindex=i                                 }                 }                  FOR(k=maxindex;k                                {                                  Console.writeline(Str[k]);                                            }  }    TEST HARNESS: ================ using system;  namespace problem {                 class Solution                 {                    static void Main(string[] args)                 {                                  String Pal1 =\"abcbabcmoms\"                                  String Result;                                  Result= Longestpalindrom(Pal1,11); }}}  ORDER: ================ O(N^2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Tarun, Nice try but you need more temp variables to save indexes and values. Try this string and you will find a bunch of bugs in ur code. \"BBABTENETTENEB\".  This is is the code i came up with, can you guys please review it:  void longestPalindrome(char* str, int size, int* begin, int* range){      *begin = 0;      *range = 0;      int i, j, pali, tempRange = 0;      for(i = 0; i < size; i++){            *begin = pali = i;            for(j = size - 1; j >= pali; j--){                  tempRange = j - *begin;                  if(str[pali] == str[j]){                       pali++;                  }else{                       tempRange = 0;                       if(pali != *begin){                           break;                           }                   }                  }            if(*range < tempRange){                *range = tempRange;                            }            } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int main() \n{ \nchar a[]=\"abcdaeeadabb\"; \nchar *p,*q,*r,*found; \nint i=0; \nint max=0; \nfor(p=a;*p!='\\0';p++) \n{ \nq=p; r=a+strlen(a); \n    while(qmax) {max=i; found=p;} \n} \nif(q==r) max=max+1; \nstd::cout<<<*found; \nreturn 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void longestPalindrome(char *str, int n) \n \n{ \n \n    int i=0, j=0, start = 0, end = 0, range = 0, maxstart = 0,maxend = 0; \n \n    while(i < n && j < n) \n \n    { \n \n        start = i; end = j; \n \n        while((str[start] == str[end]) && (start >=0) && (end <= n)) \n \n        { \n \n            if((maxEnd - maxStart) < (end-start)) \n \n            { \n \n                maxEnd = end; \n \n                maxStart = start; \n \n            } \n \n            end++; \n \n            start--; \n \n        } \n \n        start++; \n \n        end++; \n \n    } \n \n \n    for(int i = maxStart; i <= maxEnd; i++) \n \n        printf(\"%c\", str[i]); \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is indeed a Dynamic Programming problem as Gopal Krishna has indicated but I can't think of a a solution that can solve this in less than O(n2).  My O(n2) solution was to take the string and its reverse (i.e. output of strrev(string)) and do a longest sub-string match using dynamic programing. The largest sub-string match is the longest palindrome in the given string."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Collections;  class Program { static void Main(string[] args) { Program p = new Program(); Console.WriteLine(p.LargestPalindrome(\"abbac\"); }    public String LargestPalindrome(String str)         {             int[] ar = new int[str.Length];             for (int i = 0; i < str.Length; i++)             {                 int start = i;                 for (int j = str.Length - 1; j >= i; j--)                 {                     int end = j;                     int cnt = 0;                     while (start <= end)                     {                         if (str[start] == str[end])                         {                             if (start != end)                                 cnt += 2;                             else                                 cnt++;                             start++; end--;                         }                         else                         {                             cnt = 0;                             break;                         }                                             }                     if (ar[i] < cnt)                         ar[i] = cnt;                 }             }             int max = 0;             for (int i = 1; i < ar.Length; i++)             {                 if (ar[i] > ar[max])                     max = i;             }              return str.Substring(max, ar[max]);         } }1 2 10 42 11"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int _tmain(int argc, _TCHAR* argv[]) {  char p[500],*temp;  int i,j,str_len,k;  printf(\"\\n Enter the string \");  gets(p);  if (palendrome(p) == 0) {   printf(\"\\n String is a palendrome\");   return 1;  }  else   printf(\"\\n Not a palendrome\");    str_len = strlen(p);  int largest_palindrome = 0;  char q[100];  for(i=0;i {   temp = p+i;   for(j=2;j<=str_len-i;j++)   {    if(palendrome_substring(temp,j) == 0)    {     if (j > largest_palindrome){      largest_palindrome = j;      memcpy(q,temp,j);      q[j] = '\\0';     }    }   }  }  printf(\"\\n largest palendrome %s\",q);  return 0; } int palendrome(char *p) {  int str_len = 0,i;  if (!p ) return -1;  str_len = strlen(p);  if(str_len < 2)return 1;  for(i=0;i<(str_len/2);i++)  {   if (p[i] != p[str_len - i - 1])    return 1;  }  return 0; }  int palendrome_substring(char *p, int size) {  int str_len = 0,i;  if(!p || !size) return -1;   str_len = size;  for(i=0;i<(str_len/2);i++)  {   if (p[i] != p[str_len - i - 1])    return 1;  }  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"N^2 solution - Dynamic Programming. Should be good for interview. \nisPalindrome[i,j] = isPalindrome[i+1, j-1], if str[i] == str[j] \n                  = false, if str[i]!= str[j] \n                  = true,  if i == j //single character \n \nAfter the matrix is filled, traverse diagonally to find the longest palindrome"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"small change in previous program: \n \nchar * fndlong (char *str) \n{ \n char * pointpal, *longestpal; \n int length, longest=0; \n while(*str) \n {int i=1; \n \n  if(*str==*(str+i)||*(str-i)==*(str+i)) \n  { \n   if (*(str-i)==*(str+i)) \n    pointpal=str-i; \n   else \n    pointpal=str; \n   i++; \n   length=0; \n   while(*(str-(i-1))==*(str+i)||(*str-i)==*(str+i)) \n   { \n    pointpal--; \n    i++; \n    length=+ 2; \n   } \n  } \n  if(longest==0 || length>longest) \n  {  \n   longest=length; \n   longestpal=pointpal; \n  } \n  str++; \n } \n return longestpal; \n} \n \nint main() \n{ \n char * str1=\"ABMABCDDCBAOCECXYYXOPQR\"; \n char * longestpal= fndlong(str1); \n char * point=longestpal; \n int loop=1; \n \n while(loop) \n { \n  cout<<*longestpal; \n  longestpal++; \n  if (point==longestpal) \n  { \n   loop=0; \n  } \n  if(*point==*longestpal) \n   point=longestpal+1; \n } \n cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"program to find longest palindrome: int main() {  int i,j,count=0,check=0,loc=0,pos=0;  string str;  cout<<\"enter string\"< cin>>str;  for(i=1;i {   for(j=i;j  {    if(j-1<0 || j+1>=str.length())     break;    if(str[j-1]==str[j+1])    {     count++;     loc=j;    }    else     break;   }   if (count>check)   {    check=count;    pos=loc;   }  }  for(int k=(pos-check);k<=(pos+check);k++)   cout<}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A very good O(n2) easy to follow code is available in technicalypto.com/2010/02/find-all-possible-palindromes-in-string"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The idea is to go left and right from each element until left will be the beginning, or right will be the end. \nThe initial length of each possible palindrome is 1. \nWe need to distinguish 2 cases: \n \n1). \"Odd\" case, like \"abcdcba\" \n2). \"Even\" case, like \"dcbaabcd\" \n \nIn \"even\" case, we need to shift our \"right\" pointer to one position right and to increasr the current length. \n \nDuring each next move, we increase our current palindrome length on 2, if the left and the right characters are the same. \nWhen palindome stops (we reach the array borders, or our left and right characters are not the same any more), \nwe compare our current palindrome length with the previous maximal length. \n \nvoid FindLongestPalindrome(char Arr[]) \n{ \n char* pCurr; // moving through our string \n char* pBegin; // the beginning of the string \n char* pEnd; // the end of the string \n char* pLeft; // to go left from the current character \n char*pRight; // to go right from the current character \n \n int iMaxIndex=0; \n int iCurIndex=0;  \n int iMaxLength=1; \n int iLength; \n \n pCurr=pBegin=&Arr[0]; \n pEnd=pBegin; \n  \n while(1) \n { \n pEnd++; \n if(*pEnd=='\\0') break; \n } \n    // now pEnd points to the end of our array  \n \n while(1) // go through the array \n { \n  iLength=1; \n \n  //Odd case: \n  pLeft=pRight=pCurr; \n  //even case: \n  if((*pLeft)==(*pRight+1)) \n  { \n   pRight++; \n   iLength++; \n   if(pRight>pEnd) break; \n  } \n \n  while(1) \n  { \n           if((*pRight) != (*pLeft)) break; \n      \n     pLeft--; \n     pRight++; \n     if((pLeftpEnd)) break; \n \n     iLength = iLength+2; // because we add characters from the left and from the right \n  } \n \n  if(iLength > iMaxLength) \n  { \n           iMaxLength = iLength; \n     iMaxIndex = iCurIndex; \n  } \n   \n  pCurr++; \n  if(pCurr>pEnd) break; \n  iCurIndex++; \n } \n \n // Now we have iMaxIndex as the beginning of longest palindrome, and iMaxLength as it's length \n     \n for(int i=iMaxIndex; i<=iMaxIndex+iMaxLength; i++) \n printf(\"%c\", Arr[i]); \n printf(\"\\n\"); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Reverse the string and compare using a shifting window."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def updateMax(palinIndex, palinLen, maxPalinLen, maxPalinIndex, i): \n    if palinLen>maxPalinLen: \n        maxPalinLen=palinLen \n        maxPalinIndex=palinIndex \n    palinLen=0 \n    palinIndex=i \n    return palinIndex, palinLen, maxPalinLen, maxPalinIndex \n         \ndef longestPalindrome(s): \n    pi=0 #Palindrome Index \n    pl=0 #Palindrome Length \n    lpl = -1 #Longest Palindrome Index \n    lpi = -1 #Longest Palindrome Length \n     \n    for i, c in enumerate(s): \n        if i==0: \n            continue \n        if s[pi]==c: \n            if (pi>0): \n                pi-=1 \n                pl+=2 \n            else: \n                pi, pl, lpl, lpi=updateMax(pi, pl, lpl, lpi, i) \n        else: \n            pi, pl, lpl, lpi=updateMax(pi, pl, lpl, lpi, i) \n    pi, pl, lpl, lpi=updateMax(pi, pl, lpl, lpi, i) \n    return s[lpi+1:lpi+lpl+1] \n \ns=\"ldsfkjoeiwrjwelskzdjfsdaasdfgfdfghjkllkjhgfdlkfherqriuthekdfsnvgkjwnoirjsefdq\" \nprint longestPalindrome(s)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Read about Manacher's Algorithm"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Whaqt about below solution, let me know if any bug is there, inputs tested are  LongestPalindrome(\"aabcbcdab\");           LongestPalindrome(\"aaaaa\");            LongestPalindrome(\"abbba\");            LongestPalindrome(\"this is a a uyt this is a a si si\");            LongestPalindrome(\"abeeddddeabe\");    public static void LongestPalindrome(string a)         {              string isPalindrome = \"\";             string largestPalindrome = \"\";             int j, k;             for (int i = 0; i < a.Length - 1;i++)             {                 k = i + 1;                 j = i - 1;                       if (j >= 0 && k < a.Length)                 {                     if (a[i] == a[j] && a[i] == a[k])                     {                         j--; k++;                     }                 }                  if (j > 0 && k < a.Length)                 {                      if (a[i] == a[j])                         j--;                     else if (a[i] == a[j])                     {                         k++;                     }                 }                 while (j >= 0 && k < a.Length)                 {                     if (a[j] != a[k])                         break;                     else                     {                         j--;                         k++;                     }                     isPalindrome = a.Substring(j + 1, k - j - 1);                     if (isPalindrome.Length > largestPalindrome.Length)                     {                         largestPalindrome = isPalindrome;                     }                 }             }             Console.WriteLine(largestPalindrome);            }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int[] getLongest(String str){ \n  char[] data = str.toCharArray(); \n  int[] index = new int[data.length]; \n  int[] buffer = new int[256]; //store pre index \n  int max = 0; \n  int[] span = new int[2]; \n   \n  for(int i = data.length - 1; i >= 0; i--){ \n   index[i] = buffer[data[i]] == 0 ? -1 : buffer[data[i]]; \n   buffer[data[i]] = i; \n  } \n    \n  for(int i = 0; i < index.length && index[i] != -1 ; i++){ \n   int cur = i; \n   int j = index[i]; \n   while(j != -1){ \n    for(; j != -1; j = index[j]){ \n     if(isPaloindromes(data,cur,j) == true){ \n      if(max < j - cur + 1){ \n       max = j - cur + 1; \n       span[0] = cur; \n       span[1] = j; \n      } \n     } \n    } \n    int tmp = cur; \n    index[tmp] = -1; \n    cur = index[cur]; \n    j = cur == -1 ? -1 : index[cur]; \n   } \n  } \n  return span; \n } \n  \n public static boolean isPaloindromes(char[] data, int i, int j){ \n  int mid = (i + j) / 2; \n  for(int k = 0; k < mid; k++){ \n   if(data[i + k] != data[j - k]) \n    return false; \n  } \n  return true; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I choose maintainability over performance until performance testing shows the code to be a bottleneck."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"{{package mic01;  public class LongestPalindrome {   public static void main(String[] args) {      String dummy = \"AAABBGFF ili ollo benmio ooloo eo sadkjansd evbnbve eikdo ooooooooookoooooooooo\";      System.out.println(letsDoThis(dummy));      }   private static String letsDoThis(String dummy) {   String result = null;   int max = 0;   String[] a = dummy.split(\" \");   for(int i=0; i   if(isPalindrome(a[i])){     if(a[i].length() > max)      result = a[i];    }   }   return result;  }   private static boolean isPalindrome(String string) {    int length = string.length();   if(length % 2 == 0)    return false;   else{    for(int i=0; i    if(string.charAt(i) != string.charAt(length-i-1)){      return false;     }    }   }    return true;  }  }  }}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=3043","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"101","title":"Simulate a seven-sided die using only five-sided","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"This is a trick question and there is no correct solution. There are only solutions which are close to correct. The reason for this is that 5 and 7 are relatively prime (also called coprime), so no mapping between them is possible. This means that any solution either (a) does not have the correct probability, or (b) has the possibility of never terminating. All of the solutions given above are therefore incorrect. Lest you think that you can simply convert to binary and back, note that 2 is also relatively prime to both 5 and 7.  I was once asked this question in a phone interview and I tried to explain to the questioner why it was an invalid question, but he didn't understand what \"relatively prime\" meant.  http://mathworld.wolfram.com/RelativelyPrime.html http://en.wikipedia.org/wiki/Coprime"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"This solution is inspired from Nanmaga... Throw the dice twice and do the following:  function rand7() { throw the dice twice and perform the following checks  1,1 return 1 1,2 return 2 1,3 return 3 1,4 return 4 1,5 return 5 2,1 return 6 2,2 return 7 2,3 return 1 2,4 return 2 2,5 return 3 3,1 return 4 ... ... ... 5,1 return 7  [at this point we have returned numbers from 1 to 7, 3 times each] 5,2 rand7() 5,3 rand7() 5,4 rand7() 5,5 rand7() }  In short, in the last 4 cases, we are subdividing the remaining probability into equal proportions by calling rand7() again.  Any idea if this solution sounds okay?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"common solution I saw in some other post:  look at the end bits of the numbers generated by 5: 000 001 010 011 100 101  the lsb is generated wth equal probablity ... hence .. all we need to do is call rand5() 3 times and keep on appending the results to a variable num .. to get our value between 0 and 7"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Throw the dice 5 times. Calculated the sum of all the throws. The sum will be in the range [5, 25], i.e. 21 different results. For the different results do the following  Result    7-side simulation result ------    ------------------------ 5,6,7         1 8,9,10        2 11,12,13      3 14,15,16      4 17,18,19      5 20,21,22      6 23,24,25      7"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"int dice7() { while (true) { int num = 5 * (dice5() - 1) + (dice5() - 1); if (num < 21) return (num % 7 + 1); } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Could you please explain this a bit?..I mean i can throw the die only once per turn?I mean what is the expected behavior?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the idea here: all sides of the die just should have similar probability to appear:we throwing 7 times (for each side of 7-sided die) five-sided die and remember sides which got 5, i.e. \"qualified\" to next round. Then continue until single side left, i.e. got number from 7-side die. (If none got \"5\" we can either repeat or \"qualify\" those with \"4\" and so on)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"guys its simple... let me reframe the question in a different way-write the code for rand7() (that will generate random nos from 0 to 6 each with equal probability) given a function for rand5().Ans:rand7() { return (rand5() + (rand5()%3));}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"is it that simple?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Generate random bits, by calling rand5 until we get something other than 52. Output the value mod 2.3. For generating rand7, call steps 1 and 2 three times, so that you get three random bits and treat them as three-bit binary numbers(range 0..7).4. Do step 3 until you dont get a 0, then output the value."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Let's say that 5 sided die generates numbers from 0 to 4.Then throw the die for 7 times and get the total value of each die.We will get one of 0, 1, 2, 3, ..., 28.The permutation of 0 happen is 1.The permutation of 1 happen is 7.....The permutation of 27 happen is 7.The permutation of 28 happen is 1.(Symmetric)Get to total value of all the permutations and devide by 7.Let's say the value from above is V.Get 7 combination to get V.Each of 0 to 28 must be used, no duplicat but number of numbers does not matter.We get unviased 7-sided die."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It can be done in two throws:Roll the die twice: and simply take XOR of result1 and ~result2.Explanation:from 1-5 the three bits have certain probability for 1 on them. By taking 1's complement of the second throw, u find make the probability same for 1 and 0 on each bit. So, 1-7 has same probability."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Throw the dice seven times, number each trial from one to seven, and pick the one with maximum number face-up. If there is a tie, throw tied ones again to break the tie. Since all dice are identical, the outputs are distributed uniformly from 1 to 7.  I think andy78 means the same thing bus hasn't explained well. Even algooz's answer looks good."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hi,guys,the followings are the correct solutions. Throw the dice5 for 7 times, and sum the number we get. The sum will be a number between 7 and 35, with the same probility. Then, get the modul of the sum devided by 7, which is a number from 0 to 6. Just plus 1, we can get a dice7."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Call the function that generates the random numbers between 1 to 5 twice and add these two results and return modulo 7 of the sum."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int rand7() { int i, sum;  for(i = 0, sum = 0; i < 5; ++i) sum += rand5();  /* sum is in [5, 25] now, but that is not * a uniform distribution, so subtract 2 * to put it in [3, 23] so that division by * 3 gives us a nice even [1, 7]. */  return (sum - 2) / 3; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what if I take modulus of rand5() function? -mod[rand5()*7]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"r1=ran15 r2=ran15 r3=ran15 r4=ran15  ranum=(r1+10*r2+100*r3+1000*r4) - 1111  return(Floor(ranum/635)+1)  Explanation: number of possible values is 4444-0+1=4445. 4445/635 =7 we'll have a range of [0,4444] min is 0+1=1 max is 4444/635=6.999=6+1=7"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I gave same answer as uday (after a lot f confusion) not as easy as it seem but i think: return (rand5()+ rand5()+...7 times) % 7   is OK (truely random)  as far as Tuatha's explanation .. hopefully it's doesn't need to be that complex, i can't imaging coming up with that stuff while on a phone interview."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Heres another scheme - (rand5-1)*6/4 + 1  explanation: subtracting by 1 gives a random# between 0 & 4. Dividing by 4 gives a random# between 0 & 1. Multiplying by 6 gives a random number between 0 & 6. Adding 1 to this gives a random number between 1 & 7."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How come summation become uniform distribution? It is becoming Welghted.. I think we can improve the range with complete uniform solution... But we can use rejection... for example:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How come summation become uniform distribution? It is becoming Welghted.. I think we can improve the range with complete uniform solution... But we can use rejection... for example: --------- int rand7(){  int x = 21;  while( x > 20){   x = 5*(rand5()-1) + (rand5()-1);  }  int r = 1 + (x % 7);  return r; } --------- we can improve it if we take to 1-125 range..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hey, what about using shifting ? function rndBit() { // equal prob. of 0 or 1  return rand5() & 1; }  rand7= 1+ (rndBit()<<3 | rndBit()<<2 | rndBit()<<1 | rndBit()) & 6;  would not this give us random bits (not weighted) and work ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I couldn't find an answer myself. :("},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int evenrand() { return (rand()%4)*2; } rand() { //returns no between 1 to 5 }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The point of the question is equal distribution. Think about two dimension array (rand(), rand()). This will generate total 25 cases: (1,1), (1,2), ..., (5,5).  In case of (1,1) return 1. In case of (1,2) return 2. In case of (1,3) return 3. In case of (1,4) return 4. In case of (1,5) return 5. In case of (2,1) return 6. In case of (2,2) return 7. In case of (2,3), in this case, return 1.  Then (2,4) returns 2. And make it recursively until you hit the (5,1). In case of (5,2), (5,3), (5,4) and (5,5) run this logic again. In this way, we can obtain equal distribution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the uniformity of numbers among random numbers from 1 to 7 is the most important.  Clacualte:             factor = GCD( <1st_Number>, <2nd_Number> )            iff ( GCD is same as { <1st_Number> or <2nd_Number>  )               lcmNo  = LCM( <1st_Number>, <2nd_Number> )               factor = lcmNo       Generate 1....factor random numbers of range <1...1stnumber>       Sum them and take modulo of <2nd_Number>"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int rand7(){ int random7= 0; for(int i =0;i<7;i++){ random7 += rand5(); } return (random7%7); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"algooz is absolutely correct... his solution is perfect...!!!!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I believe acoder's solution is correct. It will help if someone can argue against it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why not something like this:  1) From R5(), we can generate R2() with uniform distribution. How?... 1-ret 1 2-ret 1 3 ret 2 4 ret 2 5 repeat R2()  Modification of this would be  R34() 1-ret 3 2-ret 3 3-ret 4 4-ret 4 5-repeat R34()  Similarly for 5,6 with R56()  Now, to simulate R7(),  1-ret R12() 2-ret R34() 3-ret R56() 4-ret 7 5-repeat R7()  This should be uniformly distributed....anybody thinks otherwise?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"do rand5()+rand5() 2(1,1) 3(1,2) 3(2,1) 4(1,3) 4(2,2) 4(3,1) 5 5 5 5 6 6 6 6 6 7 7 7 7 8 8 8 9 9 10(5,5)  if 1,1 = return 1 1,2 = return 2 2,1 = return 3 1,3 = return 4 2,2 = return 5 3,1 = return 6 5,5 = return 7  For all other combinations repeat rolling the dies till one of the above combinations come.  Probability calculation:- Selection probability for the above case = 1/25. Rejection probability = 18/25  1/25 + (18/25)*1/25 + (18/25)^2*1/25 + ....  1/25*(18/25 + (18/25)^2 + (18/25)^3 +....)  1/25*(25/7)  = 1/7  Comments/criticisms welcome.  Since this thread is very long, i apologize if some1 has already posted this solution.  Thanks, Rohith Menon."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Easy: rand7 = ((ran5 + rand5 + rand5 + rand5 + rand5 - 5) % 7) + 1  The 5 rand will give range 5-25 : 21 numbers.  Equal probability for all."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The solution from lensbo would seem to work if you throw the 5-sided die 14 times. The sum of the die throws will get you a number from 14 to 70 where the range is 56 (a multiple of 7). Take the sum modulo 7, and you get a number from 0 to 6 evenly distributed. Add 1, and you have a 7-sided die."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"function rand7() {  v3 = 7;  while (v3 > 6) {   v1 = 4;   while (v1 > 3) {    v1 = rand5();   }   v2 = 4;   while (v2 > 3) {    v2 = rand5();   }   v3 = (v2 << 2) | v1;  }  return v3; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why not just sum the result of two rolls, and if it is bigger then 6 try again?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why not just sum the result of two rolls, and if it is bigger then 6 try again?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"suppose rand5() returns any number in {1, 2, 3, 4, 5}.   int rand7(){ int X1=rand5(); int X2=rand5(); int result = X1 + X2; //If rand5() returns {0, 1, 2, 3, 4} then {0, 3, 4} must be excluded. If result >= 8 return rand7(); // try again return result; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i think we can follow this approach:  basically we need three diff bits to mkae those (8) numbers then we could discard 000 from there. so what we need is a routine whcih generates 0 and 1 with equal probability int rand2() { while(1)    {   int randomNum =  rand5();   return randomNum%2;  // (equal numer of cases of 1 and 0)     } }  Main routine to generate 8 randomnumbers btwn (0to 7)  int rand7(     int bit1 = rand2();    int bit2  = rand2();    int bit3  =rand2();    int finalNum = bit1<<2 | bit2<<1 | bit3    if(finalNum! =8)     return finalNum; }  This will guarantee equal probabilitu for all (0 to 7)  your views?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"surprised no one has found the \"correct\"/optimal answer.  Took me 3 days to solve it and its an elegant solution.  One guy I saw was close.  here's some hints, how do you turn a 10 sided die to a 7 sided die? And then how do you turn a 2 sided die (a coin) into a 4 sided die?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"rand5()+randr()+.....12times.. This gives numbers between 12 to 60 uniformly.... so there are 60-12+1 = 49 numbers in total..... do mod 7 with result and add 1... this gives 1-7 with equal prob! same with dice...can be thrown 12 times..n add the results % 7.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Change each five-sided die into a binary digit (1-2 are zero, 3-4 are 1, five is a re-roll) and then roll three of them. Interpret the number as binary, with zero being a re-roll PS: Found this on someone s blog about their google interview experience"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think there is no possible solution; as there are no common powers of 5 and 7. (Note: rolling a die of 6 sides twice, gives 6^2 = 36 possibilities such that (6^2)%6=0 and a number occuring has equal probabilities from 1 through 6. Thus for this to work with 5 and 7 we need a number x such that (5^x)%7=0. Such a number does not exist. Refer to post by anonymous on relative prime."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can't we simply do it like this:  floor(rand5() * 7 / 5)?  If you think a little how rand() works, it just gives you a float between 0 and 1, and we just multiply it to get a number within our range."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int dice7() { while (true) { int num = 5 * (dice5() - 1) + (dice5() - 1); if (num < 21) return (num % 7 + 1); } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The idea behind this solution is to use the previously generated random as seed to generate the next random number.  int Random7() { static int random7 = 0; random7 = (Random5() + random7)%7; return (random7+1); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"my thought is: Nos from 1 to 7 can be written in binary form as 000 to 111 Now, throw dice for getting all the binary digits. if Dice Number != 5, digit = (Dice number) % 2 else throw again. this way we can find all 3 digits with equal probability and hence the number.  Thoughts invited."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//assuming rand5() returns a number in range 0 to 4 \nint rand7(){//returns a number in range 0 to 6 \n    sum = (rand5()+rand5()+rand5()+rand5()+rand5());//0 to 20 \n    return sum/3;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There are some other answers here: rosettacode.org/wiki/Seven-sided_dice_from_five-sided_dice"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorry I'm a noob here, but why can we simply:  roll the 5-sided dice 7 times, and then divide by 5  I realise we won't get whole numbers.  But if we are allowed to get non-whole numbers, then would this solution be OK?   I notice people are saying something about \"uniform distribution\" - and that this is part of the answer as to why the above solution is wrong.   Can someone please explain how this works here ... sorry  and  thanks"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Throw the 5 sided die repeatedly until it shows either a 1 or 2. If it is 1 write down 0.  If it is 2 write down 1.  Repeat the above until you have written down 3 digits.  If you have 3 zeros start again from the beginning.  You end up with a non zero 3 bit binary number. i.e. a number between 1 and 7."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"int rand7(){ return (rand5()+ rand5()+...7 times) % 7 }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14467673","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"90","title":"Given a circular single linked list.Write a program that deletes every kth node until only one node is left. After kth node is deleted, start the procedure from (k+1)th node. e.g.list is 1->2->3->4->5->1 k=3 1. You are at 1, delete 3. List is: 1->2->4->5->1 2. You are at 4, delete 1 List is: 2->4->5->2 3. You are at 2,delete 5 List is: 2->4->2 4. You are at 2, delete 2 List is: 4 Return 4.  How efficient you can do it?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"this question is known as the \"Josephus problem\" ... search on wikipedia"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"As per given direction : I think it is the best one! \"There is an O(n) solution based on mathematics, the iterative equation is the following:  f[1]=0;  f[i]=(f[i-1]+k)%i; (i>1)  and f[n]+1 is the your final answer.\""},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"int josephus(int n, int k) \n{ \n    printf(\"LL Size: %d, OffSet: %d\\n\", n, k); \n    if (n == 1) \n        return 1; \n    else /* The position returned by josephus(n - 1, k) is adjusted because the \n            recursive call josephus(n - 1, k) considers the original position k%n + 1 as position 1 */ \n        return (josephus(n - 1, k) + k-1) % n + 1; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This is a tricky problem, i'm trying to figure out how to make it O(n). For instance, say we have n = 10 nodes and k = 100,000. Before we delete our first element, we would have traveled 100,000 times in a linked list. We would do this n-1 times = (n-1)*k = O(n*k). Assuming k is big, and not a \"constant\", this is not O(n).   Another solution is finding the index of the node to destroy via modular arithmetic and then go to that node to destroy it. Let n = 10 and k = 14. Assuming nodes numbered 0 to 9, and we start at 0, we have 10 % 14 = 4. So 0 + 4 = 4. Go to node 4 and delete it. We're not \"starting\" where node 4 was. Next, we now have n = 9 nodes, 9 % 14 = 5. 4 + 5 = node 9. Repeat this n-1 times until we have n nodes left. You can test this on paper with 10 labeled nodes from 0 to 9. We first delete node 4 then if we go around 14 more times we'll arive at node 9, which was 4 + 5. Unfortunately, this is (n-1)*n = O(n^2). This is better than O(n*k) if k is > n, but still not O(n).   Should I be assuming k is a constant and not another variable to the function? I mean, if the function is getLastNode(Nodes n, int k) then the input is not just n, k may change as well. If k was always 5 for example, then we could say O(n*5) = O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi,  There is an O(n) solution based on mathematics, the iterative equation is the following:  f[1]=0;  f[i]=(f[i-1]+k)%i;  (i>1)  and f[n]+1 is the your final answer.  Then you just need to follow the linked list from the head till you reach the f[n]+1 (starting from 1, not 0) element.  For the above example: f[1]  = 0 f[2] = (0+3)%2 = 1 f[3] = (1+3)%3 = 1 f[4] = (1+3)%4 = 0 f[5] = (0+3)%5 = 3.  So the final answer is the 4th element in the list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Code :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int delet_kh_node( node*& head, int k) {     if( head )     {         if(head->next)         {              while(head->next!=head)              {                    for(int i=1; i                                                       head=head->next;                                        node *t=head->next;                                        head->next=t->next;                                        head=head->next;                                        delete t;                    }                    }                    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; \nimport java.util.Arrays; \nimport java.util.List; \n \npublic class QCircularList { \n    private static final int K_ELEMENT = 3 - 1; \n \n    public static void main(String[] args) { \n        ArrayList list = new ArrayList(Arrays.asList(1, 2, 3, 4, 5)); \n        int idx = K_ELEMENT; \n        while (list.size() != 1) { \n            System.out.println(\"removed element at index: \" + idx); \n            list.remove(idx); \n            printList(list); \n            idx = nextRemovalIndex(idx, list); \n        } \n \n    } \n \n    private static int nextRemovalIndex(int idx, ArrayList list) { \n        int loop = 0; \n        do { \n            idx++; \n            idx = idx % list.size(); \n            loop++; \n        } while (loop < K_ELEMENT); \n        return idx; \n    } \n \n    private static void printList(List asList) { \n        int i = 0; \n        for (int a : asList) { \n            System.out.println(\"a[\" + i + \"]: \" + a); \n            i++; \n        } \n        System.out.println(\"---------------------------\"); \n    } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sorry I rush the answer, no need the method that loops to calculate the next index"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void delete_node(struct circular **node, int pos) {   struct circular *q, *p, *temp;  int i=0,j;  q = *node;  if((*node) == NULL)  printf(\"Link List is empty\\n\");   else if((*node)->next == NULL)  printf(\"final node is %d\\n\",(*node)->data);  else  {   q=(*node);   while(q->next != q)   {    for(i=1;i   {     q = q->next;    }     if(q && q->next && (q->next != q))    {     temp = q->next;     q->next = q->next->next;     if(temp)     delete temp;    }    p = q;    while(p->next != q)    {      p = p->next ;     printf(\"%d-->\",p->data);    }    p=p->next;    printf(\"%d\\n\\n\",p->data);   }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include   struct node{ int info; struct node * next; };  struct node * head;  void addBeg(int x){     struct node * temp = (struct node *)malloc(sizeof(struct node));     temp->info = x;     temp->next = head;     head=temp; }  void display(){     struct node * temp = head;     while(temp!=NULL){         printf(\"%d\\n\",temp->info);         temp = temp->next;     } }  void makeCircular(){     struct node * temp = head;     while(temp!=NULL && temp->next!=NULL){         temp=temp->next;     }     temp->next = head; }  void deleteK(int pos){     struct node * temp1;     int i;     for(i=1;i        head = head->next;     }     temp1= head->next;     head->next = temp1->next;     free(temp1);     head = head->next;     if(head->next!=head)         deleteK(pos);     else          printf(\"Last Element %d\",head->info); }  int main(){     addBeg(5);     addBeg(4);     addBeg(3);     addBeg(2);     addBeg(1);     makeCircular();     deleteK(5);     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static void delete(node first, int i) { \n  // TODO Auto-generated method stub \n  node save = first; \n  node startfrom = first; \n  node prev = null; \n  int count =1; \n  while(count"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \ntypedef struct node \n{ \n  int value; \n  struct node* next; \n}Node; \ntypedef Node* NodePtr; \nNodePtr AddToList(NodePtr list,int data); \nvoid PrintList(NodePtr list); \nint Length(NodePtr list); \nint ValueAt(NodePtr list,int pos); \nint main() \n{ \n   NodePtr List=NULL; \n   //int a[]={1,2,3,4,5,6}; \n   int i=0,count,data,k; \n   scanf(\"%d\",&k); \n   scanf(\"%d\",&count); \n   for(i=0;ivalue=data; \n   newNode->next=list; \n   if(list==NULL) \n   { \n      newNode->next=newNode; \n      list=newNode; \n   return list; \n   } \n   travel=list; \n   while(travel->next!=list) \n   { \n      travel=travel->next; \n   } \n   travel->next=newNode; \n   return list; \n} \n \nvoid PrintList(NodePtr list) \n{ \n   NodePtr travel=list; \n   printf(\"\\n\"); \n   while(travel->next!=list) \n   { \n     printf(\"%d ->\",travel->value); \n  travel=travel->next; \n   } \n   printf(\"%d -->\",travel->value); \n   printf(\"%d\",travel->next->value); \n} \n \nint Length(NodePtr list) \n{ \n  int count=0; \n  NodePtr travel=list; \n   while(travel->next!=list) \n   { \n     count++; \n  travel=travel->next; \n   } \n   count++; \n   return count; \n} \n \nint ValueAt(NodePtr list,int pos) \n{ \n   int i=1; \n   NodePtr travel=list; \n   while(travel->next!=list) \n   { \n      if(i==pos) \n    return travel->value; \n   i++; \n   travel=travel->next; \n   }    \n   if(i==pos) \n    return travel->value; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.LinkedList; \n \npublic class KRemoveFromCircularLinkedList { \n \n    public static  E kRemove(LinkedList list, int k) { \n        /* \n            size    k-condition         result \n            0                           IllegalArgumentException \n            1                           return list[1] \n            n       k in [0..n-1]       return list[1] \n         */ \n \n        if (list.size() == 0) \n            throw new IllegalArgumentException(); \n \n        if (list.size() == 1) \n            return list.element(); \n \n        if (k < 0 || k >= list.size()) \n            throw new IndexOutOfBoundsException(); \n \n        int start = 0; \n        while (list.size() > 1) { \n            int elToDelete = (start + k - 1) % list.size(); \n            list.remove(elToDelete); \n            start = elToDelete % list.size(); \n        } \n        return list.element(); \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"link(node *head,int n) start from the head while(node->next!=head&&count{*p=node; node=node->next;count++;} if(count==k&&node->next!=head) {t=node->next; node->next=t->next; t->next=NULL; link(node *head,int n);} else if(count==k) { node->next=head; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int getSurviveNode(LinkedListNode head,int times){   if(head.next==head){    return head.data;   }   LinkedListNode current=head.next;   while(current.next!=head){    current=current.next;   }   LinkedListNode pervious=current;   current=head;   int killtimes=1;   while(current.next!=current){    if(killtimes==times){     pervious.next=current.next;     current.next=null;     current=pervious.next;     killtimes=1;     continue;    }    else{     pervious=current;     current=current.next;     killtimes++;    }    }   return current.data;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"all codes looks very clustered. i have simple solution. node *cur=start; while(cur->next!=cur) { node *temp=cur->next->next; cur->next->next=temp->next; // deleting the link cur=temp->next // for next deltion; delete(temp);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"namespace \n{ \n    template  \n    struct Node \n    { \n        T value; \n        int next; \n        Node() : next(-1) {} \n    }; \n \n    template  \n    class Ring \n    { \n        int _capacity; // Capacity of Ring (initially) \n        int _size; // Valid Node Count \n        int _current; // Current node \n        Node* _nodes; // Collection of Nodes \n \n    public: \n        Ring(int cap) : _capacity(cap), _size(0), _nodes(NULL), _current(-1) \n        { \n            _nodes = new Node[cap]; \n             \n            for(int aa = 0; aa < cap; ++aa) \n                _nodes[aa].next = (aa+1)%cap; \n \n            _size = cap; \n            _current = 0; \n        } \n \n        ~Ring() \n        { \n            if(_nodes) { delete [] _nodes; _nodes = NULL; } \n        } \n \n        int Size() const { return _size; } \n \n        int DeleteAndMove(int step) \n        { \n            if(_size < 1) throw \"The ring is empty\"; \n \n            // \n            // Move prior to deleting node \n            // \n            for(int aa = 0; aa < step - 1; ++aa) \n                _current = _nodes[_current].next; \n \n            int toDelete = _nodes[_current].next; \n            printf(\"deleting %d ..\\n\", toDelete); \n            _nodes[_current].next = _nodes[toDelete].next; \n            _nodes[toDelete].next = -1; \n            _current = _nodes[_current].next; \n            --_size; \n \n            return _size; \n        } \n    }; \n \n    void DeleteTest(int size, int space) \n    { \n        Ring* ring = new Ring(size); \n \n        try \n        { \n            while(ring->Size() != 1) \n            { \n                ring->DeleteAndMove(space); \n            } \n        } \n        catch(const char* msg) \n        { \n            fprintf(stderr, \"%s\\n\", msg); \n        } \n    } \n} \n \nvoid SK::SampleQuestions::KthNodeRemoval() \n{ \n    DeleteTest(101, 7); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Above will leak memory (forgot to delete 'ring'). Spoiled from smart-pointers..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I guess double link list will work. The total traversal will be O(N). We'll start following the next pointer with count, once find 'k' delete the node. In case nxt is null we'll follow previous to get (k-count) and keep on doing unless get prev==NULL and ther revert to next and so on."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A nxn array of pointers to the given   circular linked list.  If I understand the question correctly, the problem is to design a data structure that is efficient enough to delete all elements in linked list for any given value of k in O(n) time. In other words for any value of K, this data structure that you design should take O(n) time to delete all the elements.  Note: The deletion should follow the pattern specified in the question.   In order to achieve this, we have to cache the deletion sequence for each value of K. A simple nxn dimension array would suffice. Each row would contain the deletion sequence for a given value of K. Example:  a[n][n] The deletion sequence for K=1 could be cached in the 0th row of the array, a[0][0] to a[0][n] -  n pointers the the 1st successor of every element starting from the head. For k=2 the sequence would be stored in the 1st row of the array, a[1][0] to a[1][n].  In general, for any value of K, we just need to delete the all nodes in the row k-1 sequentially,  a[k-1][0] to a[k-1][n]. - this will achieve O(n) time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about a circular array? Array where after array.length -1 position we come back to position 0. Basically using modulo operation. For elements which are removed in those cells in the array we can have some pre-defined indentifier number to indicate empty cell. Removal for single element will be O(1) since we can find the exact index which has to be free. So for n elements the removal will be O(n). Please provide suggestions on this solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I also don't see any way to do the whole thing in O(n). I hope the person who posted this question didn't mean O(n) for each iteration, hence O(n^2) total..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I may be missing something here but couldn't you use an array?  To remove every kth item we increment by the index by k and remove that item. We just need to check to see if our index is greater than array.length() -1, and if it is simply take that away from the index to maintain a circular structure.  Then if we encounter an item that has been removed (either by noticing it is null, or by having a special static 'removed' item to swap with if the array items may be null) we simply increment the index by 1. (Because the next item should be in this index, it's just that rebuilding an array is expensive). That should only happen if the array length is evenly divided by k."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Correct."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is josephus problem..  This can be done either using recursion"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"C Code:  First the header file to create double circular linked list:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"General approach for this problem is to use circular linkedlist.  Just using a plain circular linked list will give O(kn) complexity. if k=n, that would lead to O(n^2) complexity. Something like this -"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Data Structure   Node is a class with 2 instance variable int X and int Y as coordinates. Circle is a class with a instance variable NodesLinkedList. Connect the last node to the first Node in the linked list to make it circular Linked List.  To removing the K th Node from NodesLinkedList add a Method removeNode(Int k)  For Ease of understanding  Assume  NodesLinkedList has 100 Nodes. 100 th Node is connected to 1 st Node. Node to be deleted K th Node is 5. First time 5 th node is deleted and 95 nodes remain.  This goes on till we have last 4 nodes.  Since this is circular. It goes on until we have 1 node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question asks you to design a O(n) time complexity. Is it possible that we use basic array implementation and after every deletion we make a fresh copy of array of (current_size-1)? After first iteration new array is of size n-1 and we perform k % (n-1) to find next index to be deleted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"So, as many said before, this problem can be easily implemented using a Circular Double Linked List, and guaranteeing a O(n) complexity. Specifically, the complexity of this implementation will be O(k*n), and because k is a constant, O(k*n)=O(n). Here's my C++ implementation. I think it's quite simple to understand:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algorithm is based on Josephus_problem#The_general_case on wikipedia. Time complexity is O(n). The code in C:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"You can arrange the nodes as the distance from their center. What I have done here is defined a simple list, and each element of list is a node that describes the distance from the center. Then from that list I retrieve an element randomly and delete it. I do that until there is one element left.  I could have also done it sequentially i.e delete node 1, node 2.... node n-1  Or I could have made a function to delete the user-specified node until one last element is left."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"A circular linked list might be the solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This can be done with the help of doubly circular linked list where we can have track of both the previous and next pointers and at last we can add and remove the element in O(n) time"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=3576940","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"100","title":"You are given an array ' containing 0s and 1s. Find O(n) time and O(1) space algorithm to find the maximum sub sequence which has equal number of 1s and 0s.  Examples 1) 10101010 The longest sub sequence that satisfies the problem is the input itself  2)1101000 The longest sub sequence that satisfies the problem is 110100","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Longest subsequence -> any i,j where i!=j  Needs to test every combination of i,j assuming O(1) for each step. Or else, you're not validating the answer at all. Hence O(n) impossible.  O(n^2) is the minimum."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"O(n^2) solution s[i] - sum of all numbers from position 0 to position i inclusive"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Examples: 10101010 11000000000111 110001 11000100  stored in 0-based array.  Algorithm: 1.  Initialize StartIndex = 1, which represents at what index the longest subsequence starts.  Initialize 'StopAt\" = 0, representing the index you started counting from. 2.  Walk through each item in the array left to right.     a)  if you see a 1, increment startIndex.     b)  if you see a 0, decrement startIndex, with exception.    Exception. If startIndex is StopAt or startIndex > currentIndex, store the StartIndex and the current index-1 (or count) in a List.  Reset StopAt to currentIndex and StartIndex to currentIndex + 1.  3.  Repeat until you reach the end.  When you reach the end, do one final push to the List.  If a StartIndex in the list follows an endIndex, merge them two.  The list seems to be necessary to account for a situation like 1100000000111 where an algorithm that simply decrements or increments startIndex would fail.  Not the prettiest algorithm, but it works.  I think."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// returns an int array representing start and end index of the subsequence. \npublic int[2] GetLongestSubSequence(bool[] sequence) \n{ \n   if (sequence.length < 2) return new int[]{-1,-1}; \n   int startIndex = 1; \n   int stopAt = 0; \n   bool firstChar = sequence[0]; \n   Queue possibleSubSequences = new Queue(); \n    \n   for(i = 1; i < sequence.Length; i++) \n   { \n      if (sequence[i] == firstChar) \n      { \n          startIndex++; \n      } \n      else if (startIndex == stopAt) \n      { \n          possibleSubSequences.Enqueue( new int[]{startIndex, i-1}); \n          startIndex = i+1; \n          stopAt = i; \n          firstChar = sequence[i]; \n      } \n      else \n      { \n          startIndex--; \n      } \n      if (startIndex < i && i == sequence.Length) \n      { \n          possibleSubSequences.Enqueue( new int[]{startIndex, i}); \n      } \n   } \n   int EndIndex = -1; \n   StartIndex = -1; \n   while (possibleSequences.Count > 0) \n   { \n       int[] ps = possibleSequences.Dequeue(); \n       if (ps[0]-1 != lastEndIndex) \n       {  \n           startIndex = ps[0]; \n       } \n       endIndex = ps[1]; \n     } \n \n      return new int[]{startIndex, endIndex}; \n \n        \n   } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"my version: 1. count 1s and 0s and get min => 2*min is the length of the subsequence 2. according to min, we can say which digit is less frequent 3. find the first index of the less frequent digit. 4. starting from that index, while min > 0, count 0s and 1s; min--; if #0s = #1s {break;} 5. in general, start index of the subsequence is the start index of the less frequent digit and the last is the current index from step 4. of course, there are some special cases and we have to subtract/add from/to first/current index from step 4."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n) TC and O(1) SC.  No one has done the trick  :("},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private void findIndex() { \n   int numOf1 = 0, numOf0 = 0; \n   int findOccurence, index = 0, lookFor; \n   for(int i: input){ \n    if(i==0){ \n     numOf0++; \n    }else{ \n     numOf1++; \n    } \n   } \n   if(numOf0 == numOf1){ \n    System.out.println(\"sub sequence is \"+input.length); \n    System.exit(0); \n   } \n   if (numOf0 > numOf1){ \n    findOccurence = numOf0 - numOf1; \n    lookFor = 0; \n   } else { \n    findOccurence = numOf1 - numOf0; \n    lookFor = 1; \n   } \n   for( int i=input.length-1;i>=0;i--){ \n    if (input[i]==lookFor){ \n     findOccurence--; \n     if(findOccurence==0){ \n      index=i; \n      break; \n     } \n    } else { \n     findOccurence++; \n    } \n   } \n   System.out.println(\"Max sub sequence is \"+index); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is not O(1) in space, but is O(n) in time. We maintain an invariant which is difference between number of zero's and one's starting from the index 0, while calculating this we also remember, the max end index of required subsequence if it were to start from any other index i other than 0."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"even without hashing with O(N) memory you can achieve the solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include using namespace std;   void subSeq_1_0(int *ar, int size) {      int min0=-1;      int min1=-1;      int c1=0;      int c0=0;            for(int i=0;i     {              if(min0==-1 && ar[i]==0)min0=i;              else if(min1==-1 && ar[i]==1)min1=i;                            if(ar[i])c1++;              else c0++;      }      int start,n;      if(c0>c1)      {               n=c1*2;               if((n+min1)>size)               start = size-n;               else               start = min1;      }      else      {          n=c0*2;          if((n+min0)>size)          start=size-n;          else          start=min0;      }            cout << \"Longest subsequence of length: \"<<     for(int i=0;i} int main() {     int ar[] = {1,1,1,1,1,0,0,1,0,0};     int size = sizeof(ar)/sizeof(int);          int ar1[] = {0,0,0,1,1,0,0,1,0,0};     int size1 = sizeof(ar1)/sizeof(int);     int ar2[] = {1,1,1,1,1,1,1,1,1,1};     int size2 = sizeof(ar2)/sizeof(int);               subSeq_1_0(ar,size);     subSeq_1_0(ar1,size1);     subSeq_1_0(ar2,size2);     cin.get(); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Raa, what did the interviewer want you to return from your function?  A pointer to the first and last character in the subsequence, or just the size of the subsequence?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My approach:  - Assuming its a string containing binary values. - Find the no. of 1's. Complexity O(n) - if no. of 1's = n/2 then return the full string   else if no. of 1's < n/2 then max possible subset is (no. of 1's) * 2. Lets keep this as 'm'   else if no. of 1's > n/2 then max possible subset is (n - (no. of 1's)) * 2. Lets keep this as 'm' - So now we know the maximum possible subset with equal no. of 1's and 0`s which can be formed with the given string.  - Now have 3 variables, noOfZeros and noOfOnes   Start form zeroth index and move with the window size 'm', ie initially read 0 to 'm' index and update the 2 variables. - Now noOfZeros = noOfOnes then return the lower and higher indices   else if noOfOnes > noOfZeros then maxPossibleSubset in this window is noOfZeros   else maxPossibleSubset in this window is noOfZeros.   In this step save the lower and higher indices of the window  - Now move the windoew to the next index, ie move the windoew right by 1 and continue the same.   Update the maxPossibleSubset and the lower and higher indices only if current maxPossibleSubset is greater than the previous. - After scanning through the full array we will have the data of which window is possible to have the max no. of 0's n 1's.    So scan through that window alone to form the string with the help of maxPossibleSubset."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"initially take the full string if 0's are more then start pruning frm that end frm where 0's can be reduced and if both sides have 1 then take both cases and in first case prune frm left and in other prune frm right   continue these steps untill 0's and 1's become equal and campare the length of all strings  answer the maximum one"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about maintaining a counter and increasing it for every 1 and decreasing it for every 0? Store the start index and everytime the counter becomes zero, store the end index. continue increasing the end index till end of string. the largest diff between start and end index will give the substring.  Ex 001010101001  here a[2] to a[11] = 1-1+1-1+1-1+1-1-1+1 =0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algo step 1) count 0's and 1's say it is m and n respectively 2) say m>n in that case we want to get rid of m-n 0s from end than 1's. iterate from back and keep a counter for both of them and just do that  JUST O(N) AND NO EXTRA SPACE :-)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n^2) solution s[i] - sum of all numbers from position 0 to position i inclusive"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Are you sure that the solution has to be in O(1) space ? There is a solution for this problem in O(N) time and space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Traverse the array once to count n(0) & n(1). If n(0)=n(1), return the entire array. If n(1) > n(0) : Find i as index of first o which is occuring Find j as index of last o which is occuring Now, outside this window there are only leading & terminating 1's Count how many 1's lie between i & j : say k. Then include n(0)-k 1's from either the terminating or leading 1's.  Does it look okay ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it can be solved in O(n) time .. first find two extreme zero's and check if the number of ones's inside them are less than the total number of zero's.if yes them find extra number of ones's on either side to equate the number of 0's and 1's,else start pruning the string frm one side until u encounter the numbers to be equal.  my code below has done the same all what is needed to be appended is that pruning from left side as well so as to get the longest string with same number of 1's and 0's. import java.io.*; import java.lang.reflect.*; import java.lang.*; class substring{ public static void main(String args[])  {  //System.out.println(\"code wrks fr string with number of one's more than number of zero's\");  String s=args[0];  char[] str=s.toCharArray();  //System.out.println(Array.getLength(str)); //int len=str.length();  int i,c=0,so=0,sz=0,ls,zf,zl,alfa=0,ss,se,ss1,se1; //while(str[i]!=null){i++;}  int len=Array.getLength(str);  int z=0,o=0,omz=0;  for(i=0;i {   if (str[i]=='0')   {    z++;   }   else   {   o++;   }  } i=0;  while(str[i]!='0')  {   i++;  } zf=i;ss=i; i=len-1;  while(str[i]!='0')  {   i--;  } zl=i;se=i; ls=zl-zf+1;  if(o>z)  {   omz=o-z;   //System.out.println(\"no is 1's   \"+zf);   //System.out.println(\"no is 0's   \"+zl);   //System.out.println(\"no is 1's minus no. of 0's   \"+omz);  for(i=zf;i<=zl;i++)   {    if(str[i]=='1')   so++;   }  sz=ls-so;   //System.out.println(\"no of ones inside extreme zero's\"+so);  if(so<=sz)     {    alfa=sz-so;    if(((len-1)-se)>=alfa)     {     se=se+alfa;     }    else     {     se=len-1;ss=ss-(alfa-((len)-se));     }                   for(i=ss;i<=se;i++)     System.out.print(str[i]);   }   else   {    //System.out.print(so+\"   \");    //System.out.println(sz);       int i1;    i=len-1;  alfa=o-z;    //System.out.print(o+\"is 1's\");    //System.out.println(z+\"is 0's\");    //System.out.print(alfa+\"  is alfa \");//System.out.println(sz);   while((alfa!=0))    {     if(str[i]=='1')     {     alfa--;i--;     }     else {alfa++;i--;}    }   if(i==-1){System.out.println(\"full string exhausted\");}else{se=i;}   for(i1=ss;i1<=se;i1++)    System.out.print(str[i1]);   }  } else return;  } }   note:one thing more can be appended is if string has just one 0 or one 1.then answer can be given too easily so a check can be put ri8 in the start. i had coded fr this sumtime back so have just put my code here in a partial cumplete manner acording to the demand of the question but i hope i have made my idea clear to do this question in O(n) time and O(1) space... if sum1 has any prob then let me knw ,i can explain the logic a bit more vividly ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"count occurrences of 1 s1 count occurrences of 0 s0 check which is smaller s1 or s0 1. if s0 == s1 print entire string   2. if s0 < s1     find d = s1 - s0    say first zero is at x location     print sub sequence from x to size-(d-x)  3. if s1 < s0    find d = s0 - s1    say first one is at x location     print sub sequence from x to size-(d-x)  Complexity O(n) for count O(n) for finding first occurrence and printing :)  thus it will always be O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i guess if we are talking of subsequence than its length can be calculated as  2*min(no of 0's,no of 1's)  because for subsequence u can take into account all the 1's or 0's whichever is mininum  But the problem becomes harder in case of substring containing equal no of 1's and 0's"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Similar variation:  Count number of one's (call it M). and number of zero's (call it K).  - this can be done in one pass (in O(n)) and fixed memory space.  Now - let T = min(M,K). Surely the result is of size 2*T. Iterate the string from start to the index Z until you count T zero's and T one's (by definition of T,M,K - you will reach such an index Z). This is done again in O(n) time and a fixed memory space.  return the sub string from start to Z."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. count the number of 0s, denoted as n0. 2. count the number of 1s, denoted as n1. 3. MinNum=Min(n0,n1), so, the maximum sub string should no longer than 2*MinMum. 4. Suppose the MinNum is n0. Then find the first 0 and last 0 in the sub string. Then count the number of 1s between this two 0s. if num of 1s between this two 0s is equal to n0, then we are done.  otherwise,  if num of 1s is larger than n0, get rid of any 0 of those two boundary 0s and substring before it if it is beginning 0, or substring following it if it is end 0. then find substring in new generated string, go to step 1. if num of 1s is smaller than n0, then search the substring before the first 0 and last 0, until we find the answer.  coz it is a little recursive, Im not sure about time complexity."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"well i think u are also gonna end up with if else ladder along with recursive soln. because if not the case than u have to think that upto which point or which 1's u need to skip from both ends"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"From TopCoder Forum by \"konqueror\"   The following solution assumes that the given array is an integer array (instead of a char array) for ease of exposition. Later, we will show how we can modify it to use a char array instead.  The outline of the solution: 1) Transform the (integer) array (modify in place) to an equivalent (integer) array 2) Perform computation on the array 3) Restore array. So, in effect you would have used only O(1) additional space.  We shall cheat a little bit and use indexing in the range [0...n] instead of [0...n-1]. We assume that the given (integer) array actually occupies indices [1...n]. This makes things easier to understand. At the end, this will be irrelevant.  Step 1(transformation): A[i] = (i==0)?0:((A[i]==0?1:-1) + A[i-1])  In words, A[i] = (number of zeroes - number of ones) in the first i places of the (original) array. At the end of step 1, you have an array of integers. The task is to find out max{y-x | A[y] = A[x] }   Notation:  First(t) = min{ x | A[x] = t} if t appears in A, infinity if t doesn't appear in A Last(t) = max{ x | A[x] = t} if t appears in A, -infinity if t doesn't appear in A D(t) = Last(t) - First(t) L = max{ D(t) | integer t}  First and Last correspond to the indices of the first and last occurences respectively of their argument.We call integer T good if D(T) = L. Our task is to compute L. If we identify *one* good integer, g, then, we can compute L = D(g) in linear time(trivially), with O(1) additional space.  Let END = A[n]. Assume END > 0. (if END < 0, we flip 0s and 1s, solve (since flipped END > 0) (and flip back). END = 0 is trivial: L = n).  Observation 1: First(x) > First(y) if x > y >= 0. Trivial. Observation 2: First(x) > First(y) if 0 >= y > x. Trivial. Observation 3: If t > END, then t is not good. Since First(t) > First(END) and Last(t) < Last(END). Observation 4: If t < -1, then t is not good. Since END > 0, Last(-1) > Last(x) for x < -1. Follows from observation 2. Observation 5: Last(0) < Last(1) <.. < Last(END). Suppose 0 < x+1 <= END and Last(x) > Last(x+1). Then, clearly, A[Last(x)...n] does not contain x+1. Hence, it surely cannot contain END (since END >= x+1 and the values in A move only +1/-1 at a time(no jumps)), a contradiction. Observation 6: First(0) < First(1) < .. < First(END). Follows from observation 1.  Observation 5 and 6 are the crux of the linear time solution we propose. In short, we can compute Last(i) and First(i) for 0<=i<=END in one pass. Observations 3 and 4 allow us to limit the search of a good candidate to [0, END] and {-1} Also, First(x) and Last(x) can be computed in O(n) time for any x trivially.  Step 2(Computing optimum):   int first = First(END), last = Last(END), x = END-1;  int L = last-first;  while(x >= 0) {   while(A[last] != x) last--;   while(A[first] != x) first--; //(this is wrong, we will show how to fix it below)   L = max(L, last-first);   x--;  }  L = max(L, Last(-1) - First(-1));  But, there is a mistake. Can you spot it ?  The problem occurs for cases like 10000.. . In such cases, first(t) = last(t) for t>0. for t=0, however, first(t)=0, last(t)=2. (The code shown above does not handle this case). So, how do we fix it ? We realize that stepping through first(t) (in decreasing order of t) is nothing but stepping through prefix maximums. Position i is a prefix maximum if A[i] > A[j] for j < i. We can compute prefix maximums in one linear pass and mark some positions (with say most significant bit) as prefix maximums. Moving the variable \"first\" is equivalent to moving to the next lower prefix maximum (or -1).  Step 3(Restore Array): Trivial: (A[i] == A[i-1] + 1)? (A[i] = 0) : (A[i] = 1); (1<=i<=n)  This concludes the solution, given integer array.  How do we make it work with a char array ?  1) Compute END (O(1) additional space, O(n) time). (assume END > 0 from here on, else flip, etc..) 2) Mark prefix maximums with char '2'. Note only original '0's can become '2'. ('0' corresponds to depth +1 and '1' to depth -1) 3) Initialize first, last and x in line 1 of step 2. (O(n) time, O(1) additional space). 4) Replace the line:  while(A[last] != x) last--;  with   int diff = 0; while(diff != 1) { diff += (A[last]=='1'?-1:1); last--; }   5) Replace the line:  while(A[first] != x) first--;  with   --x; while(x >= 0 && A[x] != '2') x--;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n) solution in C#  private int[] getsub01(int[] n)         {              int count1 = 0, count0 = 0;             int i=0,start1=0,last1=0,last0=0;             foreach (int num in n)             {                 if (num == 0)                 {                                         count0++;                     last0=i;                 }                 else                 {                         if(count1==0)                     start1=i;                     count1++;                     last1=i;                 }                 i++;             }             int count = 0;              if (count0 == count1)                 return n;             if(count0==0 || count1==0)                 return null;                        int rest = count0 > count1 ? 0 : 1;             int last = count0 > count1 ? last1 : last0;               int oth=rest==0?1:0;               count = counter(n, oth, 0, last);               if(counter(n,rest,0,last)==count)                 return subarray(n,0,last);             else if(counter(n,rest,0,last)            {                 int inc=(count1*2)- subarray(n,0,last).Length;                 if(inc+last<=n.Length-1)                     return subarray(n,0,last+inc);              }             else{              int s=0,l=last;                            while(counter(n,rest,s,l)>count)             {                                 s=s+1;                 count = counter(n, oth,s, l);                            }              return subarray(n, s, l);                          }             return n;         }          private int counter(int[] n,int num,int start,int end)         {             int count=0;             for(int j=start;j<=end;j++)             {                 if(n[j]==num) count++;             }                      return count;         }          private int[] subarray(int[] n, int start, int end)         {             int len = end - start + 1;              int[] sub=new int[len];                          for (int i= start,j=0; i <= end; i++,j++)             {                 sub[j] = n[i];             }              return sub;         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think This Logic Might Work  1. count number of 0's called num_o o(n) 2. count number of 1's called num_1 o(n) 3. find the min of two O(1) 4. length or Bubble is of length is twice the min 5. start from first and copy all the array of size of length and count number of 0s and 1's if equal then done else shift the bubbel one int to right and check it again.  At the end you will have the solution in o(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think This Logic Might Work  1. count number of 0's called num_o o(n) 2. count number of 1's called num_1 o(n) 3. find the min of two O(1) 4. length or Bubble is of length is twice the min 5. start from first and copy all the array of size of length and count number of 0s and 1's if equal then done else shift the bubbel one int to right and check it again.  At the end you will have the solution in o(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"solution may be  \nint flag=0; \nint postion=-1; \nwhile(i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"at the postion of  \nppstion=flag; \nit is  \npostion=i;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void find(int[] a)  {   int count0 = 0, count1 = 0, maxChk, maxOccr;      int size = a.length;      for(int i=0;i  {    if(a[i]==0)     count0++;    else     count1++;   }      if(count1>count0){    maxChk = 1;    maxOccr = count0;   }else{    maxChk = 0;    maxOccr = count1;   }     int pivot=0;   int curr1 = 0;   int curr0 =0;      for(int i=0;i  {        if(a[i]==0)     curr0++;    else     curr1++;        if(maxChk==1)    {     while(curr1>maxOccr)     {      if(a[pivot]==0)      {       curr0--;       maxOccr--;      }else      {       curr1--;      }            pivot++;     }    }        if(maxChk==0)    {     while(curr0>maxOccr)     {      if(a[pivot]==1)      {       curr1--;       maxOccr--;      }else      {       curr0--;      }            pivot++;     }    }        if(maxOccr==curr0 && maxOccr==curr1)    {     System.out.println(\"start index = \"+pivot+\" , end index = \"+i+\", size = \"+(2*maxOccr));     return;    }   }    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int 1_count = 0; int 0_count = 0; int max_len = 0; int end = -1;  for(int i = 0 ; i < n ; i++){     if(a[i] == 0) 0_count++;     else 1_count++;          if(1_count != 0 && 0_count != 0){        if(min(0_count,1_count) > max_len){           max_len = min(0_count, 1_count);           end = i;        }     } }  int start = end - (2 * max_len) + 1;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How can we be so sure of substring having twice the length.. For Eg. 10100001 ..the ans will be 1010 isnt it? and its length is 4 ..not twice of min(len_0, len_1) which is 3X2=6."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"is any solution exist in given constraints? or shall i call Petr Mitrichev :P"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can we solve this by using RegExp?? any idea?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using a stack. stack has only 2 member, 1 is value (0 or 1), 1 is number of value."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"whenever 0 comes subtract and whenever 1 comes add it. using DP extra space o(n) find at each positon its value. now stores this DP values in a hash map whenever a equal value occurs check lowest index for that value and this value and if that's the max i.e length is greater than previous length den store it in max after parsing the total input  return  max"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I will give my solution by stating example:  Input: 1 0 0 1 1 0 0 1 1 1  now create another auxillary array of same size as Input. Now traverse the input and keep taking the cummulative sum where consider 0 = -1  so for given input, auxillary array will have following values:  Input: 1  0  0  1  1  0  0  1  1  1 aux  : 1  0 -1  0  1  0 -1  0  1  2  now take 2 pointers one at the start of aux and one at the end of aux. Now the purpose of moving start and end would be to bring { aux[end] - aux[start] =0 }  there are some decisions to be taken:   while(end>start) { if(aux[end] - aux[start] == 0) {   break; } else { if(aux[end] - aux[start]>0) {    if(aux[end-1] - aux[start] >= aux[end] - aux[start+1])    {       start = start + 1; // Take the value which is min    } } else  {     if(aux[end-1] - aux[start] >= aux[end] - aux[start+1])     {       end = end - 1; // Take the value which is min     } } }  final solution: startIndex = start +1; EndIndex = end;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Some problem in above logic, so correcting that:   Input: 1 0 0 1 1 0 0 1 1 1  now create another auxillary array of same size as Input. Now traverse the input and keep taking the cummulative sum where consider 0 = -1  so for given input, auxillary array will have following values:  Input: 1 0 0 1 1 0 0 1 1 1 aux : 1 0 -1 0 1 0 -1 0 1 2  now take 2 pointers one at the start of aux and one at the end of aux. Now the purpose of moving start and end would be to bring { aux[end] - aux[start] =0 }  there are some decisions to be taken:  while(end>start) { if(aux[end] - aux[start] == 0) { break; } else { if(aux[end] - aux[start]>0) { if(aux[end-1] - aux[start] >= aux[end] - aux[start+1]) { start = start + 1; // Take the value which is min } else {    end = end -1; } } else  { if(aux[end-1] - aux[start] >= aux[end] - aux[start+1]) { end = end - 1; // Take the value which is min } else { start = start +1; } } }  final solution: startIndex = start +1; EndIndex = end"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assume input is 11010 \n \nc0: count of 0 counted from beginning. \nc1: count of 1 counted from beginning. \nc0': if current element is 0, then c0'=c0-1, otherwise c0'=c0. \nc1': if current element is 1, then c1'=c1-1, otherwise c1'=c1. \n \n  (c0,c1) c1-c0     (c0',c1')  c1'-c0' \n1 (0,1)    1        (0,0)      0 \n1 (0,2)    2        (0,1)      1 \n0 (1,2)    1        (0,2)      2 \n1 (1,3)    2        (1,2)      1 \n0 (2,3)    1        (1,3)      2 \n \nif for i and j (j>i), c1[j]-c0[j] = c1'[i]-c0'[i], then a subsequence of equal 0's and 1's is found from i to j. For example, (1,4),(2,3).... \n \nint f(int* a, int n) \n{ \n   Hash h = new Hash(); \n   int c0=0; \n   int c1=0; \n   int max=INT_MIN; \n \n   for(int i=0;imax) \n           { \n              max=len; \n           }    \n       } \n \n       if(a[i]==0) \n       { \n          diff++; \n       } \n       else \n       {  \n          diff--; \n       } \n        \n       if(!h.ContainKey(diff) \n       { \n           h.Add(diff, i); \n       } \n    } \n \n    return max; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/*the function returns the end index of the longest sub-sequence \nand start index is passed as reference variable*/ \nint findMaxSubSeq(int a[],int i,int &start) \n{ \n   int end; \n   static int count[2]={0,0},token,len=(sizeof(a)/sizeof(a[0]); \n    \n   if(i==len)) \n   {   \n     token=((count[0]0) \n       end=i+(2*token)-1;  \n      else \n       end=0;  //for strings containing only 1's or only 0's \n    } \n    else if(count[0]==count[1]) \n    { \n      token=-1;  //so that the condition 'if(token>0)' above is not satisfied     \n      count[0]--; //so that this condition is not satisfied again \n      return i; \n    }  \n    else \n      count[a[i]]--; \n   } \n   return end; \n} \n \nvoid main() \n{ \n   int a[]={1,1,0,1,0,1,1},start=0; \n   end=findMaxSubSeq(a,0,start);       \n   if(start>=end) \n    cout<<\"No such sub-sequence\"; \n   else  \n    for(int i=start;i<=end;i++) \n      cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I know this thread is old, but I think this question is interesting and very tricky. Can we modify the elements in the array? I mean we can achieve the required complexity and give the start & end index if we can modify the original array, but probably not the original sub-sequence. does this count? :p Not sure if the following process can make the interviewer happy.  The idea is, we start a loop from the zero index(let's say i = 0) and find the first pair of adjacent 1 & 0, change them to -1, and then we check the left and right side of the pair if left or right has not reached the boundaries. There are two possibilities which make the sub-sequence starts from the pair a longer one: 1. array[left] ^ array[right] = 1 (if left > -1 and right < length of the array) 2. array[right] ^ array[right + 1] = 1 (if right + 1 < length of the array)  if neither of the condition can be reached, then we set the current index to right (i = right), and repeat the process until i reaches the boundary. The time complexity should be O(n)   after the loop, every possible pair should have been set to -1. And to get the start and end indexes of the required sub-sequence, we starts another loop to get the max length of continuous -1, that's another O(n). So overall, we have O(n) + O(n) = O(n), and the function requires left & right & length(this variable is used to calculate the max length of the sub-sequence) which is a constant, so the space complexity is O(1). The only problem is that we need a copy of the original array to give the detailed sub-sequence or we can only tell the interviewer where the sub-sequence is. But that's the only solution I can think of which can have a close complexity to the requirement. Looking forward to a perfect solution to this question. The following function is the implementation, it doesn't handle some edge cases like an array that has only one element. It is not perfect and has not been fully tested, but it has passed the following test cases: {1,1,0,0,0,0,0,0,0,0,0,1,1,1}(14 elements in total, the answer is 6) {1,1,0,0,0,1}(6 elements in total, the answer is 6) {1,1,0,0,0,1,0,0}(8 elements in total, the answer is 8) {0,1,1,1,1,1,1,1,1,0,1,0,0,0}(14 elements in total, the answer is 8) {1,0,1,0,0,0,1}(7 elements in total, the answer is 4)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorry, the test result of test case {1,1,0,0,0,1,0,0} should be 6"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"TC O(N); SC O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int maxSubArray(int[] array) { \n  int max = 0; \n  if(array.length<2) \n   return max; \n  for(int i=0; i hm = new HashMap(); \n  for(int i=0; imax) \n     max = pot; \n   } \n  } \n  return max; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Following solution runs in O(n+m) where m < n."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It can be done in O(n) time and O(1) space using two pointers.  1. Count # of 0's, #Z, and 1's, #O.   2. Initially \"start\" pointer points to position 0, \"end\" points to n-1. This is current window.  3. If #Z > #O, 3.a) if any of the pointers point to 0, move the pointer and reduce #Z.  3.b) If none of the pointers point to 0, skip 1's from the end where there are fewer 1's to skip to get to a 0. Once you get to zero 3.a applies. Update counters accordingly.  4. Similar logic applies to #Z < #O.  Basically the idea is that for the max window there is a #Z = #O, we try to reach that number from the possible max."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13575664","download_status":"DOWNLOAD_DONE","votes":"3","answersCount":"82","title":"Q1.- Written exam (Amazon, Bangalore)  Given a singly link list and a number 'K', swap the Kth node from the start with the Kth node from the last. Check all the edge cases.  Sample Input: 1->2->3->4->5->6->7->8 and K = 3 Sample Output : 1->2->6->4->5->3->7->8  Sample Input: 1->2->3->4->5->6->7->8 and K = 10 Sample Output: print error \"LIST IS OF LESSER SIZE\".","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"18","title":"This can be done in line without first completely traversing the list to check the size. This can be done with 3 pointers.   One pointer is for the first element which is k from the start the second pointer is for the element which is k from the end the last pointer is to find the end.  Then you traverse the list save the pointers and do the swap at the end, you don't even have to mess with the links when swapping, just swap the values from the pointers you have saved from above."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"We need to handle a few test cases. 1. Both nodes are end nodes. 2. Both nodes are adjacent. 3. Both nodes are somewhere else. 4. Both node are same. 5. kth node doesn't exist.  I prefer swapping the nodes rather than values. It is always advisable to swap the nodes as in general, nodes may contain several data. So, it will be overhead to swap the values.  Steps: Find the kth node[p] from the beginning. If no kth node, return. Take another pointer[q] & move it at head. Move it & the kth node one step at a time until kth node is null.   q is the kth node from the last.  We need to swap p & q.  The part of linked list found is: t1->p->t2   and t3->q->t4 Just swap the nodes based on links & handle the corner cases mentioned above. Here is the code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Take 3 pointers to the starting point of the list - P1, P2 & P3.  Start moving P1 & P3 till you have moved 'K'  nodes. If the list ends before P1 reaches the End, give the error message \"LIST IS OF LESSER SIZE\". Once you have reached the Kth node, move P1 and P2 pointers to the next node one by one till P1 reaches the end.  At this point P2 points to the Kth element from the last. Now simply swap the values of P2 & P3.  Job done."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public static void swap(LinkedList ll,int k){ \n  int size = ll.size(); \n  if(1<=k&&k<=size){ \n   int firstK = ll.get(k-1); \n   int lastK=ll.get(size-k); \n   ll.set(k-1, lastK); \n   ll.set(size-k, firstK); \n   System.out.println(ll); \n  }else{ \n   System.out.println(\"ERROR\"); \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algorithm: 1.Get the linked list lenghth. If it is less than 'K' print the error message. O(N) 2.Traverse to the 'K' the element from the beginning. O(N) 3.Traverse to the N-Kth element from the beginning. O(N) 4. Swap them.O(1) 5.End of Algorithm  Complexity: O(N)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Find Kth Element from Beginning. Store the pointer. 2. Using Kth Element, find kth element from last(two pointers) 3. Swap these pointers. 4. At every step, check for length traversed till is < n, otherwise raise error"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node* SwapList(Node* head, int k) \n{ \n if (head == NULL || head->next == NULL) \n { \n  return head; \n } \n  \n Node* current = head->next; \n Node* prev = head; \n int currentCount = 2; \n  \n Node* kth = NULL; \n Node* kthPrev = NULL; \n Node* kthLast = NULL; \n Node* kthLastPrev = NULL; \n  \n while (current != NULL) \n { \n  if (currentCount == k) \n  { \n   kth = current; \n   kthPrev = prev; \n  } \n   \n  if (kthLast != NULL) \n  { \n   kthLastPrev = kthLast; \n   kthLast = kthLast->next; \n  } \n  else if (kth != NULL) \n  { \n   kthLast = head; \n  } \n   \n  prev = current; \n  current = current -> next; \n } \n  \n if (kth == NULL) return head; // kth node does not exist in list \n if (kth == head) // k == 1 \n { \n  kthLast->next = kth->next \n  kth->next = NULL; \n  kthLastPrev->next = kth; \n  return kthLast; // this becomes new head \n } \n  \n  \n if (kthLast == head) \n { \n  kth->next = kthLast->next; \n  kthprev->next = kthLast; \n  kthLast->next = NULL; \n  return kth; \n } \n  \n Node* temp = kth->next; \n kth->next = kthLast->next; \n kthLast->next = temp; \n kthLastPrev->next = kth; \n kthPrev->next = kthLast; \n return head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node* SwapList(Node* head, int k) \n{ \n if (head == NULL || head->next == NULL) \n { \n  return head; \n } \n  \n Node* current = head->next; \n Node* prev = head; \n int currentCount = 2; \n  \n Node* kth = NULL; \n Node* kthPrev = NULL; \n Node* kthLast = NULL; \n Node* kthLastPrev = NULL; \n  \n while (current != NULL) \n { \n  if (currentCount == k) \n  { \n   kth = current; \n   kthPrev = prev; \n  } \n   \n  if (kthLast != NULL) \n  { \n   kthLastPrev = kthLast; \n   kthLast = kthLast->next; \n  } \n  else if (kth != NULL) \n  { \n   kthLast = head; \n  } \n   \n  prev = current; \n  current = current -> next; \n } \n  \n if (kth == NULL) return head; // kth node does not exist in list \n if (kth == head) // k == 1 \n { \n  kthLast->next = kth->next \n  kth->next = NULL; \n  kthLastPrev->next = kth; \n  return kthLast; // this becomes new head \n } \n  \n  \n if (kthLast == head) \n { \n  kth->next = kthLast->next; \n  kthprev->next = kthLast; \n  kthLast->next = NULL; \n  return kth; \n } \n  \n Node* temp = kth->next; \n kth->next = kthLast->next; \n kthLast->next = temp; \n kthLastPrev->next = kth; \n kthPrev->next = kthLast; \n return head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node* SwapList(Node* head, int k) \n{ \n if (head == NULL || head->next == NULL) \n { \n  return head; \n } \n  \n Node* current = head->next; \n Node* prev = head; \n int currentCount = 2; \n  \n Node* kth = NULL; \n Node* kthPrev = NULL; \n Node* kthLast = NULL; \n Node* kthLastPrev = NULL; \n  \n while (current != NULL) \n { \n  if (currentCount == k) \n  { \n   kth = current; \n   kthPrev = prev; \n  } \n   \n  if (kthLast != NULL) \n  { \n   kthLastPrev = kthLast; \n   kthLast = kthLast->next; \n  } \n  else if (kth != NULL) \n  { \n   kthLast = head; \n  } \n   \n  prev = current; \n  current = current -> next; \n } \n  \n if (kth == NULL) return head; // kth node does not exist in list \n if (kth == head) // k == 1 \n { \n  kthLast->next = kth->next \n  kth->next = NULL; \n  kthLastPrev->next = kth; \n  return kthLast; // this becomes new head \n } \n  \n  \n if (kthLast == head) \n { \n  kth->next = kthLast->next; \n  kthprev->next = kthLast; \n  kthLast->next = NULL; \n  return kth; \n } \n  \n Node* temp = kth->next; \n kth->next = kthLast->next; \n kthLast->next = temp; \n kthLastPrev->next = kth; \n kthPrev->next = kthLast; \n return head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node* SwapList(Node* head, int k) \n{ \n if (head == NULL || head->next == NULL) \n { \n  return head; \n } \n  \n Node* current = head->next; \n Node* prev = head; \n int currentCount = 2; \n  \n Node* kth = NULL; \n Node* kthPrev = NULL; \n Node* kthLast = NULL; \n Node* kthLastPrev = NULL; \n  \n while (current != NULL) \n { \n  if (currentCount == k) \n  { \n   kth = current; \n   kthPrev = prev; \n  } \n   \n  if (kthLast != NULL) \n  { \n   kthLastPrev = kthLast; \n   kthLast = kthLast->next; \n  } \n  else if (kth != NULL) \n  { \n   kthLast = head; \n  } \n   \n  prev = current; \n  current = current -> next; \n } \n  \n if (kth == NULL) return head; // kth node does not exist in list \n if (kth == head) // k == 1 \n { \n  kthLast->next = kth->next \n  kth->next = NULL; \n  kthLastPrev->next = kth; \n  return kthLast; // this becomes new head \n } \n  \n  \n if (kthLast == head) \n { \n  kth->next = kthLast->next; \n  kthprev->next = kthLast; \n  kthLast->next = NULL; \n  return kth; \n } \n  \n Node* temp = kth->next; \n kth->next = kthLast->next; \n kthLast->next = temp; \n kthLastPrev->next = kth; \n kthPrev->next = kthLast; \n return head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void swapElementsInLinkedList(int k){   if(k<0 || k> getSize() ){    throw new InvalifIndexException(\"LIST IS OF LESSER SIZE/LIST SIZE CANT BE NEGATIVE\");   }   temp = head ;   LinkedListNode KthnodeFromRear = null;   int newValueForK = (getSize()-k)+1;   int counter = 1;   int firstStop = 0;   int lastStop = 0;   if(k   firstStop = k;    lastStop = newValueForK;   }   else{    firstStop = newValueForK;    lastStop = k;   }     while(counter != firstStop){         counter ++;         temp=temp.getNext();          }       KthnodeFromRear = temp;     while(counter!=lastStop){         counter ++ ;         KthnodeFromRear = KthnodeFromRear.getNext();         }         swap(temp,KthnodeFromRear);          }      private void swap(LinkedListNode first, LinkedListNode last) {   Integer data = first.getData();   first.setData(last.getData());   last.setData(data);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void replace_node(struct node **head,int pos) \n{ \n        int count = 1; \n        int tmp =0; \n        myNode *curr = *head; \n        myNode *one = curr; \n        myNode *two = curr; \n        while(two != NULL && two->next !=NULL && count next; \n                count++; \n        } \n        curr = two; \n        while(one!=NULL &&one->next!=NULL&& two->next!=NULL) \n        { \n                one = one->next; \n                two = two->next; \n        } \n        tmp = curr->value; \n        curr->value = one->value; \n        curr = one; \n        curr->value = tmp; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void replace_node(struct node **head,int pos) \n{ \n        int count = 1; \n        int tmp =0; \n        myNode *curr = *head; \n        myNode *one = curr; \n        myNode *two = curr; \n        while(two != NULL && two->next !=NULL && count next; \n                count++; \n        } \n        curr = two; \n        while(one!=NULL &&one->next!=NULL&& two->next!=NULL) \n        { \n                one = one->next; \n                two = two->next; \n        } \n        tmp = curr->value; \n        curr->value = one->value; \n        curr = one; \n        curr->value = tmp; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int kthnodeswap (node*& head, int k) \n{ \n \n    if (k<=0) //invalid node given \n        return -1; \n    else \n    { \n        if (k==1) //swap head node and last when index = 1 \n        { \n            node *trav = head; \n \n            //move till the end of the list \n            while (trav->next!=NULL) \n                trav = trav->next; \n \n            //swap head and last node \n            int temp = head->data; \n            head->data = trav->data; \n            trav->data = temp; \n            return 1; \n        } \n        else \n        { \n            node *trav = head; //pointer to traverse the list \n            node *swap1 = trav; //pointer which will point to the kth node from beginning \n            node *swap2 = trav; //pointer which will point to the kth node from end \n \n            //advance both traverse pointer and the beginning pointer till kth node \n            for (int i = 2; i <= k ; i++) //index starts at 2 since 1st node is head \n            { \n                trav = trav->next; \n                if (trav == NULL) return 0; //list is of lesser size \n                swap1 = trav; //advance two pointers to the same location \n            } \n \n            //after reaching the kth node from beginning advance the traverse pointer and end pointer \n            while (trav->next != NULL) \n            { \n                trav = trav->next; \n                swap2 = swap2->next; \n            } \n \n            //swap the data pointed by beginning pointer and end pointer \n            int temp = swap1->data; \n            swap1->data = swap2->data; \n            swap2->data = temp; \n            return 1; \n \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int list_swap(snode *head,int pos) \n{ \n    snode *tmp; \n    int ll=0; \n    int cnt=1; \n    snode *curr    =    NULL; \n \n    for(tmp = head;tmp;tmp=tmp->next)  \n            ll++; \n     \n    for(tmp = head;cnt < pos;cnt++)  \n            tmp=tmp->next; \n \n    /*Found from head node*/ \n     \n    curr    =    tmp; \n    while((ll-cnt) != pos-1) \n    { \n        tmp    =    tmp->next; \n        cnt++; \n    } \n    /*Now swapping the data part*/ \n    cnt    =    tmp->data; \n    tmp->data    =    curr->data; \n    curr->data    =    cnt; \n    return(0);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void swaplist(Node** list,int K) \n{ \n if (K<1)  \n  return; \n int count=1; \n Node* first=*list; \n while (count++next; \n if (first==0) { \n  cout << \"not available\\n\"; \n  return; \n } \n Node* tmp=first; \n first=first->next; \n Node* second=*list; \n while (first) { \n  first=first->next; \n  second=second->next; \n } \n swap(tmp1,second);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is working code and covers almost all the cases and boundries:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Fellas.. this ain't a Big Complex Code.. Its tricky question...  Algo. 1> Get kth Node from last and kth node from beginning. 2> Hold one pointer each to these nodes. 3> Swap their values.. :D   Code               struct Node* Swapkth(struct Node * node,int k)               {                 struct Node *temp1,*temp2,*temp3;                 temp1=node;                   while(k!=0) {                                           node=node->next;                        }                     temp2=node;// this is kth node from first                                         while(node->next!=NULL) {                                node=node->next;                                temp1=temp1->next;                           }                    //Finally when loop exits temp1 will be  pointing to the kth node from the last.                  temp3=temp1;                  temp1->data=temp2->data;                  temp2->data=temp3->data;               free(temp1);               free(temp2);               free(temp3);              }   This is all U need... No Swapping No Complex Code.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Fellas.. this ain't a Big Complex Code.. Its tricky question...  Algo. 1> Get kth Node from last and kth node from beginning. 2> Hold one pointer each to these nodes. 3> Swap their values.. :D   Code               struct Node* Swapkth(struct Node * node,int k)               {                 struct Node *temp1,*temp2,*temp3;                 temp1=node;                   while(k!=0) {                                           node=node->next;                        }                     temp2=node;// this is kth node from first                                         while(node->next!=NULL) {                                node=node->next;                                temp1=temp1->next;                           }                    //Finally when loop exits temp1 will be  pointing to the kth node from the last.                  temp3=temp1;                  temp1->data=temp2->data;                  temp2->data=temp3->data;               free(temp1);               free(temp2);               free(temp3);              }   This is all U need... No Swapping No Complex Code.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/*Q1.- Written exam (Amazon, Bangalore)  Given a singly link list and a number 'K', swap the Kth node from the start with the Kth node from the last. Check all the edge cases.  Sample Input: 1->2->3->4->5->6->7->8 and K = 3 Sample Output : 1->2->6->4->5->3->7->8  Sample Input: 1->2->3->4->5->6->7->8 and K = 10 Sample Output: print error \"LIST IS OF LESSER SIZE\"*/ #include #include struct node *recursion(struct node *,int ); /* void append(struct node **,int ); void display(struct node *);  here is problem is that void  you will get warning warning: ??struct node?? declared inside parameter list [enabled by default] amazon1.c:12:20: warning: its scope is only this definition or declaration, which is probably not what you want [enabled by default] amazon1.c:13:21: warning: ??struct node?? declared inside parameter list [enabled by default] */ struct node  {   int data;   struct node *link; }; int main() {   struct node *start;   start=NULL;   int n,i=0,item,k;   printf(\"Enter the no of node\\n\");   scanf(\"%d\",&n);   while(i++  {    printf(\"Enter node value\\n\");    scanf(\"%d\",&item);    append(&start,item);      }   display(start);   printf(\"Enter the number k for swaping kth from the fast and kth from last\\n\");   scanf(\"%d\",&k);   swap(start,k,n);   printf(\"\\n\");   display(start); }  append(struct node **t,int b) {   struct node *r,*temp;   r=*t;     if(r==NULL)     {         r=(struct node*)malloc(sizeof(struct node));         *t=r;     }   else     {          while(r!=NULL)         {           temp=r;           r=r->link;         }         temp->link=(struct node *)malloc(sizeof(struct node));         r=temp->link;         /*            If you write like this r=(struct node *)malloc(sizeof(struct node)); then you are creating indepent node which are not connected            to it's previous node.r=NULL then r(struct node *)malloc(sizeof(struct node)); it will not link to the previous node .          */     }      r->data=b;     r->link=NULL;      }  display(struct node *q) {     while(q!=NULL)     {      printf(\"%d-> \",q->data);      q=q->link;     } } swap(struct node *fast,int k,int n) {     struct node *Kth_fast,*Kth_last;     int temp;     if(k>n)        printf(\"Swaping is not possible you enter the number greater than number of element of linklist\\n\");     else     {        Kth_fast=recursion(fast,k);        Kth_last=recursion(fast,n-k+1);     }     temp=Kth_last->data;     Kth_last->data=Kth_fast->data;     Kth_fast->data=temp;   } struct node *recursion(struct node *p,int K) {     int i=1;     while(i++    {       p=p->link;     }      return p; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Complexity: O(n) Space: O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Complexity: O(n) Space: O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapKth(Node *head,int k) \n{ \n  int counter=0; \n  Node *kth=head,*kth_end=head; \n  while(kth && counter++next; \n  if(!kth) return false; \n  counter=0; \n  while(counter ++next; \n  while(head) {head=head->next;kth_end=kth_end->next;} \n  swap(kth->data,kth_end->data); \n  return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapKth(Node *head,int k) \n{ \n  int counter=0; \n  Node *kth=head,*kth_end=head; \n  while(kth && counter++next; \n  if(!kth) return false; \n  counter=0; \n  while(counter ++next; \n  while(head) {head=head->next;kth_end=kth_end->next;} \n  swap(kth->data,kth_end->data); \n  return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapKth(Node *head,int k) \n{ \n  int counter=0; \n  Node *kth=head,*kth_end=head; \n  while(kth && counter++next; \n  if(!kth) return false; \n  counter=0; \n  while(counter ++next; \n  while(head) {head=head->next;kth_end=kth_end->next;} \n  swap(kth->data,kth_end->data); \n  return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapKth(Node *head,int k) \n{ \n  int counter=0; \n  Node *kth=head,*kth_end=head; \n  while(kth && counter++next; \n  if(!kth) return false; \n  counter=0; \n  while(counter ++next; \n  while(head) {head=head->next;kth_end=kth_end->next;} \n  swap(kth->data,kth_end->data); \n  return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapKth(Node *head,int k) \n{ \n  int counter=0; \n  Node *kth=head,*kth_end=head; \n  while(kth && counter++next; \n  if(!kth) return false; \n  counter=0; \n  while(counter ++next; \n  while(head) {head=head->next;kth_end=kth_end->next;} \n  swap(kth->data,kth_end->data); \n  return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapKth(Node *head,int k) \n{ \n  int counter=0; \n  Node *kth=head,*kth_end=head; \n  while(kth && counter++next; \n  if(!kth) return false; \n  counter=0; \n  while(counter ++next; \n  while(head) {head=head->next;kth_end=kth_end->next;} \n  swap(kth->data,kth_end->data); \n  return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"you can just reverse the value."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if (indexToBeSwapped < 0 || indexToBeSwapped > inputList.Count - 1)                 return;             int indexFromLast = inputList.Count - indexToBeSwapped;             int temp = inputList[indexToBeSwapped];             inputList[indexToBeSwapped] = inputList[indexFromLast];             inputList[indexFromLast] = temp;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There is no need to swap the node. Just swap the value. That's it,"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapList(Node* head, int k) {     int count = 0;     Node *p1, *p2, *end;     p1 = p2 = end = head;      while (count < k-1)     {         if (0 != end->next)         {             end = end->next;             count++;         }         else         {             return false;         }     }      p1 = end; // fix the first pointer      while (0 != end->next)     {         end = end->next;         p2 = p2->next;     }// fix the position of second pointer      // swap the data values in the two pointer p1 and p2     p1->data = p1->data + p2->data;     p2->data = p1->data - p2->data;     p1->data = p1->data - p2->data;      p1 = p2 = end = 0;     return true; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool swapList(Node* head, int k) \n{ \n    int count = 0; \n    Node *p1, *p2, *end; \n    p1 = p2 = end = head; \n \n    while (count < k-1) \n    { \n        if (0 != end->next) \n        { \n            end = end->next; \n            count++; \n        } \n        else \n        { \n            return false; \n        } \n    } \n \n    p1 = end; // fix the first pointer \n \n    while (0 != end->next) \n    { \n        end = end->next; \n        p2 = p2->next; \n    }// fix the position of second pointer \n \n    // swap the data values in the two pointer p1 and p2 \n    p1->data = p1->data + p2->data; \n    p2->data = p1->data - p2->data; \n    p1->data = p1->data - p2->data; \n \n    p1 = p2 = end = 0; \n    return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have written and tested the following code ... its working"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hi guys , below is the code with 2 pointers..difference between pointers is k... slow  pointer is behind k positions of fast pointers.  There is a check before getting the k(th) element from the first and k(th) element from the last..which you can see in the following loop:           for( i = 1; i< k; i++){    fast = fast.getNext();    if(fast == null){     System.out.println(\"List is of size:: \" + i + \"  which is lesser then::\" + k);     return;    }   }     Please find the code below , this is a method in a linked list class, which access the head of the list using this.getHead() method.  and swaps the values in the last..  public void replaceKthCharacter(int k){      Node  kthElementFromStart,slow , fast;   slow =  fast = this.getHEAD();      if(slow == null || fast == null){    System.out.println(\"List is empty..\");    return;   }      int i;      for( i = 1; i< k; i++){    fast = fast.getNext();    if(fast == null){     System.out.println(\"List is of size:: \" + i + \"  which is lesser then::\" + k);     return;    }   }       kthElementFromStart = fast ;      while(fast != null && fast.getNext() != null){    fast = fast.getNext();    slow = slow.getNext();   }      String tmpKey = kthElementFromStart.getKey();   kthElementFromStart.setKey(slow.getKey());   slow.setKey(tmpKey);        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Its Easy, please do as explained below.  1.take 2 pinters say ptr1 and ptr2 and assign the root node address. 2.Move the ptr2 for the k times,this the pointer you have to swap keep the address with you. 3.Now move the both the pointer ptr1 and ptr2 both at time, the moment ptr2 reach to null, note down the ptr1. 4.swap the ptr1 and once node which you have restored before.  complexity is O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nstruct node \n{ \n    int info; \n    struct node *link; \n}; \nstruct node *create(struct node *start, int data); \nvoid exchange(struct node *start, int k); \nvoid display(struct node *start); \n \nint main() \n{ \n  int data,ans,k; \n  struct node *start=NULL; \n  do \n  { \n       cout<<\"Enter the value\"<>data; \n         start=create(start,data); \n         cout<<\"do you want to add another node?\"<>ans; \n    }while(ans==1); \n    display(start); \n    cout<<\"enter the position\"; \n    cin>>k; \n    exchange(start,k); \n    display(start); \n  getch(); \n  return 0; \n} \n \nvoid exchange(struct node *start, int k) \n{ \n   int count=0,s,i; \n   struct node *p,*q,*p1,*q1,*temp; \n   p=start; \n   q=p; \n   while(p!=NULL) \n   { \n          count++; \n          p=p->link; \n     } \n     try \n     { \n       if(k>count) \n         throw k; \n     //cout<<<<\" is the count\"<link; \n     } \n     s=count-k; \n     for(i=0;ilink; \n     } \n     if(p==q1) \n     { \n     int swap; \n     swap=p->info; \n     p->info=q->info; \n     q->info=swap; \n     return; \n     } \n     temp=q->link; \n     p1->link=q; \n     q->link=p->link; \n     q1->link=p; \n     p->link=temp; \n      \n     } \n     catch(int) \n     { \n     cout<<\"out of bounds\"<info=data; \n          start->link=NULL; \n          return start; \n  } \n  while(p->link!=NULL) \n  { \n          p=p->link; \n     } \n     temp=new node; \n     temp->info=data; \n     temp->link=NULL; \n     p->link=temp; \n     return start; \n} \n \nvoid display(struct node *start) \n{ \n   struct node *p=start; \n   while(p!=NULL) \n   { \n   cout<info; \n   if(p->link!=NULL) \n     cout<<\"->\"; \n   p=p->link; \n     } \n     cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"swapKthNode(node *head){ \n    temp=head \n    while(k!=1){ \n        if (head == NULL) return \"ERROR\"; \n        head = head->next; \n        k--; \n    } \n    first_node=head; \n    while(head->next!=NULL){ \n        head = head->next; \n        temp = temp->next; \n    } \n    second_node = temp; \n    swap(first_node->data, second_node->data) \n \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// (assuming k=0 means swap root and tail) \nNode* swapK (Node* head, int k) { \n \n Node* p1, p2, temp; \n int n = 1; \n  \n // no list, nothing to swap..  \n if (head == null || head->next = null) \n  return head; \n  \n // count length of list \n // optimized here to save time for k=0 below \n p1 = head; \n while(p1->next != null) { \n  p1 = p1->next; \n  n++; \n } \n  \n // negative values of k and k greater \n // then length of list are not valid \n if (k < 0 || k > n) \n  return NULL; // should actually throw error here \n \n // normalize k \n if (k > n/2) \n  k = n-k; \n   \n // special case if k=0 or k=n \n if (k == 0) { \n  // set p1 = 2nd to last node \n  p1 = head; \n  for (int i = 1; i < n-1; i++) \n   p1 = p1->next; \n  // set p2 = last node \n  p2 = p1->next; \n   \n  // set last node to point to 2nd node \n  p2->next = head->next; \n  // set 2nd to last node to point to head \n  p1->next = head; \n  // set head to point to nothing (it is now the last node) \n  head->next = null; \n   \n  // return the new head (p2) \n  return p2; \n } \n   \n // set p1 to (k-1)th node \n p1 = head; \n for (int i = 1; i < k; i++) { \n  p1 = p1->next; \n } \n // set p2 to (n-k-1)th node \n p2 = p1->next; \n for (int i = k; i < n-2k; i++) { \n  p2 = p2->next; \n } \n  \n // swap p1's next and p2's next \n temp = p1->next; \n p1->next = p2->next; \n p2->next = p1->next; \n // swap p1 next's next and p2 next's next \n temp = p1->next->next; \n p1->next->next = p2->next->next; \n p2->next->next = p1->next->next; \n  \n return head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void fn(node * start) \n  { \n     if(K>N)// if n given else traverse inO(n) to find the length \n       printf(\"ARRAY IS OF LESSER  SIZE\") \n    else \n   { \n        int traverse=0,count=0; \n        if(K>N-K) \n          traverse=N-K; \n       else traverse=K; \n      node * one ,*two; \n      one=start; \n      while(count++!=traverse) \n         one=one->next; \n      two=one; \n     traverse=abs(2*K-N) \n     count=0 \n     while(count++!=traverse)two=two->next \n     swap(one->data,two->data); \n     } \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void move_the_node(struct link_list **node, int mov) {         struct link_list *start_ptr, *end_ptr, *length_ptr;         int i=0,j;         if((*node)->next == NULL)         printf(\"No swapping..since list is empty\\n\");         else         {                 length_ptr = (*node);                 while(length_ptr)                 {                         i++;                         length_ptr = length_ptr->next;                 }                 if(i <= mov)                 printf(\"Cant swap..since no enough nodes\\n\");                 else{                 end_ptr = start_ptr = (*node);                 for(j=0; j                start_ptr = start_ptr->next;                 for(j=0; j<(i-mov-1); j++)                 end_ptr = end_ptr->next;                 i = end_ptr->data;                 end_ptr->data = start_ptr->data;                 start_ptr->data = i;                 }         } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"don't u think the question is too easy.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void swapListNodes(int swapPosition)             {                 Node advPointer = first;                 Node normalPointer = first;                 Node tempNode = first;                 Node iterator = first;                 int tempdata = 0;                 int loop = 1;                  if (swapPosition > count) return;                                while (loop < swapPosition)                 {                     if (iterator.next != null)                     {                         advPointer = iterator.next;                         iterator = iterator.next;                         loop++;                     }                 }                  tempNode = advPointer;  // at 3rd position from start                  while (advPointer.next != null)                 {                     advPointer = advPointer.next;                     normalPointer = normalPointer.next;                 }                                   tempdata = normalPointer.data;                 normalPointer.data = tempNode.data;                 tempNode.data = tempdata;             }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void swapkelement(struct list **l,int k) { struct list *x = *l; struct list *y; struct list *z = *l; int i; for(i=0 ; i < k  ; i++) { if(x == NULL) {  printf(\"LIST IS OF LESSER SIZE\");  return; } if(i == k-1) y = x; x = x->next; }  while(NULL != x) { z = z->next; x = x->next; }  i = y->data; y->data = z->data; z->data = i; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hey guys pls let me know if this is correct solution.....  void swap(nd *start,int val) { nd *temp; int count=0,j,i=0;  temp=start; while(temp->next!=NULL) { temp=temp->next; count++; } if(count>val) { j=0; temp=start; i=count-val; while(j++<=i) { temp=temp->next; } //p(\"from last %d\\n\",temp->data); count=0; while(count++{ start=start->next; } //p(\"from beg %d\\n\",start->data); //if(start->next==temp)                    //if both elements are adjacent to each other.... //{ int var; var=start->data; start->data=temp->data; temp->data=var; //p(\"list changed...\\n\");  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nint k,t1,t2; \nint x; \nvoid insert1(); \nvoid swap1(); \nvoid swap(); \nstruct Node1 \n{ \n int info1; \n Node1 *next1; \n}; \nNode1 *ptr1,*start1=NULL,*rear1,*save1; \nmain() \n{ \n cout<<\"How many nodes in list\\n\"; \n  \n cin>>x; \n for(int i=0;i>k; \n swap1(); \n //swap(); \n} \nvoid insert1() \n{ \n ptr1=new Node1; \n  \n if(start1==NULL) \n { \n  cout<<\"Enter info\\n\"; \n        cin>>ptr1->info1; \n  start1=ptr1; \n  ptr1->next1=NULL; \n  rear1=ptr1; \n } \n else \n { \n  cout<<\"Enter info\\n\"; \n        cin>>ptr1->info1; \n  rear1->next1=ptr1; \n  ptr1->next1=NULL; \n  rear1=ptr1; \n } \n} \nvoid swap1() \n{ \n int cnt=0; \n save1=start1; \n while(save1) \n { \n  cnt=cnt+1; \n  cout<<\"\\n\"<<\"COUNT HERE\\n\"; \n  cout<<\"\\n\"<info1; \n   \n  } \n   //save1=save1->next1; \n  if(cnt==(x-k) ) \n  { \n   t2=save1->info1; \n    \n  } \n  save1=save1->next1; \n   \n } \n int temp; \n temp=t1; \n t1=t2; \n t2=temp; \n cout<<\"VALUES INTERCHANGED\\n\\n\\n\"<<<\"\\t\"<info1; \n while(save1) \n { \n  save1=save1->next1; \n  cout<<\"\\n\"<info1; \n } \n} \nvoid swap() \n{ \n  \n}*/ \n      \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void swapindex(list L,int index){ List lst=new LinkedList(L); swap(lst,lst.get(index),lst.get(lst.size()-index)); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The running time is O(N) and hardly any space complexity .. the only trick here is to maintain the height of the node in the node object and the length of the linked list in the linkedlist instance   Here is the python implementation"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I simply did this by getting the two nodes from the get node function and then swapped the two. i got the answer correctly.   public LinkedListNode getNode(int index){   String str;   LinkedListNode prevnode = first.getNext();   for(int i=0;i   prevnode = prevnode.getNext();  // reaching the index node.   }   return prevnode;  }    // Swapping the Kth node from first and last alike.  public void specialSwap(int index){   LinkedListNode frontnode = first.getNext();   LinkedListNode lastnode = first.getNext();   frontnode = getNode(index);    // obtain the first node   lastnode = getNode(size()-index+1);  // obtain the last node      // Swap the Nodes values. no need  of breaking the nodes.   String temp = frontnode.getName();   frontnode.setName(lastnode.getName());   lastnode.setName(temp);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nusing namespace std; \n \nstruct node{ \n int data; \n node *next; \n}; \n \nint main() \n{ \n  \n node *list,*nptr,*tptr; \n int item,n,i; \n list=NULL; \n  \n cout<<\"PLEASE.......Type how many nodes that you want    \"; \n cin>>n; \n for(i=1;i<=n;i++) \n { \n  cout<<\"Type your \"<<<\" node item  \"; \n  cin>>item; \n  nptr=new(node); \n  nptr->data=item; \n  nptr->next=NULL; \n  if(list==NULL) \n  { \n   list=nptr; \n   tptr=nptr; \n  } \n  else \n  { \n   tptr->next=nptr; \n   tptr=nptr; \n  } \n } \n tptr=list; \n for(i=1;i<=n;i++) \n { \n   \n  cout<data<<\"    \"; \n  tptr=tptr->next; \n   \n } \n cout<<>k; \n tptr=list; \n first=k-1; \n last=(n-k); \n int mid=(n-k+2); \n node *pptr,*sptr,*wptr=NULL,*temp2=NULL,*temp1=NULL; \n int count=1; \n tptr=list; \n for(i=1;i<=n;i++) \n { \n   \n  if(count==first) \n  { \n   pptr=tptr; \n   temp2=pptr->next; \n  } \n  else if(count==last) \n  { \n   sptr=tptr; \n   temp1=sptr->next; \n    \n  } \n  else if(count==mid) \n  { \n   wptr=tptr; \n    \n  } \n  tptr=tptr->next; \n  count++; \n   \n   \n } \n int d; \n d=(n/2); \n if(d!=k) \n { \n   \n  temp1->next=pptr->next->next; \n   \n   \n  pptr->next=temp1; \n   \n   \n   \n  sptr->next=temp2; \n   \n   \n  temp2->next=wptr; \n } \n  \n else  \n { \n  pptr->next=temp1; \n  temp1->next=sptr; \n  sptr->next=wptr; \n } \n  \n  \n int g; \n  \n for(g=1;g<=n;g++) \n { \n  cout<data<<\"   \"; \n  tptr=tptr->next; \n   \n } \n  \n    cout<<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void mainwork() \n { \n//initialise to start. \n//count is the length of link list \n//n is the position at which swap needs to be made. \n temp=p; \n int count=0; \n while(temp!=NULL) \n { \n count++; \n temp=temp->link; \n } \n int n=4; \n prev=p; \n curr=prev->link; \n next=curr->link; \n for(int i=0;ilink; \n  curr=curr->link; \n  next=next->link; \n } \n prev1=p; \n curr1=prev1->link; \n next1=curr1->link; \n for(i=0;ilink; \n  curr1=curr1->link; \n  next1=next1->link; \n } \n //cout<<\"\\n\"<data<<\",\"<data; \n \n if(nlink=curr1; \n curr1->link=next; \n prev1->link=curr; \n curr->link=next1; \n } \nelse \n{ \n \ncout<<\"Cant perform this operation\"; \n \n} \n \n \n \n \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n \nstruct node { \n int data; \n struct node *link; \n}; \n \nint append(struct node **q,int num) { \n struct node *temp, *r; \n temp = *q; \n if(temp == NULL) { \n  temp = (struct node *) malloc(sizeof(struct node)); \n  temp->data = num; \n  temp->link = NULL; \n  *q = temp; \n  return 0; \n } \n while(temp->link != NULL) \n  temp = temp->link; \n r = (struct node *) malloc(sizeof(struct node)); \n r->data = num; \n temp->link = r; \n return 0; \n} \n \nint display(struct node *q) { \n struct node *temp = q; \n while(temp != NULL) { \n  printf(\"data = %d\\n\",temp->data); \n  temp = temp->link; \n } \n return 0; \n} \n \nint sizeofl(struct node *temp) { \n int count = 0; \n struct node *temp1 = temp; \n while(temp1 != NULL) { \n  count++; \n  temp1 = temp1->link; \n } \n return count; \n} \n \nint swap_list(struct node **q,int position) { \n struct node *temp = *q, *ptr1 = *q,*ptr2 = *q; \n int size_list,i,temp_data = 0; \n size_list = sizeofl(temp); \n printf(\"count = %d\\n\",size_list); \n for(i=1; ilink; \n printf(\"ptr1 data = %d\\n\",ptr1->data); \n for(i=0;ilink; \n printf(\"ptr1 data = %d\\n\",ptr2->data); \n temp_data = ptr1->data; \n ptr1->data = ptr2->data; \n ptr2->data = temp_data; \n return 0; \n} \n \nint main() \n{ \n struct node *k = NULL; \n append(&k,1); \n append(&k,2); \n append(&k,3); \n append(&k,4); \n append(&k,5); \n append(&k,6); \n append(&k,7); \n append(&k,8); \n append(&k,9); \n display(k); \n swap_list(&k,3); \n display(k); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void swap(struct node *node1,struct node *node2) {     if(node1 == NULL || node2 == NULL)     {       cout<<\"LIST IS OF LESSER SIZE\"<      return;     }     int temp_data = 0;     temp_data = node1->data;     node1->data = node2->data;     node2->data = temp_data;     struct node *temp = start;     while(temp->next != NULL)     {        cout<data<<\"->\";        temp = temp->next;     }     cout<data<}  void trav_swap(int K) {     int curr = 1;      struct node *temp = start;     struct node * node1 = NULL, *node2 = NULL;     if(K == 0)     {       cout<<\"INVALID INPUT\"<      return;     }     while(temp != NULL && curr != K)     {                temp = temp->next;                curr++;     }     if(curr == K)     {         node1 = temp;         node2 = start;         while(temp->next != NULL)         {            temp = temp->next;            node2 = node2->next;         }     }     swap(node1,node2);      }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void swap(struct node *node1,struct node *node2) \n{ \n    if(node1 == NULL || node2 == NULL) \n    { \n      cout<<\"LIST IS OF LESSER SIZE\"<data; \n    node1->data = node2->data; \n    node2->data = temp_data; \n    struct node *temp = start; \n    while(temp->next != NULL) \n    { \n       cout<data<<\"->\"; \n       temp = temp->next; \n    } \n    cout<data<next; \n               curr++; \n    } \n    if(curr == K) \n    { \n        node1 = temp; \n        node2 = start; \n        while(temp->next != NULL) \n        { \n           temp = temp->next; \n           node2 = node2->next; \n        } \n    } \n    swap(node1,node2); \n     \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use double linked list & two pointers,one from first till our k value and another from last till our k value then exchange the values"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"check skillgun.com for free online tests with java interview questions"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Algorithm: 1.Get the linked list lenghth. If it is less than 'K' print the error message. O(N) 2.Traverse to the 'K' the element from the beginning. O(N) 3.Traverse to the N-Kth element from the beginning. O(N) 4. Swap them.O(1) 5.End of Algorithm  Complexity: O(N)."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=7578666","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"80","title":"1. How to find whether two link-lists intersect each other or not? If yes find intersection point.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"Consider two linked lists L1 and L2 1) Go through L1 and get its length l1 2) Go through L2 and get its length l2 3) Now find the difference d = l1-l2 4) So d is the number of nodes that are extra in longer list. 5) Traverse longer list till 'd' ..keep a pointer at this point 6) Now the length of longer list( That pointer) is equal to length of smaller list from front. 7) Now just traverse the the two list sequentially and compare every Node   Complexity O(n).."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"These are the following steps:- 1)traverse the first list and reach at the end 2)link the end of first list to the head of second list 3) retain the pointers at the head of both list,also at the end of 1st list 4) problem becomes a->b->c->d->e->f->g->h->e loop in a linked list and now we have to find the start of loop 5)take two pointers move 1st by one node,second by  two  6) when they meet after that take back the 1st to head 7)now move both pointers 1st and second also by one node(from the meeting point) 8)where they meet is the intersection of both list 9)break the link from last of 1st list to head of second"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"int check( struct node * list1,struct node * list2) {  int count1 = countLL(list1);  int count2 = countLL(list2);   while(count1> count2)  {   list1 = list1->next;   count1--;   }  while(count2>count1)  {   list2 = list2->next;   count2--;  }   while(list1 ! = list2)  {   list1 = list1->next;   list2 = list2->next;  }  if(list1== null)  {   return 0;/ do not intersect  }  else   return 1; //it intersects   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Another approach : 1. point the last of 1st list to begining of second list. 2. Check if cycle is present (using fast and slow pointer). 3. If cycle is present then these two list merge at some point. 4. to Find the merging point, take two pointers one at the start of 1st list and another at the node where fast and slow pointers meet. 5. increment these two pointers by one each. 6. the node where they meet will be the merging point of two list.  Thanks"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Algo: - Find lengths of lists with two given heads.  Let us say they are m, n. - Have two pointers each pointing to given head pointers - Find abs(m - n), and skip abs(m - n) nodes in the long list - Compare both pointers. If they match, return. Otherwise, move both pointers by one step.  Repeat this step till the lists end  Logic: - Maximum length of common list < minimum of lengths of linked lists -- Case - 1: One is a sub-list of the other -- Case - 2: Both lists are same - That means big list length - small list length nodes can safely be skipped for comparison  Space Complexity : O(1) Time Complexity: O(m + n)  Thanks, Laxmi"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if the address of tail nodes in both linked lists are equal then the linked lists intersect.  to find the intersection..increment a pointer from head of the longer list by L1-L2...where L1 and L2 are lengths of longer and shorter lists. The pointer on L2 starts from its head. Now keep incrementing the pointers of both L1 and L2 till they intersect."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Nope intersection in de shape of X is not possible coz if it has to occur de middle node should have 2 next pointers n v's sol is rite"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Nope intersection in de shape of X is not possible coz if it has to occur de middle node should have 2 next pointers n v's sol is rite"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"intersection of two single link-list always be in Y shape, X shape is not possible in any case."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Cudos to M.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void check(struct node *list1, struct node *list2) {  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void check(struct node *list1, struct node *list2) {  struct node *temp1, *temp2;  temp1=list1->start;  while(temp1!=NULL  {  }  ) }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void check(struct node *list1, struct node *list2) {  struct node *temp1, *temp2;  temp1=list1->start;  while(temp1!=NULL  {    temp2=list2->start;    while(temp2!=NULL)    {      if(temp1==temp2)      {       printf(\"Intersection found!\");    //at temp1 or temp2       break;      }      temp2=temp2->next;    }      temp1=temp1->next;  } ) }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If two linked lists meet then they should end at the same NULL node (or last node). Traverse both lists and if they both end at the same NULL node (or if the last node is same for both), they meet"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Y list problem. 1. Traverse both the list and count nodes. 2. Traverse the bigger one as many nodes as the difference between two. 3. Now traverse both the list simultaneously and keep on checking if both the pointers are pointing to same node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If we have authority to change the linklist  node structure,i'll makrk each visited node of 1st list.  now i'll start traversing on 2nd list & when i'll get marked node then i'll get merging point."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"while(list1 != null && list2 != null ) {   if(list1 == list2)     return true;   else    {      list1=list1->next;      if(list1==list2)       return true;      else        list2=list2->next;    } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Thanks Paras for your reply But I have one question  if the two linked lists meet, the meeting node will have two next pointers pointing to both the linked lists, so while travering in the cycle, how the next pointer will be progressed? I mean towards which linked list?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Assume list 2 to be shorter list, list 1 to be longer one  2)  loop x from head:list1 to NULL     loop y from head:list2 to NULL       if ( x == y )          intersection = x;          return;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Finding out if they merge is easy, start with 2 pointers and keep iterating until next pointer is null. If the 2 poiters are now equal, then lists merge. Basically if the last elemet of the 2 lists is the same node, they converge, otherwise not.  now finding out where they merge - can we use a hash and add nodes from first list, then from second list. First node where we hit exception is the one where lists merge, since that will be the first common node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use hashmap then store element addresses, if key is exists then it is merge point."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using a hashmap to store the addresses of the list elements is working but if the lists are huge this table will be huge.  If memory is the bottleneck and you are willing to pay for time you could do this: Get the address of the first list item in list-A and search for it in list-B. If found -> bingo. If not get the next item in list-A and repeat. If you cannot find any of the addresses of the items in list-A -> they never merge. (And it does not matter which list you use as list-A and -B)  Actually they always merge in NULL aka the empty list :) but I am not sure all interviewers will love this answer although an empty list is a very nice list and he/she might not like if you ignore this special case on another problem ;)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just compare tails of each list. If they become equal then they merge.  To find out where do they actually meet we can do the reverse traverse till the node is in both list. Thus we get the node where the lists meet."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Consider two linked lists L1 and L2 1) Go through L1 and get its length l1 2) Go through L2 and get its length l2 3) Now find the difference d = l1-l2 4) So d is the number of nodes that are extra in longer list. 5) Traverse longer list till 'd' ..keep a pointer at this point 6) Now the length of longer list( That pointer) is equal to length of smaller list from front. 7) Now just traverse the the two list sequentially and compare every Node"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"given these two lists: 1->2->3->4->5->6->7 and a->b->6->c->d, then the intersection point would be 6 right? If that's the case, then you can find that point with a hash table and the complexity would be O(n+m) (the number of nodes in both lists)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// junk.cpp : Defines the entry point for the console application. //  #include \"stdafx.h\" #include  #include    struct node  {  int data;  struct node *next; };  struct node * insert(struct node *, int ); void  insertintersection(struct node *,struct node *, int ); void display(struct node *); int intersection(struct node *,struct node *);   void main() {  struct node *head1,*head2,*top;     int x=0,p=0;  head1=NULL;  head2=NULL;  //1st list    head1=insert(head1,10);  head1=insert(head1,20);  head1=insert(head1,30);  head1=insert(head1,40);  head1=insert(head1,50);  head1=insert(head1,60);  head1=insert(head1,70);  head1=insert(head1,80);  head1=insert(head1,90);  head1=insert(head1,100);  printf(\"1st list is :=>\\n\");  display(head1);  // 2nd list    head2=insert(head2,1000);  head2=insert(head2,2000);  head2=insert(head2,4000);  head2=insert(head2,5000);  head2=insert(head2,200);  head2=insert(head2,300);  head2=insert(head2,800);  insertintersection(head1,head2,700);      printf(\"\\n2nd list is :=>\\n\");  display(head2);   p=intersection(head1,head2);  printf(\"\\nintersection point is ==>%d\",p); }  int intersection(struct node *t,struct node *r) {    struct node *temp1,*temp2;    int count1=0,count2=0,diff=0;         temp1=t;     temp2=r;    while(temp1)    {     temp1=temp1->next;     count1++;    }     while(temp2)    {     temp2=temp2->next;     count2++;    }     diff=count2-count1;        for(;diff>0;diff--)     r=r->next;      while(t->data!=r->data)    {     t=t->next;        r=r->next;    }    return (t->data); }     struct node * insert(struct node *t,int m) {  struct node *temp,*r;    temp=(struct node *)malloc(sizeof(struct node));  temp->data=m;  temp->next=NULL;   if(t==NULL)  {         t=temp;  }  else  {   r=t;   while(r->next!=NULL)   {    r=r->next;   }   r->next=temp;  }  return t; }  void insertintersection(struct node *t,struct node*s,int m) {     struct node *temp,*r;    temp=(struct node *)malloc(sizeof(struct node));  temp->data=m;  temp->next=NULL;    while(t->data!=40)    t=t->next;   while(s->next !=NULL)    s=s->next;   s->next=temp;   temp->next=t;    return;  }   void display(struct node *t) {  struct node *p;  p=t;  while(p)  {   printf(\"%d->\",p->data);   p=p->next;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// junk.cpp : Defines the entry point for the console application. //  #include \"stdafx.h\" #include  #include    struct node  {  int data;  struct node *next; };  struct node * insert(struct node *, int ); void  insertintersection(struct node *,struct node *, int ); void display(struct node *); int intersection(struct node *,struct node *);   void main() {  struct node *head1,*head2,*top;     int x=0,p=0;  head1=NULL;  head2=NULL;  //1st list    head1=insert(head1,10);  head1=insert(head1,20);  head1=insert(head1,30);  head1=insert(head1,40);  head1=insert(head1,50);  head1=insert(head1,60);  head1=insert(head1,70);  head1=insert(head1,80);  head1=insert(head1,90);  head1=insert(head1,100);  printf(\"1st list is :=>\\n\");  display(head1);  // 2nd list    head2=insert(head2,1000);  head2=insert(head2,2000);  head2=insert(head2,4000);  head2=insert(head2,5000);  head2=insert(head2,200);  head2=insert(head2,300);  head2=insert(head2,800);  insertintersection(head1,head2,700);      printf(\"\\n2nd list is :=>\\n\");  display(head2);   p=intersection(head1,head2);  printf(\"\\nintersection point is ==>%d\",p); }  int intersection(struct node *t,struct node *r) {    struct node *temp1,*temp2;    int count1=0,count2=0,diff=0;         temp1=t;     temp2=r;    while(temp1)    {     temp1=temp1->next;     count1++;    }     while(temp2)    {     temp2=temp2->next;     count2++;    }     diff=count2-count1;        for(;diff>0;diff--)     r=r->next;      while(t->data!=r->data)    {     t=t->next;        r=r->next;    }    return (t->data); }     struct node * insert(struct node *t,int m) {  struct node *temp,*r;    temp=(struct node *)malloc(sizeof(struct node));  temp->data=m;  temp->next=NULL;   if(t==NULL)  {         t=temp;  }  else  {   r=t;   while(r->next!=NULL)   {    r=r->next;   }   r->next=temp;  }  return t; }  void insertintersection(struct node *t,struct node*s,int m) {     struct node *temp,*r;    temp=(struct node *)malloc(sizeof(struct node));  temp->data=m;  temp->next=NULL;    while(t->data!=40)    t=t->next;   while(s->next !=NULL)    s=s->next;   s->next=temp;   temp->next=t;    return;  }   void display(struct node *t) {  struct node *p;  p=t;  while(p)  {   printf(\"%d->\",p->data);   p=p->next;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"(Using difference of node counts) 1) Get count of the nodes in first list, let count be c1. 2) Get count of the nodes in second list, let count be c2. 3) Get the difference of counts d = abs(c1 ??C c2) 4) Now traverse the bigger list from the first node till d nodes so that from here onwards both the lists have equal no of nodes. 5) Then we can traverse both the lists in parallel till we come across a common node. (Note that getting a common node is done by comparing the address of the nodes)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"One solution.. 1. Go to the end node of common list. 2. Make it point to the head of longer list.Loop will be created 3 Calculate the length of the loop 'x'. 4. Now take two iterator itr1 and itr2. Give head start of x to itr1. 5. Now move both the itrs toward head with same speed.whereever they meet that will be the intersection node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use 2 stacks to store nodes while traversing 2 linkedlists. Then keep popping until you find 2 nodes that are different."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sort the linklists and then it would be easy to find intersection."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"may be a crude/immature or an  engineering method  1) L1 = length( list1); 2) L2 = length( list2);  now reverse any of the list [ assume List-1 is reversed ] 3) now starting from head of List-2 find the length  = L3  intersection point Ie ( From the end )  =  ( L1+L2 - L3 )/2;  intersection point from the begining  of list 1 is (  L1- Ie)th node"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a Small correction in the above method  intersection point Ie ( From the end ) = ( L1+L2 - L3-1 )/2;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about Reverse(L1), Reverse(L2) and then check for a diverging node! Bad Idea??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"traverse linked list 1 traverse link list 2 simultaneously  until temp1->link==temp2->link; gives point of intersection"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"(1)take  2pointers initialize to head of the list (2)increment both pointer till they reach end of the list and calculate list length l1,l2 (3) calculate absolute difference between l1-l2 ie n=|l1-l2| (4) calculate nth element from end of the list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I could only think of using a hashtable"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"a binary search may be useful."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=10676884","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"82","title":"You have given a positive  number you have to find a number which is bigger than that by using same digits available in the number . Example :- You have given a number 7585 , your output should be 7855 .","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"The question need to be more specific. Does the interviewer wants the immediate greater number that can be formed or any greater number? for example if given 1234 then answer xan be 1243, 1324,1342 etc. the best way is to start with the right most digit and see if a digit on the left side is smaller than it and then switch their position."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"can be done in o(num_of_digit) time.@Anonymous :no need to sort the number to get the answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Resolve Ambiguity: Should each digit be used as many times as it appears in the number? Ex: In 7111,  should 7 be used only once and 1, only thrice? If yes, there's no bigger number for this scenario of 'XYYY' where X > Y. Can be handled as a special case.  Sounds like BIT Shifting problem. However, here's one solution runs in constant O(no.of.digits forming the number) == O(c) time: a) Divide no. by 10 and store each digit in array    eg: 7585 ->     - use a counter to count no of digits as you divide by 10, here 4    - again, store in array each digit with [index 0 == digit at unit place, index 1 ==  digit at 10th place etc] -> int[] digits = {5, 8, 5, 7} b) Find digits forming bigger no.    //code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how about  1. start from the right most digit ( ones position) 2. check if it is bigger than the immediate left..(tens position)           if yes then               swap them you got the answer            else               check the next left ( hundered postion)              if  10s is bigger than the 100s swap then you got the answer                 This might give the right answer because if 1s position is bigger than the 10s then swaping them would give the immediate next bigger number and if it is not then this method will make sure it is smaller than all the subsequent digits traversing from left to right.  eg. 79 ( swap 1s position and 10s)     ans 97  eg  7585     1s(5) < 10s(8) hence do not swap     10s(8)> 100s(5) hence swap      ans 7855  eg. 7439     swap (9,3) ans 7493 ( next bigger no)  Please tell me any counter example in which case it will not work ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"7264 -> ur algo will give 7624 but 7426 is also there.. u are only comparing the immediate ones.. but ones and hundreds can also be compared.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{{public static void main(String[] args) {          String str1 = \"12342342355555575753453453421\";          assert (str1 != null && str1.length() > 0);           int[] intArray = new int[str1.length()];          for (int i = 0; i < str1.length(); i++) {             intArray[i] = Character.digit(str1.charAt(i), 10);         }         determineNextHighest(intArray);          System.out.printf(\"Final Value =>\" + Arrays.toString(intArray));     }      public static void determineNextHighest(int[] array) {          int len = array.length - 1;         int index = 0;         int j = len;          for (; j > 0; j--) {       // iterate till n-1 < n and determine the index where swap happens             if ((array[j - 1] < array[j])) {                 index = j - 1;                 break;             }         }          if (index == 0) {      // no solution here.. for digits in descending order 7654321 etc..             return;         }          findImmediateGreaterAndSort(array, j - 1, len);      }      //    the next highest int to be swapped with     private static void findImmediateGreaterAndSort(int[] array, int i, int len) {         int noToSwap = array[i];         for (int j = len; j > i; j--) {             if (noToSwap < array[j]) {                 swap(array, i, j);   // swap                 break;             }         }          //  System.out.printf(\"1st Value =>\" + Arrays.toString(array));          //reverse found subarray .. the subarray from i + 1 to len is already in desc order. just reverseing will sort it in asc order         i = i + 1;         for (int x = 0; x <= (len - i) / 2; x++) {             swap(array, i + x, len - x);         }     }      private static void swap(int x[], int a, int b) {         int t = x[a];         x[a] = x[b];         x[b] = t;     }  }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Take the integer as string arg, decimals; scan right to left, compare sequentially (right to left) everything on the left with current, if current is larger - swap; ascending sort for the digits on the right side of the swap; otherwise make current the one to the left of the previous current, repeat."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i have written this code for this task. it take d two input number as a output it return least greater number and max lowest num."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can solve it in another way, hopefully it would work for all the cases. I am explaining using 2 examples: 1. 7684 - what is the next larger number - (ans : 7846)  Sort the numbers : 4 - a 6 - b 7 - c 8 - d  So, given number 7684 = cbda Next larger number : check \"d\" and \"a\", since d > a the swapping wouldn't help check : \"b\", \"d\" and \"a\"  For the 1st position - fill \"d\" as aFor all the rest nos. we just select the least, to make it as small as possible. For the 2nd position - \"a\" For the 3rd position - \"b\"  So, the answer is : cdab - Using the table shown above = 7846  Example 2 : 24965 - What is the next larger number (ans : 25469)  2 - a 4 - b 5 - c 6 - d 9 - e  24965 = abedc  Since d > c (swapping c to d not helpful) and (e > c and e > d - so swapping of \"c\", \"d\" and \"e\" is not helpful either), so lets take a look at next possibility : \"b\"\"e\"\"d\"\"c\"  Since b < c, it is definitely going to help find next larger number : so, swapping \"bedc\" to \"c???\" (for ? find the smallest of the remaining) to \"cb??\" to \"cbde\" gives us the answer :  acbde = 25469."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Look at what std::next_permutation does.  Also search the web for Narayana Pandita's algorithm (which is the same as std::next_permutation I believe)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"say the number is 9888 the next highest number will be what.. according to the question...since using the existing digits we cannot get next higest number..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For numbers like 9888, print -1.. I think Insertion Sort will work the best.  Letz take 126975 Start from the right and start inserting   Next number -> Sorted Array 5 -> 5 7 -> 57 9 -> 579 (Till now we were inserting only on one side i.e right side - No shifts were required)  6 -> Now we need shifts, instead what we will do is pop the number which is taking the 6's place i.e 7 and bring it to front. Place 6 at its position and we are done  Now we have 7569...Add digits in front which are not yet processed i.e 12  So, final ans will be 127569.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int getLargerNum(int dnum) {   int num[32];   int size = 31;   int cnum = dnum;   while (cnum && size)   {     num[size--] = cnum%10;     cnum /= 10;   }   for (int i = 31;i > size+1;i--)   {     if (num[i] > num[i-1])     {       for (int j = i;j < 31;j++)       {         if (num[j] < num[i] && num[j] > num[i-1])           swap(num+i,num+j);       }       swap(num+i,num+i-1);       for (int j = 31;j > i-1;j--)       {         for (int m = i;m < j;m++)         {           if (num[m] > num[m+1])             swap(num+m,num+m+1);         }       }       break;     }   }    int ret = 0;   for (int j = size+1;j < 32;j++)   {     ret = ret*10+num[j];   }   return ret; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using System; \nusing System.Collections.Generic; \nusing System.Text; \n \n \nnamespace Digits \n{ \n    class Program \n    { \n      \n       //Simply find the max of the digits starting from the second position.  \n       //So, if your number is 7585.  \n       //Split the number into digits {7,5,8,5} and find the maximum of the set  \n       //{5,8,5}. of course, it can be generalized to any number. \n \n        static void Main() \n        { \n            int num = 7585; \n            int[] digits = new int[4]; \n            int index = 4; \n            int maxIndex = 0; \n            int max = -1; \n \n            while (num != 0) \n            { \n                int rem = (num % 10); \n                num /= 10; \n \n                digits[--index] = rem; \n                if (index != 0 && rem > max) \n                { \n                    maxIndex = index; \n                    max = rem; \n                } \n            } \n \n            //Reconstruction \n            int newNum = digits[0]*10 + digits[maxIndex];  \n \n            for (int i = 1; i < digits.Length; i++) \n              if(i != maxIndex) \n                newNum = (newNum * 10) + digits[i]; \n \n \n            Console.WriteLine(newNum); \n \n             \n \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"go from right to left and add digits one by one. eg. let's say num is 76354- 5 > 4 so nothing can be done nd we have to go one more left. 3<5 and 3 < 4 so swap 3 with rightmost digit i.e. 4 and sort rest digits  rest of the left digits would be same.  so ans is -  76435"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Taking the example 7465  start from the right  Traverse till you find a digit bigger than the immediate left.( 4 is less than 6)  Exchange it with the next largest digits from the right of the array(since 5 is less than 6, exchange 4 with 5)  Now arrange the remaining digits in ascending order(46)  The number generated will be 7546"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is slightly modified version of cinderella. 1. Go from right to left till the current number is less than immediate left. (Store all the left numbers in array call leftArr and note they are already sorted.) 2. Find the number in leftArr thats immediate bigger than current number and swap with current number. Note that our new leftArr is still sorted. 3. starting to right of new current number, moving towards right end, replace all the numbers with leftArr in increasing order.  Step 2 will be order O(log(n)) so overall order will be O(nlog(n)).  I have yet to code it down. :) But i think it will work for any size."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Don't know if my code works for any case. It works so far. //Performance might be boosted by using quick sort instead of bubble sort. public class NextLarge {    public static void main(String[] args){      int[] data = {8,1,8,9,5,3,2};      int[] nextlarge = mynextlarge(data);      for(int i=0;i   System.out.print(String.valueOf(nextlarge[i])+' ');   }  }    public static int[] mynextlarge(int[] data){            int current = data.length-1;    while(true){    int pos = maxpos(data,current);    if(pos==current){     current--;    }else{     int tmp = data[current];     data[current] = data[pos];     data[pos] = tmp;     data = asendright(data,current);          break;    }    if(current<0)     break;    }    return data;  }    public static int[] asendright(int[] data,int current){   for(int i=current+1;i<=data.length-1;i++){    for(int j=i+1;j<=data.length-1;j++){     if(data[i]>data[j]){      int tmp = data[i];      data[i] = data[j];      data[j] = tmp;     }    }   }   return data;  }  public static int maxpos(int[] data,int current){      if(current == data.length-1){    return current;   }else{       int max = -9999;       int pos = current;       for(int i=current;i       if(data[i]>max){         max = data[i];         pos = i;        }       }        return pos;   }     }   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Following steps should lead to solution: 1. sort the nos  2. In the original no, starting from the 2nd right most position find a position where the no at a position has next higher value than the nos which are right of the no at that position.  3. Now swap the highest no which is found at the right side of that no with that no.  4. starting from the next right position start filling the positions with the nos such that the nos are not in left of the position found in step 2.  ex-  Given no is 24965  step 1. 24569  step 2. in the original no ie 24965, starting from 6 we check whether we have any value which is higher than it on its right.. no value found (since 5 is smaller than 6) next get the 9 and start checking to its right again no value higher than itself. next check 4, since we have next highest value on it right which is 5.  step 3: swap 4 and 5 so our valid no till now would be 25  step 4: Now chk the sort value found in step 1 fetch one value at a time...and append the values if they are not in the no found in the step 3.... so the no will become  25469  I hope this would be somewhat clear to you...here is a program for it ....let me know if it needs any corrections."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the simplest solution for this would be to simply extract the digits, store them in an array and sort it in descending order. If the array is already sorted, return -1 else return the sorted array. The question asks to find \"a\" number which is larger, not the immediately larger number. Can anyone tell me if there is a problem with this solution?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"However, if the immediately larger number is to be found.. I believe this solution should work:  1. Extract the numbers and save them in an array. 2. Starting from the right, start scanning the array such that you find a location where the array stops being sorted in an ascending order. ( asc from right ) 3. At that position, find the difference between all the digits and the digit in question. Swap it with the digit which has the smallest difference.  4. For all the digits to the right of the digits in question, sort them in descending order.  e.g. lets say 126975 starting from left, 75 is sorted, 975 is sorted, 6975 is not.  x = 6 6-5 = 1 6-7 = -1 6-9 = -3  Since smallest negative difference is with 7, swap the digits 6 and 7, we get.. 127965 Beginning from the right of 7, i.e. position x, sort all the digits in asc order, i.e. smallest first.. we get.. 127569."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include  void reverse(char s[]) {   printf(\"entring reverse\\n\");    int c, i, j;    for (i = 0, j = strlen(s)-1; i < j; i++, j--)    {      c = s[i];      s[i] = s[j];      s[j] = c;     } printf(\"exit reverse\\n\"); }  int atoi(char s[]) {    printf(\"entring atoi s=%s\\n\",s);    int i, n, sign;    for (i = 0; (s[i] == ' '); i++) /* skip white space */    ;    sign = (s[i] == '-') ? -1 : 1;    if (s[i] == '+' || s[i] == '-') /* skip sign */     i++;    for (n = 0; (s[i] >='0' && s[i] <= '9'); i++)      n = 10 * n + (s[i] - '0');    printf(\"exit atoi\\n\");    return sign * n; }  void itoa(int n , char s[]) {   printf(\"entring itoa\\n\");   int i, sign;   if ((sign = n) < 0) /* record sign */      n = -n; /* make n positive */   #include #include  void reverse(char s[]) {   printf(\"entring reverse\\n\");    int c, i, j;    for (i = 0, j = strlen(s)-1; i < j; i++, j--)    {      c = s[i];      s[i] = s[j];      s[j] = c;     } printf(\"exit reverse\\n\"); }  int atoi(char s[]) {    printf(\"entring atoi s=%s\\n\",s);    int i, n, sign;    for (i = 0; (s[i] == ' '); i++) /* skip white space */    ;    sign = (s[i] == '-') ? -1 : 1;    if (s[i] == '+' || s[i] == '-') /* skip sign */     i++;    for (n = 0; (s[i] >='0' && s[i] <= '9'); i++)      n = 10 * n + (s[i] - '0');    printf(\"exit atoi\\n\");    return sign * n; }  void itoa(int n , char s[]) {   printf(\"entring itoa\\n\");   int i, sign;   if ((sign = n) < 0) /* record sign */      n = -n; /* make n positive */    i = 0;   do   { /* generate digits in reverse order */     s[i++] = n % 10 + '0'; /* get next digit */   } while ((n /= 10) > 0); /* delete it */   if (sign < 0)   s[i++] = '-';   s[i] = '\\0';   reverse(s);   printf(\"exit itoa\\n\"); }  int find_bigger(int num) {   printf(\"inside find_bigger\\n\");   char str[20]= \"\\0\";      char temp;    int i,j;    itoa(num,str);    printf(\"str=%s\\n\",str);       i = strlen(str)-1;   j = strlen(str)-2;       while(j >= 0)    {       if(str[j] < str[i])       {          temp = str[j];          str[j] = str[i];          str[i] = temp;           break;       }       else       {          i--;          j--;       }    }  printf(\"returning from find_bigger\\n\");  return atoi(str); }  int main() {   int num;    num = find_bigger(4555);    printf(\"num = %d\\n\", num);    return 0;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am not sure if any body has already posted this solution: found = false;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sry for first example output : 8765"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sort the number"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just do selection sort, instead of calculating min at each iteration calculate max and replace with the first element."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class NextHighest \n{ \n public void sort(int[] num, int i, int length) \n { \n  // sorting algorithm \n } \n  \n public static void main(String[] args) \n { \n  int[] num = new int[]{7,5,8,6}; \n  int temp = num.length-1; \n  int i; \n  for(i=num.length-1;i>1;i--) \n  { \n   if(num[i] > num[i-1]) \n   { \n    int swap = num[i-1]; \n    num[i-1] = num[temp]; \n    num[temp] = swap; \n    break; \n   } \n   else \n   { \n    if(a[temp] > num[i]) \n     temp = i; \n   } \n  } \n  sort(num,i,num.length); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int FindNextGreater(int num) {  int previousDigit = -1;  int numOfDigits = NumOfDigits(num);  if(numOfDigits==1)   return -1;  int indexOfPreviousDigit = numOfDigits;  while(num>0)  {   int digit = num%10;   if(digit>previousDigit)   {     previousDigit = digit;    indexOfPreviousDigit--;    continue;   }   return Swap(num, indexOfPreviousDigit, indexOfPreviousDigit-1);  }  return -1; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.Start from right to left reading each digit 2.If the entire number is read in ascending order then return -1 3.Else stop when it is decreased, swap the decreased digit with the digit immediately bigger than the decreased digit from the set of surpassed digits 4. Sort the remaining digits to the right of the swapped digit  Ex: 1092 1.come from right, the digit decreased from 9 to 0 2. the surpassed digits are 2,9 so swap 0 with immediate bigger digit i.e, 2 (results in 1290) 3. sort remaining digits (1209)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"surely, neha you are the dumbest person i have ever witnessed posting on forums things that are so obvious. if it is true what you are saying, its a question even new born baby can solve!  if you dont understand question please get out of here (go join nursery school)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nusing namespace std; \nint main(){ \n    char str[1000]; \n    while(cin>>str){ \n                    if(!next_permutation(str,str+strlen(str))) \n                    cout<<\"-1\\n\"; \n                    else \n                    cout<<<\"\\n\"; \n                    } \n                    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can also use the linked list approach 1. Get the last digit from the no and add it to linked list in increasing order. 2. Convert it to no from the sorted linked list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorry guys the convertListNo(head) should be called outside the while loop in BiggestPossibleNo()."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Check code at : http: // ideone.com / fKenf"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//No need of any data structures int main() {    int n=9768;    int num=n;    int reverse=0;    int digit,right;    while(num){      digit=num%10;      num/=10;      right=0;      int p=1;      while(reverse && (reverse%10) < digit){               right=(reverse%10)*p+right;               p*=10;               reverse/=10;       }          reverse=(((reverse*10)+digit)*p)+right;    }    if(n!=reverse) cout<     cin.ignore(2);     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int findBigger(int input) \n{ \n   int dig = 0; \n   int digPre = 0; \n   int i = 0; \n   int temp = input; \n \n   if (temp <= 0) \n   { \n      return -1; \n   } \n \n   while (temp != 0) \n   { \n      digPre = dig; \n      dig = temp % 10; \n      temp = temp / 10; \n      if (dig < digPre) \n      { \n         break; \n      } \n      i++; \n   } \n \n   return input + 9 * 10^(i-1) * (digPre - dig); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int findBigger(int input) {    int dig = 0;    int digPre = 0;    int i = 0;    int temp = input;     if (temp <= 0)    {       return -1;    }     while (temp != 0)    {       digPre = dig;       dig = temp % 10;       temp = temp / 10;       if (dig < digPre)       {          break;       }       if (temp==0)       {          return -1;       }       i++;    }     return input + 9 * 10^(i-1) * (digPre - dig); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"time complexity: O(k^2) code works. int method(string s) {  vector v;  int i,j;  int flag=0;  for(i=s.size()-1;i>=0 && !flag;i--)   {   for(j=i-1;j>=0 ;j--)    if(s[j] < s[i])    {    flag=1;    cout<   break;    }   if(j<0)    v.push_back(s[i]-'0');       }  if(flag==1)  {   v.push_back(s[j]-'0');   s[j]=s[i+1];   sort(v.begin(),v.end());  for(int i=j+1,k=0;i  s[i]=v[k]+'0';  }  cout<}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class BiggestNumber {   int biggestNumber(int n) {   int originalNumber = n;   int[] digitFrequencies = new int[10];   boolean isNegative = n < 0;   if (isNegative) {    n *= -1;   }   while (n != 0) {    ++digitFrequencies[n % 10];    n /= 10;   }   n = 0;   if (isNegative) {    for (int i = 1; i < 10; ++i) {     while (digitFrequencies[i] != 0) {      n = n * 10 + i;      digitFrequencies[i] = digitFrequencies[i] - 1;     }     while (digitFrequencies[0] != 0) {      n *= 10;      digitFrequencies[0] = digitFrequencies[0] - 1;     }    }    n *= -1;   } else {    for (int i = 9; i > -1; --i) {     while (digitFrequencies[i] != 0) {      n = n * 10 + i;      digitFrequencies[i] = digitFrequencies[i] - 1;     }    }   }   return n == originalNumber ? -1 : n;  }   public static void main(String[] args) {   BiggestNumber instance = new BiggestNumber();   System.out.println(instance.biggestNumber(0));   System.out.println(instance.biggestNumber(1230));   System.out.println(instance.biggestNumber(-2130));   System.out.println(instance.biggestNumber(3210));   System.out.println(instance.biggestNumber(-1023));  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class BiggestNumber {   int biggestNumber(int n) {   int originalNumber = n;   int[] digitFrequencies = new int[10];   boolean isNegative = n < 0;   if (isNegative) {    n *= -1;   }   while (n != 0) {    ++digitFrequencies[n % 10];    n /= 10;   }   n = 0;   if (isNegative) {    boolean isZeroThere = digitFrequencies[0] != 0;    if(isZeroThere) {     for(int i = 1; i < 10; ++i) {      if(digitFrequencies[i] != 0) {       n = n * 10 + i;       digitFrequencies[i] = digitFrequencies[i] - 1;       break;      }     }     while (digitFrequencies[0] != 0) {      n *= 10;      digitFrequencies[0] = digitFrequencies[0] - 1;     }    }    for (int i = 1; i < 10; ++i) {     while (digitFrequencies[i] != 0) {      n = n * 10 + i;      digitFrequencies[i] = digitFrequencies[i] - 1;     }    }    n *= -1;   } else {    for (int i = 9; i > -1; --i) {     while (digitFrequencies[i] != 0) {      n = n * 10 + i;      digitFrequencies[i] = digitFrequencies[i] - 1;     }    }   }   return n == originalNumber ? -1 : n;  }   public static void main(String[] args) {   BiggestNumber instance = new BiggestNumber();   System.out.println(instance.biggestNumber(0));   System.out.println(instance.biggestNumber(1230));   System.out.println(instance.biggestNumber(-2130));   System.out.println(instance.biggestNumber(3210));   System.out.println(instance.biggestNumber(-1023));  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"some people think they are over smart. we are here to study so please behave like a student not like a rascal.   here is my java code. please check it and notify if there is any problem. all constructive comments are welcome."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int a; \n cin>>a; \n int b=a; \n \n int c[10]; \n \n for(int i=0;i<10;i++) \n  c[i]=0; \n \n int x=-1,y=-1; \n i=0;  \n \n while(b!=0) \n { \n  i++; \n  x=b%10; \n  c[x]++;  \n      b/=10; \n  if(y>x) \n   break; \n  y=x; \n } \n \n if(x==y) \n  cout<<\"No. is largest\"; \n else \n { \n \n for(int j=++x;j<10;j++) \n  if(c[j]>0) \n  { \n   b=b*10+j; \n   c[j]--; \n   i--; \n   break; \n  } \n \n int k=0; \n for(j=0;j0) \n  { \n   b=b*10+k; \n   c[k]--; \n   j++; \n  } \n  else \n   k++; \n } \n \n cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My approach:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Extract all d digits of a given,store it in an array sort d array in desc orer ."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=12718665","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"86","title":"String Reduction  Given a string consisting of a,b and c's, we can perform the following operation: Take any two adjacent distinct characters and replace it with the third character. For example, if 'a' and 'c' are adjacent, they can replaced with 'b'. What is the smallest string which can result by applying this operation repeatedly?  Input: The first line contains the number of test cases T. T test cases follow. Each case contains the string you start with.  Output: Output T lines, one for each test case containing the smallest length of the resultant string after applying the operations optimally.  Constraints: 1 <= T <= 100 The string will have at most 100 characters.  Sample Input: 3 cab bcab ccccc  Sample Output: 2 1 5  Explanation: For the first case, you can either get cab -> cc or cab -> bb, resulting in a string of length 2. For the second case, one optimal solution is: bcab -> aab -> ac -> b. No more operations can be applied and the resultant string has length 1. For the third case, no operations can be performed and so the answer is 5.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"19","title":"Count the number of occurences of each letter in the input string [numA, numB, numC]  If two of these counts are 0, then return string.length  Else if (all counts are even) or (all counts are odd), then return 2  Else, then return 1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"i think you shouldn't post  those skill tests.. those are not interview questions."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"none of them working correctly.  try for this input abccaccba  solution should be \"b\"  but they are giving wrong solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"none of them working correctly.  try for this input \"abccaccba\" solution should be \"b\" but they are showing wrong output"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"But, abc only reduces to 2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"must depend on how many 'a', 'b' and 'c' the input has; seems with equal number of 'a', 'b' and 'c' the min is 2, otherwise 1. if you just look at the numbers (4,3,5) the way to the min must be through keeping the three counts as close as possible.  4,3,5->3,4,4->4,3,3->3,2,4->2,3,3->3,2,2->2,1,3->1,2,2->2,1,1->1,0,2->0,1,1->1,0,0  3,3,3->2,2,4->1,3,3->2,2,2->1,1,3->2,0,2->1,1,1->0,0,2  waiting for counter examples, thanks"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If i, j, k are the number of occurrences of a, b, c respectively where i, j, k >= 1 and if b,a,a,c is a possible combination then the answer is '1'. Eg. b,a,a,c can be converted to (b,a),(a,c) => c,b => a"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If either all characters are present odd no of times or all are present even number of times, in tht case the result will be 2 and in any other case the result will be 1. Please suggest a case where this does not hold true."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ishant , your answer is incomplete . if its not I have to give you so easy counter example"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ishant, you are correct (though there's still something missing ...). So let me list all possible cases:  (1) String contains only one kind of characters, or more precisely, the string contains k identical characters and nothing else. Clearly, no reduction is poosible and the minimum length is k.  (2) String contains 2 or 3 kinds of characters. Then if all the counts are even or all the counts are odd, the minimum string possible has length 2, otherwise we can reduce it to 1.  Proof (of 2): With every reduction, the count of 2 characters decreases by 1, and the count of the third character increases by 1. So if all counts are even before reduction, all counts will be odd after reduction, and if allcounts are odd before, they will all be even after. So, for such strings, the shortest possible string we can get is (0, 0, 2) or (cc) or (bb) or (aa). All even counts. This proves that we can't do any better than (0, 0, 2). Now, are we guaranteed that we can always get to (0,0,2) for the all-odd, all-even strings and to (0,0,1) for the other strings? YES! We just have to be smart about which pairs we reduce. For example, if our string is aaaaaaabc we can either reduce ab or bc. Reducing bc would mean no more reduction so we don't want to do that! So the algorithm to reach minimum string is this  -- always reduce a pair that contains a character with maximum count. It does not matter which pair, just that the max count character be reduced. This will eventually result in a string of length 1 or 2 depending on the initial counts."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"# of consecutive characters besides matters. E.G. aaaab, the # of a is even => absorbed to one b. aaab, the # of a is odd => absorbed to c, a different char other than a and b.  #include  #include  using namespace std;  int absorbstr(string str) {   if (str.empty()) return 0;   if (str.size()==1) return 1;   if (str.size()==2) return str[0]==str[1]?2:1;    int num = 0;   for (size_t ix = 0; ix!=str.size()-1; ++ix)     if(str[ix]!=str[ix+1]) num = ix;   int last_size = str.size()-1-num;    int count = 1;    for (size_t ix = 0; ix!=str.size()-1; ++ix)   {     if (str[ix]==str[ix+1]) ++count;     else {       if( ix==num ) {          if(!(count%2) && !(last_size%2))            return count         else return 1;       }       if( count%2 ) str[ix+1] = str[ix]^str[ix+1]^'a'^'b'^'c';       count = 1;     }   }   return count; }  int main(int argc, char* argv[]) {   cout << argv[1] << \"=>\" << absorbstr(argv[1]) << endl;   return 1; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"case 1: only 1 char: understood case 2: any 2 or 3 char if count of any char is odd then min possible length = 1, else if all chars count is even min possiblee length is 2. since in case of even eventually you will left with 2 similar chars which will not be able to generate 3rd char."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Well if you have string: abb then you can reduce it to cb and then to just a. The answer therefore is 1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"stackoverflow . com/ questions/ 8551519/ string-reduction-programming-contest-solution-needed/ 8997695#8997695"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//a really dumb solution using DP \npublic class Test { \n String needTest = \"cab\"; \n int sum = 'a' + 'b' + 'c'; \n Test() \n { \n  System.out.println(testString(needTest)); \n } \n int testString(String s) \n { \n  int min = s.length(); \n  if(min == 1) \n  { \n   return 1; \n  }else if(min == 2) \n  { \n   if(s.charAt(0) == s.charAt(1)) \n   { \n    return 2; \n   }else \n   { \n    return 1; \n   } \n  } \n   \n  StringBuffer sb = new StringBuffer(); \n  for(int i= 1; i temp) \n    { \n     min  = temp; \n    } \n   } \n  } \n  return min; \n } \n public static void main(String[] argv) \n { \n  Test t = new Test(); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Main {     public static char get(char a, char b) {         if (a == 'a') {             if (b == 'b') return 'c';             else return 'b';         } else if (a == 'b') {             if (b == 'a') return 'c';             else return 'a';         } else {             if (b == 'b') return 'a';             else return 'b';         }     }  public static void main(String[] args) {   String test = \"abbbbbbbbc\";   for (int times = 0; times < test.length(); times++) {       StringBuffer sb = new StringBuffer();       sb.append(test.charAt(0));       for (int i = 1; i < test.length(); i++) {           if (test.charAt(i) != sb.charAt(sb.length() - 1)) {               char rep = get(test.charAt(i), sb.charAt(sb.length() - 1));               sb.deleteCharAt(sb.length() - 1);               sb.append(rep);           } else {               sb.append(test.charAt(i));           }       }       test = sb.toString();   }   System.out.println(test);  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"take the array  with O(n)  Walk through original array and whenever two adjacent character diff replace it and keep the final result in  second array  apply the same with second array,   Repeat above procedure unless all elements are same or length equal to 1.  Time O(n^2)  Space O(n)  Space complexity can avoided  if be put the result back to original array ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We should look for optimum solutions here. It is not enough if we just parse the elements from left to right or right to left. we must find out proper combinations to achieve maximum compression. EG : cabb   Parsing from left to right yields -> cabb -> bbb -> String of lenght 3 Parsing from right to left yields -> cabb -> ccb -> ca-> b -> string of length 1.  Hence we must check when we combine two adjacent chars to produce the resultant char, if the resultant char is same as the next char. If so, skip this pair for that round and continue."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here is the idea: (1) allocate an array of vector size equal of length of the input array. (2) initialize this array by pushing sub-string(inputstring, 0 , i)  (3) for each item from the array, domerge from the last char to the first char(merge reversely)and push newly generated string to the vector. try combining the tail char with all strings in its previous array element (i-1) (4) loop (3) for all array elements (5) the length of the shortest string in the last array element will be the answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here is the idea: (1) allocate an array of vector size equal of length of the input array. (2) initialize this array by pushing sub-string(inputstring, 0 , i)  (3) for each item from the array, domerge from the last char to the first char(merge reversely)and push newly generated string to the vector. try combining the tail char with all strings in its previous array element (i-1) (4) loop (3) for all array elements (5) the length of the shortest string in the last array element will be the answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here is the idea: (1) allocate an array of vector size equal of length of the input array. (2) initialize this array by pushing sub-string(inputstring, 0 , i)  (3) for each item from the array, domerge from the last char to the first char(merge reversely)and push newly generated string to the vector. try combining the tail char with all strings in its previous array element (i-1) (4) loop (3) for all array elements (5) the length of the shortest string in the last array element will be the answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I also have an solution but in a recursive manner :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"find out the number of each characters NumA, NumB, NumB  If two of them 0 then return string.length else if (all of them are either Odd or Even) return 2;  else return 1;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can be solved using a stack..much the same way you would evaluate an expression(for eg infix)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \n#define A 'a' \n#define B 'b' \n#define C 'c' \n \nvoid compress(char c[], int l) { \n \n int i=0; \n int sum=0, rem=0, avg; \n \n for (i=0;i2) \n    i=0; \n  } \n \n  compress(c,l); \n } \n} \n \nint main(void) { \n int i, len; \n char c[40]; \n printf(\"Enter string {a,b,c}* : \"); \n scanf(\"%s\",c); \n len=strlen(c); \n printf(\"String is : %s\\n\",c); \n \n compress(c,len); \n printf(\"String is : %s\\n\",c); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include   #define A 'a' #define B 'b' #define C 'c'  void compress(char c[], int l) {   int i=0;  int sum=0, rem=0, avg;   for (i=0;i rem = sum % l;  avg = sum / l;   //check if all elements are same  if((avg==A && !rem) || (avg==B && !rem) || (avg==C && !rem)) return;   if(l==2) {   c[0]=A+B+C-c[0]-c[1];   c[1]='\\0';   return;  }else{   while((i+2)    if((c[i+0]+c[i+1]+c[i+2])==(A+B+C)) {     if(c[i+3]!=c[i+2])      c[i+0]=c[i+2];     else      c[i+0]=c[i+1];          memmove(&c[i+1], &c[i+2], l-i);     c[l]='\\0'; --l;     continue;    }    i++;   }     i=0;   while((i+1)   if(((c[i+0]+c[i+1])==(A+B))|| ((c[i+0]+c[i+1])==(B+C)) || ((c[i+0]+c[i+1])==(A+C))){     c[i+0]=A+B+C-c[i+0]-c[i+1];     memmove(&c[i+1], &c[i+2], l-i);     c[l]='\\0'; --l;     continue;    }    i++;    if(i==l && l>2)     i=0;   }    compress(c,l);  } }  int main(void) {  int i, len;  char c[40];  printf(\"Enter string {a,b,c}* : \");  scanf(\"%s\",c);  len=strlen(c);  printf(\"String is : %s\\n\",c);   compress(c,len);  printf(\"String is : %s\\n\",c);  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Check my solution here:  basicalgos.blogspot.com/2012/02/string-reduction-given-string.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #include #include #include using namespace std;  string s; mapmp; mapchange; int get(string s) {  int i,j;  int len=s.size();  int ans=len;  if(mp.count(s)!=0)   return mp[s];  for(i=0; i {   string now=s.substr(i,2);   if(change.count(now)!=0)   {    string tp=s.substr(0,i);    string tp1=s.substr(i+2,len-(i+2));    string tp2=change[now];    string next=tp1+tp+tp2;    ans=min(ans,get(next));   }  }  return mp[s]=ans; } int main() {  int i,j,k,t;  freopen(\"in.txt\",\"r\",stdin);  scanf(\"%d\",&t);  for(i=0; i {   mp.clear();   change[\"ab\"]=\"c\";   change[\"ba\"]=\"c\";   change[\"ac\"]=\"b\";   change[\"ca\"]=\"b\";   change[\"cb\"]=\"a\";   change[\"bc\"]=\"a\";      cin>>s;   int ans;   ans=get(s);   cout<< } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #include #include #include using namespace std;  string s; mapmp; mapchange; int get(string s) {  int i,j;  int len=s.size();  int ans=len;  if(mp.count(s)!=0)   return mp[s];  for(i=0; i {   string now=s.substr(i,2);   if(change.count(now)!=0)   {    string tp=s.substr(0,i);    string tp1=s.substr(i+2,len-(i+2));    string tp2=change[now];    string next=tp1+tp+tp2;    ans=min(ans,get(next));   }  }  return mp[s]=ans; } int main() {  int i,j,k,t;  freopen(\"in.txt\",\"r\",stdin);  scanf(\"%d\",&t);  for(i=0; i {   mp.clear();   change[\"ab\"]=\"c\";   change[\"ba\"]=\"c\";   change[\"ac\"]=\"b\";   change[\"ca\"]=\"b\";   change[\"cb\"]=\"a\";   change[\"bc\"]=\"a\";      cin>>s;   int ans;   ans=get(s);   cout<< } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #include #include #include using namespace std;  string s; mapmp; mapchange; int get(string s) {  int i,j;  int len=s.size();  int ans=len;  if(mp.count(s)!=0)   return mp[s];  for(i=0; i {   string now=s.substr(i,2);   if(change.count(now)!=0)   {    string tp=s.substr(0,i);    string tp1=s.substr(i+2,len-(i+2));    string tp2=change[now];    string next=tp1+tp+tp2;    ans=min(ans,get(next));   }  }  return mp[s]=ans; } int main() {  int i,j,k,t;  freopen(\"in.txt\",\"r\",stdin);  scanf(\"%d\",&t);  for(i=0; i {   mp.clear();   change[\"ab\"]=\"c\";   change[\"ba\"]=\"c\";   change[\"ac\"]=\"b\";   change[\"ca\"]=\"b\";   change[\"cb\"]=\"a\";   change[\"bc\"]=\"a\";      cin>>s;   int ans;   ans=get(s);   cout<< } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #include #include #include using namespace std;  string s; mapmp; mapchange; int get(string s) {  int i,j;  int len=s.size();  int ans=len;  if(mp.count(s)!=0)   return mp[s];  for(i=0; i {   string now=s.substr(i,2);   if(change.count(now)!=0)   {    string tp=s.substr(0,i);    string tp1=s.substr(i+2,len-(i+2));    string tp2=change[now];    string next=tp1+tp+tp2;    ans=min(ans,get(next));   }  }  return mp[s]=ans; } int main() {  int i,j,k,t;  freopen(\"in.txt\",\"r\",stdin);  scanf(\"%d\",&t);  for(i=0; i {   mp.clear();   change[\"ab\"]=\"c\";   change[\"ba\"]=\"c\";   change[\"ac\"]=\"b\";   change[\"ca\"]=\"b\";   change[\"cb\"]=\"a\";   change[\"bc\"]=\"a\";      cin>>s;   int ans;   ans=get(s);   cout<< } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #include #include #include using namespace std;  string s; mapmp; mapchange; int get(string s) {  int i,j;  int len=s.size();  int ans=len;  if(mp.count(s)!=0)   return mp[s];  for(i=0; i {   string now=s.substr(i,2);   if(change.count(now)!=0)   {    string tp=s.substr(0,i);    string tp1=s.substr(i+2,len-(i+2));    string tp2=change[now];    string next=tp1+tp+tp2;    ans=min(ans,get(next));   }  }  return mp[s]=ans; } int main() {  int i,j,k,t;  freopen(\"in.txt\",\"r\",stdin);  scanf(\"%d\",&t);  for(i=0; i {   mp.clear();   change[\"ab\"]=\"c\";   change[\"ba\"]=\"c\";   change[\"ac\"]=\"b\";   change[\"ca\"]=\"b\";   change[\"cb\"]=\"a\";   change[\"bc\"]=\"a\";      cin>>s;   int ans;   ans=get(s);   cout<< } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #include #include #include using namespace std;  string s; mapmp; mapchange; int get(string s) {  int i,j;  int len=s.size();  int ans=len;  if(mp.count(s)!=0)   return mp[s];  for(i=0; i {   string now=s.substr(i,2);   if(change.count(now)!=0)   {    string tp=s.substr(0,i);    string tp1=s.substr(i+2,len-(i+2));    string tp2=change[now];    string next=tp1+tp+tp2;    ans=min(ans,get(next));   }  }  return mp[s]=ans; } int main() {  int i,j,k,t;  freopen(\"in.txt\",\"r\",stdin);  scanf(\"%d\",&t);  for(i=0; i {   mp.clear();   change[\"ab\"]=\"c\";   change[\"ba\"]=\"c\";   change[\"ac\"]=\"b\";   change[\"ca\"]=\"b\";   change[\"cb\"]=\"a\";   change[\"bc\"]=\"a\";      cin>>s;   int ans;   ans=get(s);   cout<< } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"string reduce (string toReduce) \n{ \n    string [] paths = new srtring [6]; \n    string min = toReduce; \n \n    path[0] = toReduce.replace('ac', 'b'); \n    path[1] = toReduce.replace('ab', 'c'); \n    path[2] = toReduce.replace('bc', 'a'); \n    path[3] = toReduce.replace('cb', 'a'); \n    path[4] = toReduce.replace('ca', 'b'); \n    path[5] = toReduce.replace('ba', 'c'); \n \n    for (int i = 0; i < 6; i++) \n    { \n        if (path[i] != toReduce)  \n            path [i] = reduce (path[i]); \n        if (path[i].length < min.length) min = path[i]; \n    } \n    return min; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solvable with no code.  If all three types have either an even or odd number, then the smallest string has size 2.  Otherwise 1.  Or a special case like he original string is all 1 char which can be treated separately.     To see this consider that e odd/even imbalance is preserved by any combination.   If all are even or odd, then a combination switches their mode from all even to all odd or vice versa since the two combined lose 1 and the created char gains one.  Similarly an imbalance keeps the imbalance but switches it from odd to even or vice versa.   Thus no combination can ever get you from all odd or even to 1 char left since zero is not odd.   This does not fully prove our assertion since it does not prove that all cases are reducible to 2 or 1.  That is easily shown by proving that any imbalance is easily reduced to an off by one case e.g. 4/4/5.   I leave that up to readers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"char replace(char char1, char char2) {      if((char1=='a' && char2=='b') || (char1=='b' && char2=='a')) return 'c';      else if((char1=='a' && char2=='c') || (char1=='c' && char2=='a')) return 'b';      else return 'a'; } int main() {     string a = \"bcabccc\";    for(int i=0 ;i+1   {            if(a[i]!=a[i+1])            {              a[i] = replace(a[i],a[i+1]);              a.erase(i+1,1);              i= (i-2<-1)?-1:i-2;            }            cout << a <<\" \";    }    cout < \n   \n    \n   -  \n     ediston \n     on April 06, 2012 Edit | Flag  \n    \n    \n   Reply"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Count the number of occurences of each letter in the input string [numA, numB, numC]  If two of these counts are 0, then return string.length  Else if (all counts are even) or (all counts are odd), then return 2  Else, then return 1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int MinOfChars(int *Arr,int PrevSum) \n{ \n if(Arr[0] != 0 && (Arr[1] == 0 && Arr[2] == 0)) \n  return (Arr[0]); \n if(Arr[1] != 0 && (Arr[0] == 0 && Arr[2] == 0)) \n  return (Arr[1]); \n if(Arr[2] != 0 && (Arr[0] == 0 && Arr[1] == 0)) \n  return (Arr[2]); \n \n int CurrSum = Arr[0] + Arr[1] + Arr[2]; \n \n if(PrevSum == CurrSum) \n  return CurrSum; \n \n sort(Arr,Arr + 3); \n \n Arr[2] -= Arr[1]; \n Arr[0] += Arr[1]; \n Arr[1] = 0; \n \n return(MinOfChars(Arr,CurrSum)); \n} \n \nint MinOfChars(char *S) \n{ \n int Arr[3] = {0,0,0}; \n  \n for(int i = 0; i < strlen(S); ++i) \n { \n  Arr[S[i] - 'a']++; \n } \n \n return MinOfChars(Arr,-1); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int MinOfChars(int *Arr,int PrevSum) \n{ \n if(Arr[0] != 0 && (Arr[1] == 0 && Arr[2] == 0)) \n  return (Arr[0]); \n if(Arr[1] != 0 && (Arr[0] == 0 && Arr[2] == 0)) \n  return (Arr[1]); \n if(Arr[2] != 0 && (Arr[0] == 0 && Arr[1] == 0)) \n  return (Arr[2]); \n \n int CurrSum = Arr[0] + Arr[1] + Arr[2]; \n \n if(PrevSum == CurrSum) \n  return CurrSum; \n \n sort(Arr,Arr + 3); \n \n Arr[2] -= Arr[1]; \n Arr[0] += Arr[1]; \n Arr[1] = 0; \n \n return(MinOfChars(Arr,CurrSum)); \n} \n \nint MinOfChars(char *S) \n{ \n int Arr[3] = {0,0,0}; \n  \n for(int i = 0; i < strlen(S); ++i) \n { \n  Arr[S[i] - 'a']++; \n } \n \n return MinOfChars(Arr,-1); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class StringReduction { \n \n StringReduction() { \n } \n \n private int allEqual(String str) { \n  boolean ret = true; \n \n  char pc; \n \n  if (str.length() == 1) \n   return 1; \n \n  char[] ca = str.toCharArray(); \n \n  pc = ca[0]; \n \n  for (int i = 1; i < ca.length; i++) { \n   if (ca[i] != pc) \n    return 0; \n   pc = ca[i]; \n  } \n \n  return ca.length; \n } \n \n private String replaceTwo(String str, int i) { \n  if (str == null) \n   throw new NullPointerException(); \n \n  if (str.length() == 1) \n   return str; \n \n  if (str.length() - 1 < i + 1) \n   return str;// do not replace \n \n  char[] ca = str.toCharArray(); \n  char replaceC = '\\0'; \n \n  if (ca[i] == ca[i + 1]) \n   return str; \n \n  if (ca[i] == 'a' && ca[i + 1] == 'b') { \n   replaceC = 'c'; \n  } else if (ca[i] == 'b' && ca[i + 1] == 'c') { \n   replaceC = 'a'; \n  } else if (ca[i] == 'c' && ca[i + 1] == 'a') { \n   replaceC = 'b'; \n  } \n \n  if (i > 0 && (i + 2) < str.length()) { \n   return (i > 1) ? str.substring(0, i - 1) + replaceC \n     + str.substring(i + 2) : ca[0] + replaceC \n     + str.substring(i + 2); \n  } else if (i == 0 && (i + 2) < str.length()) { \n   return replaceC + str.substring(i + 2); \n  } else if (i > 0 && (i + 2) >= str.length()) { \n   return (i > 1) ? str.substring(0, i - 1) + replaceC : \"\" + ca[0] + replaceC; \n  } else if (i == 0 && (i + 2) >= str.length()) { \n   return replaceC + \"\"; \n  } \n \n  return \"\"; \n } \n \n private int min(int a, int b) { \n  if (a > b) \n   return b; \n  else \n   return a; \n } \n \n public int stringReduced(String str, int i) { \n  if (str.length() == 1) \n   return 1; \n \n  if (this.allEqual(str) > 0 || str.length() == i) \n   return str.length(); \n \n  String reduceString = this.replaceTwo(str, i); \n \n  int reduceVal = 0; \n \n  if (reduceString.equals(str)) { \n   reduceVal = stringReduced(str, i + 1); \n  } else { \n   reduceVal = stringReduced(reduceString, 0); \n  } \n \n  int noreduceVal = stringReduced(str, i + 1); \n \n  return min(noreduceVal, reduceVal); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.io.BufferedReader; \nimport java.io.IOException; \nimport java.io.InputStreamReader; \n \npublic class Solution{ \n \n public static void main(String[] args) throws IOException { \n  BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); \n  int T = Integer.parseInt(br.readLine().toString()); \n  for (int i = T; --i >= 0;) { \n   String S = br.readLine(); \n   if (S.length() < 2) { \n    System.out.println(S.length()); \n   } else { \n    process(S); \n   } \n  } \n   \n } \n \n private static void process(String S) { \n  for (int i = 0; i < S.length() - 1; i++) { \n   String temp = S.substring(i, i + 2); \n   if (temp.contains(\"ab\") || temp.contains(\"ba\")) { \n    S = S.replaceFirst(temp, \"c\"); \n    i = -1; \n   } else if (temp.contains(\"ac\") || temp.contains(\"ca\")) { \n    S = S.replaceFirst(temp, \"b\"); \n    i = -1; \n   } else if (temp.contains(\"bc\") || temp.contains(\"cb\")) { \n    S = S.replaceFirst(temp, \"a\"); \n    i = -1; \n   } \n  } \n  System.out.println(S.length()); \n \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#import \n#import \nchar diff(char a, char b) \n{ \n if((a == 'a' && b == 'b') || (a == 'b' && b == 'a')) \n  return 'c'; \n else if((a == 'b' && b == 'c') || (a == 'c' && b == 'b')) \n  return 'a'; \n else if((a == 'a' && b == 'c') || (a == 'c' && b == 'a')) \n  return 'b'; \n else \n  return '@'; \n} \nvoid  moveZeros(char* a) \n{ \n        size_t len = strlen(a); \n        int index0 = 0; \n        int indexN = 0; \n printf(\"-->before %s\",a); \n        for(int i = 0; i < len; i++) \n        { \n                if(a[i] != '@') \n                { \n                        int temp = a[i]; \n                        a[i] = a[index0]; \n                        a[index0] = temp; \n                        index0++; \n                } \n        } \n a[index0] = '\\0'; \n printf(\"--> %s\",a); \n} \n \nvoid stringCompression(char* str, size_t len) \n{ \n int i = 0; \n int j; \n int cont = 1; \n while(cont == 1){ \n  i = 0; \n  cont = 0; \n  for(j = 1; j < len;) \n  { \n   char r = diff(str[i], str[j]); \n   if(r != '@') \n   { \n    cont = 1; \n    str[i] = r; \n    str[j] = '@'; \n    i++;  \n   } \n   else \n    i = j; \n   j++;  \n  } \n  moveZeros(str); \n } \n printf(\"\\t%lu\\n\",strlen(str)); \n} \n \nint main() \n{ \n char a[] = \"acbb\"; \n char b[] = \"aaaabbbb\"; \n char c[] = \"aaa\"; \n char d[] = \"acacac\"; \n \n printf(\"For %s :\",a); \n stringCompression(a, strlen(a)); \n printf(\"For %s :\",b); \n stringCompression(b, strlen(b)); \n printf(\"For %s :\",c); \n stringCompression(c, strlen(c)); \n printf(\"For %s :\",d); \n stringCompression(d, strlen(d)); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"IN JAVA:  public class StringReduction{ static HashMap map = new HashMap();  static List len = new ArrayList();  static{   map.put(\"ab\", \"c\");   map.put(\"ba\", \"c\");   map.put(\"ac\", \"b\");   map.put(\"ca\", \"b\");   map.put(\"bc\", \"a\");   map.put(\"cb\", \"a\");     }  public static void main(String args[]) throws Exception {      reduce(\"abaaccbca\");   Collections.sort(len);   System.out.println(len.get(0));  } static void reduce(String s){   Object combinations[] = getCombinations(s);   //int count = 0;   for(Object comb : combinations){    if(map.containsKey((String)comb)){          reduce(s.replace((String)comb, map.get((String)comb)));    }   }   len.add(s.length());  }    static Object[] getCombinations(String s){   ArrayList list = new ArrayList();   for(int i = 0;i   list.add(s.charAt(i)+\"\"+s.charAt(i+1));   }   return list.toArray();  } } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is easily solvable in time O(n). Just observe that the reduction rules are the same as multiplication in Klein 4 group."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"The smallest we can get is the length of smallest substring formed by similar consecutive elements. e.g.  abcbac ( smallest consecutive is 1 ) so string reduces to size 1. conside aaaabbbccccc ( a4,b3,c5) it should reduce to 3 since smallest consecutive similar is 3 )  aaaabbbccccc -> aaaabbacccc ->  aaaabbacc -> aaaabccc -> aaacccc -> aabccc -> aaa. (length is 3)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"take the array  with O(n)  Walk through original array and whenever two adjacent character diff replace it and keep the final result in  second array  apply the same with second array,   Repeat above procedure unless all elements are same or length equal to 1.  Time O(n^2)  Space O(n)  Space complexity can avoided  if be put the result back to original array ."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13817668","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"70","title":"You are given a huge log file which holds the entry and exit time of each person entering and exiting the office on a given day  format of file: entry time                      exit time 09:12:23                        11:14:35 10:34:01                         13:23:40 10:34:31                          11:20:10 . .upto N entries for a given day  Design a function which returns the total number of persons in the office at any given time.  e.g input to function is 11:05:20.  The interviewer said he could call the function every second with input 11:05:20, 11:05:21,11:05:22, 11:05:23..........14:30:30  I really did not understand how to optimize the function.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"Let me give a completely different strategy... Assuming N is very large million or billion Assume time is between 00:00:00 and 23:59:59 Since we want to optimize the lookup time , we need to preprocess data. below is the strategy to have constant time for lookup...  1. initialize an array with 86400 elements and all elemets are 0 2. Now for every element b/w starttime and end time, increment the array by 1, for e.g for 00:00:00(Start) and 00:00:59(End) array index 0 to 59 are all incremented by 1. 3. Do this for all entries. 4. Now to look at the people present in office just refer to array index (CONSTANT TIME)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Do a merge sort.... It will take O(nlogn) Then traverse along... Before doing sorting tag each entry as exit and entry time. While traversing For each entry add 1 and for each exit subtract 1. You will get your answer.  example: entry time exit time 09:12:23 10:14:35 10:34:01 13:23:40 10:34:31 11:20:10  After Sorting: 09:12:23(entry) 10:14:35(exit) 10:34:01(entry) 10:34:31(entry) 11:20:10(exit) 13:23:40(exit)  So at any time e.g at 11:00:00 the number of persons will be : +1 -1 +1 +1 = 2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"We can use a self balanced BST (AVL types) * Implement the self balancing on the entry time of each employee * Once u obtain the tree search for the subtree where everyone  enters the offc before input-time(let this be subtree have K entries) * From the subtree obtained visit every node and find who left the offc before input-time(let this number be L) * Ur answer should be ---> K - L"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"use an augmented red black tree, to build an interval tree.  Each node maintains interval and max value apart from pointer.  Search for particular time can be performed in lg n time. If there are say K occurences where interval overlaps, it will take O(K * lg n) time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"CalculatePresentPersons(N) (1) Take an array of size 86400(60*60*24) Say array D (2)Initialize whole array to zero. (3)For Each a in file -temp=a->start->hour*60*60+a->start->min*60+a->start->second; -temp2=a->end->hour*60*60+a->end->min*60+a->end->second;  for i=temp to temp2   D[i]=D[i]+1;  end inner loop end outer loop (4)Return(D[N]) (5)Finish  P.S This procedure will be run once and then in O(1) time we can calculate the number of persons present in the hall. I know Initial complexity is high but searching is O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Use bucket sort at 2 levels Preprocessing: 1. create 1 bucket for 1 hour.. so u have 24 buckets for login time.. 2. for each login bucket created above .. create another 24 buckets for logout time.. you have total  24(login)  + 24*24(logout)  buckets in total  suppose given time is 2:15 you can forget about 24 login buckets and look into 576 logout buckets.. 1. start looking from 2*24  + 3 = 51th bucket(all logout times greater than 2:15) + all items in  2*24 + 4,5,6 ... 24 buckets suppose given time is 6:20 1. start looking from 6*24 + 7 = 99th bucket(all logout times greater than 2:15) + all items in  6*24 + 8,9,10..->24"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The entry time will be in ascending order. Assuming that the exit time can be in any order, i.e. the first person to enter is not the first one to exit.  Iterate over the indexes till the entryTime > inputTime. Increase count whenever entryTime < inputTime < exitTime  int CountPeople (Calendar inputTime) { int peopleInside = 0;    BufferedReader br = new BufferedReader(new FileReader(\"filePath\")); String line; try { while ((line = br.readLine() )!=null) {  Calendar entryTime = Calendar.getInstance();  String entryTimeInString = line.subString(0, line.indexOf(\" \"));  //fill the time in entryTime using entryTimeInString if (entryTime.after(inputTime) { break; } Calendar exitTime = Calendar.getInstance();  String exitTimeInString = line.subString(line.indexOf(\" \") + 1, line.length());  //fill the time in exitTime using exitTimeInString if (exitTime.after(inputTime) { peopleInside++; } } catch (IOExecption e) { e.printStackTrace(); } return peopleInside; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since the file is large reading it each time would be a problem . We could store the number of people at a given time in a hash table. Once the table is built retrieval of number of persons at a given time would be O(1)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sort the file based on exit data... and then apply binary search on exit data, and find the  starting point i.e (exit data >= target time) end point i.e (exit data <= target time)  All the intervals that lies between start and end point is the answer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The interviewer said he could call the function every second with input 11:05:20, 11:05:21,11:05:22, 11:05:23..........14:30:30  I really did not understand how to optimize this."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Entry time is not required at all. Read in exit times. Now create a map (can implement it using a 2D array) with (exit time, no of people) as the \"key, value\" pair. Once this map is created, sort the map according to key (exit time). Now the problem reduces to adding values of all keys greater than input time, which gives you the total number of people in office at that time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Read the file. Store the data in an interval tree. The interval is stored in seconds and represents the time spent in the room ( so need a function for converting HH:MM:SS to just S )  To compute the # of people in the room at time HH:MM:S  Convert the time to check to S Get a list of all intervals that overlap the requested time. the number of people in the room is equal to the size of this list.  IntervalTree provides a good balance between space and time here.  Can also be solved with a hashTable Key is the time in seconds Value is the number of people in the room at that time. Time to populate the table is more expensive as is the memory usage -- but the lookup would be faster."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"At the time of storage, restore the log file time into blocks, say 1pm to 2pm block or even smaller blocks. Multiple hash tables can be used to quicken the access to these blocks. So at time of retrieval only the entries inside the blocks (at most two blocks) need to be scanned through instead of all the entries."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think interviewer want to check how do you solve the problem different ways. Here few approach come in my mind.  1. At first, Add all element into map depend on entry time is key. So, every time you search ppl present at perticular time. Search who enter before that time and compare exit time is not before it.  2. As interview says, it is huge file. It may possible above approach wont work as memory will not be sufficient to hold that much data. In That case, You can create multiple temporary files depending upon entry times slot (30mins/1 hour). When user try to find ppl between particular slot. Open files which has entry time before particular time, generate maps and search into it. It this case, LRU can be maintained for n maps depending upon memory and  first search into LRU list and maps and then open into other files add those into LRU.  Drawback: if every time requested time different that LRU. It will less effective as time required to build the map is waste.  3. Create multiple files with (30min/1hr) time slots i.e 11.00-11:30, 11:30-12:00 etc. Add entries which fall into those time slots. Then, whenever there is request open file generate map and search into it. Maintain LRU for the same.  Drawback: if every time requested time different that LRU. It will less effective as time required to build the map is waste."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Create two arrays. One based on entry time say A and the next based on exit time say B. Sort both the arrays.  When a person wants to find out how many persons are there. He just has to perform a Binary search(This Binary search returns an index which is at most greater than or equal to the given value.) The index returned from A minus the index returned from B will be the answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i think insertion sort using link list will give better performance than merge sort and other method"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I assume that data is already sorted by enter time.  1. Partition the data by the enter time creating hourly partitions (size of the partition can be configurable, as an extra optimization night time hours can be grouped into single partition). Ideally partition should fit in memory/ 2. For each partition create an index of exit times: for each hour keep a)list of references that have exit time in this hour b)bitmap index representing items in the main list c)interval tree index 3. When request comes query only partitions <=currenttime; inside of the partition query buckets >= currenttime and do more precise filtering by enter time 4. If resources enable distribute partitions to different machines and execute query in parallel."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Read file and populate two arrays: long[] personIn and long[] personOut. personIn represents first column of data file and personOut represent second column. Date must be converted to long!!! 2. Sort personOut in ascending order. Suppose that personIn array is already sorted in ascending order(Log file is written in ascending order). 3. Write function that will effectively finds a position for the long element in sorted array(use binary search algorithm): positionInAscSortedArray(long[] arr, long element). 4. calculate the result: positionInAscSortedArray(personIn, timeAsLong) - positionInAscSortedArray(personOut, timeAsLong)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"One solution that I can think of is to keep 24 nodes (1 for each hour). each of these 24 nodes will keep a list of 60 nodes each as children (1 node for each minute in an hour). and each of the minute nodes will again keep 60 nodes under it (1 for each second in a minute). So the internal representation will have 3 levels one each for hours, minutes and seconds. Each of the 24*60*60 nodes will have an counter variable indicating how many persons are there in office during that time.  Insertion: ======== The technique here is that we will increment the counter of the hour node only if the person is in office for the complete hour. Similarly we will increment the minute node of a particular hour only if the person is in office for the complete minute during that hour. Similarly we will increment the second counter of a minute only if the person is not inside for the complete minute but for few seconds within that minute. . Example: 09:55:50 - 15:05:05 in this case the data structure is updated as follows: 9-10: we will not increment the counter for hour 9 as we are not inside office for the complete hour. We will increment the 56, 57, 58, 59 and 60 minutes counter under hour 9. Similarly we will increment seconds counter for 50-60 under minutes 55. No other counter needs to be updated for this hour.   10-11 We will increment hour 10 node only as we are inside for the whole hour. 11-12 We will increment hour 10 node only as we are inside for the whole hour. 12-13 We will increment hour 10 node only as we are inside for the whole hour. 13-14 We will increment hour 10 node only as we are inside for the whole hour. 14-15 We will increment hour 10 node only as we are inside for the whole hour. 15-16 Again we are not inside for the whole hour so we will not increment the hour node but minutes and seconds nodes only as in the case of 9-10.  So using this technique we will at max need to change a constant number of nodes (22hour nodes + 59 minutes node and 59 seconds node) in the worst case for an employee which is not bad considering that we need to make the data structure only once and it makes the search operation constant time.  Search ======= Now during searching if we want to search the number of employees at say 10:20:30 then we will go to node 10 of first level and get the value of the counter there. It will represent all the employees who were inside office for the whole hour from 10 to 11. Next we go to minute node 20 of second level which indicate the number of employees who were present for the whole minute during that hour. next we go to scond node 30 at third level and get the counter value there which indicate the employees who were inside during that second in the minute. Adding these 3 counters is our result. So it just took us O(3) or constant time.  Space complexity: ============== We need to store 24*60*60 nodes. The size of each node will be 4 bytes to store the counter(assuming Unsigned int on 32 bit m/c). We can avoid using a pointer to represent the next or child node by using some clever array arithmetic as the number of nodes are constant and known. So the total requirement is  24*60*60*4 bytes = 337.5KB which is not at all large considering the search complexity we are achieving with this solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What I can think of is not much different from few of the above solutions but yes I think the look ups must not need calculations to be done. In problems which involve querying multiple times we generally talk about the cost of pre processing and querying.  Suppose a solution takes f[n] time to pre-process (which is a one time job) and g[n] time to query then we say that the complexity is . In such solutions our main aim is to optimize g[n] as this is the part which will be called unlimited number of times.  So, let's start with the pre-processing steps: 1) Allocate an array of size 24 * 60 * 60 and initialize it with -1. ( this is the basic necessity to make g[n] a constant mostly 1) 2) Store 0 at the first index of the array. 3) Traverse the entry column of the log file and convert the time encountered into seconds, let it be s. Find the first non -1 entry in the array before s , let it be at index k. Add 1 to A[s] and populate the indices till k with 1+A[s]. 4) Now traverse the exit column and convert the times into seconds and maintain a counter for number of exit times say count which is 0 at the beginning. Let the time be p so count++ and then A[p] = A[p]-count. do this till you get to the index of second exit time and so on. This will be done in two iterations. So I can say O(n).  Now, you can look up any time, by converting it into seconds and give them A[seconds].    As per the question the minimum time difference is 1 second"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming we have already converted entry time and exit time in seconds. Take two arrays intime[] and outtime[], each of size 86400. Assuming intime is already sorted, Sort outtime in ascending order.   Check first outtime value, Let say its x. Count no. of intime entries before 'x'. and update 'x-1' entries with that count. count is no. of people inside at any particular time.  Update xth entry as count-1.   Repeat this again, check second outtime entry, and count no. of intime entries from (x+1)th second till (second_outime_entry-1). Update entries from x+1 to (second_outime_entry-1) with count at xth second + count till second_outtime entry. and so on"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The data is static. The file is huge. How huge?  There are only ~86k discrete intervals possible.  Is there a sign-in sign-out pattern? Are these localized? Will we achieve any space optimization by using an interval tree?  If so, should we consider memoization on the fly instead of preprocessing everything.  Any optimization will have to consider the context and decide."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why not use unix commands?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This problem is similar to counting the vacancies in a parking station. In the real world, you build the running total in real time rather than doing it at the end of the day because 1. it spreads out the cpu cost (it's almost negligible) and 2. it's more useful, wouldn't you want to find out how many people in the office any time of the day rather than reading the report next day knowing that the running total approach can generate the same report?  PAPP. If you can change the problem, you can save a lot of time in algorithm, program and process."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class EntryExitCode {  int entryPointer = -1;   static int employeeCount = 0;   TreeMap employeeCountAtAnyTime = null;   ArrayList entryList = null;  PriorityQueue exitQueue = null;  TimeComparator tc = null;   void createEntries(String file) {   tc = new TimeComparator();   employeeCountAtAnyTime = new TreeMap();    entryList = new ArrayList();   exitQueue = new PriorityQueue();   String temp = null;   String[] tempArray = null;   FileReader reader = null;   BufferedReader brReader = null;   try {    reader = new FileReader(new File(file));    brReader = new BufferedReader(reader);    temp = brReader.readLine();    while (temp != null) {     tempArray = temp.split(\"[ ]\");     entryList.add(tempArray[0]);     entryPointer++;     employeeCount++;     exitQueue.add(tempArray[1]);      checkExitStatus();      temp = brReader.readLine();     }    } catch (IOException e) {    e.printStackTrace();   } finally {    try {     if (brReader != null)      brReader.close();     if (reader != null)      reader.close();    } catch (IOException e) {      e.printStackTrace();    }    }   }   private void checkExitStatus() {   String temp1 = entryList.get(entryPointer);   String temp2 = exitQueue.peek();   if (temp1.compareTo(temp2) >= 0) {    temp2 = exitQueue.poll();    while (temp1.compareTo(temp2) >= 0) {     employeeCount--;     employeeCountAtAnyTime.put(temp2, new Integer(employeeCount));     temp2 = exitQueue.poll();          }    }   }   public static void main(String[] args) {   EntryExitCode eec = new EntryExitCode();   eec.createEntries(\"EntryExitFile.txt\");   // System.out.println(eec.employeeCountAtAnyTime);   String ceiliString = eec.employeeCountAtAnyTime.ceilingKey(\"11:19:20\");   System.out.println(eec.employeeCountAtAnyTime.get(ceiliString));   }  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13394663","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"63","title":"Given a dictionary of strings [ strings are in sorted order] you have to find the precedence of characters according to the dictionary.. eat bxy e is ranked above b according to the dictionary.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"9","title":"I presume the question gives you sorted strings.  Just form a graph(DAG) and do a topological sort."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Graph creation:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Thanks. I think DAG is the way to go. But as I see from here http://en.wikipedia.org/wiki/Topological_sorting after DAG, I think we can sort by DFS to find the sorted order as the solution by Topological Sort is not necessarily unique as it depends on random node u pick for the sorting. Correct if I am wrong."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This question has been asked many times before. I've already reported as duplicate.  1. Create a DAG from letters by comparing each word with the next. Since the word list is sorted, comparing the letters by location, gives which letter comes before the other. 2. Topological sort of the DAG will give you the order of the letters in the alphabet"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"\"precedence order on the alphabet set \" - can somebody please explain this.   and if the words are coming in sorted order what is the criterion  for the ordering of the words. if the ordering of words are Lexicographic order then final output of the algo by mpmaster doesn't look okay.   please correct me if i am wrong."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@Addy I think by precedence order we are asked to find the final sorted order of the set. For eg, we know A is greater than B, but in the given set we do not know the order. We have to find the order of the set based on a set of sorted words given to us. I am not clearly understanding Lexicographic order part and how this would fail.   It would be great if you can give more insight on this."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sorry the previous comment was by me!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i agree with LOLer's solution of using a DAG and topological sorting...that solves the problem...btw, nice question!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Yes, Loler is right. At least thats what I had in mind (when posting the question). To elaborate the sol.  Constructing the dag - {for now lets assume its english lang we are dealing with)  Consider a pair of words in the list with w1 < w2. We can draw a small edge between letters which come after common prefix. For eg. disgruntled < disinterested. Then g-->i.   This will form a dag. Top sort it.  Note that this graph may not be connected. In which case our dataset is insufficient to deduce complete order of the alphabetset from. Though you can have isolated pockets of letters with order defined."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Isn't it the Topological sorting of graphs ???"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"now the question is how to create that graph... here is my approach:  example:  given words: acd ab cbe de     every position in word gives a list of sort alphabets. so we have k (max number of characters in longest word given as input) so here k=3 while charplace..for all given words word[i] ....go through charater in word at position k and place this in already built graph remembering that it comes after the character in earlier words[0-i][k] at position k   so here is how it works. after first iteration: (a->c, c->d)=> a->c->d after 2nd iteration: a->c->d and a->c->b->e (cant wirte like graph here) after 3rd iteration: a->c->d->e and a->c->b->e  after topological sorting u will get: a c b/d e (2 answers)  if we had one more word like: bd then this wil give only one answer: a c b d e"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the topological sort goes with the assumption that there is atleast one character that occurs nowhere but as the first character of the list of words.   otherwise topological sort would fail as there arent any nodes with 0 in-degree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am still confused. Can someone help ?   \"You are then given a set of words coming from the language in the sorted order\" - List of word sorted ( acb,cba, bca) or word itself is sorted (abc,bc, c) or both (a, ab,bc, abc) ??? Case 1 : Traversing the array and create an edge between two alphabet with distance 1 or infinite(if unknown) Traversing the array would give you a acyclic traversal with covering all nodes., other there is no unique solution to the problem.  Case 2 Assuming words are sorted Then each word is a graph, clubbed together all the word to form a unified graph. Perform topological sort  Please help me understand the question and its probable solution.  Thanks Ankush"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this question has been asked before. topological  sort"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"-- > Construct a Graph . Check for cycles . In case of cycles , no solution exists . ---> Topological Sort of the DAG is the answer ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static String sortBasedOnKey(String sort, String key)     {  String result = \"\";    int[] count = new int[key.length()];   for (char ch:sort.toCharArray())  {      boolean isKey = false;            for (int i=0;i     {   if (key.charAt(i) == ch)   {       count[i]++;       isKey = true;   }      }            if (!isKey)      {   result +=ch;      }  }   for (int i = count.length-1;i>=0;i--)  {      for (int j=0;j     {   result = key.charAt(i)+result;      }  }    return result;     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//====define the graph public class Node {  public char value;  public List ajacent;  public String color;    public Node(char value) {   this.value = value;   this.ajacent = new ArrayList();   this.color = \"white\";  } }  public Node buildG(String[] strings) {  Node root = null;  Node current = null;  for(int i=0;i  char[] charArr = strings.charArray();   if(i == 0) {    root = current;    }   addAjacent(root,charArr,current);   current = new Node(charArr[0]);     }  return root; }  public void addAjacent(Node root, char[] chars, Node current) {  if(root == null) {   return;  }    ArrayList nodelist = new ArrayList();  for(int i=0;i  Node oldNode = findNOde(chars[i],root);   if(oldNode != null) {    nodelist.add(oldNode);   } else {    Node newNode = new Node(chars[i]);    nodelist.add(newNode);      }    }  for(int i=0;i  List ajacent = new ArrayList();   for(int j=i+1;j   ajacent.add(nodelist.get(j));   }   nodelist.get(i).ajacent = ajacent;  }  if(current != null) {   current.ajacent.add(nodelist.get(0));  }  nodelist.clear(); }   public Node findNOde(char value,Node root) {  if(root.value == value) {   return root;  } else {   root.color = grey;  }  for(Node node:root.ajacent) {   if(node.color.equals(\"white\") {    return findNode(value,node);   }  }  root.color = \"black\";  refreshStatus(root);  return null; }  public void refreshStatus(Node root) {  for(Node node:root.ajacent) {   node.color = \"white\";   refreshStatus(node);  } }  //====find the precedence  public List findPrecedence(char value,Node root) {  List precedences = new ArrayList();  root.color = \"grey\";  for(Node node:root.ajacent) {   if(node.value == value) {    precedences.add(root.value);   } else {    if(node.color.equals(\"white\")){     List subpres = findPrecedence(value,node);     node.color = \"grey\";     precedences.copyAll(subpres);    }   }  }  return precedences; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// The idea is to build the precedence between alphabets to create a  // directed graph. If there is cycle, then training set is not correct - error out; // otherwise do topological sort for constructed DAG to return alphabet in partial order."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This comment has been deleted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is the following an accurate re-statement of the problem?  There exists an alphabet comprising some number of characters. The order of the alphabet, i.e. the full-ordering, is not known. You are given a list of \"words\" comprised of characters from the alphabet. The list of words is given to be sorted in lexicographical order. Write a program to deduce the order of the alphabet.  Bonus: 1. What is the space/time complexity of your algorithm? 2. Given the problem statement, is it possible to deduce the full (complete) order of the alphabet? Explain your answer in detail."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a great problem. I really don't like (or perhaps don't fully comprehend) the answers given on this thread. Let's dig deeper on this one and explore:  Problem restatement: There exists an alphabet comprising some number of characters. The order of the alphabet, i.e. the full-ordering, is not known. You are given a list of \"words\" comprised of characters from the alphabet. The list of words is given to be sorted in lexicographical order. Write a program to deduce the order of the alphabet.  For the sake of example, let's assume that we're using an English alphabet (i.e. we know the full order). Now assume we have a set of words sorted in ascending lexicographical order:  aardvark ant bee cat cow dog horse llama sheep zebra  Given that we know the order of the English alphabet, it's easy to see that the list of animals comprising our input data is correctly sorted.  Now forget that you know anything at all about the English alphabet. Erase from your mind the fact that you know which characters comprise the alphabet (the problem statement doesn't bound the set of characters or make any guarantee that the set of words use all characters in the alphabet). Also, erase from your mind the fact that you know the order of the English alphabet.   Let's take the first word \"aardvark\". What does this tell us? It tells us that the characters \"a\", \"r\", \"d\", \"v\", and \"k\" are present in the alphabet. Does it provide any information that can be used to establish the order of these characters? NO! Remember that it's the order of the words in the list and thus comparisons between adjacent words in the list that provides clues about the order of the alphabet.  Okay, now let's look at the first and second words:  aardvark ant  What does this tell us? We see two new characters \"n\" and \"t\" by inspection of \"ant\". What's more we notice that the characters in the first column are both \"a\". So clearly the lexicographical ordering of these two words wasn't decided on the basis of the first column. Looking at the second column we note that the characters are different and correctly conclude that in our alphabet \"a\" proceeds \"n\".  How about the third column? Sorry, no more clues here. We know that the order of \"aardvark\" and \"ant\" was decided on the basis of the second column character and cannot deduce anything further by comparing the third column.  So on we go through the list of animal words... Below I've reproduced the lexicographically sorted list of words in the left column, and indicate the \"clues\" in the right column. For simplicity I'm not going to list new characters discovered in the alphabet but rather focus only on clues about the order of the characters in the alphabet.  Note that because you actually do know the order of the English alphabet, you can easily vet this information without doing insane mental gymnastics. Also note that by convention an order clue is indicated by an ordered pair representing an edge in a directed graph. For example (a,b) indicates a directed edge from tail vertex \"a\" to head vertex \"b\" indicating that \"a\" proceeds \"b\" in the alphabet.  aardvark       no order clues ant                (a,n) based on column 2 bee               (a,b) based on column 1 cat                (b,c) based on column 1 cow               (a,o) based on column 2 dog               (c,d) based on column 1 horse            (d,h) based on column 1 llama            (h,l) based on column 1 sheep           (l,s) based on column 1 zebra            (s,z) based on column 1    n   / a -> b -> c -> d -> h -> l -> s -> z   \\    o  Now remember that you know the order of the English alphabet and vet this graph. Makes sense right? For example we know that \"n\" comes after \"a\" as does \"b\" and \"o\". And clearly a -> b -> c -> d -> h -> l -> s -> z is correctly ordered.  Note that given our sorted list of animals we do not know the order of \"b\", \"n\" and \"o\". All we know is that they follow \"a\".  Also note that there are bunch of characters used in our list of animal words for which no clues were found. These are not show in the ASCII graph above. But these are really in the graph too (all with zero in-degree).  I seriously question the utility of doing a topological sort... It would produce a somewhat interesting result BUT is essentially meaningless except in the case that every vertex has out-degree one.  You could imagine a system that attempts to deduce ordering on an alphabet that exposes an interface DoesXProceedY(x, y) which returns YES, NO or KNOWN. Such a system could not (in general) use a topological sort of the graph to deduce the correct answer. Instead, it would need the graph topology.  Hope this helps."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Graph creation:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why dont we use Tries here"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"c++ code here.. for constructing DAG from pair of consecutive two strings. And topological sort over constructed DAG."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node[] create_graph(String[] list){ \n HashSet set = new HashSet(); \n for (int i = 0 ; i < list.length ; i++) \n  for (int j = 0 ; j < list[i].length() ; j++) \n   if (!set.contains(list[i].charAt(j))) \n    set.add(list[i].charAt(j))); \n int char_size = set.size(); \n Node[] G = new Node[char_size]; \n HashMap map = new HashMap(); \n int index = 0; \n for (int i = 0 ; i < list.length ; i++) \n  for (int j = 0 ; j < list[i].length() ; j++){ \n   Node[index] = new Node(list[i].charAt(j)); \n   map.put(list[i].charAt(j) , Node[index]); \n  } \n for (char C : set){ \n  for (int i = 0 ; i < list.length ; i++){ \n   boolean seen = false; \n   for (int j = 0; j < list[i].length() ; j++){ \n    if (list[i].charAt(j) == C) \n     seen = true; \n    else if (seen == true){ \n     map.get(list[i].charAt(j)).following.add(list[i].charAt(j)); \n    } \n   } \n  } \n } \n //Now the graph is ready , we need to to DFS on it , to topoligically sort it  \n Topological-Sort(G); \n //output the list of node's characters \n} \nchar[] Topological-Sort(Node[] G){ \n int time = 0; \n for (int i = 0 ; i < G.length ; i++) \n  if (!G[i].visited) \n   DFS-Visit(G[i] , time); \n //sort in DECREASING ORDER based on each Node's FINISH_TIME \n //we can use counting sort , as there aren't many nodes and the integers (time values) are not very large \n \n int max = Integer.MIN_VALUE; \n for (int i = 0 ; i < G.length ; i++) \n  if (max < G[i].finish_time) \n   max = G[i].finish_time; \n int[] counter = new int[max + 1]; \n for (int i = 0 ; i < G.length ; i++) \n  counter[G[i].finish_time]++; \n for (int i = 1 ; i < counter.length ; i++) \n  counter[i] += counter[i-1]; \n Node[] helper = new Node[G.length]; \n for (int i = counter.length - 1 ; i>= 0 ; i--){ \n  helper[counter[G[i].finish_time]] = G[i]; \n  counter[G[i].finish_time]--; \n } \n for (int i = 0 ; i < helper.length ; i++) \n  Node[i] = helper[i]; \n int left = 0 ; \n int right = Node.length; \n while (left < right){ \n  Node temp = Node[left]; \n  Node[left] = Node[right]; \n  Node[right] = temp; \n  left++; \n  right--; \n } \n char[] result = new char[G.length]; \n for (int i = 0 ; i < G.length ; i++) \n  result[i] = G[i].c; \n return result; \n} \nvoid DFS-Visit(Node n , int time ){ \n n.visited = true; \n n.visit_time = time; \n time++; \n for (int i = 0 ; i < n.following.size() ; i++) \n  if (!n.following.get(i).visited) \n   DFS-Visit(n.following.get(i) , time); \n time++; \n n.finish_time = time; \n} \n \n \nclass Node{ \n int visit_time , finish_time; \n boolean visited; \n ArrayList following; \n char c; \n public Node(char c){ \n  following = new ArrayList(); \n  visited = false; \n  this.c = c; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"By the way, given sequence {fac, faa, aac} is not sufficient to determine the complete alphabet ordering. To be specific, the order of \"f\" and \"c\" can't be determined."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sites.google.com/site/spaceofjameschen/home/stl/find-dictionary-order----google hash_map s;     set> orderPair;      for(int i = 0; i < dict.size(); ++i)     {         for(int j = 0; j < dict[i].size(); ++j){             s.insert(make_pair(dict[i][j], 0));         }     }      for(int i = 0; i < dict.size() - 1; ++i){         string str1 = dict[i];         string str2 = dict[i + 1];          int j = 0;         while(str1[j] == str2[j]){             j ++;         }         orderPair.insert(make_pair(str1[j], str2[j]));     }      bool changed = true;     while(changed)     {         changed = false;         for(auto it = orderPair.begin(); it != orderPair.end(); ++it){             int ord1 = s[it->first];             int ord2 = s[it->second];              if(ord2 != max(ord1 + 1, ord2)){                 changed = true;                 s[it->second] = max(ord1 + 1, ord2);             }         }     }      cout << \"----------------------------\" << endl;     for(auto it = s.begin(); it != s.end(); ++ it){         order.push_back(make_pair(it->first, it->second));     }      sort(order.begin(), order.end(),          [=](pair i, pair j)->bool         {return i.second < j.second;});"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Let set be {$, !, &, *, %, #} set of words  $, * !, & *, # &, $, @ #, @  Final answer is there are n positions that needs to be filled up with n alphabets in ascending order. We can give weights to each alphabets, finally all weights shud be 1 to n.  As you encounter each alphabet, give weights in increasing order. If the alphabet already has a weight in the previous word, then in this word it should start with that word and the remaining alphabets should have weights above this number. Eventually when u finish they ll have corresponding weights. After first word: $ -1, *-2  2nd word: !(not present in first word so give 1)-1, &(not present in first word so give 2)-2 After second word :  $-1, *-2 !-1, &-2  3rd word: *-2, #-3   (*-present in first with 2, pick the maximum value in whichever word it was there) After third Word:  $ -1, *-2 !-1, &-2 *-2, #-3   (*-present in first with 2, pick the maximum value in whichever word it was there)  4th word:  & - 2 (it was present in 3rd word with this value) $ -3(But it is already present with value 1. So wherever it was present make it 3, and the others after it in that word should increase by 2(3-1)) After 4th word: (The key is after each instance, each symbol should have the same weight in all the words ie, if $ is 3 in first word, it should be 3 in every word) $-3, *-4 !-1, &-2 *-4, #-5 &-2, $-3, @-4  5th word #-5, @-6 After 5th word: $-3, *-4 !-1, &-2 *-4, #-5 &-2, $-3, @-6  Now each of them have unique positions and the precedence order is !, &, $, *, #, @ with values 1, 2, 3, 4, 5, 6.  This is the algorithm. Haven??t thought about data structures to implement this. But I think it should be fairly simple."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This comment has been deleted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"You can build a directed graph and traverse it in order to find the precedence of characters. in this case e--->b .. similarly do for all other words in dictionary .."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"We can traverse the Sorted Dictionary just concerning ourselves with the first letter. This we we can build a LinkedHashMap.Traversing which will give us the Precedence Order."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"1. Extract all relation couples from dictionary. Remove duplicates. E.g.: dictionary (and, ant, bet) will result in (a,b), (d,t). 2. Build a digraph with letters as nodes and relation couples as directed edges. Label all nodes with 0. This digraph has no cicles. 3. Traverse the graph BFS starting from first node (the first letter of the first dictionary word) and \"relax\" the nodes as we encounter them. Relaxing here means to replace the node label with the BFS step. In the end each node will be labeled with the longest path length from start node. 4. If two nodes have same label then there is no solution. Otherwise the label order gives the alphabet order."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=18813688","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"60","title":"Consider an array of integers wherein each element is +1 or -1 its preceding element. Given a number, find the first occurence of this number (index) in this array without using linear search.  For example, consider the array : 4 5 6 5 6 7 8 9 10 9 10 (each element in this array is +1 or -1 its preceding element)  Input : 10 (find first occurence of 10 without using linear search) Output : 8","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"26","title":"Pseudocode: 1) Instantiate current pointer to first position in array 2) Calculate absolute difference between current value and expected value 3) If difference is 0, return current value, else, increment current pointer by the difference 4) Repeat steps 2-4 until difference is not zero and current pointer is less than length of array"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Basic idea: Instead of doing a linear search, take advantage of +1/-1 property => Two numbers X & Y need to be at last (X-Y) distance apart in the array.  Algorithm:  1) Runner iterates through the numbers (initialized to begin of array) 2) Calculate absolute difference between current value and lookup value  3) If (difference == 0) return Runner location, else, increment Runner value by the difference -> the optimization part and continue from step 2  C++ code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"int first_occurence(int * a, int n, int key) \n{ \n    if (!n) \n        return -1; \n     \n    int diff = abs(key - a[0]); \n     \n    while(diff < n) { \n      \n        if(a[diff] == key) { \n             \n            return diff; \n \n        } else { \n             \n            int t = abs(a[diff] - key); \n            diff = diff + t; \n        } \n    } \n     \n    return -1; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"int search(int arr[],int low,int high,int key) \n{ \n    if(low"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Given x (the number to be looked for) and array A with the +-1 property.  One algorithm you can do is.  Set guess_index = 0  Compute the difference D = |x - A[guess_index]|  if D == 0, then we have found it. Otherwise we can skip D-1 elements (as we know they can't be be equal to x), so set guess_index += D and repeat.  Pseudo code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Great question here.  So to avoid linear search, you simply employ the absolute value of the difference between your current element, and your guess.  This will put you at the earliest position that could hold the desired value.  If you find your position is outside of the array length, then the element cannot possibly exist inside of the given list.  Here is my solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"for (int i = 0; i < array.Count();) \n            { \n                if (array[i] < valuetofind) \n                    i += (valuetofind - array[i]); \n                else if (array[i] > valuetofind) \n                    i += (array[i] - valuetofind); \n                else \n                { \n                    Console.WriteLine(\"Found at \" + i); \n                    break; \n                } \n            }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"read first value index jump abs(given value - value read) and read value again until end_of_array or abs(given value - new value) is smaller than previous If abs(delta) smaller, then value occurs in that bounded range"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #include int input; int firstOccurence=INT_MAX;   int search(int start,int end,int* array){ // printf(\"start = %d \\n\",start); // printf(\"end = %d \\n\",end);    if(start>end){  return -1;  }    if(start == end && array[start] != input ){   return -1;  }    int midval= start+(end-start)/2;  int diff = (array[midval] - input);  if(diff==0){  printf(\"found\");  firstOccurence = (midval search(0,midval-1,array);  return midval;  }  diff = (diff<0)?-diff:diff;   int low = midval -2*diff;  int high = midval + 2*diff;   low=(low high=(high>end)?end:high;   //printf(\"am here\");   int left = search(low,midval,array);  int right = search(midval+1,high,array);     return (left<0)?right:left; }   void main(){  int N; scanf(\"%d\",&N); int i=0; int *array=(int *)malloc(sizeof(int)*N); for(i=0;i scanf(\"%d\",array+i); } scanf(\"%d\",&input);  int res=search(0,N-1,array); printf(\"%d\",firstOccurence);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class FindANumber { \n \n /** \n  * @param args \n  */ \n static int[] arr = {2, 3, 4, 5, 6, 5, 4, 5, 6, 7, 8, 7, 6, 5, 4, 3, 2}; \n static int value = 3; \n public static void main(String[] args) { \n     \n  getIndex(0,arr.length - 1 ); \n   \n } \n \n private static void getIndex(int i, int j) { \n   \n  if(arr[i] == value) { \n   System.out.println(i);System.exit(0); \n  } \n  else if(i == j) { \n   return; \n  } \n  else{ \n   int newIndexI = i + (j-i)/2; \n   if(isValidBlock(i,newIndexI)){ \n    getIndex(i,newIndexI); \n   } \n    \n   if(isValidBlock(newIndexI+1,j)){ \n    getIndex(newIndexI+1,j); \n   } \n     \n  } \n   \n   \n   \n } \n \n private static boolean isValidBlock(int i, int j) { \n  if ( 1 + (value-arr[i]) + (value-arr[j]) <= ((j-i)+1)) return true; \n  else return false; \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String args[]){         int a[]={4, 3, 2, 3, 2, 1, 0, 1, 2, 3, 4, 5};         int number =0;         int first =a[0];         int location =0;         location =find_first_occur( a,  number,first,location);         System.out.println(\"location =\"+location+\" element =\"+a[location]); }     public  static int  find_first_occur(int array[],int number,int first,int location){          if(first ==number){             System.out.println(\" same number ...and location =\"+location);             return location;         }         else if (number > first){             int diff = number -first;             location = location+diff;             first = array[location];             System.out.println(\"diff =\"+diff+\"  newFirst =\"+first+\"  location =\"+location);             location = find_first_occur(array,number,first,location);                      }         else{             int diff = first -number ;             location = location+diff;             first = array[location];             System.out.println(\"diff =\"+diff+\"  newFirst =\"+first+\"  location =\"+location);             location = find_first_occur(array,number,first,location);         }         return location;     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n \nint main() \n{ \n    int a[50],i,j=0,num,n,count; \n    printf(\"Enter total elements of array:   \\n\"); \n    scanf(\"%d\",&n); \n    for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Stupid question, consider this sequence:  int a[] = {0,1,0,1,0,1,0,1,0,1,0,1,0,1,2,1,0,1,0,1}; //good luck not doing a linear search."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.*; \nimport java.io.*; \nclass Find_No \n{ \n public static void main(String args[]) \n { \n  \n int arr[] = {1,2,1,2,3,4,3,4,5,4}; \n int item; \n System.out.print(\"enter the item to be searched\"); \n Console con  = System.console(); \n item = Integer.parseInt(con.readLine()); \n HashMap map = new HashMap(); \n for(int i=arr.length-1;i>=0;i--) \n { \n  map.put(arr[i],i); \n } \n System.out.println(\"location of item is\"+map.get(item)); \n } \n  \n  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int find(int[]a, int num){ \n int len = a.length; \n int current = 0; \n while(current>=0 || current"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.io.*; \nclass Find_No2 \n{ \n public static void main(String args[]) \n { \n  int arr[] = {0,1,0,1,0,1,2,1,0}; \n  int count,var=0,i=1; \n  System.out.print(\"Enter a item to be searched\"); \n  Console con = System.console(); \n  int item = Integer.parseInt(con.readLine()); \n  count = item-arr[0]; \n  if(count==0) \n  { \n   \n   System.out.println(\"item is at 0 index\"); \n   System.exit(0); \n  } \n  else \n   while(i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Let's say the first element in the array  is 'A', the number to be found is 'Num' . Then ,  Loop until   Sum of(Difference of each element in the array with the next element) = (A - Num)  Let's say : 2, 3, 4, 5, 6, 5, 4, 5, 6, 7, 8  To find 8 :  A- Num = 2 - 8 = -6 (2-3) + (3 -  4) +( 4 - 5 )+ (5 - 6 ) + (6 - 5) + (5 - 4) + (4 - 5) + (5 - 6) + (6 - 7) + (7 - 8) = -6  The number is 8 since the difference -6 is found."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#define Max 10 // Array Size \n \nvoid Search(int A[], int key) \n{int i=0,diff=0; \nwhile(i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#define Max 10 // Array Size \n \nvoid Search(int A[], int key) \n{int i=0,diff=0; \nwhile(i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nusing namespace std; \n \nint main() \n{ \n    int a[10]; \n    for(int i=0;i<10;i++) \n    cin>>a[i]; \n     \n    for(int i=0;i<10;) \n    {                   \n    if(a[i]==10){ \n    cout<<\"Found at: \"<<10) \n    i=a[i]-10; \n     \n    else i=10-a[i]; \n    } \nreturn 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int searchIncDecByOne(int *arr, int size, int Num) {  int i = 0;  if (!arr || size <=0)   return -1;  while (i >= 0 && i < size) {   if (arr[i] == Num)    return i;   if (arr[i] < Num)    i +=Num-arr[i];   else    i -=arr[i]-Num;  }  if (i < 0 || i >= size)   return -1; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Duplicate question: refer /question?id=18136672"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int guesser(int a[],int size,int key){ \n int guessIndex = 0; \n while(a[guessIndex] != key && guessIndex < size){ \n  if(key > a[guessIndex]) \n   guessIndex += key - a[guessIndex]; \n  else \n  { \n   guessIndex += a[guessIndex] - key; \n  } \n                 \n } \n        if(guessIndex >= size)  return -1; \n return guessIndex; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I implemented a recursive function for the solution. The initial guessIndex =0 and each recursive call, i calculate the offset for a possible jump"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) {    int[] a = { 5, 4, 3, 2, 3, 4, 5, 6, 5, 6, 7, 8 };    findPosition(a, 6, 0);   }   /* default */static void findPosition(int[] a, int ele, int i) {    if (i > a.length - 1) {    System.out.println(\"ele not found\");    return;   }    if (a[i] == ele) {    System.out.println(i);    return;   }    // Assumption diff is positive..   int diff = 0;    diff = Math.abs(ele - a[i]);    findPosition(a, ele, diff + i);   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is sort of interpolation search with average/best case complexity of O(lg(lgn)) iff elements are uniformly distributed. but in worst case the complexity meets O(n). I come up with the following code to solve this problem.   Editing it to mention the test-cast where the complexity meets O(n)   in the following array search for 7."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int findFirstPosition(int *a,int length,int num) \n{ \n int i=1; \n if( (num%2==0 && a[0]%2==0) || (num%2!=0 && a[0]%2!=0) ) \n  i=0; \n int diff; \n while(i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My Solution can be, lets take the number series 2 1 2 1 2 3 4 And if we want to find out the position of 3, 1) Start with 2, since 3-2 =1, move 1 position and 2) Find the difference, 3-1 = 2, so move 2 positions. 3) next 3-1  = 2, again move 2 positions 4) Now 3-3 = 0, so we got the solution and its not a linear search.  Hope this should work for all the series"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Sequence { \n \n private int[] content = new int[]{9,10,9,8,7,6,7,8,9,10,9,10,9}; \n  \n public Sequence() \n { \n } \n  \n public void process(int value) \n { \n  int count = 0; \n  int i = 0; \n  while( i< content.length) \n  { \n   if(content[i] == value) \n   { \n    ++count; \n    i = i+2; \n   } \n   else \n   { \n    int diff = Math.abs(value - content[i]); \n    i = i + diff; \n   } \n  } \n   \n  System.out.println(count); \n } \n  \n public static void main(String[] args) { \n   new Sequence().process(6); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hi, this is python example:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(logn) solution.  Sharing it via CodeBunk so you could run the code as well.  codebunk.com/bunk#-Ix38C2CNuBKt-JHK5Hf"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Tweak the merge sort's merge part such that it stores the earliest location. Time O(logN) since merge takes only O(1) and split takes O(logn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static int Search(int[] arr, int value) \n{ \n    for (int i = 0; i < arr.Length; i += Math.Abs(value - arr[i])) \n    { \n        if (arr[i] == value) return i; \n    } \n    return -1; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"sites.google.com/site/spaceofjameschen/home/sort-and-search/find-the-first-occurence-of-this-number-index-in-this-array-without-using-linear-search-amazon"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5684278553739264","download_status":"DOWNLOAD_DONE","votes":"5","answersCount":"72","title":"Given s string, Find max size of a sub-string, in which no duplicate chars present.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"public static String longestSubstringUnrepeatedChar(String inputString) { \n        String longestSoFar = \"\"; \n        String longestSubstringResult = \"\"; \n        if (inputString.isEmpty()) { \n            return \"\"; \n        } \n        if (inputString.length() == 1) { \n            return inputString; \n        } \n        Map map = new HashMap(); \n        for (int i = 0; i < inputString.length(); i++) { \n            char currentCharacter = inputString.charAt(i); \n            if (longestSoFar.indexOf(currentCharacter) == -1) { \n                if (!map.containsKey(currentCharacter)) { \n                    map.put(currentCharacter, i); \n                } \n                longestSoFar = longestSoFar + currentCharacter; \n            } else { \n                longestSoFar = inputString.substring(map.get(currentCharacter) + 1, i + 1); \n                map.put(currentCharacter, i); \n            } \n            if (longestSoFar.length() > longestSubstringResult.length()) { \n                longestSubstringResult = longestSoFar; \n            } \n        } \n        return longestSubstringResult; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Iteration 0: \n------------ \n | \n\"AABC\" \nwindow = 0; \nsart =0; \ni = 0 \n \nIteration 1: \n------------- \n  | \n\"AABC\" \nwindow = 1; (1 -0) \nstart = 1; duplicate occurs so move it \ni = 1 \n \nIteration 2: \n------------- \n   | \n\"AABC\" \nwindow = 1; \nstart = 1;  \ni = 2 \n \nIteration 3: \n------------- \n    | \n\"AABC\" \nwindow = 3; (i - start) +1 \nstart = 1;  \ni = 3  // we are reaching end of string so check for last"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Similar to windowing solutions suggested in this thread, but a little better then them.  The idea is we do not need to move back the window to previous location of duplicate found in current window. Rather, we can continue from current location without ever moving back. Hence, can attain O(n) in true sense. This is on the lines of Knuth-Pratt-Morris algo."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int maxSizeNoDups(String s) {      int maxSize = 0;         for (int i = 0; i < s.length(); i++) {    int currentSize = 0;        for (int j = i; j < s.length(); j++) {     if (j != i) {      if (s.substring(i, j).contains(\"\" + s.charAt(j)))       break;     }     currentSize++;     maxSize = maxSize > currentSize ? maxSize : currentSize;         }   }      return maxSize;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int maxSizeNoDups(String s) { \n   \n  int maxSize = 0; \n   \n   \n  for (int i = 0; i < s.length(); i++) { \n   int currentSize = 0; \n    \n   for (int j = i; j < s.length(); j++) { \n    if (j != i) { \n     if (s.substring(i, j).contains(\"\" + s.charAt(j))) \n      break; \n    } \n    currentSize++; \n    maxSize = maxSize > currentSize ? maxSize : currentSize; \n     \n   } \n  } \n   \n  return maxSize; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A simple O(n?) solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Now an O(n) time + O(n) space"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package Stringissues; \n \nimport java.util.HashMap; \nimport java.util.Map; \n \npublic class StringIssues { \n // Given s string, Find max size of a sub-string, in which no duplicate \n // chars present. \n // String AlphaBetaCharlie \n public static void main(String[] args) { \n  String str = \"CharliedaadaabcdefghijklmnmbrijeshoAlphaBeta\"; \n  HashMap hm = new HashMap(); \n  String targetString = str.toLowerCase(); \n  char[] charArray = targetString.toCharArray(); \n  int len = charArray.length; \n  int stringlength = charArray.length; \n \n  String finalAnswer = \"\"; \n  int count, j = 0; \n  StringBuilder temp = new StringBuilder(); \n  String temp1 = new String(); \n  for (int i = 0; i < len; i++) { \n   j = i + 1; \n \n   if ((!hm.containsKey(charArray[i])) \n     && (((stringlength - 1) + j) == len)) { \n    hm.put(charArray[i], \"\"); \n    temp.append(charArray[i]); \n \n   } else { \n    hm.clear(); \n    if (finalAnswer.length() < temp.length()) \n     finalAnswer = temp.toString(); \n    if (temp.length() > 0) { \n     temp.setLength(0); \n    } \n \n   } \n   --stringlength; \n \n  } \n  System.out.println(finalAnswer); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \nusing namespace std; \n \n \nbool duplicate(string com) \n{ \n for (int k = 0; k < com.length()-1; ++k) \n { \n  for (int z = k+1; z < com.length(); ++z) \n  { \n   if (com[k] == com[z]) \n    return true; \n  } \n } \n return false; \n} \n \n \nint main() \n{ \n std::string content = \"ALA MA KOTA\"; \n int s = content.length(); \n std::string cur(\"\"), longest(\"\"); \n cur += content[0]; \n \n for (int k = 1; k < s; ++k) \n { \n  cur += content[k]; \n  if (!duplicate(cur)) \n  { \n   if (cur.length() > longest.length()) \n    longest = cur; \n  } \n  else if (k < s-1) \n  { \n   cur = \"\"; \n   cur += content[k]; \n  } \n } \n \n cout << longest << endl; \n \n system(\"pause\"); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java solution with O(N) run time and O(1) space complexity."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution, time complexity O(N) space O(1):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// A DP solution. \n \n//Given s string, Find max size of a sub-string, in which no duplicate chars present. \n \npublic class StringUtil { \n \n public static String maxNoDupSubstr(String s) \n { \n  if(s.length() == 0 || s == null) \n  { \n   return s; \n  } \n   \n  // hash map : character -> character's most recent seen index. \n  int[] recent = new int[256]; \n   \n  for (int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"all these O(1) space, O(strlen) time solutions.... Wow!  Now waiting for O(1) time and space solutions to be posted :P"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static String longestSubstringUnrepeatedChar(String inputString) { \n        String longestSoFar = \"\"; \n        String longestSubstringResult = \"\"; \n        if (inputString.isEmpty()) { \n            return \"\"; \n        } \n        if (inputString.length() == 1) { \n            return inputString; \n        } \n        Map map = new HashMap(); \n        for (int i = 0; i < inputString.length(); i++) { \n            char currentCharacter = inputString.charAt(i); \n            if (longestSoFar.indexOf(currentCharacter) == -1) { \n                if (!map.containsKey(currentCharacter)) { \n                    map.put(currentCharacter, i); \n                } \n                longestSoFar = longestSoFar + currentCharacter; \n            } else { \n                longestSoFar = inputString.substring(map.get(currentCharacter) + 1, i + 1); \n                map.put(currentCharacter, i); \n            } \n            if (longestSoFar.length() > longestSubstringResult.length()) { \n                longestSubstringResult = longestSoFar; \n            } \n        } \n        return longestSubstringResult; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Requirement: 1. Find Max size of substring with no duplicates. 2. No need to find the substring, just its length. Have verified with this source string \"asdfabb12345hh123456789hh\" result=10, pretty much covers boundry conditions. How this works ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My updated code, Requirement: 1. Find Max size of substring with no duplicates. 2. No need to find the substring, just its length. Have verified with this source string \"asdfabb12345hh123456789hh\" result=10, pretty much covers boundry conditions. How this works ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static String maxSubStringWithoutDuplicate(String s){ \n    //    Given s string, Find max size of a sub-string, in which no duplicate chars present. \n        if(s==null || s.isEmpty()){ \n            return s; \n        } \n        Map map = new HashMap(); \n        String max = \"\"; \n        int curLen = 0; \n        int start = 0; \n        for(int i=0; i max.length()){ \n                    max = s.substring(start, start+curLen); \n                } \n                if(curLen > map.get(s.charAt(i))-i){ \n                    curLen-= map.get(s.charAt(i))-start; \n                    start = map.get(s.charAt(i))+1; \n \n                } \n                else{ \n                    start = i; \n                    curLen = 0; \n                } \n                map.put(s.charAt(i), i); \n                 \n            } \n        } \n        return max; \n         \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution:  public static int maxSize(String S){            int len = 0;      int maxLen = 1;      HashMap theMap = new HashMap();            for(int i=0; i < S.length(); i++){        if(theMap.containsKey(S.charAt(i))){        if(maxLen < len){         maxLen = len;        }        theMap.clear();        len=0;       }       else{        theMap.put(S.charAt(i), 1);        len++;       }             }              if(maxLen < len){    maxLen = len;   }            return maxLen;     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static string MaxSizeSubstringUniqueChars(string input) \n{ \n if (string.IsNullOrEmpty(input) == true) \n { \n  throw new ArgumentNullException(\"Empty/null string\"); \n } \n  \n Dictionary charMap = new Dictionary(); \n int start = 0; \n string currentSubstring = string.Empty; \n string maxSubstring = string.Empty; \n  \n for (int index = 0; index < input.Length; index++) \n { \n  char current = input[index]; \n   \n  if (charMap.ContainsKey(current) == false) \n  { \n   charMap.Add(current, index); \n  } \n  else \n  { \n   currentSubstring = input.Substring(start, index - start); \n    \n   if (currentSubstring.Length > maxSubstring.Length) \n   { \n    maxSubstring = currentSubstring; \n   } \n    \n   start = charMap[current] + 1; \n   index = start - 1; \n   charMap.Clear(); \n  } \n   \n  if (index + 1 == input.Length) \n  { \n   currentSubstring = input.Substring(start, input.Length - start); \n   if (currentSubstring.Length > maxSubstring.Length) \n   { \n    maxSubstring = currentSubstring; \n   } \n  } \n } \n  \n return maxSubstring; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my working code. It works for all the strings given above in comments.   public class DupCheck {        public static void main(String args[])   {  int count=0;  String name = \"efabcah123456\";  boolean duplicate = false;  int currentLength = 0;  int minIndex = 0;  int maxIndex = 0;  int maxLength = 0;  int currentIndex = 0;  String stringChars = \"\";    name = name.trim().toLowerCase();    System.out.println(\"Length = \"+stringChars.length());    while(count     for(int charCount = 0; charCount < stringChars.length();charCount++) {    if(stringChars.charAt(charCount) == name.charAt(count)) {     duplicate = true;     System.out.println(\"Duplicate char \"+name.charAt(count)+\" at pos \"+(count+1));     break;    }   }      if(!duplicate) {    stringChars += name.charAt(count);    System.out.println(\"String is \"+stringChars);         if(stringChars.length() > (maxIndex-minIndex)) {      maxIndex = currentIndex+stringChars.length();      minIndex = currentIndex;     }            count++;   } else {    count = currentIndex+1;    maxLength = currentLength;        if(stringChars.length() > (maxIndex - minIndex)) {     maxIndex = currentIndex+stringChars.length();     minIndex = currentIndex;    }        currentLength = 0;    currentIndex = currentIndex+1;        duplicate = false;    stringChars = \"\";       }            }  System.out.println(\"Sub string with no duplicate letters is \"+name.substring(minIndex,maxIndex));    System.out.println(\"Length of sub string is \" + (maxIndex-minIndex));  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class MaxSubStringNoDuplicate {  public static void main(String[] args) {   Scanner sc = new Scanner(System.in);      System.out.println(\"Ener String\");   String  str = sc.nextLine();   int limit = 0;   char[] ch ;   ch = str.toCharArray();         for(int i =0;i   for(int l=i+1;l>0;l--){     if(l!=0){     if(ch[l-1]==ch[i+1])      limit = i;         }    }       }      System.out.print(\"Max SubString Wih No Duplicates    \");   System.out.println(str.substring(0,limit+1));         }         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"net. solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Scan the string from left to right and keep an array for saving position a character last encountered during the scan. 2. While scanning before updating the lastSeen array check if the character already encountered in the current scan so far.  3. If the character was not encountered that means you can add this to the longest SubString found so far.  4. Otherwise the character already encountered in the current scan which means we have encountered a duplicate. So, we ignore the substring from beginning to this position as this makes the future sequence containing duplicates. 5. While calculating longest substring so far encountered keep the tracking for absolute longest one."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my solution: -- Java version."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Construct a suffix tree. Find the longest path in the suffix tree that doesn't have any overlap in characters.  For example ababc                            Null                            /  |   \\                          c   b  ab                                /  \\        /      \\                              abc c   abc  c we can see that the last path yields abc our req soln.  There are good O(n) ways to construct suffix tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Recursive approach"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.HashMap; \nimport java.util.Map; \n \npublic class SubStringWithNoDupChars { \n \n public static void main(String[] args) { \n  String s = \"sdgauravagarwaleabcdecafsg\"; \n  int globallen = 0;                               //Global Max Length \n  int locallen = 0;                                //Local Max length \n  int r = 0;                                       //Last duplicate character index \n  Map map = new HashMap(); \n  char[] ca = s.toCharArray(); \n  for (int i = 0; i < ca.length; i++) { \n   if (!map.containsKey(ca[i]) || map.get(ca[i]) < r) { \n    locallen++; \n   } else { \n    if (locallen > globallen)  globallen = locallen; \n    locallen = i - map.get(ca[i]); \n    r = map.get(ca[i]); \n   } \n   map.put(ca[i], i); \n  } \n  System.out.println(globallen); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) { \n  String s = \"abcceddefaqqabcddddeeabcdefghipp\"; \n   \n  HashMap hashMap = new HashMap(); \n   \n  String maxSubstring = \"\"; \n  int maxSubstringLength = 0; \n  int i = 0; \n  for (int j = 0; j < s.length(); j++){ \n      \n   // if the character does not exist then store the character as well as it's position \n   if (hashMap.get(s.charAt(j)) == null) { \n    hashMap.put(s.charAt(j), j); \n   } else { \n     \n    // have i point a the new starting point \n    i = hashMap.get(s.charAt(j)) + 1; \n     \n    // remove the hashed value \n    hashMap.clear(); \n   } \n    \n   if (maxSubstringLength < getSize(i,j)) { \n    maxSubstringLength = getSize(i,j); \n    maxSubstring = s.substring(i, j+1); // inclusive  \n   } \n  } \n   \n  System.out.println(maxSubstring); \n } \n  \n private static int getSize(int i, int j) \n { \n  return Math.abs(i-j); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Modify Kadane's algo to keep track of unique chars instead of sums. Have a max_so_far variable with the longest substring found and the variables which hold the indexes. Have another variable max_current and another 2 variables for indexes. Iterate over the array and update the max_current variable. Once you hit a duplicate if max_current is greater than max_so_far update max_so_far and the indexes and clear  max_current. Time complexity O(N) space complexity O(1)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Here is my approach: \nIt as time complexity O(N) and space complexity O(size of window) \n \nI am using a hash table to track characters in current window.  \nIf an duplicate occurs than I just move start position to previous index of this character(Hash table has previous index). And clear hash table, for next window. \nCheck if previous window size is smaller than (start - current pointer ), than just replace window with (start - current pointer ). \n \nHere is implementation in java: \n public static int find(String source){ \n  int window = 0; \n  int start = 0; \n  int i =0; \n  HashMap map = new HashMap(); \n  while( i < source.length()){ \n   if(map.containsKey(source.charAt(i))){  \n    int currentWindow = i-start; \n    if(window < currentWindow){ \n     window = currentWindow; \n    } \n    start = i; \n    map.clear(); \n   } \n   if(i+1 == source.length()){ \n    int currentWindow = i-start +1; \n    if(window < currentWindow){ \n     window = currentWindow; \n    } \n    return window; \n   } \n   map.put(source.charAt(i), i); \n   i++; \n  }  \n  return 0; \n }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15192666","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"75","title":"there are two arrays named A and B , both of them with k size, they are sorted in acsending order. could you find k-th  smallest combinations of ai, bj -->(ai+bj) . 0<=i,j for example: a = {1, 3, 6} b = {4, 5, 6} then we will get 1 + 4 = 5, 1 + 5 = 6, and 1 + 6 = 7,the result is 5,6,7. does it make you understood? and could anybody do it with less time and space complexity.  Hi guys, thanks for all your suggestions and idea, and finally I get my answer and here are my c++ codes, time complexity is O(k*lgk), and space complexity is O(k):  #include using namespace std;  typedef struct node{  int row;  int col;  int data; }Node, *PNode;  void swap(PNode &a, PNode &b) {  PNode temp = a;  a = b;  b = temp; } void adjust_min_heap(PNode *bin, int i, int k) {  int left  = 2 * i + 1;  int right = 2 * i + 2;  int min_index;  if(left < k && bin[left]->data < bin[i]->data) {   min_index = left;  } else {   min_index = i;  }  if(right < k && bin[right]->data < bin[min_index]->data) {   min_index = right;  }  if(min_index != i) {   swap(bin[i], bin[min_index]);   adjust_min_heap(bin, min_index, k);  } }  void build_min_heap(PNode *bin, int k) {  for(int i = k / 2; i >= 0; i--) {   adjust_min_heap(bin, i, k);  } }  int *get_k_th_minimum(int *a, int *b, int k) {  PNode *bin = (PNode*)malloc(sizeof(PNode) * k);  int *result = (int*)malloc(sizeof(int) * k);  memset(result, 0, sizeof(int) * k);  int i;  int count = 0;  for(i = 0; i < k; i++) {   bin[i] = (Node*)malloc(sizeof(Node));   bin[i]->row = i;   bin[i]->col = 0;   bin[i]->data = a[i] + b[0];  }  build_min_heap(bin, k);  while(count < k) {   result[count++] = bin[0]->data;   bin[0]->col += 1;   bin[0]->data = a[bin[0]->row] + b[bin[0]->col];   adjust_min_heap(bin, 0, k);  }  for(i = 0; i < k; i++) {   free(bin[i]);  }  free(bin);  return result; }  void main() {  int a[] = {1, 2, 4};  int b[] = {5, 9, 11};  int k = 3;  int *p = get_k_th_minimum(a, b, k);  for(int i = 0; i < k; i++) {   cout << p[i] << \" \";  }  free(p);  getchar(); }","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Think of a k by k matrix where each element at (i,j) is the sum of item i from the first array and item j from second array. The row and coluns of this matrix are in increasing order. The idea is to have a pointer for each row in the matrix indicating the next element to consider from the row. We take the smallest element from all rows, and move the pointer for the row we took the item from forward.  This can be implemented using a heap of size k, which is initialized with the element of the first column of the matrix.  We perform k steps where we pop the min element from the heap and replace it with the next element from its row in the matrix. Complexity: time O(k log k), space O(k)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"check this link... nicely explained  The best solution, but non-trivial, O(lg m + lg n): Although the above solution is an improvement both in run time and space complexity, it only works well for small values of k, and thus is still in linear run time. Could we improve the run time further?  The above logarithmic complexity gives us one important hint. Binary search is a great example of achieving logarithmic complexity by halving its search space in each iteration. Therefore, to achieve the complexity of O(lg m  + lg n), we must halved the search space of A and B in each iteration.  We try to approach this tricky problem by comparing middle elements of A and B, which we identify as Ai and Bj. If Ai is between Bj and Bj-1, we have just found the i+j+1 smallest element. Why? Therefore, if we choose i and j such that i+j = k-1, we are able to find the k-th smallest element. This is an important invariant that we must maintain for the correctness of this algorithm.  Summarizing the above, Maintaining the invariant     i + j = k ??C 1,  If Bj-1 < Ai < Bj, then Ai must be the k-th smallest, or else if Ai-1 < Bj < Ai, then Bj must be the k-th smallest.  If one of the above conditions are satisfied, we are done. If not, we will use i and j as the pivot index to subdivide the arrays. But how? Which portion should we discard? How about Ai and Bj itself?  We make an observation that when Ai < Bj, then it must be true that Ai < Bj-1. On the other hand, if Bj < Ai, then Bj < Ai-1. Why?  Using the above relationship, it becomes clear that when Ai < Bj, Ai and its lower portion could never be the k-th smallest element. So do Bj and its upper portion. Therefore, we could conveniently discard Ai with its lower portion and Bj with its upper portion.  If you are still not convince why the above argument is true, try drawing blocks representing elements in A and B. Try visualize inserting blocks of A up to Ai in front of Bj-1. You could easily see that no elements in the inserted blocks would ever be the k-th smallest. For the latter, you might want to keep the invariant i + j = k ??C 1 in mind to reason why Bj and its upper portion could never be the k-th smallest.  On the other hand, the case for Ai > Bj is just the other way around. Easy.  Below is the code and I have inserted lots of assertion (highly recommended programming style by the way) to help you understand the code. Note that the below code is an example of tail recursion, so you could technically convert it to an iterative method in a straightforward manner. However, I would leave it as it is, since this is how I derive the solution and it seemed more natural to be expressed in a recursive manner.  Another side note is regarding the choices of i and j. The below code would subdivide both arrays using its array sizes as weights. The reason is it might be able to guess the k-th element quicker (as long as the A and B is not differed in an extreme way; ie, all elements in A are smaller than B). If you are wondering, yes, you could choose i to be A??s middle. In theory, you could choose any values for i and j as long as the invariant i+j = k-1 is satisfied.  leetcode.com/2011/01/find-k-th-smallest-element-in-union-of.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i didn't get the question"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If I am getting question right, you mean that of all the K*K pairs generated by both arrays, where one element is from array A and other element is from array B, we have to find Kth smallest pair. --------------------------------- (Make maxheap of size K.)  For each pair generated by arrays,calculate a + b, If a + b is less than top of maxheap then replace it with top and heapify. else ignore it. At the end, top of the maxheap will give kth smallest a+b. If you want you can also store index numbers of elements.  Time Complexity - O(n*n logn) Space Complexity - O(k)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"With this class you can get the sum of the smallest kth element or the combination that composes it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int[] find(int[] a, int[] b) { \n        if (a == null || b == null || a.length != b.length) return null; \n         \n        int k=a.length; \n         \n        if (k==0) return null; \n         \n        int i=0; \n        int j=0; \n         \n        int[] r = new int[k]; \n        int h = 0; \n         \n        r[h++]=a[i] + b[j]; \n        System.out.println(a[i]+\"+\"+b[j]); \n         \n        while (h a[i]+b[j+1]) { \n                j++; \n            } else { \n                i++; \n            } \n            r[h++]=a[i] + b[j]; \n            System.out.println(a[i]+\"+\"+b[j]); \n        } \n         \n        return r; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be done in O(1). we can see that for any index x, a[x]+b[x] will be greater that all a[i]+b[j] where 0 \n   \n    \n   -  \n     Gopal \n     on January 16, 2013 Edit | Flag  \n    \n    \n   Reply"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This comment has been deleted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorry, I still do not understand the question. Can you please write an example clearly?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int k_smallest_combinations(int A1[], int A2[], int l1, int l2, int k){ \n    Min_Heap heap(l1);//l1 is size of heap \n    int count=1; \n    for(int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's the solution I gave implemented in python. It works even for input lists of different sizes (e.g. one list with \"m\" elements and a second list with \"n\" elements) and any k-th largest sum:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think having an index bookkeeper array for both of the input arrays would result a linear algorithm. Take the given example. A: {1, 3, 6} B: {4, 5, 6} index_A:{0, 0, 0}      // indicating the next index of its potential pair in the opposite array. index_B:{0, 0, 0}      // same.  Each time the comparing two combinations would be taken  from index_A and index_B: {index_A[i],  index_B[j+1]} and {index_A[i+1],  index_B[j]}    Step 1: get min{(A[0], B[0]), (A[0], B[0]) }               get A[0] and B[0]. and update the index array to be:               index_A:{1, 0, 0}               index_B:{1, 0, 0}    Step 2: get min{(A[0], B[1]),  (A[1]), B[0])}     // the index pair are the crossing pair of the index array               here we have min{(1, 5), (3, 4)}, since (1, 5) wins, we need to update the index array to be:               index_A:{2, 0, 0}               index_B:{1, 0, 0} Step 3: get min{A[0], B[2]), (A[1], B[0)};      // the index pair are the crossing pair of the index array              we have min{(1, 6), (3, 4)}, it can be either. we pick (1, 6), and update the index array to be:               index_A:{3, 0, 0}           //here we have the potential pair of the first element of A to be 3, this indicates                                                                //this element is out of game.               index_B:{1, 0, 0} continue until we find the k-th combination at step \"k\""},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hope I am not mistaken. but if the two arrays A,B are in ascending order, why not compare the first element of the two then the smallest k combonations will be the frist element added with elements of the other array?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Check this complexity will be k"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Test{   public static void main(String args[]){   int[] a = {1,2,3,4,5,6};   int[] b = {-1,2,4,12,13,15};    int[] k = findK(a, b);       for(int c : k){    System.out.println(c + \" \");   }  }    public static int[] findK(int[] a, int[] b)  {   if(a == null || b == null || a.length != b.length)    return null;     int[] result = new int[a.length];   int i = 1;   int j = 1;    for(int k = 1; k < result.length; k++){    int sumWithA = a[0] + b[j];    int sumWithB = b[0] + a[i];     if(sumWithA <= sumWithB){     result[k] = sumWithA;     j++;    }else{     result[k] = sumWithB;     i++;    }    }   return result;    } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Start from ptr1 at A[0], and ptr2 at B[0].   If ptr1 is at A[i] and ptr2 is at B[j], increase ptr1 by one if A[i+1] + B[j] < A[i] + B[j+1], else increase ptr2 by one, recording the min at each step.  That is it. Kind of like merge sort, accept you are not merging or sorting :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can we do it like this:  First generate all the A[i] + B[j] combinations as suggested in the question. And then build a max heap.  Now remove the top (K*K - K) elements from the heap....and every time you remove, heapify the heap...So at the end, you will get the Kth smallest element at the top.  Hope it helps.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I'd use the priority to help computation. Everytime pop an answer with index pair(i,j) (which is the smallest sum now), and add the (i,j+1) and (i+1,j) pair into the heap."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think we can solve this problem in linear time as follows:  Since we know that the arrays are sorted, so we can assume that the first element(smallest emelent) of an array will give us the min combination when combined with any element of second array. So, we bookmark these 2 elements of both arrrays.  int i = 0; j =0;  1. Print A[0] and B[0], of course..this is the min combination so far. 2. If (A[0] + B[j+1] < A[i+1] + B[0]), then print A[0]+B[j+1] and j++; 3. If (A[i+1] + B[0] < A[0] +B[j+1]), then print A[i+1] + B[0] and i++; 4. Else .... both are equal, print A[0] + B[j+1] and A[i+1] + B[0] and i++, j++  repeat 1,2,3,4 K time...you wil get the result..I have tested on some test case...Reply if it works for you..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"scala> Array(1,2,3).zip(Array(4,5,6)).map(e => e._1 + e._2) \nres16: Array[Int] = Array(5, 7, 9)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"if my understanding is right, we can have two pointers and move forward gradually. if list1[i + 1] > list2[j+1] then we pick up j to increase by one since we need a new combo."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"public static void main(String args[]){      int[] a = {1, 3, 6};   int[] b = {4, 5, 6};   int k;   for(int i=0;i   for(int j=0;j         k = a[i]+b[j];     System.out.println(a[i] + \"+\" + b[j] + \"=\" + k);              }   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"since i <= j and all elements are in order the order will be:  (a[0] + b[0]), (a[0] + b[1]), (a[1] + b[1])...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"I think this can be done in O(k) time: Start with (a0, b0) which is the least pair. The next least pair is either (a0, b1) or (a1, b0). If it is (a0, b1) then the next least is either (a1, b1) or (a0, b2) etc. You only need to do this k times to get the desired pair."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=1606","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"70","title":"Here is a tree. It's a binary tree but in no particular order.  How do you write this tree to a file so that it can be reread in an reconstructed exactly as shown?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"An ordered (pre/post/in) works only for a complete binary tree. For the question, perhaps what they want is to store each element (say at i index) in an array and it's child at 2i and 2i+1 position. If it does not have a left/right child, leave the corresponding index empty.From this array, it is easy to reconstruct any binary tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I believe storing the pre-order and in-order sequence is the optimal solution: it takes roughly 2*n bytes to store, where n is the number of nodes in the tree, and it removes the complication in dealing with unbalanced or incomplete trees. Here's an example:Say we're given the following sequences (completely arbitrary):Pre-order: abdecf In-order: dbeafcTo reconstruct the tree, we'd read these two lines into two arrays. In a recursive function, we examine the first element of the pre-order array, which is obviously the root node of the current tree we're building. We locate its position in the in-order array, in this case, array index 3. As a result, we can divide the in-order array into two parts: the left branch (dbe) and the right branch (fc). Knowing that, we also know the \"length\" of those two branches, which we can use to extract bde and cf from the pre-order array. To finish it off, we set the left branch to be the result of calling the function recursively on pre-order bde, in-order dbe and the right branch to be the result of calling the function recursively on pre-order cf, in-order fc.Try it out -- it works. :D"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Karthik, Can you tell me solution for this?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do an inorder traversal and write as you read...For example,    +  -   * 3 5 7 8would be stored as+-35*78"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"inorder? How it is going to work for nodes with number alone?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the node's data is an object, I would use a hashing function. If the node contains data of a primitive type, then use ascii characters since an ascii is 1 byte."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just for clarification...By node's data as an object, I mean if the data type is abstract."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"When the data type is abstract, using a hashing function allows you to store a hash table into the file where the hash maps to a value. This way, the value is stored once if it has duplicates."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Also, if the integer is within range for ascii, then store characters. If not, then store data based on precision."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Also, the sequence above is preoder, not inorder."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"preorder*"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How aboutNOTE: Binary tree. not BST.         7      /         5     14    /   10   /  1  2Jack!!! Can you tell?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What I did was: Do a preorder traversal. Take string along with you, and as you go left add a 1 to it and right add a 0 to it.  Then at each node you'll have node and associated string, write it to file.  Then you can read this file back in and know where the nodes go and since we are doing preorder traversal, you can be sure the parent will come before the child when reading in the file .  Recruiter said this is the first time he saw this answer in two days of interviewing... so wondering if there was something better, but i can't see one."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I was assuming the BT is complete. If the BT isn't complete, then preorder without metadata will fail. It would have been good to clarify this w/ the interviewer. I would also ask the interviewer what type of data the binary tree is used for, since certain optimizations are possible?In that case, I would try writing name/value pairs by using a preorder traversal and converting primitive types into strings.For example...    *  -   + 72   33 485          91Contents of property file:*: - +-: 7272: 5+: 33 4848: 91Writing out ascii chars becomes inefficient for integers but makes it easier to debug your code. If storage space is not a concern, this may suffice. Nevertheless, you can optimize a string of decimal digits by using hex digits."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hmm, so jack are you saying my answer was wrong then, if it was not nec. a complete tree?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Kartik,No, it seems logically correct. You have metadata for each node using 0,1. I meant to say that a raw preorder traversal would be ambiguous when read back. Curiously, how would you separate the metadata from the data in your implementation? For instance, how would you read back a string such as 430113243? Let me know if I misunderstood your algorithm."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My traversal above isn't preorder. It's actually breadth-first on 2 queues."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"So jack, you are right in interpreting my implementation. At the end of the store (data\" \"path) you would have a file something like so:A NULLB 0C 01D 1E 11So you read the file back line by line and you parse it into two fields, content of node (I should probably note that the interviewer said there were only chars as data in this tree) and then a 0's and 1's string which says where the node is located.  Then you automatically set the first node to root. Then go though each string with the corresponding data and rebuild the tree.  So it's O(n) rebuilding time as you have the nodes in traversed order so you garuntee not hitting something twice."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"So jack, you are right in interpreting my implementation. At the end of the store (data\" \"path) you would have a file something like so:A NULLB 0C 01D 1E 11So you read the file back line by line and you parse it into two fields, content of node (I should probably note that the interviewer said there were only chars as data in this tree) and then a 0's and 1's string which says where the node is located.  Then you automatically set the first node to root. Then go though each string with the corresponding data and rebuild the tree.  So it's O(n) rebuilding time as you have the nodes in traversed order so you garuntee not hitting something twice."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"So jack, you are right in interpreting my implementation. At the end of the store (data\" \"path) you would have a file something like so:A NULLB 0C 01D 1E 11So you read the file back line by line and you parse it into two fields, content of node (I should probably note that the interviewer said there were only chars as data in this tree) and then a 0's and 1's string which says where the node is located.  Then you automatically set the first node to root. Then go though each string with the corresponding data and rebuild the tree.  So it's O(n) rebuilding time as you have the nodes in traversed order so you garuntee not hitting something twice."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) BFS and write nodes on different levels to different lines of the file2) Marking with index which parent they belong to"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"to the abov soln by Hui.i was thinkin the same thing, butwithout your index.since it is a binary tree, it is almost gauranteed that reading 2-elements would lead you to 1 parent.however, i would at this point ask the interviewer(s) whether a single child would always reside to its parent's left side(left child).also i would also ask whether i am allowed to write on different lines"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"HotDog, there is no gurantee that it is a FULL binary tree, so I think writing Index is un-avoidable. How do u think?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i am just wondering, could we ignore the fact that it is a full bt or not a full bt?because i am thinkin that we could look at the patterns.we are only reading each line as each level.we are only reading each elem in each line as a childex.a tree:[a][ b, c ] //root level[b][ d,  ]  //next level[c][ , g ]  //same level as bI believe we need to define the bound of an obj.but the basic idea is reading as it comes anda space represents a null child.(*and hui, you are right, we need to identify null child.)let's say we use | to define the bound of an obj(delimiter)|a||b||c||d|| || |e|else, i guess we would use a special byte valuethis only happens if the interviewer(s) allow(s) us to output each level as a new line.if we are only allowed to use 1 single string linei guess i would use 2 bits for identifiers10 - left01 - right11 - next levelbut i believe the way i answer this question is too naive.wut do you guys think?With LamboMumbleHumbleDumbo,HotDogMumboJumboKudo"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"More over, i would make some changes, instead of breadth first searchi would use preOrder (root,left,right)appened to the end of the file as we go.again, we only need to find a good delimiter to seperate a left child and a right child and a delimiter for null child(and maybe a delimiter for next level, this won't b necessary, we only need to keep countin as we buildin the level, 2^h is the max # nodes u could hv)or creatively you could build a relation table between each child and its parent.and recursively iterate thru and built the tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can we use \"Prufer Codes\"?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can we do it using parenthesissth like this, pre-order5(3(7,8),6(9,2)))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can do like thisstore node->data, direction, levelPreorder(node->left,0,level++);Preorder(node->right,1, level++);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use XML"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Let the tree be       a   b     c d      e    fDo a inorder traversal with a little modification.Modification is to add 0 for empty nodes.function String inorder(struct node* root,String vOutput) {if(root == null)return(vOutput +'0');if (root->left == null && root->right ==null)return (vOutput + root->data);inorder(root->left,vOutput);return(vOutput + root->data);inorder(root->right,vOutput);}So the output of the program is going to be 'db0aecf'Find the middle of the array.Elemant is the root.The left array is the left subtree andright array is the right sub tree.Using the middle element discussed above recursively print the elements"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think most of you are in the right track.. my solution is inspired by all the above ideas, but in my opinion, simple, and slightly better..I agree preorder is the best since it adds parents before children. So we output numbers as we go in preorder but everytime we go \"up\", we insert U (or some other character), and everytime we skip left child, we insert R.. since up characters are same as the number of parents, and right characters as much as nodes, we shall have 3n characters storage in the worst case. And while re-creating the tree, we shall be actually instructing the algorithm how to go, so the next character read will always be the one added..suppose tree is:          a      b        c  d     e    -      fg   -  h  i        j  -Output: abdgUUehUiUUUcRfjSince this may involve a number of U just to get to the next available spot, we can probably just put one, denoting go to next place a node can be inserted after this node.I know, it gets complicated, but you'll get an unambiguous, small, and fast storage format"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi Ann, Your solution will work only for your case, try it working for the case where the root has no right tree or even a tree with greater number of levels with few nodes missing"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"write inorder and preorder/postorder these two order traversals  uniquely represent the tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is clear by now that some of the above solutions do not work when we have left or right child missing! Testing things with this simple tree will fail many of the above solutions!    1   / \\  2   / \\    3While reconstruction, there is an ambiguity to be resolved - Where to place 3?My Algorithm:------------1) Traverse it a BFS way:   12).3)2) Read from the file:   1 Read the first symbol, Create a node for the same.   2 If symbol is null, then it is a null tree else proceed to step 3.   3 Read the next symbol from file. Set Local Var L = true;   4 If symbol is '.', then left child is null, so do not enqueue anything.      Set L = false;   5 Until Symbol is ')', do steps 6-8.   6 Retrieve the symbol, create a node and enqueue it.   7 If L is false, Queue Structure will have Direction set to 'R' else 'L'.   8 Also store the CurrentNode Value as the parent value in Queue structure.   9 L = true; Go to 5   10 Dequeue the element.   11 Search the parent value uptil now from the created tree!   12 If Direction = 'L' set the searched node left pointer to current node.   13 If Direction = 'R' set the searched node right pointer to current node.   14 Set CurrentNode = Dequeued element.I know searching tree everytime is O(logN). Hence, algorithm deserves some good improvement tips!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"With inorder and preorder sequence or in-order and post-order sequence the binary tree can be reconstructed  perfectly."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"do inorder traversal and do preorder traversal write both into the file. using these two only we can rebuild the tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Think from a compiler aspect.When you parse an expression, the BNF grammar for an expression is:Expression:= Expression OP Expressionin real code, it's like:(Expression)OP(Expression)then we get more expression:((Expression)OP(Expression))OP(Epxression)Each time we see '(', we create a new node.Using the same idea, we don't need to use the queue or BFS.e.g."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do an inorder traversal and write as you read... For example,    +  -   * 1 2 3 4 would be stored as +-12*34"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about just doing a preorder traversal, but also write out the NULL pointer. It should perfectly reconstruct the tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why did the array idea get dismissed easily ? Thought with a modified BFS it should work pretty wellArray Tree[NUMVertices]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this1. label every node, level by level, with numbers              1             / \\            2   3           /   /          4   5               \\                62. for every, record the left child, right child. O(n) space:2 4 5 N N N3 N N N 6 N1 2 3 4 5 6Then you can reconstruct the tree. I'm just simulating how the real binary tree works."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"define   tree:=  |    branch:= 1, node_value, ,    leaf:= 0, leaf_valueAs observed earlier in the posts, NULL should be allowed as leaf value"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using parentheses:A(B(D,E),C(F(,G(H(K,L),)),))For small trees which nodes can be presented as ansichar (1byte) (below), for bigger trees should use hashmap for nodes and extend string reading algorithm1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I was thinking of a solution mixing a file storing the tree details and an xml structure storing node record details.stuct node{     int d1; int d2; String d3;     node* left; node*right;}For Tree each with data node....                1       2                  3   4      NULL      NULL    5Create a treeStuct.txt file as 12,34,-1,-1,6and an XML as 104Node1StringData104Node2StringData104Node3StringDataThis works and can be reused by changing XML schema to support differnt node types...Does this work?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Save inorder and preorder of a tree.2. Reconstruct it using: a. Navigate through each character of preorder array    a.1. Check the preorder character with each node of newly tree that is          getting constructed.            a.1.1. If current preorder character comes before current node                     character in inorder array, node = node -> left            a.1.2. If current preorder character comes after current node                     character in inorder array, node = node -> right            a.1.3. Continue until you get null. If null, attach the new                     preorder character to the left/right depending on where                    reached.Here is the source code:# include # include typedef enum location {LEFT=-1, CENTRE=0, RIGHT=1} relPos;typedef enum boolean {TRUE=1,FALSE=0} boolVar;typedef struct tree {    int data;    char reData;    struct tree *left;    struct tree *right;} TREE;void addNode(TREE **root, int data);void printInOrder(TREE *root,boolVar printInt);void printPreOrder(TREE *root,boolVar printInt);void printPostOrder(TREE *root,boolVar printInt);void constructTree(TREE **root,char *inorder, char*preorder);relPos myNavigator(char *inorder,char rootNode, char currentNode);static char[] answerInorder;static char[] answerPreorder;int main() {    TREE *root = NULL;    TREE *reRoot = NULL;    addNode(&root,5);      addNode(&root,6);         addNode(&root,3);         addNode(&root,7);         addNode(&root,2);         addNode(&root,9);       addNode(&root,8);           printf(\"\\nIn-order : \");                      printInOrder(root,TRUE);    printf(\"\\nPre-order : \");        printPreOrder(root,TRUE);    printf(\"\\nPost-order : \");        printPostOrder(root,TRUE);    char inorder[] = \"2356789\";    char preorder[] = \"5326798\";    constructTree(&reRoot,inorder,preorder);      printf(\"\\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\");    printf(\"\\nIn-order : \");                      printInOrder(reRoot,FALSE);    printf(\"\\nPre-order : \");        printPreOrder(reRoot,FALSE);    printf(\"\\nPost-order : \");        printPostOrder(reRoot,FALSE);      getch(); return 1;    }void addNode(TREE **parentNode, int data) {    TREE *newNode = NULL;    newNode = malloc(sizeof(TREE));    newNode -> data = data;    newNode -> left = NULL;    newNode -> right = NULL;    if(*parentNode == NULL) {        *parentNode  = newNode;        return;    }     TREE *node = *parentNode;    TREE **leftN = NULL;    TREE **rightN = NULL;    while(node) {        leftN = &(node -> left);        rightN = &(node -> right);        if(node -> data > data) {            if(*leftN)                 node = *leftN;            else {                *leftN = newNode;                break;            }        } else {            if(*rightN)                 node = *rightN;            else {                *rightN = newNode;                break;            }        }    }}void printInOrder(TREE *node,boolVar printInt) {    if(!node)        return;    printInOrder(node -> left,printInt);    if(printInt)        printf(\"%d \",node -> data);    else        printf(\"%c \",node -> reData);    printInOrder(node -> right,printInt);}void printPreOrder(TREE *node,boolVar printInt) {       if(!node)        return;    if(printInt)        printf(\"%d \",node -> data);    else        printf(\"%c \",node -> reData);    printPreOrder(node -> left,printInt);    printPreOrder(node -> right,printInt);}void printPostOrder(TREE *node,boolVar printInt) {       if(!node)        return;    printPostOrder(node -> left,printInt);    printPostOrder(node -> right,printInt);    if(printInt)        printf(\"%d \",node -> data);    else        printf(\"%c \",node -> reData);}void constructTree(TREE **reRoot, char *inorder, char*preorder) {    TREE *newNode,*tempNode,**childNode = NULL;    *reRoot = (TREE *)malloc(sizeof(TREE));    (*reRoot) -> reData = preorder[0];    (*reRoot) -> left = NULL;    (*reRoot) -> right = NULL;    int index = 0;    for(index = 1;preorder[index] != '\\0';index++) {        newNode = (TREE *)malloc(sizeof(TREE));        newNode -> reData = preorder[index];        newNode -> left = NULL;        newNode -> right = NULL;        tempNode = *reRoot;        while(1) {            if(myNavigator(inorder,tempNode -> reData,preorder[index]) == LEFT) {             childNode = &(tempNode -> left);             if(*childNode == NULL) {              *childNode = newNode;              break;             }            }            else {             childNode = &(tempNode -> right);          if(*childNode == NULL) {           *childNode = newNode;           break;          }             }            tempNode = *childNode;        }    }}relPos myNavigator(char *inorder,char rootNode, char currentNode) {    int index = 0;    for(index = 0;inorder[index] != '\\0';index++) {        if(inorder[index] == rootNode)            return RIGHT;        if(inorder[index] == currentNode)            return LEFT;    }    return CENTRE;}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if file size is not an issue, then why not just use object serialization. for example jave object serialization. Obviously this doesn't scale for very large trees but it is one way to persist the tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"clearly, if the tree is full tree, then we can serialization easily, just like heap structure. So, we can try to make the tree \"virtual full\". That is, all leaves of the tree has exactly two children, if there is only one node, add a virtual nodes on the leaf. Then, write the value of the node or \\0(virtual node) into file level by level. When read data from file, contruct the binary tree level by level."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A C# solution with pre-order and in-order traversals to rebuild the tree:      class RebuildBinaryTree     {         static void Main(string[] args)         {             List preOrder = new List() { 1, 2, 3, 4, 5, 6, 7 };             List inOrder = new List() { 3, 2, 4, 1, 6, 5, 7 };             Node node = BuildTree(preOrder, inOrder);              preOrder = new List() { 1,2,3,8,9,10,11,12,4,13,14,5,6,15,16,7,17,18,19 };             inOrder = new List() { 8,9,3,11,10,12,2,4,13,14,1,16,15,6,5,17,7,19,18 };             node = BuildTree(preOrder, inOrder);         }          public static Node BuildTree(List preOrder, List inOrder)         {             if (preOrder == null || preOrder.Count == 0)             {                 return null;             }              Node node = new Node() { Data = preOrder[0] };             int index = inOrder.FindIndex(a => a == node.Data);             node.Left = BuildTree(preOrder.GetRange(1, index), inOrder.GetRange(0, index));             node.Right = BuildTree(preOrder.GetRange(index + 1, preOrder.Count - index - 1), inOrder.GetRange(index + 1, inOrder.Count - index - 1));              return node;         }     }      public class Node     {         public int Data { get; set; }         public Node Left { get; set; }         public Node Right { get; set; }     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. calculate PreOrder and InOrder PreOrder: 1234567 InOrder: 2431675 first element is root node so root node is 1. now find the root node in InOrder and break the string. InOrder 243 - 675 ( 3 - 3 size) PreOrder 234 - 567 ( divide the same ) now consider left part it means this is going to left child under root node. consider first element of 234 which is 2 and find the same node in Inorder and divide again so now  InOrder: 43 PreOrder 34 ( as of now you determine 1-(root) 2 ( left ) again perfrom the same and you will able to reconstruct the tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use an array. parent is at position 2i and left child is at 2i-1 and right child at 2i+1. If the left/right child doesn't exist, then assign the array slot a number that will not appear in the tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why not use JSON or XML or any sort of standard serialization?  And if that's not an option, you can do a simple encoding like each node encoded as: [content]{[child1],[child2]}, with special caution taken to properly escape characters. No need to get clever with traversals, algorithms, etc. It's O(n) runtime, O(log(n)) space, and is far more practical. Throw a round of compression on top if you're worried about file size."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"With a pre-order and an In-Order sequence, can easily rebuild the tree."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14466116","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"63","title":"Write a program which returns true if the given string contains the consecutive repeated substring .Ex-adabcabcd here abc is consecutive repeated substring.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"public class findConsSubString{ public static boolean find(String s){ int ptr1; int ptr2; int i = 1; int count; if(s.length() < 2) return false; while(i <= s.length() / 2){ ptr1 = 0; ptr2 = i; count = 0; while(ptr2 < s.length()){ if(s.charAt(ptr1) == s.charAt(ptr2)) count++; else count = 0; if(count == i){ return true; } ptr1++; ptr2++; } i++; } return false; } public static void main(String[] args){ boolean found = find(args[0]); System.out.println(\"Found Cons SubStrings:\" + found); } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"public boolean isRepeatedSubstring(String s){ \n  int i,j,k,m; \n  for(i=1;i=2){ \n     //check if the a substring of length=count from k exist \n     if (k-j==count)  \n      return true; \n    } \n   } \n  } \n  return false; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"If trying to find consecutive duplicate string, it means there must be duplicate character. So iterate each character one by one till string matched.  if found any character matched then fetched the string from current character till matched character index. and fetch second string from matched character index till difference between current index and matched index.   If both string are equal, then return true."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Let there be two suffixes A and B of the given string.  If ( length of longest common prefix of A and B == distance between starting point of A and B in the original string )        => Consecutive substrings found"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"You can count matching characters in shifted strings."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"char str[20]=\"abcababceccced\"; int len = strlen(str); int i, j, counter; for(i = 1; i <= len / 2; ++i) {    for(j = i, counter = 0; j < len; ++j)    {       if (str[j] == str[j - i])          counter++;       else          counter = 0;       if (counter == i)       {           return true;          }    } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question is ambiguous.  Do you mean repeat substring? Like athethelete : the is repeated.  Or consecutive substring? like youabcde. abcde: characters are consecutive?  Or youbadec? badec: characters are still consecutive when sorted.  Explain."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assumption:  'ab' is consecutive but not 'ba'  algo:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we can find all occurrence of the given pattern in the long string & can store the starting index in some array.... for all the occurrence in the array if (next_starting_index=current_index+length of the pattern) return true...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we can use a suffix array to find repeat pattern: e.g.  abcabc#  (# only for end of string) suffices will be c# bc# abc# cabc# bcabc# abcabc#  first we have c#, then we see how long are the common string between bc# and c# when both strings are aligned to their left sides; similarly, how long are the common string between abc# and any of bc# or c#; as long as we have found a common string longer than 1 char, then we consider the input string is a valid string.  In this case: bcabc# will have a common string 'bc' with bc# (always align strings to their left sides when in comparison), so the input string is valid. Finally, using tries will make comparison very fast, below the solution codes:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static boolean consecutiveSubString(String input, String searchKey) \n    { \n        boolean res = false; \n        for( int i = 0, j = 0, count = 0; i < input.length(); i++, j = 0, count = 0 ) \n        { \n            while( j < searchKey.length() && i < input.length() && input.charAt( i ) == searchKey.charAt( j ) ) \n            { \n                j++; \n                i++; \n                if( j == searchKey.length() && count == 0 ) \n                { \n                    j = 0; \n                    count++; \n                } \n            } \n            if( j == searchKey.length() ) \n            { \n                res = true; \n                break; \n            } \n        } \n        return res; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If I interpreted the question right: abab = true abcab = false aa = false baba = false aaabcabcaaa = true etc"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"looks like DP will work  if a.charAt(i)=a.charAt(j) m[i][j]=m[i-1][j-1]+1  else m[i][j]=0  find m[i][j]=j-i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static String getLongestCRS(String test){   if(test==\"\"){    return \"\";   }   if(test.length()==1){    return \"\";   }   String max=\"\";   for(int i=0;i!=test.length();i++){    String currentMax=\"\";    for(int j=test.length()-1;j!=i;j--){     if(test.charAt(i)==test.charAt(j)){      if(test.substring(j, test.length()).indexOf(test.substring(i,j))==0){       currentMax=test.substring(i, j);       break;      }     }    }    if(currentMax.length()>max.length()){     max=currentMax;    }   }   return max;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hey everyone, I think this problem needs a dynamic programming approach.   This is what I coded up in Java,"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Jeez, the indentation looked weird I'll try again here."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \nint removeDuplicate(char *str, int len, int size) \n{ \n \n char str1[len],str2[len]; \n int i=0,j=0,k=0; \n \n for(i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Maybe not the most efficient solution, but seems to work. I am counting single character strings, so \"aa\" for example or any repeated character would return True.  The idea is to walk through each character of the string. In the second for loop, divide every substring in half and see if the two halves are the same.   For example, for the string \"cbaba\", once we get to the last character 'a', the second for loop looks at substrings:  \"cbaba\" \"baba\" \"aba\" \"ba\" \"b\"  If you divide \"baba\" in half you get \"ba\" and \"ba\" which are the same and therefore the function returns true. It's a brute force n-squared algo, so not the best.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"its simple.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i would request clarification. Is the substring known beforehand. I mean : abcdabcdcd  In the above : the substring is abcd of cd since both are consecutive and both are repeated.please clarify"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i would request clarification. Is the substring known beforehand. I mean : abcdabcdcd  In the above : the substring is abcd or cd since both are consecutive and both are repeated.please clarify"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// main function \nbool mainfunc(char* s) \n{ \n   return f(s, 0); \n} \n \n// recursive function \nbool f(char* s, int cur) \n{ \n   int target = (strlen(s)+cur)/2; \n   for(int i=cur+1; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// this is the C# version to solve the problem   public static bool  isSubString(string input, string sub)         {             string firstSubstringChar = sub[0].ToString();             for (int i = 0; i < input.Length; i++)             {                 if (firstSubstringChar == input[i].ToString())                 {                     if(sub == input.Substring(i, sub.Length))                         return true;                 }             }             return false;         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// C# \n// use hashtable to get the occurrences of chars. \n// only search repeating strings using the chars having >1 occurrences. \nbool FindRepeatingString(string s) \n{ \n if(string.IsEmptyOrNull(s) || s.length < 2) \n  return false; \n \n HashTable> ocTable = new HashTable>(); \n \n // construct occurrence hashtable. \n for(int i=0;i ocList = new List(); \n   ocList.Add(i); \n   ocTable.Add(s[i],ocList); \n  } \n  else \n  { \n   ocTable[s[i]].Add(i); \n  } \n } \n \n // for each char having >1 occurrences, check whether they are the starting points of repeating strings. \n    foreach(char c in ocTable.Keys) \n    { \n      if(ocTable[c].Count>1) \n      { \n       if(FindRecur(s, c, ocTable[c],0) == true) \n    return true; \n      } \n    } \n \n return false;   \n} \n \n \n// recursion function to check whether the occurrences in ocList point to the repeating strings. \nbool FindRecur(string s, char c, List ocList, int cur) \n{ \n if(cur>ocList.Count-2) \n  return false; \n \n    for(int i=cur+1; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \"stdafx.h\"  void rep(char *str) {     int i,j,k,count,len;     int match=0;     i=0;     len=strlen(str);     //printf(\"%d\",len);     while(i    {        count=0;         j=i+1;         while(str[j]!=str[i] && j        {             count++;             j++;         }   count++;         while(count>0 && j        {             k=i;             if(str[k++]==str[j++])                 count--;         }         if(count==0)         {             match++;             i=j;         }         else             i++;         k=0;              }     printf(\"total matches = %d\",match); }  int main() {     char str[]=\"adabcabc\";     rep(str);  getchar(); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static boolean consecutiveSubstring(String string) {   boolean result = false;   for (int i = 2; i <= string.length() / 2; i++) { // the range of                // substring's                // length is from 2                // to n/2;    for (int j = 0; j <= string.length() - i * 2; j++) {     if (string.substring(j, j + i).equals(       string.substring(j + i, j + i * 2))) {      /*There maybe more satisfied substrings, so we can store them in a list.*/      // subs.add(string.substring(j, j+i));      result = true;     }    }   }   return result;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a good problem for dynamic programming, which can reduce a brute-force algorithm of O(N^3) down one notch to an algorithm of O(N^2).  Look up the Levenshtein algorithm as a related dynamic programming algorithm.  Explanation:  We build an N+1 by N matrix and fill in the upper half in this way: the value of an element m[i][j] is the number of characters ending at position i that match the same number of characters ending at position j.  In other words, m[i][j] = 1 + m[i-1][j-1] if the ith character matches the jth character, it is 0 otherwise.  We only need to fill the upper half of the matrix because of symmetry: the rows and columns both iterate over the same input string.  We make an extra row at the top to initialize with zeros which helps us as we start so we have a zero to add our first count onto when iterating over the top row of the matrix.  To know when a match is consecutive, we just compare the count at m[i][j] with it's position in the matrix.  The count must be equal to the distance from the diagonal.  For example, a single repeating character \"a\" in the string \"baac\" is one character long and one character from the diagonal.  Hence the check for m[i][j] == j-i+1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"main() { char s[20]; int i,j,k1,k,count=0,count1=0,c=1; clrscr(); printf(\"\\n\\n\\n\"); printf(\"enter the string\"); gets(s); for(i=0;s[i];i++) {   k=i; for(j=i+1;s[j];j++)   {      k1=j;      if(s[i]!=s[k1])      {      count++;      }      else      {      count++;      count1=count;      k=i;      while(count1>0)        {   k++;  k1++;  if(s[k]==s[k1])  {  count1--;  if(count1==1 && c==1)  {    printf(\"true\");    c=2;    break;  }        }        else  break;        }      }     }     count=0;     }     if(c==1)     printf(\"no string\");     getch();     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"main() \n{ \nchar s[20]; \nint i,j,k1,k,count=0,count1=0,c=1; \nclrscr(); \nprintf(\"\\n\\n\\n\"); \nprintf(\"enter the string\"); \ngets(s); \nfor(i=0;s[i];i++) \n{ \n  k=i; \nfor(j=i+1;s[j];j++) \n  { \n     k1=j; \n     if(s[i]!=s[k1]) \n     { \n     count++; \n     } \n     else \n     { \n     count++; \n     count1=count; \n     k=i; \n     while(count1>0) \n       { \n  k++; \n k1++; \n if(s[k]==s[k1]) \n { \n count1--; \n if(count1==1 && c==1) \n { \n   printf(\"true\"); \n   c=2; \n   break; \n } \n       } \n       else \n break; \n       } \n     } \n    } \n    count=0; \n    } \n    if(c==1) \n    printf(\"no string\"); \n    getch(); \n    return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This Java code works for me. Let me know if you spot an error or have a comment. The program spots any consecutive substrings. Starts with 0th character and checks all the consecutive substrings possible starting here. Then increment one character and repeat the process."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My algorithm: 1) build a map of array indexes for each occurred character. 2) if there exists a array of indexes in map for current character, then check if any substring from indexes in array to current character is equal to substring of same length from current character. 3) if any found equal, return true. 4) return true if all the characters are exhausted.   Following is code for stated algorithm."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"ans shud b \"abcd\" i guess"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#include #include int main() {     char a[30],b;     int j,k=0;     gets(a);     char *p;     p=a;       while(*(p+k)!='\\0')      {       b=*(p+k);       j=1;       k++;       if(*(p+k)==b+j)       {       printf(\"true\");       break;       }       k++;       }       if(*(p+k)=='\\0')       printf(\"no substring\");       getch();       return 0;       }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"See this Java Code  public class SubString{ public static void main(String args[]){ if(sub(\"abc\",\"adabcabcd\")) System.out.println(\"True\"); else System.out.println(\"False\"); } public static boolean sub(String sub,String full){ int j=0; boolean flag=false; for(int i=0;iflag=false; for(j=0;jif(full.charAt(i)==sub.charAt(j)){ i++; flag=true; } else{ if(!flag) i++; break; }} System.out.println(j); if(j==sub.length()) return true; } return false; }}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=2490","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"69","title":"You have a random 5 function. Generate a random 7 function using this random 5 function with equal probability hint: think at bit level","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Maverick's algorithm is not correct, so is Affan's comment. The problem is \"the two possible outcomes (0 and 1) are NOT equally likely\" with the algorithm! For example, the probability with \"1\" appearing at the 2nd bit is NOT 1/2."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"long Random7(){return (Random5()^Random5());}Ex-OR two random values of the Random 5 function."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"please explain the question."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int Random7()\n{ int i1,i2,i3;\n  i1=Random(5)%2;\n  i2=Random(5)%2;\n  i3=Random(5)%2;\n  return (i1*4+i2*2+i1);\n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"seems to be a sill question(Rand5()/(5 +1)) * 7, no?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I forget the random7 can not generate 0.Another way is:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"YYY, you might be wrong, since 5=1+4=2+3=3+2=4+1, it has 4 situations. Inspired by your method, we can do a \"reject sampling\", for example, if we get these seven cases, like:<1, 3>, <2, 2>, <3, 1>, <1, 4>, <2, 3>, <3, 2>, <4, 1>, we output 1 to 7. For other cases, we reject the sampling and sample agian. If John von Neumann's reject sampling proof is capable here, then this Random7() function works."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"you are right, moreover, you can accept 21/25 by merge 3 cases to one case."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If you are going to use rejection, why not use random5() to generate random25 and reject anything outside of random7?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I've a solution can you guys tell me whether it is correct or not ?I assume random5() will generate 1,2,3,4,5 all of whose binary representations has LSB as 1,0,1,0,1 resp. My algo isint random7() {str[0] = LSB(random5());str[1] = LSB(random5());str[2] = LSB(random5());return decimal(str);}In this way assuming equal probability of each numbers in random5() the min num is 1 and max is 7 from 001 & 111 resp."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Originally, I would try this function:int rand7(){  return round(rand5()*5.0/7);}Taking binary ops into account:5 => 001 to 1017 => 001 to 111Notice that the ranges intersect from 001 to 101. They do not intersect on 110 and 111. This suggests flipping the 2 least significants bits randomly.Perhaps:int rand7(){   int num = rand5();   return num | (~num&3);}Example:2=010110 | (~110&011) = 110 | (001&011) = 110 | (001) = 111 = 7"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I don't this this works...it will only give 3 or 7 ...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how about just rand() + rand()%3.............since we need to only change the last 2 bits"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Consider rand1 to generate random numbers uniformly between 0 and 1 (consider fractions too)Now, suppose you need to generate rand5, one could do so by: rand5 = (rand1*5). rand5 is still uniform, however, we lose some precision - consider rand1 possibly generates 1000 distinct numbers (this is precision), then rand5 also generates 1000 (usually higher) distinct numbers because of the math.Also, suppose we have rand5, then (rand5/5) gives rand1, but again this is uniform and we lose some precision.Note, precision is memory limitation not due to math.So, for our problem, (rand5/5)*7 should give us rand7, which is uniform but less precision.We assumed rand5 generates fractions too. Like above, if we consider rand5 to generate only whole numbers, then rand7 generated above could possibly generate only 5 values not 7, uniform though!!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"just :Rand5+2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this: int rand(7) {  int num = rand(5)  return num + (num >> 1) }coz num >> 1 gives out 0, 1, 2 with equal probability"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Given RandX (returns values 0 to X-1), RandY can be implemented using a RandZ helper (where Z=2^log2(X)) to generate a series of log2(X)-bit slices. For example, given Rand5, implement Rand7 using a Rand4 helper:uint Rand7(){    uint result;    do    {        result = Rand4() +       /* low slice, 2 significant bits */            (Rand4() & 1) << 2); /* hi slice, 1 significant bit   */    } while (result > 6);    return result;}uint Rand4(){    uint result;    do    {        result = Rand5();    } while (result > 3);    return result;}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"000001010011101The prob of 1 in LSB is 3/5, the prob of 1 in 2nd LSB is 2/5 (or 0 in 2nd LSB is 3/5), so the algo is as follows:rand5, keep the LSB and flip the 2nd LSB, and use another rand5's LSB to form a rand number from 0 to 7"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Guys... i dont know Y u guys are troubling urself a lot...the Xor solution from the first thread works fine...Hello World 0 xor 0 = 0 0 xor 1 = 1 0 xor 2 = 2 0 xor 3 = 3 0 xor 4 = 4 0 xor 5 = 5 1 xor 0 = 1 1 xor 1 = 0 1 xor 2 = 3 1 xor 3 = 2 1 xor 4 = 5 1 xor 5 = 4 2 xor 0 = 2 2 xor 1 = 3 2 xor 2 = 0 2 xor 3 = 1 2 xor 4 = 6 2 xor 5 = 7 3 xor 0 = 3 3 xor 1 = 2 3 xor 2 = 1 3 xor 3 = 0 3 xor 4 = 7 3 xor 5 = 6 4 xor 0 = 4 4 xor 1 = 5 4 xor 2 = 6 4 xor 3 = 7 4 xor 4 = 0 4 xor 5 = 1 5 xor 0 = 5 5 xor 1 = 4 5 xor 2 = 7 5 xor 3 = 6 5 xor 4 = 1 5 xor 5 = 0if u guys dint want 7 as a part of rand(7) ... then the solution will be rand(7) = (rand(5) ^ rand(5) ) % 7Rem: the hint is think bitwise... so it has to be some bit calculation"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"badri,Looking at the number of occurances of the various rand5 XOR rand5 results (where rand5 returns 0-5), we see:    result = 0 : occurances = 6    result = 1 : occurances = 6    result = 2 : occurances = 4    result = 3 : occurances = 4    result = 4 : occurances = 4    result = 5 : occurances = 4    result = 6 : occurances = 4    result = 7 : occurances = 4                 (total occurances = 36)                   As is, this does not provide for an even probability of distribution of resulting values 0-7 for rand7.  Looking at it another way, 36 (# unique input combos) % 8 (# unique results) != 0, which should raise a flag. In order to accomplish an even distribution with this method, a couple of result=0/1 input combos (e.g. (0,0), (1,1) and (0,1), (1,0), respectively) would need to be explicitly checked for and the results discarded when they occured; this would happen 4 times in 36 on average, or 11.1% of the time, and rand5 would have to be called again twice, the results checked, etc.  For example:    uint rand7() /* returns 0-7 */    {        uint x, y;        do        {            x = rand5(); /* returns 0-5 */            y = rand5();        } while (x < 2  &&  y < 2);        return x ^ y;    }A more performant alternative (based on average # of calls to rand5, 2.11 versus 2.22) uses the generic bit-harvesting method I mentioned above (which has a missing '(' typo, btw), with the modification of also employing any probablistically-correct bits of the rejected values.  For example:    uint rand7() /* returns 0-7 */    {        uint result, numBitsA, numBitsB;                result = harvestRand5Bits (&numBitsA);        result |= harvestRand5Bits (&numBitsB) << numBitsA;        if ((numBitsA + numBitsB) < 3)             /* Happens 1 time in 9 (11.1%) on avg */            result |= (rand5() & 1) << 2;         else if ((numBitsA + numBitsB) > 3)            /* mask highest of 4 bits ret'd */            result &= 7;         return result;    }    uint harvestRand5Bits (uint *numBits)    {        uint x = rand5(); /* returns 0-5 */        if (x < 4)        {           *numBits = 2;           return x & 3;        }                *numBits = 1;        return x & 1;    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"An improvement to the above (in single-thread apps, or multithread apps where perf overhead of serialization is significantly lower than calls to rand5) would be to save any unused random bits generated during the course of a given call to rand7 for utilization in subsequent calls, e.g.:    uint rand7() /* returns 0-7 */    {        static uint residualBit, numResidualBits = 0;        uint result, numBitsA, numBitsB, numBitsC;        if (numResidualBits > 0)        {            result = residualBit;            numBitsA = numResidualBits;            numResidualBits = 0;        }        else        {            result = harvestRand5Bits (&numBitsA);        }        result |= harvestRand5Bits (&numBitsB) << numBitsA;        if ((numBitsA + numBitsB) < 3)            result |= harvestRand5Bits (&numBitsC) << (numBitsA + numBitsB);        else            numBitsC = 0;        if ((numBitsA + numBitsB + numBitsC) > 3)        {            residualBit = result & 1;            result >>= 1;            numResidualBits = 1;        }        return result;    }Best case here is 1.5 calls to rand5 per call to rand7: first call to rand7 generates 4 random bits from two calls to harvestRand5Bits (occurs 4 times in 9 on avg, 44.4% of the time), and one of these bits is saved for use by second call to rand7 which generates 2 random bits from a single call to harvestRand5Bits (occurs 2 times in 3, 66.7% of the time).Worst case here is 3 calls to rand5 per call to rand7: first call to rand7 generates 3 random bits from 3 calls to harvestRand5Bits (occurs 1 time in 27 on avg, 3.7% of the time), with no random bits left over.Average case here is 1.8 calls to rand5 per call to rand7. Consider that three calls to harvestRand5Bits will generate an average of 5 random bits, and nine calls to harvestRand5Bits will generate an average of 15 random bits.  Since each rand7 requires 3 random bits, nine calls to harvestRand5 should on average generate enough random bits to satisfy five calls to rand7: 9/5 = 1.8."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int x = (random5() + random5() + random5() + random5() + random5()) % 7"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"simple yaar....below is the solution...rand7(){ return (rand5() + rand5()%3);}done!!!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this should do it.{num = rand5()if (num != 2)num = num xor 2;return num;elsereturn num;}let me know if its wrong.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Probably we should use the hint: \"think at bit level\" as an advise to don't bother with bit manipulations.(Random5()-1)*5+Random5()-1 will allow to generated numbers from 0 to 24.and any number from 0 to 24 will have the same probability 1/25.let's ignore numbers 21,22,23,24 - the remaining numbers 0-20 will still get equal chances to be generated, so we will use only them to get our Random7 numbers.int random7(){  while (true){     int v = (random5()-1)*5 + random5() -1;     if (v > 20) {         continue;     }     return v/3 + 1;}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"building on yyy's ideaint random4(){ again: int i = random5(); if( i == 5 ) goto again; else return i;}int random7(){ again: int i0 = LSB(random4()); int i1 = LSB(random4()); int i2 = LSB(random4()); int i = ( i2 << 2 + i1 << 1 + i0 ); if( i == 0 ) goto again; else return i;}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"whats the meaning of random 5 and random  generator,plz explain!!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"(7*random5())%7     if 0....6(7*random5())%7 +1 if 1....7"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"- Fascinating thread!..:-).  Implementing rand7 (with bits manipulation or else) from 5 uniformly distributed numbers as they are is I think impossible.  Why? Basically, we deal with given probabilities: ... 1/5, 2/5, 2/5. Solving this to get uniform 1/7 out of the above fractions: be my guest.  So,  \"reject sampling\" (as somebody above has called it) seems to be the only easy choice.  Here is how I did it:  a) from rand5(), take 4 and reject the 5th; get rand4(); b) from rand4(), build rand2() and rand8(); c) from rand8(), again take 7 and reject the 8th.  Here is the implementation:  def rand5(): ...return random.randrange(5) # this is the only \"real\" random  def rand4(): ...while(1): ......n = rand5() ......if n < 4: .........return n  def rand2(): ...return rand4() <2  def rand8(): ...n4 = rand4() ...if rand2(): ......n4 += 4 ...return n4  def rand_5_7(): ...while(1): ......n = rand8() ......if n < 7: .........return n   A few takes (each one calls it 100000 times and stores the results): :~> ./rand_5_7.py 100000 0: 14424; 1: 14114; 2: 14207; 3: 14517; 4: 14241; 5: 14250; 6: 14247; :~> ./rand_5_7.py 100000 0: 14383; 1: 14195; 2: 14140; 3: 14265; 4: 14226; 5: 14389; 6: 14402; :~> ./rand_5_7.py 100000 0: 14281; 1: 14195; 2: 14156; 3: 14287; 4: 14245; 5: 14531; 6: 14305; :~>   Looks like random to me:-)..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a solution. Got close approximation when monte carlo simulated.  with rand5(), you can do rand2 and rand4.  x=floor(1+(rand5/5)*2); rand2=(x>2)?2:x; (to avoid the condition when [1+(5/5)*2 = 3] happens. |||ly you can do rand4.  Do a=rand2 , b=rand4, do a+b.which means you get 8 possibilities.  2 3 3 4 4 5 5 6, and doing a reject for a = b = 1; which means your sample space becomes 3 3 4 4 5 5 6. Now for rand7 you need a probability of 4/7 for 1, for any bit. So if you take P(a+b == 3 || a+b == 4), you can get probability of 4/7 (nr of 1s in any bit position).  I tried a monte carlo simulation with the above probability and got close approx to 4/7. I also feel that the confidence interval for this wud be as high as >95%. When running this over many samples. I havent calculated that though.  Comments/suggestions/criticisms welcome.  Thanks, Rohith Menon."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The idea behind this solution is to use the previously generated random as seed to generate the next random number.  int Random7() {     static int random7 = 0;     random7 = (Random5() + random7)%7;     return (random7+1); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"mport java.util.*; import java.lang.*;  class Main {  private static int getR5(Random g) {   return g.nextInt(5) + 1;  }    private static int getR1(Random g) {   int r = getR5(g) - 1;   while ((r != 0) && (r != 1)) {    r = getR5(g) - 1;   }      return r;  }    private static int getR7(Random g) {   int r1[] = {getR1(g), getR1(g), getR1(g)};   int r7 = (r1[0] << 2) + (r1[1] << 1) + r1[2];   if (r7 == 0) {    return getR7(g);   }      return r7;  }    public static void main(String[] args) {   Random g = new Random(System.currentTimeMillis());   int dist[] = new int[7];   for (int i = 0; i < 1000; i++) {    dist[getR7(g) - 1]++;   }   for (int i = 0; i < 7; i++) {    System.out.println(dist[i]);      }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using 50%/50% distribution on a bit generator using random5"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am thinking there is no solution. For one rand5, you will have 5 possible cases. For n times rand5, you will have 5 power n cases. The result can nerver fill into 7 buckets equally."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"but what if both Random5() return same valuehere is a simple solutionlong Random7(){long i=Random5();return i+(i/5)*2;}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15487859","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"57","title":"Write a method that multiplies two integers without using multiply operator","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"int Mul(int a,int b) \n{ \n int ans=0; \n int sign= ((a^b)>>31); \n a=abs(a); \n b=abs(b); \n while(b) \n { \n  if(b & 0x01 )ans += a; \n  b >>= 1; \n  a <<= 1; \n } \n return sign?(~ans+1):ans; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"int multiply( int a, int b) { \n  if (a==0 || b==0) \n    return 0; \n  int sign = 0, result; \n  if ((a < 0 && b > 0) || (a > 0 && b < 0)) { \n    sign = 1; \n  } \n  int a1 = abs(a); \n  int b1 = abs(b); \n  while (b1--) { \n    result + = a1; \n  } \n  if (sign) { \n    return result/(-1); \n  } else { \n    return result; \n  } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"public class Solution { \n    public static int multiply(int a, int b) { \n if (a == 0 || b == 0) { \n     return 0; \n } \n if (b == 1) { \n     return a; \n } \n boolean positiveFlag = true; \n if ((a < 0 && b > 0) || (a > 0 && b < 0)) { \n     positiveFlag = false; \n } \n a = Math.abs(a); \n b = Math.abs(b); \n \n if (a < b) { \n     a ^= b; \n     b ^= a; \n     a ^= b; \n } \n  \n int ret1 = multiply(a, b/2); \n int ret2 = multiply(a, b%2); \n if (positiveFlag == false) { \n     return -(ret1+ret1+ret2) \n } \n else { \n     return ret1+ret1+ret2; \n } \n    } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"int multiply(int a, int b) \n{ \nif(b == 0) \nreturn 0; \nif(b > 0) \nreturn a + multiply(a, b-1); \nif(b < 0) \nreturn (-a) + multiply(a, b+1); \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"ex: x*y int RES = 0; for(int i = 0; i{  RES += y; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"int multiply( int a, int b ) \n{ \n    if( a==0 || b==0 ) \n        return 0; \n    return (a/(1.0/b)); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Lucky Fellow to get this question  int Multiply(int number, int multiple)  {    int num=number;    while(multiple--)       number=number+num;     retrun number;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/**   *    * PropertiesFor the natural numbers, integers, fractions, and real and complex numbers, multiplication has certain properties:    Commutative property : x*y=y*x;    The order in which two numbers are multiplied does not matter;    Associative property : (x*y)*z=x*(y*z);    Expressions solely involving multiplication are invariant with respect to order of operations;    Distributive property : x*(y+z) = x*y+x*z;    Holds with respect to multiplication over addition. This identity is of prime importance in simplifying algebraic expressions:    Identity element : x*1=x;    The multiplicative identity is 1; anything multiplied by one is itself. This is known as the identity property:    Zero element : x*0=0;    Any number multiplied by zero is zero. This is known as the zero property of multiplication:      Zero is sometimes not included amongst the natural numbers.     There are a number of further properties of multiplication not satisfied by all types of numbers.   Negation : x*-1 = -x;     Negative one times any number is equal to the opposite of that number.       -1*-1=1;    Negative one times negative one is positive one.      The natural numbers do not include negative numbers.    Inverse element    Every number x, except zero, has a multiplicative inverse, , such that .    The natural numbers and integers do not have inverses.    Exculding folating  and complex numbers mulitple   */   public static long mulitple (int a, int b){   long mulitplicationResult = 0;   boolean isPositiveResult = false;   // Retrun zero if any one input has zero   if (a == 0 || b==0){    return mulitplicationResult;   }   //Sign calculation of result   if( (a<0 && b<0) || (a>0 && b>0) ){    isPositiveResult = true;   }else{    isPositiveResult = false;   }   //Converting -ve values of the input into +ve   if(a<0) a=(~a+1);   if(b<0) b=(~b+1);   //For example: 3 multiplied by 4 can also be calculated by adding 3 copies of 4 together.   while( b>0 ){    mulitplicationResult += a;    b--;   }     return isPositiveResult?mulitplicationResult:(~mulitplicationResult+1);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"suppose we have a , b 1) First produce arr[9] where arr[i]=i*a , (1<=i<=9). we can do it with 9 addition. 2) For each digit in b[i]=k add i zero on right-side of the arr[k] and add them to each other. The result is a*b. It is the obvious way that we calculate multiply on paper! This solution is useful for bignumber multiplication too."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this is a solution in java and it doesn't involve a loop, the answer is pretty simple:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This solution works if multiplication is among either positive or negative numbers. The ~ operator is used just to make positive number to negative and negative number to positive"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"function multiply(a, b) \n  return exp(ln(a) + ln(b)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can any one help me to find the multiplication of two floating point numbers without using * operator or any library fn that uses * internally.... I think we can take the integral  & fractional part separately and multiply like above mentioned code for integral part. But m having difficulty with fractional part ...But if any one can help me to identify the bit position of fractional part in float, then it can be done easily.... Thanks in advance..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int function multiply(int a, int b) \n{ \n int result = 0; \n if ( b >= 0 ) \n { \n  while( b-- > 0 ) \n   result += a; \n } \n else \n { \n  while( b++ < 0 ) \n   result -= a; \n } \n \n return $result; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int sum(int a, int b) { \n  int result = a ^ b; \n  int carry = a & b; \n  while (carry != 0) { \n   carry <<=  1; \n   int x = result; \n   result ^= carry; \n   carry &= x; \n  } \n  return result;   \n } \n \n public int multiply(int a, int b) { \n  int result = 0;  \n  if (a == 0 || b == 0) { \n   return result; \n  } \n  boolean negative = a > 0 && b > 0 || a < 0 && b < 0 ? false : true; \n  a = a > 0 ? a : -a; \n  b = b > 0 ? b : -b; \n \n  int k = 0; \n  while (b != 0) { \n   if ((b & 1) > 0) { \n       result = sum(result, a << k); \n   } \n   k++; \n   b = b >>> 1; \n  } \n  if (negative) \n   result = sum(~result, 1); \n \n  return result; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"method with a helper function"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static int multiply(int a, int b) { \n   \n  if(a == 0 || b == 0) \n   return 0; \n   \n  int res = 0; \n  int absA = Math.abs(a); \n  int absB = Math.abs(b); \n  if ((a > 0 && b > 0)  || (a < 0 && b < 0)) { \n   a = absA; \n   b = absB; \n  } \n  if( absA > absB) { \n   while(absB > 0) { \n    res+=a; \n    absB--; \n   } \n  } else { \n   while(absA > 0) { \n    res+=b; \n    absA--; \n   } \n  } \n  return res; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Try something like this:   public int myMethod(int i, int j) {   int x = 0;   if (j >= 0) {    for (int k = 1; k <= j; k++) {     x = x + i;    }    return x;    } else if ((i < 0) && (j < 0)) {    for (int k = 1; k <= -i; k++) {     x = x + j;    }    return (-x);    } else {    for (int k = 1; k <= i; k++) {     x = x + j;    }    return x;    }   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{ int main(){     int a,b;     int ad=0;     cout<<\" \";     cin>>a>>b;     for(int i=0;i    ad=ad+a;     }     cout<<\"multiplication is \\n\"<<             getch();     return 0;     }     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int multiply(int a,int b) {  while(b!=0)  {  if(b&1)      { result=result+a;}     a=a<<1;    b=b>>1; } return result; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int multiply(int a, int b){   if(a==0||b==0) return 0;   int sign = 0;   if(((a>>31) &0x1) == 1){    sign = 1;    a = ~a + 1;     }if(((b>>31) & 0x1) == 1){    if (sign == 0)sign = 1;    else sign = 0;    b = ~b + 1;    }      int mul = 0;   //System.out.println(b + \" \"+ a);   while(b>0){    if((b & 0x1) > 0){     mul +=a;    }    b = b>>1;    a = a<<1;   }   if (sign ==1)    return ~mul + 1 ;      return mul;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def multi(a:Int, b:Int):Int ={ if(b==1)  a  else  multi(a+a,b-1);}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The function should return long for two int."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"!python \ndef multiply(x, y): \n    if x == 0 or y == 0: return 0 \n \n    negative = False \n    if x < 0 and y < 0: x = -x; y = -y;  \n    elif x < 0: x = -x; negative = True \n    elif y < 0: y = -y; negative = True         \n \n    # Small optimization \n    add_value     = x \n    counter_range = y \n    if y > x: add_value = y; counter_range = x \n \n    value = 0 \n    for i in range(counter_range): \n        value = value + add_value \n \n    return -value if negative else value"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why not a recursive algo like this?  public static int simpleMultiply(int one, int two) {  if(two==0 || one ==0)   return 0;  if(one>0 && two>0)  {   return one+simpleMultiply(one,two-1);  }  else  if(one<0 && two <0)  {   return simpleMultiply(0-one,0-two);  }  else  if(one<0 && two >0)  {   return simpleMultiply(0-one,0-two);  }  else  if(one>0&&two<0)  {   return (0-one)+simpleMultiply(one,two+1);  }  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class convert { \n \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n  System.out.println(multiply(10,300)); \n } \n \n private static int multiply(int a, int b) { \n  int result=0; \n  if(a>b) \n  { \n   for(int i=1;i<=b;i++) \n   { \n    result= add(result,a); \n   } \n  } \n  else \n  { \n   for(int i=1;i<=a;i++) \n   { \n    result= add(result,b); \n   } \n  } \n  return result; \n } \n \n private static int add(int a, int b) { \n  int carry=0; \n  while(b!=0) \n  { \n   carry=a&b; \n   a=a^b; \n   b=carry<<1; \n  } \n  return a; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def simpleMul(a,b) \n  i = a \n  (b-1).times do \n    a += i \n  end \n  a \nend \np simpleMul(4,8)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Very Simple Logic   Input  A, B -->  Left Shift the value means multiply by 2 --> Add A the above result once if B is odd number  This solution works irrespective of signs."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int multiply(int a, int b){ \n  int product = 0;   \n  for(int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Laziest Solution:-  a=5, b=2 result= a / (1/b) = 5 / (1/ 2) = 10  Note: not using mulitiply operator"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def mult(x, y) \n  total = 0 \n  y.times do  \n    total += x \n  end \n  total \nend"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14578788","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"58","title":"Given an array of integers, find all combination of four elements in the array whose sum is equal to a given value X. For example, if the given array is {10, 2, 3, 4, 5, 9, 7, 8} and X = 23, then your function should print ??3 5 7 8?? (3 + 5 + 7 + 8 = 23).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Say we are looking for a + b + c + d = x 1. Sort the array 2. Iterate over each element of the sorted array as a           Iterate over each element of the array which is right to the a, as b              For remaining array right side of b, take two pointers from front and back              Check if c (front) + d (back) = x - a- b              if yes then you got the answer              if no and if c+d is smaller then move front pointer              if no and if c+d is greater then move back pointer  Time Complexity: n logn for sorting the array n*n*n for searching the sum O(n^3) is the complexity  No extra space is required"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Assuming we are allowed sums of the form 4a[i] or 3a[i] + a[j] or 2a[i] + 2a[j] etc.  Form all possilble n^2 sums. Sort. And then find two numbers in n^2 array which sum to S.  This is O(n^2 log n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Code is written in C language. Please note I have tried to explain logic. This code is not optimized. There can be many way to do things,"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Assumption: all the members of the array are unique -- this is just for simplifying the explanation, removable with no new idea involved  the idea is to look at the 4-SUM as a 1+3-SUM problem  step 1) sort the array - n log n step 2) for every element a in the array, find if there exists triplet (b,c,d) with sum S-a  so we get the newer problem of checking for 3-SUM in an array, this is already answered in on this forum, can be done in n^2 log n, and it is the exact same reduction. look at this as 1+2-SUM problem  step 1) for every element a  step2) find a pair (b,c) such that b+c = S-a and so on... can be generalized for any k-SUM with complexity n^(k-1) log n  i am hoping this can be done faster"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"sum required by using  4 elements = Z  Step 1:   Find Sum of every 2 elements in a array and store it in array F[]. This takes O(n^2) time as there are n Choose 2 such combinations.  Step2:   Also Hash the value of Sum with the two elements that make the sum <(Sum),(a,b)> such that (a+b)=Sum .This allows for O(1) time retrieval of above calculated sums and the process of hashing will take O(n^2) time and space.Note that there can be more than one combination of <(a,b)> which gives same sum like 2+4=6 and 5+1=6,then we need to store both of them by appropriate modification to your hash table.   Step 3 : sort the array F. This takes time O(n^2 log n)  Step 4: We have to find  a,b,c,d  such that   a+b+c+d=Z Making groups of two: (a+b)=Z-(c+d);                                                   A=Z-B;    A,B are elements of array F[] as each element corresponds to a 2-element sum there and its sorted.So for each element in F[], just find if Z-(that element) is present or not by using the Hash Table.If it is output the pairs  and  from Hash Table.  Now we can Look in the Hash Table for A and B to find  pairs   Overall Complexity -  O(n^2logn) -Time O(n^2) -Space"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Are integers positive.?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"in C#,"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package amazon;  import java.util.ArrayList;  public class Give_Sum_Get_Combination_In_Array {   /*   * Given an array of integers,    * find all combination in the array whose sum is equal to a given value X.   * For example, if the given array is {10, 2, 3, 4, 5, 9, 7, 8} and X = 23,    * then your function should print ??3 5 7 8?? (3 + 5 + 7 + 8 = 23).   */    public static void Print_Result(int[] test,int aim){   ArrayList> result=new ArrayList>();   ArrayList begin=new ArrayList();   compute_process(test,0,aim,0,result,begin);   show_result(result);  }    public static void compute_process(int[] test,int index,int aim,int currentValue,      ArrayList> result,ArrayList currentArray){   if(index==test.length){    return;   }   ArrayList stepArray1=cloneArrayList(currentArray);   ArrayList stepArray2=cloneArrayList(currentArray);   ArrayList stepArray3=cloneArrayList(currentArray);   if(test[index]+currentValue==aim){    stepArray1.add(test[index]);    result.add(stepArray1);   }   stepArray2.add(test[index]);   compute_process(test,index+1,aim,currentValue+test[index],result,stepArray2);   compute_process(test,index+1,aim,currentValue,result,stepArray3);     }  public static ArrayList cloneArrayList(ArrayList obj){   ArrayList result=new ArrayList();   for(int i=0;i!=obj.size();i++){    result.add(obj.get(i));   }   return result;  }  public static void show_result(ArrayList> test){   System.out.println(\"Results number: \"+test.size());   for(int i=0;i!=test.size();i++){    int sum=0;    System.out.print((int)(i+1)+\") \");    for(int j=0;j!=test.get(i).size();j++){     int num=test.get(i).get(j);     sum+=num;     System.out.print(num);     if(j==test.get(i).size()-1)      System.out.print(\"=\");     else      System.out.print(\"+\");    }    System.out.print(sum);    System.out.println();   }  }  public static void main(String[] args) {   int[] test={10,2,3,4,5,9,7,8};   int aim=23;   Print_Result(test,aim);  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Looks like its a varient of 0/1 knapsack problem. Using dynamic programming, we can solve it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void Find(int[] arr, int index, int[] result,int total, int arr_index){ \n  if(index == 4){ \n   int temp = 0; \n   for(int i = 0; i < result.length; i++){ \n    temp += result[i]; \n   } \n   if(temp == total) \n    print(result); \n  }else{ \n   for(int i = arr_index; i < arr.length; i++){ \n    result[index] = arr[i]; \n    Find(arr, index + 1, result, total, arr_index + 1); \n   } \n  } \n } \n  \n private static void print(int[] arr){ \n  for(int i = 0; i < arr.length; i++){ \n   System.out.print(arr[i] + \" \"); \n  } \n  System.out.println(); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class IntegerArrayFourValueSum { \n public static void main(String[] args) { \n  // Test some values \n  test(10, 2, 3, 4, 5, 9, 7, 8); \n } \n \n private static void test(int... values) { \n  findCombinationsOfFourWithSum(values); \n } \n \n private static void findCombinationsOfFourWithSum(int[] values) { \n  for (int i = 0; i < values.length - 3; i++) { \n   for (int j = i + 1; j < values.length - 2; j++) { \n    for (int k = j + 1; k < values.length - 1; k++) { \n     for (int l = k + 1; l < values.length; l++) { \n      int total = values[i] + values[j] + values[k] + values[l]; \n \n      boolean match = total == 23; \n      if (match) { \n       System.out.println(values[i] + \" \" + values[j] + \" \" + values[k] + \" \" + values[l]); \n      } \n     } \n    } \n   } \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public ArrayList> find4Sum(int sum, int[] array){    ArrayList>  result  = new ArrayList>();    int length = array.length;    for(int i = 0; i < length ; i++){         for(int j = i+1; j < length ; j++){            for(int k = j+1; k < length ; k++){                int toFind = sum- array[i]-array[j]-array[k];                boolean sign = binarySearch(toFind, array, i, j ,k);                if(sign){                     ArrayList r = new ArrayList(4);                    r.add(array[i]); r.add(array[j]);r.add(array[k]);r.add(array[toFind]);                    result.add(r);                }else{                    continue;                }         }      }    }    return result; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include    void print(int* vector,int v_size) {  int i;  for(i=0;i {   printf(\"%d,\",vector[i]);  } }  void funhelp(int* str,int size,int* vector,int v_size,int ite,int sum,int tot_sum) {count++;    if(v_size>4)     return;    else if(sum==tot_sum)   {     if(v_size==4)    {    print(vector,v_size);    printf(\"\\n\");    }    return;    }   else if(sum>tot_sum)    return;   else   {    int i;    for(i=ite;i   {     vector[v_size]=str[i];     funhelp(str,size,vector,v_size+1,i+1,sum+str[i],tot_sum);    }   }  }  void fun(int* str,int size,int tot_sum) {    int* vector=(int*)malloc(size);      funhelp(str,size,vector,0,0,0,tot_sum); }  int main() {   int str[]={10, 2, 3, 4, 5, 9, 7, 8};  fun(str,8,23);      }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n \n \n \nvoid print(int* vector,int v_size) \n{ \n int i; \n for(i=0;i4) \n    return; \n \n  else if(sum==tot_sum) \n  {  \n   if(v_size==4) \n   { \n   print(vector,v_size); \n   printf(\"\\n\"); \n   } \n   return; \n \n  } \n  else if(sum>tot_sum) \n   return; \n  else \n  { \n   int i; \n   for(i=ite;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"* Java * Complexity O(n*(2^n))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using meet-in-the-middle approach and hash table we can achieve O(n^2) complexity. C# code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"void DoFindSubNumber(int ins[], int outs[], int level, int start, int len, int number, int total) \n{ \n for ( int i = start; i < len; i++ ) \n { \n  outs[level] = ins[i]; \n  total += ins[i]; \n \n  if ( total == number ) \n  { \n   for ( int j = 0; j <= level; j++ ) \n    printf(\"%d \", outs[j]); \n \n   printf(\"\\n\"); \n  } \n \n  if ( i < len - 1 ) \n  { \n   DoFindSubNumber(ins, outs, level + 1, i + 1, len, number, total); \n   total -= ins[i]; \n  } \n } \n} \n \n \nvoid FindSubNumber(int ins[], int len, int number) \n{ \n int *outs = NULL; \n  \n outs = (int *) malloc(sizeof(int) * len); \n \n for ( int i = 0; i < len; i++ ) \n  outs[i] = -1; \n \n  \n DoFindSubNumber(ins, outs, 0, 0, len, number, 0); \n \n free(outs); \n} \n \nint main() \n{ \n        int numFindSub[] = { 10, 2, 3, 4, 5, 9, 7, 8 }; \n FindSubNumber(numFindSub, 8, 23); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"this one takes o(n^3logn) ...can anyone give it in n^2???"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"int[] arr = {9,2,10,7,6,11,12,3,5,8}; \n   \n   \n  for (int i = 0; i < arr.length; i++) { \n   int j=0; \n   while(j"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"package pre;  public class starter {     public starter() {     }      public static void main(String[] args) {         int[] arr = new int[10];        // System.out.print(\"aaa\");                for(int i=0; i<10; i++) arr[i]=i+1;  for(int i=0; i<10; i++)     for(int j=0; j<10; j++)         for(int k=0; k<10; k++)             for(int l=0; l<10; l++)              if (             (arr[i]+arr[j]+arr[k]+arr[l]) == 12             && arr[i] != arr[j]             &&arr[i]!=arr[k]             &&arr[i]!=arr[l]             &&arr[j]!=arr[k]             &&arr[j]!=arr[l]             &&arr[k]!=arr[l]                                       )                   System.out.println(arr[i] + \"+\" + arr[j] + \"+\" + arr[k] + \"+\" + arr[l] + \"= 12\" );     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This is a subset problem which is NP complete. Check out the wiki page for Subset_sum_problem"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Best ans coming to my mind is.  1. Fist create an bit array of size(n) equal to max element of the input arrary and reset the array with all zeros. 2. Process input array elements and set the corresponding index of the array to 1 for each element. 3. now get the first element say k from the array at zeroth index. 4. Check for (n-k)th index in new array whether it is set or not. 5. If (n-k)th index is set then you get the element.  Thats it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-4","title":"algorithm : 1. sort the array - O(nlogn) 2. Find the range of the sum. at worst case the whole array - O(n) 3. subtract 3 number from the sum and do binary search on the other array elements. 4. if the value is found, print and continue for the other combinations   step 3 and 4 together takes - O(nlogn)  therefore total time complexity is O(nlogn)+O(n)+O(n^2logn) = O(nlogn)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14491723","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"56","title":"Find the longest subarray which consists of numbers that can be arranged in a continuous sequence. For ex- {4,5,1,5,7,6,8,4,1} output-{5,7,6,8,4}.Find the longest.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Overkill O(n^2) solution.  Preprocess for Range Minimum and Maximum queries. (O(n)) time.  For each sub-array, figure out in O(1) time whether max-min = length - 1. O(n^2) time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"The approach I took was to start from the first element in the array. I would look from the other end of the array to find the next adjacent element if one exists. I defined adjacent as n, n-1, or n+1. If I found an adjacent element, I made a subarray of elements between my starting an ending points and checked to see if the elements inside were all consecutive. (To test this I used a built-in sort and walked up the subarray to see if there were any gaps.) If it was valid, I compared it against my previous best, and stored the answer if necessary. If the subarray was invalid, I searched for the next adjacent element for my current index and repeated the process.  This took me about an hour to get a working solution and for the record I think this would make a terrible interview question. :) As a coding puzzle it was kinda fun I guess...  There are some optimizations I could make, for example, I could stop searching if array.length - current index < bestEnd - bestStart. My algorithm complexity is something like O(n^2) + time for the inner-array sorting."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void question1(int []input) \n { \n  int[] longest=new int[input.length]; \n  longest[0]=1; \n  for(int i=1;i set=new HashSet(); \n   set.add(input[i]); \n   for(int j=i-1;j>=0;j--) \n   { \n    if(set.contains(input[j])) \n    { \n     break; \n    } \n    else \n    { \n     set.add(input[j]); \n    } \n    max=Math.max(max, input[j]); \n    min=Math.min(min,input[j]); \n    if(i-j==max-min) \n    { \n     longest_=Math.max(longest_,i-j+1); \n    } \n   } \n   longest[i]=longest_; \n  } \n  int longestValue=1,longestIndex=0; \n  for(int i=1;ilongestValue) \n   { \n    longestValue=longest[i]; \n    longestIndex=i; \n   } \n  } \n  int startIndex=longestIndex-longestValue+1; \n  for(int i=startIndex;i<=longestIndex;i++) \n  { \n   System.out.print(input[i]+\",\"); \n  } \n  System.out.println(\"\"); \n  System.out.println(\"longestValue: \"+longestValue+\" longestIndex: \"+longestIndex); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void getLongestContSeq(int a[], int n){ \n     int lStart = 0, lEnd = 0; \n     int start = 0, end = n-1; \n      \n     // Sort the array \n     sort(a, a+n); \n      \n     // remove the duplicates \n     int *r = new int[n]; \n     int cnt = 0; \n     r[cnt++] = a[0]; \n      \n     for (int i=1;i (lEnd - lStart) ){ \n                  lStart = start; \n                  lEnd = end; \n              } \n              start = i+1; \n         } \n     } \n     lEnd = lEnd+1; \n      \n     for ( int i=lStart;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Take two pointers A at start and B at the end. a. Transverse through the array and find out the min max ,sum of array and number of elements. b. check the possibility of the array is consecutive i.e sum of integers  upto MAX element - sum of integers up to MIN-1 is equal to sum of array using N(N+1)/2. If yes check Digits are non repeating. If yes store the indexes and count of sub array and do A++.  Else do B--. Sum = Sum-B. if B is not MIN or MAX nothing to do else look for MIN and MAX between A and B.  repeat the step B until it reached A + Max array length found..   Do A++, B=length of array"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Match the value with index. Create another array (let's say, Boolean indexArr) that has size of the max value of the given array. Using the given example, the size should be 8 + 1. Run through the given array (let's say, valArr), mark TRUE the indexArr[valArr[i]]. At the end you will get a array looking like this {F, T, F, F, T, T, T, T, T}.  2. Create an empty vector (let's say, resultVec). 3. Loop through valArr, if (indexArr[valArr[j]] == true) then result.add(valArr[j]), else (meaning it's not consecutive) result.clear() to start over again."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this (code in Python):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is an idea of O(n*logm) amortized time. n = \"length of the array\" and m = \"length of longest continuous sequence\". Here is the array A[]= {4,5,1,5,7,6,8,4,1} (from the example)  The idea is to use a HashMap hMap (TreeNodes will be sorted by the index in the array). Here are steps: 1.) start traversing A[i], i = 1..n, and add it in the hMap as follow:   1.1.) if hMap.contains(A[i])     1.1.1) traverse the tree in A[i] and check if this is currently longest result. (here we do versioning of the Tree so if we have already checked the tree previously do not do it again.)     1.1.2) cut the left subtree at A[i]   1.2) else      1.2.1) If hMap.contains(i-1/i+1) merge the Trees A[i - 1] + A[i] + A[i + 1]     1.2.2) else just add the value to hMap 2.) Finally iterate the hMap and do 1.1.1) point"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this can be done by o(n) complexity...  #include void main() {  int a[]={1,2,-5,6,-5}; int i,j,k,l; int max=0,count;  for(i=0;i<5;i++) {  count=a[i];  for(j=i+1;j<5;j++)  {  count+=a[j];  if(count>max)  {  max=count;  k=i;  l=j;  }  } }  for(i=0;i<5;i++) if(max{ max=a[i]; k=i; l=0; }  if(l) printf(\" group size =%d max value=%d strating=%d end=%d\",l-k+1,max,k,l); else printf(\" group size =1 max value=%d starting=%d\",max,k+1); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int[] input; //original input \nint[] sortedInput; //contains input array sorted in non-decreasing order \nint[] originalIndices //originalIndices[i] contains the original index in the input for any element sortedInput[i] (0 < i < input.length) \nint[] startsAt; //inititialized to startsAt[i] = i (0 < i < input.length) \nint[] endsAt; //initialized to endsAt[i] = i (0 < i < input.length) \nint[] startsAtLastValue; //initialized to startsAtLastValue[i] = input[i] (0 < i < input.length) \nint[] endsAtLastValue; //initialized to endsAtLastValue = input[i] (0 < i < input.length) \n \n \nfor(int i = 0; i < input.length; i++) { \n int originalIndex = originalIndices[i]; \n int value = sortedInput[i]; \n  \n if(originalIndex > 0 && (value - endsAtLastValue[originalIndex - 1]) == 1) { \n  endsAtLastValue[originalIndex] = value; \n  endsAt[originalIndex] = endsAt[originalIndex - 1]; \n  startsAt[endsAt[originalIndex]] = originalIndex; \n  startsAtLastValue[endsAt[originalIndex]] = value; \n } \n \n if(originalIndex < (input.length - 1) && (startsAtLastValue[originalIndex + 1] - value) == 1) { \n  startsAtLastValue[originalIndex] = value; \n  startsAt[originalindex] = startsAt[originalIndex + 1]; \n  endsAt[startsAt[originalindex]] = originalIndex; \n  endsAtLastValue[startsAt[originalindex]] = value; \n } \n} \n \n \n//Find i such that startsAt[i] - i is maximum. For this i, input[i...startsAt[i]] will have output."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Here is the dp solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include void maxsize(char *s); void fill(char *,int*,int,int); int sequence(int*,int); main() {     char s[100];     printf(\"enter string\\n\");     scanf(\"%s\",&s);     maxsize(s); }   void fill(char *s,int *table,int j,int k) {     int i;     for(i=j;i<=k;i++)     table[s[i]-97]++; }  void maxsize(char *s) {     int gap,k,j,max,start;     int n;     int table[26];     n=strlen(s);     for(gap=1;gap    {         for(j=0,k=gap;k        {             memset(table,0,26);             fill(s,table,j,k);             if(sequence(table,gap+1))             {                 max=gap;                 start=j;             }         }     }      for(j=start;j<=start+max;j++)     printf(\"%c\",s[j]); }  int sequence(int *table,int size) {     int i;     int count=0,found=0;     for(i=0;i<26;i++)     {         if(!found && table[i])         {             found=1;             count=1;         }         else if(found && !table[i])         break;         else if(table[i])         count++;     }      return count==size; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Pseudo code (Sliding subarray of decreasing size): 1. Start with a subarray whose size = arrays length. 2. Check if this subarray is a valid contiguous subarray (algo to check follows) 3. If yes, print it. 4. If no, reduce the subarray size by 1 and start with index 0 of main array, slide the subarray until last element of main array is part of the subarray 5. Repeat step 2-4 until subarray.length > 1 6. No subarray exists if nothing found so far.    Pseudo-code for checking any given subarray is valid or not: 1. For a subarray, set starting index as 0 do the following 2. If subarray[index] > subarray.length, fail test - Number at index pos is too large to fit in this subarray; return 3. Else Check value at subarray[subarray[index]-1]. If value is same as subarray[index]-1, there is a repeating number in this subarray so fail test - return. 4. Else capture subarray[subarray[index]-1] as newIndex; set subarray[subarray[index]] = subarray[index]-1. Set index = newIndex 5. Repeat from 2."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void longestSubarray(int a[]) \n{ \n    int n=sizeof(a)/sizeof(a[0]);   //length of array \n    int max=0,*hash; \n    int subArray_start=0,subArray_end=0; \n    for(int i=0;i=0)) \n         tmp_start=i; \n       if(hash[i]==0) \n         tmp_end=i-1; \n    } \n    if(!tmp_end) \n     tmp_end=i-1; \n     \n    while(n) \n    { \n       if(a[n]<=tmp_end || a[n]>=tmp_strt) \n         subArray_end=n;      //initialize end of subarray \n       n--; \n    } \n \n    for(i=subArray_start;i<=subArray_end;i++)   //print output \n     cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"when u find a repeating elemnt check if min+max-1 is equal to number of elemnts encounterd!! if so then it was a consecutive sequence..  thn clear thee hash table used to check the repetition..check for forward.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is my solution, 1)find the max value, create and array of that size and make each value present to one. 2) now find the sequence of 1's and find the rage of the indexes. 3) print the output. Here is the below code."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This comment has been deleted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"1. sort the array in extra space..  2. find the max length of consecutive range, min and max of that range.. here length = 5, max = 8, min= 4 3. create an array[length (or) max-min+1]... here array[5].. 4. now traverse the original input with count = 0      a) if the element is within the calculated range, increase the count and array[element-min] set to 1      b) if the element is repeated(which is already set in the array[]) or out of range.. check whether the element in array[] are consecutively set to 1.. if it is, store that temporary output with count.. reset count and array[] to zero      c) repeat a).. if the count exceeds the previous count.. update it..   Note: we have to iterate through all range of values.. for example: {1,2,3,51,7,52,8,53,9,54,10,55}   i)first process with 51..55   ii)next with 7...10   iii)next with 1..3 if i) is found to be continous in input with length = 5 then no need to see for ii) and iii) as they have length less than 5.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"@leet, \"For ex- {4,5,1,5,7,6,8,4,1} output-{5,7,6,8,4}.Find the longest.\" continuous sequence means subarray in some sorted fashion ?? if yes, then how 5,7,6,8,4 is the ans of above example, ?? can you please explain your question"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Mark for consideration."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=23194664","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"56","title":"Search for an element in a matrix. Rows and columns of the matrix are sorted in ascending order.  \n \n \neg. matrix  \n[1   14    25   35] \n[2    16    28   38] \n[5     20    28   40] \n[16   22     38   41]    \n \nsearch for 38.  \n \nThe interviewer was looking for a solution better than O(n+m). He didn't want a solution which starts searching from the left bottom and go to right or above according to the key value to search. That solution has O(n+m) worst complexity, where n is row count and m is column count.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"The idea is to use quaternary search tree so the complexity T(m*n) = 3 * T(m*n/4) + c it results in O((m*n)^log 3 base 4) complexity - it is not the best result available, see below discussion for a better result"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Short answer \"Saddleback Search\"  This is a sorted matrix, i.e., the rows and columns are sorted, so you can take advantage of that.  You can either start from the top-right M[0][n-1]  While until key found in M  Let M[i][j] be the current element  if M[i][j] < key, go down (M[i+1][j])  else if M[i][j] > key, go to left (M[i][j-1])  Or you can start from bottom left M[n-1][0] While until key found in M  Let M[i][j] be the current element  if M[i][j] < key, go to right (M[i][j+1])  else if M[i][j] > key, go up (M[i-1][j])  Total running time is O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Binary search o(log(m)*log(n))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"in order to achieve better complexity we can iterate rows and for each row do a binary search in their colums O( n * log(m) )"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The algorithm works using elimination of rows and columns and its worst case complexity is O(n+m), where  is the count of rows and  is the count of columns. Solution: When moving left we eliminate all the values below that column. Similarly, when moving down we eliminate all the elements to the left  of that cell in the current row."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) { \n  int a[][] = { { 1, 14, 25, 35 }, { 2, 16, 28, 38 }, { 5, 20, 28, 40 }, \n    { 16, 22, 38, 41 }}; \n  int noToFind = 41; \n  boolean found = false; \n  int foundi = 0; \n  int foundj = 0; \n  System.out.println(a.length); \n  System.out.println(a[0].length); \n  for (int i = 0; i < a.length; i++) { \n   if (a[i][0] < noToFind && a[i][a[i].length-1] < noToFind) { \n    continue; \n   } else if (a[i][0] < noToFind && a[i][a[i].length-1] >= noToFind) { \n    for (int j = 0; j < a[i].length; j++) { \n     if (a[i][j] == noToFind) { \n      found = true; \n      foundi = i; \n      foundj = j; \n      break; \n     } \n    } \n   } \n   if (found == true) { \n    break; \n   } \n  } \n  System.out.println(\"foundi -- \"+foundi); \n  System.out.println(\"foundj -- \"+foundj); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have tried implementing the quareternary search"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can we move along the diagonal (log (n))till we exceed the search value. ? Then wecan move along the row or column (depending on the max (m, n)? This solution is log (m) + log (n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//// Split the matrix into 4 rectangles along the diagonals and recursively search through ///  left bottom and right top \n#include \n#include \n#include \n \n#define p(x) std::cout<< #x\" : \" << x << \"\\n\" \n \nint count,tra; \n \nclass Coordinate \n{ \n        public: \n        int x; \n        int y; \n        Coordinate( int X=0, int Y=0):x(X),y(Y){} \n        Coordinate operator+(int add){ x += add; y += add ; return *this; } \n        Coordinate operator-(int add){ x -= add; y -= add ; return *this; } \n        ///void operator=(Coordinate& c) {this->x = c.x ; this->y = c.y } \n        bool isBefore(Coordinate& p) { return (this->x <= p.x && this->y <= y );} \n        void setToAverage( Coordinate& b, Coordinate& e) { this->x = (b.x+e.x)/2 ; this->y = (b.y+e.y)/2 ;} \n        bool inBound(Coordinate& end) { return ( this->x >=0 && this->x <= end.x && this->y >= 0 && this->y <= end.y ); } \n        bool isValid() { return !(this->x == -1 && this->y == -1 ); } \n \n        friend std::ostream& operator << (std::ostream& o, Coordinate& p); \n}; \n \nCoordinate traverse(int **mat, int ele, Coordinate beg, Coordinate end, Coordinate matEnd) \n{ \n        Coordinate start(beg.x,end.y); \n \n        ///p(start); \n        while ( start.inBound(matEnd) ) \n        { \n                if ( mat[start.x][start.y] == ele ) \n                        return start; \n                else if ( ele < mat[start.x][start.y]) \n                        start.y -= 1; \n                else \n                        start.x += 1; \n                        //start = start - 1; \n                ///p(start); \n                tra++; \n        } \n        return Coordinate(-1,-1); \n} \n \nstd::ostream& operator << (std::ostream& o, Coordinate& p) \n{ \n        o << \"(x,y) : ( \" << p.x << \" , \" << p.y << \") \\n\"; \n        return o; \n} \n \nCoordinate lookUpElement(int **mat, Coordinate begin, Coordinate end, Coordinate matEnd,int element); \nCoordinate binarySearch(int **m, int fixedIndex, int beg, int end, bool isRow, int element); \n \nCoordinate partitionAndSearch(int **mat, Coordinate begin, Coordinate end, Coordinate pivot ,int element, Coordinate matEnd) \n{ \n \n        Coordinate lowerLeftBegin ( pivot.x, begin.y), lowerLeftEnd( end.x, pivot.y-1 ); \n        Coordinate lower = lookUpElement(mat,lowerLeftBegin, lowerLeftEnd, matEnd,element); \n        p(lowerLeftBegin); \n        p(lowerLeftEnd); \n        if ( lower.isValid() ) \n        { \n                return lower; \n        } \n        Coordinate upperRightBegin ( begin.x, pivot.y), upperRightEnd( pivot.x-1, end.y ); \n        p( upperRightBegin ); \n        p( upperRightEnd ); \n        return lookUpElement(mat, upperRightBegin, upperRightEnd , matEnd,element); \n} \n/* \n        10      20      30      40      50 \n        100     200     300     400     500 \n        1000    1020    1030    1040    1050 \n        1031    1040    1050    1060    1090 \n*/ \n \nCoordinate lookUpElement(int **mat, Coordinate begin, Coordinate end, Coordinate matEnd,int element) \n{ \n        count++; \n        if ( !begin.inBound(matEnd) || !end.inBound(matEnd) ) \n        { \n                return Coordinate(-1,-1); \n        } \n        else if ( mat[begin.x][begin.y] == element ) \n        { \n                return begin; \n        } \n        else if ( mat[end.x][end.y] == element ) \n        { \n                return end; \n        } \n        else if ( !begin.isBefore(end)) \n        { \n                return Coordinate(-1,-1); \n        } \n        int diagDistance = std::min( abs(begin.x - end.x), abs(begin.y-end.y)); \n        p(diagDistance); \n        p(begin); \n        p(end); \n        #ifndef OPTIMIZE \n        if ( !diagDistance ) \n        { \n                bool isRow ( begin.x == end.x ); \n                Coordinate o =binarySearch(mat, isRow ? begin.x : begin.y  , isRow ? begin.y : begin.x , isRow ? end.y : end.x, isRow, element ); \n                if ( o.isValid() ) \n                        return o; \n        } \n        #endif \n        Coordinate start(begin),p; \n        Coordinate last(begin.x+diagDistance, begin.y + diagDistance ); \n \n \n        while( start.isBefore(last) ) \n        { \n                p.setToAverage(start,last); \n                if ( element > mat[p.x][p.y] ) \n                { \n                        start = p + 1; \n                        ///p(start); \n                } \n                else \n                { \n                        last = p - 1; \n                        //p(last); \n                } \n                count++; \n        } \n        //p( start ); \n        return partitionAndSearch(mat,begin,end,start,element,matEnd); \n} \nCoordinate binarySearch(int **m, int fixedIndex, int beg, int end, bool isRow, int element) \n{ \n        count++; \n         if ( beg > end ) \n              return Coordinate(-1,-1); \n         int mid = beg + (end-beg)/2; \n         int chekElement = isRow ? m[fixedIndex][mid] : m[mid][fixedIndex]; \n \n         if ( chekElement == element ) \n               return ( !isRow ? Coordinate( mid, fixedIndex) : Coordinate(fixedIndex, mid) ); \n         else if ( chekElement >  element) \n               return binarySearch(m, fixedIndex, beg, mid-1, isRow, element); \n         else \n                return binarySearch(m,fixedIndex, mid+1, end, isRow, element); \n} \n \n/// To search call : \nCoordinate res = lookUpElement(m, Coordinate(), Coordinate(N-1,N-1), Coordinate(N-1,N-1), key); \n if ( res.isValid() ) \n{ \n    std::cout << \"element found at \" << res ; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why not do a binary search along the diagonal until we find the bounds around the key and then do a linear search in a 2x2 matrix?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool search(int [,] a , int num)         {             int ncol = a.GetLenght(0);             int nrow = a.GetLenght(1);             int j=0;             int i =0;              int k =0;             bool ans = false;             while( i < ncol)             {                 if(a[i][j] == num)    {    ans = true;     return;   }                 j++;                 i++;                 k++;                 if(i == ncol-1 && j == nrow-1){ return;}              if(i == ncol-1 ){ i =0;}             }         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I did this algorithm based in the next rules: a matrix have corners (0,0) and (n,m) if you have a matrix of 1x1 dimension check if the number is that cell. if number < (0,0) ---> we know the number is not in the matrix. if number > (n, m) ---> we know the number is not in the matrix. I divide the matrix in 4 submatrix and do recursion wich each of them."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Assuming the standard rows and columns sorted property, you cannot do better than O(n+m). There are known proofs. People doing binary search etc should try proving the correctness of their algorithm once in a while."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"This can be done the time of log(m)+log(n) by doing a binary search on first row and identifying the column to go further and finding a binary search for the column"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"I think it can be solved in 0(logm+logn) time with extra space of o(m) + o(n). We need to apply a modified binary search in this problem both rowwise and columnwise. Posting the solution soon."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14469085","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"54","title":"Given a list of 'N' coins, their values being in an array A[], return the minimum number of coins required to sum to 'S'","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"www_youtube_com/watch?v=GafjS0FfAC0   good source for understanding coin change problem"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"#include  \n#include  \nbool min_coin (int s, int& try1,int *coin, int nc); \nint main (int argc, char * const argv[]) { \n    \n int s; \n scanf(\"%d\",&s); \n int nc =6; \n    int coin[]={1,2,5,10,20,25}; \n int min_c = s; \n int found=0; \n for (int i=0;i0) \n  if (min_coin (s-coin[i], try1,coin, nc)) \n  { \n   if (try1+10) \n  if (min_coin (s-coin[i], try_c,coin, nc)) \n  { \n   if (try_c+1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Here is the solution using DP"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public static int getMincoinsnumber(int[] coins,int aim){   Arrays.sort(coins);   int results=compute_posscess(coins,aim,coins.length-1,0,0);   if(results==Integer.MAX_VALUE){    return -1;   }   return results;  }  public static int compute_posscess(int[] coins,int aim,          int index,int currentaim,int currentnumber){   if(index==0){    if(aim==coins[0]+currentaim){     return currentnumber+1;    }    else{     return Integer.MAX_VALUE;    }   }   if(aim==coins[index]+currentaim){    return currentnumber+1;   }   else if(aim   int result=compute_posscess(coins,aim,index-1,currentaim,currentnumber);    return result;   }   else{    int result1=compute_posscess(coins,aim,index-1,currentaim+coins[index],currentnumber+1);    int result2=compute_posscess(coins,aim,index-1,currentaim,currentnumber);    return Math.min(result1, result2);   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Simple start from max denomination coin. And keep subtracting from the sum until sum becomes zero.  C# code for this problem is :  Program returning each coin denomination, and count of coin needed to form the sum.    static int[,] MinCoin(int[] coin_den, int sum)         {              int[,] count_each_coin = new int[coin_den.Length, 2];             for (int i = 0; i < coin_den.Length; i++)             {                 count_each_coin[i, 0] = coin_den[i];             }              for (int i = 0; i < coin_den.Length; i++)             {                 count_each_coin[i, 1] = 0;             }                  for (int i = coin_den.Length-1; i >= 0; i--)                 {                     while (sum - coin_den[i] >= 0)                     {                         count_each_coin[i, 1] += 1;                         sum -= coin_den[i];                     }                                      }              return count_each_coin;         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"/*   * From a set of coins of some value. We find the minimum no. of coins   * required to get count. If not possible returns -1. Done in order O(n^2),   * way better than O(2^n) the brute force approach.   */  public int getMinCoins(int[] coins, int count) {   int res = -1;   Arrays.sort(coins);   List num = new ArrayList();   List temp = new ArrayList();   List rep = new ArrayList();   for (int i = coins.length - 1; i > -1; i--) {    if (coins[i] == count) {     return 1;    } else if (coins[i] < count) {     for (int j = 0; j < num.size(); j++) {      if (coins[i] + num.get(j) == count) {       return rep.get(j) + 1;      } else if (coins[i] + num.get(j) < count) {       temp.add(coins[i] + num.get(j));       rep.add(rep.get(j) + 1);       // System.out.println(\"Num : \"+(int)(coins[i] +       // num.get(j))+\" Rep is : \"+(int)(rep.get(j) + 1));      }     }     for (int j = 0; j < temp.size(); j++) {      num.add(temp.get(j));     }     temp.removeAll(temp);     num.add(coins[i]);     rep.add(1);     // System.out.println(\"Num : \"+coins[i] +\" Rep is : 1\");    }   }   return res;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Two approaches in Java. What do you think? They assume the values array will be sorted in increasing order of values. The first approach is a \"brute force\" one and the second used DP."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int mincoin(){ int 1c, 5c, 10c, 25c; 1c = 5c = 10c = 25c = 0; for (int i = 0; i < N; i++){         switch (A[i]){         case penny:                 1c++;                  break;         case nickel:                 5c++;                  break;         case dime:                 10c++;                  break;         case quarter:                 25c++;                  break;          }     }     int mincoins = 0;     if (S-25*25c < 0){          int diff = 25*25c - S;          return (25c - (int)diff/25);     }     mincoins+=25c;     S-= 25*25c;     if (S-10*10c < 0){          int diff = 10*10c - S;          return (10c - (int)diff/10 + mincoins);     }     mincoins+=10c;     S-= 10*10c;     if (S-5*5c < 0){          int diff = 5*5c - S;          return (5c - (int)diff/5 + mincoins);     }     mincoins+=5c;     S-= 5*5c;     if (S-1*1c < 0){          int diff = 1*1c - S;          return (1c - (int)diff/1 + mincoins);     }     mincoins+=1c;     S-= 1*1c;     if(S > 0){         return -1; //total value of coins is less than S     }     return mincoins; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int min_num_coins(const vector& coins, size_t S) { \n  if (S == 0) return 0; \n  size_t denominations[] = {25, 10, 5, 1}; // big to small order \n  map num_of; \n  for (size_t i = 0; i < coins.size(); i++) { \n    if (num_of.find(coins[i]) == num_of.end())  \n      num_of[coins[i]] = 1; \n    else \n      num_of[coins[i]]++; \n  } \n  unsigned int num_coins = 0; \n  for (size_t d = 0; d < 4; d++) { \n    size_t k = min(S / denominations[d], num_of[denominations[d]); \n    num_coins += k; \n    S -= k*denominations[d]; \n  } \n  return num_coins; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my DP solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void minDiffWork(vector arr, int sum, vector result, int pos) \n{ \n int i = pos; \n while(i < arr.size() ) \n { \n  int target = sum - arr[i]; \n  //sum = sum - arr[i]; \n  if(i > pos )  \n   result.pop_back(); \n  result.push_back(arr[i]); \n  if(target > 0 ) \n  { \n   //12,4,7,3,1,6,3 \n   i++; \n   minDiffWork(arr, target, result, i); \n  } \n  else if(target < 0) \n  { \n   i++; \n   continue; \n   //break; \n  } \n  else \n  { \n   cout << \"-----------------------\" <"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it would be better if people start discussing the approach and algorithms and then paste the sample code."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int min_coin(int coin[], int n, int s) \n    { \n         int table[n+1]; \n         table[0]=0; \n         for(int i=0;i0) \n                      { \n                            minmm=min(minm,table[i-s[j]]+1); \n                      } \n                       \n               } \n               table[i]=minm; \n         } \n         return table[n]; \n          \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nusing namespace std; \n \nint minCoins(int *a, int N, int S) \n{ \n if(S==0) \n  return 0; \n \n int minC = N; \n  \n for(int i = 0; i < N; i++) \n { \n  if(S-a[i] >= 0) \n   minC = min(minCoins(a,N,S-a[i]),minC); \n } \n return minC + 1; \n} \n \nint main(void) \n{ \n const int N = 3; \n int a[N] = {7,7,5}; \n int S = 5; \n int minC = minCoins(a,N,S); \n if(minC<=N) \n  cout << minCoins(a,N,S) << endl; \n else \n  cout << \"NOT POSSIBLE\" << endl; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sort the array containing values of coins. Take the sum and subtract it from descending order. For the remaining sum after subtraction , perform binary search to rest of the array , if number is found that we have found the Sum with min coins required. If not , continue subtracting and finding the coins"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// DP algorithm: \n// W is the minimum coins to sum up to sum (s) given coins (c). \n// W(s, c) = min (W(s-ci, c-ci)) + 1; \n \n \n// using C# \n \n// global var.  \n// Context has information of current Sum and available coins. \n// int is the minimum coin count to satisfy the Context. \n// if there is no solution for this context, the context will not be in this hash table. \nHashTable T = new HashTable(); \n \nclass Context \n{ \n    public int s; \n    public HashTable coins; \n \n    public void Context(int s, int[] arr) \n    { \n        coins = new HashTable(); \n        foreach(int a in arr) \n        { \n            if (coins.ContainKey(a)) \n            { \n                coins[a].value++; \n            } \n            else \n            {  \n                coins.Add(a, 1); \n            } \n        } \n \n        this.s = s; \n    } \n \n    public void Context(int s, HashTable coins) \n    { \n        this.s = s; \n        //TODO: create new HashTable and copy data from coins.         \n    } \n \n    // find all available coins whose values is not greater than the sum. \n    public List AvailableNotGreater() \n    { \n        List t = new List(); \n        foreach(int k in coins.Keys()) \n        { \n            if(k <= s) \n            { \n               t.Add(k); \n            } \n        } \n        return t; \n    } \n \n    // remove a coin from the context. \n    public void Remove(int z) \n    { \n        if(z>s) \n            throw new ArgumentException(); \n \n        if(!coins.ContainKey(z)) \n        { \n            throw new ArgumentException(); \n        } \n \n        s-=z; \n        if(coins[z]==1) \n        { \n           coins.Remove(z); \n        } \n        else \n        { \n           coins[z]--; \n        }          \n    } \n} \n \n// main function for this question. \n// return the minimum coins for the sum (s). return INT_MAX if not found. \nint mainfunc(int s, int[] arr) \n{ \n    Context context = new Context(s, arr); \n \n    f(context); \n \n    if(T.ContainKey(context) \n    { \n        return T[context]; \n    } \n    else \n        return INT_MAX; \n} \n \n// recursive function using DP \nvoid f(Context context) \n{ \n   if(T.ContainKey[context) \n   { \n       return; \n   } \n \n   foreach(int z in context.AvailableNotGreaterSet()) \n   {    \n       if (z == s) \n       { \n           if(T.ContainKey(context)) \n           { \n               T[context] = 1; \n           } \n           else \n           { \n               T.Add(context,1); \n           } \n       } \n    \n       Context contextCopy = new Context(context.s, context.coins); \n       contextCopy = contextCopy.Remove(z); \n \n       f(contextCopy); \n       if(T.ContainKey(contexCopy)) \n       { \n           int curMin = T[contextCopy]+1; \n           if(T.ContainKey(context)) \n           { \n              if(T[context] > curMin) \n                  T[context] = curMin; \n           } \n           else \n           { \n               T.Add(context, curMin); \n           } \n       } \n   } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"dp!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think sorting is not a bad move in this case. I have seen other solutions being downgraded where sorting was involved (probably not because of sorting but because of the actual solution they provided was not correct).  1) Sort the coins in descending order. 2) Now, for each coin, we have a choice to make i.e. to choose it or not. 3) We define a function (in algorithmic sense, not a prog language function)     W(T,C) = min( W(T-Ci,C-Ci)+1  ,  W(T,C-Ci) )   ----for i=1 to #of coins     Before applying this condition, we will also be checking whether the current coin under consideration is greater than the required total sum T. If yes, we will ignore that coin. Maybe we can incorporate it within the definition of W(T,C)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think we can use recursive to solve this problem.   private static ArrayList allSizes = new ArrayList();    public void getAllSize(int[] array, int sum, ArrayList list, int index) {   if (getSum(list) == sum) {    allSizes.add(list.size());    return;   }       if (getSum(list) > sum) {    return;   }      for (int i = index; i < array.length; i++) {    list.add(array[i]);    getAllSize(array, sum, list, i+1);    list.remove(list.size()-1);   }  }    public int getMinNumberCoin(int[] array, int sum) {   getAllSize(array,sum,new ArrayList(),0);   int min = Integer.MAX_VALUE;   for (int i = 0; i < allSizes.size(); i++) {    if (min > allSizes.get(i)) {     min = allSizes.get(i);    }   }      return min;  }    public int getSum(ArrayList list) {   int result = 0;   for (int i = 0; i < list.size(); i++) {    result += list.get(i);   }      return result;  }  /**   * @param args   */  public static void main(String[] args) {   Amazon16_MinNumberCoins a = new Amazon16_MinNumberCoins();   int[] array = {25,5,50,25,25,25,1};   System.out.print(a.getMinNumberCoin(array, 100));  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Isn't it similar to ATM?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"DP, O(N*S)  public int getMinCoins(int[] coins, int count)   {   int[] nums = new int[count+1];   for(int i=0; i<=count; i++)    nums[i] = -1;   nums[0] = 0;   for(int i=0; i  {    int value = coins[i];        for(int j=count-value; j>0; j--)    {     if(nums[j]!=-1)     {      int n = nums[j]+1;      if(nums[j+value]==-1||n     {       nums[j+value] = n;      }     }    }    nums[value]=1;   }      return nums[count];  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int min_no_coin(int a[],int N,int S) {  int min[S+1];  for(int i=0;i<=S;i++)  min[i]=int_max;  min[0]=0;  for(int i=0;i<=S;i++)  {   for(int j=0;j   {     if(a[j]<=i && (min[i-a[j]]+1    min[i]=min[i-a[j]]+1;    }    printf(\"\\n %d %d\",i,min[i]);  }  if(min[S]!=int_max) return min[S]; else return -1; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Sort the array containing values of coins. Take the sum and subtract it from descending order. For the remaining sum after subtraction , perform binary search to rest of the array , if number is found that we have found the Sum with min coins required. If not , continue subtracting and finding the coins"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Coins should be sorted ascending for the code below to work, i sort at the begining of the method."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-5","title":"classic DP"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14954671","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"55","title":"An operation \"swap\" means removing an element from the array and appending it at the back of the same array. Find the minimum number of \"swaps\" needed to sort that array.  Eg :- 3124 Output: 2 (3124->1243->1234)  How to do it less than O(n^2) ?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"How about following? Input: sequence a"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This can be done in O(n), or O(2*n) to be exact. Also don't need to do the swap operation.  Use a 2nd array, swapped[n] (initialized to 0), to record which number needs to be swapped. Also use a variable, min_swapped, to record the current min swapped number (initialized to n+1). Then use another variable, next_min, for the next min value (initialized to 1) which isn't marked as swapped.  The basic idea is   (1) If the current number is larger than the next_min, it needs to be swapped.  (2) If a number is larger than the current min_swapped, it also needs to be swapped.  For (1), use 234561789 as example, all the numbers (ie. 2, 3, 4, 5, 6) before 1 need to be swapped so 1 can be the first element in the array.  For (2), use the same example, 234561789. Before we parse 7, the min_swapped is 2. Thus, 7, 8, and 9 also need to be swapped because, after 2 is moved to the end of the array, 7, 8, and 9 need to be swapped so 2 can be right after 1.  a pseudo code is like following:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"A question for interpretation of \"How to do it less than O(n^2)\" What do you mean by \"it\" you mean the algo for sorting the array? or you mean the algo to calculate minimum steps to sort the array using swap?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about applying quicksort algorithm on that array. While portioning the array wrt to pivot element we need swaps to find the index of pivot position. We can use above swap function to easily append all the elements > pivot to the back of the array fixing index position for pivot element. In this way we can keep swaps are always going to be O(nlogn).  When"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Scan the array from the first element to last, compare consecutive elements. If first is greater then second, then swap first (put it at end of list); else continue. Do so until you don't find any unordered pairs. Something like this:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assumption: swap is not equal to copying and/or overwriting the value.  arr[4]= 3124  sort(arr) {    for(int i=0;i   {      if(arr[i]>arr[i+1])          {                      rotate(arr,i);          }        } }  rotate function will rotate the part of the array that is given to rotate them.  It will always rotate the array from the given point to the end of the array.  eg. 3124  -> rotate function will rotate whole array to the left by one. So 3 will be appended to end.  1243 -> if(4>3) than rotate function will rotate that array of 2 to left. So 4 will be appended to the end.   Hope this helps."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Nice explanation by all of you as Algo is easy to understand then code.....  bt all logic are quite same.... O(n^2) no one gave sol in complexity < O(n^2) as asked in qus"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Concept is below: 10, 17, 6, 5 10 compare 17 ok 17 compare 6 not-ok array{10, 6, 5, 17} 10 compare 6 not-ok array{6, 5, 17, 10} 6 compare 5 not-ok array{5, 17, 10, 6} 5 compare 17 ok 17 compare 10 not-ok array{5, 10, 6, 17} 10 compare 6 not-ok array{5, 6, 17, 10} 6 compare 17 ok 17 compare 10 not-ok array{5, 6, 10, 17} so output 5, 6, 10, 17 and number of times swap is called 6.  include  #define SIZE(x) sizeof(x)/sizeof(x[0])  void swap(int a[], int i, int j) {         int temp = j - i;         int store = a[i];         j = i + 1;         /* first shift */         while(temp){                 a[i] = a[j];                 i++;                 j++;                 temp--;         }         a[i] = store;         printf(\"called\\n\"); }  int main() {         int a[] = {10, 5, 7, 6, 4};         int i = 0;         int j = 1;          while(i != (SIZE(a) - 1)) {                 if(a[i] < a[j]) {                         i++;                         j++;                 } else {                         swap(a, i, (SIZE(a) - 1));                         if(i) {                                 i--;                                 j--;                         }                 }         }         return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"anon's solution provides a pattern of number of steps required to solve the problem.  One of the worst case scenario's: all numbers are in descending order  For n = 1: 0 steps For n = 2: 1 steps For n = 3: 3 steps For n = 4: 6 steps For n = 5: 10 steps For n = 6: 15 steps  i.e. 1 + 2 + 3 + 4 + 5 ... (n-1) = O(n^2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The actual number of swaps is determined by the first element in sequence that is out of the order in the unsorted list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"One expensive way to do a BFS taking the given array as root and having all the arrangements obtained by swapping each element  as child. BFS would give the shortest path from the root to destination node (sorted array) ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def swap(a: Array[Int]): Array[Int] = { \n val len = a.length-1 \n var i = 0 \n var arr = a \n while(i < len){ \n  if(arr(i) > arr(i+1)){ \n   val tmp = arr(i) \n   val bef = arr.take(i) \n   val aft = arr.drop(i+1) \n   arr = bef ++ aft :+ tmp \n   i = if(i > 0) i-1 else i \n  }else { i = i+1 } \n } \n arr \n} \n \nscala> val v = swap(Array(8,3,5,6,1,6,9,0,-1, 78,45)) \nv: Array[Int] = Array(-1, 0, 1, 3, 5, 6, 6, 8, 9, 45, 78)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"O(N) complexity :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"O(N) complexity"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"1. Maintain a min heap of size of N. 2. open a loop, and input traverse the array.  3. For every traversed element, insert the same in MinHeap(along with index). 4. Take the top of heap(minimum number so far) and swap it.  5. At the end of the loop, we will have sorted array with minimum swaps. Space Complexity---0(n) ---- for Heap. Time Complexity---- 0(nlogn)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"do merge sort or heap sort and count the number of times swap happens... o(n log n)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=12810663","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"56","title":"Given an array of N integers  with +ve & -ve numbers. Find the maxproduct of 3 numbers ? & Test Cases","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"10","title":"Well this can be solved in,O(n) time, Here is my solution, Traverse the array, and maintain a linked list of size three ,that stores the three largest elements this takes O(n) time. Now again traverse the array and find the two minimum numbers O(n) time  Now multiply the elements of linkedlist store it as max sum , and compare it with product of two -ve numbers and every element of the maintained linked list return the highest product... This works in O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"#include int max(int a,int b) {   return a>b?a:b; } int prod(int a[],int n) { int min1,min2,max1,max2,max3;  min1=min2=32767; max1=max2=max3=-32767;  int i; for(i=0;i {  if(a[i]>max1)   {   max3=max2;max2=max1;max1=a[i];   }   else if(a[i]>max2)   {    max3=max2; max2=a[i];   }   else if(a[i]>max3)   max3=a[i];   if(a[i] {    min2=min1; min1=a[i];   }   else if(min2>a[i])   min2=a[i];   printf(\"%d %d %d %d %d\\n\",max1,max2,max3,min1,min2);  }   if(min1<0 && min2 <0)   return max(min1*min2*max1, max1*max2*max3);  else   return max1*max2*max3;   }   int main() {   int a[]= {8,4,3,5,2,-1,-9,-10,11};  printf(\"%d\\n\",prod(a,9));   return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Dont know how Kadane is applicable here. It can be done simply by sorting and then multiplying max numbers accounting for signs."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Dont know how Kadane is applicable here. It can be done simply by sorting and then multiplying max numbers accounting for signs."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Dont know how Kadane is applicable here. It can be done simply by sorting and then multiplying max numbers accounting for signs."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Dont know how Kadane is applicable here. It can be done simply by sorting and then multiplying max numbers accounting for signs."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Dont know how Kadane is applicable here. It can be done simply by sorting and then multiplying max numbers accounting for signs."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Dont know how Kadane is applicable here. It can be done simply by sorting and then multiplying max numbers accounting for signs."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Dont know how Kadane is applicable here. It can be done simply by sorting and then multiplying max numbers accounting for signs."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Dont know how Kadane is applicable here. It can be done simply by sorting and then multiplying max numbers accounting for signs."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Dont know how Kadane is applicable here. It can be done simply by sorting and then multiplying max numbers accounting for signs."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Dont know how Kadane is applicable here. It can be done simply by sorting and then multiplying max numbers accounting for signs."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if i sort the linklist and find 1. product of three max numbers 2.product of two minimum nos and the max number....take the max of product 1 and 2 ...will this max give the answer??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if i sort the linklist and find 1. product of three max numbers 2.product of two minimum nos and the max number....take the max of product 1 and 2 ...will this max give the answer??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if i sort the linklist and find 1. product of three max numbers 2.product of two minimum nos and the max number....take the max of product 1 and 2 ...will this max give the answer??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can be solved using dynamic programming using only one pass Let the given array be A. While passing the A from left to right, construct a new array P and keep track of 3 variables x,y,z of whose product is the maximum. while passing through A , suppose we are at position i , then   P[i] = max product of 3 numbers (x,y,z) which lie in between between A[0] to A[i]  when extending the solution to i+1,  P[i+1] = max(P[i], P[i] * A[i+1]/x , P[i] * A[i+1]/y, P[i] * A[i+1]/z)   In each of the later 3 cases, x or y or z will be replaced with A[i+1] Finally P[n-1] contains max product of 3 numbers of A."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void maxProdOf3Nos(long[] a){          long M1,M2,M3,m1,m2;          if(a.length<3) return ;          M1=a[0];M2=a[1];M3=a[2];     m1=a[0];m2=a[1];     long t=0;     if(M1     t=M2; M2=M1;M1=t;         }if(M1     t=M3;M3=M1;M1=t;     }     if(M2     t=M3;M3=M2;M2=t;     }          if(m1>m2){t=m2;m2=m1;m1=t;}     System.out.println(M1+\" \"+M2+\" \"+M3);          for(int i =3;i           if(M1      M3=M2;       M2=M1;       M1=a[i];      }else if(M2      M3=M2;       M2=a[i];      } else if(M3      M3=a[i];      }            if(m1>a[i]){       m2=m1;m1=a[i];      }else if (m2>a[i]) m2= a[i];           }     System.out.println(M1+\" \"+M2+\" \"+M3+\"  \"+m1+\"  \"+m2);     double prod = M1*M2*M3>M1*m1*m2 ?M1*M2*M3:M1*m1*m2;     System.out.println(\"Max Product = \"+prod);              }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int array[]={9,4,1,2,-5,-7}; //-7,-5,2,1 ,4,9   int min;   int second_min;   int max;   min=array[0];   second_min=array[1];   max=array[0];   for(int i=1;i  {      if(array[i]  {      second_min=min;   min=array[i];   }   if(array[i]>max)   max=array[i];   }   System.out.println((min*second_min*max));   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can't this be solved similar to the 3SUM problem? O(n^2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This comment has been deleted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I will simply follow the algorithm.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A naive python implementation: didn't check for many input values. but hope few changes will be required."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Take two arrays a[2] and b[3]  Traverse the list and check for each element if it is >0 then call Max(b) else Min(a), these functions would internally check for elements in the array and sorts them in the array.  finally when all the processing is done, just multiply max element of b with all the elements of a and all the elements of b, whichever is greater is the solution. :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sort the array using quick sort alogorithm (Best case Order(nlogn)). then check the product of 2 and 3rd element of array with the proudct of last two elements of array. WHichever product is greater select that pair with the first element of the array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Another solution can be which is in order(N) complexity.  1. Traverse the array keep track of (three max number max1 max2 max3) along with the track of two minimum numbers (min1 min2) at the end take product of max2 and max3 also product of min1 and min2. check the greater product value and you will have three numbers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* Here is my code in O(n) time. I think it works fine.. Inform if any test case fails or error in code*/ #include #include  int main() {     int i, max1, max2 , max3, min1, min2, min3, A[9] = { 4, 1, -3, 4, -1, 2, 4, -5, 4 };     max1 = 0; max2 = 0; max3 = 0;     min1 = 0; min2 = 0;     for(i = 0; i < 9; i++)     {         if(A[i] >= max1)                 {                 max3 = max2;                 max2 = max1;                 max1 = A[i];                 }                                            if(A[i] <= min1)         {                 min2 = min1;                 min1 = A[i];         }            }     int p_mul = max2 * max3;     int n_mul = min1 * min2;    // printf(\"%d %d %d %d %d\\n\",max1,max2,max3,min1,min2);     if(p_mul > n_mul)              printf(\"%d\", p_mul * max1);     else              printf(\"%d\", n_mul * max1);                          system(\"pause\");    return 0;         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//O(n) soln #include #include  int main() {     int i, max1, max2 , max3, min1, min2, min3, A[9] = { 4, 1, -3, 4, -1, 2, 4, -5, 4 };     max1 = 0; max2 = 0; max3 = 0;     min1 = 0; min2 = 0;     for(i = 0; i < 9; i++)     {         if(A[i] >= max1)                 {                 max3 = max2;                 max2 = max1;                 max1 = A[i];                 }                                            if(A[i] <= min1)         {                 min2 = min1;                 min1 = A[i];         }            }     int p_mul = max2 * max3;     int n_mul = min1 * min2;    // printf(\"%d %d %d %d %d\\n\",max1,max2,max3,min1,min2);     if(p_mul > n_mul)              printf(\"%d\", p_mul * max1);     else              printf(\"%d\", n_mul * max1);                          system(\"pause\");    return 0;         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Pick max 3,and min 2, takes O(n) If biggest one is positive, check remain max 2 product and min 2 product, take the one larger. If biggest one is negative,same, but take the one smaller. Test: 123456, -3 -2 0 1 2 3,  -6  -5 -4 -3 -2 -1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int getMaxProduct(int array[]) { \n  int max1 = Integer.MIN_VALUE; \n  int max2 = max1, max3 = max1; \n  int min1 = Integer.MAX_VALUE, min2 = min1; \n  for (int i = 0; i < array.length; i++) { \n   if (array[i] > max1) { \n    max2 = max1; \n    max1 = array[i]; \n   }else if(array[i]>max2){ \n    max3 = max2; \n    max2 = array[i]; \n   }else if(array[i]>max3){ \n    max2 = array[i]; \n   } \n   if (array[i] < min1) { \n    min2 = min1; \n    min1 = array[i]; \n   }else if(array[i]max1*min1*min2?max1*max2*max3:max1*min1*min2; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include int main() { int arr[]={-1,-5,-2,-6,2,5,3,1,9}; int temp,i,j,k,l,total,max,len; len = sizeof(arr)/sizeof(int); for(i=0;i{ for(j=0;j{ if(arr[j]>arr[j+1]) { temp = arr[j+1]; arr[j+1] = arr[j]; arr[j] = temp; } } } max=(arr[len-1]*arr[len-2]*arr[len-3]); if(arr[0] && arr[1] < 0) { k=-arr[0]; l=-arr[1]; } if(((k>=arr[len-2]) && (l>=arr[len-2]))) { max = (arr[len-1]*k*l); } printf(\"Maxinum:%d\",max); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include int main() { int arr[]={-1,-5,-2,-6,2,5,3,1,9}; int temp,i,j,k,l,total,max,len; len = sizeof(arr)/sizeof(int); for(i=0;i{ for(j=0;j{ if(arr[j]>arr[j+1]) { temp = arr[j+1]; arr[j+1] = arr[j]; arr[j] = temp; } } } max=(arr[len-1]*arr[len-2]*arr[len-3]); if(arr[0] && arr[1] < 0) { k=-arr[0]; l=-arr[1]; } if(((k>=arr[len-2]) && (l>=arr[len-2]))) { max = (arr[len-1]*k*l); } printf(\"Maxinum:%d\",max); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Arrays;  /*Given an array of N integers with +ve & -ve numbers. Find the maxproduct of 3 numbers ? & Test Cases*/ public class Q4 {  int maxProduct(int[] numbers) {   Arrays.sort(numbers);   for (int i = 0; i < numbers.length; i++) {    System.out.println(numbers[i]);   }   int left = numbers[0] * numbers[1] * numbers[numbers.length - 1];   int right = numbers[numbers.length - 1] * numbers[numbers.length - 2]     * numbers[numbers.length - 3];   int[] max = { left, right };   Arrays.sort(max);   System.out.println(\"Max = \" + max[max.length - 1]);   return 0;  }   public static void main(String[] args) {   int[] numbers = { 2, 5, 6, 1, 3, 0, -6, -2 };   int[] numbers1 = { -8, 2, 5, 6, 1, 3, 0, -6, -2 };   int[] numbers2 = { 2, 5, 6, 1, 3, 6, 3 };   int[] numbers3 = { -2, -5, -6, -1, -3, -6, -3 };   int[] numbers4 = { 2, 5, 6, 1, 3, -6 };   int[] numbers5 = { 2, 6, 1, 3, 0, -6, -2 };   Q4 q4 = new Q4();   q4.maxProduct(numbers);   q4.maxProduct(numbers1);   q4.maxProduct(numbers2);   q4.maxProduct(numbers3);   q4.maxProduct(numbers4);   q4.maxProduct(numbers5);  } }  // Test // A. no number 0: // 1. all +ve. --right is max. // 2. all -ve. --right is max. // B. have number 0: // 3. 0 is on the left, and have >=2 -ve. --right or (2 left multiply 1 right) // is max. // 4. 0 is on the right, have <=2 +ve. --right(0) or (2 left multiply 1 right) // is max."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the only combination to have a max product is having combinations has +++ and --+ my idea is to create two arrays ppp[3] and pnn[3] step 1) fill the first 3 positives number of the given array in ppp[3] from left and 1 positive and 2 negative numbers from left of the given array in pnn[3]. step 2) now start traversing from the left if  a[0] >0 then check if a[0] is greater than any of the 3 elements in ppp, if it is then replace the lowest digit in ppp with a[0] and also check if a[0]> pnn[0](the ONLY positive number in pnn)  if  yes then replace pnn[0] with a[0]. if a[0]<0 then check if a[0]step3) and repeat step 2 with a[i] increasing the i each time step 3) compute the max of (ppp[0]*ppp[1]*ppp[2] and pnn[0],pnn[2],pnn[1]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int maxProduct(int a[],int max[],int number,int prod){       int index=0;      for(int i=0;i   if(Math.abs(a[i])>max[number -1]){     max[number-1] = Math.abs(a[i]);     index = i;    }       }   a[index] = 0;   prod *= max[number-1];      if(number-1 == 0 ){       return prod;   }      return maxProduct(a,max,number-1,prod);  }      public static void main(String[] args){   //int[] a = {-5, -7, 4, 2, 1, 9 };   int[] a = {-5, -7, 4,-8,9,1 };   int []max = {0,0,0};   int maxProduct = maxProduct(a,max,3,1);   System.out.println(maxProduct);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"use Kadanes algorithm for O(n) algorithm (nobrainer .co .cc)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Dont know how Kadane is applicable here. It can be done simply by sorting and then multiplying max numbers accounting for signs."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=1814","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"54","title":"Coding: How would you find the nth to last element in a linked list?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Use two pointers. Initalize both pointers to the front of the list then use a loop to traverse one pointer Nth times. Then moves both pointers until one reaches the end of the list. The second pointer is Nth to last element"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here n is the distance from the last element. Is there a better solution out there ??node *getNthToLast(node *head, int *pos, int n) {        if(head==NULL) {                *pos=0;                return NULL;        }        node *nElemNode = getNthToLast(head->next, pos, n);        if((*pos)++==n)                return head;        else                return nElemNode;}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Iteration solutions are generally better than recursive solutions.  Can you do it iteratively?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Well its obvious to do it iteratively if its a doubly linked list... simply traverse till the last node... now traverse back n nodes.On the other hand if its singly linked I dont see how it can be done in an \"efficient\" manner (without doing something stupid like using extra memory!). You really have to first find the length of the list somehow.... a quick way could be to traverse the list 2 nodes in each iteration of the while/for loop (something I would do to find the middle element of a linked list). Dunno if this makes sense ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using extra memory isn't much worse than a recursive solution.  Every time you add a level to your recursion, you increase the stack.  Memory usage for your recursive solution is O(n) anyway."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@KHOA   U may be right... i also think that 2 pointers make sense and simplifies the solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the size of the list is M(compute this) and you want N, then traverse a  pointer M-N-1 times."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Taking Khoa's idea further...something like this....int findNthPos(int pos){ LLIST ptr1,ptr2; ptr1=ptr2=head; int current=pos; while(ptr1->next) {  current = pos;  ptr2= ptr2->next;  ptr1 = ptr2;  while(current-- >0)  {   if(ptr1!=NULL)   ptr1=ptr1->next;  }   } return ptr2->data;}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Khoa's solution would work fine. To put it into codeint findNthPos( LinkedList* listHead, int pos ){    if ( pos < 0 || listHead == NULL )         return FAILURE;    LinkedList *ptr1, *ptr2;    ptr1 = ptr2 = head;    while( pos > 0 )    {      if( ptr1 == NULL )        return FAILURE; // could return some other error value      ptr1 = ptr1->next;      pos--;    }    while( ptr1 != NULL )    {         ptr1 = ptr1->next;         ptr2 = ptr2->next;    }    return ptr2->data;}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Trying to see if i can put spaces in here ... being a Virgo, i tend to be fussy about small things sometimes :-)int findNthPos( LinkedList* listHead, int pos){    if( pos < 0 || listHead == NULL )        return FAILURE;// look up the previous answer for complete code}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node* findNthPos( node* head, int pos ) {node *nth, *current;int n = 0;nth = listHead;current = listHead->next;while(current){current = current->next;if(n == pos){nth = nth->next;}else{n++;}}}if(n == pos)  return nth;else  return NULL;  /* no such node */}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node findNode(LinkedList list, int pos){   int size=0;   iter=list.head;   while(iter != null)   {     size++;     iter = iter -> next;   }   foundNode=list.head;   for(int i=2;i<=size-pos;i++)   {      foundNode=foundNode->next;   }   return foundNode;}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Although the above solutions may work, such complex solutions can potentially introduce bugs that are cumbersome to detect."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just for fun...to find the nth to last element.If you know how many elements are in the linked list, and you have a pointer to the first element and the last element.  Also, assuming that its a double-linked list.Determine if the Nth element is closer to the front of the list, or the back of the list, ie (length/2).  If its closer to the front of the list, travse from the front of the list.  If its closer to the back of the list, traverse from the back."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Khoa's solution would work fine. To put it into code node* findNthLast(node* head, int n){ if(n<0){ //check for negative inputcout<<\"Error\";return NULL;}node *nBehind;     //n-behind pointernode *curr = head;for(int i=0; iif(curr->next){curr = curr->next}else{return NULL;}nBehind = head; while(curr->next){curr = curr->next;nBehind = nBehind->next;}return nBehind;}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Khoa's solution would work fine. To put it into code node* findNthLast(node* head, int n){ if(n<0){ //check for negative input cout<<\"Error\"; return NULL; } node *nBehind; //n-behind pointer node *curr = head; for(int i=0; iif(curr->next){ curr = curr->next } else{ return NULL; } }nBehind = head; while(curr->next){ curr = curr->next; nBehind = nBehind->next; } return nBehind; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What is the difference between 2 pointers solution and Jack's solution? i.e.1. Count the number of elements. O(M) time, say M nodes totally.2. From begining travel M-N+1 steps.The numbers of steps are the same for both."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The 2 pointer approach will take only M steps."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think 2 pointer approach also takes 2M-N+1 moves."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why don you take Saloni's code and spend some time to analyze the number of steps."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming that Node represents a node in the linked list.struct ptrpos{Node *ptr;int pos;}With array of n structures ptrpos_array, walk through the list and fill in the array with pointer to the nodeand its position till you reach the end. Now we knowthe number of nodes lets say it is m. The pointer tothe nth node is at ptrpos_array[m-n+1].This approach also takes o(m)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Forget to mention, just round robin the arrayfilling once you reach the end of the array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ListNode* nthFromBack(LinkedList* list, int n){  int i = 1;  ListNode* node = list->first;  ListNode* to_return = NULL;  while (node)  {    if (i == n)      to_return = node;        node = node->next;    i++;  }  return to_return;}I'd test this with a few test cases... the edge cases (list size 0, 1), maybe a five-element list, and a case where n is greater than the list size."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ListNode* nthFromBack(LinkedList* list, int n){ int i = 1; ListNode* node = list->first; ListNode* to_return = NULL; while (node) {   if (i == n)   {     to_return = list->first;   }   if (i>n)   {     to_return = to_return->next ;   }      node = node->next;   i++; } return to_return;} Hi Corrected code is above.. Please check the difference"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"take 2 pointers...move one N steps and then start moving the second also..when the first hits last the second is Nth from last :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node *find(int n, node *p) {    node *temp;    int num = 0;    if (p == NULL) return -1; /* checking error condition */    if (n == 0) return p; /* another error case */    temp = p;    while (p != NULL && num < (n-1)) {        p = p->next; num++;    }    if (p == NULL) return -1; /* list is not big enough */    while (p != NULL) {        p=p->next; temp=temp->next;    }    return temp;}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Amazing solution and smart too.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi guysI think instead of using two pointers and then traversing the list we could use some extra space and do it with one pointer.We can use a circular queue of size n+1 and then start traversing the list till end and keep inserting the elements in the queue.When we reach the end of the list the front element in the queueis the required node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Take 2 pointers A and B2) Point both to starting of list A=0 b=03) Move one pointer to nth node A=n-14) Move both the pointers and stop when A hits the last Node .Now B will point to the Nth Node from last"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Khoa's solution is right and it is also mentioned in the book PIE with the same solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void show_n_elment(link *ln, int N){ link *nelement = ln, *node = ln; int i = 0 ; while(i < N && node != NULL) {  i++;  node = node->next; } if(i != N) {  printf(\"\\n No. of element in link list is less than %d \\n \",N);  return ; } else {  while(node != NULL)  {   node = node->next;   nelement = nelement->next;  } } printf(\"\\n %dth element of link list from end is : %d \" ,N,nelement->info);}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simple approach on khoa's solutionstruct list { int data; struct list *next;};typedef struct list myList;myList * find5thNode(myList *head){ myList *fast = NULL; myList *slow = NULL; int count = 1; fast = slow = head; while(NULL != fast) {  if ( (count >1) && ((count % 5) == 1)) /* 5 times slower then fast pointer*/   slow = slow->next;  fast = fast->next;  count++; } /* in case list contains lesser than 5 nodes, this returns NULL, which is ok as there is no 5th node in the list */ if(count <5)  return NULL; else  return slow;} }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For any number n, just replace 5 with n. (count%n) does the trick, it moved slow pointer n times slower than the first one."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i dont exactly understand this...Does this find nth from the tail?like if we have to find rd from the tail with 10 nodes, does the code find the 7th node?The problem is more of complexity.One solution is to count the nodes and return the 7th (after you know that there are 10 elements), or maintain a counter as u add nodes.The simpler solution is to run two pointers, ptr0 and ptr1, and start using ptr1 after ptr0 has reached the nth element (checking that it is not out of bounds)Thus, when ptr1 reaches the end of the list, ptr1 points exactly to the nth from tail element.The above solution gives n from front.The point to note is nth from tail is difficult in a singly linked list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am of a different opinion. Better use a stack. Assuming worst case where this linked list is single linked list . We do not know number of nodes we do not know the size. Just keep pushing addresses of nodes on a stack still you get end of list. When end of list is achieved just pop n-1 nodes addresses from the stack and peek top of stack. You will get nth node from last. Any suggestions on this approach??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I thin that stack approaching is not good in terms of memory management and we also need additional work for sorting either. as you mentioned, we do not know how big the size of liked list. but no matter what it's O(m) iteration would be better, I mean it's simple and clear enough I think."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Reverse the list (which can be done in O(n) ) and find the nth position and again reverse the list"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include#includeusing namespace std;struct node  {       int data;     node *nxt;// Pointer to next node  };node *start_ptr = NULL;node *current;   // Used to move along the listvoid add_node_at_end()  {  node *temp, *temp2;   // Temporary pointers     // Reserve space for new node and fill it with data     temp = new node;     cout << \"Please enter the data value: \";     cin >> temp->data;     temp->nxt = NULL;     // Set up link to this node     if (start_ptr == NULL)       { start_ptr = temp;  current = start_ptr;       }     else       { temp2 = start_ptr;         // We know this is not NULL - list not empty!         while (temp2->nxt != NULL)           {  temp2 = temp2->nxt;              // Move to next link in chain           }         temp2->nxt = temp;       }  }void display_list()  {  node *temp;     temp = start_ptr;     cout << endl;     if (temp == NULL)       cout << \"The list is empty!\" << endl;     else       { while (temp != NULL)    {  // Display details for what temp points to              cout << \"Data : \" << temp->data;       if (temp == current)  cout << \" <-- Current node\";              cout << endl;       temp = temp->nxt;    }  cout << \"End of list!\" << endl;       }  }void findNthLast(){    node *nBehind;     //n-behind pointer    node *curr = start_ptr;    int n=3;    for(int i=0; i    {         if(curr->nxt)       {                     curr = curr->nxt;       }    }    nBehind = start_ptr;    while(curr->nxt)    {                    curr = curr->nxt;                    nBehind = nBehind->nxt;    }    cout<<\"The third last element is :\"<data;}int main(){    start_ptr = NULL;    char option;    do {   display_list();   cout << endl;   add_node_at_end();   cout<<\"Enter another value (y/n):\";   cin>>option; }while (option == 'y'); display_list(); cout<<\"Here is the third node from the end in the list\\n\"; findNthLast(); getch();}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If we don't have to maintain the list in its original form, then reverse the list as we iterate the first time. So from L, we now have L' (reversed list). Now iterate N steps in L' to reach Nth last element in original list L. This would require M+N-1 steps. However, it keeps the list in reversed state. If N is very close to M, then this approach is worse than iterating twice on L. Worst case performance of both approaches are the same. If you are going to hit the 'back' of the list, then the approach stated above would work better."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ok"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node* nth_last(node* head, int n) \n{ \n node* nth; \n int i; \n nth=head; \n for(i=0;inext; \n if(!nth) return 0; \n while(nth) \n { \n  nth=nth->next; \n  head=head->next; \n } \n return head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"2-pointer approach is the best solution for this question.   All other solutions need extra time or space. Stack / Hash map approach needs extra O(n) space. Recursion (whoever suggested the reversing-approach) is equally bad. Recursion eats up a lotta stack. The function stack's size grows by twice with every recursive call.  So, stick to slow-fast pointer method which is O(n) max."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I want to solve this problem using recursion in JAVA. Can anyone please help me out?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//c# \n public Node nthToLast(int n) \n        { \n            Node runnerNode1 = firstNode; \n            Node runnerNode2 = firstNode; \n \n            for (int j = 0; j < n - 1; ++j) \n            { \n                runnerNode2 = runnerNode2.nextNode; \n            } \n            while (runnerNode2.nextNode != null) \n            { \n                runnerNode1 = runnerNode1.nextNode; \n                runnerNode2 = runnerNode2.nextNode; \n            } \n            return runnerNode1; \n        }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=11543949","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"54","title":"Given a number,find the next higher number using the same digits in the number. Eg- 15432, Soln- 21345.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"import java.io.BufferedReader; \nimport java.io.IOException; \nimport java.io.InputStreamReader; \n \n \nimport java.util.*; \npublic class nextBigI \n{ \n public static void main(String args[]) throws IOException \n { \n     BufferedReader br= new BufferedReader(new InputStreamReader(System.in)); \n     System.out.println(\"Enter an integer value\"); \n     int n=Integer.parseInt(br.readLine()); \n     nextBigI.big(n); \n } \n static void big(int a) \n { \n   String n=a+\"\"; \n   char c[]=n.toCharArray(); \n   for(int i=c.length-1;i>=1;i--) \n   { \n       if (c[i-1]>c[i]) \n       { \n           continue; \n       } \n       else \n       { \n         //swap \n           int index=nextBigI.check(c,c[i-1]); \n           char temp=c[i-1]; \n           c[i-1]=c[index]; \n           c[index]=temp; \n            \n           Arrays.sort(c,i,c.length); \n           \n           break; \n       } \n        \n   }nextBigI.print(c); \n } \n static void print(char c[]) \n { \n     for(int m=0;m=0;k--) \n         { \n           if(a[k]>j) \n            break;  \n         }     \n         return k; \n } \n  \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Code: h t t p://codepad.org/3yb97kQR - Split the number into digits - Scan from right to left (digits) till we find the digit lower than what we have passed by.  Let us, call this as flip-point.   - Find 'Next Highest' of the flip-point left digit with in the flip-point right portion (not in the whole set of digits).   - Swap and flip-point left digit with 'Next Highest'.  - Now sort the digits from the flip-point onwards (and including flip-point) - Construct the number back from digits  For example:  Input = 12345, Flip = 5, Next Highest = 5, Answer = 12354 Input = 13483, Flip = 8, Next Highest = 8, Answer = 13834 Input = 37723971, Flip = 9,  Next Highest = 7, Answer = 37727139  Thanks, Laxmi"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"/*I think the problem bases itself on the mathematical fact that the difference of 2 numbers consisting of same digits, is always a multiple of 9. so, the pseudo code for this is : 0. take the input number 1. add 9 to input number 2. check if new number's digits and the input numbers digits are same. 3. if yes, then return the new number 4. if no, then 4a. if number of digits in new number > number of digits in input, then bail out and tell that the input number is the largest. 4b. else repeat 1 to 4 */    private static void FindNextLargest()         {             int input = 100001;             int newNum = input;             int ret = 0;             do             {                 newNum = newNum + 9;                 ret = AreSameDigits(input, newNum);             }             while (ret != 0 && ret != -2);              Console.WriteLine(input + \" => \" + newNum);         }          private static int AreSameDigits(int input, int newNum)         {             ArrayList inputnums = new ArrayList(input.ToString().ToCharArray());             inputnums.Sort();              ArrayList newnums = new ArrayList(newNum.ToString().ToCharArray());             newnums.Sort();              if (newnums.Count > inputnums.Count)                 return -2;              for (int i = 0; i < inputnums.Count; i++)             {                 if ((char)inputnums[i] != (char)newnums[i])                 {                     return -1;                 }             }             return 0;         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What i did is i first sorted the number in increasing order. Say the sorted one is n and original is o.  Then starting from end,replacing the last digit of n with second last. Then checking it with original o. If its greater, then we have the solution. Repeating this till the first digit of sorted n is replaced with second digit.  eg- o=15432, n=12345. n= 12354,12435,13245,21345 (answer)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what if o=12453 ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hey, This can be done as follows,  1. Find the transition point from right to left. i.e, from higher to lower. In this case the transition occurs at 1. 2. Then sort the numbers present at right of the transition point alone. In this case, 1 2345. 3. Then swap the number with the closest higher number in the right side. 2 1 345."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  using namespace std; int main(int argc, char * argv[]) {     int lo,hi,num = atoi(argv[1]);     stack  s1,s2;     lo = num%10;     num = num/10;     s1.push(lo);     while(num != 0){         lo = num % 10;         num = num / 10;         if(lo < s1.top()){             while(!s1.empty() && s1.top() > lo){                 s2.push(s1.top());                 s1.pop();             }             hi = s2.top();             s2.pop();             s2.push(lo);             while(!s1.empty()){                 s2.push(s1.top());                 s1.pop();             }             num = num*10+hi;             while(!s2.empty()){                 num = num * 10 + s2.top();                 s2.pop();             }             cout<<\"result: \"<<            return 0;         }         s1.push(lo);     }     cout<<\"no such number exists\\n\";     return 1; }  ./a.out 13434"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Let put every digit into an arry. Now let's iterate this arry from the tail to th front. For every digit in this arry, find the digit which is in the arrary and just bigger than the digit, if found, swap them and stop the iteration.   unsigned int FindNumber(unsinged int input) {  std::vector v;    while(input > 0)  {   v.push_back(input % 10);   input /= 10;  }    vector::reverse_iterator riter = v.rbegin();  for(; iter != v.rend(); +iter)  {   vector::reverse_iterator riter1 = v.rbegin();   unsigned min = 0xffffffff;   vector::reverse_iterator minIter = v.rend();   for(; iter1 != v.rend(); ++ iter1)   {    if(riter != riter1 && *riter1 > *riter && *riter1 < min)    {     min = * riter1;      minIter = riter1;       }   }      if(minIter != v.rend())   {    unsigned int temp = * minIter;    *minIter = *riter;    *riter = temp;    break;   }       }   vecotr:;iterator iter = v.begin();  unsigned int ret = 0  for(; iter != v.end(); ++iter)  {   ret = ret * 10 + *iter2;  }   return ret;   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Consider the last digit in the number.find the first smaller number to the last digit traversing from end.insert the last digit before this number and sort all the digits after the inserted number Ex: 14532  Insertion: 21453 Sort: 21345  Another ex: 12543 Insertion: 13254 Sort: 13245"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Consider the last digit in the number.find the first smaller number to the last digit traversing from end.insert the last digit before this number and sort all the digits after the inserted number Ex: 14532  Insertion: 21453 Sort: 21345  Another ex: 12543 Insertion: 13254 Sort: 13245"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Majority of the solutions here assuming the digits are unique.  Original question poster might need to clarify that part. I guess we should also consider stuff like 33434 (ans: 33443).  This sounds to me the other problem where we need to find all numbers in sorted order for a given N.  That is, N = 1: 1 N = 2: 11, 12, 21, 22 N = 3: 111, 112, 113, 121, 122, 123, 131, 132, 133, 211, 212, 213, 221, 222, 223, 231, 232, 233, 311, 312, 313, 321, 322, 323, 331, 332, 333  In this case, N = number of digits in the given number  We have to drop the sequence generation in this program after we hit the input number, and till we find the next number that uses the same digits (and the number of repetetions).  Thanks, Laxmi"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am giving a hint to solve the problem.   at every index i starting from 0 we ask 2 questions  1. Does A[i] to A[n-1] is strictly decreasing. if not we recurse , we stop the recursion if i = n-3. at this stage if it is not strictly decreasing we can exchange n-1 and n-2.  2. if yes we stop recursion.  Below the recursive call we find out if we have returned from 1. or 2.  If we returned from 1. nothing more to be done. if we returned from 2. a small juggling of the sorted(descending) from that index is kind of enough to solve the problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have return Simple java program.  public class nexthigherValue {     public static void main(String args[]){         int givenNumber = 15432;         boolean nextHigherValFlag = false;         int givenNumberValueIncrement = givenNumber;         while(!nextHigherValFlag){             givenNumberValueIncrement++;             if(String.valueOf(givenNumberValueIncrement).length() == String.valueOf(givenNumber).length()){                 String tempString = String.valueOf(givenNumberValueIncrement);                 int intialIcount = 0;                 String givenNumberStr = String.valueOf(givenNumber);                 for(int i = tempString.length() ; i > 0 ;  i--){                     String charTemp = tempString.substring(i-1, i);                     if(givenNumberStr.contains(charTemp)){                        givenNumberStr = givenNumberStr.replaceFirst(charTemp, \"\");                        intialIcount++;                        if(intialIcount == String.valueOf(givenNumberValueIncrement).length() ){                            nextHigherValFlag = true;                           System.out.println(\"Next higher Value is:\"+givenNumberValueIncrement);                        }                     } else{                         break;                     }                 }                              } else{                 System.out.println(\"It is not possible\");                 nextHigherValFlag = true;             }         }     }      }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Scan from left to right: For each position check for next greater number than current in all positions to its right. If exists, swap and return.  So for 15432, start from 2 (no numbers to right so skip), next 3 (no numbers greater than 3 to right), next 4 (no numbers greater than 4 to its right), next 5 (no numbers greater than 5 to its right), next 1 (2 is next greater number of all positions to its right). So swap it 21345"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Scan from right to left. Find the first instance where the digit is lesser than the digit to its right. Now find the minimum of the digits to its right which is still greater than the current digit and swap them. Finally arrange everything to the digit's right in ascending order which should be very close to the reverse order so the overall complexity still remains O(n).  Do let me know if there are any errors / improvements possible in this solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"When we exchange 2 digits at position i and j, we essentially change the number by amount 10^i (x-y) + 10^j(x-y). We want this difference to be as small as possible and positive.  Hence we scan the digits from right to left to find the 1st number which is lesser than the number on it's right. We swap this with smallest number among the numbers on the right. And then re-arrange all the numbers on the right so that the bigger numbers move as far right as possible (basically in ascending order)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"*Note: x and y refer to the digits being exchanged above."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"first find the next highest digit number. here it is 2 . Now swap this with first digit. Now number becomes 25431 second step is sort elements in ascending order from 2 position.  it's O(n+n)= (n) solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A simple solution exist for this problem . Lets take example of 1243 find all possible combination of numbers for this case it should be :- 1243 1234 2134 2314 2341 and so on . Store it in a array and in a single pass you can simply find the immediate bigger number ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorting is not required.  while (length >= 0) {   if (str [length] > str [length -1])   {     swap (str [length], str [length - 1]);     break;   }    swap (str [length], str [length - 1]);   --length; } // str - String // length + 1 : Start index // strlen (str) - 1 : End index // Reverse string between start and end index reverseString (str, length + 1, strlen (str) - 1);   Example:  15432 -> 15423 -> 15243 -> 12543 -> 21(345) 12345 -> 12354() 124875 -> 124857 -> 124587 -> 125487 -> 1254(78)  Where digits in '()' are reversed.  Complexity:  Int to String O (N) +  Find Fliping point O (N) +  Reverse substring O (N) +  String to Int O (N)  Overall: O (N)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a sample code in java....  { public class FindNextNumber {   public static void main(String[] args)  {   FindNextNumber sF = new FindNextNumber();   long input = 342167;   System.out.println(\"Input Number \"+input);   System.out.println(\"Output: \\n\" +     \"Next Number --> \"+sF.findNext(input));   }    public long reverse(long n)  {   long s = 0;    long d = n / 10;   long t = n % 10;    s = (t * 10) + d;    return s;  }   public long findNext(long k)  {    String kStr = Long.toString(k);    if (kStr.length() == 2)   {    long rev = reverse(k);    if (k < rev)    {     return rev;    }    else    {     return k;    }   }   int i = 2;   while ((i) <= kStr.length())   {     String l2 = kStr.substring((kStr.length() - i), kStr.length());    long rem = k - Long.valueOf(l2);    long newVal = 0;    if (l2.length() == 2)    {     newVal = rem + reverse(Long.valueOf(l2));    }    else    {     newVal = rem + Long.valueOf(getNext(l2));     }    if (newVal > k)    {      return newVal;    }     i++;   }    return k;  }   public String getNext(String s)  {   long first = Long.valueOf(\"\" + s.charAt(0));    char[] charArray = s.toCharArray();   Arrays.sort(charArray);   String sorted = new String(charArray);    long m = -99;;   for (int i = 0; i < sorted.length(); i++)   {    long c = Long.valueOf(\"\" + sorted.charAt(i));     if (c > first)    {     m = c;     break;    }   }   if (m != -99)   {    sorted = sorted.replaceFirst(Long.toString(m), \"\");    sorted = Long.toString(m) + sorted;    return sorted;   }   else   {    return s;   }   }  }   } friends let me know if this will work...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i have a way to solve the problem. i kind of solves many cases but fails in one case. when the number is 13483 the answer should be 13834 but my program returns 31348. please have a look at my program and please suggest if we can improve it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Below is the implementation of the algorithm in c++ with all the descriptions inlined as comments:  template  void __swap(T& left, T& right) {  T tmp;  tmp = left;  left = right;  right = tmp; }  bool digs_to_int(char dat[], int elcount, int& val) {  int retv = 0;  if (0 == elcount)      return false;     val = -1;  for (int i = 0; i < elcount; i++){   retv = retv * 10 + dat[i];  }    val = retv;  return true; }  /**     - start scanning from the right at position (elcount - 1) and find the digit        with index @i such that d[i] < d[i+1];     - sort the array from @i+1 to @elcount     - from position @i+1 find the smallest digit such that d[i]    - swap(d[i], d[smallest_digit_pos])       @dat - the array of chars with the number digits      @elcount - count of elements in the array  */ bool next_max_val(char dat[], int elcount, int& nxtmax) {     int i;  int minidx; // index of the first value on the right of the pivot that is greater than the pivot value  int pividx; // the pivot index     int eidx; // the last index of the array          nxtmax = -1;     eidx = elcount - 1;  pividx = -1; // initially set to invalid index (not found)  minidx = -1;   /* Find the digit that is less than its successor digit. */  for (i = eidx - 1; i >= 0; i--) {   if (dat[i] < dat[i + 1]) {    pividx = i;    break;   }  }    /* If there is no such digit then this is the maximum value */  if (-1 == pividx) {   digs_to_int(dat, elcount, nxtmax);   printf(\"This is the maximum number: %d\\n\", nxtmax);   return true;  }    /* Sort the array starting from the element next to the pivot */  std::sort(dat + pividx + 1, dat + eidx + 1);    /* Find the first digit in the rest of the sorted digits that is > than   the pivot value at dat[pividx]*/  for (i = pividx + 1; i < elcount; i++) {   if (dat[pividx] < dat[i]) {    minidx = i;    break;   }  }   /* Swap the pivot value and the minimal value in the rest of the    * sorted array. */  __swap(dat[i], dat[pividx]);    digs_to_int(dat, elcount, nxtmax);  return true; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Works with all the test cases that were provided in the comments, code is in JAVA"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def nextHighest(n): \n  na = intToArray(n) \n  for i in range(1, len(na)): \n    sbiggeri = smallestBigger(na[i], i, na) \n    if sbiggeri > -1: \n      swap(i, sbiggeri, na) \n      break \n  return intArrayToInt(na) \n     \n# returns -1 if it cannot find a smallest digit which is greater than d \ndef smallestBigger(d, h, na): # h is exclusive \n  mind = 10 \n  mini = -1 \n  for i in range(h): \n    if na[i] > d and na[i] < mind: \n      mind = na[i] \n      mini = i \n  return mini \n \ndef countDigist(n): \n  nd = 1 \n  n = n / 10   \n  while n != 0: \n    nd += 1 \n    n = n / 10   \n  return nd \n \ndef intToArray(n): \n  c = countDigist(n) \n  na = [] \n  for _ in range(c): \n    di = n % 10 \n    n = n / 10 \n    na.append(di) \n  return na \n \ndef intArrayToInt(na): \n  n = 0 \n  for i in range(len(na)): \n    n += na[i] * pow(10, i) \n  return n \n \ndef swap(i, j, a): \n  tmp = a[i] \n  a[i] = a[j] \n  a[j] = tmp"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static char[] high(int num){ \n  char[] ch = Integer.toString(num).toCharArray(); \n  int point = ch.length-1; \n  String sRev = \"\"; \n  Boolean isSwapped = false; \n   \n//Find the pivot point as well as store the asc order number \n  for(;point >0 && ch[point]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//I've tested the following program. I think it is correct \n//I've included the main method, so you can try it directly \n//Assuming input is n, and n(0) represent MSB of n  \n//The logic is first scan the number from LSB to MSB  \n//Find the first decreasing n (i) > n (i+1); \n//Scan from i to 0 to find if there is a n(i)>n (j) > n(i+1); \n// if there is swap the value on j and i + 1, otherwise swap i and i+1 \n// For example: 322431. From right to left, 1 to 3 increase, to 4 increase \n// to 2 decrease, so scan back and find 3 is larger than 2 and smaller than 4 \n// so swap 2 and 3, we got 323421. \n// Exception if there is no decreasing like 54321, there is no such a number  \n// just return -1 \npublic class findNextValue { \n public static int findNext (int number ){ \n      int MAX_NUMBER_OF_DIGITS = 10; // 32-bit integer max \n                                     // value is  2,147,483,647 \n      int [] temp = new int [MAX_NUMBER_OF_DIGITS]; // storing scaned digit \n       \n      int dig = 10; \n      temp [0] = number % dig; // first digit \n      int counter  = 1; \n      boolean found = false; \n          // scan from right to left to find a decreasing point \n      while (number * 10 > dig){ \n           int t = number - (number / (dig * 10)) * (dig * 10); \n           t /= dig; // get current digit \n           temp [counter] = t; \n           if (temp[counter-1] > t){ // compare with last digit to see if there is a decrease \n             found = true; \n             counter ++; \n              break; \n           } \n           counter ++; \n           dig = dig * 10; \n      } \n           \n      if (!found){ \n       return -1; // no decreasing no such a number \n      } \n      int swapIndex = counter - 2; // the candidate to swap is the last one  \n          // find if there is a smaller one to swap \n      for (int i = 0 ; i< counter ; i++){ \n           if (temp [i] > temp [counter -1]){ \n                if (temp[i] < temp[swapIndex]){  \n                     swapIndex = i; \n                } \n           } \n      } \n      swap (temp, swapIndex, counter-1); \n       \n          int sum = 0; \n      dig = 1; \n          // calculate new value of the scanned part \n      for (int i = 0 ; i < counter ;i ++){ \n           sum += temp[i] * dig; \n           dig = dig * 10; \n      } \n          // for the orginal number trim the old scanned part then add new scanned part \n      number = (number / dig) * dig + sum; \n       \n          return number; \n } \n public static void swap (int arr[], int i, int j){ \n      int temp = arr[i]; \n      arr[i] = arr[j]; \n      arr[j] = temp; \n } \n  \n public static void main (String args[]){ \n  System.out.println(findNext (322431)); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"simply find the next permutation"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using recursion and Permutations"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* \n  scan digits from right to left (n to 1) keep track of count for each digit \n \n  if digit(i-1) < digit(i) replace digit(i-1) with the minimum most digit in digit(i...n) \n \n   .. then populate n to i with the count array using the msd of the count array \n \n  O(N) \n  */ \n \n public static int findNext(int number) { \n  char arr[] = String.valueOf(number).toCharArray(); \n \n  int count[] = new int[10]; \n \n  for(int i = arr.length - 1; i > 0; i--) { \n   int digit = Integer.valueOf(String.valueOf(arr[i])); \n   int nextDigit = Integer.valueOf(String.valueOf(arr[i-1])); \n   count[digit]++; \n \n   if(digit > nextDigit) { \n     \n    for(int j = nextDigit + 1; j < count.length; j++) { \n     if(count[j] > 0) { // this is the digit to be replaced \n      count[nextDigit]++; \n      count[j]--; \n      String numStr = String.valueOf(Arrays.copyOfRange(arr, 0, i-1)) + j; // from 0...i-2+j \n \n      for(int k = 0; k < count.length; k++) { // drain lowest first \n       while(count[k] > 0) { \n        numStr = numStr + k; \n        count[k]--; \n       } \n      } \n       \n      return Integer.valueOf(numStr); \n       \n       \n     } \n    } \n   } \n \n  } \n \n  throw new IllegalArgumentException(\"Can not find a next greater number using \" + number); \n }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=12663669","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"54","title":"Given a String - aaaabbbbcc, convert the given string in to a4b4c2 without using extra memory. ( Note that every character appears more than once in input string and the repeated characters are contiguous)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"This code handles everything one wants."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"This solution works only if the repeat-count is one-digit, it is easy to change it to handle cases when repeat-count is 1+ digits"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Considering the repetitive characters will appear consecutively, my solution is (in java)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use counting sort with indices as [ch-'a'], complexity O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Could you please help with pseudo code."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You cannot do it without extra memory. You need at least a variable to keep the sums and a variable to keep the index of the character read/processed. A String is an immutable object, you cannot use it to store the sums or to pop elements to avoid the need of the index variable."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if the input is s=\"abc\"; can input be lyk dis ..? if yes it needs extra space na. since v hav 2 print lyk a1b1c1..? am i ryt..?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if the input is s=\"abc\"; can input be lyk dis ..? if yes it needs extra space na. since v hav 2 print lyk a1b1c1..? am i ryt..?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what about the input like aaabbacbc ? here also each character appeared more than once..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \nint main (int argc, char * argv[]) \n{ \n    std::string str=\"aaabbbcccc\"; \n    while(str.rfind(str[0]) != std::string::npos){ \n        std::cout << str[0] << str.rfind(str[0])+1; \n        str = str.substr(str.rfind(str[0]) + 1); \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  char* func(char *ip);  main(){     printf(\"%s\\n\",func(\"firefoxthunderbirddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd\"));     getchar(); }  char* func(char *ip) {     int i=0,j=0,k=0;     int tmp[26] = {0,};     char temp_ch[100];          char *out = (char*) malloc(strlen(ip)+1);//this is to return required string from function               for(i=0; i        tmp[ip[i]-'a']++;     }              i=0;     for(j=0;j        if(tmp[ip[j]-'a'] != -1){             itoa(tmp[ip[j]-'a'],temp_ch ,10);             out[i++] = ip[j];             k=0;             while(temp_ch[k] != '\\0')             {                 out[i++] = temp_ch[k++];             }             tmp[ip[j]-'a'] = -1;         }      }         out[i] = '\\0';       return out; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static String compress(String data) {  StringBuffer sb=new StringBuffer();  for(int i=0;i {   sb.append(data.charAt(i));   int j=i;   int count=0;   while(j  {    j++;    count++;   }   if(count!=1)    sb.append(count);   i=i+count;  }  return sb.toString(); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"char* ptr=\"aaaabbbbbccddd\"; \n char ch; \n int count=0; \n while(*ptr) \n { \n  ch = *ptr; \n  while(*ptr == ch && *ptr!='\\0') \n  { \n   ptr++; \n   count++; \n  } \n  cout << ch << count; \n  count=0; \n } \n return 0;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java Code: ---------------"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void printString(char* s){  while (s){   cout << *s << printNumChar(s, s);   s += printNumChar(s, s);  } }  int printNumChar(char* start, char* end){  if (end){   if (*start == *end)    return printNumChar(start, end + 1) + 1;   else    return 0;  }  else   return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void printString(char* s){ \n while (s){ \n  cout << *s << printNumChar(s, s); \n  s += printNumChar(s, s); \n } \n} \n \nint printNumChar(char* start, char* end){ \n if (end){ \n  if (*start == *end) \n   return printNumChar(start, end + 1) + 1; \n  else \n   return 0; \n } \n else \n  return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If we read the question properly we need not store the output , just need to print ,  So parse the string in O(n) and print the count if the string changes  void printOutput(String args[])     {         String s = args[] ;         s = \"aaaaabbcccccc\";         int count =1;         System.out.print(s.charAt(0));         for(int i=1;i        {             if(s[i-1]==s[i])             {               count++;             }             else            {               System.out.print(count);               System.out.print(s.charAt(i));               count=1;            }                     }        System.out.print(count);     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If we read the question properly we need not store the output , just need to print ,  So parse the string in O(n) and print the count if the string changes  void printOutput(String args[])     {         String s = args[] ;         s = \"aaaaabbcccccc\";         int count =1;         System.out.print(s.charAt(0));         for(int i=1;i        {             if(s[i-1]==s[i])             {               count++;             }             else            {               System.out.print(count);               System.out.print(s.charAt(i));               count=1;            }                     }        System.out.print(count);     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since no extra memory is allowed, we can do an in place sorting O(nlogn) then in O(n) we can solve the problem. So over all time complexity is O(nlogn)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since no extra memory is allowed, we can do an in place sorting (quick sort) O(nlogn) then in O(n) we can solve the problem. So over all time complexity is O(nlogn)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since no extra memory is allowed, we can do an in place sorting (quick sort) O(nlogn) then in O(n) we can solve the problem. So over all time complexity is O(nlogn). If we are allowed fixed memory use 32 elements int array. Use counting sort to count them out. Time complexity is O(n) then in fixed time we can complete the answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since no extra memory is allowed, we can do an in place sorting (quick sort) O(nlogn) then in O(n) we can solve the problem. So over all time complexity is O(nlogn). If we are allowed fixed memory use 26 elements int array. Use counting sort to count them out. Time complexity is O(n) then in fixed time we can complete the answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Apologize for the word \"print\". Actually, we need to \"convert\" the given string in to the output string without using extra space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Stringnumber {  public static void main(String[] args){   char [] str;   str = (new String(\"aaaabbbbcc\")).toCharArray();   int cur =0, nex =1;   int i=0;   for(;nex   str[i]=str[cur];    i++;    int noOfRep=1;    while(nex    noOfRep++;     nex++;    }    str[i]=new Integer(noOfRep).toString().charAt(0);    i++;    cur = nex;    nex++;   }   while(i   str[i] = ' ';    i++;   }   System.out.println(str);  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i=0; \ndo  \n  { \n  count=0; \n  ch=str[i]; \n  while(ch==str[i]) { count++; i++ } \n  printf(\"%c%d\", ch, count); \n  } while(!ch);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since no extra memory is allowed, we can do an in place sorting (quick sort) O(nlogn) then in O(n) we can solve the problem. So over all time complexity is O(nlogn). If we are allowed fixed memory use 26 elements int array. Use counting sort to count them out. Time complexity is O(n) then in fixed time we can complete the answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include main() {  char *p=\"aaaaabbbbccc\\0\",*str,*h;  h=str=p;  while(*p!='\\0')  {   if(*p==*str||(*p<58&&*p>47))   {    if(*(str+1)<58&&*(str+1)>47)     *(str+1)=*(str+1)+1;    else     *(str+1)=49;   }   else   {    str=str+2;    *(str)=*p;    *(str+1)=49;   }   p++;  }  *(str+2)='\\0';  printf(\"%s\",h); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Map map =  new TreeMap();   String input = \"aaaabbbbcccccccccxxxxxxxxxxxxxxaaaaaaaaaaaaaaacc\";      for (int i = 0; i < input.length(); i++) {    char in = input.charAt(i);    if(in == ' ' )continue;    if(map.get(in) != null){     int count = map.get(in);      map.put(in, ++count);     }else {     map.put(input.charAt(i), 1);    }   }      Iterator it = map.keySet().iterator();      input = \"\";   while (it.hasNext()) {    Character ch = (Character)it.next();      int i = map.get(ch);    input +=  ch.toString() + i;   }         System.out.print(input);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"char* prev = 0;   \nint currentcount = 0; \nchar* writehere = source; \nfor( char* i = source; *i; i++ ) \n{ \n  \n if( prev == NULL || *prev != *i ) \n { \n  if( prev != NULL ) \n  { \n   *writehere++ = *prev \n   if( currentcount > 1 ){ \n    char* temp = itoa( currentcount, writehere, 10 ); \n    writehere += strlen(temp); \n   } \n  } \n  prev = i; \n  currentcount = 1; \n   \n } \n else \n  currentcount++; \n}  \n*writehere = 0;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class AlphabetCount {   public static void main(String args[]) {   Scanner in = new Scanner(System.in);   System.out.println(\"Enter the string\");   String s1 = in.next();   format(s1);  }   public static void format(String s1) {   char prev = s1.charAt(0);   StringBuffer str = new StringBuffer();   int count = 0;   for (int i = 0; i < s1.length(); i++) {    char c = s1.charAt(i);    if (c == prev) {     count++;    } else {     str.append(prev);     str.append(count);     count = 1;    }    prev = c;   }   str.append(prev);   str.append(count);      System.out.println(str);  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class AlphabetCount { \n \n public static void main(String args[]) { \n  Scanner in = new Scanner(System.in); \n  System.out.println(\"Enter the string\"); \n  String s1 = in.next(); \n  format(s1); \n } \n \n public static void format(String s1) { \n  char prev = s1.charAt(0); \n  StringBuffer str = new StringBuffer(); \n  int count = 0; \n  for (int i = 0; i < s1.length(); i++) { \n   char c = s1.charAt(i); \n   if (c == prev) { \n    count++; \n   } else { \n    str.append(prev); \n    str.append(count); \n    count = 1; \n   } \n   prev = c; \n  } \n  str.append(prev); \n  str.append(count); \n   \n  System.out.println(str); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class AlphabetCount { \n \n public static void main(String args[]) { \n  Scanner in = new Scanner(System.in); \n  System.out.println(\"Enter the string\"); \n  String s1 = in.next(); \n  format(s1); \n } \n \n public static void format(String s1) { \n  char prev = s1.charAt(0); \n  StringBuffer str = new StringBuffer(); \n  int count = 0; \n  for (int i = 0; i < s1.length(); i++) { \n   char c = s1.charAt(i); \n   if (c == prev) { \n    count++; \n   } else { \n    str.append(prev); \n    str.append(count); \n    count = 1; \n   } \n   prev = c; \n  } \n  str.append(prev); \n  str.append(count); \n   \n  System.out.println(str); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"String test=\"eaavevvqwqaa\";   int count=0,start=0,end=0;   int length=test.length();   for(int i=0;i   if(test.charAt(i)!=test.charAt(i+1)){     end=i;     test=test+\"\"+test.charAt(i)+( end-start+1);      count=count+(end-start+1);     start=end+1;    }   }   System.out.println(test.length());   if(count   test=test+test.charAt(count)+(length-count);       }   test=test.substring(length,test.length());   System.out.println(test);   System.out.println(test.length());"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package com.mishra;  import java.util.Scanner;  public class PrintArraywithRepetation {   /**   * @param args   */  public static void main(String[] args) {   // TODO Auto-generated method stub               Scanner s = new Scanner(System.in);                  String input = s.next();                        int count=1;         for(int i=0 ;i             if(i         if(input.charAt(i)!=input.charAt(i+1)){           System.out.print(input.charAt(i));           System.out.print(count);              count=1;          }          else            count++;                    }          else if(i==input.length())          {           if(input.charAt(i)!=input.charAt(i-1)){               System.out.print(input.charAt(i));               System.out.print(count);                  count=1;           }                  else                    count++;                     }          else {                      System.out.print(input.charAt(i));               System.out.print(count);               count++;          }                   }    }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package com.mishra;  import java.util.Scanner;  public class PrintArraywithRepetation {   /**   * @param args   */  public static void main(String[] args) {   // TODO Auto-generated method stub               Scanner s = new Scanner(System.in);                  String input = s.next();                        int count=1;         for(int i=0 ;i             if(i         if(input.charAt(i)!=input.charAt(i+1)){           System.out.print(input.charAt(i));           System.out.print(count);              count=1;          }          else            count++;                    }          else if(i==input.length())          {           if(input.charAt(i)!=input.charAt(i-1)){               System.out.print(input.charAt(i));               System.out.print(count);                  count=1;           }                  else                    count++;                     }          else {                      System.out.print(input.charAt(i));               System.out.print(count);               count++;          }                   }    }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static String charCount(String str) { \n  int count = 1; \n  StringBuffer strBuf = new StringBuffer(); \n  for(int i = 1; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I don't really understand what are restricted to use by saying no extra space. Because in Java, a String is immutable, so we have to create a character array from the given String, and create a String back from the modified character array. If those are the valid usage of extra memory, then here's my implementation in Java.   I've explained the code with appropriate comment, in case anyone needs an explanation:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"void printCompactedSequence(String s){ \n  int sum=1; \n  System.out.print(s.charAt(0)); \n   \n  for(int i=1;i"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=75825","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"52","title":"Given an integer array {1, -20, 29, 9, 1, 100, ..., 29), please return the index of the first non-repetitive element in the array.  Manager mentioned that HashTable was allowed.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if space is not a constraint then we can solve it in O(n).  a[N] input Array (assumption array has only positive numbers) and say X is the Max value that we have in the input Array flagArr[N] = {initialized to ZERO} bucketArr[X+1] = { initialized to MAX_VAl } // MAX_VAL some constant which is not in the array  for(i=0;i if(bucketArr[a[i]] == MAX_VAL) {      bucketArr[a[i]] = i;  }  else {       flagArr[bucketArr[a[i]]] = 1; // 1 means repetition  } }    for(i=0;i   if(flagArr[i] == 0 ) {       return i;    } }  I have assumed that the array has only positive numbers, if negative numbers are allowed then we can add min value to each number and follow the same procedure.  any bug found ? let me know"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"HashTable was allowed, but additional space was not allowed."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Quite a strange restriction. Hashtable allowed but not additional space. What does that mean?  A hash table solution (C# like pseudo-code):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"size_t vs int bug in above code."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this is an XOR question. Subha's method is not O(N) at all. The max_value could be N x N or even larger, causes bucketArr to over O(N)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is definitely not a XOR question."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A direct method of about N*N/4 algorithm:  (  if (N== 1) return 0; int No1 = a[0];  for(int i=0;i if ( No1 XOR a[j] != 0 )//not repeated   continue; else   break;  }  if (No1 XOR a[N] != 0)    return 0; // a[0] is the first non-repeated no.  for (int i=1; i {    int testNo = a[i];        if (i == N)    {       if (testNo == No1)          return -1; // no non-repeat index       else         return N;      // last index    )       if (testNo == No1) continue;// skip it    int j= i+1;    do    {       if (a[j] == No1 ) continue;       if (testNo XOR a[j] != 0 )       {           if (j== N)  // last guy             return i;           j++;       }         else  // a[j] repeats testNo       {          a[j] = No1; // don't deal with a[j] again          break;                    }    } while (j<= N);  )"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"kulang,  O(N^2) is obvious to do, and you don't need to XOR just to compare if things are equal.  You seem to be confusing this with a similar sounding problem... I suggest you read the question again."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hei, We are finding NON Repeat number's index, not the repeat index!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ROTFLOL! What are you talking about kulang?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You may be right. XOR is not needed.  HashTable solution:  Put the numbers in the array in 100 buckets according to their last two digits. Exam the number of members in each bucket, if some bucket has only one member, it is the one and record its index. If the buckets has more than one, apply the above direct method to find the minimum index of non-repeated number. Finally, compare all indice and find the smallest index.  But in worst case, it is not better than the direct method."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Yes, in worst case hashtable is not better than direct method, but using a hashtable is a much better option that brute force quadratic.  If you are worried about worst case, we can do O(nlogn) with a balanced tree.  But there is a comment saying no extra space, so neither hashtable nor tree will work with that restriction."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Forget the no extra spaces requirement, it does not make sense for Hash Table. The other way is doing a O{N*lgN) search{with indice) and then search the non-repetitve indice and find the minimum. It does require up to N extra spaces. I am not sure your balance tree solution. The direct method only needs space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A C# like balanced Tree Solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hash Table solution - O(N) The key in the hashmap is value at array[i] and the value in hashmap is a linked list. A node is added if the size is 0 or 1. Node holds the index i. Since we only care about duplicate once the size of the associated linked list with a key > 1 we can ignore adding to the link list when collision occurs. Thus the max size of linked list if 2. After complete iteration of the array. Scan the Hashmap, collect all values where associated linked list is of size one. Return the minimum from that. Worst case - when no element is duplicate is also O(N) i.e to find the minimum."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Your solution looks right. One suggestion: the first one with size one has the minimum index. But if you use array[i] as hash key, you actually do 1, 2, ..., n-1 comparisons. It is more likely O(N*N) because the size of hash table."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"To Anonymous who claims Hash Table is O(N).  Why can't you have a collision between two _different_ keys? That is what the whole collision issue is about. So worst case, it could still be O(N^2)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi Kulang  I am not iterating over the MAX_VAL. bucketArr will take space that is for sure. implementing  separate chaining method in hash table should be a nice approach. But my Algo looks O(n) for me.   Subha"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi, Subha,  The point is not O(N), it is the maxvalue and the bucket array. Say { 1, 10, 1, 100, 10, 1000, 100, 10000, 1000, 100000 ) Find Maximum X: N; Initial bucket: X (100000 in this case!) Scan number in array[i]=a, and set flag[bucket[a]]: 2N \"MAX_VAL some constant which is not in the arr\", how you find it!!! I think you see the problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For some reason, I am not able to reply to a specific comment.  To Anonymous who responded to my post.   Of course the actual integer value is the key. But what does that hash to? The collisions occur _after_ you hash the keys. The linked list is for each _hash value_ not each key.  Think about hashing and collision independent of this problem. In usual implementations, you do the linked list chaining for keys which map to the same hash. So you could have different keys with data in the _same linked list_.  So for this problem, in worst case hashing is not O(N)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming that the array elements are reasonably small enough, and the interviewer allows for use of hashtables, then hash table offers the best solution. go thru the array each time pickin an element and inserting it into the hash table as the key with a value of 1. The first time an attempt to insert an element finds a key == to the element, then that is the 1st repeating element. simply return the index of that in the array. this should be an O(n) efficiency."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Yes Chrisogonas, if the size of array elements is bounded (for instance, imagine this is an array of characters like a string) then we can use the key as the hash value itself and worst case then becomes O(N) and space O(1)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Talking limited array and BIG O is like talking a shell and the sea. O(N) means there is a constant k, such that the algorithm is good(k*N) for ANY N!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"oi AO"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You are changing the original problem, Mr. T.  Why not just conside binary numbers:  {0, 1, 0, 0, 0, ..., 1} , then you don't even need any space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int nri(int *a,int n) {     int *b,int flag,j,i=0;     while(i!=n)     {        j=i;         j++;        b[j]=a[i];        if(a[i]!='#')         {             flag=0;             while(j!=n)             {                 if(a[i]==b[j])                  {                       b[j]='#';                       flag=1;                   }                   j++;              }               if(flag==0)                return i;            }          i++;          } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The string problem is an exception. The idea of Hash Table itself is use limited number of buckets to deal with unlimited possibilities and reduce the amount of computations. In this case, using last two digits requires only 100 buckets. If the numbers are fairly distributed, another word, if it does not contain just a few repeat numbers, or all numbers has the same last two digits, then we have a O(N) solution.  You never want to pick the value itself as key and create huge buckets."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Good English! Who(m) did you direct this comment at(to)? Your code(algorithm) is O(n^2). ..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Not sure what all the excitement is about. But, a linear algorithm is in order:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Start storing the elements in a hashmap from the end of the array. If the element already exists in HashMap then remove it from hashmap. Now again traverse the array from beginning. Output the first element you come across which is also present in the hashmap  this is also O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about creating a binary search tree which contains the index and value. If a element repeats remove it from tree. Finally we will have a tree with all the non repeating numbers along with their index. O(nlogn) for constructing the tree and O(n) for find the index overall O(nlogn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this would work.... #include #include #include  using namespace std; void insertmap(map &moh,int n) { pair:: iterator ,bool> ret; ret=moh.insert(pair (n,1));//this will check if n is already in map or not. //if it returns true no such key =n is present so inserted if(!ret.second ) { moh[n]++; }  } int main() { int n; cout<<\"no of elements in list\"; cin>>n;  vector< int > num(n); map mohan; for(int i=0;i{ cin>>num[i]; insertmap(mohan,num[i]); } map::iterator trav;  // starting from first insert //so will give first element tat occurs only once for(int i =0;iif (mohan[num[i]] == 1) { cout<<\"first element\" << num[i]; break; }  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why can't we approach using the XOR way. The pseudo-python code can be: seen = set([]) temp = 0 for i in range(len(array)):     if array[i] not found in seen:          temp = array[i] XOR array[i+1]         seen.add(array[i])     if temp not 0:         print array[i]  here seen ensures that we're not goind to do XOR of same numbers more than once, the moment we've non-zero temp means we've one number that is different and that is the answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"indentation added:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/** \n  * This function will return the first non-repeated number. \n  *  \n  * Best case: O(n) and worst case: O(n2) \n  **/ \nint check(int[] arr){ \n int length =arr.length; \n for(int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int FindFirstDuplicate1(int[] arr)         {             Dictionary dic = new Dictionary(arr.Length);             for (int i = 0; i < arr.Length; i++)             {                if(dic.ContainsKey(arr[i]))                {                    return dic[arr[i]];                }                dic.Add(arr[i], i);             }             return -1;         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hi.. wat about this one map  table;   int a[10] = {2,3,1,4,5,1,6,2,3,4};    int n=10,i;    for(i=0;i           table[a[i]] = i;     for( i=0;i           if(i==table[a[i]])  return i;            else table[a[i]] = i;  And I think complexity is O(n) .. Correct ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.HashMap; \nimport java.util.Map; \n \n \npublic class FirstNonRept { \n \n public static void main(String[] args) { \n   \n  int arr[]=new int[10]; \n  arr[0]=4; \n  arr[1]=2; \n  arr[2]=3; \n  arr[3]=4; \n  arr[4]=2; \n  arr[5]=10; \n  arr[6]=11; \n  arr[7]=3; \n  arr[8]=4; \n  arr[9]=0; \n  HashMap hm =new HashMap(); \n   \n \n   \n  for(int i=0;i entry : hm.entrySet()){ \n   System.out.println(\" key \"+entry.getKey()+\"   \"+entry.getValue()); \n   if(min>entry.getValue()){ \n    min=entry.getValue(); \n   } \n  } \n \n  System.out.println(\"Minimum index of the value is :\"+min+\" value of variable :\"+arr[min]); \n  \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) { \n  Set set = new TreeSet(); \n  List l = new ArrayList(); \n  l.add(1); \n  l.add(-20); \n  l.add(1); \n  l.add(29); \n  l.add(9); \n  l.add(100); \n  l.add(29); \n   \n  set.addAll(l); \n  int k = 0; \n  for(Integer i : set ){ \n   if(l.indexOf(i) == l.lastIndexOf(i)) { \n    k = i; \n    break; \n   } \n  } \n  System.out.println(\"index of the first non-repetitive element in the array is \"+l.indexOf(k)+\" ; the element is \"+k); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int arr[N]; \n map unique_char; \n for(int i=0;i>arr[i]; \n  unique_char[arr[i]]++; \n } \n map ::iterator it; \n for(it=unique_char.begin();it!=unique_char.end();it++) \n  cout<<(*it).first<<\" : \"<<(*it).second<"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14466994","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"53","title":"N*N matrix. contains only 0's and 1's. every row is sorted in descending order. find row containing maximum no of 1's. Efficient soln reqd.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"12","title":"It can be done in O(n) time. Start from top right element check if its 0 or 1, if its 0 move to j-1 element in that row and store the index of row in a variable,if its 1 move to next row by incrementing i but keeping j same. do the same step here as well. At the end the variable will consist of row with max 0's."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"lets say we have a matrix of size (rows * columns) scan towards the left on the first row from top right till you hit the last 1. move downwards on that column till you hit another row with 1 repeat the same"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"for(int col = n-1 ; col >= 0 ; col --){  for(int row = 0 ; row < n ; row ++ ){   ( mat[row][col] == 1 )    return row ;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"O(log n) time. Start from the middle column (n/2) and check if any row has 1's. If yes, store the column value and proceed in columns with (n/2) to (n) and check only for rows which had 1's previously."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"At max 2n operation."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This comment has been deleted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Mat[n][n] \n \nint row = 0; \nint i; \nfor (i = n- 1; (i >= 0) && (!Mat[0][i]); --i); \n \nint column = i; \n \nif (i == n - 1) \n return row; \n \nint tryingColumn = i + 1; \nfor (j = 1; j < n; ++j) \n{ \n if (Mat[j][tryingColumn]) \n { \n  ++tryingColumn; \n  while (tryingColumn < n) \n  { \n   if (Mat[j][tryingColumn]) \n    ++tryingColumn;  \n  } \n  row = j; \n   \n  if (tryingColumn == n) \n   return row;  \n } \n \n} \nreturn row;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Mat[n][n] \n \nint row = 0; \nint i; \nfor (i = n- 1; (i >= 0) && (!Mat[0][i]); --i); \n \nint column = i; \n \nif (i == n - 1) \n return row; \n \nint tryingColumn = i + 1; \nfor (j = 1; j < n; ++j) \n{ \n if (Mat[j][tryingColumn]) \n { \n  ++tryingColumn; \n  while (tryingColumn < n) \n  { \n   if (Mat[j][tryingColumn]) \n    ++tryingColumn;  \n  } \n  row = j; \n   \n  if (tryingColumn == n) \n   return row;  \n } \n \n} \nreturn row;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can be done in logn..Keep binary searching on each row till you are encountering one..Remove those rows which got zero..Last row left is the solution.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"nice questio though taking the help of binary search it will still be O(nlogn) worst case  1. using binary search find the 1(index i) which has 0 at index i + 1. Once you got that move to 2. next row and check if newRow(index) == 0 then move to next row // this has less 1st than earlier row 3. else apply binarySearch on newRow from index to nth index as shown in step 1 // this has more or equal 1s than earlier row  eventually you will find the row which has max number of 1s  Though worst case it will be O(NlogN) worst case is   row1 has one 1 row2 has two 1 row3 has three 1.  eventually it will go to complexity o(n logn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//O(n) time, O(1) space solution. Just move right (while we have 1s) and down. Keep a track of longest row \n  \n public int getLongestRowIdx(int[][] m) { \n  int longestRowIdx = 0; \n  int longestClmnIdx = 0; \n  int i = 0; \n  int j = 0; \n  \n  for (int i = 0; i < m.length; i++) { \n   while (j < m[0].length && m[i][j] == 1) \n    j++; \n    \n   if (j - 1 > longestClmnIdx) { \n    longestRowIdx = i; \n    longestClmnIdx = j - 1; \n   } \n  } \n  \n  return longestRowIdx; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int FindMaxRow(int a[][],n) { int j = n-1; int i = 0; int Max = i; while( i{ if(a[0][j--] != 0) { i++; j++; } if(a[i][j] != 1) { i++; } else { Max = i; j++; } } Return Max; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int FindMaxRow(int a[][],n) { int j = n-1; int i = 0; int Max = i; while( i{ if(a[0][j] != 0) { j--; } else { i++; j++; } if(i>0) { if(a[i][j] != 1) { i++; } else { Max = i; j++; } } } Return Max; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Very simple.  Just search the first column.If any row has one in it then it would be the biggest as the whole matrix is sorted as mentioned."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class MatrixMax { \n public static void main(String[] args) { \n  int mat[][]=new int[5][5]; \n   \n  mat[0][0]=0; \n  mat[0][1]=1; \n  mat[0][2]=1; \n  mat[0][3]=1; \n  mat[0][4]=1; \n  mat[1][0]=0; \n  mat[1][1]=0; \n  mat[1][2]=1; \n  mat[1][3]=1; \n  mat[1][4]=1; \n  mat[2][0]=0; \n  mat[2][1]=0; \n  mat[2][2]=0; \n  mat[2][3]=1; \n  mat[2][4]=1; \n  mat[3][0]=1; \n  mat[3][1]=1; \n  mat[3][2]=1; \n  mat[3][3]=1; \n  mat[3][4]=1; \n  mat[4][0]=0; \n  mat[4][1]=0; \n  mat[4][2]=0; \n  mat[4][3]=1; \n  mat[4][4]=1; \n   \n  //this is for worst case scenario.. all are zero \n  /*for(int i=0;i=0 && j"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int max_ones(int mat[N][N]) \n{ \n    int r = 0, c = 0; \n    while(r < N) { \n      if(c < N && mat[r][c] == '1') \n          ++c; \n      else \n          ++r; \n    } \n    return c; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"using binary search for N rows, for example, search starts with N/2 position for each row. The search terminates for the row if current position at this row is 0. For the remaining rows, the search repeat until there is only one row left. Worst case O(NlgN)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"it can be done in o(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"you r doin it in o(n2) gtfo from there"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"correct nice... ACRush"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Could you give the psuedo code for this ?"}]}}]