{
    "question": {
        "mm_name": "interview_question",
        "location": "http://www.careercup.com/question?id=5674452213825536",
        "download_status": "DOWNLOAD_DONE",
        "votes": "-5",
        "answersCount": "29",
        "title": "Find largest element in an array",
        "interview_question_comments": [
            {
                "mm_name": "interview_question_comments",
                "download_status": "UNPROCESSED",
                "votes": "3",
                "title": "#include  \n \nmain() \n{ \n        int a[5] = {10,2,100,50,101},index=0,big; \n        big = a[0]; \n \n        for(index = 1;index < 5;index++) \n        { \n                if(a[index] > big) \n                { \n                        big = a[index]; \n                } \n        } \n \n        printf(\"biggest element :%d\\n\",big); \n} \n \noutput : biggest element :101"
            },
            {
                "mm_name": "interview_question_comments",
                "download_status": "UNPROCESSED",
                "votes": "2",
                "title": "Quicksort will be best. After the first iteration the pivot is in the right position and all values left are smaller than pivot and all values to the right are larger than the pivot. Now do the same iteration again on the right subarray till you set the last element. Avg: O(logN). Worst case (already sorted array): O(n)."
            },
            {
                "mm_name": "interview_question_comments",
                "download_status": "UNPROCESSED",
                "votes": "1",
                "title": "So, there's plenty of explanation on how/why to do a QuickSort, but in my opinion, something MAJOR is left out here, which is to *Ask your interviewer questions before answering!* QuickSort can quickly become the wrong answer with some detail.  1. Is the list sorted? Probably not, but worst case you get \"no\" and best case, you're applauded for being thorough.  2. Can I sort the list? And if not, do I have the memory to copy then sort the list? A no here means that again QuickSort is out.  3. How big is the list? If you've got an int array list of a constant size 5, QuickSort is sort of using the broad sword when the butter knife will do.  All a bit pedantic here perhaps, but keeping this mindset is vital."
            },
            {
                "mm_name": "interview_question_comments",
                "download_status": "UNPROCESSED",
                "votes": "0",
                "title": "Do a quicksort.  After the first iteration the pivot is in the right position and all values left are smaller than pivot and all values to the right are larger than the pivot.  Sort the array left of the pivot and you have the largest element, or just do comparisons. Best case, if pivot is the largest number. Worst case, if pivot is the smallest number. Average case, O(log N)"
            },
            {
                "mm_name": "interview_question_comments",
                "download_status": "UNPROCESSED",
                "votes": "0",
                "title": "a is an array max=a[1] for i 2 to n  if(a[i]>max)   max=a[i]"
            },
            {
                "mm_name": "interview_question_comments",
                "download_status": "UNPROCESSED",
                "votes": "0",
                "title": "void main() {  int max,i=0,a[10];  max=a[0];  while(i<10)  {   if(max=a[i])    max=a[i];  }  printf(\"max=%d\",max); }"
            },
            {
                "mm_name": "interview_question_comments",
                "download_status": "UNPROCESSED",
                "votes": "0",
                "title": "1.If the array is sorted the largest element can be found at the end of array 2.If the array is not sorted traverse through the array find the max 3.If there are frequent insert options that can be taking place on the array along with the finding largest element,          -   sort the array first          -   do the insert options in the sorted order          -   find largest element at the end of array"
            },
            {
                "mm_name": "interview_question_comments",
                "download_status": "UNPROCESSED",
                "votes": "0",
                "title": "If the input sequence has been sorted,use binary search.If not,i think there should just has a algorithm with O(N)"
            },
            {
                "mm_name": "interview_question_comments",
                "download_status": "UNPROCESSED",
                "votes": "0",
                "title": "If the input sequence has been sorted,use binary search.If not,i think there should just has a algorithm with O(N)"
            },
            {
                "mm_name": "interview_question_comments",
                "download_status": "UNPROCESSED",
                "votes": "0",
                "title": "Have you tried using a hashmap?"
            },
            {
                "mm_name": "interview_question_comments",
                "download_status": "UNPROCESSED",
                "votes": "0",
                "title": "I see people have commented using Bubble Sort. For those people who say Bubble Sort is stupid, How about you do only one iteration of Bubble Sort which will be O(n)[Now please note I am not saying n iterations of Bubble Sort] and the last element will always be the max. Think about it."
            },
            {
                "mm_name": "interview_question_comments",
                "download_status": "UNPROCESSED",
                "votes": "0",
                "title": "//Given an array of arbitrary length int i = 0; int max = array[0]; while(array[i] != '\\0') {  if(array[i] > max)  {   max = array[i];  }  i++; }"
            },
            {
                "mm_name": "interview_question_comments",
                "download_status": "UNPROCESSED",
                "votes": "-1",
                "title": "1. Bubble sort in increasing order 2. Linear scan to end of array, and grab last element (which should be max)  O(n^2) + O(n) . Easy."
            },
            {
                "mm_name": "interview_question_comments",
                "download_status": "UNPROCESSED",
                "votes": "-1",
                "title": "Hi, Please help me to understand why we need of bubble sort. This can be achieved simply traversing array once which is O(n-1). {{class Maxinarray {   public static void main(String[] args) {     int[] a={1,5,6,8,90,4,3,2,2};  int max=a[0];  for(int i=1;i {  if(a[i]>max) max=a[i];  }  System.out.println(\"Max is=\"+max);  } } }}}"
            }
        ]
    }
}