[{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4885162441572352","download_status":"DOWNLOAD_DONE","votes":"4","answersCount":"34","title":"Given two sorted arrays, we can get a set of sums(add one element from the first array and one from the second). Find the Nth element in the set of sums. Suppose that array A is {1,3,4,8,10}, array B is {20, 22, 30, 40}. then the sum set will be{21(1+20),23(1+22 or 3+20), 25(3+22), 24(4+22)...} the 3rd element in the sum set is 25.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Here is straight forward and simple solution ....no magic behind this... just putting all unique sums in a min heap.. and returning 3rd element from the heap."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Could you please give an example ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The task is not clear, but i guess, that we are speaking about finding K-th sum from a[i]+b[j] for ANY {i, j}. Becouse if i==j, it is simply binary search, and there is no reason to complicate the task description. ___________________________  This task reduced to another popular task, which has been discussed here many times: Find K-th element in Sorted Matrix.  Let's imagine that we have N*M Matrix: S[i][j] = a[i]+b[j];"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"findSumAtNthElement(A1,A2,N) \n{ \n   int diff= A1-A2; \n   if(diff==0){ \n  SumAtN = A1[n-1]+ A2[n-1];   \n   } \n    \n   if(diff<0) \n   { \n        SumAtN = A2[n-1]  \n   }else{ \n  SumAtN = A1[n-1]- \n   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can assume matrix with these two array... like A represents rows and B represents    columns. \nWe need only 3rd element, it will lie in 3X3 matrix if more than 7 sums are not same(duplicate).  \n   So first we will check in first 3X3 matrix than move to 6X6 ...9X9 .... so on. \n \nint m = length of first array; \nint n = length of second array; \nMaxHeap maxHeap = new MaxHeap(3); // Max heap without duplicate, add() method will check if there is duplicate. \nint maxLength = max(m,n); \nfor(k = 0; K < maxLength; K = K+3){ \n for(int i = K; (i < K+3) && (i < m); i++){   \n  for(int j = K; (j < K+3) && (j < n); j++){ \n   maxHeap.add(A[i]*B[j]); \n   if(maxHeap.size() == 3){ \n    return maxHeap.root(); \n   }  \n  } \n \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since the arrays are sorted, a modified *merge* subroutine (of mergesort) can get the job done in O(n) time and O(1) space.   The arrays' *walk* of merge subroutine can keep track of the previously computed sum and current sum to disregard duplicates and stop when the Nth sum is reached.  The arrays' walk can be done as follows: Given indices i and j, we have previoussum = a[i] + a[j]  and currentsum= Min((a[i] + a[j+1]) , (a[i+1] + a[j])). Update the pointers i & j accordingly for the next step in the arrays' walk."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since we only need to check the matrix on top-left, we can have two loop (i, j) , and i+j must less than the Nth."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am not sure if this is the approach, or I could explain my logic properly, any clarifications...welcome This works in nlog(smaller array.length) time, where n is the position of the number we are trying to find If someone could find any bug then welcome... :-)  a[] = { 1, 3, 4, 8 , 10} b[] = {20, 22, 30 ,40}  1. create an array index[b.length] )sizeof the smaller array, value 0 for each element 2. index array will contain current index of array a, for each element of array b 3. Create a min heap of size b.length, to get the current min 4. insert sum of a[0] + b[i] into the min heap (20 + 1, 22 + 1, 30 + 1, 40 + 1) 5. Now until we get the nth element, do the following 6. extract the current min (in this case 20+1) 7. increament the corresponding index pointer in this case index of 20 will be increamented to 1 from 0 8. insert this new element in to the heap (in this case 20 + 3 will be inserted into the heap)  //so next time the comparision will be between 20 + 3, 22 + 1, 30 + 1, 40 + 1  9. one thing we need to take care of,  like for the below case   a[] = {1,2,3,4,5}  b[] = {20, 60, 80, 100}    if index of an element exceeds the limit like in the above case, 20+1, 20+2, 20+3, 20+4, 20+5 and then it exceeds so insert INT_MAX into the heap,   so that the pointer of 20 will never get increamented again.  We can take care of the duplicate sum like 20+3, 22+1 case through this logic also, by maintaining a prev min and current extracted min."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Let array a anb array b ,start from start of both i,j i=0 j=0, now a[i]+b[j] is lowest sum possible ,counter =1,now compare a[i+1] with b[j+1] which one is smaller increase the respective value of i or j and find next lower sum and do counter++ do this upto counter!=N"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#include int main(){  int n,N,i;  scanf(\"%d\",&n);  scanf(\"%d\",&N);  int a[n],b[n],c[n];  for(i=0;i  scanf(\"%d\",&a[i]);}  for(i=0;i  scanf(\"%d\",&b[i]);}  for(i=0;i  c[i]=a[i]+b[i];}  printf(\"%d\\n\",c[N]);    return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I am adding both array (start from least significant digits). We need to find sum till (length -n)th element."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"The question is not clear. So, I am making following assumptions.  1. Set of sums mean {a[0]+b[0], a[0]+b[1], ...a[1]+b[0], a[1]+b[1].....} 2. Length of array a is lenA and length of array b is arrayB  So, the Nth element would a[N/lenB] + b[N%lenB]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"findSumAtNthElement(A1,A2,N) {    int diff= A1-A2;    if(diff==0){   SumAtN = A1[n-1]+ A2[n-1];      }        if(diff<0)    {         SumAtN = A2[n-1]     }else{   SumAtN = A1[n-1]-    }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"here is the simple impletation in c# with O(n):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"I gess \n \narray_one=1, 2,    3,    4,    5,    7 \narray_two=9, 11, 12,  15  16, 17 \n  \n      both arrays are sorted so sum is also a sorted array \n                    10, 13,15, 19,  21, 24 \n   so nth element is also on index n"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5718181884723200","download_status":"DOWNLOAD_DONE","votes":"-2","answersCount":"13","title":"difference between thread and process.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"I found a very nice explanation somewhere, so am pasting it here :  A process is an executing instance of an application, for example when we double click on MSWord, a process is launched. A thread on the other hand is only a path of execution within a process.  A process can contain multiple threads. When you start Word, the operating system creates a process and begins executing the primary thread of that process.  A thread can do anything a process can do. But since a process can consist of multiple threads, a thread could be considered a ??lightweight?? process. Thus, the essential difference between a thread and a process is the work that each one is used to accomplish. Threads are used for small tasks, whereas processes are used for more ??heavyweight?? tasks ??C basically the execution of applications.  Another difference between a thread and a process is that threads within the same process share the same address space, whereas different processes do not. This allows threads to read from and write to the same data structures and variables, and also facilitates communication between threads."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Process Each process provides the resources needed to execute a program. A process has a virtual address space, executable code, open handles to system objects, a security context, a unique process identifier, environment variables, a priority class, minimum and maximum working set sizes, and at least one thread of execution. Each process is started with a single thread, often called the primary thread, but can create additional threads from any of its threads.  Thread A thread is the entity within a process that can be scheduled for execution. All threads of a process share its virtual address space and system resources. In addition, each thread maintains exception handlers, a scheduling priority, thread local storage, a unique thread identifier, and a set of structures the system will use to save the thread context until it is scheduled. The thread context includes the thread's set of machine registers, the kernel stack, a thread environment block, and a user stack in the address space of the thread's process. Threads can also have their own security context, which can be used for impersonating clients."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"another difference is that processes are \"fork\"ed and threads are \"spawn\"ed.  A fork (creating a process) is usually more time-consuming. This is a system call.  A spawn (creating a new thread) can be faster than forking a new process.  The first time you run a program, you create a new process (never a new thread). A process can have multiple threads, but not the other way around.  (edited and corrected)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Threads are easier to create than processes since they  don't require a separate address space.        2. Multithreading requires careful programming since threads  share data strucures that should only be modified by one thread at a time.  Unlike threads, processes don't share the same  address space.        3.  Threads are considered lightweight because they use far  less resources than processes.        4.  Processes are independent of each other.  Threads, since they  share the same address space are interdependent, so caution  must be taken so that different threads don't step on each other.   This is really another way of stating #2 above.        5.  A process can consist of multiple threads."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Context switching among process takes more time.. Context switching among threads takes less time..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Suppose I have a program that does the following steps 1. Read a file 2. Read data from a database 3. Compute some values from the info in the file received and the data 4. display something on the screen  When this is realized into code, its a program. When the program is executed, an image of it is created (with some resources such as file handle, etc.) and loaded into main memory and scheduled to run on the processor. Now its a process. Single program be used to instantiate multiple processes. If we look closely, we can perform steps 1 and 2 independently, then 3rd and then 4th. Do we really need to wait for 1 to finish before beginning 2? To make things work parallel, we can run 1 and 2 parallel in smaller partitions of the process. This partition of the process, which has some resources inherited and its own context within the process is a thread. Threads are lighter weight and help improve throughput since we don't need to wait for executing independent tasks even within a process."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":">thread share the address space of the process that created it.process have their own address space >threads can directly communicate with other threadsof its process .process must use interprocess communication mechanisms (pipes ,sockets)to communicate with each other"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"The CPU can process a thread, but cannot thread a process."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5175246478901248","download_status":"DOWNLOAD_DONE","votes":"-4","answersCount":"19","title":"design an alarm clock for a deaf person.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Vibrator, light & pillow vibrator. To cover minimal to severely deaf. Vibrator + Light =  Normal deaf. Pillow vibrator + Light   =  severely deaf."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"spring loaded boxing glove aimed at backside while sleeping"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"vibrations , light"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using light, fully."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Yeah right. Stop posting questions from the web.  This is an idiotic PM question. Not a developer question."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Create a watch alarm clock that vibrate :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include   int main(void) {      time_t rawtime;     struct tm*  time_;      time(&rawtime);     time_ = localtime(&rawtime);      printf(\"%i:%i:%i %i %i %i\\n\", time_->tm_hour, time_->tm_min,              time_->tm_sec, time_->tm_mday, time_->tm_mon+1,             time_->tm_year+1900);      return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"person is deaf not blind"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"clock with sensor coupled to another"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sensor which is located under the bed .when the desired time iss reached the clock wud send a em signal to the bed sensor.the latter on activating will vibrate the whole bed setting him awake-for wall and table clock the wrist watch cud vibrate on its own when the desired time is reached"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":",.lm ,"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5845181920182272","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"6","title":"3 fruit baskets having apple, orange and mix. all labeled wrong. with only one sample taking from one basket but not peeking find out which basket has which one.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"(1) We know all the labels are wrong,  Because of (1), the \"mixed\" basket has to be either all apples or oranges, it cannot be mixed. You pick from the basket labeled \"mix\". There are two cases: 1. You picked an apple.  We now know the basket labeled \"mixed\" is all apples. Then (again due to (1)) the basket labeled \"orange\" can either be all apples or mixed. But we already know it is not all apples. Thus, the basket labeled \"orange\" is mixed. And the remaining basket is all apples.  2. Similar to the case above. If you get an orange from the basket labeled \"mixed\", we know that the basket is all oranges. Then the one labeled \"orange\" has to be apples and the remaining one is all mixed (EDIT: corrected the last basket label. Thanks to John Zhao)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Pick the mixed box, since it is wrongly labeled we can certainly get to know one kind of fruit basket."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Simple symmetry argument. Picking apple is \"equivalent\" to picking orange. So pick mixed."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5204967652589568","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"13","title":"9 identical balls. one ball is heavy. find the heavy ball with only 2 measurements ........ dead easy.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"this is super easy. split the ball into three groups with 3 balls each. pick two groups out to measure if they are equal weight. this way, you could find out which group contains the heavy ball. Then from this particular group, you could pick two to do one more measurement, this way, you find out the heavy ball"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Stop posting questions from the web. Microsoft stopped asking these a long time ago. Get with the program."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Create three groups of 3 balls each. \nCompare two of these groups (1st comparison) \nIf equal \n   Compare the two balls in second group (2nd comparison) \n   If equal \n       Return the uncompared ball \n   Else \n       Return the ball that is heavier \nElse  \n   Compare the balls in the group which came heavy in first comparison (2nd comparison) \n   If equal \n       Return the uncompared ball \n   Else \n       Return the ball that is heavier"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"three and three first.Then if one side is heavier, take that side and put 1 ball on each. If one side is heavier, then that is the ball. If the two sides are equal, then the leftover ball is heavy.  If on the 3-3 balance, the two sides are equal, then take the leftover side and do the 1-1 shown above."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why didn't you state that it would be measured on a balance scale i.e. by comparison?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) take 4 balls on each side. Measure. If they are equal, the 9th ball you left out is the heavy one. 2) Otherwise split the heavy 4 group into two groups of two balls each and measure again. 3) Now drop the two balls from the heavy two group, the heavy one will land on the ground first.  LOL"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"take 4 balls on one side of measurement and another 4 balls on another side , then if equal means the 9 th one is heavy ...if the measurement is unequal.take the heaviest side and split into  two and find which is heavy.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Stop posting questions from the web. Microsoft stopped asking these a long time ago. Get with the program."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Stop posting questions from the web. Microsoft stopped asking these a long time ago. Get with the program."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Stop posting questions from the web. Microsoft stopped asking these a long time ago. Get with the program."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5943815844134912","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"9","title":"given a file with each  line containing information  the user want to know the no of hits of the site from the no of people visited but the request may change frequently e.g sometime it may be asked 2 find hits according to cities,sometime it may be according 2 state,might be according 2 country or around the world.design the algorithm clearly mentioning the data structure 2 b used in the algorithm","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Can we use a trie tree to store the # of people visited based on the country/state/city name (suppose their names are unique)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The first thing that comes to mind is a hash table with linked list chaining. You hash the entire dataset on whatever field you want to count hits from. Fields that are filled out the same will hash into the same bucket and the length of the linked list will equal to the number of fields hashed into the bucket.  Since adding to linked lists is pretty crappy in terms of time complexity, it probably makes more sense to use something like a dynamic array instead of a linked list, but the main concept is the same either way. I'm not sure what the best way to handle the size of table, though, since you have to be sure that two fields of the same type can't be hashed into the same slot."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Make three strucs  Country {   Name;  }  State { Country; StateName;}  City { State, CityName) 2. Make BStree  Country, State, City 3. When there is any change in city it also add in State and Country also. 4. When any element change System should adjust in BStree so when user get allways get result in order."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use k-d tree. Kd- Tree solves multi dimensional search problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use Hash maps inside Hash maps.  e.g. in C++"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Multi level Hashing  Country -> State -> City"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Put the data into a DB and you are good:) However, If you prefer a fancy data structure, I would use Trie."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5700293077499904","download_status":"DOWNLOAD_DONE","votes":"-2","answersCount":"3","title":"For a given map (ie Bing map) given longitude/latitude/ how would you design the system so that when map longitudeDelta/latitdueDelta changed you add additional pins on map for regions that was not previously cover. In another word, how would you design it to avoid getting and displaying duplicated pins","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"To me this would involve some box collision testing to determine which pins are 'in-scope' for the current view.  Once a view is established you could store the pins in a HashMap.  If the view is shifted, you simply do your collision check again (see which pins lie within the bounding box) and insert the pins into the HashMap.  Duplicates will be filtered automatically."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how about using hash map... storing each data i.e the coordinates in a table with a key... and everytime checking if the new values are equal to the ones in the table.... if not then adding the pins in the map"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6276106994843648","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"27","title":"There is a matrix which contains white cells , black cells and  only one gray cell, need to go from (0,0) to (N-1, N-1) if Arra[N][N] constraints:  a. The path should cover only white cells and should go via grey cell. b. The node once visited cannot be visited again.   White cells are represented by 0, black cells by 1 and grey cell by 2.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"public List findPath(int[][] arr, boolean[][] visited,  \n                                      Cell start, Cell target) { \n        final Queue queue = new LinkedList(); \n        queue.add(start); \n        while (!queue.isEmpty()) { \n            final Cell current = queue.poll(); \n            final int x = current.getX(); \n            final int y = current.getY(); \n            visited[x][y] = true; \n            final List path = current.getPath(); \n            path.add(current); \n            if (x == target.getX() && y == target.getY()) { \n                return path; \n            } \n            optionalQueueAdd(arr, visited, new Cell(x + 1, y, path), queue); \n            optionalQueueAdd(arr, visited, new Cell(x, y + 1, path), queue); \n            optionalQueueAdd(arr, visited, new Cell(x - 1, y, path), queue); \n            optionalQueueAdd(arr, visited, new Cell(x, y - 1, path), queue); \n        } \n        return null; \n    } \n \n    public void optionalQueueAdd(int[][] arr, boolean[][] visited, \n                                        Cell newCell, Queue queue) { \n        if (newCell.getX() < arr.length && \n                newCell.getY() < arr.length && \n                newCell.getX() >= 0 && \n                newCell.getY() >= 0 && \n                !visited[newCell.getX()][newCell.getY()] && \n                arr[newCell.getX()][newCell.getY()] != 1) { \n            queue.add(newCell); \n        } \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"8 direction , counting all paths"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"8 directions , counting all paths"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A* algorithm should solve this problem because we know the coordinates, use a priorityQueue to store unvisited nodes(expanded from current node)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I guess, and not sure yet, that the following algorithm works."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static class Step{ \n  int x, y; \n  public Step(int xVal, int yVal){ \n   x = xVal; \n   y = yVal; \n  } \n   \n  @Override \n  public int hashCode(){ \n   int prime = 31; \n   int result = 1; \n   result = result * prime + x; \n   result = result * prime + y; \n   return result; \n  } \n   \n  @Override \n  public boolean equals(Object obj){ \n   if(obj == null){ \n    return false; \n   } \n    \n   if(this == obj){ \n    return true; \n   } \n    \n   if(getClass() != obj.getClass()){ \n    return false; \n   } \n    \n   Step step = (Step)obj; \n   if(step.x != x || step.y != y){ \n    return false; \n   } \n   return true; \n  } \n   \n } \n  \n public static ArrayList getAdjSteps(Step curStep, int[][] matrix){ \n  ArrayList ret = new ArrayList(); \n  int curX = curStep.x, curY = curStep.y; \n  if(curX - 1 >= 0){ \n   ret.add(new Step(curX - 1, curY)); \n  } \n   \n  if(curX + 1 <= matrix.length - 1){ \n   ret.add(new Step(curX + 1, curY)); \n  } \n   \n  if(curY - 1 >= 0){ \n   ret.add(new Step(curX, curY - 1)); \n  } \n   \n  if(curY + 1 <= matrix[0].length - 1){ \n   ret.add(new Step(curX, curY + 1)); \n  } \n  return ret; \n } \n enum Status {VISITED, UNVISITED}; \n public static boolean findGreyPath(int[][] matrix){ \n  Map visited = new HashMap(); \n  Stack path = new Stack(); \n  Step start = new Step(0,0); \n  Step end = new Step(matrix.length - 1, matrix[0].length - 1); \n  path.push(start); \n  visited.put(start, Status.VISITED); \n  boolean ret = findGreyPathInternal(matrix, path, visited, end); \n  if(ret){ \n   Step tmpStep = null; \n   Iterator ite = path.iterator(); \n   while(ite.hasNext()){ \n    tmpStep = ite.next(); \n    System.out.format(\"->[%d, %d]\", tmpStep.x, tmpStep.y); \n   } \n  } \n  return ret; \n } \n  \n public static boolean findGreyPathInternal(int[][] matrix, Stack path, Map visited, Step exit){ \n  if(!path.isEmpty()){ \n   Step curStep = path.peek(); \n    \n   for(Step s: getAdjSteps(curStep, matrix)){ \n    if(visited.get(s) == null && (matrix[s.x][s.y] == 0 || matrix[s.x][s.y] == 2)){ \n     path.push(s); \n     visited.put(s, Status.VISITED); \n     if(s.equals(exit)){ \n      boolean hasGrey = false; \n      Step tmpStep = null; \n      Iterator ite = path.iterator(); \n      while(ite.hasNext()){ \n       tmpStep = ite.next(); \n       if(matrix[tmpStep.x][tmpStep.y] == 2){ \n        hasGrey = true; \n       } \n      } \n      if(hasGrey){ \n       return true; \n      } \n     }// end \"== exit\" \n     boolean ret = findGreyPathInternal(matrix, path, visited, exit); \n     if(ret){ \n      return true; \n     } \n    }// end if \n   }// end for-each step \n    \n   visited.remove(path.pop()); \n    \n  }// end if stack empty \n  return false; \n } \n  \n  \n  \n public static void main(String[] args) throws Exception { \n   \n  int[][] matrix = new int[6][6]; \n  matrix[0] = new int[]{0, 1, 1, 1, 1, 1}; \n  matrix[1] = new int[]{0, 0, 0, 0, 1, 1}; \n  matrix[2] = new int[]{1, 0, 1, 0, 1, 0}; \n  matrix[3] = new int[]{1, 2, 1, 0, 1, 0}; \n  matrix[4] = new int[]{1, 0, 0, 0, 1, 0}; \n  matrix[5] = new int[]{1, 1, 1, 0, 0, 0}; \n  System.out.println(findGreyPath(matrix)); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Matgame { \n \n public static void main(String[] args)  \n { \n  // TODO Auto-generated method stub \n        Matrix matrix = new Matrix(); \n        matrix.printTheMatrixValues(); \n        matrix.findThePath(matrix.mat[0][0]); \n        matrix.printSuccessPath(); \n } \n \n} \n \n \nimport java.util.ArrayList; \nimport java.util.Iterator; \nimport java.util.Scanner; \n \n \n \npublic class Matrix  \n{ \n int rows; \n int columns; \n ArrayListsuccessPath = new ArrayList(); \n Node mat[][]; \n  \n void enterRowsAndColumns() \n { \n  Scanner input = new Scanner(System.in); \n  System.out.println(\"Enter the rows of the matrix : \\n\"); \n  this.rows = input.nextInt(); \n  System.out.println(\"Enter the columns of the matrix : \\n\"); \n  this.columns = input.nextInt(); \n } \n  \n Matrix() \n { \n  enterRowsAndColumns(); \n  this.mat = new Node[this.rows][this.columns]; \n  buildMatrixWithUserInput(); \n } \n  \n public void printSuccessPath(){ \n  int i=0; \n  System.out.println(\"\\nSuccess path is:\"); \n  while(i < this.successPath.size()) \n  { \n   System.out.println(this.successPath.get(i).id); \n   i++; \n  } \n } \n \n private void buildMatrixWithUserInput()  \n { \n  System.out.println(\"Enter the values in the matrix\\n\"); \n  // TODO Auto-generated method stub \n  Scanner input = new Scanner(System.in); \n  for(int i=0;i neighbours = new ArrayList(); \n  neighbours = getNeighboursWith0or2(n); \n  if (neighbours.size()==0) \n  { \n   //System.out.println(\"Hi: n id : \" + n.id); \n   if(n.id == 0) \n   { \n    System.out.println(\"No success path\"); \n   } \n   return false; \n  } \n   \n  for(Node k: neighbours) \n  { \n    \n   if(this.successPath.contains(k)) \n   { \n    continue; \n   } \n   this.successPath.add(k); \n   boolean success = findThePath(k); \n   if(success) \n    return true; \n   else  \n   { \n    this.successPath.remove(k); \n   } \n  } \n  return false; \n   \n   \n } \n \n private ArrayList getNeighboursWith0or2(Node n)  \n { \n  // TODO Auto-generated method stub \n  ArrayList neighbours = new ArrayList(); \n  if(n.id > this.columns) \n  { \n   Node up = getNodeWithId(n.id - this.columns); \n   if(up.value ==0 || up.value == 2) \n   { \n    neighbours.add(up); \n    //System.out.println(\"ADDED UPPER\"); \n     \n   } \n  } \n  if(n.id <= (this.rows*this.columns-1) - this.columns) \n  { \n   Node down = getNodeWithId(n.id + this.columns); \n   if(down.value ==0 || down.value == 2) \n   { \n    neighbours.add(down); \n    //System.out.println(\"ADDED DOWN\"); \n   } \n  } \n  if(n.id % this.columns != 0) \n  { \n   Node left = getNodeWithId(n.id - 1); \n   if(left.value == 0 || left.value == 2) \n   { \n    neighbours.add(left); \n    //System.out.println(\"ADDED LEFT\"); \n   } \n  } \n  if((n.id+1) % this.columns != 0) \n  { \n   Node right = getNodeWithId(n.id + 1); \n   if(right.value ==0 || right.value == 2) \n   { \n    neighbours.add(right); \n    //System.out.println(\"ADDED RIGHT\"); \n   } \n  } \n         \n  //System.out.println(neighbours.size()); \n  return neighbours; \n   \n   \n } \n  \n private Node getNodeWithId(int id) \n { \n  int col = id % (this.columns); \n  int row = id / this.columns; \n  return this.mat[row][col]; \n } \n  \n} \n \n \npublic class Node  \n{ \n int value; \n int id; \n int x; \n int y; \n boolean visited; \n  \n  \n Node(int value, int id, int x, int y, boolean visited) \n { \n  this.value = value; \n  this.id = id; \n  this.x = x; \n  this.y = y; \n  this.visited = visited; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"1. Write a function of the form:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"You can MOVE in all the 8 possible directions, i.e.,   Straights: East, West, North South Diagonals: North-East, North-West, South-West, and South-East.    Thanks"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Here I have assume that one move in only two direction. For movement in all the eight directions code needs to be modified accordingly."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Scan through the matrix and form a undirected graph with 0s and 2s vertices and do a BFS or DFS?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-4","title":"How we can move? Only down and right?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5188169901277184","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"9","title":"Write a function to retrieve the number of a occurrences of a substring(even the reverse of a substring) in a string without using the java substring() method.  Ex: 'dc' in 'abcd' occurs 2 times (dc, cd).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Yeah, I agree that you should rabin-karp, but instead of one hash, you should have also the second one, counted for a word that was reversed, and match against those two hashes instead of one."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"In an interview setting , use rabin karp."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"i = 0; j = 0; i_rev = 0; j_rev = 0; number_of_occurence = 0 while(i{  if (haystack[i] == needle[j])    {    i++;    j++;    if (j == needle.length())     number_of_occurence++;   }   else   {    i = i - j + 1    j = 0   }          if(haystack[i_rev] == needle[j_rev])   {    i_rev++;    j_rev++;    if (j_rev == needle.length())     number_of_occurence++;   }   else   {    i_rev = i_rev - j_rev + 1    j_rev = 0   } }  return number_of_occurence;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if (ispalindrome(teststring)) \n     return numsubstring(string, teststring); \nelse \n    return numsubstring(string, teststring) + numsubstring(string, rev(teststring) ) ;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use two Suffix Trees, one for the normal word and one for the reverse string. Then return the occurrences of the substrings by calling SuffixTree#search(substring).  String search in O(m) complexity, where m is the length of the sub-string (but with initial O(n) time required to build the suffix tree for the string)  Link: en.wikipedia.org/wiki/Suffix_tree"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static string reverse(String s)  \n        { \n            int start = 0; \n            int end = s.Length - 1; \n            char temp; \n            StringBuilder str = new StringBuilder(s); \n             \n            while (start < end) { \n                temp = str[start]; \n                str[start] = str[end]; \n                str[end] = temp; \n                start++; \n                end--; \n            } \n \n            return str.ToString(); \n        } \n \n        public static int compare(string sfirst, string ssecond) \n        { \n            StringBuilder s1 = new StringBuilder(sfirst); \n            StringBuilder s2 = new StringBuilder(ssecond); \n \n            int count = 0; \n            bool equals; \n            for (int i = 0; i <= s2.Length - s1.Length; i++) \n            { \n                equals = true; \n                for (int j = 0; j < s1.Length; j++) \n                { \n                    if (s1[j] != s2[i + j]) \n                        equals = false; \n                } \n                if (equals) \n                    count++; \n            } \n            return count; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class RabinKarp { \n  \n private String pat; // the pattern string. \n private long patHash; // the hash of the pattern \n private long Q; // a large prime number, small enough to avoid overflow. \n private int M; // pattern string length. \n private long RM; // R ^ (M - 1) % Q \n private int R; // radix. \n  \n public RabinKarp(String pattern){ \n  pat = pattern; \n  M = pat.length(); \n  R = 256; \n  Q = longPrimeNumber(); \n  patHash = hash(pat); \n  RM = 1; \n  for(int i = 1; i <= M - 1; i ++){ \n   RM = (RM * R) % Q; \n  } \n } \n  \n public void search(String txt){ \n  int N = txt.length(); \n  if(N < M){ \n   System.out.println(N); \n  } \n   \n  // Compare pattern and first M - character sequence in text string. \n  long txtHash = hash(txt); \n  if(patHash == txtHash && check(txt, 0)){ \n   System.out.println(0); \n  } \n   \n  for(int i = M; i < N; i ++){ \n   txtHash = (txtHash - RM * txt.charAt(i - M)) % Q; \n   txtHash = (R * txtHash + txt.charAt(i)) % Q; \n   if(txtHash == patHash && check(txt, i - M + 1)){ \n    System.out.println(i - M + 1); \n   } \n  } \n } \n  \n // Check if pattern equals the corresponding M - character sequence in text string. \n public boolean check(String txt, int offset){ \n  for(int i = 0; i < M; i ++){ \n   if(pat.charAt(i) != txt.charAt(i + offset)){ \n    return false; \n   } \n  } \n  return true; \n } \n  \n // Get a hash value of a string of length M \n public long hash(String key){ \n  long h = 0; \n  for(int i = 0; i < M; i ++){ \n   h = (R * h + key.charAt(i)) % Q; \n  } \n  return h; \n } \n  \n // Get a 31-bit prime number \n public long longPrimeNumber(){ \n  BigInteger probablePrime = BigInteger.probablePrime(31, new Random()); \n  return probablePrime.longValue(); \n } \n \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n  String pat = \"abc\"; \n  String txt = \"abcddbsabcba\"; \n  RabinKarp rk = new RabinKarp(pat); \n  rk.search(txt); \n  System.out.println(\"----------\"); \n  StringBuilder sb = new StringBuilder(pat); \n  RabinKarp rk1 = new RabinKarp(sb.reverse().toString()); \n  rk1.search(txt); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"simple version of Rabin Karp"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"void CountWords(string txt, string str, int &cnt) \n{ \n if(txt.size()==0 || str.size()==0) \n  return; \n int start=0; \n int index=0; \n int n=txt.size(); \n \n while(start!=n) \n { \n  index=txt.substr(start,n).find(str); \n  if(index!=string::npos) \n  { \n   cnt++; \n   start+=(index+str.size()-1); \n  } \n  else \n   start++; \n } \n} \nint main() \n{ \n string txt=\"   PUT SOURCE STRING HERE  \";  \n string str=\" PUT STRING TO BE SEARCHED HERE \"; \n int cnt=0; \n \n CountWords(txt,str,cnt); \n reverse(str.begin(),str.end()); \n CountWords(txt,str,cnt); \n \n cout<<\"Total Count:\\t\"<<"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5485521224597504","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"7","title":"Given an input list of lists.. flatten the list. For e.g.   {{1,2}, {3}, {4,5}} ... Output should be {1, 2, 3, 4, 5}","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"looks like merging n sorted lists . k-waymerge could solve the problem"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"In python using list comprehensions: arr = [[1,2],[3],[4,5]] [num for elem in arr for num in elem]  >> [1,2,3,4,5]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just to clarify, is it allowed to change the data structure? Or just implement like iterator to flattenly access to the elements?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public List flattenList(List> listOfList) { \n  List flattenList = new ArrayList(); \n   \n  for(List list: listOfList) { \n   flattenList.addAll(list); \n  } \n  return flattenList; \n   \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static List FlattenList(List> inputList) \n        { \n            return inputList.SelectMany(x => x).ToList(); \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"l = [[1,2], [3], [2,4,5], [6], [4,5,7,4]] \nl1 = list(l) #Copy of l \ne = [] \n \nfor i in l: \n    l2 = l1.pop(l1.index(i)) \n    for j in l2: \n        e.append(j) \n         \nprint e"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5672369481842688","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"9","title":"Find the max height of a binary tree.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"height is usually defined as max depth of any node"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int getHeight(Node root){  if(root==null) return 0;  int L=0; int R=0;  if(root.L!=null) L=1+getHeight(root.L);  if(root.R!=null) R=1+getHeight(root.R);  return max(L,R); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Max_height_tree { \n  \n int height1,height2; \n  \n public Max_height_tree() { \n height1 = 0; \n height2 =0; \n } \n  \n public int height(TreeNode node) \n  \n {  \n  if(node==null) \n   return -1;//This decides if a  \n  else{ \n   \n  height1=height(node.leftchild)+1; \n  height2 =height(node.rightchild)+1; \n   \n  } \n  return (Math.max(height1,height2)); \n   \n   \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here I`ll post a non-recursive way.  int height(TreeNode * root){         if (!root) return 0;         stack s;         TreeNode * current = root;         int maxHeight = 0;         while(true){                 if (current){                         s.push(current);                         current = (current->left != NULL)?current->left:current->right;                 }                 else{                         maxHeight = s.size()>maxHeight?s.size():maxHeight;                         current = s.top();                         s.pop();                         if (s.empty()) break;                         if (current == s.top()->left){                                 current = s.top()->right;                         }                         else{                                 current = NULL;                         }                 }          }         return maxHeight; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void MaxHeight(struct bst *b, int level, int &maxHeight, struct bst **MaxHeightNode) \n{ \n if(b) \n { \n  MaxHeight(b->lc,level+1, maxHeight, MaxHeightNode); \n  if(level>maxHeight) \n  { \n   maxHeight=level; \n   (*MaxHeightNode)=b; \n  } \n  MaxHeight(b->rc,level+1, maxHeight, MaxHeightNode); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Java code  int getHeight (TreeNode root) {  if (root == null)    return 0;  else   return 1 + Math.max ( getHeight (root.left), getHeight (root.right) ); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int maxDepth;"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4639756264669184","download_status":"DOWNLOAD_DONE","votes":"3","answersCount":"5","title":"Write your own regular expression parser for following condition:  az*b can match any string that starts with and ends with b and 0 or more Z's between. for e.g. azb, azzzb etc.  a.b can match anything between a and b e.g. ajsdskjb etc.  Your function will have to parameters: Input String and Regex. Return true/false if the input string satisfies the regex condition. Note: The input string can contain multiple regex. For e.g. az*bc.g","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include    \n#include  \n \nusing namespace std; \n \ntypedef pair rePair; \ntypedef list rePairList; \n \nbool doMatch(string re, string str) { \n  int rePos = re.size() - 1; \n  int strPos = str.size() - 1; \n   \n  while (rePos >= 0 && strPos >= 0) { \n    char reChar = re[rePos]; \n    char strChar = str[strPos]; \n     \n    //Wildcard \n    if (reChar == '*') { \n      //See if it matches without the wildcard \n      bool ret = doMatch(string(re, 0, rePos-1), string(str, 0, strPos+1)); \n      if (ret) return true; \n       \n      //No match without it.  match one by one and check again \n      //if it matches without the wild. \n      while (str[strPos] == re[rePos-1]) { \n        strPos--; \n \n        ret = doMatch(string(re, 0, rePos-1), string(str, 0, strPos+1)); \n        if (ret) return true; \n      } \n       \n      //Pass the wildcard and loop. \n      rePos -= 2; \n      continue; \n    } \n \n    //dot and literal matches \n    if (reChar == '.' || (reChar == strChar)) { \n      rePos--; \n      strPos--; \n      continue; \n    } \n \n    //Not a match! \n    return false; \n  } \n \n  //Left at the beginning of both? \n  return (rePos < 0 && strPos < 0); \n} \n \nint main() { \n \n  rePairList tests; \n  tests.push_back(rePair(\"az*b\", \"azzzzzb\")); //yes \n  tests.push_back(rePair(\"azz*zb\", \"azzzzzb\")); //yes \n  tests.push_back(rePair(\"az*.....z*b\", \"azzzzzb\")); //yes \n  tests.push_back(rePair(\"az*.z*b\", \"azzzzzb\")); //yes \n  tests.push_back(rePair(\"az.b\", \"azxb\")); //yes \n  tests.push_back(rePair(\"azxb\", \"azxb\")); //yes \n  tests.push_back(rePair(\"azxb\", \"azab\")); //no \n   \n  for (rePairList::iterator it = tests.begin() ; it != tests.end() ; it++) { \n    bool ret = doMatch(it->first, it->second); \n    cout << it->first << \" / \" << it->second << \" --> \" << ret << endl; \n  } \n  cout << endl << endl << \"DONE\" << endl; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use automata"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My simple recursive solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public class PatternMatcherRegex { \n  \n  \n public static boolean match(String regX, String candidate) { \n   \n  //If regex is empty, the pattern doesnt match \n  if(regX.isEmpty())  \n   return false; \n   \n  if(regX.charAt(0) == '*') { \n    \n   if(regX.length() == 1) { \n    /** \n     * The last regex character is *, \n     * which matches everything \n     */ \n    return true; \n   } \n   else { \n    return matchStar(regX.substring(1), candidate); \n   } \n    \n  } \n  else if(candidate.isEmpty()) { \n   //Candidate is empty but the pattern is not \n   return false; \n  }  \n  else if(regX.charAt(0) == '.' || regX.charAt(0) == candidate.charAt(0)) { \n    \n   //Last regex matches last character \n   if(regX.length() == 1 && candidate.length() == 1)  \n    return true; \n   else { \n    return match(regX.substring(1), candidate.substring(1)); \n   } \n  } \n  else  \n   return false; \n } \n  \n public static boolean matchStar(String regX, String candidate) { \n   \n  for(int i = 0; i < candidate.length(); i++) { \n   if(match(regX, candidate.substring(i))) \n    return true; \n  } \n   \n  return false; \n } \n  \n public static void main(String[] args) { \n  System.out.println(match(\"a.b\", \"accb\")); \n } \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5911331261644800","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"14","title":"Here is a good puzzle:   How do you write a program which produces its own source code as output?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"A quine is a computer program which takes no input and produces a copy of its own source code as its only output. The standard terms for these programs in the computability theory and computer science literature are self-replicating programs, self-reproducing programs, and self-copying programs. ( Wiki: en.wikipedia.org/wiki/Quine_(computing) )  Watch out for Quines here: 1. madore.org/~david/computers/quine.html 2. nyx.net/~gthompso/quine.htm  A complete Quine:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"The empty python script does the trick."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"see \"quine\" in google   #include  char str[] = \"#include %cchar str[] = %c%s%c;%cint main() { printf(str, 10, 34, str, 34, 10); return 0; }\"; int main() { printf(str, 10, 34, str, 34, 10); return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \n//#include  \n \nint main() \n{ \n        std::ifstream fp(__FILE__, std::ifstream::in); \n        std::string line; \n \n        //FILE* fp = fopen(__FILE__, \"r\"); \n \n        if(fp == NULL) \n        { \n                std::cout << \"fp = NULL\" << std::endl; \n                return 0; \n        } \n        else \n        { \n                //std::cout << \"fp != NULL \" << std::endl; \n                while(!fp.eof()) \n                { \n                        getline(fp, line, '\\n'); \n                        for(int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/This is a mirror program which prints its source code ;-)  #include #include #include  using namespace std; int main() { // to read one line from file string line; // this is our source file which is going to be the input file ifstream f (__FILE__); // read until the last line and print each line while (getline(f, line))  cout << line << endl; return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"key points: 1, use \"printf\" to keep the format 2, use ASCII code to replace \"\\n\",\"\\t\" and quotation mark."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nusing namespace std; \n \n#define ENIUQ(TEMPLATE) cout << TEMPLATE << \"(\" << #TEMPLATE << \");}\"; \n \nvoid main() \n{ \n ENIUQ(\"#include \\n#define ENIUQ(TEMPLATE) cout << TEMPLATE << \\\"(\\\" << #TEMPLATE << \\\");}\\\";\\n\\nvoid main()\\n{ENIUQ\"); \n    system(\"pause\"); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"All are stupid logic"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include  int main() {         system(\"cat test.c\"); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"A program that reads and prints its source."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5314486768500736","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"5","title":"How would you assign numbers if you were AT&T, describe a data structure","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Trie(prefix tree). The length of a phone number is a fixed number and phone numbers in close area may share the same area code(prefix). So It will be pretty efficient for searching(O(m), m is the length of the phone number) and storing all those phone numbers inside a Trie."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"10 Level Hashed data structure. (Multi Level Hashing with 10 levels because of 10 numbers in it.)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5825789740187648","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"24","title":"Given a string say \"ABCD\". Now create a new string with duplicates of each character in the original string and append the reverse of the same string (with duplicates) excluding the last character.   First iteration: AABBCCCCBBAA   [ABC three types of chars; Here c is the last char.Ignore duplicates after the last char c]  Second iteration: AABBBBAA  [here b is the last char]  Third iteration: AAAA [no second char left]","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"C:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"public class Main { \n    public static void main(String[] args) { \n        String str = \"ABCD\"; \n \n        StringBuilder builder; \n        for (int i = 0; i <= str.length()-1; i++) { \n            builder = expand(str.substring(0, str.length()-i)); \n            System.out.println(\"final == \" + builder.toString()+ builder.reverse().toString()); \n        } \n    } \n \n    public static StringBuilder expand(String str) { \n        StringBuilder builder = new StringBuilder(); \n \n        for(char ch:str.toCharArray()) { \n            builder.append(duplicate(ch)); \n        } \n \n        return builder; \n    } \n \n    public static String duplicate(char ch) { \n        return  \"\" + ch + ch; \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"String str = \"ABCD\";   StringBuffer buffer = new StringBuffer();   for(int i = 0 ; i  < str.length()-1; i++) {    buffer.append(str.charAt(i));    buffer.append(str.charAt(i));   }   System.out.println(\"final ==\" + buffer.toString()+ buffer.reverse().toString());"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def callFunct(): \n strDup(list(\"ABCD\"),0) \n \ndef strDup(ls1,length): \n while length < len(ls1): \n  str1 =\"\" \n  tempList = list() \n  for chars in ls1[:-length]: \n   str1=str1+chars+chars \n   tempList.append(chars) \n  for chars in tempList: \n   temp = tempList.pop() \n   str1 = str1+temp+temp \n  print str1 \n  strDup(ls1, length+1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \"stdafx.h\" \n#include  \n#include  \n#include  \nusing namespace std; \n \nint _tmain(int argc, _TCHAR* argv[]) \n{ \n string testCase = \"ABCD\"; \n stack stc; \n string b = \"\"; \n for (int i = 0; i < testCase.length(); i++) \n { \n  b = b + testCase.at(i); \n  stc.push(b); \n } \n while (stc.size() > 0) \n { \n  string t = stc.top(); \n  int j = 0; \n  for (int i = 0; i < t.length(); i = j / 2) \n  { \n   cout << t.at(i); \n   j++; \n  } \n  int k = 0; \n  for (int i = 0; i < t.length(); i = k / 2) \n  { \n   cout << t.at(t.length() - 1 - i); \n   k++; \n  } \n  cout << endl; \n  stc.pop(); \n } \n system(\"pause\"); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \n#include  \nvoid MyPrint(char * strdes) \n{ \n int N = (strlen(strdes) - 1) * 4 + 4 + 1;  \n char* strsrc; \n int index = 0;  \n if(NULL == (strsrc =(char *) malloc (sizeof(char) * N)))  \n { \n  perror(\"not enough memeory!\"); \n  exit(1); \n } \n \n for(int i=0; i< strlen(strdes)-1; i++) \n { \n  for(int j=0; j<2; j++) \n   strsrc[index++] = strdes[i]; \n } \n \n  \n for(int j=0; j<4; j++) \n  strsrc[index++] = strdes[strlen(strdes)-1]; \n  \n \n for(int i= strlen(strdes)-2; i>=0; i--) \n { \n  for(int j=0; j<2; j++) \n   strsrc[index++] = strdes[i]; \n } \n  \n strsrc[index] = '\\0'; \n  \n printf(\"%s\\n\", strsrc); \n free(strsrc); \n} \n \nint main() \n{ \n char* s = \"ABC\"; \n MyPrint(s); \n  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"M=len(String)-1; N=4*M; for(i=0,j=0 ; ia[j]=a[i];  j=2;i=0; while(i{ while(i{ b[i]=b[n-i]=a[j]; i++; } j+=2; }  for(i=0; icout< \n   \n    \n   -  \n     Sidz \n     on October 04, 2013 Edit | Flag  \n    \n    \n   Reply"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks;  namespace StringDubs {     class Program     {          static void Dubs(string word)         {             if (word.Length>0)             {                 int k = 0;                 int i = 0, j = 0;                 char c;                 char[] mani = new char[(word.Length) * 2];                 for (i = 0; i < word.Length; i++)                 {                     for (j = 0; j < 2; j++)                     {                         mani[k] = word[i];                         k++;                     }                                       }                 word = word.Remove(word.Length-1);                 for (k = 0; k < mani.Length; k++)                 {                     Console.Write(mani[k]);                 }                 Array.Reverse(mani);                 for (k = 0; k < mani.Length; k++)                 {                     Console.Write(mani[k]);                 }                  Console.WriteLine();             }             Dubs(word);         }         static void Main(string[] args)         {             Dubs(\"ABC\");         }     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using System; \nusing System.Collections.Generic; \nusing System.Linq; \nusing System.Text; \nusing System.Threading.Tasks; \n \nnamespace StringDubs \n{ \n    class Program \n    { \n \n        static void Dubs(string word) \n        { \n            if (word.Length>0) \n            { \n                int k = 0; \n                int i = 0, j = 0; \n                char c; \n                char[] mani = new char[(word.Length) * 2]; \n                for (i = 0; i < word.Length; i++) \n                { \n                    for (j = 0; j < 2; j++) \n                    { \n                        mani[k] = word[i]; \n                        k++; \n                    } \n \n                     \n                } \n                word = word.Remove(word.Length-1); \n                for (k = 0; k < mani.Length; k++) \n                { \n                    Console.Write(mani[k]); \n                } \n                Array.Reverse(mani); \n                for (k = 0; k < mani.Length; k++) \n                { \n                    Console.Write(mani[k]); \n                } \n \n                Console.WriteLine(); \n            } \n            Dubs(word); \n        } \n        static void Main(string[] args) \n        { \n            Dubs(\"ABC\"); \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) {         String str = \"ABCD\";                          StringBuilder builder;         for (int i = str.length() - 1; i > 0; --i) {             builder = expand(str.substring(0, i));             System.out.println(\"final == \" + builder.toString()+ builder.reverse().toString());         }     }      public static StringBuilder expand(String str) {         StringBuilder builder = new StringBuilder();          for(char ch:str.toCharArray()) {             builder.append(duplicate(ch));         }          return builder;     }      public static String duplicate(char ch) {         return  \"\" + ch + ch;     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have improved the solution provided by Urik Lagnes       class Program     {         static void Main(string[] args)         {             Console.WriteLine(\"Enter the string\");             string input = Console.ReadLine();              int displayLength = input.Length - 1;              while (displayLength > 0)             {                 char[] displayString = new char[displayLength * 4];                  for (int i = 0; i < displayLength; i++)                 {                     displayString[(i << 1)] = input[i];                     displayString[(i << 1) + 1] = input[i];                     displayString[(displayLength * 4) - (i << 1) - 1] = input[i];                      displayString[(displayLength * 4) - (i << 1) - 2] = input[i];                 }                 Console.WriteLine(displayString);                 displayLength -= 1;             }          }     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"char *s=\"abcd\"; \n int cnt=strlen(s)-1; \n int n=strlen(s); \n int i,j,index=0; \n char *str; \n  while(cnt>=1) \n { \n  index=0; \n  for(i=0;i=0;j--) \n    str[index++]=str[j]; \n  str[index]='\\0'; \n  puts(str); \n  cnt--; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the description is kind of wield.Like we only need 2 record the order the char appears???? abcd goes 2 aabbccccbbaa...how about aba? thats aaaa? what does the 2nd and 3rd iteration mean here ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"'''public class subStringWithDuplicate {   public static void main(String[] args) {   // TODO Auto-generated method stub   String str = \"ABCD\";   for(int i=0; i  {    String disp = \"\";    for(int j=0; j   {     disp = disp + str.charAt(j) + str.charAt(j);    }    for(int j=disp.length()-1; j>=0; j--)    {     disp = disp + disp.charAt(j);    }    System.out.println(disp);   }  }  }\\\\\\"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// input ABCD \n// output AABBCCCCBBAA \n \n 1) start reading from start to (lenght-1) and from Lenngth-1 to Start \n  \npublic string GetNewString(string str) \n{ \n if(str == null) return str; \n if(str == \"\") return str; \n \n StringBuilder sb1= new StringBuilder(); \n StringBuilder sb2= new StringBuilder(); \n  \n for(int i=0,j=str.length-1;i=0;j--,i++) \n { \n  sb1.Append(str[i]); \n  sb2.Append(str[j]); \n } \n \n return sb1.ToString() + sb2.ToString();"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Below code gives desired output but not a very efficient one"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution using perl"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"the  first and second solutions given above will give the output AABBCCCCBBAA for the input ABCD . What exactly is asked in the question is to go itteration by itteration . what is the expected output ? Is it AAAA or AABBCCCCBBAA ?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5923015988609024","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"9","title":"I was asked this question during campus placement drive :  You have a Timer which goes to from a certain range ( n to 0), where n is not fixed and we can have it as much as we want.  The timer when goes to 0 an associated callback for the request is done.  We have multiple requests coming into the system, however the Timer is insufficient to deal with them at all at once ( it can deal with a figure less than number of requests).  How do you reuse the timer and handle all asynchronous requests?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Guys why just don't use priority queue to store callbacks for this task? Each element of the queue contains callback address, pointer to callback paramenters and timestamp when it should be fired. The timestamp is a priority. Timer could be implemented using condition variable or another analogue, the main idea is to have possibility to wake it up from another thread. When callback is added to the queue, the timer thread is waken up, it gets the top element of priority queue, calculates the different between current time and elements timestamp and sleeps until calculated timeout exceeds. When the thread is awaken by timeout it starts new thread which invokes callback or put this callback to the queue of execution which can be served by threads pool."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"use the approach that i have given no message will loss ..  it is very similay to interrupt handling ( isr and bottom halves ) put all critical job in one function and put all the deffered job in another and  schedule deffered function to run later ... most of the RTOS  uses very much similay technique ..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Need to reread this after a coffee... woah"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You need to use a FIFO for buffering the incoming requests?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question is a bit blurry, but from what I understand -  Here's a way to implement a N to 0 (zero) timer, handling multipule request (by signaling). Assume the timer refreshes every second and could check if should serve a request.  Whenever the timer is Invoked with time t do: if first time - create array a of size n+1 (0-n), the array holds a linked list in each cell. add to list a[n] the request identifier and return. Also store t in N.  else (not first time) -   let i be the number of past seconds. (global to timer class)  if t <= n-i - add request id. to list at a[n-i-t] and return.  else -    a. create new array a' like a of size t+1   b. copy a to a' by placing each list at location k (in a) to location k-i                                 (in a'). *k-i is the time left for handling.   c. let a be a' (discarding former a).  on each refresh entrance: increase i by one if list at a[i] isn't empty serve (or signal) all requests on the list and remove them."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this is an easy approach   1. first take a dynamic buffer . 2. and  my timer is capable for handling one request at a time . 3. if suppose multiple request is generated so , what we all need to do is this  4. we take the request put it inside the buffer and make a linked list of it  5. so , we have all the request in my list . now go through the list and clear all the pending job .  6. one thing make sure that whenever a request is genereted immediatly save the status of your current job and handle the request so no request get lost ....  thank u"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi folks, I would recommend using a \"async and await\" function calls which can handle all requests asynchronously.  Imagine this timer to be a Phone app which is created in the server. If the requests comes in and we queue each requests, the user might have to wait long to get a response back from the server as the resources is blocked by the previous users.  Instead using await and async the user can keep getting response with out potentially a long wait period.   Implementing a queue in the server is a very long process and given that it is a placement drive, I think they are looking for these types of special keywords."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"you can use round robin algorithm..."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5270423625269248","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"31","title":"Print the numbers between 30 to 3000. CONSTRAINT: The numbers shouldnt contain digits either in incresing order or decreasing order.  FOLLOWING NOT ALLOWED ##123,234,345,1234,2345##increasing order, ##32,21,321,432,3210 etc##decresing order.  FOLLOWING ALLOWED: 243,27,578,2344 etc., Now see who ll code ths....","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"26","title":"String sortedNumbers = \"123456789 9876543210\"; \n        for (int i = 31; i <= 3000; i++) { \n            String temp = \"\" + i; \n            if (!sortedNumbers.contains(temp)) { \n                System.out.println(temp); \n            } \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"this loser who uses ##   ## and  \"let's see who can code best / best logic ... dare you\"  is posting a bunch of homework problems under different company names  my son rohit will pwn him"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package in.neeraj.app.main; \n \npublic class PrintNumber { \n \n public static void main(String args[]) { \n  int j, k, m, x, a, b; \n  for (int i = 30; i <= 3000; i++) { \n   if (i < 99) { \n    j = i / 10; \n    k = i % 10; \n    if (j == (k + 1) || j == (k - 1)) \n     i++; \n   } \n \n   else if (i > 99 && i < 1000) { \n    j = i / 100; \n    k = i % 100; \n    m = k / 10; \n    x = k % 10; \n    if ((m == (j + 1) && x == (m + 1)) \n      || (m == (x + 1) && j == (m + 1))) \n     i++; \n \n   }else \n    { \n    j = i / 1000; \n    k = i % 1000; \n    m = k / 100; \n    x = k % 100; \n    a = x / 10; \n    b = x % 10; \n    if (m == (j + 1) && a == (m + 1) && b == (a + 1)) \n     i++; \n   } \n   System.out.println(\" \" + i); \n  } \n \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int PrintAll(int s,int e){ \n  int count=0; \n  for(int i=s;i<=e;i++){ \n   if(i<99){ \n    int j=i/10; \n    int k=i%10; \n    if(j==(k+1)||j==(k-1)){ \n     i++; \n    } \n   } \n   else if(i>99&&i<1000){ \n    int j=i/100;//3 or 1 \n    int k=i%100; \n    int l=k/10;//2 or 2 \n    int m=k%10;//1 or 3 \n    if((j==(l+1)&&l==(m+1))||(m==(l+1)&&l==(j+1))){ \n     i++; \n    } \n   } \n   else if(i>999 && i<=e){ \n    int j=i/1000;//1 or 4 \n    int k=i%1000; \n    int l=k/100;//2 0r 3 \n    int m=k%100; \n    int n=m/10;//3 or 2 \n    int o=m%10;//4 or 1 \n    if((j==(l+1)&&l==(n+1)&&n==(o+1))||(j==(l-1)&&l==(n-1)&&n==(o-1))){ \n     i++; \n    } \n   } \n    System.out.println(\" \"+i); \n    count++; \n  } \n  return count; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class test {   int start = 30;   int end = 3000;    private boolean isAllowed(int i)  {   if (isAsnding(i) || isDecending(i))   {    return false;   }   return true;  }  private boolean isAsnding(int i)  {   int prev = -1 ;   int cur = -1;   boolean result = true;   boolean cond = true;   do{     if (i > 10000)     {      cur = (i/10000);      i = (i%10000);     }     else if (i >1000)     {      cur = (i/1000);      i = (i%1000);     }     else if (i > 100)     {      cur = (i/100);      i = (i%100);     }     else if (i >10)     {      cur = (i/10);      i = (i%10);     }     else if (i <10)     {      cur = i;      cond = false;     }     if (prev != -1 && prev != cur+1 )       result = false;     else      {      prev = cur;     }       }while (cond == true && result == true);      //System.out.println(\" asc result: \" + result);   return result;  }  private boolean isDecending(int i)  {   int prev = -1 ;   int cur = -1;   boolean result = true;   boolean cond = true;   do{     if (i > 10000)     {      cur = (i/10000);      i = (i%10000);     }     else if (i >1000)     {      cur = (i/1000);      i = (i%1000);     }     else if (i > 100)     {      cur = (i/100);      i = (i%100);     }     else if (i >10)     {      cur = (i/10);      i = (i%10);     }     else if (i <10)     {      cur = i;      cond = false;     }     if (prev != -1 && prev != cur-1 )       result = false;     else      {      prev = cur;     }       }while (cond == true && result == true);      return result;  }  private void printRange()  {   for (int i = start ; i <= end ; i++)   {    if (isAllowed(i))    {     System.out.println(i + \" \");    }   }  }  /**   * @param args   */  public static void main(String[] args)   {   test t = new test();   t.printRange();  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool valid(int n){  bool increase=false,decreas=false;  int last=n%10,cur=0;  n/=10;  while(n>0){   cur=n%10;   if(cur>last)    decrease=true;   else if (cur   increase=true;   last=cur;   n/=10;  }  return increase^decrease; }  void nonIncreasingDecreasingNum(int start,int end){    for(int i=min(100,start);i<=end;i++){   if(valid(i))    cou< } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It looks like Subbu is getting his homework done or something."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nusing namespace std; \n  \nint Fns(int Table[]) \n{ int flag=0,flag2=0; \n    int n; \nfor(int i=30;i<=300;i++) \n{ flag=0;flag2=0; \n    n=i; \n    while(n) \n    { \n        Table[n%10]+=1; \n     if(Table[n%10]>1) \n     { flag=2; \n        break; \n     }  \n    n/=10; \n    } \n   if(flag==0) \n    for(int j=0;j<10;j++) \n    { \n        if(Table[j]) \n        { \n            if(flag2==1) \n            {flag=2; \n             break; \n            } \n        flag=1; \n        } \n        else \n        {  if(flag==1) \n            flag2=1; \n  \n        } \n    } \n    if(flag==2) \n    cout<<<\" \"; \n   for(int j=0;j<10;j++) \n   Table[j]=0; \n  \n} \n  \n} \nint main() \n{ \n    int Table[10]={0}; \n    Fns(Table); \n    return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int mult=10; \n int I,i,prev,r,flag=0; \n for(I=30;I<200;I++) \n { \n  i=I; \n  prev=INT_MIN; \n  if(i/mult>=mult) \n   mult*=10; \n  while(i>0) \n  { \n   r=i%mult; \n   i=i/mult; \n   if((r==prev-1) || (r==prev+1) || (r==prev)) \n   { \n    flag=1; \n    break; \n   } \n   prev=r; \n  } \n  if(flag==0) \n   printf(\"%d\\t\",I); \n  else \n   flag=0; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Another way is to keep a prefix trie of invalid numbers while going from 30 to 30000. So 32 and 34 would go in the trie. Then 321 and 324 can be matched by searching for prefix 32."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package test;   public class TestClass {    public static void main(String[] args) {        for (int input = 300; input < 3000; input++) {      int mul = 10,currDigit = 0;   boolean flag = true,increasing = false, decreasing = false;      int lastDigit = (input) % 10;      while((input/mul) > 0 && flag)   {   currDigit = (input/mul) % 10;   if(currDigit == lastDigit + 1 && !increasing)   {    decreasing = true;      }   else    decreasing = false;    if(currDigit == lastDigit -1 && !decreasing)   {    increasing = true;      }   else    increasing = false;   if(!increasing && ! decreasing)    flag = false;   mul*=10;   lastDigit = currDigit;   }   if(!flag)    System.out.println(input);     }  }     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \"stdafx.h\" \n#include  \n#include  \n#include  \nusing namespace std; \nint _tmain(int argc, _TCHAR* argv[]) \n{ \n for (int i = 31; i < 3000; i++) \n { \n  int st[4] = {}; \n  st[3] = i % 10; \n  st[2] = (i % 100) / 10; \n  st[1] = (i % 1000) / 100; \n  st[0] = i / 1000; \n  int p = 0; \n  for (int j = 0; j < 3; j++) \n  { \n   if (st[j] != 0) \n   { \n    p = p + abs(st[j + 1] - st[j]); \n   } \n  } \n  int db = log(i) / log(10); \n  if (p != db) \n  { \n   cout << i << endl; \n  } \n  system(\"pause\"); \n } \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Yes, the code is very elegant, but is it more efficient than a more straightforward one? As I know, the KMP String Matcher takes O(m+n) time, where m is the number's length, and n is the length of \"123456789 9876543210\". While for the straightforward one, we could just scan the number's length and determine whether it is a valid number, which will takes only O(m). Here is my code in C++ for the two version:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n#define N1 30 \n#define N2 300 \nint main() \n{ \n    int i, j=0, A[N2],a=0,b=0,flag=0,temp; \n    for(i=N1;i0) \n        { \n            a=temp%10;             \n            if(a-b == 1 || a-b == -1) \n             flag=1; \n            else \n             flag=0 ; \n           b=a; \n           temp=temp/10;        \n        }  \n        if(flag==0) \n          A[j++]=i;                  \n    } \n    for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For an invalid number the abs diff of the first and the last digit is equal to its length minus 1. If the length is odd the mid digit is equal to the (first + last)/2  Examples: 56      1 5678    3 7654    3 3456789   6, and 6 = (3 + 9)/2  This would help to recursively check for the (in)validity of the number."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"578, isnt this  in an increasing order?????"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def isinc(x): \n l=list(str(x)) \n return l==sorted(l) \n \ndef isdec(x): \n l=list(str(x)) \n b=sorted(l) \n b.reverse() \n return l==b \n \nr=[] \n \nfor i in range(30,3001): \n if isinc(i) or isdec(i): \n  continue \n r.append(i)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4959773472587776","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"29","title":"Given an n X n matrix, find all elements which are zero, when found set all the elements in that row and column to zero.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"it's on CtCI book and repeated many times careercup.com/question?id=10442525 (switch 0 to 1) careercup.com/question?id=302724 etc  It's possible to do it in O(n^2) time and O(1) extra memory.   explanation: book errata page 182, ex 1.7  docs.google.com/spreadsheet/pub?hl=en_US&hl=en_US&key=0AuwEKO7o6mrAdFdhZHRlN1JUc3dEVFRNMDJzWlE1VXc&output=html   code: github.com/gaylemcd/ctci/blob/master/java/Chapter%201/Question1_7/Question.java"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please make the question clear.Do you want the program to run in a loop or do u want the program to run only once??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Scan matrix for zeroes and remember rows and columns containing 0, in second path update matrix. Computational complexity O(n^2), memory complexity O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What does the function return?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void setZero(int, int,int *, int); \n \nint main(){ \n    const int n = 4; \n    int array[n][n]={{1, 1, 3, 1}, {5, 9, 0, 8}, {1, 2, 3, 4}, {3, 2, 5, 9}}; \n    // creating a copy of matrix for locating zero in the original \n    int array_2[n][n];   \n    for(int i = 0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"\"find all\" meaning?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void SetZeros(int Matrix[][],int rowSize, int colSize) {     int rowMask = 0;    int colMast = 0;     for(int i = 0; i < rowSize; i++)    {      for(int j=0; j < colSize; j++)      if(Matrix[i][j] == 0)       {         rowMask |= 1 << i;         colMast |= 1 << j;       }         }     for(int i = 0; i < rowSize; i++)    {      for(int j=0; j < colSize; j++)      if(rowMask & 1 << j && colMask & 1 << j)       {         Matrix[i][j] = 0;       }         }      } - At least algorithm should work."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Lets define 3* 3 matrix \n            int n=3; \n \n            //this is the multidimensional array here3  dimensional is  used  \n            int[,] matrixValues = new int[n, n]; \n            //add any  values to the matrix \n            for (int f = 0; f < n; f++) \n            { \n                    for (int g = 0; g < n; g++) \n                    { \n                        matrixValues[f, g] = f + 3; \n                    } \n \n               \n            } \n            //My Matrix  will  look like  \n             //[ 3   3       3   ] \n            // [ 4   4       4   ]  \n            // [ 5   5       5   ]   \n \n            //Add  static values  0 to 2*1 index \n            //and  any  random values  to  see the diff  \n            matrixValues[0, 0] = 2; \n            matrixValues[0, 1] = 7; \n            matrixValues[1, 0] = 4; \n            matrixValues[2, 1] = 0; \n            \n            //now  here  comesw the  logic  \n            for (int i = 0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"number_of_rows = 4 \nmatrix = [[1, 2, 3, 4], \n          [5, 6, 0, 0], \n          [9, 0, 1, 0], \n          [3, 4, 5, 6]] \n \nmarked_rows = [] \nmarked_columns = [] \n \nfor i in (0..number_of_rows-1) do \n  for j in (0..number_of_rows-1) do \n    if matrix[i][j] == 0 \n      marked_rows << i unless marked_rows.include? i \n      marked_columns << j unless marked_columns.include? j \n    elsif marked_columns.include?(j) \n      break \n    end \n  end \nend \n \nfor i in (0..number_of_rows-1) do \n  for j in (0..number_of_rows-1) do \n    matrix[i][j] = 0 if marked_rows.include?(i) or marked_columns.include?(j) \n  end \nend \np marked_rows \np marked_columns \np matrix \n=begin \nmarked_row : [1, 2] \nmarked_column : [2, 3, 1] \nmatrix : [[1, 0, 0, 0], \n               [0, 0, 0, 0], \n               [0, 0, 0, 0], \n               [3, 0, 0, 0]] \n=end"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The below implementation does it with O(n) time and O(n) space complexity. Algorithm is in comments."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The algorithm uses the fist row with the zero found in it (if it is one) as a temporary storage to mark rows, that need to be zeroed in the future.  This is completely in memory solution, which doesn't require any additional dynamic allocation."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class PlaceZero{ \n int x; \n int y; \n public PlaceZero(int i,int j){ \n  this.x=i; \n  this.y=j; \n } \n} \n \n \npublic int[][] checkAndSetZero(int[][] arr) { \n  ArrayList p = new ArrayList(); \n  int n = arr.length; \n  // find zeros in matrix \n  for (int i = 0; i < n; i++) { \n   for (int j = 0; j < n; j++) { \n    if (arr[i][j] == 0) { \n     PlaceZero z = new PlaceZero(i, j); \n     p.add(z); \n    } \n   } \n  } \n  for (int k = 0; k < p.size(); k++) { \n   int l=p.get(k).x; \n   int m=p.get(k).y; \n   for (int i = 0; i < n; i++) { \n    arr[l][i]=0; \n    arr[i][m]=0; \n   } \n  } \n  return arr; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package org.avnish.javabrain;  public class SetArrayToZero {   /**   * @param args   */  public static void main(String[] args) {   int n = 4;   int a[][]={{1, 1, 3, 1}, {5, 9, 7, 8}, {1, 0, 3, 4}, {3, 2, 5, 9}};   printArray(a,n);   a=setToZero(a,n);   printArray(a,n);     }    public static void printArray(int a[][], int size){   for(int i=0;i   for(int j=0;j    System.out.print(a[i][j] + \" \");    }    System.out.println(\"\");   }   System.out.println(\"\\n\");  }    public static int[][] setToZero(int[][] a, int size){   int[] zeroArrayRow = new int[size];   int[] zeroArrayCol = new int[size];   for(int k=0;k   for(int i=0;i<=k;i++){     if(a[i][k]==0){      zeroArrayRow[i] = 1;      zeroArrayCol[k] = 1;      }     if(a[k][i]==0){      zeroArrayCol[i] = 1;      zeroArrayRow[k] = 1;      }    }   }    for(int i=0;i   if(zeroArrayRow[i]==1){     a=zeroRow(a,i, size);    }    if(zeroArrayCol[i]==1){     a=zeroCol(a, i, size);    }   }   return a;  }    public static int[][] zeroRow(int[][] a, int r, int size){   for(int i=0;i   a[r][i]=0;   }     return a;  }   public static int[][] zeroCol(int[][] a, int c, int size){   for(int i=0;i   a[i][c]=0;   }     return a;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \"stdafx.h\" \n#include  \n#include  \nusing namespace std; \n \nint _tmain(int argc, _TCHAR* argv []) \n{ \n int n = 0; \n int testCase[9][9] = { { 1, 2, 3, 4, 5, 6, 7, 8, 9 }, \n       { 1, 2, 3, 4, 5, 6, 7, 0, 9 }, \n       { 1, 2, 3, 4, 5, 6, 7, 8, 9 }, \n       { 1, 2, 3, 4, 5, 6, 7, 8, 9 }, \n       { 1, 2, 3, 4, 5, 6, 7, 8, 9 }, \n       { 1, 2, 3, 0, 5, 6, 7, 8, 9 }, \n       { 1, 2, 3, 4, 5, 6, 7, 8, 9 }, \n       { 1, 2, 3, 4, 5, 6, 7, 8, 9 }, \n       { 1, 2, 3, 4, 5, 6, 7, 8, 9 }, }; \n bool col[9] = { false, false, false, false, false, false, false, false, false }; \n bool row[9] = { false, false, false, false, false, false, false, false, false }; \n for (int i = 0; i < 9; i++) \n { \n  for (int j = 0; j < 9; j++) \n  { \n   if (testCase[i][j] == 0) \n   { \n    col[i] = true; \n    row[j] = true; \n    break; \n   } \n  } \n } \n for (int i = 0; i < 9; i++) \n { \n  for (int j = 0; j < 9; j++) \n  { \n   if (col[i] || row[j]) \n   { \n    cout << 0 << \" \"; \n   } \n   else \n   { \n    cout << testCase[i][j] << \" \"; \n   } \n  } \n  cout << endl; \n } \n system(\"pause\"); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \"stdafx.h\" \n#include  \n#include  \nusing namespace std; \n \nint _tmain(int argc, _TCHAR* argv []) \n{ \n int n = 0; \n int testCase[9][9] = { { 1, 2, 3, 4, 5, 6, 7, 8, 9 }, \n       { 1, 2, 3, 4, 5, 6, 7, 0, 9 }, \n       { 1, 2, 3, 4, 5, 6, 7, 8, 9 }, \n       { 1, 2, 3, 4, 5, 6, 7, 8, 9 }, \n       { 1, 2, 3, 4, 5, 6, 7, 8, 9 }, \n       { 1, 2, 3, 0, 5, 6, 7, 8, 9 }, \n       { 1, 2, 3, 4, 5, 6, 7, 8, 9 }, \n       { 1, 2, 3, 4, 5, 6, 7, 8, 9 }, \n       { 1, 2, 3, 4, 5, 6, 7, 8, 9 }, }; \n bool col[9] = { false, false, false, false, false, false, false, false, false }; \n bool row[9] = { false, false, false, false, false, false, false, false, false }; \n for (int i = 0; i < 9; i++) \n { \n  for (int j = 0; j < 9; j++) \n  { \n   if (testCase[i][j] == 0) \n   { \n    col[i] = true; \n    row[j] = true; \n    break; \n   } \n  } \n } \n for (int i = 0; i < 9; i++) \n { \n  for (int j = 0; j < 9; j++) \n  { \n   if (col[i] || row[j]) \n   { \n    cout << 0 << \" \"; \n   } \n   else \n   { \n    cout << testCase[i][j] << \" \"; \n   } \n  } \n  cout << endl; \n } \n system(\"pause\"); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \nvoid zero(int* array , int n) \n{ \n#define array(i,j) array[i*n+j] \n \n int *row = (int*) malloc (n * sizeof(int)); \n for(int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for(i=0;i{  for(j=0;j {   if(a[i][j]==0)   {    for(k=0;k   {     a[k][j]=0;     a[i][k]=0;    }   }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for(i=0;i{  for(j=0;j {   if(a[i][j]==0)   {    for(k=0;k   {     a[k][j]=0;     a[i][k]=0;    }   }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for(i=0;i{  for(j=0;j {   if(a[i][j]==0)   {    for(k=0;k   {     a[k][j]=0;     a[i][k]=0;    }   }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"similar to ctci solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"@Paul: you could have used this logic instead of zeroRowAndMarkColumn funtion.  for(int i = 0; i < rowSize; i++)  {  for(int j=0; j < colSize; j++)  if(Matrix[i][j] == 0)  {  rowMask |= 1 << i;  colMast |= 1 << j;  }  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4511415394107392","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"24","title":"Write a function that takes an unsorted array of integers as a paramater and returns the array without duplications. (Order of returned array doesn't matter as long as ONLY one of each integer in the original array is present).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"We can store the array in a HashSet and then covert back the HashSet in array. This will remove the duplicate elements. please Correct me if I am wrong."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"1. Sort the input array. 2. Traverse the sorted array and fill the result array without duplicates.  void GetSortedArray(int* pArr, int n, int* & pResultArr, int& nrElems) {      if (pArr == Null || n <= 0)        return NULL;       qSort(pArr, n);        vector result;       for (int i = 0; i < n -1; i++)       {             if (pArr[i] != pArr[i+1])               result.push_back(pArr[i]);       }       result.push_back(pArr[i]);       nrElems = result.Count();       pResultArr = new int[nrElems];       Copy(result, pResultArr); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think sorting is a little overkill, because we do not need these elements to be sorted at all. Couple of possible options: 1. Hash table 1. Using the idea from Set. Insert these elements into binary search tree. During insertion, all the duplicated elements will be filtered out."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def solve(input): \n  dict = {} \n  i = 0 \n  res = []  \n  while i < len(input): \n    if input[i] not in dict: \n      res.append(input[i]) \n      dict[input[i]]=''     \n    i += 1 \n    pass \n  return res  \n \nif __name__ == '__main__': \n  input = [1, 2, 2, 3, 3, 4] \n  print \"Input : \", input \n  print \"result : \", solve(input) \n  pass"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.*; class duplicate { public int[] removeDuplicate(int []ar) { HashSet hs=new HashSet();//it will not allow duplicates to enter int i,j=0; int []newArray=new int[ar.length];//initialize new array of same length of given array for(i=0;i{ hs.add(ar[i]); } Iterator ir=hs.iterator(); while(ir.hasNext()) { newArray[j]=Integer.parseInt(ir.next().toString()); j++; } return newArray; } public static void main(String args[]) { duplicate d=new duplicate(); int []a={20,10,12,10,15,10}; int []b=d.removeDuplicate(a); for(int i=0;i{ System.out.println(b[i]); } } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use Hashtable :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Try this in java:  int [] array=new int []{1,14,9,2,7,15,6,3,4,11,8,5,14,7,6,7,8,3,9,2,13,11,12};  List myList = new ArrayList ();  for (int i=0; i{     if (!myList.contains(array[i]))  myList.add(array[i]); }    Collections.sort(myList);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def unique(): \n   return list(set([int(i) for i in raw_input().split()]))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simplest solution would be to maintain a counter for every number as you proceed through an array. For eg= Array A = [1,2,3,3,3,4,5] , Counter[1] = 1, counter[2] = 1 counter [3] =1, then when a pointer comes to 3 again, it will not add that element into a result array as counter[3] is already one. This will take O(n) time. The solution is best suited when space constraints are not given."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Make a new empty array, loop the input array for each element. Take the first element and save to the new array; take the second one and compare if it's same as all elements in the new array before you save it onto. Continue this process until reaches the end of the input array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  #include  #include  #include  //method one:use map, since no hashmap, we can use stl c++ map implemented by rb tree. typedef std::map Map; int removeDup(int * a, int length){         if (!a ||length <=1) return length;         std::cout<<\"Not null\"<        Map m;         Map::iterator it;         int index = 0;         for (int i = 0;i                it = m.find(a[i]);                 if (it == m.end()){                         m[a[i]]=true;                         //std::cout<<\"Not dup \"<<                                if (index  != i){                                 a[index] = a[i];                         }                         index++;                 }         }         std::cout<<        return index; }  Note:c++ has no hashmap, so here I use the stl map which is implemented by RB tree. If the number of elements are not quite large, look up and insertion can be considered as constant. However, one can implement his own hashmap to do this. The time complexity is O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use a modified merge sort. modification: when merge, if the values are equal don't merge one of them.   time complexity: O(nlogn) space complexity: O(n)  Or you can modify a heap sort algorithm which has space complexity of O(1)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// Build Binary Search tree by reading each element and add only unique element-  \n// now readback each element in inorder traversal to return back  \n// O(nlogn) Time and O(n + n) space complexity \n// wrote on notedpad hence no compile error checking performed... \n \npublic int[] GetUniqeRecord(int[] arr) \n{ \n if(arr == null) return null; \n if(arr.Length == 1) return arr; \n \n // Build Binary search tree \n int count; \n Node root = CreateBinaryTree(arr,out count); \n  \n return uniqueRecord(root); \n  \n // Readh binary search tree \n \n} \n \npublic class Node \n{ \n public int data{get;set;} \n public Node left{get;set;} \n public Node right{get;set;} \n public Node(int data) \n { \n  this.data = data; \n } \n} \n \npublc int[] uniqueRecord(Node root,int count) \n{ \n Stack s = new Stack(); \n int[] arr = new int[count]; \n Node n = root; \n s.Push(n); \n int i=0; \n while(!s.IsEmpty() || n!= null) \n { \n  if(n != null) \n  {    \n   s.push(n); \n   arr[i++] = n.data; \n   n = n.left;    \n  } \n  else \n  { \n   n= s.Pop(); \n   n = n.right;  \n  } \n } \n \n return arr; \n} \n \npublic Node CreateBinaryTree(int[] arr,ref int cout) \n{ \n \n Node root = null; \n   \n root = new Node(arr[0]); \n Node temp = null; \n node pre; \n bool duplicate = false; \n for(int i=1;i temp.data) \n   { \n    temp = temp.right; \n   } \n   else if(arr[i] < temp.data) \n   { \n    temp = temp.left; \n   } \n   else \n   { \n    duplicate = true; \n    break;  \n   }    \n  }   \n   \n \n  if(!duplicatae) \n  { \n   if(arr[i] > pre.data) \n    pre.right = new Node(arr[i]); \n   else \n    pre.left = new Node(arr[i]); \n   count++; \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The one way is to maintain a dictionary. HashMap"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"used HashSet and an additional array, the space complexity is not O(n). Not efficient solution. Please suggest how can I improve it."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5917873302142976","download_status":"DOWNLOAD_DONE","votes":"4","answersCount":"27","title":"A link list contains following elements","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"25","title":"1. copy the 1st node and insert it between node 1 & node 2  3. Similarly,  copy 2nd node and insert it between 2 & 3.. and so on 2) Copy the arbitrary link in this fashion      Originalnode->next->arbitrary = Originalnode->arbitrary->next;        and so on...for all nodes 3) Separate the original and copy linked lists."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"sd's method is very innovative but will require extra space in the old list (adding nodes in the list). Here is an alternate method which does not use extra space in the old list:  1. Duplicate the list, change newnode->random to point to node->next, change node->next to point to newnode. e.g.:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The solution from sd should work fine and it is very creative. Another solution can be,  1. It will create a duplicate linked list.  But ->next of the original list will point equivalent  node in the new linkedlist.  node* pOld = head; node* pNew = Null; node* pNewTail = Null; while (pOld) {   if (pNewTail == null)   { pNew=pNewTail = new node; pNew->val = pOld->val; }   else   {     pNewTail->next = new node;     pNewTail->next->val = pOld->val;     pNewTail =  pNewTail->next;   }   node* pCurrent = pOld;   pOld = pOld->next;   pCurrent = pNewTail; }  2.  Then update random pointer of the new linkedlist  node* pOld = head; while (pOld) { pNew->random = pOld->random->next;  pNew = pNew->next; pOld = pOld->next; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node *temp=head; create_list(node *temp){  node *n; n=new node;  if(temp->next!=NULL){  create_list(temp->next); } n->next=temp->next; n->rand=temp->rand;   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Iterate over the linkedList and create a copy of each node with following changes: if we make n' as duplicate of node n: 1. n'.random=n.random 2. n.random=n'  Now we iterate over the lists one more time and for every node-duplicate pair: 1. temp=n'.random 2. n'.random=temp.random 3. n.random=temp  This works in O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sd's code traverses the list multiple times - to insert and to separate the lists. Is the time complexity still O(N). If so, can someone please elaborate?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I am not sure i got the what this question is asking for entirely. why can not one copy the linked list based on the next pointer first and fix up the random node pointer after the linked list is copied."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6751316000899072","download_status":"DOWNLOAD_DONE","votes":"-2","answersCount":"7","title":"Write a thread safe data structure such that there could be only one writer at a time but there could be n readers reading the data. You can consider that incrementing or decrementing a variable is an atomic operation. If more than one threads try to write simultaneously then just select one randomly and let others wait","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This question is basically asking to implement a read-write lock.  class rwRam { private:    unsigned rcount;    unsigned wcount;    void *opaque; // the payload/data. public:    rwRam(void *o): rcount(0), wcount(0), opaque(o) {}        void init_read();    void fini_read();    void init_write();    void fini_write(); } rwRam;  void rwRam::init_read() {     /// indicate there is read pending.     rcount ++;     /// wait till there is no writer.     while(!wcount); }  void rwRam::fini_read() {    rcount --; }  void rwRam::init_write() {  /// need to make sure no reader and no writer. while(wcount); wcount ++; /// this needs to be a atomic, i.e. done with cmp_xchg on x86.  /// wait for all readers to finish. while(rcount); }  void rwRam::fini_write() {    wcount --; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Class ReadWriteLock \n{ \n  private int Read; \n  private int Write; \n  private static Object _S= new Object(); \n  public void ReadWriteLock() \n { \n    Write=0; \n    Read=0; \n } \n public void GetReadLock() \n { \n    while(Write); \n     Interlocked.Increment(ref Read); \n } \n \n public void ReleaseReadLock() \n { \n     \n     Interlocked.Decrement(ref Read); \n } \n \n \n public void GetWriteLock() \n { \n    while(Read); \n   if(Read==0) \n     { \n      lock(_S) \n      { \n           if(Read==0) \n          { \n            Interlocked.Increment(ref Write); \n          } \n      } \n     } \n  } \n} \n public void ReleaseWriteLock() \n { \n     Interlocked.Decrement(ref Write); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Example of threaded read and write.  I have a code where thread pool periodically updates a value and 2 separate threads periodically read the current value."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"That's just some fast code from my mind, but I am not sure that's correct. Test that thing is really difficult."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Are java locks such as ReadLock and WriteLock Are allowed? If yes os it's quite simple task."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"rwRam(void *o): rcount(0), wcount(0), opaque(o) {}   void init_read();  void fini_read();  void init_write();  void fini_write();  } rwRam;      please explain me this code above..."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5744412457959424","download_status":"DOWNLOAD_DONE","votes":"3","answersCount":"21","title":"input -  2D array of characters and a text pattern. program to find if pattern is present in array or not. a cell can't be used twice for pattern matching. return 1 if true or 0 otherwise.   eg :   Matrix  {'a','b','c','r','d'},  {'e','f','o','g','h'},  {'i','o','j','k','i'},  {'w','g','f','m','n'},  {'z','a','s','i', 't'}   and search for \"microsoft\"","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"We can use a hash to keep the count of each character and decrement the count whenever we use the letter. O(n) time and O(n) space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"public class FindPatternInGivenArrayOfChars { \n \n    \n    private boolean findPattern(char[][] array, char[] pattern) \n    { \n        \n        for(int i=0; i< array.length; i++) \n            for(int j =0; j"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Just another c++ implementation where each cell is visited only once. Cheers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public class FindPattern { \n HashMap dictionary = new HashMap(); \n String answer; \n public boolean makeHash(char[][] matrix, String s){ \n  answer = s; \n  for(char[] x : matrix){ \n   for(char y : x){ \n    if(dictionary.containsKey(y)){ \n     dictionary.put(y,dictionary.get(y)+1); \n     } \n    else dictionary.put(y,new Integer(1)); \n   } \n  } \n  return verify(); \n } \n  \n private boolean verify(){ \n  for(char x : answer.toCharArray()){ \n   if(dictionary.get(x) > 0) \n    dictionary.put(x, dictionary.get(x) - 1); \n   else return false; \n  } \n  return true; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Create array of 128 size. set the index with character of 2D array. then search the pattern in array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool exist(vector > &board, string s){  for(int i = 0; i < board.size(); ++i){   for(int j = 0; j < board[0].size() ; ++j){    if(board[i][j] == s[0]){     if(existHelper(board, s, 1, i, j)) return true;    }   }  }  return false; }  bool existHelper(vector > &board, string s, int index, int i , int j ){  if(index == s.size()) return true;   if(i > 0 && board[i - 1][j] == s[index]){   char temp = board[i][j];   board[i][j] = '#';   if(existHelper(board, s, index + 1, i - 1, j)) return true;   board[i][j] = temp;  }   if(i < board.size() - 1 && board[i + 1][j] == s[index]){   char temp = board[i][j];   board[i][j] = '#';   if(existHelper(board, s, index + 1, i +1, j)) return true;   board[i][j] = temp;  }   if(j> 0 && board[i][j - 1] == s[index]){   char temp = board[i][j];   board[i][j] = '#';   if(existHelper(board, s, index + 1, i , j - 1)) return true;   board[i][j] = temp;  }   if(j < s.size() - 1 && board[i][j+1] == s[index]){   char temp = board[i][j];   board[i][j] = '#';   if(existHelper(board, s, index + 1, i, j + 1)) return true;   board[i][j] = temp;  }   return false; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nmain() \n{ \n      char str3[30],str2[20]=\"microsoft\"; \n      int i,j,p=0,k=0; \n      char *q; \n      q=&str2[0]; \n      char str1[20][20]={{'a','b','c','r','d'}, \n                         {'e','f','o','g','h'}, \n                         {'i','o','j','k','i'}, \n                         {'w','g','f','m','n'}, \n                         {'z','a','s','i','t'} \n                         }; \n       for(i=0;i<5;i++) \n       for(j=0;j<5;j++)  \n       {str3[k]=str1[i][j];k++;}  \n                         \n      for(k=0;k"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My searching algorithm was of order o(n^3) i searchd for each letter of string 'microsoft' in 2-D string and wherever i found that charachter i replaced it with '1' and incremented the loop for the string to find next letter. then i counted the number of '1' in the 2-D String if it equals the length of 'microsoft' this means string found else not found...fortunately my algorithm worked in c++"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"would it be wise to compare for each letter in matrix with ''microsoft\" and if found then count can be incremented..if count==strlen(),..then pattern found..order O(n).."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming that string is mutable - we can modify a string on the go, then we can simply do the following:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How is the pattern expected in the array. Should \"Microsoft\" exist contiguous or just scattered letters."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There is very simple code. O(n^2+m) without hash, just a little fixed buffer."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5799446021406720","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"10","title":"Given below is a tree/trie  A      B  c  D      e     F a<>>c<>d<>>> above string represents the following trie/tree (visualize) and assume that there exisits a serialize method that performs above. Now, write a deserialize method so that above string to an object model of the following TreeNode TreeNode[] children","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"int pos = 0; \nTreeNode* deserialize(const string& s) { \n  if (s.empty()) \n    return null; \n  char val = s[pos++]; \n  Node* root = new TreeNode(val); \n  assert(s[pos] == ??<??); \n  pos++; \n  while (s[pos] != ??>??) { \n    root.appendChild(deserialize(s)); \n  } \n  assert(s[pos] == ??>??); \n  pos++; \n  return root; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"C code, but assumes that there can be atmax 3 children of a node -  typedef struct node {  char data;  struct node **list; }node;  node ** deserialize_tree(char * str, int *j){  if(str[*j] != '\\0'){   if(str[*j] == '<' ){    (*j)++;    struct node **arr = (struct node **)malloc(sizeof(struct node *)*3);    int i = 0;    while(str[*j] != '>'){     struct node * temp = (struct node *)malloc(sizeof(struct node ));     temp->data = str[*j];     (*j)++;     temp->list = deserialize_tree(str, j);     arr[i] = temp;     i++;    }    (*j)++;    return arr;    }  }  return null; }  void print_ntree(node * temp){  if(temp){   printf(\"%c \", temp->data);   printf(\"children \");   node **list = temp->list;   int i =0;   while(list && i < 3){    print_ntree(list[i]);    i++;   }   printf(\"\\n\");  } }  void deserialize_tree_util(){  char * str = \"a<>>c<>d<>>>\";  struct node * temp = (struct node *)malloc(sizeof(struct node ));  temp->data = str[0];  int j = 1;  temp->list = deserialize_tree(str, &j);   print_ntree(temp); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Create a stack. Whenever a character is encountered which is followed by '<', create a new node as a child of the topmost element in the stack and insert the new node on the stack. Pop out the topmost node from the stack each time '>' is encountered.  I assume that e is child of b and f is child of d. If e is child of both b and a, then instead of stack, we can use array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please read like this. apologies for this ugly formatting by me. I could not properly structure it.  A(Root) B(A's child)     C (A's child) D(A's child) E(A & B's child)   F (A & D's child)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Did not test."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package mirco; \n \nimport java.util.ArrayList; \nimport java.util.List; \n \npublic class ParseStringToTree { \n \n static String input = \"a<>>c<>d<>>>\"; \n \n public static void main(String[] args) { \n \n  TreeNode head = null; \n  TreeNode current = null; \n  TreeNode parent = null; \n  for (Character c : input.toCharArray()) { \n \n   switch (c) { \n   case '<': \n    parent = current; \n    break; \n   case '>': \n    current = current.parent; \n    break; \n   default: \n    TreeNode child = new TreeNode(c, new ArrayList()); \n    child.parent = current; \n    if(null!=current){ \n     current.nexts.add(child); \n    } else{ \n     head = child; \n    } \n    current = child; \n   } \n \n  } \n   \n  System.out.println(\"head = \" + head); \n \n } \n \n static class TreeNode { \n \n  public char value; \n  public List nexts; \n  public TreeNode parent; \n \n  TreeNode(char value, List nexts) { \n   this.value = value; \n   this.nexts = nexts; \n  } \n \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my solution in JAVA. It's tested."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6130581557477376","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"30","title":"Given a n by m matrix of bits find the largest X that is formed in the matrix and return the size of the diagonal of that X. An X is defined as 2 equally sized diagonals that share a single 1.  For instance, the matrix:  00100001 00010010 00001100 00001100 00010010 00100001  Will return a size of 1, because the given X is invalid as the middle part does not share a single 1. On the other hand, the following matrix  101 010 101  Will return a value of 3, as the diagonal is 3. Write such program,","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"10","title":"At every cell, there are two diagonals that pass through this cell, one going from top-left corner of the matrix to bottom-right corner and the other going from  top-right to bottom-left corner. The idea is to keep a matrix of the same size as the input matrix, each entry represents the the number of consecutive ones in the diagonal going from top-left to bottom-right corner such that the sequence of ones starts at the top left of current cell and ends at the current cell, similarly we keep 3 other matrices, one for sequences of ones in the diagonal going from top-left to bottom-right but starting at a cell that is at the bottom right of the current cell. The other 2 matrices are kept from the other diagonal going from top-right to bottom-left corner. for example, consider the matrix: 0 1 1 1 0 0 0  0 1 0 0 0 0 0  0 1 1 0 1 0 1  1 0 0 1 1 1 0  1 0 1 1 0 1 0  1 1 1 1 1 0 1   top-left matrix keeping counts of ones starting at top left and ending at each cell: 0 1 1 1 0 0 0  0 1 0 0 0 0 0  0 1 2 0 1 0 1  1 0 0 3 1 2 0  1 0 1 1 0 2 0  1 2 1 2 2 0 3   bottom-left 0 1 2 1 0 0 0  0 1 0 0 0 0 0  0 2 1 0 4 0 2  1 0 0 3 3 1 0  1 0 2 2 0 2 0  1 1 1 1 1 0 1   top-right 0 1 1 1 0 0 0  0 2 0 0 0 0 0  0 1 1 0 1 0 1  2 0 0 2 1 2 0  1 0 3 2 0 1 0  1 4 3 1 2 0 1   bottom-right 0 1 1 1 0 0 0  0 3 0 0 0 0 0  0 1 2 0 2 0 1  1 0 0 1 3 1 0  2 0 2 2 0 2 0  1 1 1 1 1 0 1    and then at each cell[i,j] in the original matrix, get length of sequences  of ones ending at the 4 neighboring diagonal cells from the matrices computed above, namely [i-1, j-1], [i-1, j+1], [i+1, j-1], [i+1, j+1], compute \"minValue\" which is the minimum of these values. size of an X with center at the current cell is 2*minValue+1. time complexity O(n*m), space Complexity O(n*m)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"As I see it, this question is really about your attention to detail in relation to the question asked and the requirements.  Here are the key points:  1.  Bits:  only 1's or 0's will be allowed. 2.  Equally sized diagonals:  they must be the exact same length (see assumption below to see why this is critical) 3.  Share a common mid-point:  the middle 1 must be present in both diagonals.  We can get some good operational savings by applying these parameters.  First off, we are scanning for diagonals that share a common mid-point, so we need not scan the first or last row nor column as they can't be a mid-point.  This gets us some major performance gains on smaller matrices (N < 5 or M < 5) as it limits the possible mid-points substantially, which will reduce the number of 'check for diagonal' scans that must be done.  Secondly, the output of this operation is an integer value of the longest diagonal, so there is no need to store the length of all diagonals or use any type of dynamic programming methodology (if we wanted the locations of the longest diagonal then we would).  We merely need to find all of the X's as defined above, measure the length of the diagonals, and keep a running tracker of the max length to return at the end, knowing that a return of 0 means  there is not an X present.  In this sense, our algorithm will actually be in-place, or O(1) as we only use a small number of additional constant variables to track our progress.  One last assumption I will make is that unequal lengths will disqualify an X, even in this case: 1 0 1 0 0 1 0 0   1 0 1 0 0 0 0 1  Now with a clear operational definition, we can proceed with our pseudo:  1.  Scan through each matrix entry starting with 1,1 (not 0,0) and ending at n-1,m-1 (not n,m) so that we only scan entries that can be a mid-point. 2.  If we encounter a 1, check for diagonals via a quick if to see if the 4 diags contain a 1.  If any of them contain 0's, return to step 1 and continue.  Otherwise proceed with:     2a.  traverse each directional diagonal (up-right, up-left, down-right, down-left) till you find a 0 or edge, count it's value (without the mid-point)   2b.  Add together the opposite diags (up-right + down-left and up-left + down-right), add 1 to account for the mid-point and compare sizes   2c.  If sizes are the same, compare to maxDiag variable, else go back to step 1   2d.  If it's larger, update maxDiag to equal this diagonal length, otherwise leave it at current value 3.  Once all entries are scanned, return maxDiag.  Our running time is between O( (nm)^2) and O(nm) because while our primary loop only touches each entry once (excluding the outer edge), there is the possibility to scan each node multiple times depending on the number of diagonals present in the matrix.  However, given the constraints, I believe a safe upper notation would be O((nm)^2), knowing that across random distribution of matrices we will get better performance, particularly on smaller matrices due to our \"exempt outer edge\" scan.  [I hope to come back and edit this with a live code example once I get a chance to write one up]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's one approach:  Traverse the whole matrix and store all diagonals according to size. If the array size is (n, m), then the diagonal size can range from 1 to min(n, m)  Make two arrays of vectors which will store the two kinds of diagonals.  For example, something like(some kind of pseudo-code):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since the diagonals may share only a single '1', you want to scan the matrix in one direction, looking for, in each row (or column), all pairs of 1's that are separated by an odd number of 0's or 1's only.  You would then look for a chain of these pairs where the interval of separation descends to a 'singularity' (the single '1' at the center) and then ascends back to the original interval of separation."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"an O(n^3) algorithm. we can use a function to calculate the longest X fron each i , j in the matrix. for each cell = 1 in the matrix, find the long X. return the longest X from all the cells in the matrix.  int longX(int a[n][m], int n, int m, int i, int j){ {    int k = 1;} {    while (1){} {        if (i+k > n || j+k > m || i-k < 0 || j-k < 0)} {           return k;} {       if (a[i+k][j+k] != 1 || a[i-k][j+k] != 1 || a[i-k][j+k] != 1 || a[i-k][j-k] != 1)} {            return k;} {        k++;} {    }} }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the question needs some clarification on the definition of an X. Do the lines have to cross at mid-points? For example, do two lines that are orthogonal to each other but form a \"T\" count as an X or not? According to your definition, it does, but logically it should not.  Either way, we need to start at one corner and iterate through all elements in the matrix in a sequential way. For each \"1\", assume it is the crossing point of the \"X\": - check the length of the longest line that crosses that point - do we have a line that is perpendicular to the initial line. If yes, calculate its length and return the minimum of the two, else return 1.  This will yield a O(n^3) solution. Sounds bad but in this case, I think this is the best available solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I wonder if we could do a depth first search on the matrix from top of matrix to bottom and then in the reverse direction. We store the top to bottom: (right, left) diagonal length values  and the bottom to top: (left, right) diagonal length values originating from each cell. Then we traverse these ~nm values to find the cell whose pair of values from above are the same."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include void main() {clrscr(); int a[5][4],i,j,k,l,count=0; cout<<\"entr the array\"; for(i=0;i<5;i++) {for(j=0;j<4;j++) cin>>a[i][j]; } for(i=0;i<4;i++) { for(j=0;j<3;j++) { k=l=0; if(a[i][j]==1) {while(++k) { if(a[i+k][j+k]==0 || (i+k)>=5 || (j+k)>=4) {k--; break; } } } if(a[i][j+k]==1) { while(++l) { if(a[i+l][j+k-l]==0 || (i+k)>=5 || (j+k)>=4) {l--; break; } } } if(k>=l && l>=count) count=l+1; if(l>=k && k>=count) count=k+1; if(count>(4-count-j)) break; } if(count>(5-count-i)) break; } if(count==1) count=0; cout<getch(); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void FindLargestX() \n{ \n int i,j,k,p,max=-1,flag,q,r; \n int I=-1,J=-1; \n int start=-1; \n int end=-1; \n for(i=0;i=j;p--) \n      { \n       if(a[r][p]!=1) \n       { \n        flag=0; \n        break; \n       } \n       r++; \n      } \n     } \n     if(flag==1) \n     { \n      if(q>max) \n      { \n       max=q; \n       I=i; \n       J=j; \n      } \n     } \n    }    \n   } \n  } \n } \n \n if(I!=-1 && J!=-1) \n { \n  for(i=I;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Amr Gamals solution has an optimal asymtotic time complexity. Do you see how to revise the algorithm so that the time complexity is O(nxm/k) on a k-processor machine?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int find(int a[5][5]) {     int m=5, n =5;     int count = 0;     int xpos, ypos;     int ulx, urx, llx, lrx;     int uly, ury, lly, lry;      for(int i=0; i    {         for(int j=0; j             if(a[i][j]==1)             {   xpos =i;                 ypos = j;                 ulx = xpos -1; uly = ypos -1; urx = xpos+1; ury = ypos+1;                llx = xpos+1; lly = ypos-1; lrx = xpos-1; lry = ypos+1;                  while(a[ulx][uly] == 1 &&                       a[urx][ury] == 1 &&                       a[llx][lly] == 1 &&                       a[lrx][lry] == 1) {                     count += 2;                     ulx--; uly--; urx++; ury++; llx++; lly--; lrx--; lry++;                       }             }         } //cout<< } cout< } int main() { int a[][8]={ {0,0,1,0,0,0,0,1}, {0,0,0,1,0,0,1,0}, {0,0,0,0,1,1,0,0}, {0,0,0,0,1,1,0,0}, {0,0,0,1,0,0,1,0}, {0,0,1,0,0,0,0,0}};  int b[][5] = { {1,0,0,0,1}, {0,1,0,1,0}, {0,0,1,0,0}, {0,1,0,1,0}, {1,0,0,0,0} };  find(b);  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int find(int a[5][5]) \n{ \n    int m=5, n =5; \n    int count = 0; \n    int xpos, ypos; \n    int ulx, urx, llx, lrx; \n    int uly, ury, lly, lry; \n \n    for(int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why do we need such complex algo. It can be solved in O(n*m) .Here is the code."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int bigX(int [][] n){ \n  int max = 0; \n  for(int i = 0; i = 0 && ti + c< n.length && tj - c >= 0 && tj + c < n.length){ \n      if ( n[ti-c][tj-c] == 1 && n[ti-c][tj+c] == 1 && \n        n[ti+c][tj-c] == 1 && n[ti+c][tj+c] == 1 ) \n       c+=2; \n     } \n    } \n    if ( c > max ) \n     max = c; \n   } \n  } \n  return max; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"what is the meaning of \"equally sized diagonals\""}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4981467352399872","download_status":"DOWNLOAD_DONE","votes":"5","answersCount":"30","title":"What is the minimum representation in bits of two positions on an 8x8 chessboard?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"You can represent 2^n values with n bits.  However, you can represent 2^n + 2^(n-1) + 2^(n-2) + ... 1 = 2^(n+1) - 1  values with *atmost* n bits  So you can represent 2^11 - 1 = 2047 different values using just 10 bits.  Now here's the catch in the problem, as brennahan already mentioned - the order of the pieces doesn't matter. So there are 64C2 = 2016 possible ways to arrange two pieces on an 8x8 chessboard.  Therefore, it should definitely be possible to represent 2016 ways using 10 bits. In fact, you can represent 2016 values using all 5, 6, 7, 8, 9 and 10 bit sequences.  Here's one method:  Consider all possible relative positionings:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"One way of doing it with 11 bits is like the following: You use 6 bits to represent your first position, and you use 5 bits to represent your second. You first position is represented by a simple x,y bit scheme. The second position will be represented as follows: If 5 bits for the second position are passed in, make a x,y grid on the opposite half of the board and use the 5 bits to locate the second position. If 4 bits are passed in, do the same thing as previously but in the opposite quadrant on the same half of the first picked point. If 3 bits, use them to find it on the opposite eight on the same quadrant If 2 bits , on the opposite sixteenth of the same eight If 1, on the same thirtysecondth of the same sixteenth if no bits, the second position is right below/above the first one  So basically you exploit the fact that no 2 pieces can be in the same place and save a bit"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Let's consider how many ways there are to place two pieces on an 8x8 chessboard. The first piece can be placed in one of 64 locations. The second piece can be placed in any one of the 63 remaining locations. Then, assuming you don't care about the order of locations, every pair of locations (i, j) is equivalent to the pair (j, i), so to get the total number of different pairs of locations, we need to divide by 2.  We get 64 * 63 / 2 = 2016.  There is therefore no way to do this with 10 bits, since a 10-bit value can only have one of 2^10 = 1024 possible values. With only 10 bits, only 1024 of the 2016 possibilities could have a representation. All the claims in this thread that you can do it with 10 bits are groundless.  With 11 bits, you can represent 2048 values, which is sufficient. The algorithm for encoding two locations as an 11-bit value is relatively straightforward. Give each chess square a number from 1 to 64. Then represent a pair of locations as the smaller number followed by the larger number. Map an integer to each pair in order, like this: (1, 2) -> 0 (1, 3) -> 1 ...  (1, 64) -> 62 (2, 3) -> 63 (2, 4) -> 64 ... (2, 64) -> 124 (3, 4) -> 125 ... (63, 64) -> 2015  You can do some simple math to compute the mapping efficiently.  The locations then have a 1-to-1 correspondence with integers between 0 and 2015. 11 bits are necessary and sufficient to represent these."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"There are 4,032 total combinations for 2 different positions on a chessboard (=64*63(2 pieces can't occupy the same space assuming chess rules)) 2^12 would be 4096 so we would need 12 bits in order to cover all possibilities for the 2 positions.   In terms of determining the exact positions from the bit representation, you would need to set up a schema to translate(i.e. the first 6 bits determine where the first position is and the later 6 bits represent the second position is.)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"6 bits.. bcz.. on an 8x8 chess board... there can be 64 boxes... thus... in the worst case... we need atleast 6 bits.. to distinguish all d boxes dintinctly"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"lets see the possible number of combinations possible 8*8*8*8/2 = if positions mutually independent = 12 bits otherwise 8*8*(8*8-1)/2 = 2016 combinations total number of combinations possible with 3 bits=  0,1,00,01,10,11,000,001,010,011,100,101,110,111 2+2^2+2^3 = 14 = 2 (2^3-1) total combination with 10 bits= 2(2^10-1)= 2046 combinations.. i will update the answer with a logical division or some1 can work it out"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"combinations for one 8x8 grid = 64 we have two pieces to take into account = 64 *2 two pieces cannot occupy the same space = (64 * 2) - 1 how many bits we need = floor(Lg2((64*2) - 1) answer: 6"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I dont know where you all get those ideas...  An 8x8 chessboard with two pieces, where each position is represented as tuple (x,y) and the two pieces using two tuples as a set (since order does not matter), like {(x1,y1),(x2,y2)}... That is the basic mathematic abstraction of the input space. Now for the real question. We are to find the number of all possible, different tuple-sets, which is given by   256!/(254! 2!) - 256 = 32384  Minus 256 in the end, because thats the amount of tuple-sets, where both tuples are equal, a case that is not possible.  Now that makes 14 < log2(32384) <15, so we can conclude that we can save one bit, that is encode the whole thing with 15 bits instead of the obvious 16..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There are 64 squares and 32 pieces.  I take it, that 2 positions means the state of ALL of the white and black pieces at a given time or a \"snapshot\". To represent 2 positions: won't you need 32 longs (each with 64 bits), so that each long represents a chess piece and each bit (long has 64 bits) in that long represents the position on any one of the 64 squares."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You realize, with the way this question is asked, the answer of '2 bits' suffices. You are only asking bits to represent two positions out of 64 positions, not every possible combination of the 2 positions on the board..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"what do you thing about this solution: we can use 5 bits for the white squares and 5 bit for the black squares. then you have another bit to tell if you need to refer to a white or a black square i think even you can do this only with 6 bits: one bit is for the color and let say if color is white then you go to the 5 bit positions by starting at 00000 and if is black you start at 00001 then each loop you move two positions"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=24832663","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"12","title":"Find the majority element which occurs more than n/2 times in an array of n size, which contains duplicate elements in minimum time and space complexity.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Moore's voting algorithm, seems a pretty standard problem asked in the tech interviews."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"#include  \n \nint findmajelement(int arr[], int size) \n{ \n    int count = 1, i = 0, m_index= 0; \n for(i = 1; i < size; i++) \n { \n  if(arr[m_index] == arr[i]) \n   count++; \n  else \n   count--; \n  if( count == 0) \n  { \n   m_index = i; \n   count = 1; \n  } \n } \n return arr[m_index]; \n} \n \nvoid ismajelement(int arr[], int maj_elem, int size) \n{ \n int i = 0, count = 0; \n for(i = 0; i< size; i++) \n { \n  if(arr[i] == maj_elem) \n   count++; \n } \n printf(\"count = %d\\n\"); \n if(count > size/2) \n  printf(\"majority element = %d\\n\", maj_elem); \n else \n  printf(\"no majority element present\\n\"); \n} \n \nint main() \n{ \n int arr[6] = {2,4,2,2,4}; \n int majority_element  = 0; \n majority_element = findmajelement(arr, 6); \n ismajelement(arr, majority_element, 6); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using System; \nusing System.Collections.Generic; \nusing System.Linq; \nusing System.Text; \n \nnamespace Problem1 \n{ \n    class Program \n    { \n        static void Main(string[] args) \n        { \n            /* \n             * Find the majority element which occurs more than n/2 times in an array of n size,  \n             * which contains duplicate elements in minimum time and space complexity. \n             */ \n            int[] arr = { 2, 2, 2, 3, 4 }; \n \n            Dictionary dict = new Dictionary(); \n \n            int majItem = 0; \n            foreach (int item in arr) \n            { \n                if (dict.ContainsKey(arr[item])) \n                { \n                    dict[arr[item]] = ++dict[arr[item]]; \n \n                    if (dict[arr[item]] > (arr.Length / 2)) \n                    { \n                        majItem = item; \n                    } \n                } \n                else \n                { \n                    dict[arr[item]] = 1; \n                } \n            } \n \n            System.Console.WriteLine(majItem.ToString() + \" has occurred more than half the length of the array!\"); \n        } \n \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Sort the array 2. pick the n/2th element"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the array is an array of ints, why don't we just sort the array and iterate through the sorted array. This is pretty simple cuz in the sorted array, the same ints should all be right next to each other. This takes O(n) time and almost no space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \nint find(int *a ,int n) \n{    \n int target = a[0]; \n int num = 1; \n int i; \n for( i=1; i< n; i++) \n { \n  if(num == 0) \n  { \n   target = a[i]; \n   num++; \n  } \n  else if(target == a[i]) \n  { \n   num++; \n  } \n  else \n  { \n   num--; \n  } \n } \n \n return target; \n} \n \nint main() \n{ \n int a[5] = {0,1,2,1,1}; \n printf(\"%d\", find(a,5)); \n  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"candidate = 0 count = 0 for value in input:   if count == 0:     candidate = value   if candidate == value:     count +=1   else:     count -= 1"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=24819662","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"31","title":"C program to Delete a node from SLL, in which the last node points to the middle node( in case of even no of nodes, it points to the first middle node) and update the SLL.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"It would be a two step process.  1. In step 1, start two pointers, one moving ahead one node at a time and the other two nodes at a time. This lets us find out the middle and the last element. 2. In step 2, using 3-pointer mechanism that points to previous, current and next nodes, delete the given node. Handle the special case of adjusting the pointers if the deleted node is the middle node.(The middle and last-element pointers obtained in step 1 are used here) Otherwise fix, the pointers or previous, current and next nodes regularly along with fixing the pointer to the middle node from the last node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"**TO FIND THE LAST AND MIDDLE NODE**  1. use the fast and slow pointer to find a node in loop 2. count the number of nodes in the loop 3. if the count is k then ther are  two possibilities  1. there are k+(k-1) nodes in sll         2. there are 2k nodes in sll 4. with this find the middle and last node of the sll **DELETE THE GIVEN NODE**  now the delete the node, and point the last node to 1.      if length of sll is odd, to the previous node 2.      if even point to the  next node  correct me, if i am wrong"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"package oracle.prakash.investmentbank.test;  public class MicrosoftStack {     public MicrosoftStack() {         super();     }      public MicrosoftStack(T data) {         this.setData(data);     }      private MicrosoftStack next;     private MicrosoftStack prev;     private int count;     private MicrosoftStack mid;     private MicrosoftStack head;     private MicrosoftStack tail;     private T data;      public static void main(String[] args) {         MicrosoftStack microsoftStack = new MicrosoftStack();         int[] ints = { 20, 30, 40, 50, 60, 70, 80,90 };         for (int i : ints) {             microsoftStack.push(i);         }         microsoftStack.traverse();         System.out.println(\"---------------------------------------\");         System.out.println(microsoftStack.getHead().getData());         System.out.println(microsoftStack.getTail().getData());         System.out.println(microsoftStack.getMid().getData());         System.out.println(\"---------------------------------------\");         System.out.println(microsoftStack.pop());         System.out.println(microsoftStack.getHead().getData());         System.out.println(microsoftStack.getTail().getData());         System.out.println(microsoftStack.getMid().getData());         System.out.println(\"---------------------------------------\");         System.out.println(microsoftStack.pop());         System.out.println(microsoftStack.getHead().getData());         System.out.println(microsoftStack.getTail().getData());         System.out.println(microsoftStack.getMid().getData());         System.out.println(\"---------------------------------------\");         System.out.println(microsoftStack.pop());         System.out.println(microsoftStack.getHead().getData());         System.out.println(microsoftStack.getTail().getData());         System.out.println(microsoftStack.getMid().getData());         System.out.println(\"---------------------------------------\");         System.out.println(microsoftStack.pop());         System.out.println(\"---------------------------------------\");         System.out.println(microsoftStack.pop());         System.out.println(\"---------------------------------------\");         System.out.println(microsoftStack.pop());         System.out.println(\"---------------------------------------\");         System.out.println(microsoftStack.pop());         System.out.println(microsoftStack.getHead().getData());         System.out.println(microsoftStack.getTail().getData());         System.out.println(microsoftStack.getMid().getData());         System.out.println(\"---------------------------------------\");         System.out.println(microsoftStack.pop());         System.out.println(microsoftStack.getHead());         System.out.println(microsoftStack.getTail());         System.out.println(microsoftStack.getMid());     }      public void push(T data) {         MicrosoftStack item = new MicrosoftStack(data);         this.setCount(this.getCount() + 1);         if (this.getHead() == null) {             this.setHead(item);             this.setMid(item);             this.setTail(item);          } else {             item.setNext(this.getHead());             this.getHead().setPrev(item);             this.setHead(item);             if (this.getCount() % 2 != 0) {                 this.setMid(this.getMid().getPrev());             }             this.getTail().setNext(this.getMid());         }      }      public T pop() {         T data = null;         if (this.getHead() == null)             return null;         MicrosoftStack head = this.getHead();         data = head.getData();         this.setCount(this.getCount() - 1);         this.setHead(head.getNext());         head.setNext(null);         if (this.getCount() % 2 != 0) {             this.setMid(this.getMid().getNext());          }                  this.getTail().setNext(this.getMid());         if(this.getCount()==0) {             this.setHead(null);             this.setTail(null);             this.setMid(null);         }         return data;     }      public void traverse() {         MicrosoftStack head = this.getHead();         while (head != null) {             System.out.println(head.getData());             head = head.getNext();             if (head.getData().equals(this.getTail().getData())) {                 System.out.println(head.getData());                 break;             }         }     }      public void setNext(MicrosoftStack next) {         this.next = next;     }      public MicrosoftStack getNext() {         return next;     }      public void setPrev(MicrosoftStack prev) {         this.prev = prev;     }      public MicrosoftStack getPrev() {         return prev;     }      public void setCount(int count) {         this.count = count;     }      public int getCount() {         return count;     }      public void setMid(MicrosoftStack mid) {         this.mid = mid;     }      public MicrosoftStack getMid() {         return mid;     }      public void setHead(MicrosoftStack head) {         this.head = head;     }      public MicrosoftStack getHead() {         return head;     }      public void setTail(MicrosoftStack tail) {         this.tail = tail;     }      public MicrosoftStack getTail() {         return tail;     }      public void setData(T data) {         this.data = data;     }      public T getData() {         return data;     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"u dont need to traverse  twice..in the very first step, remove the node if you find it and rearrange it. u'll eventually end up pointing to the new last and middle."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi, I need a clarification from Saran.  Are we given access to only the node we need to delete and nothing else. What I mean here is in a SLL it is possible to delete a node with just the information of the node to be deleted and nothing else such as head , tail etc. Is such info available here Thanks"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I can think of two things here: 1. we have to maintain the property that last node is pointing to middle node, so when any node is deleted, change the last node pointer to one node in backward direction. 2. Delete the node and reset the pointers, for this we need to traverse the linked list and keep two pointers prevNode and currentNode. Once we find the node to be deleted then delete that node and reset the pointers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"find the middle element with slow and fast runner for a circularly linked list. find element that is before and after middle element. find lastElement by traversing until .next is the middle element for the second time. When deleting     if(even && element to be delete occurs before middle) {   middle = afterMiddle;  }  else if(odd && element to be delete occurs after middle) {   middle = beforeMiddle;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Let's split the question into two parts :  1. One is to delete any node in the linked list. 2. To make the last node of a linked list point to the middle element.  First delete the node in the linked list in O(n) time.  Next start from the head node using two pointers, slow and fast.  Slow moves one node at a time and fast moves two nodes at a time.  When fast reaches the end of the list, slow will be pointing to the middle element in the list. Make the last node point to slow and we're done."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"**TO FIND THE LAST AND MIDDLE NODE**   1. use the fast and slow pointer to find a node in loop  2. count the number of nodes in the loop  3. if the count is k then ther are two possibilities  1. there are k+(k-1) nodes in sll  2. there are 2k nodes in sll  4. with this find the middle and last node of the sll  **DELETE THE GIVEN NODE**  now the delete the node, and point the last node to  1. if length of sll is odd, to the previous node  2. if even point to the next node   comment if anything wrong."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First find the middle node in the list  Make count no of elements on left and right of middle node (Node_left, Node_right) (Node_left, Node_right) could be equal or Node_left = Node_right-1  Now when delete the random node in the list check if it is right or left of the middle node, and change this count  on the basis of this count you have to then move middle right or left if(Node_left < Node_right-1 ) move right else if(Node_right move left"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think here we can use 3 pointers  mid, mid_prev, mid_next move these pointers accordingly to get mid."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can take it with the cases:  Step 1: Try to find out the middle node and also the number of the nodes in the linked list whether they are even or odd.  How to: Start from Head (using fast and the slow pointers). if fast -> next == slow (Then the number of nodes would be odd). else if (fast->next->next == slow) then the number of nodes would be even. Now after this iteration we would be able to get the pointer to the middle element and also to the last element in the linked list.  Step 2: Remove the node:  How To: Go to the desired node. if the number of nodes are odd then after removal of the desired node the number of nodes would be even so the location of the middle element wont change.  In case there are odd nodes currently then the new middle node would be the node previous to the current middle node.  Note: Some special cases have to be taken care of. 1. If the desired node itself is the middle element. 2. If the desired node is the last element in the linked list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ListNode* delete(ListNode* head, int key) \n{ \n         if (head == NULL) return head; \n         ListNode* slow = head, fast = head->next, slowPrev = NULL; \n         while (fast->next != slow) \n         { \n              slow = slow->next; \n              fast = fast->next; \n              if (fast->next != slow ) fast = fast->next; \n         } \n          fast->next = NULL // change the last to new middle and now try to delete the element.  \n \n         ListNode* h = head, prev = NULL;  \n         while (h != NULL ) { \n                     if (h->val = key) {  \n                              if (h == new_middle) { \n                                      if (prev == NULL) { head = h->next; } \n                                      else { prev->next = h->next; last->next = h->next; } \n                                      break;      \n                              } \n                             if (h == last) { \n                                         prev->next = new_middle; \n                                         delete h; \n                             } \n                             else { prev->next = h->next; delete h; break; }  \n                               \n                     } \n                     else if (h == last) break;  \n                     else  { h = h->next; }  \n         } \n         return head;  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can we do it this way :-- (I m assuming that we know the number of nodes in the list. If not we can find it easily using cycle finding algo in the list.) 1. Simply delete the required node first as in SLL. 2. Now we know how many nodes remain in the list. Based on this restore the last node          pointer which is pointing to the middle node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can we do it this way :--  (I m assuming that we know the number of nodes in the list. If not we can find it easily using cycle finding algo in the list.)  1. Simply delete the required node first as in SLL.  2. Now we know how many nodes remain in the list. Based on this restore the last node pointer which is pointing to the middle node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The crux of this problem is how u traverse backward in single link list ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The crux of this problem is how u traverse backward in single link list"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i think thr will be several cases (after finding mid,end) 1 if node to be deleted is head :  see if its mid  2.if node to be deleted is end : change end ptr 3.if node to be deleted is mid : see if odd length(mid will change to prev  to mid) and if even length(mid will change to next to mid) 4.if node to be deleted is other : see if b4 mid(see if odd length then mid will change) else if after mid (see if even length then mid will not change)  tell if wrong line of thinking!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can be done as following:  1. use two pointers with x and 2x speed to find the mid node and whether the length of array is even or odd. 2. traverse the list for second time to find the node to delete, while tracking if it comes before mid or not. 3. if length is odd and element to delete is mid or before mid, set newMid to next of mid. If length is even and deleted element is mid or after mid set newMid to prev of mid. 4. delete the node. if newMid is not NULL, set the end of modified list to newMid."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why make it complicated; when most (if not all) of the solutions require you to scan the list twice why not just follow the normal LL deletion logic. 1) scan the list and delete target node 2) scan the list and make last node point to the middle node (can achieve this by using slow and fast pointers)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"void printList(){  lNode curr = head;  lNode mid = head;  lNode prev = null;  int count = 0;  while(curr!=null){   System.out.println(curr.value + \" \");   if(curr.next==null){    curr.next = mid;   }   if(count%2==0){    prev = curr;    curr=curr.next;   }   else{    prev=curr;    curr=curr.next;    mid = mid.next;    }   count++;     }  You can do normal delete function and when accessing the list, call this function."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"So isn't there a much simpler solution than looping through the list?  I believe so.  First let's utilize a list.size() function to return the size of the list.  That will help us find even/odd.  Now when a node is deleted from anywhere in the list, we find the middle element via:  if(list.size() %2 == 0) mid = list.size()/2 else mid = ciel(list.size()/2)  Note that the ciel function rounds up to the next largest int.  You could also allow it to divice, truncate the remainder, then simply add 1.  Either way, we now know our middle location based on the size of the list after deletion.  Now simply iterate through your list to that element (mid) and set the end node mid-pointer to that.  If our list has a built in pointer to the end, this becomes very easy as we do not need to loop through to find the end.  We do have to design for the edge case that occurs when we delete the end node though."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=24313662","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"14","title":"Convert a base 2 number to a base 4 number","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"Group each pair of binary bits gives base4.   example: base2: | 11  | 01 | 01 | 10 | base4: |  3 |  1 |  1 |  2 |"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"by multiplying bits by  1st bit by 1 2nd bit by 2 3rd bit by 10 4th by 20  5th by 100 then 200 1000......"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// Interview specific questions \n// Convert 2-base integer string to 4-base integer string \n// A: Use grouping, because 2, 4, 8, 16 are very GOOD numbers :-) \n// NOTE: \n//   1. No overflow detection; \n//   2. No invalid char/digit detection; \nstring Convert2_4(const string& s) \n{ \n    // Construct the map \n    map map24; \n    map24[\"0\"] = \"0\"; \n    map24[\"1\"] = \"1\"; \n    map24[\"00\"] = \"0\"; \n    map24[\"01\"] = \"1\"; \n    map24[\"10\"] = \"2\"; \n    map24[\"11\"] = \"3\"; \n \n    string r; \n \n    // Group two digits by two \n    int len = s.length(); \n    int start = 0; \n    if (len % 2) \n    { \n        r += map24[s.substr(0, 1)]; \n        start = 1; \n    } \n \n    for (int i = start; i < len; i += 2) \n    { \n        r += map24[s.substr(i, 2)]; \n    } \n \n    return r; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void Base2To4(byte[] base2) \n        { \n            int pos = base2.Length - 1; \n            int base4 = 0; \n            int positionPower = 10; \n \n            while (pos >= 0) \n            { \n                if (base2[pos] > 1) throw new InvalidOperationException(); \n \n                int value = base2[pos] == 0 ? 0 : 1; \n                if (pos > 0) \n                { \n                    if (base2[pos - 1] > 1) throw new InvalidOperationException(); \n                    value += base2[pos - 1] == 0 ? 0 : 2; \n                } \n                if (base4 == 0) \n                    base4 = value; \n                else \n                { \n                    base4 += value * positionPower; \n                    positionPower *= 10; \n                } \n \n                pos -= 2; \n            } \n \n            Console.WriteLine(base4); \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algo 1: --------- Convert binary to decimal and then from decimal to base 4 number"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using property of grouping and converting, this is a simple solution to the problem with complexity O(n)   public static void convertTobase4(String s)  {   String base4Number = \"\";   if(s.length() % 2 !=0 )   {    s = \"0\"+s;   }      for (int i = 0; i < s.length(); i=i+2)   {    if(s.substring(i, i+2).equals(\"00\"))    {     base4Number =base4Number + \"0\";    }    if(s.substring(i, i+2).equals(\"01\"))    {     base4Number =base4Number + \"1\";    }    if(s.substring(i, i+2).equals(\"10\"))    {     base4Number =base4Number + \"2\";    }    if(s.substring(i, i+2).equals(\"11\"))    {     base4Number =base4Number + \"3\";    }   }      System.out.println(base4Number);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Base2_4 { \n \n static void stringBaseChange(char[] arr, int len) { \n  char ch1; \n  char ch2 = 0; \n  boolean flag = false; \n  if (len <= 0) \n   return; \n  if (len == 1) { \n   ch1 = arr[len - 1]; \n   flag = true; \n  } else { \n   ch1 = arr[len - 1]; \n   ch2 = arr[len - 2]; \n   stringBaseChange(arr, len - 2); \n  } \n \n   if (ch2 == '0' && flag == false) { \n \n    if (ch1 == '0') \n     System.out.print(\"\" + 0); \n    else \n     System.out.print(\"\" + 1); \n   } else if (ch2 == '1' && flag == false) { \n \n    if (ch1 == '0') \n     System.out.print(\"\" + 2); \n    else \n     System.out.print(\"\" + 3); \n   }else{ \n    System.out.print(\"\" + ch1); \n   } \n \n   \n \n } \n \n public static void main(String[] args) { \n  char []arr = {'1','1','0','0','1','1','1'}; \n  stringBaseChange(arr,7); \n \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void printBase4(String str) { \n  int n = str.length(); \n  if(n % 2 == 1) { \n   System.out.println(\"Not Possible\"); \n  } \n  int i; \n  String out = \"\"; \n  for(i = n - 1; i >= 0 ; i = i-2) { \n   char ch1 = str.charAt(i); \n   char ch2 = str.charAt(i-1); \n   int o; \n   if(ch1 == '0') { \n    if(ch2 == '0') { \n     o = 0; \n    } else { \n     o = 2; \n    } \n   } else { \n    if(ch2 == '0') { \n     o = 1; \n    }else { \n     o = 3; \n    } \n   } \n   out = \"\" + o + out; \n  } \n  System.out.println(out); \n }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=24308662","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"24","title":"I have heard this question many times in microsoft interviews. Given two arrays find the intersection of those two arrays. Besides using hash table can we attain the same time complexity that is O(m+n) by using some other approach.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"bit maps is one probable solution if the data range is small, other wise it takes lots of space  time complexity O(m+n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"For Intersection of two sorted arrays, print the element only if the element is present in both arrays. 1) Use two index variables i and j, initial values i = 0, j = 0 2) If arr1[i] is smaller than arr2[j] then increment i. 3) If arr1[i] is greater than arr2[j] then increment j. 4) If both are same then print any of them and increment both i and j."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Comparison only algorithms have proven lower bounds which are O(K log K), where K = min (m,n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the question instead was to solve the problem for two sorted arrays, there is a simple comparison-based O(m+n) time algorithm whose logic is very similar to the \"merge\" step of mergesort. Step through the two arrays in the same way that the merge algorithm does, and when the next element from array1 is equal to the next element from array2, add the common number to a list of results.  For two unsorted arrays, you can solve using a hash set, but this is O(m+n) only in the expectation and not in the worst case. You can solve the problem in worst-case O(m+n+R) time where R is the range of the numbers, if you also have O(R) space, by using a bitset. Finally, if you are programming in a language that does not initialize memory, you can solve the problem with O(R) space and O(m+n) (no R) time by combining the bitset approach with uninitialized memory tricks."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If space is not an issue we can do: 1.Hash the elements of the smaller array based on their values -> O(m) time and O(m) space 2. Search the elements of larger array in the hash and if exists keep it -> O(n)  Hence, we achieve a O(n) time with the addition of O(m) space where n>m. Apparently, it would be a O(n) time and space if m=n"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can someone please explain in detail the solution with bitmaps"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int findIntersection(int[] a, int[] b)  {                             quickSort(a);                             quickSort(b);   int N = a.length;   int M = b.length;   int i = 0;   int j = 0;   while(i  {    if (a[i]   else if (a[i]>b[j]) j++;    else if(a[i] == b[j]) break;    else return -1;   }   return a[i];  }      public static void main(String[] args)  {       int[] a = {5,1,99,2,4};   int[] b = {3,5,7,23,66,100};   System.out.println(findIntersection(a,b));  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Suppose we have 2 arrays of size n & m respectively, now sort the array of size n with complexity O(n log n) , then look for every element of the second array (size m) in the first array (size n) then the complexity will be O(m log(n)) Will this be considered acceptable ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"If each array has only distinct elements, then: -  XOR all elements of one array.. Let's say it is x. - For each element of the second array, find  (x XOR element). If that is 0, this element is in the intersection list."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=24098662","download_status":"DOWNLOAD_DONE","votes":"-3","answersCount":"28","title":"please read full question before ans, time complexity to merge k sorted arrays of size n each where space is not constraint and merge them with in  m swap( m is total no of element i.e m=k*n )  Example:  Input: k = 5, n =  4 arr[][] = { {3, 33, 55, 71},             {29, 63, 64, 88},             {100,999, 1100, 1800}      {18,99, 155, 180}             {360,480, 590, 620}} ;  Output: 3 18  29 33 55 63 64 71 88  99 100 155 180  360 480 590 620 999 1100 1800   ==> ( \" sort this array with in 15 swap or insertion \")","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Algorithm as follows 1.Create a min  heap of first elements of all the arrays. (a node of heap would be an object containg number's value and number of array it belongs to.)O(Klogk) 2.Now remove the element from the min  heap  3. Add corresponding element of that array  to heap to which min element belonged. repeat steps 2 and 3  total time complexity  will be  ->m is total no of element i.e m=k*n"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"The algorithm that I am suggesting is O(m) and the way the question has been framed I can understand that the total time should be m. But if its actually O(m) then here's my solution.  1. Pair all arrays such that we have k/2 arrays. Merge the arrays in each pair. Time complexity to merge each individual pair is O(n)  (n comparisons). Time complexity to merge all such pairs is (n*k/2) 2. Repeat step 1 till we have got our final sorted array.  Total time complexity for all merges is:        = k/2*O(n) + k/4*O(n) + k/8*O(n) +.....        = O(n) * k *(1/2 + 1/4 + 1/8 + ...)        = O(n) * k * 1/2*(1/(1-1/2)) (Geometric series)        = O(n) * k        = O(n*k)        = O(m)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"you can consider this approach: a. Now in your example there are 5 arrays and they are sorted. b. Let us suppose the arrays are a,b,c,d,e. Then take three variables i,j,d such that i,j=0 and d=m that is the size of the array. Take a destination array of size 5m that is didx[5m] c. Then do this. 1.while(iif a[i]else didx[d]=b[j]j++,d++ then take i=0,d=0,j=m 2.while(iif(c[i]else didx[d]=didx[j],j++,d++ again take i=0,j=0,d=4m and then do the above step 1 then take i=0,d=0,j=5m and do step 2 at last didx holds the sorted elements with 15 swaps."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"please rephrase the question. that english is not clear at all"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@blackfever: In your step 2 you said remove elements from min heap, don't we need to compare removed element with all the elements from the min heap to find out which one to insert."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about if we create a BST using first array and then for each array keep adding elements into the tree as per BST rules. Insertion in tree if counted as one for each element will be K*n = m  Once tree is completed, simply traverse using pre-order traversal."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since space is not an issue, we can create a hash map with two entries: one for the actual values and second for their frequencies. It takes O(k*n) to hash all the elements of these lists, based on the values of the nodes of these lists. As a result, the hash entries will be sorted (they are based on the nodes' values). Next, we write these values, as per their corresponding frequencies, in the final destination. The pseudo code looks like :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"considering the above matrix, stored in row major, the first element is the smallest, even if we go through the array for every element, like even if we do a selection sort we can do it within 15 swaps right? i think it will take 12 swaps."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I dont understand why people are bent on using a heap here?  Wouldn't it be more efficient to just keep track of the current ptr  (named curPtr) in each of the K lists.  1.) All the K curptr are initialized to 0. We find the minimum element from the set of K elements formed by (list1[curPtr1], list2[curptr2], etc) 2.) We output the corresponding minimum element and hence increase the corresponding curPtr 3.) We need to make sure that once the curPtr for some list reaches the \"n\" we ignore it in the next iteration 4.) Since we will output one element in each iteration. The function will run in O(K*n) time. Maybe I have missed something or committed some grave blunder. So, please feel free to comment. UPDATE: Here is some quick code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Could somebody provide any running Java solution for this please?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5740630621814784","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"Test the unknown code. You can not see the code, and the only way to test it is through this function: (the 3 arguments are inputs of the unknown code)  void test(string s, int* a, double d){ //black box code ... ... }  How do you test it to ensure that the code is robust?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Pass the permutation combination of the below values.  Parameter 1: 1. null 2. string.Empty 3. largeString 4. largeStringWithMixOfSpecialChars. 5. largeStringWithOnlySpecialChars. 6. Globalized unicode chars.  Parameter 2 and 3: 1. NegativeIntUpperBound, 2. PositiveIntUpperBound 3. NegativeDoubleUpperBound 4. PositiveDoubleUpperBound 5. 0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"some more string with mix of upper and lower case string with all upper case string with all lower cases string which is more than what we can fit into its String.Length property which is integer  for int/double Max+1, Min-1 to cause overflow Cross combination of integer and double like both +, both -, one +, one - and vice versa, plus both zero, 1non zero other zero and vice versa."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For the int Pointer we can pass:  address of int which holds  values: 0, - range, +range. And For NULL pointer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"some more,"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5673934611546112","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"8","title":"what is the best,worst and average case complexity for fibonacci no.s ..explain?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"best case o(1) - by Eigen values AX = lamda X  avg - O(n) - go linearly from 1 to n  worst - fib(n-1) + fib(n-2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"best   -   lg(n)  ( matrix expo )"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Best log(N) Worts O(Fib(N))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Best O(1) (if you can do infinite precision calculation of doubles by solving the recursive formula and finding the solution as a function of (n) and the eigen functions of the recursion)  Worst O(2^(O(1) n)) (exponential).  If you do a naive recursive approach, such as this:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There are formula to calculate using formula so answer is O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Best Case: O(1) - hash every possible answer ahead of time Average Case: I don't know Worst Case: O(infinite) - have a while loop that doesn't do anything useful and never breaks"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"That depends on how the algorithm of fibonacci has been implemented, but assuming its implemented iteratively  best case - O(1) (asking for fib(0) or fib(1)) average case and worst case O(n)  If it has been recursively implemented without memoization   best case - O(1) (asking for fib(0) or fib(1)) average and worst case is O(2^n)  If it has been implemented recursively with memoization, it will be  best case - O(1) average & worst case - O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Worst question."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4810054553305088","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"39","title":"Remove duplicates from a string inplace. The algorithm should be as efficient as possible. I gave two approaches. First, the simple comparison O(n2) and second, sorting O(nlgon). But the interviewer did not seem satisfied. Can someone please suggest a better algorithm?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"This can be resolved using a simple approach - no hashmaps. You can reduce your complexity to O(N) by simply using an array of size 128 characters (to represent ASCII values). This boolean array will track the characters you encounter as you iterate through the string.   Implementation below:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the question is about removing duplicate characters from the string. For example: If the string is \"amazon\", the output should be \"amzon\". This can be done in O(N) using a HashMap. Algorithm: 1. Traverse the string character by character 2. Enter the character in the HashMap as key if it is not already present  3. If a character is already in HashMap, we found a duplicate. 4. Based on the requirement, we can either just display the characters and skip the duplicate characters OR store the characters in a character array and return the resultant array as a String."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Remove duplicates from string..does that mean  abaaabbcdeee = abcd or = ababcde ?  If its second then its easy to do in O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the characters are s8 bits, you can use a 256 size boolean array as your O(1) space hashmap for an O(n) time algorithm."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think it formated my white space automatically while posting"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorry I posted to the wrong question. The one I posted is to remove duplicate white spaces in specific from a string"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think it is nor possible to do it in O(n) time complexity without extra space. In order to remove duplicates we have to keep track of elements which have been already processed or time complexity will be bigger cause multiple check of the same elements is required."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"String is an immutable object.  \"in place\" modification does not make sense to me"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"eewe"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(N) algorithm: Keep count of number of spaces an unique character has to left shifted. Start with 0. Create hash map of 127 values For each character, 1. If it is not yet seen, move it left by count. Add to hash map. 2.  If it is duplicate, increment count."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think using hash or boolean array voilates in place as it uses too much extra memory. Instead of using a boolean array, use a int variable and set its bits according to the Ascii value of the char you encounter. So you only very little extra space and hence it doesnt voilates inplace!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I faced the same question in the interview. I think what the meant was this   The array AMAZON would become AMZON\\n. Just add a special character at the end to specify that you would have your result before that. In this case you just cant erase a string you have to copy the char 'Z' at index 2 and shift all the remaining characters by one.  This problem is little more involved than simple removal of duplicates."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming that string contain ASCII chars (array can be extended to 256 for extended ASCII), below solution in Java will take O(n) time:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Idea to do it inplace is to swap the dupes to the end of the array and maintain a variable that tells you end of the unique values , result will be char [] from 0 to end. See code below :-   Note : string builder is just a syntactical sugar , we already have result in input array from 0 to end"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hey guys, I think it would be simplest just to use a HASHSET. With the if statement we try to add the current character to the hash set; if we succeed, it means that the char is encountered for the first time, so we increment the counter i, otherwise (when if returns false), we just remove the particular char. Note that the value of i is not incremented.  Hope it helps. :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static char[] removeDups(char []dups) { \n \n        int i = 0; \n \n        for(int j = 1; j < dups.length;j++) { \n            boolean flag = false; \n \n            for(int k = 0;k <= i; k++) { \n                if(dups[k] == dups[j]) { \n                    flag = true; \n                    break; \n                } \n            } \n \n            if(flag == false) { \n                i++; \n                dups[i] = dups[j]; \n            } \n        } \n \n        return Arrays.copyOf(dups,i + 1); \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class RemoveDup( \n    val str: String) { \n \n    def removedup(): String = { \n        val a = new Array[Boolean](256) \n        val sb = new StringBuffer \n        str.foreach(c => { \n            if (a(c.toInt) == false) { \n              a(c.toInt) = true \n              sb.append(c) \n            } \n        }) \n        sb.toString \n    } \n} \n \nobject RemoveDup { \n    def main(args: Array[String]):Unit = { \n        val inst = new RemoveDup(\"amazon\") \n        val after: String = inst.removedup \n        println(after) \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use hashset and hashset buffer. just check if the element is present in the hashset  if present{ put the element in to hashset } else dont put."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* assume ASCII */ \nint remove_duplicates(char *str) \n{ \n    char *cp, *currentp; \n    unsigned char map[32] = {0}; \n \n    for (currentp = str, cp = str; *cp; cp++) \n    { \n        if (!(map[*cp >> 3] & ( 1 << (*cp & 7)))) \n        { \n            map[*cp >> 3] |= (1 << (*cp & 7)); \n            *currentp++ = *cp; \n        }         \n    } \n \n    *currentp = '\\0'; \n \n    return currentp - str; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i am just going to help you out with logic:  first take the string in a variable  secondly use a loop construct to loop until the stringlength  use an if clause and compare the string character by character  if the character repeats two times go for else clause and increment the array of characters by +1  (this step eliminates the dual characters)  similarly for all  characters in an array and then print the array it display the series of character without duplicates .  Thus you can achieve it. NOTE: take string as array of character as you take in C-lang.  Hope it was useful.  Thank U.-"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"StringBuilder myNewString = new StringBuilder(); \n                for (int i = 0; i < str.Length; i++) \n                { \n                    if (i == 0 && str[i] == ' ') \n                        continue; \n                    if (i == str.Length - 1 && str[i] == ' ') \n                        continue; \n                    if (i > 0) \n                    { \n                        if (str[i] == ' ' && str[i - 1] == ' ') \n                            continue; \n                        else \n                        { \n                             \n                            myNewString.Append(str[i]); \n                        } \n                    } \n                } \n                return myNewString.ToString();"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5417227184504832","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"design a data structure to store time series and implement add operation","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"please, can you give some example of time series?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"From wiki: A time series is a sequence of data points, measured typically at successive points in time spaced at uniform time intervals.  Use two arrays of the same length to store your time series. The first array stores values (e.g. price) and the seconds stores time. Note that the second series is monotonically increasing (or at least non-decreasing), i.e. it's sorted. This property enables you to search it using the binary search algorithm. Once you get an index of a time of interest in the second array you also have the index of the relevant entry in the first array. If you wrap the two arrays and the search algorithm e.g. in a class you will have the whole implementation complexity hidden behind a simple interface."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5878624968245248","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"41","title":"Given a number of arrays where:- Arr-1={1,2,3,4,5,6,7,8,9 ... N} Arr-2 is formed by eliminating all the elements that satisfy x*2 from Arr-1 (x belongs to natural numbers) ie. Arr-2={1,3,5,7,9,11,13,15,17,19 ... } Similarly Arr3 is formed by eliminating all the elements that satisfy x*3 from Arr2 (x belongs to natural numbers) i.e.  Arr3={1,3,7,9,13,1519,21,25,27 ... } Arr-k is formed by eliminating x*k elements from Arr-(k-1).  Given number \"z\" and Array suffix \"k\" Find if z exists in Arr-k (with as space and time minimum complexity as possible)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I don't know if I have understood the question properly......also feel should be Arr3={1,2,4,5,7,10,11,13,14,16,17,19,.....} is what understood from explaination of  Arr2. If this true then"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Explaining the question further:-  Arr-3 is formed by eliminating 3rd, 6th, 9th ... (x*3)th from Arr-2 Now since Arr-2 was {1,3,5,7,9,11,13 ...} (after eliminating 2nd,4th,6th (x*2)th elements from Arr-1) -  Arr-3 eliminates 5(3rd element), 11(6th element) ... from Arr-2 and forms Arr-3={1,3,7,9,13,15 ...}  So Arr-k formed by removing x*kth element from Arr-(k-1) immediate preceding array of Arr-k.  Please revert if am still not clear."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include   using namespace std;  int main() {     int arr[50]={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25};     int i,j;      printf(\"Array elements are:-\");     for(i=0; i<25; i++)         printf(\"%5d\", arr[i]);      printf(\"\\n\");      int Array_kth, No;     printf(\"Enter the kth Array and No to find in Kth array:-\");     scanf(\"%d %d\", &Array_kth, &No);      bool found = false;     if( Array_kth==1 )     {         printf(\"Found the Element in first array\\n\");         return 0;     }      for(i=1; i<=No; )     {         if(i==No)         {             found = true;             break;         }         for(j=1; j        {             if(i==No)             {                 found = true;                 break;             }                i=i+(j*2);         }                  if(found)             break;     }      if(found)         printf(\"Number %d Found the Element in array %d\\n\", No, Array_kth);     else         printf(\"Number %d Not Found the Element in array %d\\n\", No, Array_kth);      printf(\"\\n\");          return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) { \n \n  int n = 100; \n  int z = 39; \n  int k = 7; \n  int indexToRemove = 2; \n  Integer[] arr = new Integer[n]; \n  for (int i = 1; i <= n; i++) { \n   arr[i - 1] = i; \n  } \n  Queue q = new LinkedList(Arrays.asList(arr)); \n  for (int i = 0; i < k - 1 && !q.isEmpty(); i++) { \n   int counter = 0; \n   int initialSize = q.size(); \n   while (counter < initialSize) { \n    for (int j = 0; j < indexToRemove - 1 && counter < initialSize; j++, counter++) { \n     q.offer(q.poll()); \n    } \n    if (counter < initialSize) { \n     q.poll(); \n     counter++; \n    } \n   } \n   indexToRemove++; \n  } \n \n  System.out.println(\"Element exists: \" + q.contains(z)); \n \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void checkExistense(int z, int k){ \n  int d = checkPrime(z); \n  if(d==0){ \n   System.out.println(z+\" is present in Arr-\"+k); \n   return; \n  } \n  if(k>d){ \n   System.out.println(z+\" is not present in Arr-\"+k); \n  }else{ \n   if(z%2==0 || z%3==0 || z%5==0){ \n    System.out.println(z+\" is not present in Arr-\"+k); \n   }else{ \n    System.out.println(z+\" is present in Arr-\"+k); \n   } \n  }   \n } \n  \n public static int checkPrime(int z){ \n  for(int i=(int) Math.sqrt(z);i>1;i--){ \n   if(z%i==0) \n    return i; \n  } \n  return 0; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static boolean exists(int z, int k) {     if(k<=1) return true;    if(z<1) return false;    if(z==1) return true;    if(z<=k) return false;    for(int i=2;i<=k;i++)       {            if(z%i==0)               return false;       }    return true; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"x=z; for(i=2; i<=k; i++) {  if(x%i==0)   return \" z exist in Arr-(k-1) \";  else   x=(x/k)*(k-1) + x%k;         // used to calculate the position of z in Arr-i }  return \" z exist in Arr-k at position x\";   Space Complexity: O(1) Time Complexity: O(K)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"System.out.println(\"\");"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is this really from msft? Anyways"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import math \n \ndef alg(z, k): \n    for i in range(2, k+1): \n        if z % i == 0: \n            return False \n        else: \n            z = z - math.floor(z/i) \n    return True \n \n \nprint(alg(9, 3)) \nprint(alg(9, 4))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"array-2 is all elements of array except multiples of 2 array-3 is all elements of array except multiples of 2, 3 array-4 is all elements of array except multiples of 2,3,4 and .... so on array-k is all elements of array except multiples of 2,3,4,5,....k-1  For each number i from 2 to k, if z is multiple of i, a number z can not be in array.  z can be a multiple of number from 2 to k, if its multiple of prime between 2 to k Find out prime numbers between 2 to k (O(k) time and space complexity). Check if z is multiple of prime numbers between 2 to k (O(k) time complexity) If it is then z can't be in array-k If its guaranteed that z is always taken from array then we end here otherwise then run binary search(O(logn) time complexity) if array is sorted (else linear search O(n) or sort and search(O(logn)) to find z in array. if found z is in array-k, else it is not in array-k"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static bool Exists(int arg, int k) \n        { \n            for (int mod = 2; mod <= k && mod <= arg; mod++) \n            { \n                if (arg % mod == 0) return false; else arg -= (arg / mod); \n            } \n            return true; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static boolean exists(int number,int k) { \n        for(int i = 2;i <= k && i <= number;i++) { \n            if(number % i == 0) { \n                return false; \n            } else { \n                number -= (number / i); \n            } \n        } \n        return true; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Arr-k is formed by eliminating x*k elements from Arr-(k-1)??NOT Arr-1?? I dont think anyone really undertand what it means, except the author."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Say if we are to check for value N in round K, then we check from 1st round till Kth round. At each round we are interested in the index of N.  - Clearly when K=2 index of N is N itself (as nothing has been eliminated yet) - When K=3 then index of N is N - (floor(N/2)); as floor(N/2) elements have been eliminated when K=2  Also in each round (say K) a number whose index is 'X' is eliminated if X%K=0 Therefore we start from 1st round and continue up and see if the number survives till Kth round."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"So for this if k = 1 then it exists always else for z to exist it should not be divisible by 2 and 2+3 and 2+3+4 and.........2+3+4+....+k."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You need to check only for primes in 2 to k..You can use  sieve method for that. So space O(k) time O(kloglogk).. However, if you check for every k, space=O(1), time is O(k). I don't undderstand which one of the two is better? Is mod operation costly so that we should use the first way, or should we go with the basic intuition of the second method?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public bool ElementExists(int[] array,int z, int k)         {             int index = -1;              for (int i = 0; i < array.Length; i++)             {                 if (array[i] == z) { index = i; break; }             }                           if (index == 1) return true;              for (int i = 2; i <= k; i++)             {                 if (index % i == 0) return false;                 index = ((i-1)*(index/i))+(index%i);             }              return true;         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public bool ElementExists(int[] array,int z, int k)         {             int index = -1;              for (int i = 0; i < array.Length; i++)             {                 if (array[i] == z) { index = i; break; }             }                           if (index == 1) return true;              for (int i = 2; i <= k; i++)             {                 if (index % i == 0) return false;                 index = ((i-1)*(index/i))+(index%i);             }              return true;         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class ArrayK { \n \n    public static void main(String[] args){ \n \n        int z=5; \n        int index=z; \n        int k=3; \n        int i; \n \n        for(i=2;i<=k;i++){ \n \n            if(index%i !=0) { \n \n                if(i==k){ \n \n                    System.out.print(\"the number with value  \" + z +\"   is present in Array \" + k); \n                } \n \n            index = index-(index/i); \n \n            } \n \n            else \n \n            { \n                System.out.print(\"the number with value  \" + z +\"   is not present in Array \" + k); \n \n                break; \n            } \n \n \n        } \n \n \n \n \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static boolean isPresentInArray_K(int number, int k) \n { \n  //base conditions \n  if(k == 1) \n   return true; \n   \n  if(k >= 2 && (number % 2) == 0) \n   return false; \n     \n  // approach for the Array3 and after \n  else \n  { \n   int positionInArrayTwo = (int) Math.ceil((double)number/2); \n   System.out.println(\"The position of \" + number + \" in Array_2 is : \" + positionInArrayTwo); \n    \n   int positionInPreviousArray = positionInArrayTwo; \n   int positionInCurrentArray; \n    \n   for(int i = 3 ; i <= k ; i++) \n   { \n    if(positionInPreviousArray % i == 0) \n     return false; \n     \n    positionInCurrentArray = positionInPreviousArray - (positionInPreviousArray / i); \n    System.out.println(\"The position of \" + number + \" in Array_\" + i + \" is : \" + positionInCurrentArray); \n    positionInPreviousArray = positionInCurrentArray; \n   } \n   return true;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1 . Z cannot be multiple of any number between [2,k]. 2.  Z can be any prime number <= N 3.  Z can be any number which is multiple of [k+1,N]."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1 . Z cannot be multiple of any number between [2,k]. 2.  Z can be any prime number <= N 3.  Z can be any number which is multiple of [k+1,N]."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1 . Z cannot be multiple of any number between [2,k]. 2.  Z can be any prime number <= N 3.  Z can be any number which is multiple of [k+1,N]."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5643620463935488","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"Identifying the number of occurrences of each  palindrome in a file","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Text file can be too large to fit in RAM, so i will prefer .. Map-Reduce approach:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Create HashMap where key is palindrome and value is the number of occurrences. Iterate over file and check if given word:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5766928975003648","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"16","title":"A node which has following fields    a) data   b) next_ptr   c) prev_ptr can be used to represent doubly linked list, binary tree or none. Given a random pointer recognize whether it forms DLL, Binary Tree or none.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Since it is pointer-based, there is a hint at recursive implementation. For BinaryTree when starting at root, you need to make sure there is no cycle, e.g., when moving down the tree, you can keep a HashMap to make sure new nodes are not being revisited. Another thing which \"I did not consider\" but could be important is the consistency of values at different nodes, e.g., do we need to have one child value larger, and the other one smaller than current node?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"with  binary tree quite easy - check all parent nodes have no more then two children and data  satisfy  Binary Tree criteria.  DLL is simple - parents always have one children"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For a Doubly linked list: The next and prev pointers will act just as they should for a doubly linked list.  For a Binary tree: The next and prev pointers will act as pointers to the left and right child.   Here is my solution: For a DLL which looks like:                pre-input<====>input <====>post-input Either going foward and back from 'input' OR backward and forward from 'input' should lead to the original node.  For a Binary Tree: If the node does not form a DLL  AND If both pointers point to different locations, the input node could represent a node in a binary tree with  atleast one child.  For Neither of the two: If both the pointers are NULL, then the input node points represents a node which can neither be a DLL nor a binary tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"To check if it is a DLL, we need to traverse the list both forward and backwards and check if the previous and next pointers are correct. Also, if the DLL may be circular (ask the interviewer), we need to detect cycles.  Checking if it is a binary tree is a bit more complex. A Tree does not have cycles. On top of that, we also need to check that each node has at most one parent (otherwise it is just a Directed Acyclic Graph and not a Tree)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"As per my understanding, the best way to differentiate Binary tree and DLL is by counting leaf nodes.   In case of DLL there will be only two null values one is at the start and one at the end.  Where as in Binary tree there will be  2^h-1 to 2^h leaf nodes. So by counting the leaf nodes we can solve the problem.  If the given node having two null pointers then we can't say whether it is BT or DLL."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can this be done for any random pointer?  If there is just one node and it's prev and next are 0 (or NULL) then it can be regarded as both binary tree as well as doubly linked list. Or if input is NULL pointer even then it can be either DLL or BT"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4799926751985664","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"10","title":"Consider a binary tree for which root node and a target node are given to you. Give the next sibling of the target.(let the target be in level k, then you need to give the immediate node which is in level k)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do BFS search of the binary tree till the level of the target node. Keep track of nodes for particular level so that you know when nodes for particular level start and end. At the end you should have all nodes which are at the same level as target node. Now it's very simple to find target node and return its sibling which is on the right or left. Code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just realized the question may involve the cousins too. the above solution will not handle that.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"do a level order traversal, once reached the target node, return next node in the same level if exist."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What is meant by the next sibling? A binary tree can have at most one sibling only."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do BFS and keep track of the queue continuously, to figure out if the Target has now been available in the queue. If yes, then find the parent of the target in the queue by continuously dequeing so that the right sibling where ever it is (under same parent of target or different parent) is achieved. Level needs to be tracked because if the target is right most sibling, then the right sibling of it wont exist"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do BFS and keep track of the queue continuously, to figure out if the Target has now been available in the queue. If yes, then find the parent of the target in the queue by continuously dequeing so that the right sibling where ever it is (under same parent of target or different parent) is achieved. Level needs to be tracked because if the target is right most sibling, then the right sibling of it wont exist"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4943998208704512","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"8","title":"Printing diagonals of a matrix","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//The diagonals of a matrix are such that i = j.  \nint matrix[row][col]; \nfor (int i = 0; i < row; i++){ \n   //For matrices such that max({row,col}) = row \n   if(i > col){ \n      break; \n   }else{ \n      printf(\"%d \\n\", &matrx[i][i]); \n   } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"[(matrix[i][i], matrix[i][len(matrix) -i-1])  for i in range(len(matrix))]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Printing diagonals of a matrix is quite easy, but you need to understand the relation between matrix and diagonals. If you want perfect diagonals from matrix then your matrix must be square, I mean your matrix should be NxN. For example 2??2, 4??4 or 9??9 etc. Because in rectangular matrix (2??3 or 5??7) it is not possible to find perfect diagonals.  1      2      3      4 5      6      7      8 9      10   11    12 13    14   15    16  Now if you see above matrix carefully there are two diagonals in this one is 1, 6, 11, 16 and other is 4, 7, 10, 13.   I found this implementation, which is already done, you can check algo on below website link  somanyword.com/2013/12/print-diagonals-of-a-given-matrix/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String []args){ \n        System.out.println(\"Hello World\"); \n        int [][] array = {{00,01,02,03,04}, \n                          {10,11,12,13,14}, \n                        {20,21,22,23,24}, \n                        {30,31,32,33,34}, \n                        {40,41,42,43,44}}; \n                         \n        for(int i =0; i < array.length; i++){ \n            System.out.print(array[i][i]+\" \"); \n        } \n        System.out.println(); \n \n        for (int j = 0 ; j < array.length; j++ ){ \n            System.out.print(array[j][(array.length-1)-j]+\" \"); \n             \n        } \n     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Solution for main and incidental diagonals"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5259277396606976","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"How would you structure the game of life (classes, functions etc...)? How would you structure the board if it was played on a sphere?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Game of Thrones is better :D"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"en.wikipedia.org/wiki/Conway's_Game_of_Life"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6688746397237248","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"6","title":"Find the degree of separation between two people (e.g. LinkedIn's connected feature)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"This is can also be done using two BFS searches - one from person A and one from person B. \n \nBFS algorithm explores every node at a distance/radius k from the source node before it moves to distance k+1.  The algorithm also keeps a track of visited nodes by coloring them as white(not explored), gray(being explored) and black(explored). \n \nRun two BFS searches from A and B:- \n1.  From A, let the explored radius be X, let the colors used for exploration be g1 and b1 \n2.  From B, let the explored radius be Y, let the colors used for exploration be g2 and b2 \n \nExplore all nodes from A with X = 1, then from B with Y = 1, then from A with X = 2.. and so on. \n \nDuring exploration whenever BFS from A encounters a node colored b2 or vice versa, the search can be terminated. \n \nThe degree of separation is X + Y."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"You can try this: 1) Create a graph between two people and their friends. If two people know each other (they are present in contacts list) make a vertex. 2) Find the shortest path between person A and B. Number of nodes in the path is the separation degree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.first, we should make sure that A,B can be connected, that means there must be at least one path from A to B. we can use Union Find to check it(is root(A)==root(B)?). 2.second, if A,B are conntected, then use BFS to find the shortest path."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What the degree of separation means? it is a distance on the graph?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5126210803728384","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"34","title":"Find the maximum-sum subarray of an array.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Use Kadane algorithm."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public int Calculate(int[] array) \n        { \n            if (array == null || array.Length == 0) \n                throw new ArgumentException(); \n \n            int max = array[0]; \n \n            for (int i = 1; i < array.Length; i++) \n                max = Math.Max(max, Math.Max(array[i], array[i] + max)); \n \n            return max; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Below is the python script, algorithm is simple I've commented so you could understand:  a = [1, 4, -5, -4, -8]  # max sum array indexes                                                                                                 n1=n2=0  # current positive array indexes                                                                                        c1=c2=0  # maxium sum so far                                                                                                     m_sum=float(\"-inf\")  # current sum                                                                                                           p_sum=0  for i in range(0, len(a)):     # current sum index                                                                                                     c2=i     p_sum = p_sum + a[i]     # current sum got larger then max sum                                                                                   if p_sum > m_sum:         m_sum=p_sum         (n1, n2)=(c1, c2)      # if sum is -ve then don't carry it                                                                                     if p_sum < 0:         p_sum=0         c1=i+1   print 'Max sum: %d, from index [%d - %d]'%(m_sum, n1, n2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I put again the code, sorry about last post it does not format properly for the code."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/** \n * Progamming Language Used : PHP \n * Algorithm Used : Kadane's algorithm \n *  \n * This method computes the maximum sum of subarray from the given array. \n *  \n * @return int sum of sub array \n *  \n * @author Varun Jalandery  \n */ \nfunction maximumSumOfSubArray(array $numbers) \n{ \n    // Initialize variables here \n    $maxSoFar = 0; \n    $maxEndingHere = 0; \n    for ($i = 0; $i < count($numbers); $i++) { \n        $maxEndingHere += (int) $numbers[$i]; \n        if ($maxEndingHere < 0) { \n            $maxEndingHere = 0; \n        } else { \n            $maxSoFar = $maxEndingHere; \n        } \n        if ($maxSoFar < $maxEndingHere) { \n            $maxSoFar = $maxEndingHere; \n        } \n    } \n    return $maxSoFar;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In some sense, books like \"cracking the..\" and websites like this one add to the problem of allowing mediocre people beat out the really creative geniuses (who don't check careercup every week) in interviews.  There are a average folks who spend a lot of time here who would probably beat out Ken Thompson in these cookie cutter interviews."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int maxSumSubArr(ArrayList list){ \n int ret = 0; \n int cur = 0; \n int max = Integer.MIN_VALUE; \n for(int i = 0; i max){ \n   max = list.get(i); \n  } \n  cur = max(0, cur + list.get(i)); \n  if(cur > ret){ \n   ret = cur; \n  } \n } \n if(max < 0){ \n  return max; \n } \n return ret; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class MaxSumSubArray {   static int maxSumSubArr(ArrayList list) {   int ret = 0;   int cur = 0;   int max = Integer.MIN_VALUE;    for (int i = 0; i < list.size(); i++) {    if (list.get(i) > max) {     max = list.get(i);    }    cur = max(0, cur + list.get(i));    ret = max(cur, ret);   }   return ret;  }   private static int max(int i, int j) {   return (i < j ? j : i);     }   public static void main(String[] args) {   ArrayList num = new ArrayList();   num.add(-3);   num.add(-4);   num.add(5);   num.add(6);   num.add(-1);   num.add(-2);   num.add(-9);   num.add(-2);    int result = maxSumSubArr(num);   System.out.println(\"The result is::\" + result);  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int GetMaxSumOfSubArray(int *n, int len) \n{ \n    int tempMax = 0; \n    int maxSum = -2147483648; \n    int theLeft = 0; \n    int theRight = 0; \n    int tempLeft = 0; \n \n    for (int i=0; i maxSum) \n        { \n            maxSum = tempMax; \n            theLeft = tempLeft; \n            theRight = i; \n        } \n \n        if (tempMax < 0) \n        { \n            tempLeft = i+1; \n            tempMax = 0; \n        } \n    } \n \n    for (int i=theLeft; i<=theRight; i++) \n    { \n        printf(\"%d \", n[i]); \n    } \n    printf(\"\\n\"); \n \n    return maxSum; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class MaxSumSubArray \n{ \n    static void Main() \n    { \n        int[] a = new int[] { -1,-2,-3 }; \n        int sum = Int32.MinValue; \n        int max = 0; \n \n        for (int i = 0; i < a.Length; i++) \n        { \n            if (max <= 0) \n                max = a[i]; \n            else \n                max += a[i]; \n            if (max > sum) \n            { \n                sum = max; \n            } \n        } \n \n        Console.WriteLine(sum); \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think I have an O(n) solution, but which is O(n) in space too. The code would probably be messy so I'll just propose a sketch for the algorithm. also, the sketch is concerned with finding the maximum sum itself,  but it can (somewhat) easily be modified to return start and end indices, though, again, it will get even messier."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is an example of dynamic programming:  Here is the code for this"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"CONSOLE  OUTPUT: ==================  Enter array size :  20 Enter the elements :  2 -3 1 -2 3 -1 2 -3 1 -2 3 -1 2 -1 3 -2 1 -2 2 -1  The start index : 10 The end index : 14 The sum is : 6"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class MaxSumArray { \n \n    public static void main(String[] args){ \n \n        int[] array=new int[]{2,30,15,-7,9,14,-10,23,14,0}; \n        int[][] sum=new int[array.length][array.length]; \n \n        int i=0; \n        int j=1; \n \n        int max=0; \n        int start=0,end=0; \n \n        sum[0][0]=array[0]; \n \n         while(i=sum[i][j-1]) \n            { \n                sum[i][j]=sum[i][j-1]+array[j]; \n \n \n            } \n \n            else \n            { \n \n               i=j+1; \n            } \n \n            if(max"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int maxSumSubArray(int a[], int size) {  int sum = 0, i = 0, max = 0;  for(i =0; i   sum = sum + a[i];   if(sum < 0) sum = 0;   if(sum > max) {    max = sum;   }  }  return max; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-5","title":"why amazon ask an algorithm that (some) people memorize ? Google \"Kadane's algorithm'"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4849778118623232","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"37","title":"Write a function to validate the integrity of a binary search tree.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Pythonic version"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Most of the answers are wrong. As @msft pointed out the solutions will return the following BST is valid  5 <- 10 ->15 Left child of 5 is 20. This is not a BST but the solutions would validate this case..  The simplest solution is to perform inorder traversal and check if every node is greater than the previous node. If the inorder traversal is sorted then it is a BST."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"int isBST(struct node* node) {  \n  return(checkIsBST(node, INT_MIN, INT_MAX));  \n} \n \nint checkIsBST(struct node* node, int min, int max) {  \n  if (node==NULL)  \n return true; \n \n  if (node->datadata>max)  \n return false; \n \n  return  \n     ( checkIsBST(node->left, min, node->data) &&  \n       checkIsBST(node->right, node->data+1, max) );  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"One has to make a mistake once in their life to get the small trap in this problem.  If you have not coded this ever, you will most likely come up with (in nervous interview) checking that every left child is less than and ever right child is greater than current node (then recurse to children).  But we have to check that WHOLE left subtree is less than and WHOLE right subtree is greater than.  Basically google you should question and study the pitfalls and the correct inefficient and efficient solutions."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I didn't test it. hope It works"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"C++ version."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"1. Check to see if the node is greater than or equal to max value of the left subtree 2. Check to see if the node is less than the minvalue of the right subtree 3. Check to see if the left or right subtrees are invalid 4. if all tests pass, then return true"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Basically you should google question*"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static int Pre = INT_MIN; \nbool IsValidBST(root) \n{ \n Pre = INT_MIN; \n return IsValidBST(root) \n} \nbool Verify(TreeNode* root) \n{ \n if( !root ) return true; \n if( !Verify(root->left) ) return false; \n if( root->data < Pre ) return false; \n Pre = root->data; \n if( !Verify(root->left) ) return false; \n return true;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What you guys think about this?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why not just push the root node into a stack, say stack A. Then, until A is empty, pop A into some node variable n, validate that n->left is less than n->value and n->right is greater than n->value. If both are true, push n->right then push n->left. Else, return false. If A becomes empty, return true."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct Node \n{ \n int val; \n Node* left; \n Node* right; \n}; \n \nbool checkIntegrityRec(Node* node, int& prevVal) \n{ \n if (!node) \n  return true; \n if (!checkIntegrityRec(node->left, prevVal)) \n  return false; \n if (node->val < prevVal) \n  return false; \n prevVal = node->val; \n if (!checkIntegrityRec(node->right, prevVal)) \n  return false; \n return true; \n} \n \nbool checkIntegrity(Node* root) \n{ \n Node* n = root; \n while (n->left) \n  n = n->left; \n int prevVal = n->val - 1; \n return checkIntegrityRec(root, prevVal); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do in order traversal and check if the list is sorted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do in order traversal and check if the list is sorted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public boolean isValidBST(TreeNode root) {   return isValidBSTHelper(root, Integer.MIN_VALUE, Integer.MAX_VALUE);  }   private boolean isValidBSTHelper(TreeNode node, int minValue, int maxValue) {   if (node == null) {    return true;   }   if (node.val > minValue && node.val < maxValue) {    return isValidBSTHelper(node.left, minValue, node.val) && isValidBSTHelper(node.right, node.val, maxValue);   } else {    return false;   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public boolean isValidBST(TreeNode root) { \n  return isValidBSTHelper(root, Integer.MIN_VALUE, Integer.MAX_VALUE); \n } \n \n private boolean isValidBSTHelper(TreeNode node, int minValue, int maxValue) { \n  if (node == null) { \n   return true; \n  } \n  if (node.val > minValue && node.val < maxValue) { \n   return isValidBSTHelper(node.left, minValue, node.val) && isValidBSTHelper(node.right, node.val, maxValue); \n  } else { \n   return false; \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public boolean isValidBST(TreeNode root) { \n return isValidBSTHelper(root, Integer.MIN_VALUE, Integer.MAX_VALUE); \n} \n \nprivate boolean isValidBSTHelper(TreeNode node, int minValue, int maxValue) { \n if (node == null) { \n  return true; \n } \n if (node.val > minValue && node.val < maxValue) { \n  return isValidBSTHelper(node.left, minValue, node.val) && isValidBSTHelper(node.right, node.val, maxValue); \n } else { \n  return false; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can we not do a traversal ( say inorder ) and while are visiting the node compare the left and right node values. Do this recursively for all node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"void IsBST(Node* current,bool& isBST)  {   if(current == 0 || isBST == false) return;    if(current->Left != NULL && current->Left->Data > current->Data)   {    isBST = false;    return;   }   if(current->Right!= NULL && current->Right->Data < current->Data)   {    isBST = false;    return;   }   IsBST(current->Left,isBST);   IsBST(current->Right,isBST);  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5684901156225024","download_status":"DOWNLOAD_DONE","votes":"4","answersCount":"45","title":"Arrange the numbers in an array in alternating order. For example if the  array is [a1, a2, a3, a4.. ]arrange the array such that b1<=b2>=b3<=b4 and so on. Sampe Input: 3 5 7 8 4 9 Sample Output: 3 < 5 > 4 < 8 >7 < 9","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"13","title":"void arrangeList(int A[], int n) \n{ \n for(int i=1; i A[i-1]) \n   swap(A[i], A[i-1]); \n } \n return; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"You can solve this in O(n) time by finding the median of the array in O(n) using quickselect or the median-of-medians algorithm, and then placing numbers less than the median (in any order) in even positions (for a 0-indexed array), and numbers greater than the median (in any order) in odd positions. For elements equal to the median, distribute them between both even and odd slots that remain after placing the other elements. The correctness of this approach follows from the observations that every constraint on the final output is of the form a[some_odd_index] >= a[some_even_index], and that this construction ensures all odd indexes are >= the median and all even indexes are <= the median, therefore guaranteeing that all odd indexes are >= all even indexes."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Sort the array in ascending order  Array.sort(inputArray);  Once sorted traverse the array for modifications and swap every two elements in the following logic  for(i=1; i{  int temp = inputArray[i];  inputArray[i] = inputArray[i+1]  inputArray[i+1] = input Array[i] }  This will result the array in required output. Please correct me if I am wrong."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void arrange(int array[]){ \n char int[] = Programming.mersort(array,0,array.length); \n \n int i =  0; \n int e = sorted.length -1; \n boolean flag = false; \n while(i<=e){ \n  if(flag){ \n   System.out.print( sorted[e--] + (i<=e?\" >= \":\"\") ); \n  }else{ \n   System.out.print( sorted[i++] + (i<=e?\" <= \":\"\") ); \n  } \n  flag = !flag; \n \n } \n System.out.println(\"\"); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Little modification to the merge sort will work for this 1) Divide the input as we do in the merge sort 2) While merging use a variable which is incremented on every merge operation  3) Use ascending order condition for merging if it is even or descending order when it is odd package ms.cc.alternatesorting;  public class AlternateSorting { int[] inputArray = {3,5,7,8,4,1,2,12,15}; void mergeSort(int[] array) { int[] helper = new int[array.length]; mergesort(array, helper, 0 , array.length-1); for (int i = 0; i < array.length; i++) { System.out.println(array[i]); } } private void mergesort(int[] array, int[] helper, int low, int high) { if (low{ int middle= (low+high)/2; mergesort(array, helper, low , middle); mergesort(array, helper, middle+1 , high); merge(array, helper,low, middle, high);  }  } private void merge(int[] array, int[] helper, int low, int middle, int high) { for (int i = low; i <= high; i++) { helper[i]=array[i]; } int helperLeft= low; int counter=0; int helperRight= middle+1; int current=low; while(helperLeft<=middle && helperRight<=high) { if(counter%2==0) { if(helper[helperLeft]<=helper[helperRight]) { array[current]=helper[helperLeft]; helperLeft++; } else { array[current]=helper[helperRight]; helperRight++; }  } else { if(helper[helperLeft]>=helper[helperRight]) { array[current]=helper[helperLeft]; helperLeft++; } else { array[current]=helper[helperRight]; helperRight++; }  } counter++; current++; } int remaining = middle- helperLeft; for(int i= 0; i<=remaining;i++) { array[current+i]= helper[helperLeft+i]; }  } public static void main(String[] args) {  AlternateSorting i = new AlternateSorting(); i.mergeSort(i.inputArray);  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Python code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for(int i=1;itemp) \n    sb.append(numbers[i-1]+\">\"); \n   else \n    sb.append(numbers[i-1]+\"<\"); \n  } \n  sb.append(numbers[numbers.length-1]);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Incorrectness: can be proved by unit test. The output will be 3 7 5 8 4 9. Who are these people who voted for this answer?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.Sort the given Array to make Array A 2.Add elements in new Array(B) in this order  (a)Take two iterators which points to beginning and end of Array A          (b)Fill B with element from beginning and then element from end    (c)increment beginning and decrement end  (d)Repeat step 2(b) until beginning < end  B is our required result(Elements in Alternative Order) Running time: O(n log n) So if the input Array is 3 5 7 8 4 9  Then A = 3 4 5 7 8 9   B = 3 9 4 8 5 7 which is our output"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) arrange the array in ascending order. 2)in another array,copy the first element,and then simply swap the other elements in 2s pair(consequetive).  array:a1,a2,a3,a4,a5...(in ascending order) answer in a new array: a1,a3,a2,a5,a4,....so on..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \nusing namespace std; \n \nvoid swap(int &a,int &b) \n{ \n    int temp =a; \n    a =b; \n    b= temp; \n} \n \nint main() \n{ \n    int a[] = {3,5,7,8,4,9}; \n    int n = sizeof(a)/sizeof(a[0]); \n    sort(a,a+n); \n    for(int i=1;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java Code  Complexity O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just one case for clarification about  b1<=b2>=b3<=b4 >=b5 <= b6 >= b7 >=b8 and so on. Am I correct, that it is NOT required to have following additional rule: b1 <= b3 <= b5 <= b7 and so on b2 <= b4 <= b6 <= b8 and so on"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(nlogn) Sort first, then swap elements from 1...n-2 [a(0-n-1)] array"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//this algorithm works if numbers are not repeated ac"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"internal void AlternateSort(int[] input)         {             bool findLower = false;             var len = input.Length;             int temp = 0;             if (input[0] < input[1])             {                 findLower = true;             }             else             {                 findLower = false;             }              for (int i = 1; i < len -1; i++)             {                 int j = i + 1;                 if (input[i] < input[j] && findLower == true)                 {                     temp = input[i];                     input[i] = input[j];                     input[j] = temp;                                     }                 else if (input[i] > input[j] && findLower == false)                 {                     temp = input[i];                     input[i] = input[j];                     input[j] = temp;                 }                  findLower = !(findLower);             }              foreach (int i in input)             {                 Console.Write(i + \" \");             }         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int[] convertLessMore(int[] a, int n) {     boolean less = true;          for (int i=1; i < n ; i++) {         if (less) {             if (a[i-1] > a[i]) {                 swap(a, i-1, i);             }         } else {             if (a[i-1] < a[i]) {                 swap(a, i-1, i);             }         }                  less = !less;     }          return a; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Sort array  2) Iterate through array, inserting into output array alternating between head and tail of sorted array.   Time: O(nlogn) Space: O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Eugene posting some theoretical mumbo jumbo again without any real coding or psuedocode."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5768831796510720","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"42","title":"Write code to remove alternate duplicate characters (case insensitive) from a string in place. For eg. \"Today is the day\" -> \"Today ishe \". Also give test cases.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"void removeAlternateDuplicates(char str[],int n){ \n int letters [256]; \n int i = 0; \n int index=0; \n for(i=0;i<256;i++) \n  letters[i]=0; \n for(i=0; i= 65 && str[i] <= 90){ \n   lowerCase +=('a' - 'A'); \n  } \n  if(letters[lowerCase] == 0){ \n   letters[lowerCase]++; \n   str[index++]=str[i]; \n  }else{ \n   letters[lowerCase]--; // We want to Alternate \n  } \n } \n while(index < i){ \n  str[index++]= 0; \n } \n} \nint main(){ \n char str[]=\"aAaBbBcCcdefgFGZzzzO\"; \n   removeAlternateDuplicates(str,20); \n   printf(\"%s\\n\",str ); \n  \n return 0; \n \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This one is very important for micro so please answer it fast."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Very important for micro intern and sde interviews so please try it soon for your benefits."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please find below java implementation :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void removeDuplicates(char str[],int n){ \n int letters [256]; \n int i = 0; \n int index=0; \n for(i=0;i<256;i++) \n  letters[i]=0; \n for(i=0; i= 65 && str[i] <= 90){ \n   lowerCase +=('a' - 'A'); \n  } \n  if(letters[lowerCase] == 0){ \n   letters[lowerCase]++; \n   str[index++]=str[i]; \n  }else{ \n   letters[lowerCase]--; // We want to Alternate \n  } \n } \n while(index < i){ \n  str[index++]= 0; \n } \n} \nint main(){ \n char str[]=\"aAaBbBcCcdefgFGZzzzO\"; \n   removeDuplicates(str,20); \n   printf(\"%s\\n\",str ); \n  \n return 0; \n \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Diego Giagio posted the best code!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static String removeDup(String txt){ \n  boolean [] dp=new boolean [26]; \n  char []chs=txt.toCharArray(); \n  int j=0; \n  int dif=0; \n  for (int i=0;i='a'&&chs[i]<='z'){ \n    dif=chs[i]-'a'; \n   } else if (chs[i]>='A'&&chs[i]<='Z'){ \n    dif=chs[i]-'A'; \n   } \n   if (!dp [dif]||chs[i]==' '){ \n   chs[j++]=chs[i]; \n   dp [dif]=true; \n  } \n    \n  } \n  return new String(chs,0,j);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def remove_duplicate_chars(st): \n     \n    seen_chars = set() \n    actual_len = 0 \n    for s in st: \n        s_lc = s.lower() \n        if s_lc not in seen_chars: \n            seen_chars.add(s_lc) \n             \n            # replace current character with non-duplicate character \n            st[actual_len] = s \n            actual_len += 1 \n     \n    # clean up the extra space caused due to duplicates \n    # Note the reverse order below \n    for s in range(actual_len, len(st))[::-1]: \n        del st[s] \n \n    return st"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class RemoveAlternativeDuplicate { \n \n    public static String removeAlternateDuplicates(String str) { \n StringBuffer sb = new StringBuffer(); \n int charachters[] = new int[256]; \n char c; \n for (int i = 0; i < str.length(); i++) { \n     c = str.charAt(i); \n     if (c >= 65 && c <= 90) { \n  c += ('a' - 'A'); \n     } \n     if (charachters[c] == 0) { \n  charachters[c]++; \n  sb.append(str.charAt(i)); \n     } else { \n  charachters[c]--; \n     } \n } \n return sb.toString(); \n    } \n    public static void main(String[] args) { \n String str = \"Today is the day, yet another day\"; \n System.out.println(removeAlternateDuplicates(str)); \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.*; public class remove_alternate_duplicates{        public static void removeAlternateDuplicates(String str)     {         String output=\"\";     HashSet hs = new HashSet();     Character c;          for(int i=0;i    {         c = Character.toLowerCase(str.charAt(i));      if(hs.contains(c))      {          hs.remove(c);      }      else      {          hs.add(c);       output=output+str.charAt(i);      }     }               System.out.println(output);          }        public static void main(String [] args)     {        System.out.println(\"Enter the String\");     String str = new Scanner(System.in).nextLine();          removeAlternateDuplicates(str);          }   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It usually helps when you have input/output examples with a problem..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public  char[] removeAlternateDuplicates(String str) {  char temp [] = new char [str.length()];  temp[0] = str.charAt(0);  Bool remove = false;  for(int i = 1; i < str.length(); i++)  {   for(int j = 0; j < temp.length(); j++)   {    if(str.charAt(i) == temp.charAt(j))    {    remove = true;    }    }    if(!remove)    {     temp[i] = str.charAt(i);    }   }   return temp; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package test; \n \npublic class RemoveDuplicates { \n \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n  String s = \"Today is the day\"; \n  System.out.println(removeDuplicates(s.toLowerCase())); \n } \n \n private static char []  removeDuplicates(String s){ \n  char c [] = s.toCharArray(); \n  int [] arr = new int[256]; \n  int i = 0; \n  while(i0){ \n    arraySqueeze(c, i); \n   } \n   else{ \n    arr[s.charAt(i)]++; \n    i++; \n   }  \n  } \n  return c; \n } \n  \n private static void arraySqueeze(char[]c, int i){ \n   \n  for(int j = i+1;j"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) {   String str = \"Today is the day\";   List modStr = new ArrayList();   StringBuilder sb = new StringBuilder();   for(int i=0; i < str.length(); i++) {    if(i == 0) {     modStr.add(String.valueOf(str.charAt(i)));     sb.append(str.charAt(i));    } else {     if(!modStr.contains(String.valueOf(str.charAt(i)))) {      modStr.add(String.valueOf(str.charAt(i)));      sb.append(str.charAt(i));     }    }       }   if(modStr.size() > 0) {    System.out.println(sb.toString());   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For clarification, the question says remove *alternate* duplicate characters but the test provided is: Today is the day -> Today ishe. Isn't this just removing characters with >1 occurrences?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"map setmap(){         mapmp;         mp[' ']=false;         for(int i=0;i<=25;i++){                 mp['A'+i]=false;         //      int j=i+32;                 mp['a'+i]=false;         }         return mp;  }  string mic1(string& s){         mapmp;         mp=setmap();         int pos=-1;         for(size_t i=0;i                pos++;                 if(!mp[s[i]]){                         mp[s[i]]=true;                         mp[s[i]+32]=true;                         s[pos]=s[i];                 }                 else{                         pos--;                         mp[s[i]]=false;                         mp[s[i]+32]=false;                 }           }            return s.substr(0,pos+1); } \"mic1.cpp\" 54L, 617C"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"map setmap(){ \n        mapmp; \n        mp[' ']=false; \n        for(int i=0;i<=25;i++){ \n                mp['A'+i]=false; \n        //      int j=i+32; \n                mp['a'+i]=false; \n        } \n        return mp; \n \n} \n \nstring mic1(string& s){ \n        mapmp; \n        mp=setmap(); \n        int pos=-1; \n        for(size_t i=0;i setmap(){ \n        mapmp; \n        mp[' ']=false; \n        for(int i=0;i<=25;i++){ \n                mp['A'+i]=false; \n        //      int j=i+32; \n                mp['a'+i]=false; \n        } \n        return mp; \n \n} \n \nstring mic1(string& s){ \n        mapmp; \n        mp=setmap(); \n        int pos=-1; \n        for(size_t i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"string inputString = \"Today is the tough day\".ToLower(); \nint i = 0; \nint length = inputString.Length; \nwhile (i != length) \n{ \nfor (int j = i + 1; j <= inputString.Length - 1; j++) \n{ \nif (inputString[i] == inputString[j]) \n{ \ninputString = inputString.Remove(j, 1); \nbreak; \n} \n} \n \nlength = inputString.Length; \ni++; \n} \n \nConsole.WriteLine(inputString);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java Code Verified"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n \n \nint main() \n{ \n char c[] = \"today is the day\",*ptr = c; \n int a[256] = {0},count,strcount = 0,i; \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void removeAlternateDupChar(String str){ \n  StringBuilder sb = new StringBuilder(); \n  byte[] flag = new byte[128]; \n  for(int i = 0; i < str.length(); i ++){ \n   if(flag[str.charAt(i)] == 0){ \n    flag[Character.toUpperCase(str.charAt(i))] = (byte)1; \n    flag[Character.toLowerCase(str.charAt(i))] = (byte)1; \n    sb.append(str.charAt(i)); \n   }else{ \n    flag[Character.toUpperCase(str.charAt(i))] = (byte)0; \n    flag[Character.toLowerCase(str.charAt(i))] = (byte)0; \n   } \n  } \n  System.out.println(sb.toString()); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static string RemoveDuplicateChars(string sourceString) \n        {             \n            // Store encountered letters in this string. \n            string resultString = string.Empty; \n \n            // Loop over each character. \n            foreach (char value in sourceString) \n            { \n                // See if character is in the table. \n                if (resultString.IndexOf(value) == -1) \n                { \n                    // Append to the table and the result. \n                    resultString += value; \n                } \n            } \n            return resultString; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static string RemoveDuplicateChars(string sourceString) \n        {             \n            // Store encountered letters in this string. \n            string resultString = string.Empty; \n \n            // Loop over each character. \n            foreach (char value in sourceString) \n            { \n                // See if character is in the table. \n                if (resultString.IndexOf(value) == -1) \n                { \n                    // Append to the table and the result. \n                    resultString += value; \n                } \n            } \n            return resultString; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// for O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Console.WriteLine(\"Alternating letters string: \"); \n            string input = Console.ReadLine(); \n \n            var occurences = new Dictionary(); \n             \n            var splitInChars = input.ToCharArray(); \n            var output = string.Empty; \n \n            splitInChars.ToList().ForEach(x => \n                                              { \n                                                  int val; \n                                                  if(occurences.TryGetValue(((int)x), out val)) \n                                                  { \n                                                      if(occurences[(int)x] == 0) \n                                                        output += x;   \n                                                      occurences[(int)x]++; \n                                                  } \n                                                  else \n                                                  { \n                                                      occurences.Add((int)x, 1); \n                                                      output += x; \n                                                  } \n                                                   \n                                              }); \n            Console.WriteLine(\"Result: {0}\", output); \n \n            Console.ReadLine();"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#include #include #include using namespace std; void remove_alternate_dup(char* str) {     int len=strlen(str);     bool *h=(bool*)calloc(sizeof(bool),len);     int tail=0;     int i=0;     int flag_space=0;     while(i    {         if((str[i]>=65&&str[i]<=90)||(str[i]>=97&&str[i]<=122))         {             if(str[i]>=65&&str[i]<=90)             {                 if(h[str[i]]==0||h[str[i]+32]==0)                 {                   h[str[i]]=1;                   h[str[i]+32]=1;                   str[tail++]=str[i++];                 }                 else if(h[str[i]]==1||h[str[i]+32]==1)                  {                   h[str[i]]=0;                    h[str[i]+32]=0;                    i++;                   }              }             else if(str[i]>=97&&str[i]<=122)             {                 if(h[str[i]]==0||h[str[i]-32]==0)                 {                  h[str[i]]=1;                   h[str[i]-32]=1;                  str[tail++]=str[i++];                 }                 else if(h[str[i]]==1||h[str[i]-32]==1)                 {                   h[str[i]]=0;                    h[str[i]-32]=0;                    i++;                   }             }          }         else         {             if(flag_space==0)             {              str[tail++]=str[i++];              flag_space=1;             }             else             {                 flag_space=0;                 i++;             }            }      }      str[tail]='\\0';   } int main() {     char str[]=\"Today is the day\";     remove_alternate_dup(str);     cout<<    return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"1. Use a hashmap. 2. Scan linearly through given string. 3. For each character check if it is present in hashmap. If it is, then just remove the char from hashmap. Else, add it to hashmap and append it to new string. 4. Return new string."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Java version:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public class remove_alternate_duplicates{          public static void main(String args[])   {       String  s = \"today is the day\";    boolean b[] = new boolean[127];       String output=\"\";        for(int i=0;i   {        char c = s.charAt(i);     if(b[c])        b[c] = false;     else        {           output=output+c;        b[c] =  true;        }    }        System.out.println(output);      }   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"In C#  public static String RemoveAlterNameChar(String p) {      if (String.IsNullOrEmpty(p))     {         return null;     }     ArrayList t = new ArrayList();     foreach (char c in p)     {         if (!t.Contains(c))         {             t.Add(c);         }     }      return String.Join(\"\", t.ToArray()); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"IN C#"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5752167323402240","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"6","title":"Write code for removing alternate duplicate characters (case insensitive) in a string in place. Also give test cases.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"try it soon it will help for your micro interview"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #include using namespace std; void remove_alternate_dup(char* str) {     int len=strlen(str);     bool *h=(bool*)calloc(sizeof(bool),len);     int tail=0;     int i=0;     int flag_space=0;     while(i    {         if((str[i]>=65&&str[i]<=90)||(str[i]>=97&&str[i]<=122))         {             if(str[i]>=65&&str[i]<=90)             {                 if(h[str[i]]==0||h[str[i]+32]==0)                 {                   h[str[i]]=1;                   h[str[i]+32]=1;                   str[tail++]=str[i++];                 }                 else if(h[str[i]]==1||h[str[i]+32]==1)                  {                   h[str[i]]=0;                    h[str[i]+32]=0;                    i++;                   }              }             else if(str[i]>=97&&str[i]<=122)             {                 if(h[str[i]]==0||h[str[i]-32]==0)                 {                  h[str[i]]=1;                   h[str[i]-32]=1;                  str[tail++]=str[i++];                 }                 else if(h[str[i]]==1||h[str[i]-32]==1)                 {                   h[str[i]]=0;                    h[str[i]-32]=0;                    i++;                   }             }          }         else         {             if(flag_space==0)             {              str[tail++]=str[i++];              flag_space=1;             }             else             {                 flag_space=0;                 i++;             }            }      }      str[tail]='\\0';   } int main() {     char str[]=\"Today is the day\";     remove_alternate_dup(str);     cout<<    return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please find below java implementation:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void removeALTERNATEDuplicates(char str[],int n){ \n int letters [256]; \n int i = 0; \n int index=0; \n for(i=0;i<256;i++) \n  letters[i]=0; \n for(i=0; i= 65 && str[i] <= 90){ \n   lowerCase +=('a' - 'A'); \n  } \n  if(letters[lowerCase] == 0){ \n   letters[lowerCase]++; \n   str[index++]=str[i]; \n  }else{ \n   letters[lowerCase]--; // We want to Alternate \n  } \n } \n while(index < i){ \n  str[index++]= 0; \n } \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5926096587456512","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"8","title":"You have three covered baskets labelled \"Apples\", \"Oranges\" and \"Mixed.\" All of them are labelled incorrectly. Choosing only one fruit from one of the baskets (and not peeking inside), how can you determine how to relabel the baskets?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"always picking from the basket labelled \"mixed\".  If picking an apple, this \"mixed\" is actually apple basket, the one labelled \"orange\" is actually mixed basket. The left one is orange basket.  If picking an orange,  the one labelled \"mixed\" is  orange, the one labelled \"apple\" is mixed basket, and the left one is apple."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can you explain better please?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Suppose Basket labelled \"Apples\" is Basket#1,   Basket labelled \"Oranges\" is Basket#2, and  Basket labelled \"Mixed\" is Basket#3.  Take a fruit from the Basket#3.  If the fruit picked is Apple, take the \"Apples\" label from the Basket#1 and place it on Basket#3 and we are done. Basket#2 will be labelled with \"Mixed\", Basket#1 will be labelled as \"Oranges\" from the fact that all baskets are labelled incorrectly.   Same logic goes in case the fruit taken turns out to be Orange."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This question was already asked: id=5428361417457664"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"okay... So lets pick from basket 'Mixed'  (it can be either Orange or Apple, as its not mixed) Case 1 : its an Orange Result : Now, 'Mixed' becomes 'Orange', and we left with two baskets, Orange & Apple, label 'Orange' as 'Apple' and 'Apple' as 'Mixed' because we know they are wrongly labeled and we already got Orange basket in first step.  Case 2: we got an apple Result : mark 'Mixed' as Apple, and A -> O and O -> M"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Excellent answer"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4800196680613888","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"6","title":"You have a gold bar with seven segments. For seven days, you must pay an employee with one gold segment each day. Breaking the bar only twice, how can you ensure the employee gets paid appropriately?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"You break the bar so that you get 1 peace, 2 peaces and 4 peaces.   **** | ** | * first day you give 1 peace 2dn you give the one with 2 and get back the other with only 1 3rd you give the 2 and 1 4.- you give the one with 4 5.-  4 & 1 6.- 4 & 2 7.- All"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This question can be thought of as a specialized case of the generalized problem set : Given a rod of length n, divide it into minimum number of parts such that you can generate a rod of each length from 1 to number n. For given n, 2^m<= n < 2^(m+1) , number of cuts will be m and hence numbers of parts will be m+1. In present case n=7 lies in the range [4,8), so number of cuts(divide/break) = 2 (It is true not only for 7 but all the numbers from 4 through 7) and parts = 1,2,4 (for 7)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1, 2, 4"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Thank you David!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Cut the bar Across the segment num-3 which will give u  chain   (1)-(2) ,, 3rd-segment and the rest (4)-(5)-(6)-(7) .... 1st day-give 3rd segment 2nd day-give chain 1-2 and get 3rd segment  3rd day(u have 3rd and chain 4-5-6-7): so give 3rd segment 4th day:give chain 4---7 and get 3rd and chain 1-2 5th day u have(3rd and chain1-2):so give 3rd segment 6th day- give chain 1-2 and get back 3rd segment 7th day: Give 3rd segment"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4808015567912960","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"3","title":"Design a controller for kids.  (This is a PM interview question, so you're supposed to clarify a lot to clear ambiguity before you get to an answer)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Cool"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I need one controller. Desperately.  Come back here you little***"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I will start with the basic requirements and the target users.  Target Users : Kids Age group: 0-3, 3- 10, 11 - 18? They are all different with different amounts of technical literacy and maturity. Lets consider for 0-3 and 3-10 to begin with: The controller should be: a. Light and smaller b. Strong - damage resistant against banging it, throwing it on the floor, etc. c. Water and food proof/resistant: Water and food spills shouldn't go inside it. d. Should be made up of non-toxic material (if possible with horrible taste but no odor so that even if kids lick it, they shouldn't be harmed) e. If it is wired, the juncture and the wire should be pretty strong so that it can take a good amount of stress (kids tend to swing the controllers by the wires) f. A small piece of material can be added so that the controller is slide proof - doesn't slide off an incline. g. Buttons should be easily press-able and the controller shouldn't be easy to disassemble. ----------------------------------- h. The buttons on the controller should be designed in accordance with the types of games that would be made for this age group. i. The same goes for their colors, symbols, etc.  The I would go ahead and design something with these points in mind."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6543214668414976","download_status":"DOWNLOAD_DONE","votes":"-4","answersCount":"17","title":"Write a function called FooBar that takes input integer n and prints all the numbers from 1 upto n in a new line. If the number is divisible by 3 then print \"Foo\", if the number is divisible by 5 then print \"Bar\" and if the number is divisible by both 3 and 5, print \"FooBar\". Otherwise just print the number. for example FooBar(15) should print as follows: 1 2 Foo 4 Bar Foo 7 8 Foo Bar 11 Foo 13 14 FooBar  I know, easy right? ;)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Why not add two variables to save the results of the mod operations so as to save doing them once more?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"void FooBar(int n) \n{ \n for( int i=1;  i <= n;  i++, print(\"\\n\") ) \n { \n  if( i%3 && i%5)  print( i ), continue; \n  if( i % 3 ==0)   print( \"Foo\"); \n  if( i % 5 ==0)    print( \"Bar\"); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void FooBar(int n){ \n  for(int i=1;i<=n;i++){ \n    \n   if(i%5!=0 && i%3!=0){ \n    System.out.println(i); \n    continue; \n   } \n   if(i%3==0){ \n    System.out.print(\"Foo\"); \n   } \n   if(i%5==0){ \n    System.out.print(\"Bar\"); \n   } \n   System.out.println(); \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My husband is at it again  ripsid is my hubs"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Typical of microsoft. Copy others and give their own boring name.  Fizz -> Foo Buzz -> Bar."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void fooBar(int n) { \n for (int i = 1; i <= n; i++) { \n     if (i % 3 == 0 && i % 5 == 0) { \n  System.out.println(\"FooBar\"); \n     } else if (i % 3 == 0) { \n  System.out.println(\"Foo\"); \n     } else if (i % 5 == 0) { \n  System.out.println(\"Bar\"); \n     } else { \n  System.out.println(i); \n     } \n } \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how about n is negative number"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Seriously? Microsoft really asked this question?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void FooBar(int n){ \n   \n  for(int i=1;i<=n;i++){ \n   if(i%3==0 && i%5==0){System.out.println(\"FooBar\");} \n   else if(i%3==0){System.out.println(\"Foo\");} \n   else if(i%5==0){System.out.println(\"Bar\");} \n   else{System.out.println(i);} \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void FooBar(int n){      for(int i=1;i<=n;i++){    if(i%3==0 && i%5==0){System.out.println(\"FooBar\");}    else if(i%3==0){System.out.println(\"Foo\");}    else if(i%5==0){System.out.println(\"Bar\");}    else{System.out.println(i);}   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"F#:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"string temp = string.Empty;             for (int i = 1; i <=15; i++)             {                 temp= (i % 3 == 0 && i % 5 == 0)?\"Foo Bar\":(i%5==0?\"Bar\":(i%3==0?\"Foo\":Convert.ToString(i)));                 lstBoxGetName.Items.Add(temp);             }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This was asked in Philips too .."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5428361417457664","download_status":"DOWNLOAD_DONE","votes":"3","answersCount":"9","title":"You have three jars filled with candies. One jar is filled with banana candies, one jar is filled with lemon candies and one jar has a mix of both. All the jars are mislabelled (i.e. all the jars have wrong labels about what kind of candies they contain). All the candies look very similar in shape, size and color and they even smell the same. The only way to distinguish them is by tasting. You have to eat one and only one candy to determine the correct jar labels. You can eat that one candy from any jar you want as long as you eat only one in total.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Suppose jar 1 is labelled lemon         jar 2 -> banana  jar 3 -> Mix Take a candy from the jar 3 which is labelled as Mix of both and eat.   Suppose it is lemon, take the lemon label from the jar 1 and place it on jar 3. Now we are done. jar 2 will be mix, jar 1 banana from the fact that all jars have wrong labels.   Same logic goes in case it turns out to be banana candy after eating."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Lets lebel them as B, L, BL  Since all have incorrect lebel, 'BL' is lebelled as either 'B' or 'L'. That's why we should not pick to taste from the jar that's either lebelled as 'B' or 'L'. Pick one from the jar which is lebelled as 'BL', if it comes out as 'B' then the one that's lebelled 'L' is 'BL', if it comes out 'L' then the one lebelled as 'B' is 'BL'."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"what is the question"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"lets say  j1 is banana j2 is lemon j3 is mix  I would eat a candy from jar j3(labeled a mixed one) and whatever I got(either banana or lemon), then this j3 must be this kind of type, it is not mix for sure. lets suppose my candy was lemon, so j3 will be lemon j1 will be mix ////it can not stay mix, because all jar labels are messed up j2 will be banana//it can not stay lemon, because all jar labels are messed up"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Suppose correctly label is 1 -> B, 2 -> L, 3 -> BL. Accroding to question, suppose all labeled incorrectly, then only two case is 1 -> L, 2 -> BL, 3 -> B or 1 -> BL, 2 -> B, 3 -> L. So that, we can deduce labelled BL is only one taste candy, then we can pick up one candy from BL, if it is B, we can reasoning backward accroding to 1 -> L, 2 -> BL, 3 -> B, instead is 1 -> BL, 2 -> B, 3 -> L. If question contain which one label is correctly, then I think we need more condition to solve it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Legend: B for banana, L for Lemon , BL for mix  You don't consider anything you just pick one candy from the jar labelled BL and here you have two cases  1- if its lemon then you stick \"L\" to it and stick the \"BL\" to the jar labelled \"B\" and finally the \"BL\" should be placed on the final jar which is previously labelled \"L\". 2- if its banana then you stick \"B\" to it and stick the \"BL\" to the jar labelled \"L\" and finally the \"BL\" should be placed on the final jar which is previously labelled \"B\"."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"As far as questions go, this is pointlessly easy and uninformative when people do/don't get it.  I have seen this asked as: \"provided a strategy for figuring out which jar is which, while minimizing candy consumption\", which is slightly harder in practice, but tends to be more informative."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6282862240202752","download_status":"DOWNLOAD_DONE","votes":"4","answersCount":"43","title":"Given an integer array. Perform circular right shift by n. Give the best solution.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"void reverse(int A[], int start, int end) \n{ \n while(start < end) \n  swap(A[start++], A[end--]); \n} \n \n//shift A[0??sz-1] by n (n>0) \nvoid shiftArray(int A[], int sz, int n) \n{ \n n = n%sz; \n reverse(A, 0, sz-1); \n reverse(A, 0, n-1); \n reverse(A, n, sz-1); \n return; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"public static void circularShift(int[] inputArray, int shiftSize) { \n        if (inputArray.length <= 1) { \n            System.out.println(\"Array must have more than one integer.\"); \n \n        } else { \n            System.out.println(\"Before shift:--\"); \n            for (int temp : inputArray) { \n                System.out.println(temp); \n            } \n            int i = 0; \n            int[] outputArray = new int[inputArray.length]; \n            while (i < inputArray.length) { \n                int k = (shiftSize + i) % inputArray.length; \n                outputArray[k] = inputArray[i]; \n                i++; \n            } \n            System.out.println(\"After shift:--\"); \n            for (int temp : outputArray) { \n                System.out.println(temp); \n            } \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"C++ implementation with O(n) time and O(1) space using tail recursion."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int[] reverse(int[] A, int shifts) \n { \n  int[] temp = new int[A.length * 2]; \n  System.arrayCopy(A, 0, temp, 0, A.length); \n  System.arrayCopy(A, 0, temp, A.length, A.length); \n \n  shifts = shifts % A.length; \n  int[] result = new int[A.length]; \n  System.arrayCopy(temp, shifts - 1, result, 0, A.length); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The catch is to do it in place. No use of temporary array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"With a temp buffer of size n (or within a larger permanent buffer assigned to this task) we can:  N copies of last n elem. Of array into temp. A.len-N copies of array's first elements from very front to very end. Copy N elements from temp to start of array.  In total (a.len+N) writes."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for N is the size of the array and n < N/2 the following would work"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int size = array.Length; \n            int i1 = 0; \n            int i2 = size - shift; \n \n            while (i1 < size-1) \n            { \n                swap(i1, i2, array); \n                i1++; \n                i2++; \n                i2 = i2 == size ? size - shift : i2; \n            }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class CircularShiftArray { \n \n \n public static void main(String[] args) { \n  int[] array = {2,5,1,8,10}; \n  shiftArray(array,2); \n } \n \n private static void shiftArray(int[] array, int n){ \n  int length = array.length; \n  int i =0,temp = array[0],temp2 =0, count = 0; \n  while(count!=length){ \n   int newIndex = (i+n)%length; \n   temp2 = array[newIndex]; \n   array[newIndex] = temp; \n   temp = temp2; \n   count++;i = newIndex; \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"best sol would be if a swap gets minimized and in one shot the elements gets reolcation to right position.  for example : if we have array of size 6 and 4 shifts has to be done then a[(i+s)%n]  = a[i]  a[0] =a[4] a[4] = a[2] a[2] =a[0] and so on   number of actual shift s = k % n  for( i=0 ; i < n/3 ; i++) {    temp = a[i];    for(j=1; j < 4 ; j++)    {            next = ( i + j*s)%n        //swap the contents of a[next] and temp        temp1 = a[next]         a[next] = temp           temp = temp1     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(N) time, O(N) space... determine new position in array for bucket, move into temporary array, determine for next bucket etc..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The O(N) time and O(1) space looks optimal for small tables"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include   #define S 5  void show(int* w, int size) {  printf(\"-------------\\n\");  for (int e = 0; e < size; ++e)   printf(\"%d \\n\", w[e]); }  int main() {  int tab[S] = { 1, 2, 3, 4, 5 };   int shift = 2;  int* w = new int[shift];  for (int k = 0; k < shift; ++k)   w[k] = tab[S - k - 1];   show(w, 2);   int tmp = S - shift - 1;  int dek = S - 1;  for (int z = tmp; z >= 0; --z)   tab[dek--] = tab[z];   int k = 0;  for (int e = shift - 1; e >= 0; --e)   tab[k++] = w[e];   show(tab, 5);   system(\"pause\");  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \n#define S 5 \n \nvoid show(int* w, int size) \n{ \n printf(\"-------------\\n\"); \n for (int e = 0; e < size; ++e) \n  printf(\"%d \\n\", w[e]); \n} \n \nint main() \n{ \n int tab[S] = { 1, 2, 3, 4, 5 }; \n \n int shift = 2; \n int* w = new int[shift]; \n for (int k = 0; k < shift; ++k) \n  w[k] = tab[S - k - 1]; \n \n show(w, 2); \n \n int tmp = S - shift - 1; \n int dek = S - 1; \n for (int z = tmp; z >= 0; --z) \n  tab[dek--] = tab[z]; \n \n int k = 0; \n for (int e = shift - 1; e >= 0; --e) \n  tab[k++] = w[e]; \n \n show(tab, 5); \n \n delete[] w; \n \n system(\"pause\"); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void shiftRight( int[] arr, int shift ){ \n   \n  if( arr == null ){ \n   throw new IllegalArgumentException(\"NULL 'arr' parameter passed\"); \n  } \n  if( arr.length < 2 ){ \n   return; \n  } \n   \n  if( shift % arr.length  == 0 ){ \n   return; \n  } \n   \n  int index = 0; \n  int prev = arr[0]; \n   \n  do{    \n   int newIndex  = (index+shift) % arr.length; \n   int temp = arr[newIndex]; \n    \n   arr[newIndex] = prev; \n   prev = temp; \n   index = newIndex;     \n  } \n  while(prev != arr[index]); \n   \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this  run a while loop for length of array. shift first element to n after copying a[n]th element to a local variable(k). Now k will be copied to n1=(n+n)%len.  Similarly copy the existing element of the array and put the shifted element."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void Shift(int[] array, int n) \n        { \n            if (array.Length <= 1 || n == 0) \n            { \n                return; \n            } \n \n            n = n % array.Length; \n \n            int i = 0; \n            int k; \n            int lastItem, temp; \n            lastItem = array[0];             \n \n            while (true) \n            { \n                k = (i + n) % array.Length; \n                temp = array[k]; \n                array[k] = lastItem; \n                lastItem = temp; \n                i = k; \n \n                if (i == 0) \n                { \n                    break; \n                } \n            } \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nmain() \n{ \n int i,n,temp,var; \n int a[]={1,2,3,4,5,6,7,8,9}; \n printf(\"\\nEnter the shifting no: \"); \n scanf(\"%d\",&n); /*right shift the array by n*/ \n for(;n;n--) \n { \n  var=a[0]; \n  for(i=1;i<=9;i++) \n  { \n   temp=a[i%9]; \n   a[i%9]=var; \n   var=temp; \n  } \n } \n getch(); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) { \n  int[] array = {2,5,1,8,10,12,4,15}; \n  shiftArray(array,3); \n  MyUtilities.PrintArray(array); \n } \n \n public static void Reverse(int[] A,int first, int last) { \n  while(first < last){ \n   MyUtilities.Swap(A, first, last); \n   first++;last--; \n  } \n } \n private static void shiftArray(int[] array, int n){ \n  if(n0){ \n   Reverse(array,0,array.length-1); \n   Reverse(array,0,n-1); \n   Reverse(array,n,array.length-1); \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def s(l,n): \n n%=len(l) \n a=len(l)-n \n b=a+n \n i,j=a-n,b-n \n if i<0: \n  i=0 \n if j<0: \n  j=0 \n while a>0: \n  l[a:b],l[i:j]=l[i:j],l[a:b] \n  i,j,a,b=i-n,j-n,a-n,b-n \n  if i<0: \n   i,j=0,a \n return l"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"c++  #include   static void shiftArray(int shift, int arr[], int length ) {  int *tmp = new int[length];  memcpy(tmp, arr + (length-shift), sizeof(int)*shift);  memcpy(arr + shift, arr, sizeof(int)*(length-shift));  memcpy(arr, tmp, sizeof(int)*shift); }  int main(int argc, char* argv[]) {  int arr[] = {1,2,3,4,5,6,7,8,9};  shiftArray(3, arr, sizeof(arr)/sizeof(*arr));  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static void CircularRightShiftForArrayOfIntegers(int[] inputArray, int shift)         {             int[] outputArray = new int[inputArray.Length];             int i = 0;              while (i != inputArray.Length)             {                 if (i + shift == inputArray.Length)                 {                     shift = -i;                                    }                                  outputArray[i + shift] = inputArray[i];                  i++;             }              Console.WriteLine(string.Join(\" \", outputArray));         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int[] outputArray = new int[inputArray.Length]; \n            int i = 0; \n \n            while (i != inputArray.Length) \n            { \n                if (i + shift == inputArray.Length) \n                { \n                    shift = -i;                    \n                } \n                 \n                outputArray[i + shift] = inputArray[i]; \n \n                i++; \n            } \n \n            Console.WriteLine(string.Join(\" \", outputArray));"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void circle(int n)         {                         int j = -1;             int[] aInt = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };             int[] aInt1 = new int[aInt.Length];             for (int i = n; i < aInt.Length ; i = i + 1)             {                 j++;                 aInt1[j] = aInt[i];                             }             for (int i = 0; i < n; i = i + 1)             {                 aInt1[aInt.Length - n + i] = aInt[i];             }         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void circle(int n)         {                         int j = -1;             int[] aInt = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };             int[] aInt1 = new int[aInt.Length];             for (int i = n; i < aInt.Length ; i = i + 1)             {                 j++;                 aInt1[j] = aInt[i];                             }             for (int i = 0; i < n; i = i + 1)             {                 aInt1[aInt.Length - n + i] = aInt[i];             }         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this: jump with step n, e.g. starting from index 0, n, 2*n, .... and swap their values. Do that n times with starting points in n first elements. O(N) time, O(1) memory."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class CircShift { \n    public static void main(String[] args){ \n    int[] array=new int[]{0,1,2,3,4} ; \n    int[] newarray=new int[5]; \n    int shiftsize=2; \n \n    for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"github.com/techpanja/interviewproblems/tree/master/src/arrays/circularshiftintarray"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int count =0,i=0,prev=arr[0],newInd,temp; while(count count++;  newInd = (i+shift)%n;  temp = arr[newInd];  arr[newInd] = prev;  prev = temp;  i = newInd; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"Msft asking toughest questions on the weekends f2f int. I can see that. Maybe we can use A* search for this? I know the one guy who always posting A* as answer will suggest for this heuristic of A*.  The question is a little bit tougher for intwrview in the face of face. It might take one week think to produce code with quartic runtimes and spaces."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5141226646929408","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"11","title":"Given two strings remove duplicates and test it","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please provide some more data... or at least an example.  Data insufficient."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def string_duplicate(a,b):     set_result = set(a) and set(b)     result = ''.join(list(set_result))     return result"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class RemoveDuplicates  {          private static String str1;     private static String str2;     private static boolean flag=false;      private static int i;    public static void main(String [] a)     {      str1=a[0];      System.out.println(\"1st Input: \"+ str1);      str2=a[1];      System.out.println(\"2nd Input: \"+ str2);      new RemoveDuplicates().remover(str1,str2);         }     public void remover(String s1, String s2)  {       String token = \"\\\\ \";    String [] fs = s1.split(token);    String [] ss = s2.split(token);    for( i=0;i          {     if(fs[i]!=null)     {     int j=0;       do    {       while(ss[j]==null)        {     j++;         }             if(fs[i].equals(ss[j]))         {          ss[j]=null;          flag=true;               }    j++;    }while(j     int k=i+1;                        do    {                             if(k==fs.length)                               break;       while(fs[k]==null)        {     k++;                                  if(k==fs.length) break;               }         if(k==fs.length)                               break;                          if(fs[i].equals(fs[k]))         {          fs[k]=null;          flag=true;          }    k++;    }while(k             }     if(flag)       {      fs[i]=null;      flag=false;       }         }     System.out.println (\"Post Removal of Duplicate Strings \");  System.out.print (\"1st String becomes: \");  for(String s: fs)  {     if(s!=null)            {             System.out.print(s + \" \");            }  }  System.out.println();     System.out.print (\"2nd String becomes: \");  for(String s: ss)  {     if(s!=null)       System.out.print(s + \" \");  }     }    }    ============================== OUTPUT: ======= 1st Input: Subham is good boy Subham 2nd Input: Subham is not a good girl Post Removal of Duplicate Strings  1st String becomes: boy  2nd String becomes: not a girl"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Remove duplicates of chars as well? removed duplicates from one of the strings? What happens if you get the following 2 strings: \"aa\", \"aa\"?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"check_duplicate( char * S1, char * S2) {      //Hash both strings S1 and S2 with a Key = tolower(S[i]) - 'a';      // length of String S1 : S1len = strlen(S1); S2len = strlen(S2);            for (i = 0; i < S1len; i++) {          key =  tolower(S1[i]) - 'a' ;            A[ key ] = A[key] + 1;      }            for (i = 0; i < S2len; i++) {          key =  tolower(S2[i]) - 'a' ;            A[ key ] = A[key] - 1;      }       // Now check the hash value for S1, find out duplicates and copy the not duplicates to            target array      for (i = 0; i  <  S1len ; i++) {           key = tolower(S1[i]) - 'a';           if ( A[ key ] != 0) target1[i] = S1[i];      }        // Now check the hash value and find out duplicates in S2 and copy not duplicates to target2      for (i = 0; i  <  S2len ; i++) {           key = tolower(S2[i]) - 'a';           if ( A[ key ] != 0) target2[i] = S2[i];      } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public List RemoveDupInStr(string str1, string str2)         {             List Res = new List();             List CommonStr = new List();              for (int i = 0; i < str1.Length; i++)             {                 if (Res.Contains(str1[i]))                 {                     CommonStr.Add(str1[i]);                 }                 else                 {                     Res.Add(str1[i]);                 }              }              for (int i = 0; i < str2.Length; i++)             {                 if (Res.Contains(str2[i]))                 {                     CommonStr.Add(str1[i]);                 }                 else                 {                     Res.Add(str2[i]);                 }             }             return Res;         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public List RemoveDupInStr(string str1, string str2)         {             List Res = new List();             List CommonStr = new List();              for (int i = 0; i < str1.Length; i++)             {                 if (Res.Contains(str1[i]))                 {                     CommonStr.Add(str1[i]);                 }                 else                 {                     Res.Add(str1[i]);                 }              }              for (int i = 0; i < str2.Length; i++)             {                 if (Res.Contains(str2[i]))                 {                     CommonStr.Add(str1[i]);                 }                 else                 {                     Res.Add(str2[i]);                 }             }             return Res;         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"You make this website into a easy jungle.  -Guest DS"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"import java.util.*; \n \npublic class Recusiveley_Remove_all_Duplicates { \n \n public static void main(String[] args) { \n  // TODO Auto-generated method stub \n  Scanner in = new Scanner(System.in); \n  String str = \"\"; \n  str = in.next(); \n  System.out.println(\"Initial String is: \" + str); \n  System.out.println(\"Removing Duplicates ...\"); \n  String retVal =\"\"; \n  int initialLength = 0; \n  int finalLength = str.length(); \n  retVal = str; \n  /* Check if string is of length 1 or 0 */ \n  if(str.length() == 1 || str.length() == 0) \n  { \n   initialLength = finalLength; \n  } \n  while(initialLength != finalLength) \n  { \n   initialLength = finalLength; \n   retVal = removeDuplicates(retVal); \n   finalLength = retVal.length(); \n  } \n  System.out.println(\"Final String is: \" + retVal); \n  in.close(); \n } \n  \n public static String removeDuplicates(String strVal) \n { \n  int ctr = 0; \n  for(int i=1; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#include  \n#include  \n#include  \n \nusing namespace std; \n \n#define S 6 \n \nint main() \n{ \n string n1 = \"aabbb\", n2 = \"aaaa\"; \n \n int s1 = n1.length(), s2 = n2.length(); \n int bigger = ((s1 > s2) ? s1 : s2); \n int smaller = ((s1 < s2) ? s1 : s2); \n \n for (int z = 0; z < bigger; ++z) \n { \n  char c = n1[z]; \n  for (int j = 0; j < smaller; ++j) \n  { \n   if (c == n2[j]) \n   { \n    n1[z] = '*'; \n    n2[j] = '*'; \n    break; \n   } \n  } \n } \n cout << \"n1 : \" << n1 << endl; \n cout << \"n2 : \" << n2 << endl; \n \n string score1 = \"**bbb\", score2 = \"**aa\"; \n assert(score1==n1); \n assert(score2 == n2); \n \n system(\"pause\"); \n return 0; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5783246948270080","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"11","title":"Given a function to reverse a linked list write code to test the function","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"They have just asked us to write a code to test the reverse function written to reverse a linked list.  Assume"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"typedef struct LinkList \n     { \n                  int info; \n                  struct LinkList *next; \n     } node; \n      \n     node *start; \n \n     void ReverseList(node** start) \n     { \n                node *prev, *curr, *nnext; \n                prev = (node*) NULL; \n                curr = *start; \n                nnext = curr->next; \n                curr->next = (node*) NULL; \n                while(nnext != (node*)NULL) \n                { \n                                prev = curr; \n                                curr = nnext; \n                                nnext = curr->next; \n                                curr->next = prev; \n                 } \n                 *start = curr; \n      }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ListNode *reverse(ListNode *head) \n        { \n              if(head == NULL || head->next == NULL) \n   return head; \n \n       ListNode *temp = head->next; \n       ListNode *retP =  reverse(temp); \n       temp->next = head; \n       head->next = NULL; \n       return retP; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This maybe not the most elegant of the code. However, it works:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void checkReverseLinkedListProg() { \n  // TODO Auto-generated method stub \n \n  LinkedList L1 = new LinkedList(); \n  LinkedList L2 = new LinkedList(); \n \n  L1.add(\"a\"); \n  L1.add(\"b\"); \n  L1.add(\"c\"); \n  L1.add(\"d\"); \n \n  L2.add(\"d\"); \n  L2.add(\"c\"); \n  L2.add(\"b\"); \n  L2.add(\"a\"); \n \n  ListIterator it1 = L1.listIterator(); \n \n  Iterator it2 = L2.descendingIterator(); \n \n  String a = null; \n  String b = null; \n  String flag = \"true\"; \n  while(it1.hasNext()){ \n   if((a=it1.next()) != (b=it2.next())){ \n    flag = \"false\"; \n    System.out.println(\"function to reverse a linked list is NOT CORRECT\"); \n    break; \n   } \n  } \n  if (flag == \"true\"){ \n   System.out.println(\"function to reverse a linked list is CORRECT\"); \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assume we're to test following reverse function"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5947744195706880","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"7","title":"Remove common characters from two strings and print the common characters and test cases","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"class a \n{ \n    public static void Main() \n    { \n        string a = \"abcde\"; \n        string b = \"bcf\"; \n        List l = new List(); \n        Dictionary dic = new Dictionary(); \n \n        for (int i = 0; i < a.Length; i++) \n        { \n            if (!dic.ContainsKey(a[i])) \n            { \n                dic.Add(a[i], 1); \n            } \n        } \n \n        for (int j = 0; j < b.Length; j++) \n        { \n            if (!dic.ContainsKey(b[j])) \n                l.Add(b[j]); \n        } \n \n        foreach (char c in l) \n        { \n            Console.Write(c); \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I'm assuming that upper are different than lower cases.  But It would be a good thing to point out to the interviewer.  Here is my algorithm:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class RemoveAndPrintCommonChar {   /*Remove common characters from two strings and print the common characters and test cases*/  public static void main(String[] args) {   String string1 = \"ahob6n\";   String string2 = \"javbrho\";  //  char[] arrayofChar = string1.toCharArray();   Set setOfCharString1 = new HashSet();   for (int i=0; i   setOfCharString1.add(string1.charAt(i));   }    StringBuilder duplicatebuilder = new StringBuilder();   StringBuilder string2builder = new StringBuilder();    for (int j=0; j   char a = string2.charAt(j);    if (setOfCharString1.contains(a)){     setOfCharString1.remove(a);     duplicatebuilder.append(a);    }    else{     string2builder.append(a);    }   }   System.out.println(\"String 1 without duplicates: \"+setOfCharString1.toString());   System.out.println(\"String 2 without duplicates: \"+string2builder.toString());   System.out.println(\"Duplicates among both strings: \"+duplicatebuilder.toString());   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class RemoveAndPrintCommonChar { \n \n /*Remove common characters from two strings and print the common characters and test cases*/ \n public static void main(String[] args) { \n  String string1 = \"ahob6n\"; \n  String string2 = \"javbrho\"; \n \n//  char[] arrayofChar = string1.toCharArray(); \n  Set setOfCharString1 = new HashSet(); \n  for (int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"check_duplicate( char * S1, char * S2)  {       //Hash both strings S1 and S2 with a Key = tolower(S[i]) - 'a';  Key is int      // length of String S1 : S1len = strlen(S1); S2len = strlen(S2);       if  ( S1 || S2 == NULL) return;           for (i = 0; i < S1len; i++) {            key = tolower(S1[i]) - 'a' ;           A[ key ] = A[key] + 1;     }   for (i = 0; i < S2len; i++) {  key = tolower(S2[i]) - 'a' ;  A[ key ] = A[key] - 1;  }   // Now check the hash value for S1, find out duplicates and copy the not duplicates to target array  for (i = 0; i < S1len ; i++) {  key = tolower(S1[i]) - 'a';  if ( A[ key ] != 0) target1[i] = S1[i];  }   // Now check the hash value and find out duplicates in S2 and copy not duplicates to target2  for (i = 0; i < S2len ; i++) {  key = tolower(S2[i]) - 'a';  if ( A[ key ] != 0) target2[i] = S2[i];  }  }  Testcases   1) Pass Null pointers 2) Pass one Null another valid character string. 3) Pass valid characters 4) Pass numbers and special characters 5) Pass huge characters with space separated 6) Record the time taken for the entire program"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming all characters in a string are ASCII, declare array of 128 boolean elements."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Jack williams, subbu, forgot coding, avk Punk city"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4838147984719872","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"5","title":"Delete m nodes for every n nodes in linked list and write the test cases","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Loop and skip n-m then delete m then skip n-m   Do you get the concepts?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Delete m nodes for every n nodes, then m < n ? For every 2 nodes delete 1 node, for every 5 nodes delete 3 nodes.   How do you want to delete is a question? Because one can calculate length of a list. Divide length by n. And delete quotient*m nodes from either end, front or back or can be deleted from each segment of n."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5173689888800768","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"40","title":"Complexity of a function:  int func_fibonacci ( int n) {      if (n < 2) {         return n;     } else {          return ( func_fibonacci(n-1) +  func_fibonacci(n-2));     } }","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Time complexity of Fibonacci function evaluation is Fibonacci function itself."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"O(2^n) both space and time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(\\theta^n), where \\theta = (\\sqrt(5)+1)/2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Number of function calls for the n-th fibonacci number is  1+2+2^2+2^3+...+2^(n-2) which is actually 2^(n-1) - 1 the asymptotic behavior of this expression when n -> infinity  is O(2^n) obviously"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5963086758412288","download_status":"DOWNLOAD_DONE","votes":"-8","answersCount":"12","title":"Given a result in string of pass, fail, blocked, unknown as pppppppfffffbbbbbuuuuu or pppppppppppppppfffffff or pfpfpfpfpfpfpfpfpuuuuuuuuu or any combination of characters from p,f,b, or unknown character say u or x or y or z... question is write a program which can identity a pattern like all tests passed or all tests are failing or tests started failing (blocking issue may be) or unknown pattern... this is what my friend recall if someone also faced this question and recall better explaination , please add.. interviewer asked to code the solution not algo...","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I don't think MS can ask this kind of easy question."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Dumb Mr. Rahul, try to write code for this coding (not algo) for best time and space complexity and then comment irresponsibly, without understanding problem don't be rude to questions, this forum is to share solutions to learn mutually and help each other."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"String s1=\"pppppppfffffbbbbbuuuuu\"; \n        Map cmap=new HashMap<> (); \n        for (int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ublic class CheckPatternFailPass { \n public static void checkFailPass(String st) { \n  int n = st.length(); \n  for(int i =0 ; i < n ; i++) { \n   switch(st.charAt(i)) { \n   case 'p': System.out.println(\"pass\"); break; \n   case 'f':System.out.println(\"fail\");break; \n   case 'b' : System.out.println(\"block\"); break; \n   default : System.out.println(\"unknown\"); break; \n    \n   } \n  } \n } \n  \n public static void main(String args[]) { \n  String st = \"pppppppfffffbbbbbuuuuub\"; \n  checkFailPass(st); \n   \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"highschool homework I think (please no alg, they asked for coded solution) this place is garbage lately"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Guys, don't fight, and stop abusing. I thought we are here to learn and help each other. I posted question to help people. I don't control what an interviewer is asking and personal opinion \"Only idiots can assume caliber of company based on one question\". Some of the comments made by folks here are against one of the best company in world. I wish they are never allowed to even attend tech interview's as people who cant respect a companies are not worth getting hired. They should be asked to work in alternate. In my experience in software world, it is not coding skills which makes you succeed but its mix of soft skills + coding skills which makes a person successful. Respect each and every company and questions. If you are so smart then what the fu** you have accomplished in your own life, how many interview's you cracked, whats your position in your company, who the fu** you are in this software world, anyone knows you or writes article on you.. don't take it personally but have a open minded attitude.. get right attitude first then only you can succeed in life. I am leaving this forum because of some idiots and lousy moderations of this website. There are many other forums where comments are moderated and I am better of their with educated people."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Subbu is Jack"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Will you write some code or show dumb-s ... did u complete high school or was sent back home cleaning a-s-s, show code and folks can see how good are ppl who call a question simple... rofl.. show us what you got as coding skill than talking brain less..."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6314866323226624","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"11","title":"Design remote controller for me.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Class ICommand \n execute(); \n//All command flags should be listed here,  \n//execute method will work on the basis \n//of flag value \nenum CommandTypes \n POWER_OFF, \n POWER_ON, \n - \n - \nClass  Command implements ICommand \n up() \n down() \n off() \n on() \nClass VideoCommand extends  Command \n changeVideoSettings(); \nClass AudioCommand extends  Command \n changeAudioSettings(); \npublic class Button  \n Command c;  \n        Button(Command c); \n click(); // Click will execute command \nClass Remote \n Button videoButton; \n Button audioButton; \n \n powerOn(); \n powerOff();"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Remote newRemote = new Remote(); Button newButton = new Button(color, name); Battery newBattery = new Battery(someVolt); //changes the battery newRemote.updateBatteries(newBattery); //add a button to its internal hashmap that has name associated with buttons. newRemote.addButton(newButton); //to press a button on remote you can say newRemote.getButton(\"power\").execute(); So the above end code will tell you that you need a Button class, a Battery class. To take it further. The Button class can have a execute() function. Battery could have getRemainingPower() function."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Base class button{ //common setters and getter variables //common methods declared abstract and called virtually } class channel extends button {  //channel specific getters and setters and methods }  class volume extends button {  //volume specific getters and setters and methods } class power extends button{  //power specific getters and setters and methods }  //Not sure of the below two. class battery{ }  class remote{ }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Classes you could have are..Also you could follow the Observer pattern..  /** *All actions are funneled through this class..gets the actionStr and publishes it.. */  class Remote  implements Observable { make,model,.. , List, publish() }   class Button { name, actionStr }  /** Set of common actions in the Action class and Controller also observes the changes to button's state (which is published by Remote) */ class Controller extends Action implements Observer { .. sendSignals() {..} }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Implement Command Design pattern"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Remote control for what? What is the scenario?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is it a remote controller for an alarm clock for the deaf, by any chance?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Remote controller for him ... was he going to control himself with the remote ?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4857795983704064","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"20","title":"You have 10 million IP addresses. (IPv4 4 byte addresses). Create a hash function for these IP addresses.   Hint: Using the IP's themselves as a key is a bad idea because there will be a lot of wasted space.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"@ivermette - a 6 character string would take 6 bytes while a simple 32 bit int address takes only 4 bytes if used as key."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"IPv4 is X1.X2.X3.X4 where X can be from 0 to 255, that's mean it can take 2^8 values. 4*X - is 4*8 bit and is it 4 byte.  1. we can use 4 byte as key for one element. In this case we will never have collisions. 2. we can use less then 4 byte, then the best way to impliment hash function will be to ignore first numbers, and use last (X4, X3.X4 or X2.X3.X4 dependence of how many memory we want to use) as hashkey. We use only end of id address, because in real life ip addresses usually in one area have same first 3 digits, more over in one (home/work) network they usually have same 3*3 digits. So collisions will be more evenly distributed if we skip first part."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Use trie... root with 255 branches and and then next level 255 branches....."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"or we can use multilevel hashtable"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Treat it as a 32 bit unsigned integer, and use some famous hash (google one). Or design an unsigned integer hash as per your algorithms text."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Probably naive, but I might convert the IP to a network address (long int) and convert that to base 36.  That gets it down to a 6-character unique string."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it depends how much collisions you want, just take it as 32 bit unsigned number, then for example if I want to contain it in 5 bits itself  do H(IP)=IP%31, if I want 6 bit I might do H(IP)=IP%61 something like thatbut of course the more you decrease the bits the more will be collisions so depends upon your application how much it can bear and how much space it can allocate"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If we have 32 bits of data, we could enumerate all possible values (treated as an unsigned int), but we'd use too much space if we allocated for all of them. We only need enough space to store ~10 million ints. Depending on how many collisions we want to see, we can chop off some of the bits. 2^23 = 8 million 2^24 = 16 million  We could choose to only use the lower 23 or 24 bits of the addresses. I wouldn't choose the higher 24 bits because the variability is less.  Sticking with the lower 24 bits is nicer because we chop a whole byte off our 32 bit addresses, but it may be a better idea for memory reasons to stick with the lower 23 bits instead."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Maybe question is about creating hash table? Not hash function? For this we can use Bloom filter, if some false positives are allowed."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can we use some thing like network mask 255.255.255.0 or 255.255.0.0 as a hash function......it really depends whether you need 255 buckets or 255 * 255 buckets"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think 10 million is      2^23<=10^7 <=2^24  hence with 23 bits we will have arround 1 0r 2 collosions and we will save a lots of space as compared to 24 bit has...i.e using last 3 actates//..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Largest IPv4 address can be 254.254.254.254, find out its 32 bit representation. Chose nearest prime number and hash function will be (IPv4 in 32 bit representation)%prime."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I guess a matrix of the type hash[4][32] can be used."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bloom filter"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=18582668","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"30","title":"Code to check if a given short string is a substring of a main string. Can you get a linear solution (O(n)) if possible?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"KMP algorithm/ Z algorithm."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"int substring() {     char s[]=\"AmitPratapSingh\";     char sub[] = \"ra\";     int i,j;     bool flag = false;     int str_len1,str_len2;     i = j = 0;     str_len1 = strlen(sub);     str_len2 = strlen(s);     for(j=0;j    {         if(sub[i] == s[j])         {             if( i == str_len1-1)             {                 flag = true;                 break;             }             i++;             continue;         }         else         {             i = 0;         }     }      if(flag)         printf(\"It is Substring\\n\");     else         printf(\"Not Substring\\n\");     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"string str1 = \"hello world\"; \n            string str2 = \"world\"; \n \n            int index = 0; \n \n            for (int i = 0; i < str1.Length; i++) \n            { \n                if (index < str2.Length) \n                { \n                    if (str1[i] == str2[index]) \n                        index++; \n                    else \n                    { \n                        index = 0; \n                        if (str1[i] == str2[index]) \n                            index++; \n                    } \n                } \n            } \n \n            if (index == str2.Length) \n                Console.WriteLine(\"Is Substring\"); \n            else \n                Console.WriteLine(\"Is not Substring\");"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I was able to solve it with O(n^2), but not with O(n). Also I dont think we can do it in O(n). Correct me if I'm wrong. However the interviewer did not even tell me if there exists an O(n) solution, after the interview.  this was my code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Don't assume that if you don't know the algorithm then it won't exist. Try to look out the two algorithms i mentioned in my comment ( both are almost same )."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Thanks, i'm looking into those algorithms. I didn't assume there cant be better solution than mine :), it's just that I was not aware how we can do this with a linear solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since the string is \"short\", say abc, compute the DFA for .*abc.* and run the big string through it.  KMP is apparently an optimization of this approach.  Z algorithm is neat, and a dynamic programming algorithm."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"All the given algo are O(n*m) where n is length of input and M length of substring.   A more efficient algorithm is building a Trie out of the long input string O(n) and once that is done, existence test is done in O(m) where m is length of substring."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"string parent = \"abcdef\";             string substr = \"cde\";             bool isSubstr = false;             int parentcount = parent.Length;             int substrcount = substr.Length;              char[] parentarr = parent.ToCharArray();             char[] substrarr = substr.ToCharArray();             int j = 0;              for (int i = 0; i < parentcount; i++)             {                 if (parentarr[i] == substrarr[j])                 {                     j++;                     if (j == substrcount)                     {                         Console.WriteLine(\"This is a sub string\");                         isSubstr = true;                         break;                     }                 }                 else                 {                     j = 0;                 }              }               if (!isSubstr)             {                 Console.WriteLine(\"This is not a sub str\");             }             Console.ReadLine();"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class StringExam2 {   public static void main(String[] args) {      String s1=\"thulalsi\";      String s2=\"lal\";   String s3=s1.substring(3, 6);   if(s2.equals(s3)){    System.out.println(\"equals\");   }   substringfinding(s1,s2);  }   private static void substringfinding(String s1, String s2) {      int i=0;   int len=s1.length();   int j=s2.length();   System.out.println(j);   for(i=0;i   if(s2.equals(s1.substring(i, j))){     System.out.println(\"true\");    }    else{     //System.out.println(\"j value is\"+j+\"i value is\"+i);     j++;    }   }  } }   please tell me if any wrong"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// this function will return the beginning index of substring otherwise return -1 \n public static int indexOfSubString(String str, String target){ \n  int index = -1; \n  int runner = 0;  //running index for target string \n  if(str == null || target == null || target.length() > str.length) \n   return index ; \n \n  char[] strChars = str.toCharArray(); \n  char[] targetChars = target.toCharArray(); \n  for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// Question clearly says a big string and a small string. No need for any complex algo like KMP."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def findSubString (short_str,long_str): \n if len(short_str) > len(long_str): \n  return False \n \n s = 0 \n l = 0 \n scanning = False \n found = False \n \n while l < len(long_str): \n  if scanning: \n   if long_str[l] != short_str[s]: \n    scanning = False \n    s = 0 \n   else: \n    s = s + 1 \n  else: \n   if long_str[l] == short_str[s]: \n    scanning = True \n    s = s + 1 \n   \n  l = l + 1 \n \n  if (s == len(short_str)): \n   found = True \n   break \n \n return found"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we can create a temp array to sore the occurrence of each char in the given string, and then start matching the count with the given string."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"there's this Knuth Morris Pratt's algo of substring matching that would solve this prob in linear time by using a prefix function and a string matcher.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"KMP"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am beginner, tried something..looks like it works"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i m a beginner..tried something, looks like it works"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class ShortStringIsPartOfMainString { \n \n public static void main(String[] args) { \n  String mainStr=\"abcabcabd\"; \n  String shortStr=\"abcabd\"; \n  int j = 0; \n  boolean bool=false; \n  if(mainStr.length()>shortStr.length()){ \n  for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have got to solve it in O(N). Please let me know if you think this will not work in any scenario."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void checkIfSubString(){ \n String main=\"GoogleSearchPage\".toLowerCase(); \n String substr=\"sea\".toLowerCase(); \n int j=0; \n for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public class CheckIfAStringIsASubstringOfAMainString { \n \n private static String shortStr = \"aba\"; // m characters \n private static String mainStr = \"this is an abaacus\"; // n characters \n  \n static Map hMap = new HashMap(); \n  \n public static void main(String[] args) { \n   \n  int lShort = shortStr.length(); \n  int lMain = mainStr.length(); \n   \n  if(lShort > lMain) \n  { \n   System.out.println(shortStr + \" - is not a SubString of - \" + mainStr); \n   System.exit(0); \n  } \n   \n  hMap.put(shortStr, 1); \n  for(int i = 0; i <= lMain-lShort; i++ ) // O(n-m) where n > m \n  { \n   String substring = mainStr.substring(i, i+lShort); \n   if(hMap.containsKey(substring)) // O(1) \n   { \n    System.out.println(shortStr + \" is a SubString of \\\"\" + mainStr + \"\\\" starting at position \" + i ); \n    System.exit(0); \n    // net time complexity of this search is O(n-m+1) === O(n)  \n   }    \n  } \n  System.out.println(shortStr + \" - is not a SubString of - \" + mainStr); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public static void subStringinMainString(String mainstr,String substr) \n        {    \n            String newstr = \"\"; \n            for (int i = 0; i <= mainstr.Length - substr.Length;) \n            { \n                newstr = mainstr.Substring(i, substr.Length); \n                if(newstr==substr) \n                { \n                    Console.WriteLine(newstr +\" is substring\"); \n                    break; \n                } \n                else { i++; } \n            } \n \n            if (newstr != substr) \n            { \n                Console.WriteLine(substr + \" is not substring\"); \n            } \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"I believe the complexity of my solution is O(N). In this code is used a hash function to avoid compare strings."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=18488671","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"28","title":"Given a circular linked list, find the mid element of the linked list.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"have two pointer faster and slower, increase one node for a slower and two nodes for faster pointer and see when faster pointer reach the starting node again, slower pointer will point to the middle element."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Assuming that by mid element you mean a node which is equidistant from the initial node whether you see from right or left i.e.  -1->2->3->4->1- here 3 is middle as it is equidistant from head, which points to 1, from left and right.  Algorithm :  1. Take two pointers and point them to the initial node (head). 2. Move one pointer (turtle) by one step, another pointer(rabbit) by two step. 3. if rabbit == head OR rabbit->next == head then return turtle as the mid element.  Code :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Here is a fool proof way that will take O(n).  1.) make a temp value and set it equal to head.next 2.) iterate temp through linked list while incrementing a count 3.) if temp = head break out of loop. else increment count and set temp to temp.next 4.) divide count by 2. this is how many nodes away from the head node the mid node is 5.) iterate from the head node to the mid node and return the mid node"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think we use logic of slow and fast pointer here.  code is as follow :  node * middle(node *head)  {  node *sp=NULL;         node *fp=NULL;        sp=head;  fp=head;  while(sp)              {   sp=sp->next;   fp=fp->next;   if(fp->next!=NULL)    fp=fp->next;  if(fp->data==head->data)    return sp;                 }     return NULL;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void GetMidNode(){   if(Head == null)    return;      if(Head.next == Head){    System.err.print(\"Mid Element : \" + Head.i);    return;   }      CircularNode t1,t2;   t1 = t2 = Head;      do{    t1 = t1.next;    t2 = t2.next.next;   }while(t2.next != Head);      System.out.print(\"Mid Element : \" + t1.i);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If it's circular, isn't the definition of \"mid element\" more or less an oxymoron?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int MidInCircList(struct Node *node) {  if(!node || !node->next)   return -1;  struct Node *head=node;  struct Node *first=node->next,*second=node;  while(first!=head)  {   first=first->next;   if(first!=head)   {    second=second->next;    first=first->next;   }  }  return second->data; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Use 2 pointers, one slow and other fast int middle(node* head) { node* p,*q; p=head;q=head; if(!q) while(q->next!=head && q->next->next!= head) { p=p->next; q=q->next->next; } if(q->next==head) return p->value; else return p->next->value; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It just another version of  finding middle of linked listwith following modifaction 1.Storing head in a temp variable. 2.The termination condition will now be while(p2>next!=Head&&p2->next->next !=head)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use fast & slow pointer...  Move fast pointer by 2 nodes & slow pointer by 1 node. When fast pointer takes each move check if initial node reached. At that time move slow pointer by 1. As soon as u get intial node, That is the middle node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is very close, just need the following 1. After each increment of fast pointer check if head is reached, in case list has odd number of items 2. Instead of comparing data of fast pointer to the head of data pointer, compare the fast pointer itself with the head pointer. This is in case the list has two items with the same data."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we can solve this by two pointers intialy both pointing two intial node and move first pointer to left side another to right side ..ther meeting node is the middle one"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Have to pointer objects and traverse in opposite directions. After each step, check if the both objects point to same location. When both objects point to same location, that is the mid element."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=18135677","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"28","title":"Design an algorithm to search for Anagrams of a word in a dictionary. The interviewer stressed on not processing all the words in the dictionary.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"Actually you need to find all permutations of a given word, which exists in given dictionary."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Pre-process the dictionary: Store the whole dictionary in a trie. This will give search O(1).  Now generate all the permutations of the given word and check for the generated word in dictionary.  Total time complexity: O(n!) where n is the length of the word."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"the only way i can think of is: 1. compare length. not length match means no anagrams. this will reduce a lots of words. 2. Split the remaining words in group of characters. god-> g,o,d 3. Sort the letters. and compare hash."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"did u ask how the words in a dictionary are stored ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First sort you string... Find anagrams of this string (using permutation) ( ;) they will be generated in sorted order) (I think permutation algorithms do like this) Then finding them in order in the dictionary will be easier..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#1. process only the words in the dictionary whose length equals to given words length; #2. sort the given word's letters, sort the selected word's letters form #1; #3. compare the result from #2, if equal, then fine one"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming that you can pre-process dictionary.  Pre-process dictionary. 1)  create new dict 2) for each word w1 in dictionary        sorte_w1 = sort(w1)       dict[ sorte_w1].append(w1)  Query: find all anagrams for word q 1) sorted_q = sort(q) 2)  return dict[ sorted_q]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can we decide how dictionary itself is stored?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Generate permutations of the word. 2. Binary search through the \"dictionary\" (e.g. if given as a string array, or file directories - basically, avoid loading the entire dictionary into memory). O(N! * log(P)), where N is the length of the word, and P is the number of words in the dictionary."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Dictionary Creation:  Data Structure: HashMap(AnagramHash key) contains HashMap(uniqueHash key)  hash1: anagramHash() - > Returns same hashcodes for all anagrams and not for non-anagram words hash2: unique for each word  search:  Find hash 1 and hash 2 for any word and get the info  Time: O(1) i.e constant time  Anagram search:  find hash1 and return all objects in the inner hashmap  Time: O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) from the given word, separate all the alphabets and take only those sets from the dictionary starting with those alphabets eg. given word \"god\", then tk the set of words starting with 'g','o' and 'd' 2) find the length off the given word and make a group of words with the same length. 3) that's it..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"\"interviewer stressed on not processing all the words in the dictionary.\" That's the key point in this problem. I read algo for this problem long back somewhere, it was like this :  Map each alphabet with a prime number and product of prime values of letters in a word will act as hash. Now search in the given dictionary this hash value. If dictionary has been implemented as trie then search in the trie and break from a particular word if its prime product exceeds the corresponding value for the given word.  You need to take care of oveflow by carefully chosing prime values for letters, so higher frequency letters should be given lower prime value."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sort the word...find all anagrams of the word... store the anagrams in lexicographically greater to smaller order!  find first word....in dict.. next word will b present from beginning till where first word was found... next word will b present from beginning till where second word was found... hence reducing search space on evry iteration!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Build a anagram HashMap of the dictionary itself. Key is the sorted string of characters of the words and value is a list of all the anagrams. Given a word, sort it and get the value of the sorted string from the HashMap. The list should have all the anagrams of the given words.  You only build the HashMap once. Sorting the input word has a complexity based on the sorting algorithm used (mostly O(nlogn)). Searching for list of anagrams is O(1) and looping through the list should also take O(m). Assuming the size of the word is small enough and the anagram list is mostly small, complexity should be O(1) once the HashMap of dictionary is created."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This seems the best :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"- Search only the words whose letter starts with a letters in given word. - Eliminate the dictionary words.length != given word.length."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=18235668","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"37","title":"Sort an array which only has 0's and 1's. Do not use count sort.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Just travel through the array, the first 1 found, store its position. Continue till a zero is encountered, swap the positions. Again start from the stored index of 1.  Continue till no. zero is found to the right to swap."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"static public void sortZeroOne(int[] a) { \n  if (a==null || a.length==1) return; \n  int i=0; \n  int j=a.length-1; \n  while (i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Pseudocode:  1) Find the point from start of array where zeros end 2) Find the point from end of array where ones end 3) Swap the two points 4) Increment zeros pointer by one and decrement ones pointer by one 5) Repeat steps 1-4 while (ones-zeros) > 1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this can be done in order of n. Create a new array of same size and keep two pointers - one at start and one at the end. Now traverse the original array - every time you encounter a zero, keep it to the left of the new array and increment the left counter and if 1, put it on the right and decrement the left counter."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void sort(int arr[], int len)  \n{  \none=0;  \n while(one!=len) \n {  \nif(arr[one]==1) \n {  temp=one; } \n one++;  \nif(one!=len&&arr[one]) \n { arr[temp]=0; \n arr[one]=1; \n } \n one=temp+1;  \n}  \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void SortString(char data[]) \n{ \n if (data != 0) \n { \n  int len = strlen(data); \n  if (len > 1) \n  { \n   int i = 0; \n   int j = len - 1; \n   while (i < j) \n   { \n    while(data[i] == '0') \n     ++i; \n \n    while((i < j) && (data[j] == '1')) \n     --j; \n \n    if (i < j) \n    { \n     data[i++] = '0'; \n     data[j--] = '1'; \n    } \n   } \n  } \n } \n} \n \nvoid RunDriver() \n{ \n //input \n char data[1000]; \n cin.getline(data, 1000); \n \n SortString(data); \n cout << endl << \"the sorted string is: \" << data << endl; \n} //RunDriver"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void sortIt(int *a, int n) \n{ \n int i,indx; \n \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* \n Sorts the given binary array from the index 'from' to the index 'to'. \n*/ \nvoid sortBinaryArray(int* array, int from, int to) \n{ \n   int left = from; \n   int right = to; \n \n   while (left < right) \n   { \n       if(array[left] > array[right]) /* one before zero is not ok */ \n       { \n          array[right--] = 1; \n          array[left++] = 0; \n \n          continue; \n       } \n \n       while(left < right && array[left] == 0) /* zero in the left is fine */ \n        left++; \n \n       while(right > left && array[right] == 1) /* one in the right is fine */ \n        right--; \n   } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is algo with o(n) ============================================= public class SortZeroOne {   public static void main(String[] args) {    int[] number = {0,1,1,1,0,0,0,1,1,0};   sort(number);   for(int i=0;i   System.out.println(number[i]);     }    private static void sort(int[] numbers)  {   int[] ones = new int[numbers.length];   int oneStart=-1,oneEnd = -1;      for(int i=0;i  {    if(numbers[i] == 0){     if(oneStart != -1 && oneEnd != -1 && oneEnd < ones.length){      swap(numbers,i,oneStart++);     }    }    if(numbers[i] == 1){     if(oneStart == -1 && oneEnd == -1){      oneStart = oneEnd = 0;      ones[oneEnd] = i;     }     else     {      ones[++oneEnd] = i;     }         }       }     }    private static void swap(int[] numbers,int x,int y)  {   int tmp = numbers[x];   numbers[x] = numbers[y];   numbers[y] = tmp;  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void sort(int[] arr) \n{ \n int Number_Of_Ones = 0; \n int Number_Of_Zeros = 0; \n for(int i = 0; i < arr.length; i++) \n { \n  if(arr[i] == 0) \n  { \n   Number_Of_Zeros++; \n  } \n  if(arr[i] == 1) \n  { \n   Number_Of_Ones++; \n  } \n } \n for(int i = 0; i < Number_Of_Zeros; i++) \n { \n  arr[i] = 0; \n } \n for(int i = 0; i < Number_Of_Ones; i++) \n { \n  arr[i] = 1; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void sort(int[] arr) \n{ \n int Number_Of_Ones = 0; \n int Number_Of_Zeros = 0; \n for(int i = 0; i < arr.length; i++) \n { \n  if(arr[i] == 0) \n  { \n   Number_Of_Zeros++; \n  } \n  if(arr[i] == 1) \n  { \n   Number_Of_Ones++; \n  } \n } \n for(int i = 0; i < Number_Of_Zeros; i++) \n { \n  arr[i] = 0; \n } \n for(int i = Number_Of_Zeros; i < Number_Of_Ones + Number_Of_Zeros; i++) \n { \n  arr[i] = 1; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #define size(arr) sizeof(arr)/sizeof(arr[0]) int main(){         int arr[]               = {1,0,0,0,1,0,1,1,1,0,1,1,0,1,0,0,1}, index=0,index_1=0;         int num_of_elems        = size(arr);         int *result             =malloc(num_of_elems*sizeof(int));         printf(\"Input : \");         for(;index                 printf(\"%d \", arr[index]);                 if(1 == arr[index] )                         result[num_of_elems-index-1]    = arr[index];         }         printf(\"\\nOutput : \");         for (index=0;index                printf(\"%d \", result[index]);         printf(\"\\n\");         return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi, below is the code in which no extra array is required and can be done in o(n) (also simple to understand) .  private static int[] sort(int[] a) {   int i=0;   for(int k=1;k       if(a[i]==0){     i++;     continue;    }else{     if(a[k]==0){      int temp = a[i];      a[i]=a[k];      a[k]=temp;      i++;     }else{      continue;     }    }   }   return a;  }    -- Swetha Reddy Parava"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simple code which is doing this in O(n) with just O(1) space complexity."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int[] sortZeroOne(int[] a)  \n        { \n            int lastindex = a.Length-1; \n            for (int i = 0; i <= lastindex;)  \n            { \n                if (a[i] > 0) \n                { \n                    int temp = a[i]; \n                    a[i] = a[lastindex]; \n                    a[lastindex] = temp; \n                    lastindex--; \n                    //dont increment i,we need to visit here again \n                } \n                else  \n                { \n                    i++; \n                } \n            } \n            return a; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include using namespace std;  int main() {     int arr[5];     cout<<\"enter elements\";     for(int i=0;i<5;i++)     cin>>arr[i];   int  n=4;     for(int i=0;i<=n;)     {                            if(arr[i]==0)                   i++;                   else if(arr[i]==1)                   {                   int x=arr[n];                   arr[n]=arr[i];                   arr[i]=x;                   n--;                   }                                                                   }             for(int i=0;i<5;i++)             cout<            getch();             return 0;             }                                         #include #include using namespace std;  int main() {     int arr[5];     cout<<\"enter elements\";     for(int i=0;i<5;i++)     cin>>arr[i];   int  n=4;     for(int i=0;i<=n;)     {                            if(arr[i]==0)                   i++;                   else if(arr[i]==1)                   {                   int x=arr[n];                   arr[n]=arr[i];                   arr[i]=x;                   n--;                   }                                                                   }             for(int i=0;i<5;i++)             cout<            getch();             return 0;             }                                   #include #include using namespace std;  int main() {     int arr[5];     cout<<\"enter elements\";     for(int i=0;i<5;i++)     cin>>arr[i];   int  n=4;     for(int i=0;i<=n;)     {                            if(arr[i]==0)                   i++;                   else if(arr[i]==1)                   {                   int x=arr[n];                   arr[n]=arr[i];                   arr[i]=x;                   n--;                   }                                                                   }             for(int i=0;i<5;i++)             cout<            getch();             return 0;             }                                         #include #include using namespace std;  int main() {     int arr[5];     cout<<\"enter elements\";     for(int i=0;i<5;i++)     cin>>arr[i];   int  n=4;     for(int i=0;i<=n;)     {                            if(arr[i]==0)                   i++;                   else if(arr[i]==1)                   {                   int x=arr[n];                   arr[n]=arr[i];                   arr[i]=x;                   n--;                   }                                                                   }             for(int i=0;i<5;i++)             cout<            getch();             return 0;             }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void sort(int[] input){ \n  int oneIndex=input.length-1; \n  for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"An easier approach may be to search for 0's from right and store it in a location say pos0 and 1's from left and store it in a location say pos1 Then swap them. Continue this till the pos1complexity : O(n)  Here is the code :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A simple O(n) approach"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sites.google.com/site/spaceofjameschen/home/sort-and-search/sort-an-array-which-only-has-0-s-and-1-s-do-not-use-count-sort-microsoft"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Count the number of 0s and 1s in the first pass and save the values in say variables m and n. In the second pass, convert everything to 0 until m and remaining to 1. O(n) solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void sortanarray (int *array, int length) { \n    int left = 0, right = length - 1; \n    if(array == NULL || length == 0) \n        return; \n    while (left < right ) { \n        if (array[left] == 1 && array[right] == 0) { \n            array[left++] = 0; \n            array[right--] = 1; \n        } else if (array[left] == 1) { \n            --right; \n        } else if (array[right] == 1) { \n            ++left; \n        } else { \n            ++left; \n            --right; \n        } \n    }     \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nvoid sort(int [],int); \nmain() \n{ \n int a[15]={1,1,1,0,1,1,0,1,0,0,1,1,0,0,0}; \n int i; \n clrscr(); \n sort(a,14); \n for(i=0;i<15;i++) \n { \n  printf(\"  %d\",a[i]); \n } \n getch(); \n} \nvoid sort(int a[],int n) \n{ \n int j,i=-1,p,flag=0; \n for(p=0;p<=n;p++) \n { \n       if(flag==0 && a[p]==0) \n  i++; \n       else if(flag==0 && a[p]==1) \n       { \n  j=p; \n  flag=1; \n       } \n       else if(flag==1 && a[p]==0) \n       { \n  a[j]=0; \n  a[p]=1; \n  i=j; \n  j=j+1; \n       } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"just use the partition function of quick sort.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is just the first step of quick sort"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Start from two ends left and right"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Make a linked list out of the array. 2) Traverse the linked list. for each 0 encountered, remove that node and make it the first node.  You will end up with a sorted list.  Time complexity O(n) Space complexity O(n)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=18062669","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"0","title":"Q1. What is inheritance 2. Polymorphism 3. Diff between Pure Virtual class and Virtual Class 4. Adv and dis-adv of C# and C++ over each other 5. Sequence in which constructors are called when a child class object is created and why is the order so."}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=18043680","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"24","title":"Given a rotated sorted array, find the MIN of the array.  He pointed out a mistake in my  int middle = (begin+end)/2 which could overflow if the array size was INT_MAX.  Answer was: middle = (end-begin)/2 + begin","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"public static int FindMinInRSA(int[] arr, int start, int end) \n        { \n            if (start == end) \n                return arr[start]; \n \n            if (arr[start] < arr[end]) \n                return arr[start]; \n \n            int middle = (start + end) / 2; \n \n            int small1 = (arr[start] < arr[middle] ? arr[start] : arr[middle]); \n            int small2 = (arr[middle + 1] < arr[end] ? arr[middle + 1] : arr[end]); \n \n            if (small1 < small2) \n                return FindMinInRSA(arr, start, middle); \n            else \n                return FindMinInRSA(arr, middle + 1, end); \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Given a rotated array that was sorted,  say for example  6,7,1,2,3,4,5 use :  {{ for (i  =  0; i < n - 1; i ++) {  if (a[i+1] break; } cout<<\"Minimum element is at index\"<<<\" and it's value is\"<}}   Time complexity is O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just use bisection and compare to the values at both ends of the array, it is in the book."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class MinTest { \n    public int findMinOfTwoNumbers(int i, int j) \n { \n     if(i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include using namespace std; set myset; void binarysearch(int a[],int n) {  int l=0,mid;  int h=n-1;  while(a[l]>a[h])  {   mid=(l+h)/2;   if(a[mid]>a[h])   l=mid+1;   else   h=mid;  }  myset.insert(a[1]);  myset.insert(a[l]);  set :: iterator it=myset.begin();  cout<<\"the minimum element is \"<<*it< cout<<\"the rotation is \"<<  } int main() {  int a[100];  cout<<\"enter the elements\";  cout< int n;  cin>>n;  for(int i=0;i {   cin>>a[i];  }  binarysearch(a,n); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// O(log n) steps  \nint min (int array[], int left, int right) { \n    int middle = (left + right)/2; \n    int temp; \n    if (issorted(array, left, middle)  \n        && issorted(array, middle + 1, right)) { \n        return ((array[left] < array[middle+1]) ? array[left] : array[middle + 1]); \n    } else if (issorted(array, left, middle)) { \n        temp = min (array, middle+1, right); \n        return ((array[left] < temp) ? array[left] : temp ); \n    } else if (issorted(array, middle+1, right)) { \n        temp = min (array, left, middle); \n        return ((array[middle+1] < temp) ? array[middle+1] : temp);  \n    } \n} \n \n \nint issorted (int array[], int left, right) { \n    if (array[left] < array[right]) \n        return 1; \n    else  \n        return 0;     \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"even though array contains duplicates we can use divide and conquer by little modification"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A simple modified binary search would work..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void findMin(int a[]){ \n  for(int i=0;i0){ \n    System.out.print(\"Min Elem of Arr::\"+a[i+1]); \n    break; \n   } \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int searchMin(int[] array, int s, int f){         \n        if(s == f) \n            return array[s]; \n        else if(s - f == 1) \n            return (array[s] < array[f]? array[s]: array[f]); \n        else{ \n            int mid = (f - s)/2 + s;   \n            if(array[mid] < array[mid - 1]) \n                return array[mid]; \n            else if(array[mid] < array[s]) \n                return searchMin(array, s, mid - 1); \n            else if(array[f] < array[mid]) \n                return searchMin(array, mid + 1, f); \n            else \n                return array[s]; \n        }    \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int minIndex (int *arr, int size) \n{ \n        int low = 0; \n        int mid = (size/2); \n        int high = size-1; \n \n        while (low arr[mid+1]) \n                        return mid+1; \n                if (arr[mid-1] > arr[mid]) \n                        return mid; \n                if (arr[low] < arr[high]) \n                        return low; \n                if (arr[low] < arr[mid]) \n                { \n                        low = mid+1; \n                } \n                else if (arr[low] > arr[mid]) \n                { \n                        high = mid-1; \n                } \n                mid = low + (high-low)/2; \n        } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int findNumOfShifts2(int [] A){ \n int start=0; \n int end=A.length-1;  \n while(startA[start+1]) \n   break; \n   \n  if(A[mid]A[end]) \n   start=mid; \n  else  \n   start=start+1;//fallback to linear search \n } \n return A[(start+1)%A.length];  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution in C++ below.  As mentioned in the question, it's better to write (start + end) / 2 = start + (end - start) / 2 as it doesn't imply an addition of two integers which results could be greater than INT_MAX."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"The point at which rotation has occurred can be found only in linear time. So the entire thing will take O(n), the same as finding min in any array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"My code is below with the algorithm as comments. Works even for the repeated elements."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=18065671","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"34","title":"Given a binary tree, print its perimeter:  node, left->most nodes from top to bottom, leaf nodes from left-> right, right->most nodes from bottom to top  ----------------------------1 -----------------------2--------3 ------------------4-----5-----6--------7 -------------8------9-----10------11-----12  should print: 1-2-4-8-9-5-10-11-12-7-3  5 because it doesn't have any children. 10 and 11 are children of 6 and 8 & 9 are children of 4.  Apologies for the messy diagram.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Here's a very simple solution thats O(n):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"First solution I thought of was to do it in 3 steps, the left, bottom and right sides:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"// reference stackoverflow"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Interesting question.  This is how I would solve this:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I traverse the binary tree recursively:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"you have to do 3 task for making it simple ,break in three process 1)print all the left node. 2)print all the leaf. 3)print all the right node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"function PrintPerimeter(Node n, bool isLeft, bool isRight) {  \n if( isLeft )  \n  print n  \n PrintPerimeter(n->left,isLeft,false); \n if ( n-> left == NULL AND n-> right == NULL)  \n  print n  \n PrintPerimeter(n->right,false,isRight); \n if ( isRight )  \n  print n  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* \nHelper function to print the perimeter nodes of the binary tree, recursively \nAlgorithm: \n1) Print the left edge of binary tree \n2) Print the leaves of binary tree \n3) Print the right edge of binary tree \n*/ \nvoid PrintPerimeterofBinaryTree(binaryTreeNode *root, int leftedge, int rightedge) \n{ \n if(!root) \n  return; \n \n if(leftedge) \n  printf(\"%d \\n\", root->data); \n \n PrintPerimeterofBinaryTree(root->left, leftedge && 1, 0); \n \n if(!leftedge && !rightedge && (!(root->left) || !(root->right))) \n  printf(\"%d \\n\", root->data); \n \n PrintPerimeterofBinaryTree(root->right, 0, rightedge && 1); \n \n if(rightedge) \n  printf(\"%d \\n\", root->data);  \n} \n \n/* \nFunction to print the perimeter nodes of the binary tree \nAlgorithm: \n1) Print the root of binary tree \n2) Print the perimeter nodes of left binary tree \n3) Print the perimeter nodes of right binary tree \nTime Complexity: O(n) \nSpace Complexity: is of the recursive function stack that is being used \n*/ \nvoid PrintPerimeterofCompleteBinaryTree(binaryTreeNode *root) \n{ \n if(!root) \n  return; \n \n printf(\"%d \\n\", root->data); \n PrintPerimeterofBinaryTree(root->left, 1, 0); \n PrintPerimeterofBinaryTree(root->right, 0, 1); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private void VisitPerimeter(BinaryTreeNode node, BinaryTreeNodeVisitDelegate visitor, bool isLeft, bool isRight) \n        { \n            if (node == null) return; \n            if (isLeft || isRight) \n                visitor(node); \n            else if ((node.Left == null) && (node.Right == null)) \n                  visitor(node); \n             \n            VisitPerimeter(node.Left, visitor, isLeft, false); \n            VisitPerimeter(node.Right, visitor, false,isRight); \n        } \n \n        public void VisitPerimeter(BinaryTreeNodeVisitDelegate visitor) \n        { \n            VisitPerimeter(root, visitor, true, true); \n \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question is actually a lot trickier than it seems.  I am a CS student in a high school for gifted youth in Israel. I used your site as a source for questions for our final exams, and I gave this question. One of the  students from a different class approached me after the test and pointed out that the question is not well defined, giving the following tree as an example:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is my solution (in C). it handles Yossi's example too."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Your solution does cover the example I gave, but it will print values twice (the leaf 6 will be printed 3 times), since the left and the right hand sides are the same nodes (and 6 is on both sides and is also a leaf). The only way I see around it, is to use a linked list of Tree nodes (yechhh) so you can make sure every item that you add is not already in the list, and then in the end you print the list. If it is given that the values in the tree are unique, then you can use a list of integers. Of course the question would be much more fair if you were to assume that the tree is full except for the leaves level and that the values are uniqe.  Yossi"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// Printing root node, as it is always part of perimeter. \n std::cout<value<<\"  \"; \n \n if(myBST->left) \n  perimeterTraversal(myBST->left, true, true);   // passing true, true. root->left is always on perimeter and belongs to left subtree. \n if(myBST->right) \n  perimeterTraversal(myBST->right, true, false);  // passing true, false. root->right is always on perimeter and doesn't belongs to left subtree. \n \n \n \nvoid perimeterTraversal(BST *tree, bool isOnPerimeter, bool isInLeftSubtree) \n{ \n if(tree) \n {  \n  if(tree->left == NULL && tree->right == NULL) \n  { \n   // Node is a leaf node, which is always on perimeter. \n   std::cout<value<<\"  \"; \n  } \n  else \n  { \n   // Node is not a leaf node. \n   if(isOnPerimeter)  // This means that current node is on perimeter. \n   {   \n    std::cout<value<<\"  \"; \n \n    if(tree->left != NULL && tree->right == NULL)  // If there is only left child, traverse that and it would be on perimeter. \n     perimeterTraversal(tree->left, true, isInLeftSubtree); \n    else if(tree->left == NULL && tree->right != NULL) // If there is only right child, traverse that and it would be on perimeter. \n     perimeterTraversal(tree->right, true, isInLeftSubtree); \n    else if(tree->left != NULL && tree->right != NULL) // If there are two children, check current node belongs to which subtree. \n    { \n     if(isInLeftSubtree)  // It's a part of left subtree, left child will be on perimeter not right. \n     { \n      perimeterTraversal(tree->left, true, isInLeftSubtree); \n      perimeterTraversal(tree->right, false, isInLeftSubtree); \n     } \n     else     // It's a part of right subtree, right child will be on perimeter not left. \n     { \n      perimeterTraversal(tree->left, false, isInLeftSubtree); \n      perimeterTraversal(tree->right, true, isInLeftSubtree); \n     } \n    } \n   } \n   else   // This node is not on perimeter, travese both child for leaf nodes. \n   { \n    perimeterTraversal(tree->left, false, isInLeftSubtree); \n    perimeterTraversal(tree->right, false, isInLeftSubtree); \n   } \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"you have to do 3 task for making it simple ,break in three process 1)print all the left node. 2)print all the leaf. 3)print all the right node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"psuedocode: 1) preorder of left subtree only (including root but excluding leafs) 2) leafs of left subtree 3) leafs of right subtree 4) postorder of  right subtree only (excluding leafs)  Code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static bool flag = false; \n        static bool returnFlag = false; \n        static void PrintPrimeter(TreeNode cur) \n        { \n            if (cur != null) \n            { \n                if (cur.Left != null || cur.Right != null) \n                { \n                    //Do PreOrder and Print each number on the road. \n                    if (!flag) Console.WriteLine(cur.Value); \n                    PrintPrimeter(cur.Left); \n                    PrintPrimeter(cur.Right); \n                     \n                    //Print everything when we quite the recursion \n                    if (returnFlag) Console.WriteLine(cur.Value); \n                } \n                else \n                { \n                    //When we hit the first leaf node.  \n                    //Start to print nothing but all leaf  \n                    flag = true; \n                    Console.WriteLine(cur.Value); \n \n                    //Until we hit the most right node which is also the last leave node \n                    //We set the returnFlag to quite the recursion \n                    if (cur == MostRightTreeNode) returnFlag = true; \n                } \n            } \n        } \n \n        static TreeNode MostRightTreeNode = null; \n        static bool rflag = false; \n        static void FindRightMostNode(TreeNode cur) \n        { \n            if (cur != null) \n            { \n                if (cur.Left != null || cur.Right != null) \n                { \n                    if (!rflag) FindRightMostNode(cur.Right); \n                    if (!rflag) FindRightMostNode(cur.Left); \n                } \n                else \n                { \n                    MostRightTreeNode = cur; \n                    rflag = true; \n                } \n            }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static printPremier (Node root, State s) { \n  if (root == null) return; \n \n  switch (s) { \n   case ROOT: \n    System.out.println(root.value()); \n    printPremier(root.left(),State.LEFT); \n    printPremier(root.right(),State.RIGHT); \n   case LEFT: \n    System.out.println(root.value()); \n    printPremier(root.left(),State.LEFT); \n    printPremier(root.right(),State.INTERNAL); \n    break; \n   case INTERNAL: \n    if (root.left() == null && root.right() == null) { \n     System.out.println(root.value()); \n    } else { \n     printPremier(root.left(),State.INTERNAL); \n     printPremier(root.right(),State.INTERNAL); \n    } \n    break; \n   case RIGHT: \n    printPremier(root.left(),State.INTERNAL); \n    printPremier(root.right(),State.RIGHT); \n    System.out.println(root.value()); \n    break; \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this: 1) Root node and leaf nodes will be there in the perimeter. For all other nodes: 2) If the depth of the tree is n, then for first and last nodes of any level i will be in the perimeter.   3) the order in which the answer has to be printed can be determined by traversing the tree and checking for each node if it is filtered out by step 1 or 2."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void PrintPerimeter(node *root, bool isleft, bool isright) \n{ \n if (!root)  \n     return; \n \n if (!root->l && !root->r) \n { \n     printf(\"%d \", root->data); \n     return;   \n } \n \n if (isleft) \n     printf(\"%d \", root->data); \n \n PrintPerimeter(root->l, isleft, false); \n PrintPerimeter(root->r, false, isright); \n  \n if (isright) \n     printf(\"%d \", root->r);  \n \n} \n \nint main() \n{ \n ...... \n \n     PrintPerimeter(root,true,true);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #define true 1 #define false 0 struct tree{  struct tree *lc; int data; struct tree *rc; };  void insert(struct tree **root,int num) {  struct tree *temp=*root;   if(*root==NULL)  {  (*root)=(struct tree *)malloc(sizeof(struct tree));  (*root)->lc=NULL;  (*root)->rc=NULL;  (*root)->data=num;  return;  }   else  {    if(numdata)   {   insert(&(temp->lc),num);   }    else   {   insert(&(temp->rc),num);   }  }  }   void treeleftperi(struct tree *root,int a) {  if(root==NULL)  return;     if(a==0)  {  printf(\" %d\",root->data);  }  if(root->rc!=NULL && a==0 && root->lc==NULL)  {  printf(\" %d\",root->rc->data);  }   treeleftperi(root->lc,0);  treeleftperi(root->rc,1); }  void treerightperi(struct tree *root,int a) {  if(root==NULL)  return;      if(a==1)  {  printf(\" %d\",root->data);  }  if(root->lc!=NULL && a==1 && root->rc==NULL)  {  printf(\" %d\",root->lc->data);  }   treerightperi(root->rc,1);  treerightperi(root->lc,0); }  void treeperi(struct tree *root) {  treeleftperi(root->lc,0);  treerightperi(root->rc,1); }   int main() { struct tree *st=NULL;  int arr[]={50,30,70,20,40,60,80,21,65}; int n=sizeof(arr)/sizeof(arr[0]); int i;  for(i=0;i{  insert(&st,arr[i]); }  printf(\"\\n\");  treeperi(st); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #define true 1 #define false 0 struct tree{  struct tree *lc; int data; struct tree *rc; };  void insert(struct tree **root,int num) {  struct tree *temp=*root;   if(*root==NULL)  {  (*root)=(struct tree *)malloc(sizeof(struct tree));  (*root)->lc=NULL;  (*root)->rc=NULL;  (*root)->data=num;  return;  }   else  {    if(numdata)   {   insert(&(temp->lc),num);   }    else   {   insert(&(temp->rc),num);   }  }  }   void treeleftperi(struct tree *root,int a) {  if(root==NULL)  return;     if(a==0)  {  printf(\" %d\",root->data);  }  if(root->rc!=NULL && a==0 && root->lc==NULL)  {  printf(\" %d\",root->rc->data);  }    if(a==1 && root->rc!=NULL && root->lc==NULL)  {  printf(\" %d\",root->rc->data);  }   treeleftperi(root->lc,0);  treeleftperi(root->rc,1); }  void treerightperi(struct tree *root,int a) {  if(root==NULL)  return;      if(a==1)  {  printf(\" %d\",root->data);  }  if(root->lc!=NULL && a==1 && root->rc==NULL)  {  printf(\" %d\",root->lc->data);  }   if(a==0 && root->lc!=NULL && root->rc==NULL)  {  printf(\" %d\",root->lc->data);  }     treerightperi(root->rc,1);  treerightperi(root->lc,0); }  void treeperi(struct tree *root) {  treeleftperi(root->lc,0);  treerightperi(root->rc,1); }   int main() { struct tree *st=NULL;  int arr[]={50,30,70,20,40,60,80,21,65,22,23}; int n=sizeof(arr)/sizeof(arr[0]); int i;  for(i=0;i{  insert(&st,arr[i]); }  printf(\"\\n\");  treeperi(st); }  It is correct"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=18063672","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"17","title":"Given a Binary tree and a node, return it's post-order predecessor","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"To find the postorder predecessor of node u: If u has a right child, r, then pred(u) is r. Otherwise If u has a left child, l, then pred(u) is l. Otherwise if u has a left sibling, ls, then pred(u) is ls Otherwise if u has an ancestor, v, which is a right child and has a left sibling, vls, then pred(u) is vls Otherwise, pred(u) is undefined."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"The simplest way is to save the predecessor in a variable, and then update it while traversing the BT with post-order. 1) set predecessor = null 2) traverse BT with post-order 3) if current_node == input_node {     return predecessor; } else {     predecessor = current_node } 4) goto step 3)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@Prasanna: Nice solution..Can you also provide code with this?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the code for Prasanna's algorithm"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node* postOrderPred(node* root,int val,int *found){       if(!root) return NULL;       if(valdata)                         return postOrderPred(root->left,val,found);       if(val>root->data){            node* t;            if(t=postOrderPred(root->right,val,found))                   return t;            if(*found && root->left)                          return root->left;       }       else{            *found=1;            if(root->right)                           return root->right;            if(root->left)                          return root->left;       }       return NULL; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Logic  1. if non leaf node and it has a right child return right child as pred 2. if non leaf node and it has a left child but no right child return left child as pred 3. if leaf node, iterate from root and track current pred at that instance     3.1 if in a root and target is the right child then a left child is the pred for the right child.     3.2 go to left sub-tree, current is still the current pred     3.3 go to right sub-tree, root-left is the current current pred for the right sub-tree     3.4 if the target is root-left, return current   (Note : 3.4 can be between 3.1 and 3.2. I have put it at the last to have a better understanding and because of which you might go few extra iterations :) )"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simple straightforward code using recursion. However, it could be become tricky if interviewer only wants iterative code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Post-order predecessor is nothing but its left child. (last post order visited element in left sub tree)  struct BinaryTree *PostorderPredecessor(struct BinaryTree *node) {   return node->left }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=18061681","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"9","title":"Single Initialization :  Global variable x, initialized to 0.  Implement a function that can be called by multiple threads simultaneously or sequentially. The value of x should be set to the current time only once. If it is already set, the value shouldn't be updated.  Make sure that the function doesn't become a bottleneck","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"{{ if(x==0){  lock(x);  if(x==0){   x=newTime();  }  unlock(x); } }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I believe the function used to get the global variable x should use Double Checked Locking mechanism. (Multithreaded Singleton)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Looks like a singletone to me also."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class buffer resource \n{ \nprivate Date d; \npublic synchorized void method1() \n{ \nif (d == null) { \nd = new Date(); \n} \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static volatile YourObject instance;  public YourObject getInstance() {     YourObject r = instance;     if(r == null) {         synchronized(lock) {    // while we were waiting for the lock, another              r = instance;       // thread may have instantiated instance             if(r == null) {                   r = new YourObject();                 instance = r;             }         }     }     return r; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// Mark x as volatile to make sure we always read the latest update \n volatile int x = 0; \n \n void setX() { \n  if (x != 0) \n   return; \n  synchronized (x) { \n   // Need to check again in case x has been set \n   // by another thread after our initial check  \n   if (x == 0) { \n    x = new_value; \n   } \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use pthread_once_t and pthread_once."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"numerous ways"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \n#include  \n \nint x = 0; \nstd::once_flag flg; \nvoid setX(const int n) {  \n x = n;  \n std::cout << \"setX: \" << n << std::endl; \n} \n \nvoid wait_and_set(const int id) { \n std::this_thread::sleep_for(std::chrono::microseconds(100)); \n std::call_once(flg, setX, id); \n} \n \nint main() { \n std::vector tLst; \n for (int i = 1; i < 10; ++i) { \n  tLst.push_back(std::thread(wait_and_set, i)); \n } \n for (auto& t : tLst) t.join(); \n \n std::cout << \"The final value of x is \" << x << std::endl; \n std::cin.get(); \n std::cout << \"Press Enter to continue ...\" << std::endl; \n return 0; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=18063671","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"17","title":"Given a BT and 2 nodes, find LowestCommonAncestor","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Is it possible to get the solution this way ? Get the path from root to node a and b. (Use 2 stacks) And start popping the node out until you find a common node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Suppose if node a is parent of node b, what should be the output?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can't be done in O(n) without extra space. Down voting can't change the facts"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algo: At any node, check if either of its children or both of its children has return true (got keys)    i) if both elements are found, then this current node is common ancestor. return current node    ii) if either of children has return true and this current node is another key then return this current node    iii) if either of children has return true & this current node is not another key, return NULL but update found pointer with true.  Function is called : found = 0; tree* node = commonAncestor (root, &found, f, s)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is it only a Binary Tree or a Binary Search Tree(BST) ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Least common Ancestor Tested this code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"static int findLowestCommonAncestor(final TreeNode node, int first, int second){ \n  if((node.getValue() < first) == (node.getValue() < second)){ \n   return findLowestCommonAncestor(node.getValue() < first ? node.getRight() : node.getLeft(), first, second); \n  } else if(node.getValue() == first || node.getValue() == second){ \n   return node.getValue() == first ? first : second; \n  } else \n   return node.getValue(); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"In a binary tree, there is no way to avoid O(n^2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This problem can ben solved in O(N), and using a single stack. do a pre-order of the first node, and Push every node in the stack. Now take the second node, do the same Pre-order traversal, and this time visiting every node do a POP from the stack if the Popped value doesn't match with the current node value then the last Pop value was the lowest common ancestor. Note: we need another variable to hold the last matched node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"bool findLCA(Node* node, int minC, int valA, int valB) \n{ \n  if(!node) return MAXINT; \n \n  minC = min(node->val, minC); \n \n  bool bFoundL = findLCA(node->left, minC, valA, valB); \n  bool bFoundR = findLCA(node->right, minC, valA, valB); \n  if(bFoundL && bFoundR) \n  { \n    printf(\"Lowest Common Ancestor is: %d\", minC); \n    return false; \n  } \n \n  return bFoundL || bFoundR || node->val == valA || node->val == valB; \n} \n \n// call like this \nfindLCA(root, MAXINT, value1, value2);"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=18043679","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"17","title":"Find the Max sum subsequence in array","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"If all the elements are -ve than print the one having smallest magnitude else take into account only +ve numbers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public static find_max_subarray(int[] a) { \n    // check arguments \n    if(a == null || a.Length == 0) throw new ArgumentNullException(); \n     \n    int max = a[0], tmp_max = a[0]; \n    foreach(var i in a) { \n        if(tmp_max < 0) { \n            tmp_max = i; \n        } else { \n            tmp_max += i; \n        } \n        max = tmp_max > max ? tmp_max : max; \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int main () \n{ \n  int arr[] = {-23, -45, 78, 67, 45, 78, 23, -67, -45}; \n  int max_sum = 0, max_pos = 0, max_sz = 0; \n  int arr_sz = sizeof(arr)/sizeof(int); \n  for(int i=0; i < arr_sz; i++) \n  { \n    int sum = 0; \n    int cur_sz = arr_sz - i; \n    for(int j=0; j < cur_sz; j++) \n    { \n      sum += arr[i + j]; \n      if(sum > max_sum) \n      { \n        max_sum = sum; \n        max_pos = i; \n        max_sz = j + 1; \n      } \n    } \n  } \n \n  for(int i = max_pos; i < max_pos+max_sz; i++) \n    printf(\"%d \", arr[i]); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int subseq (int array[], int length) { \n    int sum[length], i, j, max; \n    sum[0] = array[0]; \n    for (i=1;i= 0) { \n            if (array[j] < array[i] \n                && (sum[j] + array[j]) > sum[i]) { \n                sum[i] = sum[j] + array[j]; \n            } \n            --j; \n        } \n    } \n    max = sum[0]; \n    for (i=1;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static int[] Subsequence(int[] A) \n        { \n            int maxStart = 0; \n            int maxEnd = A.Length - 1; \n            int maxSum = 0; \n \n            int start = -1; \n            int end = 0; \n            int sum = 0; \n \n            for(int i = 0; i < A.Length; i++) \n            { \n                if(A[i] >= 0 && start < 0) \n                { \n                    start = i; end = i; sum=A[i]; \n                } \n                else if(A[i] >= 0 && start >= 0) \n                { \n                    end = i; sum += A[i]; \n                } \n                else if (A[i] < 0 && start >= 0) \n                { \n                    if(sum > maxSum) \n                    { \n                        maxSum =sum; \n                        maxStart= start; \n                        maxEnd = end; \n                    } \n \n                    start = -1; \n                } \n            } \n \n            //last sum \n            if (start >= 0 && sum > maxSum) \n            { \n                maxSum = sum; \n                maxStart = start; \n                maxEnd = end; \n            } \n \n            return new int[] \n            { \n                maxSum, \n                maxStart, \n                maxEnd \n            }; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int MaxSequenceSum(int[] nums) \n        { \n            if (nums == null || nums.Length == 0) \n            { \n                throw new ArgumentException(); \n            } \n \n            if (nums.Length == 1) \n            { \n                return nums[0]; \n            } \n \n            int sum = 0; \n            int maxSum = nums[0]; \n            int lastEnd = 0; \n \n            for (int i = 0; i < nums.Length; i++) \n            { \n                if (nums[i] > 0 && lastEnd == i - 1) \n                { \n                    sum += nums[i]; \n                    ++lastEnd; \n                } \n                else if (nums[i] > 0 && lastEnd < i - 1) \n                { \n                    sum = nums[i]; \n                    lastEnd = i; \n                } \n                else if (nums[i] < 0) \n                { \n                    if (lastEnd != 0) \n                    { \n                        if (maxSum < sum) \n                        { \n                            maxSum = sum; \n                        } \n                    } \n                    else \n                    { \n                        if (maxSum < nums[i]) \n                        { \n                            maxSum = nums[i]; \n                        } \n                    } \n                } \n            } \n \n            return maxSum; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Divided algo in few parts: part 1:  1) get minimum negative value  2) get first positive sum of array   3) get start & end index of first positive sum this will be current running sum part 2:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This code find the max sum with the locations:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I don't understand your code. I think you need 3 loops. At least my Code works.  struct index {  int index_left,index_right; };  index findLargestSubsequence(int arr[],int len) {    int index_left=0;    int index_right=0;    int max_sum=0;    int sum = 0;    index my_index;     for(int i = 0 ; i   {     for( int k = i ;k    {      for( int j = i ; j<=k ; j++)      {     sum += arr[j];            }       if(sum > max_sum)      {       max_sum = sum;       index_left = i;       index_right = k;      }      sum=0;     }    }    my_index.index_left = index_left;    my_index.index_right = index_right;    return my_index; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static long maxSumSequence(int[] arr){   long sum = arr[0];   long oldsum = arr[0];   for (int i = 1; i < arr.length; i++){    long newsum = arr[i], tempsum = sum + arr[i];    if(tempsum < sum){     if (oldsum < sum) oldsum = sum;     sum = newsum;     }else{     if ((newsum > tempsum) && (newsum > sum)) sum = newsum;     if ((tempsum > sum) && (tempsum > newsum)) sum = tempsum;    }   }   if (sum > oldsum)return sum;   return oldsum;  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17905669","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"10","title":"Given 'n' coins, print the number of ways to form an amount 'A' . This is a standard denomination problem with one small twist(We have only one coin of each type,not infinite number,if we choose one coin for making change we should not choose it again) . Can somebody give a code with explanation ?  Example:  Amount:3 coins : 1 2 3  There are only two ways (1,2)(3) not (1,1,1)(1,2)(3)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Assumption: All the coins have different values. If we have coins with same value then we will start getting duplicate results.  To me this problem looks like finding the combination of the coins and checking if that combination's total is the value we want to compute. So I can extend the find combinations algorithm to do this.  Here is a recursive solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"int total=0; \n#define SIZE(a) sizeof(a)/sizeof(a[0]) \nint arr[] = {1, 2, 3}; \nint visited[100]; \n \nvoid IsSubArray(int n, int N, int sum) // N is the number of elements in the array  \n{ \n        visited[n] = 1; \n        if(sum == N) { \n                total++; \n                visited[n] = 0; \n                return; \n        } \n \n        if((n <= (SIZE(arr)-1)) && arr[n]+sum <= N) { \n                IsSubArray(n+1, N, sum+arr[n]); \n        } \n \n        if((n <= (SIZE(arr)-1)) && arr[n+1]+sum <= N) { \n                visited[n] = 0; \n                IsSubArray(n+1, N, sum); \n        } \n} \n \nint main() \n{ \n        int j, i; \n        int target_sum=3; \n \n        memset(visited, 0, sizeof(int)*100); \n        IsSubArray(0, target_sum, 0); \n        printf(\"total %d\\n\", total); \n        return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"If coins are 1,2,3,4 and amount is 4 then possible set is {4}. if amount is 3 then {1,2} and {3} are possible. So max two set are possible. min one set is also possible. If the amount is power of 2 then only one set is possible else two sets are possible.  If we take binary form of that given number then easily we can solve this problem"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"- we have n coins each of unique denomination - a coin once selected cannot be reused/repeated (sampling without replacement) - number of subsets of a set of n coins = 2^n - brute force: compare sum of elements in a subset with the desired amount.  - Repeat 2^n times - obviously bad. Exponential time complexity - So, sort the set. Use binary search to find the desired denomination - The denomination is either present in the set, or not.  - Either way, you will know the coins lesser than A. Reject all coins bigger than A. - Apply the brute algorithm (above) to this list of subsets (having coins smaller than A). - This way, at least we reduce the time complexity to half (but it remains exponential)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sort all the denominations in increasing order and let Di denotes ith denomination. Let N(i,K) = Number of ways of obtaining an amount K only using denominations from D1 to Di."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if we use greedy algorithm, the greedy standard is using the minimum number of coins to form the result. First, order the coins array by their values, after that, the value will be in non-descending order. Second, search the array from the largest point.  If the largest value is equal to the 'A', we set the element has been visited; else if the largest value is less than 'A', we set the element has been visited, and search the elements which can be added to get 'A',  if we should add three or more values to get 'A', we can also use a temp value to replace 'A'; if the largest value is larger than 'A', just ignore it and set the element has been visited. This method can ensure we use the least number of coins to get 'A'."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void subSum(int M,int arr[],int k,int s,int n, int res[]) \n{ \n if(s+arr[k]==M) \n { \n  res[k]=1; \n  return; \n } \n if(k+1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; import java.util.List;  public class Bag {   public static void main(String[] args)  {    System.out.println(\"begin\");      List from = new ArrayList();      List to = new ArrayList();      from.add(1);   from.add(2);   from.add(3);   from.add(4);   from.add(5);   from.add(6);   from.add(7);      fill(from, to,0, 9);      System.out.println(\"end\");  }    private static void fill(List from, List to, int index, Integer target)  {   if(sum(to) == target)   {    System.out.println(print(to));    return;   }      while (index < from.size()) {        Integer current = from.get(index);        List newto = Copy(to);        List newfrom = Copy(from);        newto.add(current);        newfrom.remove(current);        fill(newfrom, newto, index, target);        index++;   }  }   private static String print(List to) {      String output = \"{\";      for (int i = 0; i < to.size(); i++) {    output += to.get(i) + \",\";   }      return output.subSequence(0, output.length()-1) + \"}\";  }   private static Integer sum(List from) {   Integer sum = 0;      for (int i = 0; i < from.size(); i++) {    sum += from.get(i);   }      return sum;  }    private static List Copy(List input)  {   ArrayList output = new ArrayList();      for (int i = 0; i < input.size(); i++) {    output.add(input.get(i));   }   return output;  }   }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17872666","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"37","title":"Write a program to calculate Sum of  two singly linked lists. e.g.  1-->2-->3 8->9->10 . Result list should be  10-->2-->3  You are not allowed to make any change in input lists. Those are read only.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"#include \n \n#include \n \nstruct linkedlist \n { \n    int n; \n    struct linkedlist *next;   \n \n \n }; \ntypedef struct linkedlist node; \n \nint sum(node *str1,node *str2,node **str3) \n  { \n       int a=0; \n      if(str1 !=NULL && str2 !=NULL ) \n          { \n                node *nw=(node *) malloc(sizeof(node)); \n                //printf(\"Hello\\n\"); \n                 \n                a=(str1->n) + (str2->n) + sum(str1->next,str2->next,str3); \n                nw->n=a % 10; \n                nw->next=(*str3);  \n                *str3=nw; \n               // printf(\"%d\",((*str3)->n)); \n               return a/10; \n \n          } \n          return 0; \n} \n \n   node * createlinkedlist(node  *str) \n    {  \n       node *nw; \n       int i=0,k; \n       printf(\"enter how many nos \\n\"); \n       scanf(\"%d\",&k); \n       while(in)); \n               if(i==0) \n                 { \n                   nw->next=NULL; \n                   str=nw; \n                  }  \n               else{ nw->next=str; \n                str=nw;} \n                i++;  \n                \n        } \n  \n          return str; \n   } \n \n \n     void display(node *str) \n      { \n         while(str != NULL) \n          { \n              printf(\"%d\\t\",str->n); \n             str=str->next; \n \n          } \n \n        printf(\"\\n\"); \n      } \n    \n    \n   void main() \n    { \n          node *str1,*str2,*str3,*nw; \n          int carry;   \n          str1=str2=str3=NULL; \n          str1= createlinkedlist(str1); \n          str2=createlinkedlist(str2);  \n          display(str1);   \n           \n          carry=sum(str1,str2,&str3); \n           if(carry !=0) \n            { \n              nw=(node *) malloc(sizeof(node)); \n              nw->n=carry; \n              nw->next=str3; \n              str3=nw;  \n            } \n \n \n          display(str2); \n           \n          display(str3);  \n           \n \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void sumList(Node head1, Node head2, Node result) {       if (head1 == null || head2 == null) {          return;       }       sumList(head1.next, head2.next, result.next);       int carry = 0;       Node next = result.next;       if (next != null && next.data > 10) {          carry = next.data / 10;          next.data = next.data % 10;       }       result.data = head1.data + head2.data + carry;    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I don't think above code wil  work in case list are of varied length. I suggest, the simplest way wil be to reverse both linked list, add them to get our sum list, and then reverse all three list to get the original and our answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can do this recursively or by using stack. I choose the latter. I am using a Stack of Integers. The following code will take care of the case where two lists are unequal length.   1. Start putting the integer value of each node of the bigger list on stack until the length of two lists become equal. 2. Start adding the values of data from two lists. At this point do not care about carry and just add them and push onto the stack. 3. Start popping values out of stack and putting them in newly created linked list node. You need to adjust the values by doing sum%10 and carry = sum/10. Use this carry for the next popped out entry. Every node that you create, put it in the front of the list.  NOTE: We might be able to get rid of the stack if we just add the two list and put them in a third list. Then adjust the third list for carry propagation and in the end reverse it. In this case time=O(n) auxiliary space O(1)  But even the stack approach should not be worse than the recursive way.  Here is a code to get you started:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int FindSum(node* n1, node* n2, node** r, int depth) \n{ \n if (!n1 && !n2) \n  return 0; \n  \n node* result = (node*)malloc(sizeof(node)); \n n->value = value; \n n->next = next; \n *r = result; \n \n int v1,v2,carry = 0; \n if(!n1) \n { \n  v1 = 0; \n  v2 = n2->value; \n  carry = FindSum(NULL,n2->next,&(result->next),depth+1); \n } \n else if(!n2) \n { \n  v1 = n1->value; \n  v2 = 0; \n  carry = FindSum(n1->next,NULL,&(result->next),depth+1); \n } \n else \n { \n  v1 = n1->value; \n  v2 = n2->value; \n  carry = FindSum(n1->next,n2->next,&(result->next),depth+1); \n } \n \n if (depth==1) \n { \n  result->value = v1+v2+carry; \n  return 0; \n }  \n else \n { \n  int sum = v1+v2+carry; \n  result->value = sum%10; \n  return sum/10; \n } \n} \n \n/// Call: FindSum(n1,n2,&result, 1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First List       : 1-->2-->3 \n \n            1*100 + 2*10 + 3*1 = 123 \n \n    Second List  : 8-->9-->10 \n \n            8*100 + 9*10 + 10*1 = 900 \n \n    Result List    : \n \n123 \n \n       +  900 \n \n       ----------- \n \n         1023 \n \nadd 1023 to Singly List. \nif(ans.length==4) \n{ \n add first two digit to first node \n} \nelse \n{ \n add one digit to node \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Try this java code here...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"reverse both the linked list and  add it and store the result in third list.Reverse the third list in the end."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package programmingInterview; \npublic class LinkedListSum{ \n public static class List{ \n  int value; \n  List next; \n   \n  public List(int value){ \n   this.value = value; \n   this.next = null; \n  } \n  public List(){ \n  } \n  public static List addElement(List a, List b){ \n   b.next = a; \n   a = b; \n   return a; \n  } \n } \n \n public static List findSum(List a, List b){ \n  List c = new List(); \n  List d = new List(); \n  while(a!=null || b!=null){ \n   if(a!=null && b!=null){ \n    c = new List(a.value + b.value); \n    a = a.next; \n    b = b.next; \n   } \n   else if(a==null){ \n    c = new List(b.value); \n    b = b.next; \n   } \n   else{ \n    c = new List(a.value); \n    a = a.next; \n   } \n \n   d = List.addElement(d, c); \n  } \n  return d; \n } \n \n \n \n public static void print(List lls) { \n  while(lls.next != null){ \n   System.out.print(lls.value+\"-->\"); \n   lls = lls.next; \n  } \n  System.out.println(lls.value+\"-->NULL\"); \n } \n \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// here in our logic we 1st calculate the value of each linked list separately int sum(struct node *f,struct node *s) {  static su,sf,ss;  //sum for total sum SF for the number in first  SS number in second   if(f==NULL && s==NULL)  {   su=sf+ss;   return ;  }  else if(f==NULL && s!=NULL)  {   ss=ss*10+s->data;   sum(f,s->link);  }  else if(f!=NULL && s==NULL)  {   sf=sf*10+f->data;   sum(f->link,s);  }  else  {   sf=sf*10+f->data;   ss=ss*10+s->data;   sum(f->link,s->link);  }  return su; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi, here's one piece of code which was developed with reference to the one I noticed at geeksforgeeks"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static class Node { \n public int digit; \n public Node next; \n public Node(int digit) { \n  this.digit = digit; \n } \n} \npublic static Node add(Node a, Node b) { \n Node _a = a; \n Node _b = b; \n Node c = new Node(0); \n Node _c = c; \n int extras = 0; \n while (_a != null) { \n  int sum = _a.digit + _b.digit; \n  if (sum < 9) { \n   for (int i = 0; i < extras; ++i) { \n    _c.next = new Node(9); \n    _c = _c.next; \n   } \n   _c.next = new Node(sum); \n   _c = _c.next; \n   extras = 0; \n  } else if (sum == 9) { \n   ++extras; \n  } else { \n   ++_c.digit; \n   for (int i = 0; i < extras; ++i) { \n    _c.next = new Node(0); \n    _c = _c.next; \n   } \n   _c.next = new Node(sum % 10); \n   _c = _c.next; \n   extras = 0; \n  } \n  _a = _a.next; \n  _b = _b.next; \n } \n for (int i = 0; i < extras; ++i) { \n  _c.next = new Node(9); \n  _c = _c.next; \n } \n if (c.digit == 0) { \n  c = c.next; \n } \n return c; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sites.google.com/site/spaceofjameschen/home/linked-list/add-two-lists"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static List findSum(List l1, List l2){ \n \nint sum1=0; \nint sum2=0; \n \n//Find the integer stored in list1 \nfor (int i =0; i resultList= new LinkedList(); \n \nwhile(result!=0){ \n int mod=result%10; \nresult=result/10; \nresultList.addFirst(mod); \n} \n \nreturn resultList; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"addtwolists(node *p,node *q) \n{ \nint carry=0,num,num1,num2; \nnode *temp1=p,*temp2=q,*list3=NULL; \nwhile(temp1!=NULL||temp2!=NULL) \n{ \nif(temp1==NULL) \n{ \n \nnum1=temp2->data+carry; \nif(carry==1) \ncarry=0; \nif(num1>=10) \n{ \nnum1=num1-10; \ncarry=1; \n} \nadd(&list3,num1); \n \n} \nelse \n{ \nif(temp2==NULL) \n{ \nnum2=temp1->data+carry; \nif(carry==1) \ncarry=0; \nif(num2>=10) \n{ \nnum2=num2-10; \ncarry=1; \n} \nadd(&list3,num2); \n} \nelse \n{ \nnum=temp1->data+temp2->data+carry; \nif(carry==1) \ncarry=0; \nif(num>=10) \n{ \nnum=num-10; \ncarry=1; \n} \nadd(&list3,num); \n} \n \n} \nif(temp1!=NULL) \ntemp1=temp1->next; \nif(temp2!=NULL) \ntemp2=temp2->next; \n} \nif(carry==1) \n{ \nadd(&list3,carry); \ncarry=0; \n} \nreturn list3; \n} \n \nadd(node **p,int num) \n{ \nnode *temp,*r; \ntemp=*p; \nif(*p==NULL) \n{ \ntemp=malloc(sizeof(node)); \ntemp->data=num; \ntemp->next=NULL; \n*p=temp; \n} \nelse \n{ \ntemp=*p; \nwhile(temp->next!=NULL) \ntemp=temp->next; \nr=malloc(sizeof(node)); \nr->data=num; \nr->next=NULL; \ntemp->next=r; \n} \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What's the correct result of the example? 1) 12 -> 7 -> 3 -> 10 2) 1 -> 2 -> 7 -> 4 -> 0 3) 2 -> 8 -> 3 -> 0 -> 1  The answer depends the three cases. I don't see a clear clue what the problem is.  As for the 1) and 3), the solution is quite straightforward. However, we should visit the two lists in advance, reversing or calculating the merging point."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Looks to be simple .  bool returnsum(Node **headnode1, Node **headnode2, Node **sum) {   int data1= 0;  int data2 = 0;  int sumNode = 0;  Node *newNode = *sum;  Node *temp1 = *headnode1;  Node *temp2 = *headnode2;   if(*headnode1 == NULL && *headnode2 == NULL)  {   return false;  }    while(temp1 || temp2)  {   if(temp1)   {    data1 = temp1->data;    temp1 = temp1->next;   }   else   {    data1 = 0;   }       if(temp2)   {    data2 = temp2->data;    temp2 = temp2->next;   }   else   {    data2 = 0;   }    newNode ->data = data1 + data2;    if(temp1 || temp2)   {   newNode->next = new Node();   newNode = newNode->next;   }   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public Linkedlist sum(Node aHead, Node bHead)     {         if(aHead.next == null || bHead.next == null)         {             Linkedlist ll = new Linkedlist();             Node h = new Node();             h.data =  (aHead.data + bHead.data);             h.next = null;             ll.head = h;             return ll;         }         else         {             Linkedlist l =  sum(bHead.next, aHead.next);             Node n = new Node();             n.data = aHead.data + bHead.data + l.head.data/10;             l.head.data = l.head.data % 10;             n.next = l.head;             l.head = n;             return l;          }     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about traversing the linked list and storing the result. Example: 9->8->7->6 5->4->3->2  now, we get 4->2->0->8 and carry as 1->1->1->0 shift it and add again.so,  0->4->2->0->8 1->1->1->0  now we get the answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Code for n-length linked list with result list of size 'n' preallocated  void findSUM( Node l1, Node l2, Node result){ if( (l1==NULL && l2==NULL) || result==NULL) return; if(l1!=NULL) {result=l2; return;} else {result=l1; return;}  carry=sumHelper(l1, l2, result); if(carry>0) result.data=result.data+(carry*10); }  int sumHelper(Node l1, Node l2, Node result){ if(l1==NULL || l2==NULL) return 0;  carry=sumHelper(l1.next, l2.next, result.next); result.data=(l1.data + l2.data+ carry)%10; return (l1.data + l2.data + carry)/10; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// Recursive approach \nLinkedList* addLinkedList(LinkedList* list1, LinkedList* list2) { \n LinkedList* sumNode = NULL; \n if (list1 == NULL && list2 == NULL ) \n  return NULL ; \n else { \n  int carry = 0; \n  LinkedList* prevSumNode = \n    addLinkedList(list1 != NULL ? list1->next : NULL, \n      list2 != NULL ? list2->next : NULL); \n \n  sumNode = malloc(sizeof(LinkedList)); \n  sumNode->next = NULL; \n  int data1 = list1 != NULL ? list1->data : 0; \n  int data2 = list2 != NULL ? list2->data : 0; \n \n  if (prevSumNode != NULL && prevSumNode->data > 10) \n  { \n   carry = prevSumNode->data / 10; \n   prevSumNode->data = prevSumNode->data % 10; \n  } \n  sumNode->data = data1 + data2 + carry; \n  sumNode->next = prevSumNode; \n } \n \n return sumNode; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"template  node* add_reverse_order(node* nod1, node* nod2, int& carry, int level) {  if (nod1 == NULL && nod2 == NULL) {   return NULL;  } else {   node* nod3 = new node();   nod3->set_next(add_reverse_order(nod1->return_next(), nod2->return_next(), carry,     level + 1));   int sum = nod1->return_value() + nod2->return_value() + carry;   carry = sum / 10;   int unit_place = sum % 10;   if (level != 0) {    nod3->set_value(unit_place);   } else {    nod3->set_value(sum);    while (nod3 != NULL) {     cout << nod3->return_value() << \"--->\";     nod3 = nod3->return_next();    }   }   return nod3;  } }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17833665","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"18","title":"Given a BST find Ceiling value of given key","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"struct Node \n{ \n  int data; \n  Node* left; \n  Node* right; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Correct one: \n \nstruct bst { \n int data; \n struct bst* left; \n struct bst* right; \n}; \n \nIterative: \n \nint ceiling(struct bst* root, int key) { \n if(!root) \n  return 0; \n struct bst* t = root; \n while(t) { \n  if(t->data > key && (!t->left || (t->left && t->left->data <= key))) \n   return t->data; \n  else if(t->data > key && t->left && t->left->data > key) \n   t = t->left; \n  else if (t->data <= key && t->right) \n   t = t->right; \n  else if(t->data <= key && !t->right) \n   return NULL; \n } \n} \n \nRecursive: \n \nint ceiling(struct bst* root, int key) { \n if(!root) \n  return 0; \n if(root->data > key && (!root->left || (root->left && root->left->data <= key))) \n  return root->data; \n else if(root->data > key && root->left && root->left->data > key) \n  return ceiling(root->left, int key); \n else if(root->data <= key && !root->right) \n  return NULL; \n else if(root->data <= key && root->right) \n  return ceiling(root->right, int key); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"its just INorder Successor :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct bst { \n int data; \n struct bst* left; \n struct bst* right; \n}; \n \nIterative: \n \nint ceiling(struct bst* root, int key) { \n if(!root) \n  return 0; \n struct bst* t = root; \n while(t->data > key && t->left && t->left->data > key) \n  t = t->left; \n return t->data; \n} \n \nRecursive: \n \nint ceiling(struct bst* root, int key) { \n if(!root) \n  return 0; \n if(root->data > key && root->left && root->left->data <= key) \n  return root->data; \n return ceiling(root->left, int key); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Smallest integer greater than the key and present in BST."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//finds the smallest integer greater than the key and present in BST //if return value is same as key, there is value in the tree that is greater than the key  int find_ceiling(node *head, int key) {  int ceil = key;     while (head)  {   if (head->data >= key)   {    if ((head->data > key) && (head->data < ceil)) ceil = head->data;    head = head->right;   }   else   {    head = head->left;   }  }   return ceil; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Iteration:  Node* ceiling(Node* root, int value) { Node* ret=NULL;  while(root) {  if(root->data > value)  {   ret=root;   root=root->left;  } else  root=root->right; } return ret; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Implemented by C#."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Both iterative & recursive version :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Can you give a precise definition of what it means to \"find the ceiling value of a given key\"? Does it mean that we want to find the smallest-valued node in the tree that is greater than or equal to the given key?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17808664","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"17","title":"Q: Given a binary tree with nodes that have left, right pointers pointing to the left and right children respoectively. It also has a neighbor pointer that currently Points to null. Write a function to make it point to its neighbor.  E.g","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"struct Node \n{ \n  int data; \n  Node* right; \n  Node* left; \n  Node* RightNeighbor; \n} \n \nvoid UptateTreeToPointToRightNeighbor(Node* head) \n{ \n  if(!head) \n    return null; \n     \n  Queue myQ = new Queue(); \n  myQ.push(head); \n  myQ.push(NULL);   \n   \n  while(!myQ,IsEmpty) \n  { \n    Node* curr = myQ.Dequeue(); \n     \n    if(curr) \n    { \n      curr->RightNeighbor = myQ.Front; \n      if(curr->left) \n        myQ.push(curr->left); \n      if(curr->right) \n        myQ.push(curr->right); \n    } \n    else \n        myQ.push(NULL); \n  } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Do level order traversal, and then assign neighbor accordingly as done by JSDUDE"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct btree { \n int data; \n struct btree* left; \n struct btree* right; \n struct btree* neighbor; \n}; \n \nRecursive: \n \nvoid set_neighbor(struct btree* bt) { \n if(!bt || !bt->right) \n  return; \n if(bt->right && bt->left) \n  bt->left->neighbor = bt->right; \n set_neighbor(bt->left); \n set_neighbor(bt->right); \n} \n \nIterative: \n \nvoid set_neighbor(struct btree* bt) { \n if(!bt || !bt->right) \n  return; \n stack sbt; \n if(bt) sbt.push(bt); \n while(!sbt.empty()) { \n  struct btree* tmp = sbt.peek(); \n  if(tmp->left && tmp->right) \n   tmp->left->neighbor = tmp->right; \n  sbt.pop(); \n  if(tmp->left) sbt.push(tmp->left); \n  if(tmp->right) sbt.push(tmp->right); \n } \n return; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* This function returns the leftmost child of nodes at the same level as p. \n   This function is used to getNExt right of p's right child \n   If right child of is NULL then this can also be sued for the left child */ \nstruct node *getNextRight(struct node *p) \n{ \n    struct node *temp = p->nextRight; \n \n    /* Traverse nodes at p's level and find and return \n       the first node's first child */ \n    while (temp != NULL) \n    { \n        if (temp->left != NULL) \n            return temp->left; \n        if (temp->right != NULL) \n            return temp->right; \n        temp = temp->nextRight; \n    } \n \n    // If all the nodes at p's level are leaf nodes then return NULL \n    return NULL; \n} \n \n/* Sets nextRight of all nodes of a tree with root as p */ \nvoid connect(struct node* p) \n{ \n    struct node *temp; \n \n    if (!p) \n      return; \n \n    // Set nextRight for root \n    p->nextRight = NULL; \n \n    // set nextRight of all levels one by one \n    while (p != NULL) \n    { \n        struct node *q = p; \n \n        /* Connect all childrem nodes of p and children nodes of all other nodes \n          at same level as p */ \n        while (q != NULL) \n        { \n            // Set the nextRight pointer for p's left child \n            if (q->left) \n            { \n                // If q has right child, then right child is nextRight of \n                // p and we also need to set nextRight of right child \n                if (q->right) \n                    q->left->nextRight = q->right; \n                else \n                    q->left->nextRight = getNextRight(q); \n            } \n \n            if (q->right) \n                q->right->nextRight = getNextRight(q); \n \n            // Set nextRight for other nodes in pre order fashion \n            q = q->nextRight; \n        } \n \n        // start from the first node of next level \n        if (p->left) \n           p = p->left; \n        else if (p->right) \n           p = p->right; \n        else \n           p = getNextRight(p); \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include \"iostream\" \n#include  \n \nusing namespace std; \n \nstruct node \n{ \n int data; \n node* leftChild; \n node* rightChild; \n node* rightNeighbour; \n}; \nclass SetRightChild \n { \n    public:node* root;  \n public:SetRightChild() \n     { \n      root = new node(); \n     } \n public:node* SetTree() \n { \n   \n  root->data = 2; \n  node* leftNode = new node(); \n  node* rightNode = new node(); \n \n  leftNode->data = 1; \n  leftNode->leftChild = NULL; \n  leftNode->rightChild = NULL; \n  leftNode->rightNeighbour = NULL; \n  root->leftChild = leftNode; \n \n  rightNode->data = 3; \n  rightNode->leftChild = NULL; \n  rightNode->rightChild = NULL; \n  rightNode->rightNeighbour = NULL; \n  root->rightChild = rightNode; \n  return root; \n } \n \n public:void SetRightNeighbour(node* rootNode) \n { \n  if(rootNode == NULL) \n  { \n   return; \n  }   \n  if(rootNode->leftChild != NULL && rootNode->rightChild != NULL) \n  { \n   rootNode->leftChild->rightNeighbour = rootNode->rightChild; \n  } \n  SetRightNeighbour(rootNode->leftChild); \n  SetRightNeighbour(rootNode->rightChild); \n } \n \n public:void printTree(node* rootNode) \n { \n  if(rootNode != NULL) \n  { \n   cout<<\"Node: \"<data<leftChild != NULL) \n   { \n    cout<<\"LeftChild: \"<leftChild->data<rightChild != NULL) \n   { \n    cout<<\"RightChild: \"<rightChild->data<rightNeighbour != NULL) \n   { \n    cout<<\"RightNeighbour: \"<rightNeighbour->data<leftChild != NULL) \n  { \n   printTree(rootNode->leftChild); \n  } \n  if(rootNode->rightChild != NULL) \n  { \n   printTree(rootNode->rightChild); \n  } \n  } \n } \n \n   \n  \n}; \n void main() \n {  \n  SetRightChild* tree = new SetRightChild(); \n  tree->root = tree->SetTree(); \n  cout<<\"before setting rightneighbour: \"<printTree(tree->root); \n   \n  tree->SetRightNeighbour(tree->root); \n \n  cout<<\"after setting rightneighbour: \"<printTree(tree->root); \n \n  _getch();   \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Iterative approach. Time complexity: O(n) and O(1) space complexity. Here we use the populated sibling ptr to traverse the tree in the zigzag manner and populate the sibling ptr of root's child.  Code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void SetNeighbour(Node1 n) \n        { \n            if (n == null) \n                return; \n \n            if (n.left != null) \n                n.left.neighbour = n.right; \n \n            if (n.right != null && n.neighbour != null) \n                n.right.neighbour = n.neighbour.left; \n \n            SetNeighbour(n.left); \n            SetNeighbour(n.right); \n \n            return; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void SetNeighbour(Node1 n) \n        { \n            if (n == null) \n                return; \n \n            Queue q = new Queue(); \n            q.Enqueue(n); \n             \n            while (q.Count > 0) \n            { \n                Node1 current = q.Dequeue(); \n                if (current.left != null) \n                    current.left.neighbour = current.right; \n \n                if (current.right != null && current.neighbour != null) \n                    current.right.neighbour = current.neighbour.left; \n \n                if(current.left != null) \n                    q.Enqueue(current.left); \n \n                if (current.right != null) \n                    q.Enqueue(current.right); \n            } \n \n            return; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Public void ConnectSibling(node root, int depth, List prev) { if(root==null) return; if(prev.count<=depth) Prev.Add(root); else { Prev[depth].sibling=root; Prev[depth]=root; } Connect(root.left,depth+1,prev);  Connect(root.right,depth+1,prev); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class Node \n { \n public: \n  int data; \n  Node* right; \n  Node* left; \n  Node* nebihor; \n  Node():right(NULL),left(NULL),nebihor(NULL){} \n }; \n void getLevels(Node* node,int level, vector>&levels) \n { \n  if(node==NULL) \n   return; \n  if(levels.size() nodes; \n   levels.push_back(nodes); \n  } \n  levels[level].push_back(node); \n  getLevels(node->left,level+1,levels); \n  getLevels(node->right,level+1,levels); \n } \n void makeNeighbours(Node* node) \n { \n  vector> levels; \n  getLevels(node,0,levels); \n  for(int i=0; i< levels.size();i++) \n   for(int j=0;jnebihor=levels[i][j+1]; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"An iterative solution: level by level with constant space (no stack/queue). An recursive solution: using a HashMap to record the current first node of each level, each time we deal with the current root node first and then its right child and then its left child. Another recursive solution: adapted from the iterative solution."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17191667","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"25","title":"4 men- each can cross a bridge in 1,3, 7, and 10 min. Only 2 people can walk the bridge at a time. How many min. minutes would they take to cross the bridge.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"13","title":"its 11"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Well, if only 1 person can pass each time, it will take 21 minutes, but 2 people can cross the bridge at the same time, so the minimum optimal time is 10.5 (assume that the bridge has 2 people crossing at any given time, which is impossible if t is not integer), and we can tell that the optimal solution is integer.   11 works, (7 & 10 go, 3 go when 7 reach the other side, at t = 10, 1 go across // one side 3 & 7 & 1, the other 10). Thus, 11 is the optimal solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Is it 11 min?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"3+7=10 & 10 means all will cross in 10 mnts ... Last one can cross in one mnts hence ... 10+1=11 is optimal..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"// We can make this problem more general. \n// Consider more than 4 men, for example, a set {15, 14, 10, 7, 5} \n// We can find that the mininum time is such a division that two subsets has a mininum difference. \n// e.g subset1 = {15,10}, subset2 = {14,7,5}; \n// Ideally, the min time should be perfect match, pm = SumOfSet/2; \n// If there is such a match, we find the answer, otherwise pm++; \n// It can be solved recursively. \n// C++ code: \n \n#include  \n#include  \n \nusing namespace std; \n \nbool FindSubsetSumTo( int pm, int array[], int N, bool visited[] ); \n \nint MinCrossBridgeTime( int array[], int N ); \n \nint main( int argc, char* argv[] ) \n{ \n    int a[] = {1, 3, 7, 10}; \n    int b[] = {15, 14, 10, 7, 5}; \n    int c[] = {2994, 1443, 533, 2324, 1133, 4444, 2382}; \n \n    cout << \"minimum time: \" << MinCrossBridgeTime( a, 4 ) << endl << endl; \n    cout << \"minimum time: \" << MinCrossBridgeTime( b, 5 ) << endl << endl; \n    cout << \"minimum time: \" << MinCrossBridgeTime( c, 7 ) << endl << endl; \n \n    return 0; \n} \n \nint MinCrossBridgeTime( int array[], int N ) \n{ \n    int pm = 0; \n    for( int i = 0; i < N; i++ ) pm += array[i]; \n    if( pm %2 == 1 ) pm = pm/2 +1; \n    else pm /= 2; \n    bool* used = new bool[N]; \n    bool found = false; \n    while( !found ) \n    { \n        for( int i = 0; i < N; i++ ) used[i] = false; \n        found = FindSubsetSumTo( pm, array, N, used ); \n        if( found ) \n        { \n            cout << \"subset1: \"; \n            for( int i = 0; i < N; i++ ) \n                if( used[i] ) cout << array[i] << \" \"; \n            cout << endl; \n            cout << \"subset2: \"; \n            for( int i = 0; i < N; i++ ) \n                if( !used[i] ) cout << array[i] << \" \"; \n            cout << endl; \n            return pm; \n        } \n        else pm++; \n    } \n} \n \nbool FindSubsetSumTo( int pm, int array[], int N, bool used[] ) \n{ \n    if( pm == 0 ) return true; \n    if( pm < 0 ) return false; \n    bool found = false; \n    int i = 0; \n    while( !found && i < N ) \n    { \n        if( !used[i] ) \n        { \n            used[i] = true; \n            found = FindSubsetSumTo( pm-array[i], array, N, used ); \n            if( !found ) used[i] = false; \n        } \n        i++; \n    } \n    return found; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@DashDash :Min value would be 20 min,here you have to think logic so that 2 max time taking person  walks together on the bridge and should not repeat walking to the bridge again back and forth.  I think now you get easily find the solution on your own ;)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"10 minutes.   Let 10 start in lane 1, and 7 start in lane 2. After 7 minutes, let 3 start in lane 2. After 9 minutes, let 1 start in lane 1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Even I think it's 11 mins  is optimal"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Even I think it's 11 mins  is optimal"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"11 is Ofcourse an Answer but I think the question is something different.. I have seen somewhat like this is a greater difficulty."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Yes its 11"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is 11."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Its 11 This is very simple :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can some one explain how it is 11 min? 1. 10 & 7 starts, When 7 is finishes 3 starts ..10 and 3 finish at the same time ...1 is still left..he can not walk alone.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"11 minutes: 1=10 minutes 2=3+7+1 minutes"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The answer is 17 Mins.  At a given time only 2 people can cross the bridge. SO the optimal way is ,  1,2,7,10   ---------> 1,2         2 mins  1,7,10   <---------2               1 mins 1                --------> 2,7,10   10 mis 1,2           < --------,7,10        2 mins                  ----------> 1,2,7,10 2 mins  Total  = 2+1+10+2+2 = 17mins"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"first 7 min : from lane1 10 and lane2 :7 next 3 min : from lane1 10(cont.) lane2 3(join) last 1 min : from lane 1 1  hence 11 is optimal solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"first  10,1  ->1minute next 10-1,3 ->3 minute next 10-1-3,7 -> 7minutes"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17810665","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"7","title":"The probability of a bus passing through a certain intersection in a time window of 20 min. is 0.9 What is the probability of the same bus passing through the same intersection in 5 min.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"Let the probabilty of passing of bus in the time intersection of 5 min be X. Then the probabilty of not passing of bus in the same 5 minute intersection is Y=1-X.  Let the bus not pass for 4 '5 min intersection', i.e, for 20 mins. The probablity of above will be Y^4.  Then as per question,  1 - Y^4 = 0.9 Y^4 = 0.1 (1-X)^4 = 0.1 X =  0.4377"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"The first solution is correct if the bus can only arrive once during the 20 minute period. The second is correct if the bus can arrive once during each 5 minute time slot.  The problem as stated is incomplete and requires further information for a definitive solution to be given."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A continuous probability question. Divide 20 min of time in 5 min time slots. So 4 such time slots. Bus may pass through intersection in any one of the 4 slots. So probability that the bus passes through intersection in first 5 min is 0.9*1/4 = 0.225."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Some body can  explain why 0.4377 is correct?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming arrival of buses is a poisson process, the interarrival time of buses T ~ exp (lambda min).. lambda unknown. Now Given P (T <= 20 min) = 1 - exp (-lambda * 20) = 0.9. => lambda = 0.115 min => P (T <= 5 min) = 1 - exp (-lambda * 5) = 0.43729"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Let X be the time taken by bus to come out from intersection. Hence, it will be uniformally distributed in interval (0,b). P(X <= 20)=0.9 which implied b= 20/0.9. Therefore, P(X<= 5)= 0.9*5/20=0.225."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17637670","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"16","title":"Suppose we want to convert one string S1 to another string S2 using only 3 types of operations:  -Insert(pos,char) (costs 8) -Delete(pos) (costs 6) -Replace(pos,char) (costs 8) Find the sequence of steps to convert S1 to S2 such that the cost to convert S1 to S2 is minimum. Eg. 'calculate' to 'late' - the possible operations are  Delete(0) Delete(1) Delete(2) Delete(3) Delete(4) and the above sequence of operations costs 30.  I used the following code(using levenshtein algorithm) to solve this. But I am not getting correct answer.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"This is the minimum edit distance algorithm. You can look it up at various sources, some of them listed below (AKA \"Levenshtein distance\"): w_ww.stanford.edu/class/cs124/lec/med.pdf w_ww.csse.monash.edu.au/~lloyd/tildeAlgDS/Dynamic/Edit/ e_n.wikipedia.org/wiki/Levenshtein_distance"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"find longest common subseuqence, and use the avail operations on the rest of the characters."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would think it should use the A* search algorithm."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In python strings are immutable . I tried similar kind of string manipulation  problem but it didn't work out . Use C/C++ or StringBuffer in Java"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using Edit distance algorithm: Code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using Edit distance algo. Code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using Edit distance algo Code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int minEdits(char s1[], char s2[]) { \n  int m = s1.length, n = s2.length; \n  int d[][] = new int[m + 1][n + 1]; \n  for (int i = 0; i <= m; i++) { \n   for (int j = 0; j <= n; j++) { \n    if (i == 0) \n     d[i][j] = j * I; \n    else if (j == 0) \n     d[i][j] = i * D; \n    else { \n     if (j < i) \n      d[i][j] = minimum(d[i - 1][j - 1] \n        + ((s1[i - 1] == s2[j - 1]) ? 0 : R), \n        d[i - 1][j] + R, d[i][j - 1] + I); \n     else \n      d[i][j] = minimum(d[i - 1][j - 1] \n        + ((s1[i - 1] == s2[j - 1]) ? 0 : R), \n        d[i - 1][j] + R, d[i][j - 1] + D); \n    } \n \n   } \n  } \n  return d[m][n]; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can solve this by Edit distance algo. Just by adding Insert,Delete,Replace costs."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a typical dynamic problem called Edit Distance.  pasted my solution here:     public static int minDistance(String word1, String word2) {         // Start typing your Java solution below         // DO NOT write main() function         int[][] ans = new int[word1.length() + 1][word2.length() + 1];         for(int i = 0; i < word1.length() + 1; i++) {             ans[i][0] = i;         }         for(int i = 0; i < word2.length() + 1; i++) {             ans[0][i] = i;         }                  for(int i = 1; i < word1.length() + 1; i++) {             for(int j = 1; j < word2.length() + 1; j ++) {                 if(word1.charAt(i -1) == word2.charAt(j - 1)) {                     ans[i][j] = getMin(ans[i-1][j-1], ans[i-1][j] + 1, ans[i][j-1] + 1);                 } else {                     ans[i][j] = getMin(ans[i-1][j-1] + 1, ans[i-1][j] + 1, ans[i][j-1] + 1);                 }             }         }                  return ans[word1.length()][word2.length()];     }          public static int getMin(int a, int b, int c) {         if(a < b && a < c) return a;         if(b < c) return b;         return c;     }          public static void main(String[] args) {         System.out.println(minDistance(\"algorithm\", \"altruistic\"));     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a typical dynamic problem called Edit Distance.  pasted my solution here:     public static int minDistance(String word1, String word2) {         // Start typing your Java solution below         // DO NOT write main() function         int[][] ans = new int[word1.length() + 1][word2.length() + 1];         for(int i = 0; i < word1.length() + 1; i++) {             ans[i][0] = i;         }         for(int i = 0; i < word2.length() + 1; i++) {             ans[0][i] = i;         }                  for(int i = 1; i < word1.length() + 1; i++) {             for(int j = 1; j < word2.length() + 1; j ++) {                 if(word1.charAt(i -1) == word2.charAt(j - 1)) {                     ans[i][j] = getMin(ans[i-1][j-1], ans[i-1][j] + 1, ans[i][j-1] + 1);                 } else {                     ans[i][j] = getMin(ans[i-1][j-1] + 1, ans[i-1][j] + 1, ans[i][j-1] + 1);                 }             }         }                  return ans[word1.length()][word2.length()];     }          public static int getMin(int a, int b, int c) {         if(a < b && a < c) return a;         if(b < c) return b;         return c;     }          public static void main(String[] args) {         System.out.println(minDistance(\"algorithm\", \"altruistic\"));     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a typical dynamic problem called Edit Distance.  pasted my solution here:     public static int minDistance(String word1, String word2) {         // Start typing your Java solution below         // DO NOT write main() function         int[][] ans = new int[word1.length() + 1][word2.length() + 1];         for(int i = 0; i < word1.length() + 1; i++) {             ans[i][0] = i;         }         for(int i = 0; i < word2.length() + 1; i++) {             ans[0][i] = i;         }                  for(int i = 1; i < word1.length() + 1; i++) {             for(int j = 1; j < word2.length() + 1; j ++) {                 if(word1.charAt(i -1) == word2.charAt(j - 1)) {                     ans[i][j] = getMin(ans[i-1][j-1], ans[i-1][j] + 1, ans[i][j-1] + 1);                 } else {                     ans[i][j] = getMin(ans[i-1][j-1] + 1, ans[i-1][j] + 1, ans[i][j-1] + 1);                 }             }         }                  return ans[word1.length()][word2.length()];     }          public static int getMin(int a, int b, int c) {         if(a < b && a < c) return a;         if(b < c) return b;         return c;     }          public static void main(String[] args) {         System.out.println(minDistance(\"algorithm\", \"altruistic\"));     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a typical dynamic problem called Edit Distance.  pasted my solution here:     public static int minDistance(String word1, String word2) {         // Start typing your Java solution below         // DO NOT write main() function         int[][] ans = new int[word1.length() + 1][word2.length() + 1];         for(int i = 0; i < word1.length() + 1; i++) {             ans[i][0] = i;         }         for(int i = 0; i < word2.length() + 1; i++) {             ans[0][i] = i;         }                  for(int i = 1; i < word1.length() + 1; i++) {             for(int j = 1; j < word2.length() + 1; j ++) {                 if(word1.charAt(i -1) == word2.charAt(j - 1)) {                     ans[i][j] = getMin(ans[i-1][j-1], ans[i-1][j] + 1, ans[i][j-1] + 1);                 } else {                     ans[i][j] = getMin(ans[i-1][j-1] + 1, ans[i-1][j] + 1, ans[i][j-1] + 1);                 }             }         }                  return ans[word1.length()][word2.length()];     }          public static int getMin(int a, int b, int c) {         if(a < b && a < c) return a;         if(b < c) return b;         return c;     }          public static void main(String[] args) {         System.out.println(minDistance(\"algorithm\", \"altruistic\"));     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"there is another thing that can be kept in mind while solving: there is a fixed cost of either deletion or insertion if the lengths of the input strings are different. and the additional cost can be thought of as the minimum hemming distance (multiplied by appropriate cost).  tried some code, there could be some bugs (and scope for improving efficiency) ..  have a slightly modified hemming distance calculator (adjusts length) and there is some redundancy in code .. but you know what to do about that :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the trivial algorithm that is optimal once memoized or done in a dynamic programming fashion"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Dynamic programming approach:  Let S[I][J] denote the min valued operation required to convert the 1st I chars of A into first J chars of B.   Let Cd Ci Cr denote the cost pf deletion, insertion and replacement respectively.  S[0][J] = 0;S[I][0]=0; S[I][J] = MIN ( S[I-1][J] + Cd , S[I][J-1] + Ci , (A[I] == B[J])? S[I-1][J-1], S[I-1][J-1] + Cr )   S[A.size()][B.size()] gives the optimal solution."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17697664","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"20","title":"Implement a simple regex parser which, given a string and a pattern, returns a boolean indicating whether the input matches the pattern. By simple, we mean that the regex can only contain one special character: * (star). The star means what you'd expect, that there will be zero or more of any character in that place in the pattern. However, multiple consecutive stars are allowed. Some examples of valid input (and expected output):  f(a*b, acb) => true f(abc*, abbc) => false f(**bc, bc) => true","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Brute force for O(n2) complexity"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool match(char *first, char * second) \n{ \n    // If we reach at the end of both strings, we are done \n    if (*first == '\\0' && *second == '\\0') \n        return true; \n  \n    // Make sure that the characters after '*' are present in second string. \n    // This function assumes that the first string will not contain two \n    // consecutive '*' \n    if (*first == '*' && *(first+1) != '\\0' && *second == '\\0') \n        return false; \n  \n    // If the first string contains '?', or current characters of both \n    // strings match \n    if (*first == '?' || *first == *second) \n        return match(first+1, second+1); \n  \n    // If there is *, then there are two possibilities \n    // a) We consider current character of second string \n    // b) We ignore current character of second string. \n    if (*first == '*') \n        return match(first+1, second) || match(first, second+1); \n    return false; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def match_advance(ri, regexp, si, string)  \n rend = ri == regexp.length \n send = si == string.length \n \n if rend && send then return true end \n if rend && !send then return false end \n \n rc = regexp[ri].chr \n if rc == \"*\" then \n  return match_advance(ri+1, regexp, si, string) || # assume regexp wasn't matching \n  match_advance(ri+1, regexp, si+1, string) # assume regexp did match \n else \n  if send then return false end \n \n  sc = string[si].chr \n  if rc != sc then return false \n  else return match_advance(ri+1, regexp, si+1, string) end \n end \nend \n \ndef reg(regexp, string) \n return match_advance(0, regexp, 0, string) \nend \n \nputs reg(\"a*b\", \"acb\") \nputs reg(\"abc*\", \"abbc\") \nputs reg(\"**bc\", \"bc\") \nputs reg(\"ba**\", \"badfg\") \nputs reg(\"ba**\", \"badfg\") \nputs reg(\"abc\", \"abcdef\") \nputs reg(\"abcdef\", \"abc\") \nputs reg(\"\", \"\")"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n#include \nmain() \n{ \n char pat[10], input[10]; \n int i, found=1; \n clrscr(); \n cout<<\"enter pattern: \"; \n cin>>pat; \n cout<<\"enter input: \"; \n cin>>input; \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static boolean matches(String str, String pat) { \n  int strLen = str.length(); \n  int patLen = pat.length(); \n  int pati = 0, stri = 0; \n  while (pati < patLen || stri < strLen) { \n   if (pati + 1 < patLen && pat.charAt(pati + 1) == '*') { \n    while (stri < strLen && str.charAt(stri) == pat.charAt(pati)) \n     stri++; \n    pati += 2; \n   } else if (stri < strLen && pati < patLen \n     && str.charAt(stri) == pat.charAt(pati)) { \n    stri++; \n    pati++; \n   } else \n    return false; \n  } \n  return true; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is an iterative solution. Complexity O(n)  Algorithm: 1. If the pattern starts with '*', start matching from the back until you hit the '*' and return result 2. If the pattern ends with '*' start matching from the beginning until you hit the * and return result 3. Perform 1 and 2 simultaneously and return result."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//1 is for true //0 is for false"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"That's not at all what I expect * to do. I expect to match zero or more of the previous character. I guess it makes sense that Microsoft is asking this question because the bastardization of * is due largely to Word and Excel search boxes."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Dynamic Programming. If n = len(regex) and m  = len(word) have time = O(n * m) and space O(m)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class Program     {         static void Main(string[] args)         {             char[] pat0 = new char[] { '*', 'a', 'b', 'c', 'd' };             char[] iTrue0 = new char[] { 'r', 't', 'a', 'b', 'c', 'd' };             Console.WriteLine(ValidatePatten(pat0, iTrue0));             char[] iFalse0 = new char[] { 'r', 't', 'a', 'c', 'c', 'd' };             Console.WriteLine(ValidatePatten(pat0, iFalse0));              char[] pat1 = new char[] { 'a', 'b', 'c', '*', 'd' };             char[] iTrue1 = new char[] { 'a', 'b', 'c', 'r', 't', 'd' };             Console.WriteLine(ValidatePatten(pat1, iTrue1));             char[] iFalse1 = new char[] { 'a', 'b', 'c', 'r', 't', 'd', 'e' };             Console.WriteLine(ValidatePatten(pat1, iFalse1));              char[] pat2 = new char[] { 'a', 'b', 'c', 'd', '*' };             char[] iTrue2 = new char[] { 'a', 'b', 'c', 'd', 'r', 't'  };             Console.WriteLine(ValidatePatten(pat2, iTrue2));             char[] iFalse2 = new char[] { 'a', 'b', 'c', 'r', 't', 'd' };             Console.WriteLine(ValidatePatten(pat2, iFalse2));         }          static bool ValidatePatten(char[] pattern, char[] input)         {             int pLen = 0;             int iLen = 0;             bool result = false;              while (pLen < pattern.Length && iLen < input.Length)             {                 if (pattern[pLen] == input[iLen])                 {                     pLen++;                     iLen++;                 }                 else if (pattern[pLen] == '*')                 {                     pLen++;                     //if '*' is at the end, there is no need to do the matching if previous all matched.                     if (pLen == pattern.Length) iLen = input.Length;                 }                 else if (pattern[pLen] != input[iLen])                 {                     iLen++;                 }             }              if (pLen == pattern.Length && iLen == input.Length)                 result = true;              return result;         }     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"C# implementation"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Modifying KMP algorithms at the char after * mismatched to move to * in pattern string"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool bIsStringInPattern(PTCHAR pStr, PTCHAR pPattern) \n{ \n if(NULL == pStr || NULL == pPattern || 0 == iStrLen || 0 == iPLen) \n { \n  return false; \n } \n \n int iStrLen = _tcslen(pStr); \n int iPLen = _tcslen(pPattern); \n \n bool bRet = true; \n int i=j=0; \n  \n while(i < iStrLen && j < iPLen) \n { \n  if(pPattern[j] != pStr[i] && pPattern[j] != '*') \n  { \n   bRet = false; \n   break; \n  } \n  if(pPattern[j] == '*') \n  { \n   if((j + 1) < iPLen && pPattern[j+1] == '*') \n   { \n    j++; \n    continue; \n   } \n   if((j + 1) < iPLen && pPattern[j + 1] != pStr[i]) \n   { \n    i++; \n    continue; \n   } \n  } \n  j++; \n  i++; \n } \n  \n // (acb, acb***c, ) \n if(bRet && i >= iStrLen && j < iPLen) \n { \n  //good case is (acb, acb*******) \n  while(j < iPLen) \n  { \n   if(pPattern[j] != '*') \n   { \n    bRet = false; \n    break; \n   } \n   j++; \n  } \n } \n \n // what about (acbsrcs, a*b) or (acbsrcs, a*) or (acbsrcs, a****) \n if(bRet && i < iStrLen && j >= iPLen) \n { \n  if(pPattern[j-1] != '*') \n  { \n   bRet = false; \n   break; \n  } \n } \n \n return bRet; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17562671","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"8","title":"Design a class structure for an airport terminal, where your primary use case is allocating runway time to approaching aircraft. For example, an instance of a terminal may have only two runways of different lengths and must schedule these among five aircraft of different types requesting permission to land.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"class terminal { }  Terminal will have multiple objects of Runway class Runway {  string type;  Ctime t  // class which holdsTime occupied }  class Aircraft { }  class  : Aircraft { }  In the main program I can stacks depending on the size of runways. 1 stack for small runways and second for long runways Depending on the type of aircraft and runway runway is allocated and that stack is popped. Once it gets freed, stack gets pushed"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This seems to me a concurrent application  Something like this:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Terminal \n        { \n            private class WaitingRunwayRequestor \n            { \n                public IRunwayRequestor runwayRequestor; \n                public int minLength; \n            } \n \n            public List AvailableRunways{get;set;} \n            public List WaitingRunwayRequestors { get; set; } \n \n            public Terminal() \n            { \n                AvailableRunways = new List(); \n                WaitingRunwayRequestors = new List(); \n            } \n \n            public void RequestRunway(IRunwayRequestor runwayRequestor, int minLength) \n            { \n                Runway allocatedRunway=null; \n \n                foreach (Runway runway in AvailableRunways) \n                { \n                    if (runway.length >= minLength) \n                    { \n                        allocatedRunway = runway; \n                        runwayRequestor.AssignRunway(runway); \n                    } \n                } \n \n                if (allocatedRunway != null) \n                { \n                    AvailableRunways.Remove(allocatedRunway); \n                } \n                else \n                { \n                    WaitingRunwayRequestors.Add(new WaitingRunwayRequestor() { runwayRequestor = runwayRequestor, minLength = minLength }); \n                } \n            } \n \n            public void ReturnRunway(Runway runway) \n            { \n                WaitingRunwayRequestor allocatedRunwayRequestor = null; \n \n                foreach (WaitingRunwayRequestor waitingRunwayRequestor in WaitingRunwayRequestors) \n                { \n                    if (waitingRunwayRequestor.minLength <= runway.length) \n                    { \n                        allocatedRunwayRequestor = waitingRunwayRequestor; \n                        waitingRunwayRequestor.runwayRequestor.AssignRunway(runway); \n                    } \n                } \n                if (allocatedRunwayRequestor != null) \n                { \n                    WaitingRunwayRequestors.Remove(allocatedRunwayRequestor); \n                } \n                else \n                { \n                    AvailableRunways.Add(runway); \n                } \n            } \n \n        } \n        public class Runway \n        { \n            public readonly int length; \n            public readonly Terminal terminal;//same runway cannot be at 2 terminals \n \n            public Runway(Terminal terminal, int length) \n            { \n                this.terminal = terminal; \n                this.length = length; \n            } \n        } \n         \n        public interface IRunwayRequestor \n        { \n            void AssignRunway(Runway runway); \n            void ReturnRunway(); \n        } \n        public abstract class RunwayRequestor \n        { \n            public Runway AssignedRunway{get; set;} \n            public Terminal Terminal { get; set; } \n \n            public virtual void AssignRunway(Runway runway) \n            { \n                this.AssignedRunway = runway; \n            } \n            public virtual void ReturnRunway() \n            { \n                Terminal.ReturnRunway(AssignedRunway); \n                AssignedRunway = null; \n            } \n        } \n        public class Aircraft : RunwayRequestor \n        { \n            public Aircraft(Terminal terminal) \n            { \n                this.Terminal = terminal; \n            } \n \n            public override void AssignRunway(Runway runway) \n            { \n                base.AssignRunway(runway); \n                Land(); \n            } \n            public void Land() \n            { \n                //perform takeoff \n \n                ReturnRunway(); \n            } \n        } \n        public class MaintenanceCrew : RunwayRequestor \n        { \n            public MaintenanceCrew(Terminal terminal) \n            { \n                this.Terminal = terminal; \n            } \n \n            public override void AssignRunway(Runway runway) \n            { \n                base.AssignRunway(runway); \n                PerformMantenance(); \n            } \n            public void PerformMantenance() \n            { \n                //perform maintenance \n \n                ReturnRunway(); \n            } \n \n        }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17417667","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"Write a service or services to support tic-tac-toe between two players, on an infinite board. Normal rules apply (i.e. three in a row to win), but the players are not limited to a 3X3 board and can choose to place an X or an O in any arbitrary, positive (i, j) position. Solution should be as space and time efficient as possible. Your service is only responsible for maintaining and updating the state of the board between two players, given their sequence of moves.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Since the service need to track only the player moves and subsequent state changes, the board size (infinity) does not  matter. Another reason why the infinite expanse of the board does not matter is this: since the player who gets the 3 consecutive/contiguous blocks win, the other play will be forced to play in the same vicinity as the first player. he players can start anywhere on the board, as long as the service maintains a log of moves and the state changes.   For a player to win, she must play at least 4 moves for a 3 in a row state. Sometimes, she will need 5 moves or perhaps higher in this case. So evidently, we will need to track the blocks marked by the players in each move. I am thinking of using a stack for each player. Popping the stack every 4th move for each player, check each moves, meaning the cells for their adjacency. This is O(1) time efficient.   The adjacency is proved by: 1. If rows match across the moves (row match) 2. If cols match across the moves (column match) 3. If rows and cols both increase or decrease (diagonal match)  (agreed i need to elaborate on this)  if not match is found, discard the stack, start again.   (There are gaps in this approach, but would be happy to hear other alternatives)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17632666","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"23","title":"Truth Table implementation: Write a function which takes integer as In put parameter (let's say n), print all True (T) , False (F) combinations n times. Here is the example:  for n = 1 Output :  T F  for n = 2 Output :  T F F T  For n = 3 Output :","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"Nothing fancy, just tail recursion (pass empty string for 2nd argument)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"We can print using binary equivalent of number from 0 to pow(2,n) Code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public static void printTruthTable(int n) \n { \n  int[] out=new int[n]; \n  printTruthTableAux(n,0,out); \n } \n \n private static void printTruthTableAux(int n, int d, int[] out) { \n  if(d==n) \n  { \n   printArray(out); \n   return; \n  } \n  for(int i=0;i<=1;i++) \n  { \n   out[d]=i; \n   printTruthTableAux(n,d+1,out); \n  } \n   \n } \n \n private static void printArray(int[] out) { \n  char res; \n  for(int a:out) \n  { \n    res= a==0? 'F' : 'T'; \n    System.out.print(res + \" \"); \n  } \n  System.out.println(); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I think this is a good entry-level question for three reasons: (1) its solution doesn't require foreknowledge of any \"trick\", just a basic understanding of recursion and how to use it to do multi-combinations. (2) the implementation is elementary enough to code in 15-60 minutes, while under the stress of interviewing for a job. (3) it requires just enough attention to detail so that a candidate unable to code this on a whiteboard, and explain the answer, will not likely be successful coding on your team.  Note, however, that the converse is not true: success at answering this question will NOT tell you if someone is a good programmer since it can be practiced or memorized.  However, there is NO interview-coding question that can really tell you if someone is a good programmer.  I do NOT recommend this question for senior candidates unless you're just pre-screening.  It's insulting and shows the candidate that the interviewer doesn't really know what he's doing.  Moreover, it's a waste of time that could be used to ask more salient questions (e.g. \"how would you architect X\" or \"tell me about a time when Y\" ).  Here's a recursive solution in D, which I think may be a little easier to understand than some of the other fine solutions presented earlier.  The time complexity is O(m^n) where m is the length of the alphabet; the space complexity is O(n).  For a truth table, the alphabet is simply \"TF\""},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Dhass's method also can work, but if the input number is larger than 32 or 64, it won't work. Use a array (integer or bool), which length is n,  as {x(n), x(n-1), ..., x(1)} and x(i) = 1 or 0 (true or false),  imitating the process, add 1 (or do bit operation from x(1) to x(n). Repeat the process until the array become all 0 (or all false)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be achieved in C# in one for loop as shown in the code below: for (int i = 0; i < Math.Pow(2, n); i++)  Console.WriteLine(Convert.ToString(i, 2).PadLeft(n, '0').Replace(\"0\", \"F\").Replace(\"1\", \"T\"));"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be achieved in C# in one for loop as shown in the code below:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class SpecialPermIterator implements Iterator { \n \n  private static final int MAX_SEQ_LENGTH = 30; \n   \n  private int curValue = 0; \n   \n  private final int seqLength; \n  private final int maxValue; \n   \n \n  private final char[] arr; \n   \n   \n  public SpecialPermIterator(int seqLength){ \n    \n   if( seqLength < 1 ){ \n    throw new IllegalArgumentException( \"Can't create iterator  for value '\" + seqLength + \"', value should be greater then 1\" ); \n   } \n    \n   if( seqLength > MAX_SEQ_LENGTH ){ \n    throw new IllegalArgumentException( \"Sequence length too big, current '\" + seqLength + \"', max value '\" + MAX_SEQ_LENGTH + \"'\"); \n   } \n    \n   this.seqLength = seqLength; \n   this.maxValue = 1 << seqLength;    \n   this.arr = new char[seqLength]; \n  } \n   \n  @Override \n  public boolean hasNext() { \n   return curValue < maxValue; \n  } \n \n  @Override \n  public String next() { \n    \n   if( !hasNext() ){ \n    throw new NoSuchElementException(); \n   } \n    \n   String res = toBinaryString(curValue, seqLength); \n   ++curValue; \n    \n   return res; \n  } \n \n  @Override \n  public void remove() { \n   throw new UnsupportedOperationException();    \n  } \n   \n \n   \n  private String toBinaryString(int value, int length ) { \n       \n   int mask = 1; \n    \n   for( int i = 0; i < length; i++ ){    \n    arr[length-i-1] = (( value & mask ) == 0 ? 'F' : 'T' ); \n    mask <<= 1; \n   } \n    \n   return new String(arr); \n  } \n   \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import sys \n \ndef print_bits(n, num_bits): \n    for i in xrange(num_bits-1, -1, -1): \n        if (n >> i) & 0x1: \n            sys.stdout.write('T ') \n        else: \n            sys.stdout.write('F ') \n    sys.stdout.write(\"\\n\") \n \ndef print_truth_table(n): \n    for i in xrange(0, 2**n): \n        print_bits(i, n) \n \nif __name__ == \"__main__\": \n    truth_table(5)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorry. I  missed two more rows in my question , if n = 2. Here is complete list for n = 2. Output :  T F  F T T T F F"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This solution is iterative and has complexity O(n*2^n). But uses constant memory. The logic is to flip entries every time based on the position of the entry and the iteration number."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class Program \n    { \n        static void Main(string[] args) \n        { \n            int n = 0,Q=0,R=0; \n            String line =\" \"; \n            \n            Console.WriteLine(\"Enter no of combinations\"); \n            n = int.Parse(Console.ReadLine().ToString()); \n            int possibilities = (int)Math.Pow(2,n) ; \n            for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  #include   int main() {         int number1, i, j ;         long  number;         printf(\"Enter the Number:\");         scanf(\"%d\",&number1);         number = pow(2, number1);         printf(\"Printing the square of the number %ld\\n\", number);         for(j=0; j                {                         for(i=0;i                                {                                         printf(\"%s\", (j << i & 1 << (number1 -1)) ? \"T  \":\"F  \");                                 }                         printf(\"\\n\");                 }                 printf(\"\\n\");           return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It's just a binary representation of numbers in [0, n]."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It may overflow when using power2 To avoid this problem, please see sites.google.com/site/spaceofjameschen/home/stl/truth-table-implementation-microsoft"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \n \nint main() \n{ \n int n; \n int total; \n int i, j; \n printf (\"Enter n\\n\"); \n scanf (\"%d\", &n); \n total = pow (2, n); \n for (i = 0; i < total; i++) \n { \n  for (j = ( n - 1 ); j >= 0; j--) \n   (! ( i & ( 1 << j ))) ? printf (\"F\") : printf (\"T\"); \n  printf (\"\\n\"); \n } \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void truthTable(int n, String str, int ind) { \n     if(ind == n) { \n         System.out.println(str); \n         return; \n     } \n     truthTable(n, str + 'T', ind + 1); \n     truthTable(n, str + 'F', ind + 1); \n }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17472666","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"25","title":"Given a sequence of numbers (or array).Find the maximum distance between all the same numbers.Like you have 1,2,3,4,1,1,7,4 so max(1)=5,max(2)=0 max(4)=4. etc.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"enter each element in hash table and store starting and ending index. first time inserting an element in hash table starting and ending index is same, after that for duplicate elements update the ending index...  for each element the max distance will be (end index - start index + 1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Time: O(N) Space: O(N)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Use a Self-Balanced Binary Search Tree. Let each node have 2 fields - start_index and end_index.  Insert elements into the BST along with the below operations. If the element is not found in BST, create a node in BST using a[i]. Let start_index=end_index=i If element is already found, then end_index=i  After inserting all the elements, traverse the BST to find the node with maximum distance.  Time Complexity Analysis ------------------------ Insert Operation= O(logN) Inserting N elements = O(NlogN) Other operations = O(1)  Time Complexity - O(NlogN) Space Complexity - O(N)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"One more solution: Find the last occurrence of element by traversing from end.  Code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a = [1,2,3,4,1,1,7,4] \nmax_dist = {} \n \nfor i,e in enumerate(a): \n    if e in max_dist: \n        max_dist[e][-1] = i \n    else: \n        max_dist[e] = [i,i] \nfor k,v in max_dist.items(): \n    print '{0}:{1}'.format(k,v[-1]-v[0])"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"c++ code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static HashMap findAllMaxDistance(int[] arr){ \n HashMap hashFirst = new HashMap(); \n HashMap hashLast = new HashMap(); \n HashMap result = new HashMap(); \n  \n /* Record the first index for all the characters */ \n for(int i = 0; i < arr.length; i++){ \n  if(!hashFirst.containsKey(arr[i])){ \n   hashFirst.put(arr[i], i); \n  } \n } \n /* Record the last index for all the characters */ \n for(int i = arr.length - 1; i >= 0; i--){ \n  if(!hashLast.containsKey(arr[i])){ \n   hashLast.put(arr[i], i); \n  } \n } \n /* Compute the max distance for all the characters */ \n for(int i = 0; i < arr.length; i++){ \n  if(!result.containsKey(arr[i])){ \n   result.put(arr[i], hashLast.get(arr[i]) - hashFirst.get(arr[i])); \n  } \n } \n  \n return result; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.HashMap; \nimport java.util.Map; \npublic class MaxDistance { \n    public static Map getMaxDists(int a[]) { \n        Map ret = new HashMap(); \n        Map firstOccurance = new HashMap(); \n        int maxDist = 0; \n        for (int i = 0; i < a.length; ++i) { \n            Integer j = firstOccurance.get(a[i]); \n            if (j == null) { \n                firstOccurance.put(a[i], i); \n                j = i; \n            } \n            ret.put(a[i], i - j); \n        } \n        return ret; \n    } \n    public static void main(String args[]) { \n        int a[] = new int[] {1, 2, 3, 4, 1, 1, 7, 4}; \n        Map ans = getMaxDists(a); \n        for (Map.Entry entry : ans.entrySet()) { \n            System.out.println(entry.getKey() + \" \" + entry.getValue()); \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"not understood"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Logic: -Search the first occurrence of  element from left side say elementLeftIndex -Search the first occurrence of  element from right side say elementRightIndex -now [elementLeftIndex-elementRightIndex+1] is the max length as asked in qus -apply logic for all elements"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Correct me if I'm wrong, but isn't the max distance the position of the last occurrence subtracted from the position of the first occurrence?  In C#"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"HashMap l_DistMap = new HashMap(); \n   \n  for (int i = 0 ; i < input.length; i++) \n  { \n   if(! l_DistMap.containsKey(input[i])) \n    l_DistMap.put(input[i],i); \n  } \n   \n  int l_minIndex; \n   \n  for (int i = input.length - 1 ; i >= 0; i--) \n  { \n   if(l_DistMap.containsKey(input[i])) \n   { \n    l_minIndex = Integer.parseInt(l_DistMap.get(input[i]).toString()); \n    System.out.println(input[i] + \":\" + i + \" - \" + l_minIndex + \" = \" + (i - l_minIndex)); \n    l_DistMap.remove(input[i]); \n   } \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"HashMap l_DistMap = new HashMap(); \n   \n  for (int i = 0 ; i < input.length; i++) \n  { \n   if(! l_DistMap.containsKey(input[i])) \n    l_DistMap.put(input[i],i); \n  } \n   \n  int l_minIndex; \n   \n  for (int i = input.length - 1 ; i >= 0; i--) \n  { \n   if(l_DistMap.containsKey(input[i])) \n   { \n    l_minIndex = Integer.parseInt(l_DistMap.get(input[i]).toString()); \n    System.out.println(input[i] + \":\" + i + \" - \" + l_minIndex + \" = \" + (i - l_minIndex)); \n    l_DistMap.remove(input[i]); \n   } \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"HashMap l_DistMap = new HashMap(); \n   \n  for (int i = 0 ; i < input.length; i++) \n  { \n   if(! l_DistMap.containsKey(input[i])) \n    l_DistMap.put(input[i],i); \n  } \n   \n  int l_minIndex; \n   \n  for (int i = input.length - 1 ; i >= 0; i--) \n  { \n   if(l_DistMap.containsKey(input[i])) \n   { \n    l_minIndex = Integer.parseInt(l_DistMap.get(input[i]).toString()); \n    System.out.println(input[i] + \":\" + i + \" - \" + l_minIndex + \" = \" + (i - l_minIndex)); \n    l_DistMap.remove(input[i]); \n   } \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Create an array called index array which stores the indexes of elements of input array. Initialize index[i]=i for i=0 to n-1 2. Now sort the input array and while sorting also maintain the order of indexes in index array corresponds to the each element in the input array. This can be done using O(nlogn) sorting algorithm 3. Now traverse both the input and index arrays and calculate the max length for each element. This can be done on O(n) time.  Time Complexity: O(nlogn) Space: O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hope this won't be considered cheating ;)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Iterate over an array from start to end for a given number, find out its first and last position in an array"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17597662","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"18","title":"Given an array of integers, find all sub-arrays whose elements sum zero. 1.-1,4,-4 has 3 such arrays 1 to -1, 1 to -4 and 4 to -4","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"You can solve this one in linear time using dynamic programing, hear me out.  Basically you store the sum in an array from start till the point. That can be done in 1 pass. After that basically you look for twins in the array and all numbers in b/w are subsets of 0.  Its basically because numbers that add to 0 do not change the total sum of all numbers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Bruteforce solution. time: O(N^2), space: O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This solution uses O(n square) space, O(n) time -  calc all subarray sums & store in a 2D matrix (actually uses only half the matrix) print subarrays as you find 0 subarray sums"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"solve using subset sum problem with one additional constraint, which is to find only two elements which add up to k. Using binary tree example as explained in this paper.Very nice approach. www dot wou.edu/~broegb/Cs345/SubsetSum.pdf"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Given array arr, create array run so that run[i] = sum(arr[0..i]), you can do this in linear time. Now look for duplicate entries in run. You can do this by scanning over it, checking if an element is in the hashmap, if yes we have a duplicate and so a sum to zero, if not add it to the map."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is NPC - a variation of subset sum"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"a"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"edit it will require O(n^2) using recursion here {{ def findSum(array,index,sum,path):        if index >= len(array):           return         sum = sum  + array[index]        path.append(array[index])        if sum == 0 :            print path        findSum(array,index+1,sum,path)        findSum(array,index+1,0,[]) }}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17336677","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"8","title":"Given a mathematical expression, remove the redundant brackets from the expression. e.g. input: (a + (b*c)) * (d * ( f * j) ) output should be: (a + b * c) *d * f * J  operations to support: +, -, /, *, ++, also ternary operators.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this: 1) Convert the expression to post fix notation 2) Convert the post fix notation back to infix"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the priority of operators is \"++\" > \"* /\" > \"+ -\" > \"( or ) or boundary of the string\" So for expression like \"opA(...op1...opN...)opB\", if the priority of Min{op1....opN} is >= Max{opA, opB}, then the () can be removed. Firstly, remove redundant brackets like ((....)) Secondly, process the () from outter to inner (when processing the outter \"()\" ingore the operators inside the inner \"()\")"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Which team asked this ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Little cowboy coding but it should work. The idea is to go recursive and solve each bracket seprately. Follow the BODMAS rule and set priorities (except 'B' has a -ve priority because w want to remove that."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If an expression that has brackets results in the same postfix expression as the one without any brackets. Then all the brackets can be removed.  Algorithm - assuming that brackets are legally placed 1) Compute the postfix expression of the given expression (say STR) with brackets, lets call this postFix(STR) = orgPost 2) For each pair of bracket with STR   a) Remove the pair of bracket and compute STR'   b) if postFix(STR')=orgPost then STR=STR' 3) Return STR"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Keep on pushing the operators into a stack and keep a track of the braces corresponding to the two pushed operators. If the operators are of unequal priority, let the braces remain, otherwise, remove them. Please correct me if I am wrong."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17297667","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"10","title":"Write a function to populate the best (lowest cost) path in a 64x64 weighted grid from a given start cell to a destination cell.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"if weights are non-negative and there are no cycles allowed: Djikstra's Algorithm if weights can be negative and possible negative cycles may exist: Bellman-Ford Algorithm"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Yes..We can use DP to get the shortest path here..Complexity would be O(n2)  Code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if the path is only allowd to move right or down or rightdown then the algorithm like DP can be used. else Djikstra should be used. Suppose  1 0 1 1 0 1 0 0 1 0 1 0 start point is (0, 0) end point is (3, 2) under this condition, Djikstra should be used."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Djikstra's Algorithm Implementation in C#"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Implementing Djikstra's Algorithm  here is not easy. I guess a lot of modifications are to be done for it. DP solution is what is best."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17332663","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"0","title":"Design a task scheduler"}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17339664","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"Design a vending machine.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include   \nusing namespace std;  \n \nclass VendingMachine \n{ \n private: \n  int iWaterPending_; \n  int iCoffeePending_; \n  int iTeaPending_; \n  int iSoupPending_; \n \n        int iMaxWaterCount_; \n        int iMaxCoffeCount_; \n        int iMaxTeaCount_; \n        int iMaxSoupCount_; \n public: \n        VendingMachine() \n        { \n            iWaterPending_ = iCoffeePending_ = iTeaPending_ = iSoupPending_ = 0; \n            iMaxWaterCount_ = iMaxCoffeCount_ = iMaxTeaCount_ = iMaxSoupCount_ = 0; \n        } \n \n        VendingMachine(int iMaxWater, int iMaxCoffee, int iMaxTea, int iMaxSoup) : \n            iMaxWaterCount_(iMaxWater), iMaxCoffeCount_(iMaxCoffee), iMaxTeaCount_(iMaxTea),  \n            iMaxSoupCount_(iMaxSoup) \n        { \n        } \n         \n        void AddWater(int iCount) \n        { \n            if (iWaterPending_ + iCount > iMaxWaterCount_) \n            { \n                //! print error message \n                return; \n            } \n            iWaterPending_ += iCount; \n        } \n         \n        void AddCoffee(int iCount) \n        { \n            if (iCoffeePending_ + iCount > iMaxCoffeCount_) \n            { \n                //! print error message \n                return; \n            } \n            iCoffeePending_ += iCount; \n        } \n \n        void AddTea(int iCount) \n        { \n            if (iTeaPending_ + iCount > iMaxTeaCount_) \n            { \n                //! print error message \n                return; \n            } \n            iTeaPending_ += iCount; \n        } \n \n        void AddSoup(int iCount) \n        { \n            if (iSoupPending_ + iCount > iMaxSoupCount_) \n            { \n                //! print error message \n                return; \n            } \n            iSoupPending_ += iCount; \n        }    \n \n        void GetCoffee() \n        { \n            if (iCoffeePending_ == 0) \n            { \n                // Print error message \n                // Water comes out without coffee \n                iWaterPending_ = iWaterPending_ - 1; \n                return; \n            } \n            iCoffeePending_ = iCoffeePending_ - 1; \n            iWaterPending_ = iWaterPending_ - 1; \n        } \n        //! Similar functions for GetSoup, GetTea and GetWater \n};"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17333668","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"11","title":"array of numbers are given. WAP to find the sum of contiguous subarray within a one-dimensional array of numbers which has the largest sum.  Follow up: After writing program to return the largest sum modify it to return the start and end index of such a subarray.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void maxsum(int *a,int n){ \n \nint max_so_far=a[0],max_end_here=a[0]; \nint start,end,temp_start,i; \n \nfor(i=0;imax_so_far){ \n  max_so_far=max_end_here; \n  start=temp_start; \n  end=i; \n   \n } \n \n} \n \nprintf(\"( %d , %d )  %d\",start,end+1,max_so_far); \n \nreturn; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Kadane's algorithm"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Dynamic programming:-Maximum subarray problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using System; \n \nclass Program \n{ \n    public static void Main(){ \n        int[] a = {1,2,3,-3,4}; \n        int n = a.Length; \n        int maxSum = 0; \n \n        for(int i=0;i maxSum) \n                    maxSum = workingSum; \n            } \n        } \n \n        Console.WriteLine(maxSum); \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if  a[i] < a[i] + a[i-1]  then  a[i] = a[i] + a[i-1]       for all i>0 and then find maximum  time complexity = O(n) and no extra memory required"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class ArrayMaxSum { \n \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n \n  String string = \"1,2,-10,3,4,-20,5,6,4,-50,9,0,-1\"; \n  String[] numbers = string.split(\",\"); \n \n  LinkedList lst = new LinkedList(); \n  LinkedList tmp = new LinkedList(); \n \n  int max_so_far = 0; \n  int max_ending_here = 0; \n \n  for (int i = 0; i < numbers.length-1; i++) \n  { \n    \n   max_ending_here = max_ending_here + Integer.parseInt(numbers[i]); \n   lst.add(numbers[i]); \n \n   if (max_ending_here < 0) \n   { \n    max_ending_here = 0; \n    lst.clear(); \n   } \n \n   if (max_ending_here > max_so_far) \n   { \n    tmp.clear(); \n    max_so_far = max_ending_here; \n    tmp.addAll(lst); \n   } \n \n  } \n \n  for(String str : tmp) \n  { \n   System.out.print(str+\", \"); \n  } \n  System.out.print(\" = \"+max_so_far); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using System; \n \nnamespace Algorithms \n{ \n    class Program \n    { \n        static void Main(string[] args) \n        { \n            Program p = new Program(); \n            int[] array = { 31, -41, 59, 26, -53, 58, 97, -93, -23, 84 }; \n \n            int result = p.ArrayMaxSum(0, array.Length - 1, array); \n            Console.Write(result.ToString()); \n            Console.ReadKey(); \n        } \n \n        public int ArrayMaxSum(int lowerBound, int upperBound, int[] array) \n        { \n           \n            if (lowerBound > upperBound) \n                return 0; \n \n            if ( lowerBound == upperBound ) \n            { \n               return Math.Max(0,array[lowerBound]); \n             } \n \n            int mid = (lowerBound + upperBound) / 2; \n \n            int sum = 0; \n            int lmax = 0; \n \n            for (int i = mid; i >= lowerBound; i--) \n            { \n                sum = sum + array[i]; \n                lmax = Math.Max(lmax, sum); \n                \n            } \n \n            sum = 0; \n \n            int rmax = 0 ; \n            for (int i = mid+1 ; i <= upperBound; i++) \n            { \n                sum = sum + array[i]; \n                rmax = Math.Max(rmax, sum); \n                \n            } \n \n           \n            return Math.Max((lmax + rmax), Math.Max(ArrayMaxSum(lowerBound, mid, array), ArrayMaxSum(mid + 1, upperBound, array))); \n        } \n    } \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17337664","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"12","title":"Given an array with source code and braces (braces means  '{' or '}' ) intermixed. WAP to return true of braces are balanced (implies that for each opening brace there must be a closing brace and for each closing brace there must be opening brace) and false otherwise.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"I too thought of using the stack but realized it is not doing anything better than just keeping a count variable and without the stack it is more space efficient."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Take a stack and scan the input character by character from beginning to end. For every opening brace you encounter, push char '{' on to the stack and for every closing brace pop one '{'. At the end of input stream, if stack is non-empty then it is unbalanced, if not balanced.  Time complexity : O(n) Space complexity :O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Shall we use three integer variables one for ( and the second for [ and the another one for { and increment these variable when those characters are encountered and decrease those variables when ) and ] and } are encountered"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"HashMap braceMap = new HashMap(); \n  braceMap.put(\"}\", \"{\"); \n  braceMap.put(\")\", \"(\"); \n  braceMap.put(\"]\", \"[\"); \n   \n  Stack braceStack = new Stack(); \n  String c; \n  boolean l_value = true; \n  for (int i = 0 ; i < braces.length(); i++) \n  { \n   c = String.valueOf(braces.charAt(i)); \n   if (braceMap.containsKey(c)) \n   { \n    if(braceStack.isEmpty() || ! braceMap.get(c).equals(braceStack.pop())) \n    { \n     l_value = false; \n     break; \n    } \n   } \n   else \n    braceStack.push(c); \n  } \n  if(l_value) \n   System.out.println(\"Valid Braces\"); \n  else \n   System.out.println(\"Invalid Braces\");"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"String code = \"#{code{anotherCOde}}dsd}}\"; \n  int count = 0; \n \n  for (int i = 0; i < code.length(); i++) { \n   if (code.charAt(i) == '{') { \n    count++; \n   } else if (code.charAt(i) == '}') { \n    count--; \n   } \n  } \n \n  System.out.println(count == 0 ? \"true\" : \"false\");"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6337018766295040","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"7","title":"What do you think is the next big thing in technology? For example, search engine is Google, social media is Facebook, etc. etc...","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I vote for decentralized bitcoin technologies.  this is something smart people seem to like more the deeper into it they look .  Eliminating the requirement for trusted third parties (centralized banks, etc.) for transactions and contracts is quite a disruptive and revolutionary invention, IMO."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Home automation. We've seen fire alarms under Nest, however, in general home automation is lagging behind and has a lot of scope for improvement.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Would go for BYOD"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I vote for google driverless car for saving people's travel time!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Did microsoft say search engine is Google? Well sorry Bing"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"seems they also use google under the rug.........."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5680049562845184","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"\"How would you find the number of gas stations in the United States?\"  *You cannot look up any concrete information (like the average number of gas stations per state), but you need to yield an accurate answer.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Divide and conquer is a good stategy here.  Get the # of gas stations from each state and add them. Each state can subdivide its seach to districts and so on"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Well you can use order of magnitude estinations. First I assume that per person in the US 10 miles are driven 10^1 Next I assume that the population of the us is >300  10^9 (I round up from 10^~8.5) Using this I estimate that each day 10^10 miles are driven I assume average fuel consumption is 10^1 miles per gallon Now I can say that cars use 10^9 gallons I assume the average fuel tank is 10^1 I can guess that there are 10^8 refills per day I assume that a gas station on average services 10^3 cars My estimate is 10^5 gas stations in the US. Afterwards I looked it up and it's 121,446 so I did pretty well."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"From the US census you can look up what is the average density of gas station / population ( some number ). Multiply that by the population and you get the answer. 10 gas stations / 1000 people * (300,000) = 3000 gas stations. Although this answer will be within the standard deviation and you will have to find the upper and lower limit  +- std.dev. Another way would be to do data mining. Either way you need some information, you cannot pull a number out of thin air. Well, unless you travel through each and every street and corner of the country. Another great idea: gather telephone books from each and every area of the US and count the number of gas stations in each region and add them up. Not all gas stations are labelled gas stations.  So, pick and choose, or maybe another idea!!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I will GOOGLE it."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5204611044474880","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"3","title":"Implement a class that does string manipulation by overloading the following operators: <<, >>, = and ==.  For example consider the following code: StrShift example; example = ??Microsoft???; printf(??\\???example << 2\\??? results in %s\\n??, example << 2); In the above code the output would be ??ftMicroso??? which shows the last two characters of the string ??Microsoft??? rotated to the left of the string.  Please note that state is maintained so two calls of example << 1 would give the same end result as calling example << 2 once.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For  <<, >>, it works like the following: <1.Reverse the whole string first. 2.Reverse the first X substr. 3.Reverse the last length-X substr. For example: Microsoft << 2: 1. tfosorciM 2. First 2 chars, ftosorciM 3. Rest substr, ftMicroso;  The >>X operation works the same way except the reverse the Length-X chars first and than X chars."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Oper \n{ \n    ... \n    public string Value { get; private set; } \n} \n \npublic static string operator <<(Oper lh, int rh) \n{ \n    ... \n    int len = lh.Value.Length - rh; \n    return lh.Value.Substring(len) + lh.Value.Substring(0, len); \n} \n \nOper x = new Oper(\"Microsoft\"); \nstring t = x << 2; \noutput = ftMicroso"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Being a fairly easy question overall, in this case, I think the examiner would focus more on technical aspects. E.g. did you cover corner case, or NULL string, or syntax for overloading an operator   << or >> can be implemented using any of the two approaches mentioned above: a) Reverse entire string and then reverse parts of it b) Get a relevant substring at starting pos and append remaning string. Would require extra space  = can be implemented using a simple strncpy or memcpy == is strncmp"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5090344244871168","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"1","title":"3. Write a class that represents a minimal heap.  The heap class should at a minimum support the following methods: - AllocTinyHeap() which should initialize the heap with a given amount of bytes - DeleteTinyHeap() which frees all memory associated with the heap - TinyAlloc() which allocates a given number of bytes on the heap if there is room - TinyFree() which frees a specific location on the heap You may define whatever parameters are necessary for the above methods as well as write any additional methods.  Overall consideration will be given to correctness, design, code readability as well as any unit testing done.  As part of a final solution please submit test cases you used to verify correctness in addition to any unit tests done.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Looks like an coding test question?  One simple way to implement would be using linked lists. Every time TinyAlloc and TinyFree is done, have a LL node point to the mem allocated and the next chunk of available mem. One thing to watch out here for is fragmentation."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5661573955715072","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"13","title":"Move the first n numbers in a 10 element array to the end.  I think the way to do it was to reverse the array and then reverse the first 10-n and then the last n.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Here are the possible solutions:  Solution #1 (brute force)  1. temp = first element of array  2. Shift all the remaining array elements left by 1  3. last element of array = temp  4. Continue for n steps   Time complexity: O(n * k)  Solution #2 (with a temp array)  1. Copy the first n bits to a temp array.   2. Move the remaining arrayLength - n bits to front  3. Copy the temp array to the end  Space complexity: O(k), Time complexity: O(n)  Solution #3 (with reverse):  FrickinHamster solution - reverse the strings. But reversing a string takes O(n) and this will need 3 reverse. Good but not the best.  Solution #4 (most efficient solution and I think the interviewer is looking for this one)  Circular left shift the entire array with each element moved to right position at first iteration itself. This will utilize mod operation to compute next position. I could explain more, but the following link does a far better job. Time Complexity: O(k) Best case, O(n) average case  stackoverflow.com/questions/11893053/circular-left-shift-of-an-array-by-n-positions-in-java  PS: k = number of elements, n = array length"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The suggested method takes O(n) time for reversing the elements..  In java, we can use subList method of ArrayList class. I guess it takes constant time..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use LinkedList p://msdn.microsoft.com/ru-ru/library/he2s3bh7(v=vs.110).aspx"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class ReversefirstNuNUmbers { \n public static void main(String[] args) { \n  int a[] = { 2, 12, 8, 6, 5, 1, 2, 10, 3, 2 }; \n  reverseArray(a,3); \n  display(a); \n   \n } \n \n public static void display(int a[]) { \n  for (int a1 : a) { \n   System.out.print(a1 + \",\"); \n  } \n } \n \npublic static void reverseArray(int a[],int count) \n{ \n for (int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \nmain() \n{ \n        int a[10] = {1,2,3,4,5,6,7,8,9,0},*ptr,i,j,n; \n \n        ptr = malloc(10*sizeof(int)); \n \n        printf(\"enter how many no's wish to push\\n\"); \n        scanf(\"%d\",&n); \n \n        //copying last 10-n into ptr// \n \n        for(i=n,j=0;i<10;i++,j++) \n        { \n                *(ptr+j) = a[i]; \n        } \n \n        //copying first n into ptr // \n \n        for(i=0,j=10-n;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is array rotation question. wwwDOTgeeksforgeeks.org/array-rotation/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my algorithm :  Consider you have an array which can be split into A( first N elements), B( remaining array) 1. Reverse the first n elements in the array. 2. Reverse the elements n+1 to end of the of the array.  3. Reverse the whole array once.   Eg : say you have an Array  [1, 2, 3, 4, 5 ,6, 7,8,9,10]  say n = 3 meaning 3 elements have to copied to end of the array. expected output is [4,5,6,7,8,9,10,1,2,3]  1) we will have [3,2,1,4,5,6,7,8,9,10] 2) we will have [3,2,1,10,9,8,7,6,5,4] 3) we will have [4,5,6,7,8,9,10,1,2,3] => expected output"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Array rotation is inefficient as its complexity is O(n*n). I suggest you hould try place swaping with n and 10-n. In that case complexity is only O(n)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6082007230578688","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"10","title":"One of the questions in one of the interviews -   Given a stack S and another empty stack T and a variable v, write a function that returns S but with its elements reversed.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"1. v = Pop top one element from s 2. Push all remaining element to t 3. Push v to s 4. Push all t elements back to s This will get first element of s in correct reverse position. Continue for all other elements by keeping a count of how many elements are reversed."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"In the reverse function, 1) pop the elements one by one from Stack s and push into Stack t. 2) Assign Stack s = Stack t 3) Return Stack s;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's the solution I gave in the interview -"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Slightly more efficient implementation"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) put the last item of s in t, in order to do so do (keep track of the number elements of t, those shouldn't be moved)     1.1) move all items from s to t     1.2) pop the top element of t (was last item of s) and store it in v     1.3) return all the items of t and put them in s     1.4) push v in t     1.5) at this point t has the last item of s at its top  2) repeat step 1) as many times as the initial size of s, the idea is that in each step t will grow and s will shrink  3) at the end s will be empty and t will be a copy of s, then move all from t to s, that will reverse s  The time complexity is O(n^2), not sure the if there's a better way to do it"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have written the code in different manner using the v at most:-"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void reverse(Stack input, Stack helper) { \n        copyAsIs(input, helper); \n        while(!helper.isEmpty()) { \n            input.push(helper.pop()); \n        } \n    } \n     \n    public void copyAsIs(Stack input, Stack helper) { \n        if(input.isEmpty()) { \n            return; \n        } \n        Integer pop = input.pop(); \n        copyAsIs(input, helper); \n        helper.push(pop); \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void ReverseStack(std::stack &S) \n{ \n std::stack T; \n int v; \n \n int stack_size = S.size(); \n \n for (int i = 1; i < stack_size; i++) \n { \n  v = S.top(); \n  S.pop(); \n \n  for (int j = 0; j < stack_size - i; j++) \n  { \n   T.push(S.top()); \n   S.pop(); \n  } \n  S.push(v); \n  for (int k = 0; k < stack_size - i; k++) \n  { \n   S.push(T.top()); \n   T.pop(); \n  } \n } \n} \n \nint main(void) \n{ \n /* Given a stack S, a variable v and an empty stack T, \n  return the stack S reversed. \n */ \n  \n std::stack S; \n ReverseStack(S); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/*  * ALGORITHM  * for size n to 1  *    Keep the first element in the variable v  *    for 1 to n-1 pop from S and push to T  *    push v to S  *    pop all from T and push to S  *   * return S  */"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4840369632051200","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"Suppose you have a collection of collection  Eg : CEO-> Vps-> GMs ->..  CEO will contain collection of VP's, VP's will have collection of GM's and so on.   Suppose you need to find a particular GM is the alias is given. Write a linq query to get the employee details if the employee alias is given. Hint : Use Recursion + Linq","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using System; \nusing System.Collections.Generic; \nusing System.Linq; \nusing System.Text; \nusing System.Threading.Tasks; \n \nnamespace MS_Question \n{ \n    class Program \n    { \n        CEO ceo; \n        Program() \n        { \n            Employee w1 = new Employee(); w1.name = \"w1\"; \n            Employee w2 = new Employee(); w1.name = \"w2\"; \n            Employee w3 = new Employee(); w1.name = \"w3\"; \n            Employee w4 = new Employee(); w1.name = \"w4\"; \n            Employee w5 = new Employee(); w1.name = \"w5\"; \n            Employee w6 = new Employee(); w1.name = \"w6\"; \n            Employee w7 = new Employee(); w1.name = \"w7\"; \n            Employee w8 = new Employee(); w1.name = \"w8\"; \n \n            GM gm1 = new GM(); gm1.name = \"gm1\"; \n            gm1.workers.Add(w1); gm1.workers.Add(w2); \n            GM gm2 = new GM(); gm2.name = \"gm2\"; \n            gm2.workers.Add(w3); gm2.workers.Add(w4); \n            GM gm3 = new GM(); gm3.name = \"gm3\"; \n            gm3.workers.Add(w5); gm3.workers.Add(w6); \n            GM gm4 = new GM(); gm4.name = \"gm4\"; \n            gm4.workers.Add(w7); gm4.workers.Add(w8); \n \n            VP vp1 = new VP(); vp1.name = \"vp1\"; \n            vp1.mgs.Add(gm1); vp1.mgs.Add(gm2); \n            VP vp2 = new VP(); vp2.name = \"vp2\"; \n            vp2.mgs.Add(gm3); vp2.mgs.Add(gm4); \n \n            CEO ceo1 = new CEO(); ceo1.name = \"ceo1\"; \n            ceo1.vps.Add(vp1); ceo1.vps.Add(vp2); \n            this.ceo = ceo1; \n        } \n \n        public Human findWorker(Human h, String name){ \n            if (h is CEO) \n            { \n                if(h.name.Equals(name)) \n                    return h; \n                else \n                { \n                     \n                    IEnumerable res = ((CEO)h).vps.Select(i => i).Where( i => i.name.Equals(name)); \n                    foreach (VP vp in res) \n                    { \n                        return vp; \n                    } \n                    foreach (VP v in ((CEO)h).vps) \n                    { \n                        return findWorker(v, name); \n                    } \n                } \n                     \n            } \n            if (h is VP) \n            { \n                IEnumerable res = ((VP)h).mgs.Select(i => i).Where(i => i.name.Equals(name)); \n                foreach (GM mg in res) \n                { \n                    return mg; \n                } \n                foreach (GM m in ((VP)h).mgs) \n                { \n                    return findWorker(m, name); \n                } \n            } \n \n            if (h is GM) \n            { \n                IEnumerable res = ((GM)h).workers.Select(i => i).Where(i => i.name.Equals(name)); \n                foreach(Employee w in res){ \n                    return w; \n                } \n            } \n \n            return null; \n        } \n \n        static void Main(string[] args) \n        { \n            Program p = new Program(); \n            Human h = p.findWorker(p.ceo, \"ceo2\"); \n            if (h != null) \n            { \n                Console.WriteLine(h.name + \" Exists.\"); \n            } \n            else \n            { \n                Console.WriteLine(\"No such person exists.\"); \n            } \n            Console.ReadKey(); \n        } \n    } \n    class Human{ \n        public string name=\"\"; \n    } \n    class CEO:Human \n    { \n        public List vps = new List(); \n    } \n    class VP:Human \n    { \n        public List mgs = new List(); \n    } \n    class GM:Human \n    { \n        public List workers = new List(); \n    } \n    class Employee : Human \n    { \n \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"don't understand the question very well. Not sure what kind of method do you need. How you write the code, it really depends on how the objects look like.  how you write the code, it depends on the design of those classes.   if your design is good, you can just do this"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5637641189982208","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"Suppose you have a collection of collection Eg : CEO-> Vps-> GMs ->.. CEO will contain collection of VP's, VP's will have collection of GM's and so on.  Suppose you need to find a particular GM is the alias is given. Write a linq query to get the employee details if the employee alias is given.  Hint : Use Recursion + Linq","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public string GetGMByAlias(string alias)         {             if (string.IsNullOrWhiteSpace(alias))                 return null;             var gms = (from v in listOFVps                           from g in v.listOfGMs                           where g.Alias.Equals(alias)                           select g).FirstOrDefault();             return gms.ToString();         }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5752271719628800","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"17","title":"Given an array of integers and a length L, find a sub-array of length L such that the products of all integers are the biggest. Example: Input: {4, 1, -7, -8, 9}, 3 Output: {-7,-8,9}","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can have to arrays, one for positive numbers and one for negative numbers. Sorting the two arrays as the absolute values decreasing. Setting two pointers at the beginning of two arrays. Comparing the absolute value at the two pointers. Each time get the bigger absolute value one , doing the multiplication and move the corresponding pointer ahead. After K moves we can get the product. If the product is positive then done. If it is negative, dividing the number at the pointer of negative array, multiplying the number at the pointer of positive array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sort the array chose the biggest of a[0]*a[1]*a[N] and a[N-2]*a[N-1]*a[N]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can simply run a Length product through the array in O(n) time. Each time you have two pointers one which points at location i and the other one at i+L-1. The new product is previous_product*element[i+L]/element[i], assuming element[i] is non-zero. You compare this product with your current max value. Every time you encounter a zero you can simply skip L locations including the one containing zero."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"subarray here must be contiguous, what if it's not?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algorithm: Find all the sub-arrays of length = input length and compute the product of each. Sub-arrays can be generated by generating all binary numbers from 0 to 2^arrays.length.  For example: all subarrays of an array {2,5} can be generated in binary as: 00 = {} 01 = {,5} 10 = {2,} 11 = {2,5} in below code: 1 << array.Length = 1 << 2 = 2 ^ 2 = 4 max subsets can be generated Now, get all subsets of input length and find the max product."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since this is a subset rather than a subsequence. I think this can be solved in O(n) for the following case  Scenario 1: no zeros in the array  1. Count the number of negative numbers in the array 2. if there are no negative numbers in the array  a) We just need to ignore the leading and trailing 1s.                     i) Run from the index 0 to n-2 . and start multiplying the elements. if there are leading 1 increase the start counter. if there are trailing 1 dont increase the end counter. store the multiplication to max1 and well the start and end index                    ii) Run the index from n-1 to 1 follow the above step and store it in max2 and start and end index      iii) print the index of highest multiplication value.  3. if there are odd number of negative numbers. we need to multiply upto negCount-1 at the minimum and handle if there are any leading and trailing 1s  a) We can multiply from index 0 upto negCount-1 followed by positive numbers  until we reach last negative number. if there are any leading and trailing 1s adjust the start and end index.         b) start from n-1 and multiply upto negCount-1 and any positive numbers following that until we reach the first negative number. Ignore the leading or traling 1s.         c.) compare the products and print the index of the largest product.  4. If the negative count is even. Then we can max multiply n-1 elements on the both side ignoring leading and trailing 1s.  Scenario 2: If there are zeros.  1. all the above scenarios applicable but we have to consider that there are more than 1 array based on the number of zeros."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the solution would be to sort the array in absolute value and pick the last n elements. If product comes out to be negetive, remove the smallest negetive and take the next smallest positive number from the array.   Example: {4, 1, 7, -8, 9}, 3   sort it  { 1, 4, 7, -8, 9}   take last n element  {7, -8, 9}  If (product is negetive)    replace smallest -ve number (-8) with 4  ->  {4, 7, 9} else    You already have the answer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/*   * ALGORITHM   * for i=1 to n   *   find products of i to i+l array elements   *   if product>maxproduct   *      maxProduct=product and maxStartIndex=i   *  return maxStartIndex   */  public static int findmaxProductSubArray(int[] arr, int l)  {   int len=arr.length;   int maxProduct=Integer.MIN_VALUE;   int maxStartIndex=0,tempProduct=1;   for(int i=0;i<=len-l;i++)   {    for(int j=i;j<((i+l));j++)    {     tempProduct*=arr[j];    }    if(tempProduct>maxProduct)    {     maxProduct=tempProduct;     maxStartIndex=i;    }    tempProduct=1;   }   return maxStartIndex;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sort the array based on the absolute value of each element of the array into a sorted array. The sorted array holds the original values not absolute values. then (length of the array - L) to end of the sorted array. Multiply these numbers and you have absolute value of the biggest product."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Just keep the product of 'n' running elements and every time compare it with the max product which has been found so far. Java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"In O(n) we can realize that do we have a positive number or not."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5164438336307200","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"Design a download manager. The download manager would be shipped with a browser. Detailed design of components and interaction between them.   Follow up question - What features would you add to the  download manager so that it is more marketable than others.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Great question :-    In My opinion I would like to Put this as :-   1> It should basically work as an Independent module which can  be integrated as the plugging for various application. 2> For that, I would like to expose an interface say DownloadURL(String URL). 3> I would also expose another API for File Storage Like SaveFile(String filepath). 4> Internally , I would implement these API by breaking into Modules like. File support and fault tolerance . 5> For File fault tolerance, I would basically implement a counter for bytes downloaded to the bytes to be download. I would Cache these bytes till A > User Cleans it , B > Files it 100% downloaded and 3 > System Cache Overflows . 6> Actually it a Huge Application so we can go a long while ..  Now Second Part Follow ups   1> Feature like stop and resume download is mandatory . 2> Another One could be data rate control. Like User should Be able to allocate the bandwidth for each of the specific download during parallel downloads etc."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5943729928011776","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"8","title":"Suppose you get number of unique users every second from bing  For eg, 2,4,5,1,2,etc  You need to write a web service method , such that it takes the input n, which return lowest n unique number from the list of unique numbers. For eg, if n is 3 then you need to return 2,1,2","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"selection algorithm, find max or min k numbers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Construction of min heap of size n for the given input series and then clearing the min heap will give us the required result. Complexity is O(n log n).  Adding element to min heap is O(log n) as it requires correction of the heap through log levels. For n elements it would be O(n log n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int *findLowestUniqueNumber(int a[], int n){ \n  int m = sizeof(a)/sizeof(int); \n  int *res = malloc(sizeof(int)*n); \n  int *temp = malloc(sizeof(int)*m); \n  memset(res, 0, sizeof(int)*n); \n  memset(temp, 0, sizeof(int)*m); \n \n  int min = 0; \n  for (int i = 0; i < n; i++){ \n      int minFlag = 0 ; \n      min = a[0]; \n      for (int j = 0; j < m; j++){ \n          if (temp[j] == 0){ \n              if (min >= a[j]){ \n                  min = a[j]; \n                  temp[j] = min; \n                  minFlag = 1; \n              } \n          } \n      } \n      if (minFlag == 0){ \n          temp[0] = min; \n      } \n  } \n  int k = 0; \n  // remove 0s \n  for (int i = 0; i < m; i++){ \n      if (temp[i] != 0){ \n          res[k++] = temp[i]; \n      } \n  } \n  free(temp); \n  return res; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def min_heapify(a,i): \n    l = 2*i+1 \n    r = 2*i+2 \n    min = i \n    if (l < len(a) and a[l] < a[i]): \n        min = l \n    if (r < len(a) and a[r] < a[min]): \n        min=r \n    if (min != i): \n        a[i],a[min] = a[min],a[i] \n        min_heapify(a,min) \n \n \nif __name__ == '__main__': \n  temp = [5,3,17,10,84,19,6,22,9]  \n  print ('enter the number:') \n  n = int(input()) \n  for i in range(n): \n    for j in range (int(math.ceil(len(temp)/2)),-1,-1): \n      min_heapify(temp,j) \n    print (temp[0]) \n    temp = temp[1:]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Could someone elaborate the question. The way i understand it we have a stream of numbers and we have to return all numbers less than a given number (n). And that seems to be a trivial problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There are two efficient solutions.  1) Create a bst (allow duplicates)out of these numbers. Each time a query comes, it would take O(k) time to get k least numbers. Here the catch is insertion time O(logn)  2) Store all these numbers in an array. Apply selection algorithm each time a query comes. Here it will take O(n) time to figure out the least k numbers. Also there is a huge constant factor involved in this method. Insertion takes O(1). If array size needs to be increased, that will take O(n) time. Also deletion is a problem here."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5649647234187264","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"4","title":"A draw method is given, write a function to draw a chess board. The Draw method, draws a square and  has parameters row position, column position and color.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"void draw_chessBoard() \n{ \n     char color[2][6] = { \"Black\", \"White\" }; \n \n     for(int i = 0; i < 8; i++) \n          for(int j = 0; j < 8; j++) \n          { \n               Draw(i + 1, j + 1, color[ j % 2 ]); \n                \n          } \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5075421557161984","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"9","title":"Forgot to add this question along with my previous... This is a brain teaser type question...     S E N D   +    M O R E -------------- M O N E Y --------------  Each of the above characters hold a specific value which is unique (meaning no two characters have same value). Now the question is, to uncover what value each character stands for...   (Hint - 'M' has to be 1 because it's the carry in the result (M O N E Y). Now similarly back track the rest of the characters) Note: this hint is given by me, for the sake of understanding the question for interested folks, it was not given to me in the interview).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Check wiki/Verbal_arithmetic"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"For this question, were you asked to produce the answer or an algorithm that is capable of producing the answer?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"s=9,e=5,n=6,d=7 m=1,o=0,r=8,e=5 m=1,o=0,n=6,e=5,y=2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Are questions like this really still asked in programming interviews?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can find solution @ mathforum.org/library/drmath/view/60417.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"M=1, S=9, O=0, R=8, E= N - 1 for sure. Thus, there are 4 possibilities:  1. E=5, D=7, Y=2 2. E=6, D=7, Y=3 3. E=7, D=5, Y=2 4. E=7, D=6, Y=3"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Get a integer array with numbers 1-9 and 0.Also take a array with integers whose variables are a[]={s,e,n,d} and b[]={m,o,r} and make a for loop to add the two arrays a[] and b[] such that the values are equal for all the list of combinations."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-4","title":"Done, most important info is \"no two characters have same value\""}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4981417205301248","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"31","title":"Imagine we have a large string like this \"ABCBAHELLOHOWRACECARAREYOUIAMAIDOINGGOOD\" which contains multiple palindromes within it, like ABCBA, RACECAR, ARA, IAMAI etc... Now write a method which will accept this large string and return the largest palindrome from this string. If there are two palindromes which are of same size, it would be sufficient to just return any one of them.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public class LongestPalindrome { \n \n public static void main(String[] args) { \n  String str = \"ABCBAHELLOHOWRACECARAREYOUIAMAIDOINGGOOD\"; \n  System.out.println(\"Longest Palindrome: \"+longestPalindrome(str)); \n } \n public static String longestPalindrome(String str){ \n  \n  String longestPalindrome = null; \n  if(null==str) \n   return null; \n  else{ \n   longestPalindrome=str.substring(0,1); \n   for(int i=0;i1) \n    System.out.println(palindrome); \n    if(palindrome.length()>longestPalindrome.length()){ \n     longestPalindrome=palindrome; \n    } \n     \n    palindrome=expand(str,i,i+1); \n    if(palindrome.length()>1) \n    System.out.println(palindrome); \n    if(palindrome.length()>longestPalindrome.length()){ \n     longestPalindrome=palindrome; \n    } \n   } \n  } \n  return longestPalindrome; \n   \n } \n static String expand(String str, int left, int right){ \n  if(left>right) \n   return null; \n  else{ \n   while(left>=0 && right"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"In C# using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks;  namespace LargestCommonSubstring {     class Program     {         static void Main(string[] args)         {             var str = \"ABCBAHELLOHOWRACECARAREYOUILOVEUEVOLIIAMAIDOINGGOOD\";             var longestPalindrome = GetLongestPalindrome(str);             Console.WriteLine(longestPalindrome);                      }          public static string GetLongestPalindrome(string input)         {             int rightIndex = 0, leftIndex = 0;             List paliList = new List();             string currentPalindrome = string.Empty, longestPalindrome = string.Empty;             for (int currentIndex = 1; currentIndex < input.Length - 1; currentIndex++)             {                 leftIndex = currentIndex - 1;                 rightIndex = currentIndex + 1;                 while (leftIndex >= 0 && rightIndex < input.Length)                 {                     if (input[leftIndex] != input[rightIndex])                     {                         break;                     }                      currentPalindrome = input.Substring(leftIndex, rightIndex -leftIndex + 1);                     paliList.Add(currentPalindrome);                     leftIndex--;                     rightIndex++;                 }             }              var x = (from c in paliList                     select c).OrderByDescending(w=>w.Length).First();                           return x;         }     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Check leetcode - longest-palindromic-substring-part-ii. There is explained O(n) solution using Manacher??s Algorithm."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Build a trie for all the suffixes of the string and its reverse in O(n) time. Then find the deepest interior node in the tree--the concatenation of the edges in the unique path from this node to the root corresponds to the longest palindrome in the string."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"DP solution.  I would commit code, but write a formula.  if(s[i] == s[j])  T[i,j] = T[i + 1,j - 1] + 1  else  T[i,j] = max(T[i + 1,j],T[i,j  - 1])   result T[0,n] then we need to find position of i and j where result occurs."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/**O(n^2)**/ \npublic class LargestPalindromicSubstring { \n  \n private static final int ODD = 1; \n private static final int EVEN = 2; \n public static int max = 0; \n public static int left=0, right=0; \n  \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n  max = left = right = 1; \n  for(int i=0; i=0 && j< arg.length()){ \n   if(arg.charAt(i) == arg.charAt(j)){ \n    len = j-i+1; \n   } else break; \n   i--;j++; \n  } \n  if(len > max){ \n   max = len; left = i+1; right = j-1; \n  } \n  return; \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int T[ MAX ][ MAX ], n, i, j, k; \n  \n string s; \n cin >> s; \n n = s.length(); \n  \n for (T[0][0] = 1, i = 1; i < n; ++i) \n { \n  T[i][i] = 1; \n  T[i][i-1] = 0; \n } \n  \n for (j = 2; j <= n; ++j) \n { \n  for (i = 0; i + j - 1 < n; ++i) \n  { \n   k = i + j -1; \n   if (s[i] == s[k] && T[i+1][k-1] == k-1-i) \n   { \n    T[i][k] = T[i+1][k-1] + 2; \n   } \n   else \n   { \n    T[i][k] = max(T[i+1][k], T[i][k-1]); \n   } \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// Simple O(N**2) algo \n    public String getLargestPalindrome(final String input) \n    { \n        final int n = input.length(); \n        for (int wordSize = n; wordSize >= 2; wordSize--) \n        { \n            for (int startPos = 0; startPos <= n - wordSize; startPos++) \n            { \n                final String checkWord = input.substring(startPos, startPos + wordSize); \n                System.out.println(checkWord); \n                if (isPalindrome(checkWord)) \n                { \n                    return checkWord; \n                } \n            } \n        } \n        return \"\"; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Step1: index 0=stIndx, index n=lstindx=length(string)-1. Step2:check if string from stIndx to lstindx is palindrome, if yes abort and save the length, if no stindx to lstindx=lstindx-1 and check for palindrome again. Step 3: Repeat step 2 till stIndx=lstIndx or you find a palindrome (whichever comes first) Step4: Check if string from stIndx=stIndx+1 to lstIndx and check for palindrome. Step 5: Repeat step 4 till you find a palindrome or stIndx =lstIndx (whichever comes first) Step6: Compare the string obtained from step 3 and step 5, display the larger string."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Step1: index 0=stIndx, index n=lstindx=length(string)-1. Step2:check if string from stIndx to lstindx is palindrome, if yes abort and save the length, if no stindx to lstindx=lstindx-1 and check for palindrome again. Step 3: Repeat step 2 till stIndx=lstIndx or you find a palindrome (whichever comes first) Step4: Check if string from stIndx=stIndx+1 to lstIndx and check for palindrome. Step 5: Repeat step 4 till you find a palindrome or stIndx =lstIndx (whichever comes first) Step6: Compare the string obtained from step 3 and step 5, display the larger string."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using System; using System.Collections.Generic; using System.Linq; using System.Text;  namespace test {    public class Program     {         static void Main(string[] args)         {             string s = \"ABCBAHELLOHOWRACECARAREYOUIAMAIDOINGGOOD\";             String str=\"\";             char[] a = s.ToCharArray();                      for (int j = 0; j < a.Length; j++)             {                 String tempchar = a[j].ToString();                 for (int temp = j+1; temp < a.Length; temp++)                 {                     tempchar = String.Concat(tempchar, a[temp]);                     if (ispalindrome(tempchar))                     {                         if (tempchar.Length > str.Length)                         {                             str = tempchar;                                                     }                     }                                    }             }             Console.WriteLine(str);             Console.ReadLine();                     }         public static bool ispalindrome(string s1)         {             char[] arr = s1.ToCharArray();             Array.Reverse(arr);             string s2 = new String(arr);             if (s1.Equals(s2) == true)             {                 return true;             }             return false;         }     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the solution using recursion. I think it is very easy to understand. feel free to share any pros and cons of the code."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public string LargestPalindrome (string str)         {             string maxPoli = String.Empty;             char[] chArray = str.ToCharArray();             for(int i=0;i            {                 var val = Expand(chArray,i);                 if (maxPoli.Length < val.Length) maxPoli = val;             }             return maxPoli;         }          private string Expand(char[] str ,int index)         {             string tempval = String.Empty;             for(int i=index, j=index; i>-1; i--,j++)             {                 if (j< str.Length && str[i] == str[j]) tempval = new string(str, i, j - i+1);                 else break;             }             return tempval.Length>1 ? tempval :String.Empty;         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package oracle.string.examples;  public class PalindromesInString {  public static void main(String[] args) {    String givenStr =\"MADAMABABKALOMORAKMADAM\";   PalindromesInString pal = new PalindromesInString();   String result = pal.getBiggestPalindrome(givenStr);   System.out.println(\"Result  :\"+result);     }   String getBiggestPalindrome(String str) {   String revStr = new StringBuffer(str).reverse().toString();   String biggestPalindrome = \"\";   for (int i = 0; i < str.length(); i++) {    char tempChar = str.charAt(i);    for (int j = i+1; j < str.length(); j++) {     char nextChar=str.charAt(j);     if(tempChar==nextChar){            String tempString = str.substring(i, j+1);      if(biggestPalindrome.length()             biggestPalindrome =tempString;               }     }         }      }      return biggestPalindrome;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The key is to form a suffix trie from the string. Then reverse the string and iterate on the tree we have constructed and merge the two and also keep a count of path that was common in both. Keep a max of the height of common paths found and that is your longest palindrome."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A simple Groovy algorithm which runs in O(n**2). Look for palindromes starting from the center. Note that the center might be on character (in case the palindrome length is odd - aba) or between two characters (when the palindrome length is even aabbaa).  The most efficient solution would be the Manacher??s algorithm, which runs in O(n), but is too complex for me."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include \n \nint main(void) { \n char str[100]; \n scanf(\"%s\",str); \n int len=strlen(str); \n int j,k; \n  \n int lp[len][len]; \n for(j=0;jlp[j][j+k-1]) \n   lp[j][j+k]=lp[j+1][j+k]; \n   else \n   lp[j][j+k]=lp[j][j+k-1]; \n  } \n } \n printf(\"%d\",lp[0][len-1]); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ublic class LongestPalindrome { \n  \n public static void main(String []args){ \n        int max=0; \n        int start=0; \n        int stop=0; \n        int maxIndex=0; \n        String given=\"abcdeedcbadgefdadadaddd\"; \n        String toreturn=\"\"; \n        for(int i=0;i=0 && i+1=0){if(given.charAt(i+1)==given.charAt(i) && given.charAt(i)!=given.charAt(i-1))j =i+1;} \n            int count=0; \n            while(a>=0 && j"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Public class LongestPalindrome { \npublic static void main(String []args){ \nint max=0; \nint start=0; \nint stop=0; \nint maxIndex=0; \nString given=\"abcdeedcbadgefdadadaddd\"; \nString toreturn=\"\"; \n        for(int i=0;i=0){if(given.charAt(i+1)==given.charAt(i) &&               given.charAt(i)!=given.charAt(i-1))j =i+1;} \n            int count=0; \n            while(a>=0 && j"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the answer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class LongestPalindrome { \n \n /** \n  * @param args //laxmikant's arena \n  */ \n public static void main(String[] args) { \n  // TODO Auto-generated method stub \n   longestPalindrome(\"ABCBAHELLOHOWRACECARAREYOUIAMAIDOINGGOOD\"); \n } \n  \n  \n public static void longestPalindrome(String str){ \n   \n  int len=str.length(); \n   \n  int[][] table=new int[len][len]; \n   \n  for(int i=0;imax_len) \n     { \n      max_len=k; \n      start=i; \n     } \n    } \n     \n     \n   } \n  } \n   \n  System.out.println(str.substring(start,start+max_len)); \n   \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/*   *    * MAX_POLINDROME(str)   * for i 1 to length   *  if current and current-1 matches //even length   *   move both sides,count and check with max   *  else if current and current-2 maches //odd length   *   move both sides,count and check with max   *    * return the max length string   *    */"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public class Palindrome {    public static void main(String args[]){   Palindrome mypalindrome = new Palindrome();   String input1 = \"ABCBAHELLOHOWRACECARAREYOUIAMAIDOINGGOOD\";   System.out.println(mypalindrome.largestPalindrome(input1));  }    public String largestPalindrome(String input){   for(int i = input.length()-1; i>=2; i--){    for(int j=0; j< input.length()-i; j++){     String mystr = input.substring(j,j+i);     if(isPalindrome(mystr)){      return mystr;     }    }   }   return \"\";  }    public Boolean isPalindrome(String input){   char[] inputchar = input.toCharArray();   for(int i =0; i < inputchar.length; i++){    if(inputchar[i] != inputchar[inputchar.length-1 -i]){     return false;    }   }   return true;  }  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6253711340863488","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"Test cases for int rand() which returns a random number between 0 - 999","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"My answer: - verify that the frequency is distributed evenly for all the possible numbers - Verify that the distance between repititions is about the size of the set (1000) for each number - Verify that the distance between consecutive random numbers is random in itself - Verify that the numbers 0-999 are only generated - Verify that in each run you do not get the same sequence of random numbers. Seed it differently - For visual identification of anomalies, plot the values (y-axis as random number, x-axis as each attempt)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Random number => no predictable pattern in numbers generated => the diff between the nos should not be the same, etc  2. Each number in between 0-999 has to have equal probability of occurrence. So, we should maintain frequency counts and verify that no single number stands out w.r.t. frequency."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Chi Square test."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would be referring to diehard tests. Check Wikipedia. And, of course that any returned int fits the specified range. For really depth testing, we could test it is not leaking memory, etc."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5203498857660416","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"13","title":"Given a number give its english form 1-> One 999 -> Nine hundred and ninety nine  Max number is: 999, 999, 999","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"My answer: Observation: each three digit number is spelled the same, the only difference is the magnitude (million, thousand, hundred). Hence write a utility function which processes a number from 0-999 and call it for hundreds, thousands and millions.   Algorithm:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* \n \n  2 functions assumed \n    1) findMaxDecimalPlace e.g for 123 it will return 100 for 1202 -> 1000 \n  2) print function which return string value on the assumption that we have mapping  \n  something like this  \n    1 -> \"one\", 2 -> \"two\", upto 19 \n   and 20 -> \"twenty\"....90 \"Ninety\", 100 -> \"hundred and\", \n      1000 -> \"thousand\" and so on  \n   \n \n */ \n public void IntToString(int number) { \n  if (number <= 20) { \n   System.out.println(print(number)); \n   return; \n  } \n  while (number > 0) { \n   int maxdecimalPlace = findMaxDecimalPlace(number); \n   if (number / maxdecimalPlace > 0) { \n    if (number / maxdecimalPlace < 20) { \n     System.out.println(print(number - (number % maxdecimalPlace)) \n       + print(number % maxdecimalPlace)); \n     break; \n    } \n    System.out.println(print(number - (number % maxdecimalPlace))); \n    number = number % maxdecimalPlace; \n   } else { \n    System.out.println(print(number)); \n   } \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Maintain an 'order' table as below. order[0] = \"\" order[1] = thousand order[2] = million order[3] = billion order[4] = trillion ... Have another table called text[] such as: text[0] = \"zero\" text[1] = \"one\" .. text[999] = \"nine hundred and ninety nine\"  1. Count the number of digits to figure out the what 'order' the number belongs to - say, millions or thousands or units. This is obtained by order[(digit_count(n) -1)/3] 2. Chomp 3 digits at a time and print out: text[chomped_digits] + order[(digit_count(n) -1)/3] If chomping the number from MSDs is difficult, reverse the number, extract the last 3 LSDs using a % operator and then again reverse the extracted 3(or less) digits. 3. Go back to step 1 until the number is exhausted.  For ex:  1.123,456: One hundred and twenty three *thousand*(order), four hundred and fifty six 2. 9,999,999 Nine *million*, nine hundred and ninety nine *thousand*, nine hundred and ninety nine."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"approach is to start from highest decimal place and reduce it to zeroth decimal place."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This will work till 9999"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"string NumToString(int n) \n{ \n string[] one_dig = {\"zero\", \"one\", ..., \"nine\"}; \n string[] two_dig_minor = {\"ten\", \"eleven\", ..., \"nineteen\"}; \n string[] two_dig_major = {\"twenty\", \"thirty\", ..., \"ninety\"}; \n string[] unit = {\"hundred\", \"thousand\", ..., \"trillion\"}; \n string result = \"\"; \n  \n if (n < 0) \n  return \"error\"; \n while (true) \n { \n  int tenPow = Math.Log(n); \n  if (tenPow == 0) //1 digit  \n  { \n   s = s + dig1[n]; \n   break; \n  } \n  else if (n < 20) \n  { \n   s = s + two_dig_minor[n - 10]; \n   break; \n  } \n  else if (n < 100) \n  { \n   int temp = n / (Math.Pow(10, tenPow)); // n = n / (10 ^ tenPow); \n   s = s + two_dig_major[n - 2];    \n   n = n % (Math.Pow(10, tenPow)); \n  } \n  else \n  { \n   int temp = n / (Math.Pow(10, tenPow)); // n = n / (10 ^ tenPow); \n   s = s + dig1[temp] + unit[tenPow - 2]; \n   n = n % (Math.Pow(10, tenPow)); \n  } \n } \n return s; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"string NumToString(int n) \n{ \n string[] one_dig = {\"zero\", \"one\", ..., \"nine\"}; \n string[] two_dig_minor = {\"ten\", \"eleven\", ..., \"nineteen\"}; \n string[] two_dig_major = {\"twenty\", \"thirty\", ..., \"ninety\"}; \n string[] unit = {\"hundred\", \"thousand\", ..., \"trillion\"}; \n string s = \"\"; \n  \n if (n < 0) \n  return \"error\"; \n while (true) \n { \n  int tenPow = Math.Log(n); \n  if (tenPow == 0) //1 digit  \n  { \n   s = s + dig1[n]; \n   break; \n  } \n  else if (n < 20) \n  { \n   s = s + two_dig_minor[n - 10]; \n   break; \n  } \n  else if (n < 100) \n  { \n   int temp = n / (Math.Pow(10, tenPow)); // n = n / (10 ^ tenPow); \n   s = s + two_dig_major[n - 2];    \n   n = n % (Math.Pow(10, tenPow)); \n  } \n  else \n  { \n   int temp = n / (Math.Pow(10, tenPow)); // n = n / (10 ^ tenPow); \n   s = s + dig1[temp] + unit[tenPow - 2]; \n   n = n % (Math.Pow(10, tenPow)); \n  } \n } \n return s; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import queue \n#import list \n \n \nd_h = { \n       2 : 'ten', \n       3 : 'hundred', \n       4 : 'thousand', \n       5 : 'thousand', \n       6 : 'lakh', \n       7 : 'lakh', \n       8 : 'crore', \n       9 : 'crore'  \n}  \nty_di  = ['elevan','twelve','thirteen','fourteen','fifteen','sixteen','seventeen','eighteen','nineteen'] \nse_di  = ['ten','twenty','thirty','forty','fifty','sixty','seventy','eighty','ninty'] \none_di = ['one','two','three','four','five','six','seven','eight','nine'] \n \ndef populate(f_item,s_item,let): \n  #print (f_item,s_item,let) \n  if s_item !=0 and f_item != 0: \n    if s_item != 1:        \n      let.append(se_di[s_item-1] +' '+one_di[f_item-1] ) \n      #let.append() \n    else: \n      let.append(ty_di[f_item-1]) \n  elif s_item ==0 and f_item != 0: \n      let.append(one_di[f_item-1]) \n  elif s_item !=0: \n    let.append(se_di[s_item-1]) \n  else: \n    pass   \n \n \ndef letters(s): \n  q = queue.Queue() \n  l = len(s) \n  let = [] \n  digit = 1 \n  p_index = 0 \n  for i in range(l-1,-1,-1): \n    q.put((s[i],digit)) \n    digit = (digit+1)  \n  while (not q.empty()): \n    ele,digit = q.get() \n    n = int(ele) \n    #print (let , ele , digit) \n    if digit == 2: \n      s_item = n \n      f_item = let.pop() \n      populate(f_item,s_item,let) \n      p_index = digit \n    elif digit == 3: \n      if n != 0: \n        let.append(d_h[digit]) \n        let.append(one_di[n-1])     \n        p_index = digit \n      else: \n        pass       \n    elif digit > 3: \n      if (digit % 2) != 0 : \n        f_item = let.pop() \n        s_item = n \n        #print (f_item,s_item) \n        if n != 0 or f_item != 0: \n          let.append(d_h[digit]) \n        populate(f_item,s_item,let) \n        p_index = digit \n      else:   \n        let.append(n) \n    else: \n      let.append(n) \n  if (p_index != digit): \n    item = let.pop() \n    if digit in d_h: \n      let.append(d_h[digit]) \n      let.append(one_di[item-1]) \n    else: \n      let.append(one_di[item-1])     \n   \n  #let = let.reverse()     \n  print (' '.join(let[::-1])) \n \n \n \n \n \n \n \n \n \nif __name__ =='__main__': \n   \n  print (\"Enter the Number:\") \n  s = (input()) \n  letters(s)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Declare an array of number[]={\"one\",\"two\" ... }; upto 99  and another array of place[]= {\"hundred\",\"thousand\" ... }; upto your need.  now count the number of digits   e.g   while(1){      v=x/10;      /* v is any temp variable and x contain your number */   count++;    /*  initial value = 0 */      if(v==0)    break;  }  on count we get the no. of digits .  Reverse the digit   e.g       temp=v;  num=0;     while(temp!=0){    v=x%10;   num=num*10+v;   x=x/10;   temp--;  }  now on every odd value of v (i.e number of digits ) read two at a time (>3)  suppose :   12345  so here we have 5 digits ,therefor read first two value at a time 12  and do it as    char *ch;  ch=number[12];  printf ch;  if digit==5  ch=place[2];    and so on...  printf ch;  o/p = twelve thousand  and for last three digit read first    ch=number[v];  print ch;  if(v==3)  ch=place[1];  print ch;  /* append the result to o/p */  o/p = twelve thousand three hundred  if(v<3)  ch=number[v];  print ch;  append answer with o/p  o/p = twelve thousand three hundred forty five"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"A working solution in Python. The only thing it lacks is it doesn't insert the word \"and\"."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5127811434020864","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"6","title":"Design a webservice which would take a word, and return all anagrams","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Constraints: 1. Web-service should return the result with in sub-second (< 1 second) 2. Using the permutation mechanism can slow down the processing 3. The data structure used to store the dictionary should be explained as well  Algorithm: 1. Pre-processing: Store the dictionary as multimap . Construct the key by sorting the letters of the word. (Use quick sort for sorting the letters) 2. Web-Service: The web-service takes the word as input and sort the letters using quick sort O(nlogn) and query the multimap O(1) for all the anagrams."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is like asking to print all the 'valid' permutations of the word, the validity of whom is checked against a given dictionary."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We make hash map, from sorted word letters. When we recieve a request with word, we sort it and return all words from appropriate bucket. Also hash table can be distributed. We assign to node some interval from aaaaaa to xxxxxx, for instance. Each node is responsible for continious interval of sorted in lexicographicsl order strings. So we can very fast make decision which node shoud proceed request."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For a one-off puzzle, you could just do the permutations approach. For a web service though, it wouldn't make sense to re-compute the permutations every time a request is received.  My suggestion would be to simply structure the dictionary as a hash map, where the keys are unique sorted words and the values are all words which when sorted yield the key.  The problem gets a lot more interesting if your service has to support other queries as well, not just finding anagrams. The above representation of the dictionary is ideal for anagrams but maybe bad for different sorts of queries."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include                                                               \n                                                                                 \nusing namespace std;                                                             \n                                                                                 \nvoid backtrack(string s, string sofar)                                           \n{                                                                                \n  if (s == \"\")                                                                   \n  {                                                                              \n    cout << sofar<>s;                                                                        \n  backtrack(s,\"\");                                                               \n  return 0;                                                                      \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Generate all the permutaion of the string and check against the dictionary whether the word is valid or not."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5088710051758080","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"Given a graph that where A->B indicates that node A should be processed before processing B. Design an parallel algorithm to process all the nodes","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if i've understood question well, we have some kind network planing. So we need to know which parts of job can be done in parallel. We can do BFS on the graph and mark vertexes. Those vertexes who are on the same level - can be proceed in parallel. But how to find distinct branches, who can be proceed independently - i have no ideas."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My answer: Well the idea is to 1st process all node whose in-degree is 0. Then keep processing newly added nodes whose in-degree becomes 0. The main part is coming up with a parallel solution.   Algorithm: - Dedicate a process to go through the graph and add ready nodes (whose in-degree is 0) to a ready-process-queue - Either use SMP or Master-Slave architecture to assign processing of each node present in the ready queue.  - For efficient tracking of changing in-degrees, maintain a hash, which is updated for all the outDegree nodes of the currently processed node. Say if we have a link A->B. When processing A we can decrement the indegree count of B.  - Few enhancements are the main process which scans the graph for 0 indegree nodes can be designed to receive a signal when new nodes are ready (whose in-degree has become 0) rather than staying in a busy-wait loop."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Topological sort can do it. I dont know how to make it parallel ?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6281061692604416","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"0","title":"Smart pointers, how are they implemented. Any usecase for using smart pointers in languages that already have garbage collectors"}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6032987502149632","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"Design a voicemail system. Would you use RDBMS or File system, provide rationale.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"A single Voicemail message has the following (common) characteristics :::::: Sequential read always, Read in full always, Possibly replayed, but rarely, Small file sizes.  Assuming that a vmail system has to be developed for many users, we need a way to select all messages belonging to one user i.e. no sharing of vmail messages across users.  So, a simple system of one dir per user, with some small files under each directory, is sufficient. I.e. a file system would be sufficient. In addition, backup, replication, dedup  and other tools built for a file system can be easily used for the vmail system as well.  I do not much about DBMSes, but it seems to me that we do not have any complex query system that needs to be supported for a vmail system and neither does any complex relationship info maintained. So a DBMS seems like overkill to me."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I would use both,  DBMS for storing meta data like caller id, timestamp, date/time, call back number, voice message file id etc...  File system for storing voice message."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would go with Filesystem. Storing and retrieving from DBMS is quiet slow compared to that of memory."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think file system with inode structure saving all meta data."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6030034980569088","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"An application is crashing the moment it is opened, how would you test it.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If it;s written in C++ then it can be crash before calling main function iff something messed up in global static initialization. Just have a look onto the same."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Run it in a debugger and see where it is dying?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5194746351845376","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"7","title":"Implement Stack operations using two queues. I wrote some code, later he asked, how many elements could be added to this queue. (My code was like this Queue q1 = new Queue();  ) What would be the maximum number of elements that this queue would accomodate? My code was in java.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Queue is an interface,so you cannot create object. You need to do it as Queue q=new LinkedList():..or someother data structure."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"your queue can be of Integer.Max in Java because when you look at the java code of Queue you will find that capacity is an int."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class Stack{ \n private Queue q1 = new LinkedList(); \n private Queue q2 = new LinkedList(); \n \n public void push(T elem){ \n  q1.offer(elem); \n } \n \n public T pop(){ \n  while(q1.size() > 1)  { \n   q2.offer(q1.poll()); \n  }  \n \n  T result = q1.poll(); \n \n  while(!q2.isEmpty()) { \n   q1.offer(q2.poll); \n  } \n \n  return result; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Queue; \nimport java.util.concurrent.ConcurrentLinkedQueue; \n \npublic class QueueStack { \n Queue queue1 = new ConcurrentLinkedQueue(); \n Queue queue2 = new ConcurrentLinkedQueue(); \n  \n public void push(T elem){ \n  queue1.offer(elem); \n } \n  \n public T pop(){ \n  if(!queue1.isEmpty()){ \n   while(queue1.size()>1){ \n    queue2.offer(queue1.poll()); \n   } \n   return queue1.poll(); \n  }else if(!queue2.isEmpty()){ \n   while(queue2.size()>1){ \n    queue1.offer(queue2.poll()); \n   } \n   return queue2.poll(); \n  }else{ \n   return null; \n  } \n } \n  \n public T peek(){ \n  if(!queue1.isEmpty()){ \n   while(queue1.size()>1){ \n    queue2.offer(queue1.poll()); \n   } \n   return queue1.peek(); \n  }else if(!queue2.isEmpty()){ \n   while(queue2.size()>1){ \n    queue1.offer(queue2.poll()); \n   } \n   T desiredelem = queue2.poll(); \n   queue1.offer(desiredelem); \n   return desiredelem; \n  }else{ \n   return null; \n  } \n } \n  \n public static void main(String[] args){ \n  QueueStack testStack = new QueueStack(); \n  testStack.push(1); \n  testStack.push(2); \n  testStack.push(3); \n  System.out.println(testStack.pop()); \n  System.out.println(testStack.pop()); \n  System.out.println(testStack.pop()); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think 32768.. ( Max size until stack overflow occurs(65536) /2 )"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Infinite number of elements but you can choose to implement the Queue yourself and place a restriction on the max number of elements you wanna be able to add. So you had a Google and Microsoft interview on the same day! Either a weird coincidence or some simple homework."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6042711308107776","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"59","title":"In given array find zero and replace the entire row and column with zeros  \n     \n    E.g Input: \n     \n    1   2   3   4 \n    5   6   7   8 \n    9   10  0   11 \n    12  13  14  15 \n \n    Output: \n     \n    1   2   0   4 \n    5   6   0   8 \n    0   0   0   0 \n    12  13  0   15","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package main.java.matrix; \n \nimport java.util.ArrayList; \nimport java.util.Iterator; \nimport java.util.List; \n \n/** \n * In given array find zero and replace the entire row and column with zeros  \n     \n    E.g Input: \n     \n    1   2   3   4 \n    5   6   7   8 \n    9   10  0   11 \n    12  13  14  15 \n \n    Output: \n     \n    1   2   0   4 \n    5   6   0   8 \n    0   0   0   0 \n    12  13  0   15 \n * @author kuldeep \n * \n */ \npublic class MatrixZeroValueFinder { \n \n int[][] array = new int[][]{ \n   {1,2,3,4}, \n   {5,6,7,8}, \n   {9,10,0,12}, \n   {13,0,15,16} \n }; \n  \n private List zeroIndexes = new ArrayList(); \n  \n public void printArray(){ \n   \n  System.out.println(\"Printing Array\"); \n  for (int i = 0; i < array.length; i++) { \n   for (int j = 0; j < array[i].length; j++) { \n    System.out.print(\"\\t\"+array[i][j]); \n   } \n   System.out.println(); \n  } \n } \n  \n public void fillArrayForZeroValues(){ \n  for (Iterator iter = zeroIndexes.iterator(); iter.hasNext();) { \n   ArrayIndex element = (ArrayIndex) iter.next(); \n   int row = element.getRow(); \n   int column = element.getColumn(); \n   for (int i = 0; i < array[row].length; i++) { \n    array[row][i]=0; \n   } \n   for (int i = 0; i < array.length; i++) { \n    array[i][column]=0; \n   } \n  } \n } \n  \n public void findZeroIndexes(){ \n  for (int i = 0; i < array.length; i++) { \n   for (int j = 0; j < array[i].length; j++) { \n    if(array[i][j]==0){ \n     zeroIndexes.add(new ArrayIndex(i,j)); \n    } \n   } \n  } \n } \n  \n public static void main(String[] args) { \n  MatrixZeroValueFinder finder = new MatrixZeroValueFinder(); \n  finder.printArray(); \n  finder.findZeroIndexes(); \n  finder.fillArrayForZeroValues(); \n  finder.printArray(); \n } \n  \n} \nclass ArrayIndex{ \n  \n private int row; \n private int column; \n  \n public ArrayIndex(int row,int column){ \n  this.row=row; \n  this.column = column; \n } \n \n public int getColumn() { \n  return column; \n } \n \n public int getRow() { \n  return row; \n } \n  \n  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"all the above  Solutions will take o(n^4) time.Can anybody suggest optimized solution for this problem ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"all the above  Solutions will take o(n^4) time.Can anybody suggest optimized solution for this problem ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can anybody suggest optimized solution for this as all the above solution takes O(n^2) time"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Logic I Used: 1.scan the matrix row wise. 2.the moment you encounter 0 break from that iteration 3.Maintain 2 list called row and col that specify the row index and col index of 0(handles multiple occurence of 0). 4.Once the elements are  scanned then fetch the row list and change it to 0. (so this should happen column no of times) 5.fetch the col list and change it to 0. (so this should happen row no of times).  Time Complexity:fetching 0 + changing to 0                                O(mn)+O(n(m))+O(m(n))=O(mn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Logic I Used: 1.scan the matrix row wise. 2.the moment you encounter 0 break from that iteration 3.Maintain 2 list called row and col that specify the row index and col index of 0(handles multiple occurence of 0). 4.Once the elements are  scanned then fetch the row list and change it to 0. (so this should happen column no of times) 5.fetch the col list and change it to 0. (so this should happen row no of times).  Time Complexity:fetching 0 + changing to 0                                O(mn)+O(n(m))+O(m(n))=O(mn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/*  * Problem1: In given array find zero and replace the entire row and column with zeros   * Logic I Used:  1.scan the matrix row wise.  2.the moment you encounter 0 break from that iteration  3.Maintain 2 list called row and col that specify the row index and col index of 0(handles multiple occurence of 0).  4.Once the elements are scanned then fetch the row list and change it to 0.  (so this should happen column no of times)  5.fetch the col list and change it to 0.  (so this should happen row no of times).   Time Complexity:fetching 0 + changing to 0  O(mn)+O(n(m))+O(m(n))=O(mn) */"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the Java Code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Question {         public static void nullifyRow(int[][] matrix, int row) {                 for (int j = 0; j < matrix[0].length; j++) {                         matrix[row][j] = 0;                 }                         }          public static void nullifyColumn(int[][] matrix, int col) {                 for (int i = 0; i < matrix.length; i++) {                         matrix[i][col] = 0;                 }                         }                                  public static void setZeros2(int[][] matrix) {                 boolean rowHasZero = false;                 boolean colHasZero = false;                                                  // Check if first row has a zero                 for (int j = 0; j < matrix[0].length; j++) {                         if (matrix[0][j] == 0) {                                 rowHasZero = true;                                 break;                         }                 }                                                  // Check if first column has a zero                 for (int i = 0; i < matrix.length; i++) {                         if (matrix[i][0] == 0) {                                 colHasZero = true;                                 break;                         }                 }                                                  // Check for zeros in the rest of the array                 for (int i = 1; i < matrix.length; i++) {                         for (int j = 1; j < matrix[0].length;j++) {                                 if (matrix[i][j] == 0) {                                         matrix[i][0] = 0;                                         matrix[0][j] = 0;                                  }                         }                 }                                                  // Nullify rows based on values in first column                 for (int i = 1; i < matrix.length; i++) {                         if (matrix[i][0] == 0) {                                 nullifyRow(matrix, i);                         }                 }                                                  // Nullify columns based on values in first row                 for (int j = 1; j < matrix[0].length; j++) {                         if (matrix[0][j] == 0) {                                 nullifyColumn(matrix, j);                         }                 }                                          // Nullify first row                 if (rowHasZero) {                         nullifyRow(matrix, 0);                 }                                  // Nullify first column                 if (colHasZero) {                         nullifyColumn(matrix, 0);                 }         }                          public static void setZeros(int[][] matrix) {                 boolean[] row = new boolean[matrix.length];                         boolean[] column = new boolean[matrix[0].length];                  // Store the row and column index with value 0                 for (int i = 0; i < matrix.length; i++) {                         for (int j = 0; j < matrix[0].length;j++) {                                 if (matrix[i][j] == 0) {                                         row[i] = true;                                         column[j] = true;                                  }                         }                 }                                  // Nullify rows                 for (int i = 0; i < row.length; i++) {                         if (row[i]) {                                 nullifyRow(matrix, i);                         }                 }                                  // Nullify columns                 for (int j = 0; j < column.length; j++) {                         if (column[j]) {                                 nullifyColumn(matrix, j);                         }                 }         }                          public static boolean matricesAreEqual(int[][] m1, int[][] m2) {                 if (m1.length != m2.length || m1[0].length != m2[0].length) {                         return false;                 }                                  for (int k = 0; k < m1.length; k++) {                         for (int j = 0; j < m1[0].length; j++) {                                 if (m1[k][j] != m2[k][j]) {                                         return false;                                 }                         }                 }                         return true;         }                  public static int[][] cloneMatrix(int[][] matrix) {                 int[][] c = new int[matrix.length][matrix[0].length];                 for (int i = 0; i < matrix.length; i++) {                         for (int j = 0; j < matrix[0].length; j++) {                                 c[i][j] = matrix[i][j];                         }                 }                 return c;         }                  public static void main(String[] args) {                 int nrows = 10;                 int ncols = 15;                 int[][] matrix1 = AssortedMethods.randomMatrix(nrows, ncols, 0, 100);                                 int[][] matrix2 = cloneMatrix(matrix1);                  AssortedMethods.printMatrix(matrix1);                                  setZeros(matrix1);                 setZeros2(matrix2);                                  System.out.println();                                  AssortedMethods.printMatrix(matrix1);                 System.out.println();                 AssortedMethods.printMatrix(matrix2);                                  if (matricesAreEqual(matrix1, matrix2)) {                         System.out.println(\"Equal\");                 } else {                         System.out.println(\"Not Equal\");                 }         }  }  Assorted Method.randomMatrix is simple function to print Matrix  public static int[][] randomMatrix(int M, int N, int min, int max) {                 int[][] matrix = new int[M][N];                 for (int i = 0; i < M; i++) {                         for (int j = 0; j < N; j++) {                                 matrix[i][j] = randomIntInRange(min, max);                         }                 }                 return matrix;         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import CtCILibrary.AssortedMethods; \n \npublic class Question { \n        public static void nullifyRow(int[][] matrix, int row) { \n                for (int j = 0; j < matrix[0].length; j++) { \n                        matrix[row][j] = 0; \n                }                 \n        } \n \n        public static void nullifyColumn(int[][] matrix, int col) { \n                for (int i = 0; i < matrix.length; i++) { \n                        matrix[i][col] = 0; \n                }                 \n        }                 \n         \n        public static void setZeros2(int[][] matrix) { \n                boolean rowHasZero = false; \n                boolean colHasZero = false;                 \n                 \n                // Check if first row has a zero \n                for (int j = 0; j < matrix[0].length; j++) { \n                        if (matrix[0][j] == 0) { \n                                rowHasZero = true; \n                                break; \n                        } \n                }                 \n                 \n                // Check if first column has a zero \n                for (int i = 0; i < matrix.length; i++) { \n                        if (matrix[i][0] == 0) { \n                                colHasZero = true; \n                                break; \n                        } \n                }                 \n                 \n                // Check for zeros in the rest of the array \n                for (int i = 1; i < matrix.length; i++) { \n                        for (int j = 1; j < matrix[0].length;j++) { \n                                if (matrix[i][j] == 0) { \n                                        matrix[i][0] = 0; \n                                        matrix[0][j] = 0; \n                                 } \n                        } \n                }                 \n                 \n                // Nullify rows based on values in first column \n                for (int i = 1; i < matrix.length; i++) { \n                        if (matrix[i][0] == 0) { \n                                nullifyRow(matrix, i); \n                        } \n                }                 \n                 \n                // Nullify columns based on values in first row \n                for (int j = 1; j < matrix[0].length; j++) { \n                        if (matrix[0][j] == 0) { \n                                nullifyColumn(matrix, j); \n                        } \n                }         \n                 \n                // Nullify first row \n                if (rowHasZero) { \n                        nullifyRow(matrix, 0); \n                } \n                 \n                // Nullify first column \n                if (colHasZero) { \n                        nullifyColumn(matrix, 0); \n                } \n        }         \n         \n        public static void setZeros(int[][] matrix) { \n                boolean[] row = new boolean[matrix.length];         \n                boolean[] column = new boolean[matrix[0].length]; \n \n                // Store the row and column index with value 0 \n                for (int i = 0; i < matrix.length; i++) { \n                        for (int j = 0; j < matrix[0].length;j++) { \n                                if (matrix[i][j] == 0) { \n                                        row[i] = true; \n                                        column[j] = true; \n                                 } \n                        } \n                } \n                 \n                // Nullify rows \n                for (int i = 0; i < row.length; i++) { \n                        if (row[i]) { \n                                nullifyRow(matrix, i); \n                        } \n                } \n                 \n                // Nullify columns \n                for (int j = 0; j < column.length; j++) { \n                        if (column[j]) { \n                                nullifyColumn(matrix, j); \n                        } \n                } \n        }         \n         \n        public static boolean matricesAreEqual(int[][] m1, int[][] m2) { \n                if (m1.length != m2.length || m1[0].length != m2[0].length) { \n                        return false; \n                } \n                 \n                for (int k = 0; k < m1.length; k++) { \n                        for (int j = 0; j < m1[0].length; j++) { \n                                if (m1[k][j] != m2[k][j]) { \n                                        return false; \n                                } \n                        } \n                }         \n                return true; \n        } \n         \n        public static int[][] cloneMatrix(int[][] matrix) { \n                int[][] c = new int[matrix.length][matrix[0].length]; \n                for (int i = 0; i < matrix.length; i++) { \n                        for (int j = 0; j < matrix[0].length; j++) { \n                                c[i][j] = matrix[i][j]; \n                        } \n                } \n                return c; \n        } \n         \n        public static void main(String[] args) { \n                int nrows = 10; \n                int ncols = 15; \n                int[][] matrix1 = AssortedMethods.randomMatrix(nrows, ncols, 0, 100);                 \n                int[][] matrix2 = cloneMatrix(matrix1); \n \n                AssortedMethods.printMatrix(matrix1); \n                 \n                setZeros(matrix1); \n                setZeros2(matrix2); \n                 \n                System.out.println(); \n                 \n                AssortedMethods.printMatrix(matrix1); \n                System.out.println(); \n                AssortedMethods.printMatrix(matrix2); \n                 \n                if (matricesAreEqual(matrix1, matrix2)) { \n                        System.out.println(\"Equal\"); \n                } else { \n                        System.out.println(\"Not Equal\"); \n                } \n        } \n} \n \n \nAssortedMethods.randomMatrix is a simple function to print matrix \npublic static int[][] randomMatrix(int M, int N, int min, int max) { \n                int[][] matrix = new int[M][N]; \n                for (int i = 0; i < M; i++) { \n                        for (int j = 0; j < N; j++) { \n                                matrix[i][j] = randomIntInRange(min, max); \n                        } \n                } \n                return matrix; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void findZero(int[][] array){ \n   \n  for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) { \n \n  int col = 0, row = 0; \n  int arr[][] = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 0, 11 }, \n    { 12, 13, 14, 15 } }; \n  for (int i = 0; i < arr.length; i++) { \n   for (int j = 0; j < arr.length; j++) { \n    if (arr[i][j] == 0) { \n     col = i; \n     row = i; \n    } \n   } \n  } \n  for (int i = 0; i < 4; i++) { \n   arr[col][i] = 0; \n   arr[i][row] = 0; \n  } \n  for (int i = 0; i < arr.length; i++) { \n   for (int j = 0; j < arr.length; j++) { \n    System.out.print(arr[i][j] + \"  \"); \n   } \n   System.out.println(); \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include   void main() {  clrscr();  int a[3][3],b[10],k=0,z,i;  for(int p=0;p<10;p++)   b[p]=-1;  cout<<\"Enter the aaray\";  for(i=0;i<3;i++)  {   for(int j=0;j<3;j++)   {    cin>>a[i][j];    if(a[i][j]==0)    {     b[k]=i;     k++;     b[k]=j;     k++;    }   }  }   for(i=0;i<10;i++)  {   if(b[i]!=-1)   {    z=b[i];    if(i%2==0)    {      for(int d=0;d<3;d++)        a[z][d]=0;    }    else    {     for(int d=0;d<3;d++)      a[d][z]=0;    }  }  }  for(i=0;i<3;i++)  {   for(int j=0;j<3;j++)   {    cout<  }   cout<<\"\\n\";  }  getch(); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \nvoid main() \n{ \n clrscr(); \n int a[3][3],b[10],k=0,z,i; \n for(int p=0;p<10;p++) \n  b[p]=-1; \n cout<<\"Enter the aaray\"; \n for(i=0;i<3;i++) \n { \n  for(int j=0;j<3;j++) \n  { \n   cin>>a[i][j]; \n   if(a[i][j]==0) \n   { \n    b[k]=i; \n    k++; \n    b[k]=j; \n    k++; \n   } \n  } \n } \n \n for(i=0;i<10;i++) \n { \n  if(b[i]!=-1) \n  { \n   z=b[i]; \n   if(i%2==0) \n   { \n \n    for(int d=0;d<3;d++) \n       a[z][d]=0; \n   } \n   else \n   { \n    for(int d=0;d<3;d++) \n     a[d][z]=0; \n   } \n } \n } \n for(i=0;i<3;i++) \n { \n  for(int j=0;j<3;j++) \n  { \n   cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include   void main() {  clrscr();  int a[3][3],b[10],k=0,z,i;  for(int p=0;p<10;p++)   b[p]=-1;  cout<<\"Enter the aaray\";  for(i=0;i<3;i++)  {   for(int j=0;j<3;j++)   {    cin>>a[i][j];    if(a[i][j]==0)    {     b[k]=i;     k++;     b[k]=j;     k++;    }   }  }   for(i=0;i<10;i++)  {   if(b[i]!=-1)   {    z=b[i];    if(i%2==0)    {      for(int d=0;d<3;d++)        a[z][d]=0;    }    else    {     for(int d=0;d<3;d++)      a[d][z]=0;    }  }  }  for(i=0;i<3;i++)  {   for(int j=0;j<3;j++)   {    cout<  }   cout<<\"\\n\";  }  getch(); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #include using namespace std; int main() {  int array[4][4] = {{1,2,3,4},    {5,6,7,8},    {9,10,0,12},    {13,0,15,16}};  int R=4; int C=4;  set s1;  set s2;  for( int i = 0 ;i < R ; i++ )  {   for(int j = 0; j < C;j++)   {    if( array[i][j] == 0 )    {      s1.insert(i);     s2.insert(j);        }     }  }  std::set::iterator it;  for( it = s1.begin(); it != s1.end(); it++ )  {   for( int i = 0 ; i < C ; i++ )   {    array[*it][i] = 0;   }     } cout << endl;  for( it = s2.begin(); it != s2.end(); it++ )  {   for( int i = 0 ; i < R ; i++ )   {    array[i][*it] = 0;   }  }  for(int i = 0; i < R; i++)  {   for(int j = 0 ;j  {    cout << array[i][j] << \" \";   } cout << endl;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n#include \nusing namespace std; \nint main() \n{ \n int array[4][4] = {{1,2,3,4}, \n   {5,6,7,8}, \n   {9,10,0,12}, \n   {13,0,15,16}}; \n int R=4; int C=4; \n set s1; \n set s2; \n for( int i = 0 ;i < R ; i++ ) \n { \n  for(int j = 0; j < C;j++) \n  { \n   if( array[i][j] == 0 ) \n   {  \n    s1.insert(i); \n    s2.insert(j);     \n   }   \n  } \n } \n std::set::iterator it; \n for( it = s1.begin(); it != s1.end(); it++ ) \n { \n  for( int i = 0 ; i < C ; i++ ) \n  { \n   array[*it][i] = 0; \n  } \n   \n } cout << endl; \n for( it = s2.begin(); it != s2.end(); it++ ) \n { \n  for( int i = 0 ; i < R ; i++ ) \n  { \n   array[i][*it] = 0; \n  } \n } \n for(int i = 0; i < R; i++) \n { \n  for(int j = 0 ;j"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; \n \npublic class Matrix { \n  \n public static int[][] setZeroRowsCols(int[][] matrix){ \n  int len = matrix.length; \n  ArrayList locations = new ArrayList(); \n   \n  for(int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) iterate through the matrix  - if a zero is found at [i,j]set [i,0] and [0,j] to 0 2) iterate again and set all the values to 0 based on if [i,0] or [0,j] is 0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It will take O(N) time complexity...  public class Class1 {     public Class1() {         super();     }          public static void main(String args[]){                 int a[][] = {{1, 2 ,  3  , 4 },{5 ,  6  , 7  , 8},{9  , 10 , 0  , 11},{12 , 13 , 14 , 15}};        int row=0 , col =0;         for(int i=0;i<16;i++){                        if(i%4==0 && i!=0){                row++;            }            if(a[row][i%4]==0){                System.out.println(\"Founded Element!!!\"+row+(i%4));                col = i%4;                break;            }                    }         for(int i=0 ; i<4;i++){             a[row][i]=0;         }         for(int i=0;i<4;i++){             a[i][col]=0;         }         row =0 ;         for(int i=0;i<16;i++){                 if(i%4==0 && i!=0){                     row++;                     System.out.println();                 }                 System.out.print(a[row][(i%4)]+\"   \");             }                  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It will take O(N) time complexity...  public class Class1 {     public Class1() {         super();     }          public static void main(String args[]){                 int a[][] = {{1, 2 ,  3  , 4 },{5 ,  6  , 7  , 8},{9  , 10 , 0  , 11},{12 , 13 , 14 , 15}};        int row=0 , col =0;         for(int i=0;i<16;i++){                        if(i%4==0 && i!=0){                row++;            }            if(a[row][i%4]==0){                System.out.println(\"Founded Element!!!\"+row+(i%4));                col = i%4;                break;            }                    }         for(int i=0 ; i<4;i++){             a[row][i]=0;         }         for(int i=0;i<4;i++){             a[i][col]=0;         }         row =0 ;         for(int i=0;i<16;i++){                 if(i%4==0 && i!=0){                     row++;                     System.out.println();                 }                 System.out.print(a[row][(i%4)]+\"   \");             }                  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a in-place replacement except the matrix is traversed twice. Time complexity is O(m x n) + O(m x n). We might need some space for storing the rows and columns that have Zeroes.  1. Find all the positions (X,Y) where the value is ZERO 2. Keep all X positions to rows set and Y positions to column set 3. If for any position in the matrix (X,Y) existing in the row set or column set respectively set as Zero or else keep it the same"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's python version:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This will work"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"my algorithm is O(m*n), which m,n is the length of row and col.  using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks;  namespace RepZero {     class Program     {         static List> matrix = new List>         {             new List {1,2,3,4},             new List {5,6,7,8},             new List {9,10,0,12},             new List {13,0,15,16}         };         static List row = new List { 1, 1, 1, 1 };         static List col = new List { 1, 1, 1, 1 };           static void Main(string[] args)         {             Console.WriteLine(\"row : \");             printList(row);             Console.WriteLine();             Console.WriteLine(\"col : \");             printList(col);             Console.WriteLine();             Console.WriteLine(\"matrix : \");             printMatrix(matrix);             Console.WriteLine();             Console.WriteLine(\"progress.\");             findZero();             Console.WriteLine(\"row : \");             printList(row);             Console.WriteLine();             Console.WriteLine(\"col : \");             printList(col);             Console.WriteLine();             Console.WriteLine(\"replace Zero.\");             replaceZero();             Console.WriteLine(\"matrix : \");             printMatrix(matrix);              Console.ReadKey();         }          static void findZero()         {             for (int r = 0; r < matrix.Count(); r++)             {                 if (row[r] == 0) continue;                 for (int c = 0; c < matrix[r].Count(); c++)                 {                     if (col[c] == 0) continue;                     if (matrix[r][c] == 0)                     {                         row[r] = 0;                         col[c] = 0;                     }                 }             }         }          static void replaceZero()         {             // update row             for (int r = 0; r < row.Count(); r++)             {                 if (row[r] == 0)                 {                     for (int i = 0; i < matrix[r].Count(); i++)                     {                         matrix[r][i] = 0;                     }                 }             }             // update col             for (int c = 0; c < col.Count(); c++)             {                 if (col[c] == 0)                 {                     for (int i = 0; i < matrix.Count(); i++)                     {                         matrix[i][c] = 0;                     }                 }             }         }          static void printList(List list)         {             foreach (var item in list)             {                 Console.Write(item + \",\");             }         }          static void printMatrix(List> matrix)         {             foreach (var row in matrix)             {                 printList(row);                 Console.WriteLine();             }         }     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"my algorithm is O(m*n), which m,n is the length of row and col."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Another way to do in it in C# since this is Microsoft interview."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The solution is simple. I am not writing the code but you can easily follow the logic to write your own. We have to understand that as soon as we encounter an element as 0 in a row(or column), we can simply continue to the next row(or column).  1. Make 2 1-D boolean arrays for rows and columns. Mark all as false. 2. Go through the 2D array and mark the row number/column number as true and move to the next loop without checking any further in same row or column. 3. Go through the row array and mark all rows in matrix with boolean value true as 0. 4. Go through the column array and mark all columns with boolean value true as 0."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The solution is simple. I am not writing the code but you can easily follow the logic to write your own. We have to understand that as soon as we encounter an element as 0 in a row(or column), we can simply continue to the next row(or column).  1. Make 2 1-D boolean arrays for rows and columns. Mark all as false. 2. Go through the 2D array and mark the row number/column number as true and move to the next loop without checking any further in same row or column. 3. Go through the row array and mark all rows in matrix with boolean value true as 0. 4. Go through the column array and mark all columns with boolean value true as 0."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"In N X M Matrix, Consider N as row and M as column, need to optimize the below code. O(n X m) for finding zeros and  In worst case O(n X m) for replacing the respective row and column with zeros, assuming if 1 entire row and entire column given as zeros. E.g.  0  0  0 0  1  2 0  3  4"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public static void replaceZero(int[][] array){ \n        Set rowList = new HashSet(); \n        Set colList = new HashSet(); \n        for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"private static void FillZeros(int[][] arr, int nRows, int nCols) \n        { \n            var rowsToZero = new bool[nRows]; \n            var colsToZero = new bool[nCols]; \n \n            for (int rowIdx = 0; rowIdx < nRows; rowIdx++) \n                for (int colIdx = 0; colIdx < nCols; colIdx++) \n                    if (arr[rowIdx][colIdx] == 0) \n                    { \n                        rowsToZero[rowIdx] = true; \n                        colsToZero[colIdx] = true; \n                    } \n \n            for (int rowIdx = 0; rowIdx < nRows; rowIdx++) \n                for (int colIdx = 0; colIdx < nCols; colIdx++) \n                    if (rowsToZero[rowIdx] || colsToZero[colIdx]) \n                        arr[rowIdx][colIdx] = 0; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public static void FindAndReplaceZero() \n        { \n            int[,] array = \n            { \n                {0, 2, 3, 4}, \n                {5, 6, 7, 8}, \n                {9, 10, 1, 11}, \n                {12, 13, 14, 15} \n            }; \n \n            int row = 0, col = 0; \n            for (int i = 0; i < 4; i++) \n            { \n                for (int j = 0; j < 4; j++) \n                { \n                    if (array[i, j] == 0) \n                    { \n                        row = i; \n                        col = j; \n                    } \n                } \n            } \n            for (int i = 0; i < 4; i++) \n            { \n                for (int j = 0; j < 4; j++) \n                { \n                    if (j ==col ) \n                    { \n                        array[i, j] = 0; \n                    } \n                    if (row == i) \n                    { \n                        array[i, j] = 0; \n                    } \n                } \n            }                         \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I think we can through the matrix first and find out all the zeros' cols and rows in it then fill those cols and rows.  But instead of scanning by row only or by col only, we can do it both in one loop, so the procedure is more like scanning the matrix from left up to right down, meanwhile we can record those to-be-filled cols and rows to save rebundant scannings."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"-Initialize 2 arrays, countRows, countCols to zero, to keep track of which rows and columns to make zero. -Scan the given matrix for zeros and make countRows[i] and countCols[j] = 1 -In the second pass, just go through countRows and countCols, look for 1 and make the corresponding row and column 0.  Complexity: O(m x n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"CONSIDERING 4X4 MATRIX N=3   for (i=0;i    {  for (j=0;j<=n;j++)             {               if(a[i][j] ==0 )                   {                       for (k=0;k<=n;k++)                            {                                if(a[i][k]!=0){a[i][k]=0; }                                   if(a[k][j]!=0){a[k][j]=0; }                                                             }                   }        }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This is not very optimized code. But this will work."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"/*In given array find zero and replace the entire row and column with zeros  \n     \n    E.g Input: \n     \n    1   2   3   4 \n    5   6   7   8 \n    9   10  0   11 \n    12  13  14  15 \n \n    Output: \n     \n    1   2   0   4 \n    5   6   0   8 \n    0   0   0   0 \n    12  13  0   15 \n*/ \n \n \n#include \n#include \n#define row 4 \n#define col 3 \nmain() \n{ \n int i,j; \n int m,n; \n int arr[row][col]; \n printf(\"Inputing matrix...\");  \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"#include  #include  int main() {     int i, j, x, y;     int a[3][3] = {1, 2,0 ,4,5, 6,7,8,9};             printf(\"\\ncheck  postion of zero\");          for(i = 0; i < 3; i++)     {         for(j = 0; j < 3; j++)         {             if(a[i][j] == 0)             {                 x = i;                 y = j;             }         }     }           printf(\"\\n Out put \\n\");           for(i = 0; i < 3; i++)     {         for(j = 0; j < 3; j++)         {             if(i == x | (j == y))             {                 a[i][j] = 0;             }             printf(\"%d \", a[i][j]);         }         printf(\"\\n\");     }                         return 0;               }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"#include void main() {     int a[15][15],i,j,m,n,s;     printf(\"Enter row and column size: \");     scanf(\"%d%d\",&m,&n);      printf(\"Enter elements:\");     for(i=0;i    for(j=0;j    scanf(\"%d\",&a[i][j]);      printf(\"Enter index:\");     scanf(\"%d\",&s);      for(i=0;i    {         for(j=0;j        {             if(a[i][j]==s)             {                 for(j=0;j                {                     a[i][j]=0;                 }             }         }     }     for(i=0;i    for(j=0;j    {         printf(\"%d,\",a[i][j]);     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"public static void replaceRowNcolumWith0(){   int  matricArray[][] = new int[][]{{1,2,3,5},{5,6,0,43},{9,10,11,6},{13,14,15,8},{1}};      int row = 0,col = 0; // A element's row number and column number which is 0.       for(int i=0;i   for(int j=0;j    System.out.print(matricArray[i][j]+\" \");     if(matricArray[i][j] == 0){      row = i;      col = j;     }    }    System.out.println();   }    for(int k=0;k   for(int l=0;l    if(row==k || col==l)      matricArray[k][l] = 0;    }   }   for(int i=0;i   for(int j=0;j    System.out.print(matricArray[i][j]+\" \");    }    System.out.println();   }   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"public static void main(String[] args) { \n \n  int[][] a = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 0, 12 }, \n    { 12, 13, 14, 15 } }; \n  int i = 0; \n  int j = 0; \n   \n  boolean found = false; \n   \n  for (i = 0; i < a.length; i++) { \n   for (j = 0; j < a[i].length; j++) { \n    if (a[i][j] == 0) { \n     found = true; \n     break; \n    } \n   } \n    \n   if(found) { \n    break; \n   } \n  } \n \n  // Zero column j for all rows \n  for (int k = 0; k < a.length; k++) { \n   a[k][j] = 0; \n  } \n \n  print(a); \n \n   \n  //Zero row i for all columns \n  for (int x = 0; x < a[i].length; x++) { \n   a[i][x] = 0; \n \n  } \n \n  print(a); \n } \n \n static void print(int[][] a) { \n  for (int i = 0; i < a.length; i++) { \n   for (int j = 0; j < a[i].length; j++) { \n    System.out.print(a[i][j] + \" \"); \n   } \n \n   System.out.println(); \n  } \n  System.out.println(); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"public static void replaceZero(int[][] array){ \n        Set rowList = new HashSet(); \n        Set colList = new HashSet(); \n        for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"public static void replaceZero(int[][] array){ \n        Set rowList = new HashSet(); \n        Set colList = new HashSet(); \n        for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"public static void replaceZero(int[][] array){ \n        Set colList = new HashSet(); \n        for(int i=0;i"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5694538274308096","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"14","title":"How to sort 2 queues without additional containers?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"this is just a extended version of \"sort a queue with the help of an other queue.\"  First give the solution of \"sort a queue with the help of an other queue\", the idea here is if the item at the head of the target queue (first queue) is smaller than the item has been dequeued and pushed to the temp queue (second queue) , we dequeue the item from target queue and push it to the temp queue, otherwise dequeue it from target and enqueue it back to the target, process until we have worked thru all the elements, if all the elements are in the tmp queue (second queue) means the sort is done, otherwise redo the process until the sort is done .   Code as below -"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Suppose we have two queues as an array q[], we can do the following steps to sort them in order: (1)Keep dequeuing q[0] and enqueue them into q[1], till q[0] is empty and q[1] has all the items.  >>> Now q[0] is empty and q[1] has all the items.  (2)Dequeue all items in q[1] and enqueue them into q[0], at the same time record how many items there are and the minimum item's position in the queue, let's say the there are N items in total, and the minimum is the Kth item in the queue now. >>> Now q[0] has all the items and the minimum is the Kth item.  (3)Dequeue q[0] K-1 times and enqueue them into q[1], so that we have the minimum item in front of q[0]. Move all items in q[1] to q[0]. And then dequeue q[0] and enqueue it back. >>> Now q[0] has all the items and the minimum is in the end.  (4)As for the second minimum item, just like repeating step 2 and step 3, but this time we only need to dequeue q[0] N-1 times at most to find out the second minimum item's position, because we already know the minimum is in the end! Then we can let the second minimum be the end of the queue, while the minimum is just in front of it. >>> Now q[0] has all the items and the two minimums are in the end and in order.  (5)Repeat the procedure as stated above till the largest item is in the end of the queue and then the sorting is done."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public Queue sort(Queue a, Queue b){ \n   \n  if (a.isEmpty()&&b.isEmpty()){ \n   return null; \n  } \n   \n  //clear a queue \n  while (!a.isEmpty()){ \n   b.add(a.poll()); \n  } \n   \n  //count total number and clear b queue \n  int i = 0; \n  while(!b.isEmpty()){ \n   a.add(b.poll()); \n   i++; \n  } \n   \n  //add one element to b queue \n  b.add(a.poll()); \n   \n  // i-j is the size of b queue \n  int j = i-1; \n   \n  while (j>0){ \n   // if a head <= b head, add a head before b head \n   if (a.peek()<=b.peek()){ \n    b.add(a.poll()); \n    for (int x =i-j; x>0; x--){ \n     b.add(b.poll()); \n    } \n   } \n   else{ \n    // move b head find the b head which is bigger than a head. \n    int x = i-j; \n     \n    while(a.peek()>b.peek()){ \n     if(x==0) \n      break; \n     b.add(b.poll()); \n     x--; \n    } \n     \n    // add a head to b queue \n    b.add(a.peek()); \n     \n    // move b head back to increasing order \n    while(x>0){ \n     b.add(b.poll()); \n     x--; \n    } \n     \n    //delete a head \n    a.remove(); \n   }  \n    \n   j--; \n  } \n   \n  return b;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Time complexity : O((n1 + n2)^2) worst case, but for random input will be O(nlog(n)). First off, I should say that I believe O(nlog(n)) for worst does not seem to be likely to exist. The Quicksort algorithm, which is in-place sorting, needs O(1) swapping between elements which we cannot do here. Nonetheless, It is just a guess.  I show the algorithm with an example. The attach the java code.   Lets assume Q1: [1 4 3 2] and Q2: [8 6 5 7] are the two queues where the left most is head of line. I just show the steps 1- (dequeue Q2 into Q1) Q1:[1 4 3 2 8 6 7 5] Q: []   (nQ2inQ1 = 4, nQ1inQ1 = 4) 2- Dequeue the first the head of line in Q1 into Q2. Q1:[4 3 2 8 6 7 5] Q2:[1] (nQ1inQ1 = 3) 3- Dequeue all the elements from Q1. If it is larger than the last element entering Q2, enqueue into Q2, otherwise, enqueue into Q1. Q1:[3 2 8 6 7 5] Q2:[1 4] nQ1inQ1 = 3, nQ2inQ1 = 4, nQ1inQ2 = 2, last_entered_Q2 = 4 Q1:[2 8 6 7 5 3] Q2:[1 4] nQ1inQ1 = 3, nQ2inQ1 = 4, nQ1inQ2 = 2, last_entered_Q2 = 4 Q1:[8 6 7 5 3 2] Q2:[1 4]. 4- Dequeue Q2 into Q1. Q1:[8 6 7 5 3 2 1 4] Q2:[] nQ2inQ1 = 4, nQ1inQ1 = 4. 5- Repeat the process again for elements of Q2. You eventually get: Q1[3 2 1 4 6 7 5 8] Q2:[] 6- Again doing it for elements of Q1. We get at the end Q1[6 7 5 8 2 1 3 4] Q2:[] 7- Again (for Q2) Q1[2 1 3 4 5 6 7 8] Q:[] (note that Q2 is sorted now) 8- Again (for Q1) Q1:[5 6 7 8 1 2 3 4] Q:[] 9- In this round, we realize that Q2 is sorted. (no inversions) 10- In the next step, we find that Q1 is also sorted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Merge the two queues.  2. Sort it using Insertion sort technique."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"QueueSort (queue Q1, queue Q2) \n{ \n Q1 end marker: q1_end \n Q2 end marker: q2_end \n \n Q2.enqueue (q2_end); \n \n //Push all data from Q1 to Q2 \n while ( !Q1.empty() ) \n { \n  Q2.enqueue (Q1.dequeue() ); \n } \n //put end marker for Q1's data \n Q2.enqueue (q1_end); \n \n //sort Q2's data into Q1 \n while (1) \n { \n  small = e = Q2.dequeue (); \n  //process till Q2's end marker is not reached \n  while (e != q2endmarker() ) \n  { \n   //remember smallest element and keep enqueuing rest of Q2 element in Q2 itself \n   e = Q2.dequeue(); \n   if (e < small) \n   { \n    Q2.enqueue (small) \n    small = e \n   } \n   else \n    Q2.enqueue (e) \n  } \n  //again mark queue end \n  Q2.enqueue (q2_end) \n \n  //put smallest Q2's element in Q1 \n  Q1.enqueue (small) \n \n  //Simply Dequeue and enqueue back Q1's all element into Q2 \n  e = Q2.dequeue() \n  while (e != q1endmarker()) ) \n  { \n   Q2.enqueue (e) \n   e = Q2.dequeue () \n  } \n  //again mark queue end \n  Q2.enqueue (q1_end) \n } \n remove q1_end and q2_end from Q2 \n} \n//after this function, Q2 is sorted in Q1 \n \nFunction (Queue Q1, Queue Q2) \n{ \n QueueSort (Q1, Q2); \n QueueSort (Q2, Q1); \n //Swap elements of both queue's. Function not implemented \n swapQueue (Q1, Q2); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assume that we moved all elements from Queue2 to Queue1. Then perform the below steps.  1. Store the 'Queue1' count and peek 'Queue1' element and store it in 'queue1InitialTempElement'. 2. Repeat a loop till a flag 'IsSorted' becomes true. 3. Once enterted in loop dequeue element from the 'Queue1' and store it in 'queue1DequedElement'.  4. if 'queue1InitialTempElement' is grater than or equals to 'queue1DequedElement'.     4.1. Then store 'queue1DequedElement' value in 'queue1InitialTempElement'.     4.2. And enqueue 'queue1InitialTempElement' value in to 'Queue2'.  5. Else store 'queue1DequedElement' back to 'Queue1'. 6. Increment the 'lpCntProcessedElemnts' and check it if it is equals 'Queue1' length.      6.1. If they are not equal then continue the loop.          7. If the Queue2. Count is equals to 'Queue1' length.       7.1. If they are equal then make 'IsSorted' flag as true.  8. Reset 'lpCntProcessedElemnts' to zero. 9. Repeat loop till 'Queue2' Count is grater than zero and dequeue all elements from 'Queue2' and enqueue then to 'Queue1'. 10. Peek 'Queue1' element and store it in 'queue1InitialTempElement'.  11. End the loop of 'IsSorted' flag."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4804950454435840","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"13","title":"Given a 2D array of 1 and 0, Find the largest rectangle (may not be square) which is made up of all 1 or 0.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"First, consider the following problem (Maximizing Histogram rectangle area problem): Given an array of non-negative integers which represents column heights in a column graph, what is the maximum area rectangle in the given graph? For instance, suppose array = {1,3,5,2,4,1,3} (first column height is 1, second is 3,...). The maximum area rectangle's height in this case is 2 and its width would be 4 (corresponding to the indices 1,2,3,4 in array).  To solve this problem we'll maintain a stack of array indices with the following constraints: 1. The indices are in increasing order. 2. The column heights which correspond to the stack indices are in a non-decreasing order.  We'll iterate over the array and we'll push indices into the stack as long as conditions (1) and (2) hold. If we've reached a point where we can't push an index without violating constraint (2) then that means that the height of the current column (column i) is smaller than the column whose index is at the top of the stack. In this case, we'll pop indices and compare rectangle areas (with the maximum area) until we can finally push the current index  into the stack. The rectangle area at each stage (when we pop) will be calculated by multiplying the popped column height - height(popped_index) and the number of columns between him and the current column (the columns we already popped) - current_index - popped_index. Notice that constraint (1) implies that the column heights of columns between the column at the top of the stack and the current column are all greater/equal to the stack's top column height which implies that the area we calculate is indeed of a rectangle which is included in the column graph.  Here is an implementation of this idea (the method maxHistRect()):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is good solution id=15420704. The other one is here. belbesy.wordpress.com/2011/03/11/uva-108-maximum-sum/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static int FindLargestOnes(bool[,] table, int width, int height, out int x, out int y, out int w, out int h)         {             int currentmax = 0;             int[,] maxw = new int[height, width];             int[,] maxh = new int[height, width];             x = y = w = h = 0;             for (int i = 0; i < height; i++)                 for (int j = 0; j < width; j++)                 {                     if (table[i, j])                     {                         if (i == 0 && j == 0)                         {                             maxw[i, j] = maxh[i, j] = 1;                         }                         else if (j == 0)                         {                             maxw[i, j] = 1;                             maxh[i, j] = maxh[i - 1, j] + 1;                         }                         else if (i == 0)                         {                             maxw[i, j] = maxw[i, j - 1] + 1;                             maxh[i, j] = 1;                         }                         else                         {                             maxw[i, j] = maxw[i, j - 1] + 1;                             maxh[i, j] = maxh[i - 1, j] + 1;                             if (maxw[i - 1, j] - maxw[i, j - 1] <= 1)                             {                                 int tmpw = maxw[i - 1, j];                                 int tmph = maxh[i - 1, j] + 1;                                 if (tmpw * tmph > maxw[i, j] * maxh[i, j])                                 {                                     maxw[i, j] = tmpw;                                     maxh[i, j] = tmph;                                 }                             }                             if (maxh[i, j - 1] - maxh[i - 1, j] <= 1)                             {                                 int tmpw = maxw[i, j - 1] + 1;                                 int tmph = maxh[i, j - 1];                                 if (tmpw * tmph > maxw[i, j] * maxh[i, j])                                 {                                     maxw[i, j] = tmpw;                                     maxh[i, j] = tmph;                                 }                             }                         }                         if (maxw[i, j] * maxh[i, j] > currentmax)                         {                             w = maxw[i, j];                             h = maxh[i, j];                             x = j - w + 1;                             y = i - h + 1;                             currentmax = w * h;                         }                     }                 }             return currentmax;         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \n//Given a 2D array of 1 and 0, Find the largest rectangle (may not be square) which is made up of all 1 or 0. \n \nusing namespace std; \n \n#ifdef HISTOGRAM \nint hist[4] = {3,2,6,8}; \nvoid find(int i) \n{ \n     int j = i; \n     int sz =0; \n    \n     while(hist[i] <= hist[j]) \n     { \n        //cout << \"hist[i]\" << hist[i] << \" i \" << i << \"  hist[j]\" << hist[j] << \" j \" << j << endl; \n        sz = sz + hist[i]; \n        if( j == 3 ) \n             break; \n        j++; \n     } \n     cout << i << \"th=\" << sz << endl;  \n} \n \n \nint main(int argc, char *argv[]) \n{ \n     \n    for(int i = 0; i<4 ; i++) \n    { \n      find(i); \n             \n             \n    } \n     \n     \n     \n    system(\"PAUSE\"); \n    return EXIT_SUCCESS; \n} \n \n#endif \n \n \n \nint hist[4][4] =  \n                 { \n                   {0,1,1,1}, \n                   {1,1,1,1}, \n                   {1,0,1,0}, \n                   {1,0,0,0}, \n                  }; \nvoid print(const int& j,const int& i) \n{ \n    int szx = 0; \n    int szy = 0; \n    int y = 0; \n    int x = 0; \n    bool ff = true; \n    while(hist[x + i][y + j] == hist[i][j] && y < 4) \n    { \n \n        while(hist[x + i][y + j ] == hist[i][j] && x < 4) \n        { \n          x++;                  \n        } \n        if (ff) \n         szx = x ; \n        else if(szx > x ) \n        szx = x ; \n         ff = false; \n        szy++; \n        y++; \n        x = 0; \n       // cout << \"--y--\" << endl; \n    } \n     \n       \n      cout << \"i,j = (\" << i << \" , \" << j << \" ) sz = (\" << szx << \" , \"<< szy   << \" )\" << endl;            \n} \n     \n  \n \nint main(int argc, char *argv[]) \n{ \n     \n    for(int i = 0; i < 4 ; i++) \n    { \n      for(int j = 0; j < 4 ; j++)       \n      { \n            print (i,j); \n  \n             \n      } \n       \n    } \n   // cout << hist[1][2]; \n    system(\"PAUSE\"); \n    return EXIT_SUCCESS; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"DP solution provided on StackOverflow.com. Put 1726632 in search there (CC doesn't allow links in the answers). In essence this is an algorithm:  At each scan do this:  If the cell has 0 assign count=0 If the cell has 1 and is an edge cell (bottom or right edge only), assign count=1 For all other cells, check the count of the cell on its right, right-below, and below. Take the min of them and add 1 and assign that to the count. Keep a global max_count variable to keep track of the max count so far."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6366101810184192","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"Design database locks to allow r/w concurrency and data consistency.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Which company please?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A simple reader/writer lock would be as follows:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4655343523069952","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"10","title":"Design a Logging mechanism. Should be thread safe.   Initially i came up with Command Pattern, and write into a File. Was asked how i will synchronize multiple threads writing into Same File? Later he gave hint about Aspect-oriented Programming(AOP). And also he gave a hint of Not always writing into the File, can also be a Mail,etc..","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Write to a file + Most file systems serialize writes to a file. But, we cannot predict the order in which writes end up in a file. So, if you need absolute incoming order to be maintained, then serialize with a lock. This leads to a performance issue due to lock contention.  + We can work around it by using something like mmap() and just protecting the write offset into the file and taking the actual write out of the performance path i.e. the lock will protect only the mmap offset movement. But, if we assume that the number of bytes logged is less, then we do reduce contention by much.  Write to a per-cpu in-mem buffer and transfer to a file offline. + Each cpu can log stuff into its own buffer i.e. no lock contention issues. + But, if you need ordering, you have to add a timestamp to each entry that can be sorted offline. This assumes that post processing of the log entries is an allowed relaxation of rules. + Still, when the in-core buffer is full, contents need to be written to the disk..so, will logging stall at that time? The usual solution for this is to have two buffers: live and frozen. While the frozen buffer is being written to disk, the live one continues to take the logging entries."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how about using already existing infrastructures like log4j in java and windows Trace in .NET"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If it has to be thread safe and provide high performance, then the first thing to do is to decouple the serialization into the file with the rest of the logic, since file I/O is much slower than memory operations.This knowledge inherently yields a dedicated thread for the logger to serialize its FIFO cache of messages, which can be implemented with the command pattern, as mentioned by the poster. Anyway, access to the shared resources has to be protected with some type of OS-specific locks or similar mechanisms. On Windows platforms, you can use the QueueUserAPC, which will shift the locking from the user-space to the OS's kernel, while on Linux platforms, you will eventually come to mutices and the like."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5704767309348864","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"You have a directed graph that is quite generic (has disjoint parts, cycles, etc). Please find the first loop you hit when traversing and print the nodes in the loop. Assume data is an integer.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Assuming it is a finite graph, use dfs traversal using colours. To speed things up you may use multiple threads and colours to detect cycles. If the graph is disjoint search must start from a node of each disjoint part."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use a simple DFS. starting from one of the disjoint parts and using a \"visited\" flag for each node (can be stored in an array, each for a disjoint part) and when a back edge is found, ie when a node which was already visited is found, we have our loop."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Very straightforward"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is just what came in my mind. I have not tested this code. It may contain some errors."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5069387027447808","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"14","title":"You are given an array of n elements. The elements have are n-bit long too.   Now n here represents the number of employees in a company. Element with index 0 is information about employee 0, at index 1 is information of employee 1....  For each element, the bits represent whether that employee works (not same team... just works) with employee at that index.  Ex. element 0 = 0110 => emplyee 0 works with employee 1 and 2 element 1 = 1001 => emplyee 1 works with employee 0 and 3 ...  Put employees in groups in which they work. The transitive property is applicable here i.e. if A works with B and B works with C, ABC will be in one group.  The solution needs to efficient in terms of run time and memory. I hope the above is clear.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Union-Find Set might work. (1)at first everybody himself/herself forms a set. (2)scan every element's bits, if the kth bit of element[i] is 1, which means i work with k, then find k's set and i's set, and merge them if they are not in the same sets. (3)as the average time complexity of find and merge is O(1), the total time complexity is O(N*N), while space complexity is O(N)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"The solution I am providing is the solution to find the connected components using DFS in an UnDirected Graph. Here each employee is considered as a Node and the other employees he/she works with are the adjacentNodes. The code gives correct solution to me. Please try and let me know if it fails on some conditions.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If we use label propogation, then we need O(N^2) for time complexity and also an array with length N to store the label. Any better solution?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would go for a graph solution. Construct a graph and connect all employees who work together  e.g if A works with B and B works with C then the connection is as follows A-B-C. For each node perform search and create its team. Skip nodes which has been already assigned to teams. In this way transitive property will be handled quite well."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Treat the array of bits as a matrix (Use Bit rotation to achieve this). The matrix is a symmetric matrix with diagonal elements being zero.Now traverse the upper half of the matrix using bitwise right rotation and check for values of 1 and put the ones in their group. YOu can either use graphs or labels depeding on your inclination.  Complexity roughly O(N^2)/2. If you use graph with the matrix, it will be even lesser."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My proposal starts with setting the bit of worker in his own bipmap. Ex: worker 0 has bit 0 = 1.  After that, gonna iterate forward doing binary OR with all other workers presented in the bitmap.  As I have to iterate through array changing the bit set, I'm not sure about running complexity.  Follow my code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"As it was mentioned above - it is a simple graph problem. You need to find strongly connected components of the graph. Subsets of vertexes, where each u is reachable from each v, both belongs to the subset. This can be solved yousing double DFS."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the number of groups will be equal to the number of different values of the array. Thus,we can find the number of different groups by counting the number of unique values in the n size array.  we can further reduce the time complexity by searching for unique values in the array only until the number of 1's in the bit values of the unique element(eg if element 1=0010110 then here 3 1's are there)  is less than n."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"algorithm 1     group1 will contain all employee whose bit is 1 in element 0 2 val=value of element 0 3     for next group   2.1 find the first bit which is zero in the val say d  2.2 all employee whose bit is 1 in element d is included in the group  2.3 val=val OR element d(bitwise or) 4 continue step 3 until val=111...(all bits are1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"algorithm  1 group1 will contain all employee whose bit is 1 in element 0  2 val=value of element 0  3 for next group  3.1 find the first bit which is zero in the val say d  3.2 all employee whose bit is 1 in element d is included in the group  3.3 val=val OR element d(bitwise or)  4 continue step 3 until val=111...(all bits are1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Straightforward way: - the matrix is a symmetric, so will check only half of it; - get co-workers of current element and try to merge them with existing groups."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think if property is transitive then the bit arrangement of people working in same group will be same since they are working in same group so a Bin-sort will suffice with running time O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"find all connected/disconnected components using either bfs or dfs"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void DoubleLink(bool[][] T, int N) \n        { \n            for (int i = 0; i < N; i++) \n                for (int j = 0; j < N; j++) \n                    T[j][i] = true; \n        } \n \n        static int[] Grouping(bool[][] T, int N) \n        { \n            int[] groups = new int[N]; \n            int curgroup = 0; \n            Queue nodes = new Queue(); \n            for (int i = 0; i < N; i++) \n            { \n                if (groups[i] == 0) \n                { \n                    groups[i] = ++curgroup; \n                    nodes.Enqueue(i); \n                    while (nodes.Count != 0) \n                    { \n                        int j = nodes.Dequeue(); \n                        for (int k = 0; k < N; k++) \n                        { \n                            if (T[j][k] == true && groups[k] == 0) \n                            { \n                                groups[k] = curgroup; \n                                nodes.Enqueue(k); \n                            } \n                        } \n                    } \n                } \n            } \n            return groups; \n        }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5120588943196160","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"19","title":"Three points are given A(x1, y1), B(x2, y2), C(x3, y3). Write a method returning an array of points (x, y) inside the triangle ABC.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I have used the following algorithm described by - IntwPrep.MS   Way to test a point (p,q) is within a triangle is by checking if the area of the triangle is equal to the sum of the three triangles formed with (p,q).   Now to return points within a triangle  - Get a point (p,q) which is within the triangle  - Use flood-fill to generate next points by using the above mentioned condition"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The points are probably int types, otherwise it would be infinite points. Any constructive opinion?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Way to test a point (p,q) is within a triangle is by checking if the area of the triangle is equal to the sum of the three triangles formed with (p,q).   Now to return points within a triangle - Get a point (p,q) which is within the triangle  - Use flood-fill to generate next points by using the above mentioned condition"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ok i've done the first part, but i don't understand how to add flood fill part in my code. Can you help me?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Triangles {   public static void main(String[] args) {   int[]a={0,0};   int[]b={0,2};   int[]c={3,0};   int[]d={0,2};   System.out.println(getArea(a,b,c));   System.out.println(ptInside(a,b,c,d));  }  static double distance(int[]a,int[]b){   if(a.length>2 || b.length>2){    System.out.println(\"Not a valid coordinate\");    return 0;   }   else{//a0a1x1y1 b0b1x2y2    double dis=Math.sqrt((Math.pow((b[1]-a[1]),2)+Math.pow((b[0]-a[0]),2)));    return dis;   }     }  static double getArea(int[]a,int[]b,int[]c){   double x=distance(a,b);   double y=distance(b,c);   double z=distance(c,a);   double semi=(x+y+z)/2;   double area=Math.sqrt(semi*(semi-x)*(semi-y)*(semi-z));   return area;     }  static boolean ptInside(int[]a,int[]b,int[]c,int[]d){   if(getArea(a,b,c)==getArea(a,b,d)+getArea(b,c,d)+getArea(d,c,a)){    return true;   }   else{    return false;   }  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This seems like a simple problem, and flood-fill etc seems overkill. (assuming we are only dealing with integers, otherwise agree with the BS comments).  Say points are P1, P2 and P3.  Find the leftmost point of the triangle (smallest x coordinate). If there are two, then it is a different case easily dealt with.  Say the sorted x coords are x1 <= x2 <= x3 (and Pi = (xi, yi)  Now for all integers M in x1 to x2, find intersections of x = M with the two sides of the triangle P1P2 and P1P3.  For integers N in range x2 to x3, find the intersections of x = N with the two side P2P3 and P1P3."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This formula for calculating the area, only works for the 1st quadrant of the coordinate system.  Math.abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))/2  You need to shift the coordinates to pull them to the Q1 before applying the formula."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There is a more computational efficient solution to this by using vector operations. Each vector is the 2D point P1=(x1,y1) P2= (x2,y2) P3=(x3,y3). A random point inside the triangle is given by: p=a1*P1+(1-a1)*a2*P2 OR: p=a1*P2+(1-a1)*a2*P3 p=a1*P1+(1-a1)*a2*P3  where a1 and a2 are uniform variates in the interval [0,1]. This will give you a non uniform distribution inside the triangle but will be much faster. There is also a way to generate a uniform distribution by using a quadrilateral composition."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please read completely before calling BS.  In scanline rasterizer, we try to color all pixels that is covered by the triangle given by the coordinates (x1,y1) (x2,y2) and (x3,y3) . Ignoring the z-coordinates.  If we just use the math of the scanline rasterizer then we can get what are the points which are present inside the triangle . which is pretty much the (x,y) we need.   This is my idea."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a different solution in Java."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Suppose we have three points A, B, C such that A - the leftmost point, B - middle point, C - the rightmost point. Also recall that the equation of the line passing through the two points, as follows: (Y - Y1) / (Y2 - Y1) = (X - X1) / (X2 - X1).   Then an algorithm for finding points with integer coordinates what inside the triangle as follows:  1) Find the equation of segments AB, AC, BC  2) Determine which side will be incremented Y coordinate (if B is greater than A, then up, otherwise down)  3) Move from point A to point C on the segment AC  4) For each X will move up (down) from function AB to AC, after to BC. On each point (x, y) check, whether this point is above (below) the points on the function AB and AC  Code on F#:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"let our original triangle be ABC, and Point P. Consider three different triangles,"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"let our original triangle be ABC, and Point P. Consider three different triangles,"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"I call BS on this."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=23891666","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"25","title":"Given array of words, group the anagrams IP:{tar,rat,banana,atr} OP:{[tar,rat,atr],[banana]}","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"map m; \nfor (int i=0; i < strs.size(); i++) \n{ \n    string temp = strs[i]; \n    sort(temp.begin(), temp.end()); \n    m[temp].push_back(strs[i]); \n} \nint k = 0; \nfor (auto it = m.begin(); it != m.end(); it++) \n{ \n       vector& v = it->second; \n       for (int i=0; i < v.size(); i++) \n             strs[k++] = v[i];  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Tries can be used to print all anagrams together. a. Get all the anagrams related to a word under one leaf node. b. Then again traverse the trie and print all anagrams together"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Not sure if this is an efficient way to do it. Just used a HashMap. Please suggest if there are better ways."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Create a node with two values for each word"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"- keep a structure  - the struct contains -     the string - char *str;     the length - length of string - int length;  so, go thru the array one by one  - measure the length of the string  - based on the length start storing the string (node for every string) in the linked list such that the string with the lesser array length always comes as a first node in the list"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about taking the first one and get all the permutations of the string and store all into hashmaps? And then take the next set of elements and search into hashMap. If found then add into the list otherwise neglect."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"C# style:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static string[,] SortAnagrams(string[] inputAnagrams) \n        { \n            Dictionary> container = new Dictionary>(); \n \n            string signature = \"\"; \n            foreach (string word in inputAnagrams)  \n            { \n                signature = String.Concat((String.Copy(word).ToUpper()).OrderBy(c => c)); \n \n                if (container.ContainsKey(signature)) { container[signature].Add(word); } \n                else { container.Add(signature, new List { word }); }      \n            } \n \n            string[,] anagramList = new string[,] { }; \n            int ith = 0, jth = 0; \n \n            foreach (string word in container.Keys) \n            { \n                List anagrams = (container[word]); \n                foreach (string anagram in anagrams) \n                { \n                    anagramList[ith, jth] = anagram; \n                    jth++; \n                } \n                ith++; \n            } \n            return anagramList; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void AnagramGroups(string[] strs) \n        { \n            Hashtable h = new Hashtable(); \n            foreach (string s in strs) \n            { \n                int sum=0; \n                for (int j=0;j"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"One solution to this question using Hash Table. consider each word, sort it and add as key to hash table if not present. The value for the key would be a list of all anagrams with the same key. I wanted to know about the time complexities, To sort the characters in an array, suppose O(n log n) To store in the hash table it would be O(n), a total of O(n*nlogn). Is there a better algorithm? with lesser time complexity?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=23872665","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"Design a parking meter.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"It will be FREE!, but AD supported :-)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=23778670","download_status":"DOWNLOAD_DONE","votes":"-4","answersCount":"4","title":"You have a machine that can create anything. You just have to specify the details, and voila, it will give you the output. Design test cases for such a machine","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Just taking a shot at this one.  Assume we specify details to the extent of our knowledge : 1. Create a void space 2. Create god / show god to me 3. Create Time Machine 4. Take me to another time(past or future) or planet in an instant."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Not possible to design test cases without more information about \"anything\". I could say that I want something good, nice, juicy and sweet. It could mean an apple or a cake.  There has to be a finite set of inputs and outputs for any computer system."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Test Case: The machine shall create Design Test Case for itself!  Details: 1. Each entity created during tests will be terminated during or in the end of tests, so no energy will be wasted and no garbage will accumulate in the end.  2. Tests will use a pre determined amount of energy. No extra energy will be required during the execution of the tests and no extra energy will be returned from the tests. 3. Tests will run in machine's own space-time continuum that will be created in the beginning of the test. The space shall inflate as needed and time will flow as long shall need. 4. Inside the space-time continuum, continuous exchange of energy shall occurs, entities shall evolve from simple to complex forms. 5. One single specie of observers will be created inside in a single place to challenge the creation of the machine. 6. The observers will judge the concept of good over wrong. Equal amounts of good and bad will be generate during the tests. The distribution of good and bad over time/space shall vary; the test case ends when either one win over the entire space (succeed), or the distribution of energy becomes uniform so no change would be possible anymore (fail.)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=23832684","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"6","title":"Problem of concurrent transactions done by two persons of a joint account at two different ATM Machines. How is it managed without introducing any inconsistency in balance of the account holders?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"There are two ways of locking database - Pessimistic and Optimistic.  Pessimistic used:  In the banking application example, an account is locked as soon as it is accessed in a transaction. Attempts to use the account in other transactions while it is locked will either result in the other process being delayed until the account lock is released, or that the process transaction will be rolled back. The lock exists until the transaction has either been committed or rolled back.  If Optimistic is used :  In the banking application example, the amount of an account is saved when the account is first accessed in a transaction. If the transaction changes the account amount, the amount is read from the store again just before the amount is about to be updated. If the amount has changed since the transaction began, the transaction will fail itself, otherwise the new amount is written to persistent.  I have taken this from wiki : Please read complete article from  wiki/Lock_(database)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Critical section."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Generating a key for every  single account. One person will be holding that key unless his transaction is complete. Then key will shift to next user of the same account.  Hope it will be fine"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Suppose two joint account holders try to withdraw some amount at the same time. The withdrawal process should be a critical section. The other person can specify his requirements (about how much to withdraw) and can even click on \"OK\" button to debit, but his machine shouldn't render any money as long as the first person's transaction is not complete and there is still enough money in account to cater second withdrawer's request.  The lock should be obtained as soon as \"OK\" button is clicked."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Most times, when you are worried about corruption due to two processes happening simultaneously, it is common to lock down the thread when the first process begins.In this case, I would design it so that when someone is making a withdrawal or deposit on the account, it would lock down the account (typically using a mutex of some sort) and limit the other user to only being able to view the balance or other things that don't actually change the state of the account. Also, for end user knowledge/experience, I would display a warning stating that this account is in use at another location and therefore, the balance may not be up to date. Once the first person was done, the account would be released so that the other user could then conduct their business"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=23728669","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"4","title":"Two airline companies, Kingfisher and Jet airways want to do a merger. Design a database migration scheme, so that no inconsistencies and redundancy occur. Assume suitable data and brief on the problems you might face.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Extract entities from both systems and determine database tables whose rows are to be merged. (Assume both have the same normal form 3NF for simplicity). Merge columns, and then data and so on. Ensure that the foreign keys etc. are mapped correctly. Example, Table A (a1, a2) and B(b1,b2,b3) are to be merged and column mapping is a1->b1 and a2->b2. The merged table shoud have C(a1b1, a2b2, b3)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"To actually merge and hope for a correct understanding of the data. The solution would be to think of a Federated Databasesystem. The databases exists independently, but are aware of each other and can communicate with each other through an interface.  This will save both company money and time by merging alot of data into a databasesystem.  If we did merge, the problem would be how the datas understand each other at all? This is a typical heterogeneous problem that might occur."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"To actually merge and hope for a correct understanding of the data. The solution would be to think of a Federated Databasesystem. The databases exists independently, but are aware of each other and can communicate with each other through an interface.  This will save both company money and time by merging alot of data into a databasesystem.  If we did merge, the problem would be how the datas understand each other at all? This is a typical heterogeneous problem that might occur."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Huh?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=23511662","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"17","title":"Given notes of different denominations ( 1,2,5,10) , WAP to find in how many ways can you make an amount ??x?? ?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Maximum number of $1 bills you can use n1 = x Maximum number of $2 bills you can use n2 = x/2 Maximum number of $5 bills you can use n5 = x/5 Maximum number of $10 bills you can use n10 = x/10  Create a set A = { n1 times 1, n2 times 2, n5 times 5, n10 times 10 } Now the problem reduces to finding number of subsets of A whose sum is exactly x, which is the subset sum problem solvable by dynamic programming."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Other than dynamic programming this simple approach works too."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a geeksforgeeks solution:-)  .geeksforgeeks.org/dynamic-programming-set-7-coin-change/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args)  {   int[] coins={1,4,6,2,3,5};   int count=0;         for (int i=0;i  {    count=count+Count(9,coins,i,0);   }   System.out.println(count);  }    public static int Count(int Sum,int[] coins,int index,int curSum)  {   int count=0;      if (index>=coins.length)    return 0;      int sumNow=curSum+coins[index];   if (sumNow>Sum)    return 0;   if (sumNow==Sum)    return 1;      for (int i= index+1;i   count+=Count(Sum,coins,i,sumNow);      return count;     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int GetConbimationCount(int n) \n{ \n if(n <= 0) \n  return 0; \n \n int[] baseCount = new int[](10); \n baseCount[0] = 1; \n \n for(int i = 1; i < 10 || i < n; i++) \n { \n  int count1 = i - 1 > 0 ? baseCount[i - 1] : 0; \n  int count2 = i - 2 > 0 ? baseCount[i - 2] + baseCount[2 - 1] : 0; \n  int count5 = i - 5 > 0 ? baseCount[i - 5] + baseCount[5 - 1] : 0; \n  int count10 = i - 10 > 0 ? baseCount[i - 10] + baseCount[10 - 1] : 0; \n \n  baseCount[i - 1] = Max(count1, count2, count5, count10); \n } \n  \n if(x <= 10) \n  return baseCount[x - 1]; \n \n int baseCount2 = baseCount[2 - 1]; \n int baseCount5 = baseCount[5 - 1]; \n int baseCount10 = baseCount[10 - 1]; \n \n or(int i = 11; i <= n; i++) \n { \n  int count1 = baseCount[(i - 1) % 10 - 1]; \n  int count2 = baseCount[(i - 1) % 10 - 2] + baseCount2; \n  int count5 = baseCount[(i - 1) % 10 - 5] + baseCount5; \n  int count10 = baseCount[(i - 1) % 10 - 10] + baseCount10; \n \n  baseCount[(i - 1) % 10] = Max(count1, count2, count5, count10); \n } \n \n return baseCount[(n - 1) % 10]; \n} \n \nint Max(params int[] arr) \n{ \n int max = arr[0]; \n \n for(int i = 1; i < arr.Length; i++) \n { \n  if(arr[i] > max) \n   max = arr[i]; \n } \n \n return max; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"So, here I go. base cases : countWays(1)=1; countWays(2)=2;countWays(3)=2;countWays(4)=3;countWays(5)=3  Calculate Maximum number of 1,2,5,10 bills that can be used in amount x. ONES = x; TWOS = x/2; FIVES = x/5; TENS = x/10; So, number of ways are following. ways = 0; 1. All 1$ bills used. ways+=1; 2. All 2$ bills are used (even amount) or All 2$ and one 1$ bill used (odd amount). ways+=1; 3. (TWOS-1) can be replaced with two 1$ bill. ways+=(TWOS-1) 4. All 5$ bills possible are used and calculate ways of remainder. So, ways+=countWays(n%FIVES). 5. (FIVES-1) bills replaced by 2,2,1$ bills. So, ways+=(FIVES-1)*countWays(n%FIVES) 6. All 10% bills possible are used and calculate ways of remainder. ways+=countWays(n%TENS). 7. (TENS-1) bills replaced by 5,5$ bills. So, ways+=(TENS-1)*ways(n%TENS)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"So, here I go.  base cases : countWays(1)=1; countWays(2)=2;countWays(3)=2;countWays(4)=3;countWays(5)=3   Calculate Maximum number of 1,2,5,10 bills that can be used in amount x.  ONES = x; TWOS = x/2; FIVES = x/5; TENS = x/10;  So, number of ways are following. ways = 0;  1. All 1$ bills used. ways+=1;  2. All 2$ bills are used (even amount) or All 2$ and one 1$ bill used (odd amount). ways+=1;  3. (TWOS-1) can be replaced with two 1$ bill. ways+=(TWOS-1)  4. All 5$ bills possible are used and calculate ways of remainder. So, ways+=countWays(n%FIVES).  5. (FIVES-1) bills replaced by 2,2,1$ bills. So, ways+=(FIVES-1)*countWays(n%FIVES)  6. All 10% bills possible are used and calculate ways of remainder. ways+=countWays(n%TENS).  7. (TENS-1) bills replaced by 5,5$ bills. So, ways+=(TENS-1)*ways(n%TENS)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"count10=count5=count2=count1=0; while(x>10) { x=x-10;count10++; } while(x>5) { x=x-5;count5++; } while(x>2) { x=x-2;count2++; } while(x>1) { x=x-1;count1++; } printf(\"no of 1s=%d\\n no of 5s=%d\\n no of 2s=%d,no of1s=%d\",count10,count5,count2,count1);   is dis code ok ven ders no limit over no of coins?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the code in Java. Tested with basic use cases. Please let me know if there are any bugs in this."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Its super simple..  // if coins can repeated"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-4","title":"X = amount to get denominations \nn = array size \n \nint count(int X, int n) \n{ \n if (X == 0)  \n  return 1; \n if (X < 0) \n  return 0; \n if (n<= 0 && X >= 1) \n  return 0; \n \n return (count(X, n-1) + count(X - a[n-1], n)); \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=23123665","download_status":"DOWNLOAD_DONE","votes":"8","answersCount":"20","title":"Given an array having 16000 unique integers, each lying within the range 1<20000, how do u sort it. U can load only 1000 numbers at a time in memory.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"23","title":"use bit vector to store each integer in single bit. 625 integers are required to store 20000 numbers  int arr[625] = {0};  ex: to store data 2000 arr index = 2000/32 = 62 bit position = 2000%32 = 16  now make bit position 16 of array index 62 arr[62] to 1  using this bit vectors we can store data range from 1 - 20000 in 625 integers..  after storing all data in bit vectors, check all bit positions of arr[0], arr[1]..... arr[625]... if any bit position is set to 1 then store back that data into array  lets arr[10] bit position 15 is set to 1 then this is equivalent to data 10*32+15 = 335"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"If you can use C++ bitset, just use it"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"#include  \n \nint main() \n{ \n int arr[] = {97,75,209,435,430,531,990}; \n int vec[625] = {0}; \n  \n int i; \n int j; \n int n = 1; \n int index = 0, bit_pos = 0; \n for (i = 0; i < sizeof(arr)/sizeof(arr[0]); i++) \n { \n  index = arr[i] / 32; \n  bit_pos = arr[i] % 32; \n   \n  n = n << bit_pos ; \n  vec[index] = vec[index] | n; \n  n = 1; \n } \n index = 0; \n for (i = 0; i < sizeof(vec)/sizeof(vec[0]); i++) \n { \n  for (j = 0; j < 32; j++) \n  { \n   if ( vec[i] & ( 1 << j )) \n   { \n    arr[index++] = i*32 + j; \n   } \n  } \n } \n  \n for (i = 0; i < sizeof(arr)/sizeof(arr[0]); i++) \n  printf (\"%d\\n\", arr[i]); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can use external quicksort. In an external quicksort, instead of heaving a single pivot element used for partitioning the array, we have a group of elements called 'middle group' or 'pivot group'. In a generalized algorithm, we use a Doubly Ended Priority Queue, (DEPQ)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is C# version"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"vector sortUnique(vector&num) \n{ \n        int  n = num.size(); \n         bitset<20000> bs; \n         for (int i=0; i < n; i++) bs[num[i]] = 1; \n         for (int i=0, k =0; i < 20000; i++) \n                         if (bs[i] == 1) num[k++] = i; \n         return num; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=21121664","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"0","title":"The object of this exercise is to fix 3 known issue with the existing code, and add a new feature to the tool.    The known issues to address are:   ???        The current implementation of the tool incorrectly ignores white space (spaces and tabs) between words, which is a bug. Modify the code so that white space differences are correctly detected ???        Tool doesn't report difference if second file is larger than first file ???        For large input files the tool consumes considerable RAM.  Modify tool to address this performance bug   The new feature to implement is:   ???        Add a new command line switch -i and functionality to allow case-insensitive comparison   Running the tool requires you to supply 2 command line arguments ??C these will be the paths to 2 text files that should be compared.  You are responsible for creating this test data.  /* * New Requirement: * - Add a new command line switch -i and functionality to allow case-insensitive comparison. * * Issues to fix: * - The current implementation of the tool incorrectly ignores white space (spaces and tabs) between words, which is a bug. * Modify the code so that all white space differences are correctly detected and reported along with differences in words. * - Tool doesn't report difference if second file is larger than first file. * - For large input files the tool consumes considerable RAM. Modify tool to address this performance bug. * * Please ensure you include all test files that you create for each of your test cases along with your submission. */  namespace CsDiff {  using System;  using System.Collections.Generic;  using System.IO;   class Program {  static void Main(string[] args) {  if (!ProcessArgs(args)) {  return; }   using (FileReader sourceFile = new FileReader(args[0]))  using (FileReader targetFile = new FileReader(args[1])) {  IEnumerator sourceEnum = sourceFile.Words.GetEnumerator();  IEnumerator targetEnum = targetFile.Words.GetEnumerator();  for (int word = 1; sourceEnum.MoveNext() && targetEnum.MoveNext(); word++) {  if (sourceEnum.Current != targetEnum.Current) {  Console.WriteLine(\"Difference at position {0}: '{1}' different to '{2}'\",word,sourceEnum.Current, targetEnum.Current); } } } }  static bool ProcessArgs(string[] args) {  if (args.Length != 2) {  Console.WriteLine(\"Please specify [source] and [target] file paths\");  return false; }  for (int arg = 0; arg <= 1; arg++) {  if (String.IsNullOrEmpty(args[arg]) || !File.Exists(args[arg])) {  Console.WriteLine(\"File '{0}' not found\", args[arg]);  return false; } }  return true; } }  public class FileReader : IDisposable {  string[] words;  public FileReader(string path) {  string fileData = File.ReadAllText(path);  words = fileData.Split(new char[] { ' ', '\\t' }); }  public IEnumerable Words {  get {  return this.words; } }  public void Dispose() { } } }"}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=23039666","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"88","title":"Maximum value Continuous Subsequence: Given array A[n] find continuous subsequence a[i]..a[j] for which sum of elements in the subsequence  is maximum.  Ex: {-2, 11, -4, 13, -5, -2} -->   11 - 4 +13 = 20        {1, -3, 4, -2, -1, 6} -->      4 -2 -1 +6 = 7  Time complexity should O(nlogn)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"Kadane's algorithm - Maximum Subarray Problem"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"search terms: Kadane / max subarray.  It's tricky to get the linear code correct."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"It seems there is a mistake in the question --  {5,6,-4,3} = 0,1; {8,9,-6,0,3,9} = 1, 5 the first example looks correct, but the second one would be 0,5 not 1,5.  Sum(0-5) = 23 Sum(1-5) = 15."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Thanks to Anonymous for pointing out at error in my my original and to S.Abakumoff for pointing out that the original algorithm requires at least one positive number.  This solution addresses both comments:  Kadane's algorithm is the go-to solution for the maximum subarray problem.  It is an iterative solution which runs in O(n) time.  It finds largest subarray at each index i of array A, starting at index zero and iterates through the entire array.  By using the knowledge of the previous largest subarray in combination with the knowledge that a previous subarray's sum can only be increased with a positive number at the next contiguous index, we can find the maximum contiguous subarray of A.  Consider the integer array A of size n where A contains at least one positive number (I'll handle the case where it doesn't at the end).  To do this, we need to track 2 things: the current maximum subarray's sum and the maximum subarray which ends at index i.  We??ll call them  overallMax and maxEndingHere, respectively.  For each index, we set maxEndingHere equal to A[i] + the previous index's maxEndingHere.  If it's not positive, we reset maxEndingHere equal to 0.  Finally, we compare the value of maxEndingHere with overallMax and take the larger of the two numbers for our new overallMax.  Note that in the actual algorithm, we would want to keep track of the current set of indices representing the overallMax.  We would also make sure that array was not empty.  Here is a simple example: {6,-10,12} overallMax =0 maxEndingHere=0  Start  A[0]:  maxEndingHere =Math.max(0, maxEndingHere + A[0]) =Math.max(0, 0 + 6)=6 overallMax=Math.max(overallMax, maxEndingHere)=Math.max(0,6)=6  A[1]: maxEndingHere =Math.max(0, maxEndingHere + A[1]) =Math.max(0,6-10)=0 overallMax=Math.max(overallMax, maxEndingHere)=Math.max(0,6)=6  A[2]: maxEndingHere=Math.max(0, 0 + A[2])=Math.max(0,12)=12 overallMax=Math.max(overallMax, maxEndingHere)=Math.max(6,12)=12 End  In the scenario where there are all negative numbers, I believe we could temporarily make all the numbers positive and use Math.min instead of Math.max to achieve the same result..  Then, at the end, we could return all the numbers to negatives and find the sum of the values given by our negative numbers between the indices of our max subarray."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"public static int[] findMaxSubArray(int[] array, int start, int end) \n { \n \n  if(start == end) \n   return new int[]{start, end, array[start]}; // starIndex, endIndex, and Maxsum \n \n  int mid = (start + end)/2; \n \n  int[] leftMaxSubarray = findMaxSubArray(array, start, mid); \n \n  int[] rightMaxSubarray = findMaxSubArray(array, mid +1, end); \n \n  int[] crossMaxSubarray = findCrossMaxSubArray(array, start, mid, end); \n \n \n  return max(crossMaxSubarray, max(leftMaxSubarray, rightMaxSubarray)); \n \n } \n \n \n public static int[] max(int[] array1, int[] array2) \n { \n  if(array1[2] > array2[2]) \n   return array1; \n  return array2; \n } \n \n public static int[] findCrossMaxSubArray(int[] array, int start, int mid, int end) \n { \n  int maxSum = Integer.MIN_VALUE; \n \n  int sum = 0; \n \n  int leftMaxIndex = mid; \n \n  for(int i = mid; i >= start; i--) \n  { \n   sum = sum + array[i]; \n   if(sum > maxSum) \n   { \n    maxSum = sum; \n    leftMaxIndex = i; \n   } \n  } \n \n  sum = 0; \n  int maxSum2 = Integer.MIN_VALUE; \n \n  int rightMaxIndex = mid; \n  for(int i = mid +1; i <= end; i++) \n  { \n   sum = sum + array[i]; \n   if(sum > maxSum2) \n   { \n    maxSum2 = sum; \n    rightMaxIndex = i; \n   } \n  } \n   \n  return new int[]{leftMaxIndex, rightMaxIndex, maxSum + maxSum2}; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Thought to share the questions that were asked to me in the phone interview. The questions were pretty simple."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #define len 9 int maxs(int a[]) { int maxcurrsum=0; int maxsum=0; int i=0; int start_temp=0; int start=0; int end=0; for(;i{ maxcurrsum=maxcurrsum+a[i];  if(a[i]>maxcurrsum) { maxcurrsum=a[i]; start_temp=i; }  if(maxcurrsum>maxsum) { maxsum=maxcurrsum; start=start_temp; end=i; } } printf(\"%d %d\\n\",start,end); for(i=start;iprintf(\"%d\\n\",a[i]); return maxsum; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Also found in - jasmeetsingh.net/wordpress/?p=36"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Regarding jasmeet's answer: the 4th element in the array should be 4 and not -4 in order to match the wikipedia example"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"As I understand the Kadane's algorithm works only when the input array containing at least one positive number. The question does not tell anything about it..So I would start with clarifying.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Jasmeet`s algo won`t work if we have 4 instead of -4 and say -100 at the end of the array ... it`ll output -2, 1, -3, 4, -1, 2, 1 which is incorrect"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class algo1 {  static int arr[] = new int[]{-2, 1, -3, 4, -1, 2, 1, -5, 4,-100};  public static void main(String args[]) {   int min = Integer.MAX_VALUE;   int max = Integer.MIN_VALUE;   int minPointer = 0;   int maxPointer = 0;   int subArrSum = 0;   for(int i =0;i  {    subArrSum += arr[i];    if(subArrSum   {     minPointer = i;     min = subArrSum;    }    if (subArrSum>max)    {     maxPointer = i;     max = subArrSum;    }        }   minPointer++;  int sum2=0;  int flag=0;   if(minPointer >= maxPointer)   {    min=Integer.MAX_VALUE;     minPointer=0;    for(int i=0;i   { sum2+=arr[i];     if(min>sum2) { min=sum2; minPointer=i;    }    flag=1;   }   }    //System.out.print(minPointer);    if(flag==1)    minPointer++;   //System.out.println(max - min);   for(int i = minPointer; i<=maxPointer;i++)   {    System.out.print(arr[i] + \" \");   }   } }   Tweak in jasmeet`s code .. instead of setting minptr to 0 if min>=max set it by finding the min. element just before the max element ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Python version:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nusing namespace std; \n#include \nint main() \n{ \n          int i,s,*a,t=0,start=0,end=0,max_s=0,end1=0; \n          cout<<\"Enter size of first array\"; \n          cin>>s; \n          cout<<\"Enter elements in first array:\"; \n          a=new int[s]; \n          for(i=0;i>a[i]; \n          for(i=0;imax_s) \n                  { \n                             max_s=t; \n                             end1=i; \n                  } \n          } \n          cout<<\"Max sum is:\"<<<\"\\n\"; \n          cout<<\"start\"<<<\"\\t\"<<\"end\"<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nusing namespace std; \n#include \nint main() \n{ \n          int i,s,*a,t=0,start=0,end=0,max_s=0,end1=0; \n          cout<<\"Enter size of first array\"; \n          cin>>s; \n          cout<<\"Enter elements in first array:\"; \n          a=new int[s]; \n          for(i=0;i>a[i]; \n          for(i=0;imax_s) \n                  { \n                             max_s=t; \n                             end1=i; \n                  } \n          } \n          cout<<\"Max sum is:\"<<<\"\\n\"; \n          cout<<\"start\"<<<\"\\t\"<<\"end\"<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is called Maximum Subarray Problem. If we want O(n) time complexity then we use Kadane's Algorithm."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Cadene's Algo"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Define M(t) such that \nM(0) = 0, and \n \nfor each element in array Arr[t]            \n M(t) = max(0, M(t-1)+Arr[t])                  \n \nfind max element in array M. It will give you the maximum sub-array sum."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I tried with couple of examples and the below code snippet was giving correct result. It is not an elegant snippet though."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class MaxSum \n{ \n \n    public static void main(String a[]) \n    { \n MaxSum ms=new MaxSum(); \n ms.maxSum(); \n    } \n    void maxSum() { \n int[] arr = {25000,25000,900,3,7,188000,2600,120,24,89,123000}; \n \n int leftPtr = 0; \n int leftPtrForMaxVal = 0; \n int rightPtr = arr.length-1; \n int rightPtrForMaxVal = 0; \n \n \n  \n int j=arr.length-1; \n  leftPtrForMaxVal=arr[0]; \n  rightPtrForMaxVal=arr[j]; \n for(int i=0; ileftPtrForMaxVal  && i!=rightPtr ) \n     { \n  leftPtrForMaxVal=arr[i]; \n  leftPtr=i; \n     } \n     if(arr[j]>rightPtrForMaxVal  && j!=leftPtr ) \n     { \n  rightPtrForMaxVal=arr[j]; \n  rightPtr=j; \n     } \n     j--; \n } \n  \n  \n     \n     System.out.println(\"leftPtrValue : \"+leftPtrForMaxVal); \n     System.out.println(\"leftPtr : \"+leftPtr); \n     System.out.println(\"rightRptValue : \"+rightPtrForMaxVal); \n     System.out.println(\"rightPtr : \"+rightPtr); \n \n  \n \n  \n  \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int main() {  int index1=0, index2=0, a;  int array1[12] = {1,2,3,4,5,6,8,7,10,4,1,2};  for(int i=0 ; i < sizeof(array1)/sizeof(int)-1 ; i++)  {   a = index1;   cout<  cout< if(array1[index1]  {    index1 = i+1;    index2 = a;   }   }  system(\"pause\");  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You should find the longest partial sequence that sums to the bigger number"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java version of Kadane / max subarray:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can use dynamic programming here."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simpler and Easier to understand #include int GetLargestSubArray(int* arr, int n){  int iBeginSaved=0, iEndSaved=0; // the start/end positions of the saved sub array  int iBegin=0, iEnd=0; // the start/end positions of the current sub array  int nSumSaved=0, nSum=0; // the sums of whole saved largest and current sub arrays  int i = 0;               // index to loop in the array  if (0 == n){     iEndRet = iBeginRet = -1;   return 0;  }  nSumSaved = nSum = arr[i];  for(i = 1; i < n; i++) {   /* Compute the current largest sum */   if (nSum<=0){    nSum = arr[i];    iBegin = iEnd = i;   }   else{    nSum += arr[i];    iEnd = i;   }   if (nSum > nSumSaved){    nSumSaved = nSum;    iBeginSaved = iBegin;    iEndSaved = iEnd;   }}  printf(\"\\n%d %d\",iBeginSaved,iEndSaved);  return nSumSaved; } int main(){  int a[]={1, -9,4, 15, -9, 0, -6, 6, -12, 2, 3};  int n=sizeof(a)/sizeof(a[0]);  printf(\"%d \",n);  GetSubArray(a,n,0,0); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Generally, we have a left index and a right index indicating the boundaries of the current window. We also have a running sum of the current window. If the running sum goes below zero, then we start a new window from right+1. Update the maxSum accordingly. It works for both negative or positive arrays."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \"stdafx.h\" \n#include  \n#include  \n#include  \nusing namespace std; \n \n \nint _tmain(int argc, _TCHAR* argv[]) \n{ \n int testCase [] = { 8, 9, -6, 0, 3, 9 }; \n queue indexQueue; \n int descendingNum = 0; \n bool ascending = false; \n int ascendingFinalIndex = 0; \n int ascendingBeginIndex = 0; \n for (int i = 0; i < 6; i++) \n { \n  if (testCase[i] < 0) \n  { \n   if (ascending) \n   { \n    ascending = false; \n    ascendingFinalIndex = i - 1; \n    descendingNum = testCase[i]; \n   } \n   else \n   { \n    descendingNum += testCase[i]; \n   } \n  } \n  else \n  { \n   ascendingFinalIndex = i; \n   if (!ascending) \n   { \n    if (descendingNum > 0) \n    { \n     ascending = true; \n     descendingNum = 0; \n     ascendingFinalIndex = i; \n    } \n   } \n  } \n } \n cout << ascendingBeginIndex << \",\" << ascendingFinalIndex; \n system(\"pause\"); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \"stdafx.h\" \n#include  \n#include  \n#include  \nusing namespace std; \n \n \nint _tmain(int argc, _TCHAR* argv[]) \n{ \n int testCase [] = { 8, 9, -6, 0, 3, 9 }; \n queue indexQueue; \n int descendingNum = 0; \n bool ascending = false; \n int ascendingFinalIndex = 0; \n int ascendingBeginIndex = 0; \n for (int i = 0; i < 6; i++) \n { \n  if (testCase[i] < 0) \n  { \n   if (ascending) \n   { \n    ascending = false; \n    ascendingFinalIndex = i - 1; \n    descendingNum = testCase[i]; \n   } \n   else \n   { \n    descendingNum += testCase[i]; \n   } \n  } \n  else \n  { \n   ascendingFinalIndex = i; \n   if (!ascending) \n   { \n    if (descendingNum > 0) \n    { \n     ascending = true; \n     descendingNum = 0; \n     ascendingFinalIndex = i; \n    } \n   } \n  } \n } \n cout << ascendingBeginIndex << \",\" << ascendingFinalIndex; \n system(\"pause\"); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void Main(string[] args)  \n        { \n            int[] arr = { 5, 3, 1, 9, 12 }; \n            // this should return 0, 3 as the indexes that will produce larger sum \n \n            int Lindex = 0, Rindex = 1, sum = 0, maxSum = arr[Lindex] + arr[Rindex]; \n            int tmp = (arr[Lindex] > arr[Rindex]) ? Lindex : Rindex; \n            for (int i = 1; i < arr.Length; i++) \n            { \n                tmp = (arr[Lindex] > arr[Rindex]) ? Lindex : Rindex; \n                sum = arr[tmp] + arr[i]; \n                if (sum > maxSum) \n                { \n                    Lindex = tmp; \n                    Rindex = i; \n                    maxSum = sum; \n                } \n            } \n \n            Console.WriteLine(Lindex + \" , \" + Rindex + \" : \" + maxSum); \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void Largest_Indices(int arr[],int size) \n{ \n int pos=0,pos1=1,i,j; \n i=pos; \n for(j=i+1;j"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void Largest_Indices(int arr[],int size) \n{ \n int pos=0,pos1=1,i,j; \n i=pos; \n for(j=i+1;j"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A = [int(x) for x in raw_input().split()] \n \nmaxsofarstart = 0 \nmaxsofarend = 0 \nmaxsofar = A[0] \nsumsofar_start = 0 \nsumsofar = A[0] \n \nfor i in xrange(1,len(A)): \n    if A[i] > sumsofar: \n        if sumsofar > 0: #include sumsofar \n            sumsofar += A[i] \n        else: #remove sumsofar \n            sumsofar_start = i \n            sumsofar = A[i] \n    else: \n        sumsofar = sumsofar + A[i] \n \n    if sumsofar > maxsofar: \n        maxsofar = sumsofar \n        maxsofarstart = sumsofar_start \n        maxsofarend = i \n \nprint maxsofarstart, maxsofarend"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"check_max(int arr, int i, int j, int *p_sum) {   if( sum(arr,i,j)> *p_sum) *p_sum = sum(arr,i,j);   if(j+1< arr.len()-1)   { check_max(arr,i,j+1, p_sum);   check_max(arr,i+1,j+1,p_sum);  }  if(j>i) check_max(i+1,j,p_sum); return;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class maxSum {   public static void main(String[] args) {   // TODO Auto-generated method stub   //int[] a = {8, -6, 8, -3};   //int[] a = {11, 12, -28, 26};   //int[] a = {8,9,-6,0,3,9};   int[] a = {11, 16,-28, 31, -30, 31};   int maxSumVal = 0;   int sum = 0;   int previous = 0;   int startIndex = 0;   int endIndex = 0;   for (int i = 0; i  {      sum = sum + a[i];    if(sum > 0)    {     if(sum >= previous)     {      previous = sum;      maxSumVal = sum;      endIndex = i;     }             }    else    {     sum = 0;     startIndex = (i+1)%a.length;    }   }   System.out.println(maxSumVal);   System.out.println(startIndex);   System.out.println(endIndex);  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class maxSum {   public static void main(String[] args) {   // TODO Auto-generated method stub   //int[] a = {8, -6, 8, -3};   //int[] a = {11, 12, -28, 26};   //int[] a = {8,9,-6,0,3,9};   int[] a = {11, 16,-28, 31, -30, 31};   int maxSumVal = 0;   int sum = 0;   int previous = 0;   int startIndex = 0;   int endIndex = 0;   for (int i = 0; i  {      sum = sum + a[i];    if(sum > 0)    {     if(sum >= previous)     {      previous = sum;      maxSumVal = sum;      endIndex = i;     }             }    else    {     sum = 0;     startIndex = (i+1)%a.length;    }   }   System.out.println(maxSumVal);   System.out.println(startIndex);   System.out.println(endIndex);  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #define MAX 5 int main(int argv,char**argc) {  int index,index_start,index_end;  int end_index,sum=0,sum1=0;  end_index=MAX-1;  int array[MAX];  std::cout<<\"Enter data\"< for(index=0; index {   std::cin>>array[index];  }  for(index=0; index {   if(index==end_index)   {    index++;    end_index=MAX-1;   }   sum=array[index]+array[end_index];   if(sum1  {    sum1=sum;    index_start=index;    index_end=end_index;   }   end_index--;   std::cout<<\"loop\"< }  std::cout<<<\",\"<<<<\"sum\"<<}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #include #include #include #include #include #include #include #include #define SIZE sizeof(arr)/sizeof(int) #define FEL(i,a,b) for(int i=a;i#define INF 1<<30 using namespace std; int main() {  int arr[]={5,-6,-4,-3,9,-9};  int start = 0,end = 0 ,sum = 0;int reset =0;  for(int  i=0;i<6;i++)  {   sum +=arr[i];   if(sum<0)   {   sum =0;reset =i+1;   }   if(sum - arr[i] < sum)   {    start = reset;    end= i;    sum =sum+arr[i];   }   if(sum ==0)   {    reset =i+1;   }  }  cout<< return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class MaxSum { \n \n  \n public static void main(String[] args) { \n  Integer []input = {3,4,-8,9}; \n  int loc1 = 0, loc2 = 0; \n  int max = input[0];   \n  for(int i=1; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this is a far simple code that what others have suggested."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is it a dynamic programming problem? if a[i]...a[j] is the max subsequence of a[0]...a[n] and a[k]...a[n] is the max subsequence of a[0]...a[n] that ends with a[n] value[n] = a[i] + a[i+1] + ... a[j] start[n] = i last[n] = j value2[n] = a[k] + a[k+1] + ... + a[n] start2[n] = k  value2[n+1] = max(value2[n]+a[n+1], a[n+1]) start2[n+1] = (value2[n]>0)?k,(n+1) value[n+1] = max(value[n], value2[n+1]) start[n+1] = (value[n]>value2[n+1])?start[n], start2[n+1] last[n+1] = (value[n]>value2[n+1])?last[n]??(n+1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class MaxSubArray { \n \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n  int[] data = {13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7}; \n  int[] result = findMaxSubArray(data, 0, data.length-1); \n  System.out.println(result[0] + \" \" + result[1] + \" \" + result[2]); \n } \n  \n public static int[] findMaxCrossing(int[] A, int low, int mid, int high) { \n  int left_sum = -1000; \n  int left_index = 0; \n  int sum = 0; \n  for (int i = mid; i >= 0; i --) { \n   sum += A[i]; \n   if (sum > left_sum) { \n    left_sum = sum; \n    left_index = i; \n   } \n  } \n   \n  int right_sum = -1000; \n  int right_index = 0; \n  sum = 0; \n  for (int i = mid + 1; i < high; i++) { \n   sum += A[i]; \n   if (sum > right_sum) { \n    right_sum = sum; \n    right_index = i; \n   } \n  } \n   \n  int[] result = {left_index, right_index, left_sum + right_sum}; \n  return result; \n } \n \n public static int[] findMaxSubArray(int[] A, int low, int high) { \n  int[] result = new int[3]; \n  int[] resultLeft = new int[3]; \n  int[] resultRight = new int[3]; \n  int[] resultCross = new int[3]; \n  if (high == low) { \n   result[0] = low; \n   result[1] = high; \n   result[2] = A[low]; \n   return result; \n  } else { \n   int mid = (int) Math.floor((low + high)/2); \n   resultLeft = findMaxSubArray(A, low, mid); \n   resultRight = findMaxSubArray(A, mid + 1, high); \n   // (cross-low, cross-high, cross-sum) = findMaxCrossing(A, low, mid, high) \n   resultCross = findMaxCrossing(A, low, mid, high); \n   if (resultLeft[2] >= resultRight[2] && resultLeft[2] >= resultCross[2]) { \n    return resultLeft; \n   } else if (resultRight[2] >= resultLeft[2] && resultRight[2] >= resultCross[2]) { \n    return resultRight; \n   } else { \n    return resultCross; \n   } \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int MaxSubArray(int[] arr){ \n        int maxSum=0; \n        int sum=0; \n        for (int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int MaxSubArray(int[] arr){ \n        int maxSum=0; \n        int sum=0; \n        for (int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Fully working Java code - handles all the cases"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{ int maxi = s =arr[0]; for(int i=1;i s += arr[i];  if(s < arr[i]) s = arr[i];  if(s > maxi) maxi = s; } cout << maxi << endll; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int maxSubSeq(int arr[],int n) \n{ \n    int maxi,s; \n    maxi = s = arr[0]; \n    for(int i=1;i maxi) maxi = s; \n    } \n    return maxi; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is in Java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"The key point is to add the values in the contiguous sub array until it's negative, otherwise keep adding. Here is the O(n) solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"// O(n^2) }}}  int tab[] = {-2, 11, -4, 13, -5, -2};  const int size = sizeof(tab)/sizeof(tab[0]);  int max= -1;  int sum = 0;    for(int k=0;k {   for(int z=k;z  {    sum += tab[z];    if(sum>max && z>k) max = sum;   }   sum = 0;  } }}}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"void maxSum(String[] args) {   int[] arr = {5,2,9,3,7,18,2,12};      int leftPtr = 0;   int leftPtrForMaxVal = 0;   int rightPtr = arr.length-1;   int rightPtrForMaxVal = 0;      while(leftPtr   if(arr[leftPtr]>arr[leftPtrForMaxVal]){     leftPtrForMaxVal = leftPtr;    }    leftPtr++;        if(arr[rightPtr]>arr[rightPtrForMaxVal]){     rightPtrForMaxVal = rightPtr;     }    rightPtr--;   }    System.out.println(\"leftPtr : \"+leftPtrForMaxVal);   System.out.println(\"rightRpt : \"+rightPtrForMaxVal);      System.out.println(\"leftMax : \" +arr[leftPtrForMaxVal]);   System.out.println(\"rightMax : \"+arr[rightPtrForMaxVal]);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"array is a[], int max1=a[0],max2,t1=0,t2=0; for(i=0;i<=max;i+++) { if(max1<=a[i]) max1=a[i]; t1=i; max2=max1; t2=t1; } printf(\"%d,%d\",t1,t2);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"index(int a[]) \n { \n  int p=0,q=1; \n  for(int i=2;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#include  \n \nusing namespace std; \n \nint maxsum(int array[], int nlength) \n{ \n int nfirst; \n int nsecond; \n if(array[0] > array[1]) \n { \n  nfirst = array[0]; \n  nsecond = array[1]; \n } \n else \n { \n  nfirst = array[1]; \n  nsecond = array[0]; \n } \n  \n for(int i=2; i= nfirst) \n  { \n   nsecond = nfirst; \n   nfirst = array[i]; \n  } \n } \n \n return nfirst + nsecond; \n} \n \nint main() \n{ \n int a[6] = {8,9,-6,0,3,9}; \n cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This can be solved by finding the max element in the array and second max in the array and by noting their index simulatneously.Naturally the summation of max and the second max give the max sum!This can be done in just 1 for loop over the array to find the max and second max"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Finding firstLargest and second largest element"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Here is the working solution.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Here is an implementation of Kadane's algorithm. It also handles the case where all numbers are negative."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"#include #include  using namespace std; int find(vector v) {  int l = v.size();  int a[l][l];  for(int i = 0; i < l; i++){   a[i][i] = v[i];  }  for(int i = 0; i < l; i++){   for(int j = i + 1; j < l; j++){    a[i][j] = a[i][j - 1]+v[j];   }  }  int max = 0;  for(int i = 0; i < l; i++){   for(int j = i; j < l; j++){    if(max < a[i][j]){     max = a[i][j];    }   }  }    return max; }  int main() {  vector v;  int n, k;  cin >> n;  for(int i = 0; i < n; i++){   cin >> k;   v.push_back(k);  }   cout << find(v) << endl;  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"#include \n#include \n \nusing namespace std; \nint find(vector v) \n{ \n int l = v.size(); \n int a[l][l]; \n for(int i = 0; i < l; i++){ \n  a[i][i] = v[i]; \n } \n for(int i = 0; i < l; i++){ \n  for(int j = i + 1; j < l; j++){ \n   a[i][j] = a[i][j - 1]+v[j]; \n  } \n } \n int max = 0; \n for(int i = 0; i < l; i++){ \n  for(int j = i; j < l; j++){ \n   if(max < a[i][j]){ \n    max = a[i][j]; \n   } \n  } \n } \n  \n return max; \n} \n \nint main() \n{ \n vector v; \n int n, k; \n cin >> n; \n for(int i = 0; i < n; i++){ \n  cin >> k; \n  v.push_back(k); \n } \n \n cout << find(v) << endl; \n return 0; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=20902675","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"15","title":"Given a N * M matrix, you have to rotate it by 90 degree. I gave him solution with transpose matrix & then reverse each row. He was satisfied but after asked that this required each element to be touched twice. Can you do it like all elements will be touched once only.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"This question is a classic entry-level question at many tech companies, which is why it's included in Gayle's book.   It was one of my favorites when interviewing candidates in the 1990s, but became so popular that I got too many candidates providing a memorized answer, unable to explain the details of what they wrote. This rendered the question almost useless for interview purposes.     It's not very tricky, but many interviewers like to ask it because it requires familiarity with C/C++ rectangular-array syntax and has enough details to enable an interviewer to observe a candidate's attention to detail.  The java solutions are less interesting to the interviewer.  I've observed that many mid-level and senior-level candidates have trouble tracking all the details of this question, so it's not entirely inappropriate for non-entry-level positions."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"public static int[][] rotateMatrix(int[][] matrix) { \n  int[][] result=new int[matrix[0].length][matrix.length]; \n  for(int i=result.length-1;i>=0;i--){ \n   for(int j=0;j<=result[0].length-1;j++){ \n    result[i][result[0].length-1-j]=matrix[j][i]; \n   } \n  } \n  return result;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for(i=N-1; i>=0; i--) {   for(j=0;j<=M-1;j++)   {     B[j][N-1 - i] = A[i][j]      }  }  here A is original array of size N*M here B is another auxillary array to hold data of transpose of size M*N"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"When you transpose the matrix then during transpose also swap the first and last columns thus swapping like: 1 with n-1 2 with n-2 3 with n-3 proceeding like until we reach the middle column"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Given:  Matrix [M x N]   Logic:  -Have 4 variable columnMin, columnMax, rowMin, rowMax  -Initialize variables as  columnMin = 0  rowMin = 0  columnMax = N  rowMax = M   Loop  if(columnMin != columnMax)  {  Print Row from Matrix [rowMin][columnMin] to Matrix [rowMin] [columnMax]  rowMin ++ ;  }  else  {  break;  }   if(rowMin != rowMin)  {  Print Column from Matrix [rowMin][columnMax] to Matrix [rowMax][columnMax]  columnMax - - ;  }  else  {  break;  }   if(columnMin != columnMax)  {  Print Row from Matrix [rowMax][columnMax] to Matrix [rowMax][columnMin]  rowMax - - ;  }  else  {  break;  }   if(rowMin != rowMin)  {  Print Column from Matrix [rowMax][columnMin] to Matrix [rowMin][columnMin]  columnMin ++ ;  }  else  {  break;  }  END LOOP"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void rotate (int array[][], int n, int m) { \n    int newarray[m][n], i, j; \n    for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void rotateRight(int matrix[][SIZE], int length) {       int layer = 0;       for (int layer = 0; layer < length / 2; ++layer) {           int first = layer;          int last = length - 1 - layer;           for (int i = first; i < last; ++i) {               int topline = matrix[first][i];              int rightcol = matrix[i][last];              int bottomline = matrix[last][length - layer - 1 - i];              int leftcol = matrix[length - layer - 1 - i][first];               matrix[first][i] = leftcol;              matrix[i][last] = topline;              matrix[last][length - layer - 1 - i] = rightcol;              matrix[length - layer - 1 - i][first] = bottomline;          }      }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I/P :            1 2    3   4            O/P :             9    5  1 a[n][m]        5 6    7   8            b[m][n]         10  6  2                   9 10 11 12                                11  7  3                                    12  8  4"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"While doing the transpose instead of writing from first column, start writing from last column moving backward to first column"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"main idea: rotate each matrix's edge from outer to inner.  time efficience is O(n^2)."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=22215664","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"15","title":"Two 32-bit integers n and m are given and positions i,j,k,l are given.Write a method to copy the contents of m from position k to l into n from position i to j. (example n=1010000000,m=10101010,i=3,j=5,k=5,l=7..output=10'101'00000)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"let us take m = 3937331622 and n = 3416423919 m binary value is 1110 1010 1010 1110 1110 1001 1010 0110 n  binary value is 1100 1011 1010 0010 0111 1101 1110 1111  i = 9, j = 16..... so we have to pick from the 9th bit to 16th bit of 'n'  ie .....  1100 1011 <1010 0010> 0111 1101 1110 1111......  k = 15, l = 22; And we have to pick from the 15th bit to 22nd bit of 'm'  for replacement ie .....  1110 1010 1010 11<10 1110 10>01 1010 0110   And then we should find the mask for 'n'.... mask is just all bits will be OFF other than 9 to 16th bit... so we will get.... 0000 0000 <1111 1111> 0000 0000 0000 0000  we should find the mask for 'm'.... mask is just all bits will be ON other than 15 to 22nd bit... so we will get.... 1111 1111 1111 11<00 0000 00>11 1111 1111  Now, AND of 'm' and its mask will be 3937141158 ie.... 1110 1010 1010 11<00 0000 00>01 1010 0110 (say \"A\") here note that , the bits which need replacement become OFF.  Now, AND of 'n' and its mask will be 10616832 ie.... 0000 0000 <1010 0010> 0000 0000 0000 0000  (say \"B\") here note that , the bits which going to replace in 'm' are retained as it is from 'n'. And, this value obtained needs to be right shifted so that <1010 0010> will get settle in 'm' perfectly.  the number of times we need to do the right shift will be  k - i... here 15 - 9 will give you 6... so we have to shift \"B\" for 6 times   so that you will get a new \"B\"...... now add(OR) \"A\" , \"B\" to get the solution  Here the solution is 3937307046 ie.... 1110 1010 1010 11<10 1000 10>01 1010 0110  thus the bits are replaced!!! Here is the code...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"You just need 2 lines of code:  unsigned int mask = (((m >> i) ^ (n >> k)) & ( ((1UL <> (k-1))); n = n ^ (mask << k);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It's not clear if i, j, k, l zero- or one-based. For one-based indexing solution is underneath (and extendable for zero-based). It's also assumed that l-k == j-i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int copycontents(int n, int m, int i, int j, int k, int l) \n  { \n      assert(j-i+1 == l-k+1); \n      for (int p = i, q = k; p <= j; p++, q++) { \n               n &= ~(1 << p); // first unset the bit \n               if (m & (1 << q)  //  see ifs it is need to set the bit again \n                           n |= (1 << i); \n      } \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include    int length(int x){  int l = 0;  while (1){   x = x / 2;   l++;   if (x == 0){    return l;   }  } }  int main(){    int i = 3, j = 5, l = 5, k = 7;    int n = (1 << 9) + (1 << 7);  int m = (1 << 1) + (1 << 3) + (1 << 5) + (1 << 7);    int length = length(n);   for (int p = length - j; p <= length - i; p++){   n = n | (1UL << p);  }  m = m << (k - i);  length = length(m);  for (int p = 0; p < length; p++){   if (p < length - k || p > length - l){    m = m | (1UL << p);   }  }  n = n & m;    return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include    int length(int x){  int l = 0;  while (1){   x = x / 2;   l++;   if (x == 0){    return l;   }  } }  int main(){    int i = 3, j = 5, l = 5, k = 7;    int n = (1 << 9) + (1 << 7);  int m = (1 << 1) + (1 << 3) + (1 << 5) + (1 << 7);    int length = length(n);   for (int p = length - j; p <= length - i; p++){   n = n | (1UL << p);  }  m = m << (k - i);  length = length(m);  for (int p = 0; p < length; p++){   if (p < length - k || p > length - l){    m = m | (1UL << p);   }  }  n = n & m;    return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \n \nint length(int x){ \n int l = 0; \n while (1){ \n  x = x / 2; \n  l++; \n  if (x == 0){ \n   return l; \n  } \n } \n} \n \nint main(){ \n  \n int i = 3, j = 5, l = 5, k = 7; \n  \n int n = (1 << 9) + (1 << 7); \n int m = (1 << 1) + (1 << 3) + (1 << 5) + (1 << 7); \n  \n int length = length(n); \n \n for (int p = length - j; p <= length - i; p++){ \n  n = n | (1UL << p); \n } \n m = m << (k - i); \n length = length(m); \n for (int p = 0; p < length; p++){ \n  if (p < length - k || p > length - l){ \n   m = m | (1UL << p); \n  } \n } \n n = n & m; \n  \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bitwise operations are a good idea, and it should be the fastest. but if you are allowed to use C++ bitset, it's easier (though a little bit slower, and maybe not allowed in an interview :-)  NOTE: In the following solutions, I have changed the index counting from right to left, starting from 0."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=20688669","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"10","title":"if we open a new tab in a browser,is it a new process or thread?and what if we open a new window of the browser?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"11","title":"Depends on the browser. On Chrome, its a new process whenever you open a tab. On Firefox it is thread. Windows IE a new process is opened."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"there is very healthy discussion on this on stackoverflow. Firefox is in process of implementing the process per tab method like chrome  stackoverflow.com/questions/4263124/which-is-better-choice-for-browsers-tab-multi-thread-or-multi-process"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"i just figured out we can check that by ourselves using task manager. go to the Details tab of a task manager, now open your browser, you can see new task(Process) for that browser. Open a new tab in that browser and observe the task manager, if you see another process getting created, then that means every tab is creating its own process, and if u just see only one instance of the process even after opening a new tab then i is thread. correct me if i am wrong"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=21117662","download_status":"DOWNLOAD_DONE","votes":"4","answersCount":"51","title":"Imagine an alphabet of words. Example: a ==> 1 b ==> 2 c ==> 3 . z ==> 26 ab ==> 27 ac ==> 28 . az ==> 51 bc ==> 52 and so on.  Such that the sequence of characters need to be in ascending order only (ab is valid but ba is not). Given any word print its index if valid and 0 if not.  Input Output ab  27 ba  0 aez  441  Note: Brute-force is not allowed.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"ideone.com/tJRIsZ"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"The total words is 2^26 -1. For a given word, the word with small size occur first.  Let n be the length of the word,  Total number of words with size less than n is C(26, 1) + C(26, 2) + ...+ C(26, n -1) Then calculate how many words with the same size prior to the given word the sum of two numbers plusing one is the index  sites.google.com/site/spaceofjameschen/annnocements/printtheindexofawordwithlettersinascendingorder--microsoft"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"For calculation of aez:  Get yz value . It is equal to  26 + 25 + .... + 1 = 351  abc = yz + 1 = 352 acd = abc + 23 + 1 = 376 ade = acd + 22 + 1 = 399 aef = ade + 21 + 1 = 421  Finally aez = aef + 20 = 421 + 20 = 441"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public class SeqTONum { \n  \n private final static int ALPHABETNUM = 26; \n \n public static int GetSequenceNum(int numberOfChars, String input) \n { \n  char[] arrInput = input.toUpperCase().toCharArray();     \n \n  /* \n   * Test some illegal situations \n   * Return 0 if illegal \n   */ \n  if (numberOfChars <=0 || numberOfChars > 26) \n    return 0; \n  if (arrInput.length > numberOfChars) \n  { \n   return 0; \n  } \n  if (arrInput.length > 1){ \n   for (int i = 0; i < arrInput.length-2; i++){ \n    if(arrInput[i]>=arrInput[i+1]) \n     return 0; \n   } \n  } \n   \n  /* \n   * Seq to Num \n   */ \n  int num = 0; \n  if( arrInput.length == 1){ \n   num +=(int)arrInput[0] - ((int) 'A') + 1; \n   return num; \n  } \n   \n  for(int i = 0; i < arrInput.length -1 ; i++){ \n   num += comNum(ALPHABETNUM, i + 1); \n  } \n   \n  for(int i = 0; i < arrInput.length; i++) { \n   if(i==0){ \n    for(char first = 'A'; first < arrInput[0]; first = (char)(first + 1)){ \n     int bit = arrInput.length - 1; \n     int left = 'Z' - first; \n     num += comNum(left, bit); \n    } \n   } else if(i == arrInput.length-1){ \n    num += (arrInput[i]-arrInput[i-1]); \n   } else{ \n    for(char cur = (char)(arrInput[i-1] + 1); cur < arrInput[i]; cur = (char)(cur + 1)){ \n     int bit = arrInput.length - i - 1;  \n     int left = 'Z' - cur; \n     num += comNum(left, bit); \n    } \n   } \n  }  \n  return num;   \n } \n  \n  \n public static int comNum(int num, int top){ \n     if(top == 0) \n      return 0; \n  int value = 0; \n  int tmp1 = 1, tmp2 = 1; \n  for(int i = 0 ; i < top; i++){ \n   tmp1 *= (num-i); \n   tmp2 *= (top-i); \n  } \n  value = tmp1/tmp2; \n  return value; \n } \n  \n public static void main(String[] args){ \n  System.out.println(GetSequenceNum(5, \"vwxyz\")); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what do think will be the brute force algorithm for this ???"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"\"aez\" is calculated as this:  26+(25+24+23+22+21+20+19+18+17+16+14+13+12+11+10+9+8+7+6+5+4+3+2+1+0+0) +25+24+23+22+21 modified form below: 26+25(24)/2 +25+24+23+22+21  26 + n*(n-1)/2+sum of arithmetic progression of 5(e) numbers starting from (26-e) 21  26+sum of arithmetic progression till 25 + sum of arithmetic progression of 5(e) numbers starting from (26-e) 21  I don't know if it will work for all numbers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i think it should be 26+26*(25)/2 +24+23+22+21"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Lets start with reducing our problem space.  suppose there are only 5 alphabets in question here a,b,c,d,e so it would be like a=1 b=2 c=3 d=4 e=5 ab = 6 ac = 7 ad = 8 ae = 9.....  to find 'cde' we will do = c*5^2 + d*5^1+c - invalid combinations.(aa,ba,bb,...) etc  finding invalid combinations -  of length 2 starting with  a=1(aa) b=2(ba,bb) c= 3(ca,cb,cc) d=4(da,db,dc,dd) e =5(ea,eb,ec,ed) ----------- length 3 a = (a-a+1)*5^(length-2)+#(b-e) invalid of length 2  b= (b-a +1)*5^(length-2)+(c-e) invalid of length  2  and so on ----------------- length 4 a = (a-a+1)*5^(length-2)+#(b-e) in valid of length 2 ---------------------------  We also need to find invalid combinations selectively like in case of cde. we need to subtract total #invalid combinations of length 2 but we need to be selective in case of  length 3. We will subtract only those invalids which start with a*, b*,ca*,cb*,cc*,cda, cdb,cdc,cdd"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Shouldn't the \"return isValid\" be outside the \"for\" loop?!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The idea is to change the string into base-26 system. The pseudo code as follows:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class SeqTONum { \n  \n private final static int ALPHABETNUM = 26; \n \n public static int GetSequenceNum(int numberOfChars, String input) \n { \n  char[] arrInput = input.toUpperCase().toCharArray();     \n \n  /* \n   * Test some illegal situations \n   * Return 0 if illegal \n   */ \n  if (numberOfChars <=0 || numberOfChars > 26) \n    return 0; \n  if (arrInput.length > numberOfChars) \n  { \n   return 0; \n  } \n  if (arrInput.length > 1){ \n   for (int i = 0; i < arrInput.length-2; i++){ \n    if(arrInput[i]>=arrInput[i+1]) \n     return 0; \n   } \n  } \n   \n  /* \n   * Seq to Num \n   */ \n  int num = 0; \n  if( arrInput.length == 1){ \n   num +=(int)arrInput[0] - ((int) 'A') + 1; \n   return num; \n  } \n   \n  for(int i = 0; i < arrInput.length -1 ; i++){ \n   num += comNum(ALPHABETNUM, i + 1); \n  } \n   \n  for(int i = 0; i < arrInput.length; i++) { \n   if(i==0){ \n    for(char first = 'A'; first < arrInput[0]; first = (char)(first + 1)){ \n     int bit = arrInput.length - 1; \n     int left = 'Z' - first; \n     num += comNum(left, bit); \n    } \n   } else if(i == arrInput.length-1){ \n    num += (arrInput[i]-arrInput[i-1]); \n   } else{ \n    for(char cur = (char)(arrInput[i-1] + 1); cur < arrInput[i]; cur = (char)(cur + 1)){ \n     int bit = arrInput.length - i - 1;  \n     int left = 'Z' - cur; \n     num += comNum(left, bit); \n    } \n   } \n  }  \n  return num;   \n } \n  \n  \n public static int comNum(int num, int top){ \n     if(top == 0) \n      return 0; \n  int value = 0; \n  int tmp1 = 1, tmp2 = 1; \n  for(int i = 0 ; i < top; i++){ \n   tmp1 *= (num-i); \n   tmp2 *= (top-i); \n  } \n  value = tmp1/tmp2; \n  return value; \n } \n  \n public static void main(String[] args){ \n  System.out.println(GetSequenceNum(5, \"vwxyz\")); \n } \n  \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class SeqTONum { \n  \n private final static int ALPHABETNUM = 26; \n \n public static int GetSequenceNum(int numberOfChars, String input) \n { \n  char[] arrInput = input.toUpperCase().toCharArray();     \n \n  /* \n   * Test some illegal situations \n   * Return 0 if illegal \n   */ \n  if (numberOfChars <=0 || numberOfChars > 26) \n    return 0; \n  if (arrInput.length > numberOfChars) \n  { \n   return 0; \n  } \n  if (arrInput.length > 1){ \n   for (int i = 0; i < arrInput.length-2; i++){ \n    if(arrInput[i]>=arrInput[i+1]) \n     return 0; \n   } \n  } \n   \n  /* \n   * Seq to Num \n   */ \n  int num = 0; \n  if( arrInput.length == 1){ \n   num +=(int)arrInput[0] - ((int) 'A') + 1; \n   return num; \n  } \n   \n  for(int i = 0; i < arrInput.length -1 ; i++){ \n   num += comNum(ALPHABETNUM, i + 1); \n  } \n   \n  for(int i = 0; i < arrInput.length; i++) { \n   if(i==0){ \n    for(char first = 'A'; first < arrInput[0]; first = (char)(first + 1)){ \n     int bit = arrInput.length - 1; \n     int left = 'Z' - first; \n     num += comNum(left, bit); \n    } \n   } else if(i == arrInput.length-1){ \n    num += (arrInput[i]-arrInput[i-1]); \n   } else{ \n    for(char cur = (char)(arrInput[i-1] + 1); cur < arrInput[i]; cur = (char)(cur + 1)){ \n     int bit = arrInput.length - i - 1;  \n     int left = 'Z' - cur; \n     num += comNum(left, bit); \n    } \n   } \n  }  \n  return num;   \n } \n  \n  \n public static int comNum(int num, int top){ \n     if(top == 0) \n      return 0; \n  int value = 0; \n  int tmp1 = 1, tmp2 = 1; \n  for(int i = 0 ; i < top; i++){ \n   tmp1 *= (num-i); \n   tmp2 *= (top-i); \n  } \n  value = tmp1/tmp2; \n  return value; \n } \n  \n public static void main(String[] args){ \n  System.out.println(GetSequenceNum(5, \"vwxyz\")); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"not sure this is optimized code. but written based on getting number and subtracting invalid strings from that."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ideone.com/hT22xi"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n#include \n#include \nusing namespace std; \nint cal1(char a[]); \nint cal2(char a[]); \nint cal3(char a[]); \nint cal(char a); \nint miss2(); \nint miss3(); \n \nint main() \n{ \n char *c; \n int size,ch; \n do \n { \n  cout<<\"Input size \"; \n  cin>>size; \n  c = new char[size]; \n  cout<<\"INPUT: \"; \n  cin>>c; \n  for(int i=0; ic[i+1]) \n   { \n    cout<<\"INVALID INPUT\\n\"; \n    break; \n   } \n  } \n   int val=0; \n   if(size==1) \n   val = cal1(c); \n   else if(size==2) \n   val = cal2(c); \n   else if(size==3) \n   val = cal3(c); \n   cout<>ch; \n } \n while(ch==1); \n getch(); \n return 0; \n} \nint cal1(char a[]) \n{ \n return int(a[0])-96; \n} \nint cal2(char a[]) \n{ \n int x=0; \n for(int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n#include \n#include \nusing namespace std; \nint cal1(char a[]); \nint cal2(char a[]); \nint cal3(char a[]); \nint cal(char a); \nint miss2(); \nint miss3(); \n \nint main() \n{ \n char *c; \n int size,ch; \n do \n { \n  cout<<\"Input size \"; \n  cin>>size; \n  c = new char[size]; \n  cout<<\"INPUT: \"; \n  cin>>c; \n  for(int i=0; ic[i+1]) \n   { \n    cout<<\"INVALID INPUT\\n\"; \n    break; \n   } \n  } \n   int val=0; \n   if(size==1) \n   val = cal1(c); \n   else if(size==2) \n   val = cal2(c); \n   else if(size==3) \n   val = cal3(c); \n   cout<>ch; \n } \n while(ch==1); \n getch(); \n return 0; \n} \nint cal1(char a[]) \n{ \n return int(a[0])-96; \n} \nint cal2(char a[]) \n{ \n int x=0; \n for(int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nusing namespace std; \nchar st[100]; \nint func(char *st); \nint main() \n{ \n    int i,in,j; \n    cout<<\"\\nenter string\\n\"; \n    cin>>st; \n    cout<<\"\\n\"<st[i+1]) \n    return 0; \n    l--; \n    char t,t1,*st1; \n    t=st[l]; \n    while(true){ \n    if(l>0 && t-1!=st[l-1]){ \n \n    st[l]=--t; \n    in=len-1; \n      t1='z'; \n      while(in>l){ \n      st[in]=t1; \n      t1--; \n      in--; \n      } \n      //cout<<\"\\nc1\"<<<\"\\n\"; \n    break; \n    } \n    else \n    if( l>0&& t-1==st[l-1]) \n    { \n \n        l--; \n        t=st[l]; \n        //cout<<\"\\nc2\"<<<\"\\n\"; \n    } \n    if(l==0&& st[l]=='a') \n    { \n \n      in=len-2; \n      t1='z'; \n      while(in>=0){ \n      st[in]=t1; \n      t1--; \n      in--; \n      } \n      st[len-1]='\\0'; \n      //cout<l){ \n      st[in]=t1; \n      t1--; \n      in--; \n      } \n \n      //cout<<\"\\nc4\"<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nusing namespace std; \nchar st[100]; \nint func(char *st); \nint main() \n{ \n    int i,in,j; \n    cout<<\"\\nenter string\\n\"; \n    cin>>st; \n    cout<<\"\\n\"<st[i+1]) \n    return 0; \n    l--; \n    char t,t1,*st1; \n    t=st[l]; \n    while(true){ \n    if(l>0 && t-1!=st[l-1]){ \n \n    st[l]=--t; \n    in=len-1; \n      t1='z'; \n      while(in>l){ \n      st[in]=t1; \n      t1--; \n      in--; \n      } \n      //cout<<\"\\nc1\"<<<\"\\n\"; \n    break; \n    } \n    else \n    if( l>0&& t-1==st[l-1]) \n    { \n \n        l--; \n        t=st[l]; \n        //cout<<\"\\nc2\"<<<\"\\n\"; \n    } \n    if(l==0&& st[l]=='a') \n    { \n \n      in=len-2; \n      t1='z'; \n      while(in>=0){ \n      st[in]=t1; \n      t1--; \n      in--; \n      } \n      st[len-1]='\\0'; \n      //cout<l){ \n      st[in]=t1; \n      t1--; \n      in--; \n      } \n \n      //cout<<\"\\nc4\"<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public class _26BaseToDecimal \n    { \n \n        char[] alpha = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' }; \n \n        public void lettersToDecimal(string input, int baseN=26) \n        { \n            \n \n            int decimalN = 0; \n \n            for (int i = 0; i < input.Length; i++) \n            { \n                // aasci value for 'a' is 97 so, a-a + 1=97-97 + 1= 1 , So a=>1, b-a+1=98-97+1=2, so b=>2 (mapping) \n                decimalN = decimalN * baseN + int.Parse((input[i] - 'a' + 1).ToString()); \n            } \n \n            Console.WriteLine(\"For alphabate {0} decimal is {1}\", input, decimalN); \n        } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public int GetSequenceNo(int numberOfChars, string input) \n{ \n var arrInput = input.ToUpper().ToCharArray(); \n bool isValid = true; \n \n if (numberOfChars <=0 || numberOfChars > 26) \n   return 0; \n \n //Only allow alphabets, therefore max length of valid input is 26 \n if (arrInput.Length > numberOfChars) \n { \n  return 0; \n } \n \n if (arrInput.Length == 1) \n  return (int)arrInput[0] - ((int) 'A'); \n  \n for(int i=0;i(int)arrInput[i+1]) \n  { \n   isValid=false; \n   break; \n  }  \n } \n \n if (!isValid) \n  return 0; \n \n int[] arrValue = new int[arrInput.Length+1]; \n for (int i=0; i < arrInput.Length; i++) \n { \n  arrValue[i] = (int)arrInput[i] - ((int) 'A'); \n } \n arrValue[0] = 0; \n \n long seq = 0; \n int size = arrInput.Length; \n bool substracted = false; \n int i = 0; \n \n while (arrValue[size-1] > 0) \n { \n  seq += (int)arrValue[size-1] - (int)arrValue[size-2]; \n \n  if (arrValue[size-2] > 0)  \n  {    \n   arrValue[size-1] = numberOfChars; \n \n   substracted = false; \n   i = size - 2; \n        \n   do \n   { \n    arrValue[i] -= 1; \n     \n    if(arrValue[i-1] > 0) \n    { \n     if (arrValue[i-1] == arrValue[i]) \n     { \n      arrValue[i] = numberOfChars - 3 + i + 1; \n       i-=1 \n     } \n     else \n     { \n      substracted = true; \n     } \n    } \n    else \n    { \n     substracted = true; \n    }  \n   } while (!substracted)   \n  } \n  else \n  { \n   arrValue[size-1] = 0; \n  } \n } \n \n return seq; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public int GetSequenceNo(int numberOfChars, string input) \n{ \n var arrInput = input.ToUpper().ToCharArray(); \n bool isValid = true; \n \n if (numberOfChars <=0 || numberOfChars > 26) \n   return 0; \n \n //Only allow alphabets, therefore max length of valid input is 26 \n if (arrInput.Length > numberOfChars) \n { \n  return 0; \n } \n \n if (arrInput.Length == 1) \n  return (int)arrInput[0] - ((int) 'A'); \n  \n for(int i=0;i(int)arrInput[i+1]) \n  { \n   isValid=false; \n   break; \n  }  \n } \n \n if (!isValid) \n  return 0; \n \n int[] arrValue = new int[arrInput.Length+1]; \n for (int i=0; i < arrInput.Length; i++) \n { \n  arrValue[i+1] = (int)arrInput[i] - ((int) 'A'); \n } \n arrValue[0] = 0; \n \n long seq = 0; \n int size = arrInput.Length; \n bool substracted = false; \n int i = 0; \n \n while (arrValue[size] > 0) \n { \n  seq += (int)arrValue[size] - (int)arrValue[size-1]; \n \n  if (arrValue[size-1] > 0)  \n  {    \n   arrValue[size] = numberOfChars; \n \n   substracted = false; \n   i = size - 1; \n        \n   do \n   { \n    arrValue[i] -= 1; \n     \n    if(arrValue[i-1] > 0) \n    { \n     if (arrValue[i-1] == arrValue[i]) \n     { \n      arrValue[i] = numberOfChars - size + i + 1; \n       i-=1 \n     } \n     else \n     { \n      substracted = true; \n     } \n    } \n    else \n    { \n     substracted = true; \n    }  \n   } while (!substracted)   \n  } \n  else \n  { \n   arrValue[size] = 0; \n  } \n } \n \n return seq; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-4","title":"According to the problem since any sequence of letters in increasing order is valid, you can easily convert the string to character array and check whether each subsequent letter has an ASCII value greater than the previous one.  Pseudocode:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=21092663","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"11","title":"Input: Consider a file containing a list of 100,000 license plate numbers which follow the format ABC-123 and could be any value ranging from AAA-001 to ZZZ-999.  This data is expected to be read-in and stored in memory based on following requirements:  ? The list can be reconstructed using the stored data. Original sequence does not need to be maintained.  ? Perform searches efficiently on the stored data using the first 3 characters of the number as given below :  ? List all licenses starting with ??MMM??  ? Count the total number license numbers starting with ABC","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"As a first thought, I would create a trie of some special type. The terminal nodes of the trie are the nodes with alpha keys (thus making it at most 3 nodes high - \"ABC\"), each containing a set of numbers ranging from 000-999."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Store the data in the following structure:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"For starter, convert each letter to a number between 0-25. Then you can create a 3-dimensional array \"LinkedList license[][][]\", where license[i][j][k] is a list of the 3-digit suffixes for license that starts with ('A'+i)('A'+j)('A'+k). This should support the search quite efficiently and allow you reconstruct all stored data.  Downside is that it takes extra storage because many of the elements might be empty, and so it also takes longer to reconstruct the whole list than needed. An alternative would be to use a multi-level HashMap instead, but the implementation would be slightly more cumbersome."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Maintain a Hash table with \"key\" as the first 3 characters and the value being a \"list\" of the last three numbers of all the license plates with the same starting \"key\". It should be straight forward to get the \"List all licenses starting with ??MMM?? \".  Also mantain a Binary Search Tree where the node value is the \"key\" above and the \"value\" is the count of the license plate numbers with that key. Getting the \"Count the total number license numbers starting with ABC\" can be accomplished by searching for key \"ABC\" and doing inorder traversal from that node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The following structure was defined:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would store it in one long bitmask. AAA-ZZZ range gives us 17576 permutations, 000-999 range in each, divided by 8 (1 bit per plate) is ~2 Mb file.  It's pretty trivial to calculate offsets and make queries in such a file."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"build an array of arrays for eg in php  $array['abc']=array('123'=>'somevalue'); to find this value $array['abc']['123'] to find all vaues in mmm $array['mmm']"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=20658674","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"5","title":"Implement T9 dictionary for mobile phone","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Dictionary using trie - each node as number bit, so there will be a node 2 representing \"abc\", Hence tree till have 9 nodes as root and so on."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"construct dictionary using trie with augmentation. Instead of char key's, use numbers corresponding to combination for chars."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"include std"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"i think the best answer would be using hash tables.. as you all know hash uses 0(1) as the complexity.Storing the known words in hash table and when the user wants to add a user defined words to dictionary we can just add it to the hash.this way its simpler and faster implementation of t9 dictionary."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=20532664","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"22","title":"Given an mxn matrix, design a function that will print out the contents of the matrix in spiral format.  Spiral format means for a 5x5 matrix given below:","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"public static void printMat(int [][]mat) \n { \n  if(mat == null  || mat.length == 0) \n   return; \n \n  int offset = 1; \n  int row = 0, col = 0; \n  while(row != mat.length / 2 && col != mat[0].length / 2) { \n    \n   while(col < mat[0].length - offset) \n    System.out.print(mat[row][col++]+\"  \"); \n \n   while(row < mat.length - offset) \n    System.out.print(mat[row++][col]+\"  \"); \n \n   while(col >= 0 + offset) \n    System.out.print(mat[row][col--]+\"  \"); \n \n   while(row >= 0 + offset) \n    System.out.print(mat[row--][col]+\"  \"); \n \n   offset++; \n   row++; \n   col++; \n  } \n   \n  System.out.print(mat[row][col]); \n \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This is for general matrix i.e. it would work for any  (n x m) matrix"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"#include \n#include \n \nusing namespace std; \n \nint main() \n{ \nint a[6][6]={1,2,3,4,5,6,20,21,22,23,24,7,19,32,33,34,25,8,18,31,36,35,26,9,17,30,29,28,27,10,16,15,14,13,12,11}; \n//6X6 matrix initialized from 1-36 so it prints in asending order \nint i=0,j=0,left=0,right=5; //we use left and right to traverse through the matrix \nint m=6,n=6; //6X6 mXn \ncout<<\"\\n values of the matrix :\\n\"; \nfor(i=0;ileft; j--) \n                       cout<<'\\t'<left;i--) \n                       cout<<'\\t'<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Check out the C solution at w w w.geeksforgeeks.org/print-a-given-matrix-in-spiral-form/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Given: Matrix [M x N]  Logic: -Have 4 variable columnMin, columnMax, rowMin, rowMax -Initialize variables as    columnMin = 0    rowMin = 0    columnMax = N    rowMax = M  Loop  if(columnMin != columnMax)  {   Print Row from Matrix [rowMin][columnMin] to Matrix [rowMin] [columnMax]   rowMin ++ ;  }  else   {   break;  }   if(rowMin != rowMin)  {   Print Column from Matrix [rowMin][columnMax] to Matrix [rowMax][columnMax]   columnMax - - ;  }  else   {   break;  }   if(columnMin != columnMax)  {   Print Row from Matrix [rowMax][columnMax] to Matrix [rowMax][columnMin]  rowMax - - ;  }  else   {   break;  }   if(rowMin != rowMin)  {   Print Column from Matrix [rowMax][columnMin] to Matrix [rowMin][columnMin]   columnMin ++ ;  }  else   {   break;  }  END LOOP"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void print_matrix(std::vector > matrix) \n{  \n    if(matrix.size()) \n    { \n        int m = matrix.size();//number of rows \n        int n = matrix[0].size();//number of columns \n        int layers_number = std::min((m + 1) / 2, (n + 1) / 2); \n        for(int layer = 0; layer < layers_number; ++layer) \n        { \n            //print top of the layer \n            for(int i = layer; i < n - layer; ++i) \n                std::cout << matrix[layer][i] << \" \"; \n \n            //print right part of the layer \n            for(int i = layer + 1; i < m - layer; ++i) \n                std::cout << matrix[i][n - 1 - layer] << \" \"; \n \n            //print bottom of the layer \n            if(layer < m / 2) \n            { \n                for(int i = n - 2 - layer; i >= layer; --i) \n                    std::cout << matrix[m - 1 - layer][i] << \" \"; \n            } \n \n            //print left part of the layer \n            if(layer < n / 2) \n            { \n                for(int i = m - 2 - layer; i > layer; --i) \n                    std::cout << matrix[i][layer] << \" \"; \n            } \n        } \n    }     \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Following is my efforts to solve the problem. The solution is written in java."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void spiralMatrix(int** array, int startRow, int startCol, int nrows, int ncols) \n{ \n if (nrows <=0  || ncols <= 0 ) \n  return; \n   int i = 0; \n   for (i = startCol ; i < ncols; i++) \n   { \n    printf(\"%d \", array[startCol][i]); \n   } \n   for (i = startRow + 1; i < nrows; i++) \n   { \n   printf(\"%d \", array[i][ncols-1]); \n   } \n   for (i = ncols - 2; i >= startCol;i--) \n   { \n    printf(\"%d \", array[nrows-1][i]); \n   } \n   for (i = nrows-2; i >= startRow + 1; i--) \n   { \n    printf(\"%d \", array[i][startCol]); \n   } \n   spiralMatrix(array, startRow + 1, startCol + 1, nrows-1, ncols-1); \n \n} \n \n \nint main(void) \n{ \n   int i,nrows,ncols,j; \n \n   printf(\"Enter number of rows and number of columns \"); \n   scanf(\"%d %d\",&nrows,&ncols); \n \n   int** array; \n   array=(int**)malloc(nrows*sizeof(int*)); \n   for (i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int a[4][5] = { \n                        {1,  2,  3,  4, 5}, \n                        {14,  15,  16,  17, 6}, \n                        {13,  20,  19,  18, 7}, \n                        {12,  11,  10,  9, 8}, \n                        }; \n \nvoid print_spiral (int r, int c) \n{ \n        int i = 0; \n        int j = -1; \n        int right_max = c; \n        int down_max = r; \n \n        int left_min = -1; \n        int up_min = 0; \n \n        int total_count = r * c; \n \n        while (total_count > 0) \n        { \n                i = up_min; \n                j++; \n                while (j < right_max && total_count > 0) \n                { \n                        printf (\"%d \\n\", a[i][j]); \n                        j++; \n                        total_count--; \n                } \n                right_max--; \n \n                j = right_max; \n                i++; \n                while (i < down_max && total_count > 0) \n                { \n                        printf (\"%d \\n\", a[i][j]); \n                        i++; \n                        total_count--; \n                } \n                down_max--; \n \n                i = down_max; \n                j--; \n                while (j > left_min && total_count > 0) \n                { \n                        printf (\"%d \\n\", a[i][j]); \n                        j--; \n                        total_count--; \n                } \n                left_min++; \n \n                j = left_min; \n                i--; \n                while (i > up_min && total_count > 0) \n                { \n                        printf (\"%d \\n\", a[i][j]); \n                        i--; \n                        total_count--; \n                } \n                up_min++; \n        } \n} \nint main () \n{ \n        print_spiral(4, 5); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The solution works for m * n matrix no metter m is equl or not equal to n."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void printSpiral(int **a,int m,int n) \n{ \n    int i=0,j=0,p,q; \n    p=m; \n    q=n; \n    while(p>0 && q>0) \n    { \n        while(j=(n-q)) \n    { \n        printf(\"%d \",a[i][j]); \n        j--; \n    } \n    j++; \n    i--; \n    while(i>m-p) \n    { \n        printf(\"%d \",a[i][j]); \n        i--; \n    } \n    i++; \n    j++; \n    p--; \n    q--;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int[] getSpiral( int[][] m ){   \n   \n  int circleIndex = 0; \n   \n  int totalCirclesCount = m.length/2; \n   \n  int index = 0; \n  int[] arr  = new int[m.length * m.length]; \n   \n  while( circleIndex < totalCirclesCount ){ \n    \n   for( int col = circleIndex; col < m.length-circleIndex-1; col++ ){     \n    arr[index++] = m[circleIndex][col];     \n   } \n    \n   for( int row = circleIndex; row < m.length-circleIndex-1; row++){ \n    arr[index++] = m[row][m.length-circleIndex-1];  \n   } \n    \n   for( int col = m.length-1-circleIndex; col > circleIndex; col-- ){ \n    arr[index++] = m[m.length-1-circleIndex][col]; \n   } \n    \n   for( int row = m.length-1-circleIndex; row > circleIndex; row--){ \n    arr[index++] = m[row][circleIndex]; \n   } \n    \n   ++circleIndex; \n  } \n    \n   \n  int middle = m.length/2; \n   \n  // 'odd' matrix size  \n  if( (m.length & 1) == 1 ){ \n   arr[index] = m[middle][middle]; \n  }   \n   \n  return arr; \n   \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"while((leftEnd <= rightEnd) && (upEnd <= downEnd)){     for(int i=leftEnd;i<=rightEnd;i++){  System.out.print(matrix[upEnd][i]+\" \");     }     upEnd++;     for(int i=upEnd;i<=downEnd;i++){  System.out.print(matrix[i][rightEnd]+\" \");     }  rightEnd--;     for(int i=rightEnd;i>=leftEnd;i--){  System.out.print(matrix[downEnd][i]+\" \");     }     downEnd--;     for(int i=downEnd;i>=upEnd;i--){  System.out.print(matrix[i][leftEnd]+\" \");     }     leftEnd++; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n \n \nvoid printspiral(int ar[5][6],int rowstart,int rowend,int colstart,int colend) \n{ \n   int i; \n     if(rowstart <= rowend  && colstart <=colend) \n       { \n            \n            if(rowstart == rowend) \n              { \n                  \n                  for(i=colstart;i<=colend;i++) \n                   printf(\"%d  \",ar[rowstart][i]); \n                   return;  \n \n              } \n \n \n              if(colstart == colend) \n              { \n                  \n                  for(i=colstart;i<=colend;i++) \n                   printf(\"%d  \",ar[i][colstart]); \n \n                   return; \n              } \n         \n              for(i=colstart;i<=colend;i++) \n               { printf(\"%d  \",ar[rowstart][i]);} \n \n              rowstart++; \n             \n              for(i=rowstart;i<=rowend;i++) \n               { printf(\"%d  \",ar[i][colend]);} \n \n              colend-- ; \n \n              for(i=colend;i>=colstart;i--) \n               { printf(\"%d  \",ar[rowend][i]);} \n \n               --rowend; \n \n              for(i=rowend;i>=rowstart;i--) \n                { printf(\"%d  \",ar[i][colstart]);} \n           \n               ++colstart; \n             \n \n               \n              printspiral(ar,rowstart,rowend,colstart,colend); \n \n \n \n        } \n \n} \n \n \nint main() \n{ \n   int ar[5][6]={ {1,2,3,4,5,6}, \n                {7,8,9,10,11,12}, \n                {13,14,15,16,17,18}, \n                {19,20,21,22,23,24}, \n                {25,26,27,28,29,30} \n                }; \n \n   int rowstart=0; \n   int rowend =4; \n   int colstart = 0; \n   int colend =5; \n \n   printspiral(ar,rowstart,rowend,colstart,colend); \n             \n \n  }  \n \n \noutput :1  2  3  4  5  6  12  18  24  30  29  28  27  26  25  19  13  7  8  9  10  11  17  23  22  21  20  14  15  16"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"One more solution in cpp :-)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void PrintMatrixInSpiralOrder(int[][] matrix) \n{ \n List result = GetMatrixInSpiralOrder(matrix, 0, 0, matrix.GetLength(0)-1, matrix.GetLength(1)-1); \n  \n if (result.Count > 0) \n { \n  Console.Write(result[0]); \n  for (int i=1;i < result.Count;i++) \n   Console.Write(string.Format(\" {0}\", result[i])); \n }  \n} \n \nprivate List PrintMatrixInSpiralOrder(int[][] matrix, int startRow, int startCol, int endRow, int endCol) \n{ \n List values = new List(); \n \n if (startRow > endRow || startCol > endCol) \n  return values; \n \n //first row \n for(int i=startCol;i<=endCol;i++) \n  values.Add(matrix[startRow, i]); \n \n //last col \n for(int i=startRow;i<=endRow;i++) \n  values.Add(matrix[i, endCol]); \n \n //last row \n for(int i=endCol-1;i>=startCol;i--) \n  values.Add(matrix[endRow, i]); \n \n //first col \n for(int i=endRow-1;i>=startCol+1;i--) \n  values.Add(matrix[i, startCol]); \n \n startRow += 1; \n startCol += 1; \n endRow -= 1; \n endCol -= 1; \n  \n List resultOfInside = PrintMatrixInSpiralOrder(matrix, startRow, startCol, endRow, endCol); \n return values.AddRange(resultOfInside); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The output of the matrix is very simple, just it:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Turned out to be simpler than I thought. Hope I am not missing something. Here is the code in java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution uses state machine that can change direction of move based on current direction"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In Java for any m*n matrix"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a simple version of Java code.  The idea is to have four indexes: top, down, left and right which are gonna be used to point where we are gonna start printing rows and columns, when top > down or left > right then we are done."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=20533663","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"5","title":"Open two instances of Microsoft Word and print to printer simultaneously. How would the underlying printer driver work? How would you design the printer driver?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"There can be two possible solutions to this problem I ) Use Print Spooler of OS II ) Design specific program to handle prints  if we follow option (I) then life is simple, just put every print request we get to spooler and OS will mange by itself ( actually its a solution to producer-consumer problem )  if we follow option (II) then we would have to design priority scheduler as mentioned by @vgeek on any basis we like whether size, time of arrival or even user can be asked for priority if two print commands are given simultaneously. This would require us to code manually the work of spooler."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"The jobs in the printer are basically kept in a queue and if only one instance is there and several jobs to be printed are there then the printer prints the jobs on a first come first serve basis. But when two or more instances of the word are running and simultaneous instructions are provided to print the job to the printer then the priority to the jobs should be given according to the size of the job. Suppose the size of one job is 100 kb and size of another job is 50 kb then the priority to first job should be given. Thus the printer driver could be designed on the basis of priority queue. To ensure it more we can use a counting semaphore where the less-size job holds the resources that is the printer driver until it is completely printed after which the resource becomes available to the next job for printing."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assumptions:  Printer has unlimited memory  We have two components: 1. Client driver on the machine 2. The service listening on the printer On receiving a request to print, the client driver on the machine sends a notification to the printer about a print job. The printer stores the request in a FIFO queue. The printer has a different thread which dequeues from the queue and processes that job. While processing, it calls back the client driver and downloads the entire document to be printed.  This is very high level but you can decompose these components and decide on the different messages and contents of the message.  Plus, if the assumption of unlimited memory is untrue, there needs to be a secondary memory which is larger. Optimizations will be required to print multiple copies of the same doc in this case in order to avoid downloading the doc multiple times."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=19957673","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"5","title":"Design an algorithm to find all the nouns and verbs present in a book. Discuss and explain your decision as to why you chose that algorithm.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"1. Dictionary of all Nouns and verbs:  a. make a trie of nouns. let the word in trie end with the word and also add  s or es depending  on singular or plural property.   b. In case of verb, we will need to have all permutations of verb in the trie i.e. run, running, runs etc so it can be matched 2. Create a Hash table to store the nouns and verbs in the book. for each permutation of noun/verb only store the main word i.e. for running only store run so that the list is complete. Reason for trie : O(1) search time for word   Reason for Hashtable: O(1) search time"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"how does the hashset work?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I would consider it as other way round, as nothing is given about extra noun-verb dict.  Let us define"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"how does dictionary of nouns is possible , there can  be infinite nouns"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"how does dictionary of nouns is possible , there can  be infinite nouns"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=6466717509222400","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"14","title":"\"Write test cases for reversing words of string \". For eg. \"This is nice\" is input string and output is \"nice is This\".  I gave him -  \" \" \"Hello\" \"bye! Mr. X  Y. Kumar\"  But he didn't seem satisfied.   Can u plz tell what general guidelines should I follow for writing efficient test cases.  What more test cases should I have written for this question ?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"Test Cases: Check for  - NULL string - \"\" empty string - \"a\" string that consists only one word - More than one space between words"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"1) An empty string. 2) String with only one space. Ex: \" \". 3) String with multiple spaces in between words. 4) String with spaces at the starting. Single and multiple. 5) String with spaces at the end. Single and multiple. 6) Combinations of step 3 with 4 and 5. 7) String with alphanumeric. 8) Include special characters in step 7. 9) Strings which are palindromes. 10) String with only one character. 11) String with more than 255 characters. 12) String with combinations of uppercase and lowercase letters. 13) String with only special characters. 14) String with only uppercase and only lowercase letters. 15) String with only spaces. more than 2 spaces. 16) String with ASCII characters and with Unicode characters. 17) String with exactly single spaces in between letters. 18) String containing even number of letters in some words and odd number of letters in others."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"two more test cases are needed 1)  string with even no. of word counts, 2) String with odd no. of word count"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think he was expecting this :  (Probably a unit test).  1) Take \"This is nice\"  2) Put in the program = get the output \"nice is This\" 3) Take output \"nice is This\" put in program back  , you should get original string. \"This is nice\". (If the program is right :))   To the above program automated with single word , >1 words , null ,  empty string , and one manual test would be good.   I am not QA BTW. Just a programmer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"when you find '\\n' or ' '(space) just insert the word into the stack ... if you have found '\\n' , now pop your words ...  it will be in d reverse order ..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"when you find '\\n' or ' '(space) just insert the word into the stack ... if you have found '\\n' , now pop your words ...  it will be in d reverse order ..."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5293418343301120","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"3","title":"Design class structure for a building, floors and space. The space can be an apartment, a store or an office. Include any properties, fields and methods you think would be interesting to have.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"1. I would use an abstract class for SPACE and then specialize it to concrete classes APARTMENT, STORE, OFFICE and what not.  2. FLOOR will be another class that will be composed of collection of SPACE objects. 3. BUILDING will also be a class and will be composed of collection of FLOOR objects.  In order to properly identify properties and methods I need to know what is the purpose of this design? What functionality are we intending to provide?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You better sit relax back .... have pencil and book ...  then draw ER diagram then start design skeleton of class structures and it's services ;)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"building class with properties like Street address, # of total properties in the building, parking space, No. of parking places available to rent, etc..Child classes derived from building classes like Apartment, Store, Office, etc.. Each one having Suite no, monthly maintenance cost and a constructor which checks with total # of properties available in apartment before creating instance of property. Apartment class has properties like # of bedrooms. When each time constructor is called to reserve a new property in the building,"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5374996952121344","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"5","title":"Giving a 2D (N*N) Matrix of characters, construct every possible  words out of it. A cell in the matrix can only be used one time.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"This is essentially the game, Boggle.  There is a solution to it on StackOverflow.   stackoverflow.com/questions/746082/how-to-find-list-of-possible-words-from-a-letter-matrix-boggle-solver"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Looks like a repeat of the following question -  question?id=19099663"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think BFS or DFS will work."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think building up a trie and then running a DFS comparing each of the words to the trie, if character visited, discard the whole word.  Will it work?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A BackTrack Solution.  1. choose all the words of length 1,2,3,.... n*n. 2. whenever a word of certain length is found compute all it's permutation and print them one by one."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=4655753138798592","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"16","title":"Print the actual phone number when given an alphanumeric phone number. For e.g. an input of 1-800-COM-CAST should give output as 18002662278 (note: output also does not contain any special characters like \"-\").","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Store the mapping in a hashmap; A -> 2 B -> 2 ... Z-> 9  Then parse the input stream and for characters look up in the hashmap and get the digit for the alphabet."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"I think this is a good entry-level *screening* question.   Firstly, its solutions don't require foreknowledge of any \"trick\", just a basic understanding of ASCII layout and how to use it to do character translations.   Secondly, an efficient implementation is very elementary, and, as we see from earlier posted solutions, there are a variety of ways to solve the problem. It's easy to code in <10-15 minutes, perhaps longer for a candidate with minimal experience or for someone who feels a lot of stress or nervousness when interviewing for a job.   I personally only use this question for screening out the bottom 1:50 candidates, or those candidates who can't program at all under the stress of an interview. It will NOT tell me anything about the quality of the candidate when she/he writes an adequate solution.  Here's a straight forward solution in D that uses only an array table to translate the letters to numbers. It's more efficient than the hash-map solutions and simply leverages the positional adjacency of successive characters 'A'...'Z' in UTF-8 or ASCII encoding."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"public static String expandPhone(final String phone) { \n  final StringBuilder sb = new StringBuilder(phone.length()); \n  for (final char ch : phone.toCharArray()) { \n   if (Character.isDigit(ch)) { \n    sb.append(ch); \n   } else { \n    switch (Character.toUpperCase(ch)) { \n     case 'A': \n     case 'B': \n     case 'C': \n      sb.append(2); \n      break; \n     case 'D': \n     case 'E': \n     case 'F': \n      sb.append(3); \n      break; \n     case 'G': \n     case 'H': \n     case 'I': \n      sb.append(4); \n      break; \n     case 'J': \n     case 'K': \n     case 'L': \n      sb.append(5); \n      break; \n     case 'M': \n     case 'N': \n     case 'O': \n      sb.append(6); \n      break; \n     case 'P': \n     case 'Q': \n     case 'R': \n     case 'S': \n      sb.append(7); \n      break; \n     case 'T': \n     case 'U': \n     case 'V': \n      sb.append(8); \n      break; \n     case 'W': \n     case 'X': \n     case 'Y': \n     case 'Z': \n      sb.append(9); \n      break; \n    } \n   } \n  } \n  return sb.toString(); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class Program \n    { \n        public static string getDigitsFromPhoneString(string str) \n        { \n            char[] pnArray = str.ToCharArray(); \n            StringBuilder strBldr = new StringBuilder(); \n            foreach (char chr in pnArray) \n            { \n                int res; \n                if (chr != '-') \n                { \n \n                    if (Int32.TryParse(chr.ToString(), out res)) \n                    { \n                        strBldr.Append(chr); \n                    } \n                    else \n                    { \n                        char ch = getDigitfor(chr); \n                        if(ch != ' ') \n                        strBldr.Append(ch); \n                    } \n                } \n            } \n \n            return strBldr.ToString(); \n        } \n        public static char getDigitfor(char chr) \n        { \n            switch (chr) \n            { \n                case 'a': \n                case 'b': \n                case 'c': \n                    return '2'; \n                //Similarly for rest characters     \n                default: return ' '; \n            } \n        } \n        static void Main(string[] args) \n        { \n            getDigitsFromPhoneString(\"1800abacba\"); \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"string num = \"\"; \n for(int i = 0; i < s.Length; i++) \n { \n  int key = (int)Math.Ceiling((decimal)( (s[i]-'A')+ 1 )/3) + 1; \n  if(s[i] == 'V' || s[i] == 'S') \n   key--; \n  num+=key;    \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nmain() \n{ \n    char a[20]; \n    int b=0,i; \n    scanf(\"%s\",a); \n    for(i=0;i='A'&&a[i]<='O') \n        { \n            b=b*10+(a[i]-'A')/3+2; \n        } \n        if(a[i]>='a'&&a[i]<='o') \n        { \n            b=b*10+(a[i]-'a')/3+2; \n        } \n        if(a[i]>='P'&&a[i]<='Z') \n        { \n            b=b*10+(a[i]-'P')/4+7; \n        } \n        if(a[i]>='p'&&a[i]<='z') \n        { \n            b=b*10+(a[i]-'p')/4+7; \n        } \n    } \n    printf(\"%d\",b); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public Hashtable LookupTable() \n        { \n            var lookup = new Hashtable(); \n            lookup['C'] = '2'; \n            lookup['O'] = '6'; \n            lookup['M'] = '6'; \n            lookup['A'] = '2'; \n            lookup['S'] = '7'; \n            lookup['T'] = '8'; \n            //.... \n            return lookup; \n        } \n \n \n \n \n        public string TransformNumber(string cell) \n        { \n            var lookup = LookupTable(); \n            var output = new StringBuilder(); \n            int n = 0; \n            foreach (var number in cell) \n            { \n                if (number == '-') \n                { \n                    continue; \n                     \n                } \n                if (!Int32.TryParse(number.ToString(), out n)) \n                { \n                    output.Append(lookup[number]); \n                } \n                else \n                { \n                    output.Append(number); \n                } \n            } \n            return output.ToString(); \n        } \n \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public string telephonewords(string str) \n        { \n            char[] ca = str.ToCharArray(); \n            int i=0; \n            Dictionary dic = new Dictionary();                    \n            dic.Add('A', 2); \n            dic.Add('a', 2); \n            dic.Add('B', 2); \n            dic.Add('b', 2); \n            dic.Add('C', 2); \n            dic.Add('c', 2); \n            dic.Add('D', 3); \n            dic.Add('d', 3); \n            dic.Add('E', 3); \n            dic.Add('e', 3); \n            dic.Add('F', 3); \n            dic.Add('f', 3); \n            dic.Add('G', 4); \n            dic.Add('g', 4); \n            dic.Add('H', 4); \n            dic.Add('h', 4); \n            dic.Add('I', 4); \n            dic.Add('i', 4); \n            dic.Add('J', 5); \n            dic.Add('j', 5); \n            dic.Add('K', 5); \n            dic.Add('k', 5); \n            dic.Add('L', 5); \n            dic.Add('l', 5); \n            dic.Add('M', 6); \n            dic.Add('m', 6); \n            dic.Add('N', 6); \n            dic.Add('n', 6); \n            dic.Add('O', 6); \n            dic.Add('o', 6); \n            dic.Add('P', 7); \n            dic.Add('p', 7); \n            dic.Add('Q', 7); \n            dic.Add('q', 7); \n            dic.Add('R', 7); \n            dic.Add('r', 7); \n            dic.Add('S', 7); \n            dic.Add('s', 7); \n            dic.Add('T', 8); \n            dic.Add('t', 8); \n            dic.Add('U', 8); \n            dic.Add('u', 8); \n            dic.Add('V', 8); \n            dic.Add('v', 8); \n            dic.Add('W', 9); \n            dic.Add('w', 9); \n            dic.Add('X', 9); \n            dic.Add('x', 9); \n            dic.Add('Y', 9); \n            dic.Add('y', 9); \n            dic.Add('Z', 9); \n            dic.Add('z', 9); \n            dic.Add('1', 1); \n            dic.Add('2', 2); \n            dic.Add('3', 3); \n            dic.Add('4', 4); \n            dic.Add('5', 5); \n            dic.Add('6', 6); \n            dic.Add('7', 7); \n            dic.Add('8', 8); \n            dic.Add('9', 9); \n            dic.Add('0', 0); \n            StringBuilder sb = new StringBuilder(); \n             \n            //foreach (KeyValuePair pair in dic) \n            //{ \n            //    Console.WriteLine(\"Key: {0}, Value: {1}\", pair.Key, pair.Value );  \n            //} \n \n \n \n           while(i< ca.Length) \n           { \n               if (ca[i] == '-') \n                   i++; \n \n               if (dic.ContainsKey(ca[i])) \n               { \n                   sb.Append(dic[ca[i]]); \n                   i++; \n               } \n           } \n         //   Console.WriteLine(sb); \n \n \n            return sb.ToString(); \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"my $s = '1-800-COM-CAST'; \nmy %hash = ( \n   '2' => ['a', 'b', 'c'], \n   '3' => ['d', 'e', 'f'], \n   '4' => ['g', 'h', 'i'], \n   '5' => ['j', 'k', 'l'], \n   '6' => ['m', 'n', 'o'], \n   '7' => ['p', 'q', 'r', 's'], \n   '8' => ['t', 'u', 'v'], \n   '9' => ['w', 'x', 'y', 'z'], \n     ); \n      \nforeach $key (keys %hash) \n{ \n foreach $value (@{$hash{$key}}) \n { \n  if($s =~ /$value/i) \n  { \n   $s =~ s/$1/$key/g; \n  } \n } \n} \nprint \"Now My string is $s\";"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is an excellent candidate for using hash tables:  A possible solutions is as follows:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This took me longer than 15 minutes, so I guess I'm at the bottom of those 50 candidates. Here's a java solution that breaks out the functions a little more, but otherwise very similar to Leif's.   I'm assuming that the input is a string, and that this is code that should be written on the whiteboard, hence avoiding a long enum."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution in Java."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package collections;  import java.util.regex.Pattern;  public class TelephineAlphanumeric {   private String PATTERN=\"[a-z]\";  private String phoneNumber=\"\";  private int currPosition=0;  Pattern pattern=null;   public TelephineAlphanumeric()  {   pattern=Pattern.compile(PATTERN);  }   public TelephineAlphanumeric(String phoneNumber)  {   pattern=Pattern.compile(PATTERN);   this.phoneNumber=phoneNumber.toLowerCase();   findTelephoneNumber(this.phoneNumber);  }   private int getPositionNumber(char ch)  {   int temp = (int)ch;   if(temp<=122 && temp>=97)   {    int pos=(temp-96);    int pool=pos / 3;    int rem=pos % 3;    if(rem>0)pool++;    pos=pool+1;    return pos ;   }   else   {    return 0;   }  }   public void setTelephoneNumber(String phoneNumber)  {   if (phoneNumber==null||phoneNumber.length()==0)   {    throw new RuntimeException(\"Input Is Not Valid.\");   }   this.currPosition=0;   this.phoneNumber=phoneNumber.toLowerCase();   findTelephoneNumber(this.phoneNumber);   }   private void findTelephoneNumber(String phoneNumber)  {   char posChar=this.phoneNumber.charAt(this.currPosition);    String currChar=String.valueOf(posChar);   int posNum=getPositionNumber(posChar);   if(isMatch(currChar)&&posNum>0)   {    this.phoneNumber=this.phoneNumber.replaceAll(currChar,String.valueOf(posNum));   }   this.currPosition++;   if(this.currPosition  {    findTelephoneNumber(this.phoneNumber);   }   else   {    return;   }  }   private String getPhoneNumber()  {   this.phoneNumber=this.phoneNumber.replaceAll(\"-\", \"\");   return this.phoneNumber;  }   private boolean isMatch(String input)  {   if(this.pattern.matcher(input).matches())   {    return true;   }   return false;  }   public static void main(String[] args) {   TelephineAlphanumeric telNum= new TelephineAlphanumeric();   telNum.setTelephoneNumber(\"1800-2-ABVBBBZ\");   System.out.println(telNum.getPhoneNumber());  } }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=5242643239927808","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"49","title":"Is this even possible?  Move the spaces to the starting of the string in a c style string. In place within one iteration.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Yes, possible. Start two pointers i & j from the end of the string.   a. Keep copying the character from ith location to the jth location and decrement both i & j b. When i encounters a space, decrement i, but not j c Repeat steps a & b until i falls of the beginning of the string.  d. Keep setting 'space' character at jth location and decrement j unitl j falls of the beginning of the string"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"It is possible. sites.google.com/site/spaceofjameschen/home/string/move-the-spaces-to-the-starting-of-the-string-in-single-iteration---microsoft"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"its possible run a iteration from end of the string to the starting.Take two indexes,keep on putting the character at the end except space.Automatically all the spaces will come in front"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"char str[]=\"  asdfe  sdrfjcz  dgrjf  \"; int i=0, len=0, count=0; len = strlen(str); for(i=len-1; i>=0; i--) {        if(count ==i)         {             str[i] = ' '; count--;          }           else if(str[i] == ' ')         {            count++; continue;         }         else        {            if(count)               str[i+count] = str[i];        } }          }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I did in Java, but the technique is very similar. Java code is:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n#include \nusing namespace std; \n \nvoid swap(char str[],int i,int j) \n{ \n      char temp=str[i]; \n      str[i]=str[j]; \n      str[j]=temp; \n} \n \nint main() \n{ \n     \nchar str[60]; \ncout<<\"Enter string:\"; \ngets(str); \n \nint len=strlen(str); \nint j=len-1; \nfor(int i=len-1;i>=0;i--) \n{ \n        if(str[i]!='_') \n        {                  \n                          \n                          swap(str,i,j); \n                          j--;              \n        }         \n} \n \nputs(str); \ngetch(); \nreturn 0;     \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void inlineSpacesMove(char* str, int len, int currLen, int* numSpaces) { \n if (*str == '\\0') \n  return; \n inlineSpacesMove(str + 1, len, --currLen, numSpaces); \n printf(\"%s\\n\", str); \n \n if ((currLen + (*numSpaces)) == len) { \n  *(str) = ' '; \n  (*numSpaces)--; \n } else { \n  if (*(str - *numSpaces) == ' ') \n   (*numSpaces)++; \n \n  if (*numSpaces > 0 && currLen + (*numSpaces) != len) { \n   printf(\"%c \\n\", *str); \n   *str = *(str - (*numSpaces)); \n \n  } \n } \n \n} \n \nint main() { \n char *str = malloc(500); \n \n int numSpaces = 0; \n fgets(str, 500, stdin); \n /* Remove trailing newline, if there. */ \n if ((strlen(str) > 0) && (str[strlen(str) - 1] == '\\n')) \n  str[strlen(str) - 1] = '\\0'; \n printf(\"%s \", str); \n inlineSpacesMove(str, strlen(str), strlen(str), &numSpaces); \n printf(\"%s \", str); \n free(str); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think its possible in one single pass."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include int main() {    char *name = new char(100);    char* name2=new char(100);    int n=0, i=0, spaceC=0, j=0;    strcpy(name, \"This is my string\");    for(j=i=strlen(name);i>=0;i--,j--){     if(name[i]==' ')     {        i--;        name2[j]=name[i];        name2[spaceC]=' ';        spaceC=spaceC+1;     }     else     name2[j]=name[i];    }    printf(\"\\nthe entered string is '%s'\\n\", name2);    return 0;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \nmain() \n{ \n    char a[500] = \" i  s th i   s ev   enpos  si  b      l  e    \"; \n    printf (\"%s\\n\", a); \n    int i; \n    int j; \n    i = j = strlen(a) - 1; \n    while(i) \n    { \n        if ((a[j] >= 'a' && a[j] <= 'z') && ( --i && --j )) \n        ; \n         \n        else if ( (a[i] == ' ') && --i) \n        ; \n         \n        else if (( a[i] >= 'a' && a[i] <= 'z' )) \n        { \n            a[j] = a[i]; \n            a[i] = ' '; \n            --i; \n            --j; \n        } \n    } \n    printf (\"%s\\n\", a); \n     \n    return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I implemented in java, Its very simple."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Implemented in java, its simple."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void movespacestofront(char* str) \n{ \n    if(str == NULL) return; \n int len = strlen(str); \n    int i,j; \n i = j = len-1; \n char space = ' '; \n while(i>=0) \n { \n  if(str[i] != space) \n  { \n   std::swap(str[i--],str[j--]); \n  } \n  else { \n   --i; \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void MoveSpacesToFront(ref char[] input) \n        { \n            int lastSpace = -1; \n            for (int i = input.Length - 1; i >= 0; i--) \n            { \n                if (input[i] == ' ') \n                { \n                    lastSpace = Math.Max(lastSpace, i); \n                } \n                else if (lastSpace != -1) \n                { \n                    Swap(input, i, lastSpace); \n                    lastSpace--; \n                } \n            } \n \n        } \n \n        private static void Swap(char[] input, int i, int j) \n        { \n            char temp = input[i]; \n            input[i] = input[j]; \n            input[j] = temp; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \"stdafx.h\" #include   int _tmain(int argc, _TCHAR* argv[]) {  //char str[] = {'a',' ','b','c',' ','d'};  char str[] = \"H  i t h e re! Is t  hi s ev  en p o s sib  le?\";  int j=-1;  for(int i= strlen(str) - 1;i>=0;i--)  {   if(str[i] == ' ' && j==-1)   {    j=i;    continue;   }   if(str[i]!=' ' && j!=-1)   {    str[j] = str[i];    str[i] = ' ';    j--;   }  }  printf(\"%s\\n\",str);  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void removespaces(string &str) \n{ \n int t1=0; \n int t2=0; \n while (t2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void removespaces(string &str) \n{ \n int t1=0; \n int t2=0; \n while (t2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is my resolution, and it takes only one iteration."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution below works well. Not sure if it is qualified for 'one iteration' here as I have a small while loop inside a while loop. However when there are plenty of spaces the small while loop would take trivial time as it marks position to start searching for next non-space character each time.   #include  #include  #include   int main() {    char str[]=\" Hello I am\";       printf(\"Input: %s\\n\",str);        char *end = str + strlen(str)-1;      char *next_non_space = NULL;        while(end>=str)    {        if(*end==' ')        {            //Find the next non-space character j from the left substring and move it to end,  then set j to space      char *j;      if(next_non_space!=NULL)      {          j = next_non_space;      }      else      {          j = end;      }            while(j>str)      {          j--;       if(*j!= ' ')       {           next_non_space = j; // We found the next non space character at j, next time when we search the 'next' next non space character, we should start from j (j is input but it actually starts at (j-1) in the program)              *end = *j;        *j= ' ';        break;       }      }           }             end--;            }    printf(\"Output: %s\\n\",str);     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution below works efficiently. Although I am not sure if it's qualified for 'one iteration' as I have a small while loop inside a while loop. However the small while loop would take trivial time if there are plenty of spaces as it marks the next position to start searching for next non-space character.  #include  #include  #include   int main() {    char str[]=\" Hello I am\";       printf(\"Input: %s\\n\",str);        char *end = str + strlen(str)-1;      char *next_non_space = NULL;        while(end>=str)    {        if(*end==' ')        {            //Find the next non-space character j from the left substring and move it to end,  then set j to space      char *j;      if(next_non_space!=NULL)      {          j = next_non_space;      }      else      {          j = end;      }            while(j>str)      {          j--;       if(*j!= ' ')       {           next_non_space = j; // We found the next non space character at j, next time when we search the 'next' next non space character, we should start from j (j is input but it actually starts at (j-1) in the program)              *end = *j;        *j= ' ';        break;       }      }           }             end--;            }    printf(\"Output: %s\\n\",str);     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{ i=-1 for j=0,n-1   if c[j]<>' '     ++i     swap c[i],c[j] }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  using namespace std;  void MoveSpaces(string* line){          string input=*line;         int count=input.length();         int pos1=0,pos2=input.length();         char* charAry=new char[input.length()];         strcpy(charAry,input.c_str());         char* charAry2=new char[input.length()];         string space,non_space;         while(count >= 0){                 if(charAry[count] == ' '){                         space=charAry[count]+space;                 }else{                         non_space=charAry[count]+non_space;                 }                 count--;         }         *line=string(space+non_space); } int main(){          string input=\"H i T h e r e!\";         MoveSpaces(&input);         cout << \" After function iz : \" << input << endl; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Just use two pointers as explained by Dumbo and replace in the below program '_' with ' '. '_' is used to see the output clearly."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"void movespace(char str[]) \n{ \n int i=0,j=0; \n while(str[i]!='\\0') \n { \n  if(str[i]!=' ') \n  ++i; \n  else \n  { \n   swap(str[i],str[j]); \n   ++j; \n  } \n } \n cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"static void Main() \n        { \n            string inputString = \"H  i t h e re! Is t  hi s ev  en p o s sib  le?\"; \n            char[] chars = inputString.ToCharArray(); \n \n            for (int i = chars.Length - 1; i > 0; i--) \n            { \n                while (chars[i] != ' ') \n                { \n                    i--; \n                } \n                int j = i; \n                while (chars[j] == ' ' && j > 0) \n                { \n                    j--; \n                } \n \n                chars[i] = chars[j]; \n                chars[j] = ' '; \n            } \n \n            foreach (char c in chars) \n                Console.Write(c); \n \n            Console.ReadKey(); \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"void moveSpace(char *str) \n{ \n  char *sp_a,*sp_b; \n  int bFlag = 0; \n  int walker=0; \n  int spaceCount = 0; \n  char c; \n  sp_a = str; \n  while(*sp_a) \n  { \n    sp_a++; \n  } \n  walker=sp_a-str; \n  if (walker <= 1) return ; \n \n  printf(\"%d\",walker); \n  --sp_a; \n \n  while(walker--) \n  { \n    if(*sp_a == ' ') \n    { \n      if (!spaceCount) \n      { \n        sp_b = sp_a; \n      } \n      spaceCount++; \n      sp_a--; \n      continue; \n    } \n    if (spaceCount) \n    { \n       c = *sp_a; \n       sp_b[0] = c; \n       sp_b--; \n    } \n    sp_a--; \n  } \n  sp_a++; \n  sp_b++; \n  while(sp_a%s<----------------\",str); \n \n  return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This can be done but with recursion. I hope doing it recursion will count it as one iteration :) I have used _ in place of space( ) for clarity.  Point me out for any wrong assumptions."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#include  #include using namespace std;  int main() {       string str=\" this is me, baby^^\";     cout<<         int head=0;          for(int i=0; i!=sizeof(str);++i)              {         if (str[i]==' ')         {             for(int j=i;j>0;--j)             {                 str[j]=str[j-1];             }             str[head]=' ';         }      }     cout<    return 0;  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=19638671","download_status":"DOWNLOAD_DONE","votes":"9","answersCount":"47","title":"Write a program to find whether a given number is a perfect square or not. You can only use addition and subtraction operation to find a solution with min. complexity.  i/p : 25  o/p : True  i/p : 44 o/p: False","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"14","title":"#include int check(int); main()       {         int N;                           printf(\"\\n Enter the N:\");         scanf(\"%d\",&N);         if(check(N))             {                 printf(\"\\n[%d] Perfect Square:\\n\",N);                          }                  else             {                              printf(\"\\nNot perfect Square\\n\");                          }      }  int check(int n)     {         int i=1;                  while(n>0)             {                 n-=i;                 printf(\"[%d]\",n);                 i+=2;                                       }         if(n==0)             return 1;                      return 0;              }     complexity:O(logn)in some cases and  \n   \n    \n   -  \n     NAX \n     on June 12, 2013 Edit | Flag  \n    \n    \n   Reply"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"Sum of first n odd numbers is n^2. So we can keep adding odd numbers. If we reach the number its a perfact square."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"simply we can also keep on summing all odd numbers till we get desired num. If sum ends up with given number then it is perfectly square number otherwise if sum exceeds given number, number is not perfectly square and will return false.  all Square numbers are: 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289  If we see the difference among these numbers, following figure we get: 3, 5, 7, 9, 11, 13, 15, 17, 19, 21  So, you see, every consecutive square number is Arithmetic progression. So if we can add number of this series to get desired result. Complexity will be O(sqrt(n)) As in case of square root of 25, we need 5 iteration of addition."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Just to add a little mathematical explanation..  (n+1)square - n square=2 n+1, so if he have a perfect square number n, then the next perfect square number will be 2n+1 more than n.  Now for all n,      2n+1,4n+1,6n+1 will be always in Arithmetic Progression."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for an integer i > 0, compute the sum by summing up i for i times; compare the sum with the given number  when doing the summing up for each i, the complexity can be O(log i)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Linear time complexity. O(N)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You could also use binary like search for possible square. Time should be less then O(N)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import System.io.*; \nclass Square \n{ \n  static int cal(int num) \n    { \n       for(float i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package com.rakesh.topcoder;  import java.util.Scanner;  public class PerfectSquareWithAddition {   /**   * @param args   */  public static void main(String[] args) {    Scanner input = new Scanner(System.in);   System.out.println(\"Enter a numer..\");   int n = input.nextInt();   int finalval = findPerfectSquare(n);   if(finalval == 0) System.out.println( n + \" is a Perfect Square \" );   else System.out.println(n + \" is not a perfect square \");  }   public static int findPerfectSquare(int n){   int a=1;      while(n>0){    n -= a;    a += 2;   }      return n;  }   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"To find out if 25 is a perfect square, i have to find a number which is greater than 1 but less than n=25 which n= 25  will be divisible by and when that number is multiplied by itself then it should be equal to n=25;  in my method; n = value the number that n should be divisible by = div; so div * div == value and value%div == 0; the for loop accomplishes div*div using addition instead; complexity root n * root n = n (not sure on this one, help is appreciated);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use dynamic programming 1^2 = 1 (n+1) = n^2 + 2n + 1  calc 1^2 , 2^2 until n^2 >= value  the time complexity is O(n^0.5)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"string input = Console.ReadLine(); \n            int value = 0; \n            bool isSquare = false; \n \n            if (int.TryParse(input, out value)) \n            { \n                for (int i = 0; i <= value / 2; i++) \n                { \n                    int square = 0; \n \n                    for (int j = 0; j < i; j++) \n                    { \n                        square += i; \n                    } \n \n                    if (square == value) \n                    { \n                        isSquare = true; \n                        break; \n                    } \n                } \n            } \n \n            string msg = input + \" is \" + (isSquare ? \"\" : \"not \") + \"a perfect square\";  \n            Console.WriteLine(msg); \n            Console.Read();"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Regarding the complexity of the arithmetic-progression algorithm, it is sqrt(n) in relation to the value of n, but it is n^2 to the size of n (for example, the size of 100 is 3 [3 digits] but it takes 10 arithmetic operations)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n \nvoid main() \n{ \n int current_sum = 0; \n int final_sum = 0; \n int x = 0; \n int i = 0; \n int flag = 0; \n int j = 0; \n \n printf(\"Enter the number to be checked\\n\"); \n scanf(\"%d\", &x); \n \n for(i = 1; final_sum <= x; i++) \n { \n  for (j = 1; j <= i; j++) \n  { \n   current_sum = current_sum + i; \n  } \n  if (current_sum == x) \n  { \n   flag = 1; \n   break; \n  } \n  else \n  { \n   final_sum = current_sum; \n   current_sum = 0; \n  } \n } \n \n if (flag == 1) \n { \n  printf(\"The number is a perfect square\\n\"); \n } \n else \n { \n  printf(\"The number is NOT a perfect square\\n\"); \n }  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static public boolean checkPerfectSquare(int n) {      int i = 0;   int j = 1;      while (i < n) {    i +=j;    if (i == n)     return true;    j+=2;   }      return false;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use this:    f(x)=x^2        because  (x+1)^2=x^2+2*x+1,     so,      f(x+1)=f(x)+2*x+1 the code is like below:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int main() \n{ \n int i=1,sum=0; \n int input = 901; \n while(sum <= input) \n { \n  if(sum == input) \n   break; \n  sum += i; \n  i += 2; \n } \n if(sum == input) \n  std::cout << \"Square\"; \n else \n  std::cout << \"Not Square\"; \n return 1; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"With the same logic as discussed above by adding values (2n+1) with preceding values eg. 1, 4(1+(1+2)), 9(4+ (3+2)), 16(9+ (5+2)).... and comparing with given value. Ruby Code -"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"With the same logic as discussed above by adding values (2n+1) with preceding values eg. 1, 4(1+(1+2)), 9(4+ (3+2)), 16(9+ (5+2)).... and comparing with given value. Ruby Code -"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"With the same logic as discussed above by adding values (2n+1) with preceding values eg. 1, 4(1+(1+2)), 9(4+ (3+2)), 16(9+ (5+2)).... and comparing with given value. Ruby Code -"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this is most compact solution in C-style languages. O(sqrt(n)) complexity. C# code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Hi there! Here is my code, the easiest way to solve this problem:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=19286700","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"27","title":"Write a program to reverse a sentence in a zigzag order. i/p: I am a software programmer o/p: programmer erawtfos a ma I","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"1) Reverse the whole string from start to end and you get the this output.              \"remmargorp erawtfos a ma I\"  2) Reverse the individual words at odd locations, we get the below string.             \"programmer erawtfos a ma I\""},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package test; \n \npublic class ZigZagReverse { \n \n public static void main(String[] args) { \n \n  String input[] = { \"zig\", \"zag\", \"reverse\", \"string\" }; \n  ZigZagReverse zigZagReverse = new ZigZagReverse(); \n  for (int i = 0; i < input.length; i++) { \n   String s = input[i]; \n   input[i] = zigZagReverse.reverse(s, i); \n  } \n  zigZagReverse.displayOutput(input); \n } \n \n /* method to display the output */ \n private void displayOutput(String[] output) { \n  for (int i = 0; i < output.length; i++) { \n   System.out.print(output[i] + \" \"); \n  } \n } \n \n  \n /* method to reverse a string */ \n private String reverse(String s, int i) { \n  int start, end; \n  char temp; \n  if (i % 2 == 0) { \n   char array[] = s.toCharArray(); \n   start = 0; \n   end = array.length - 1; \n   while (start < end) { \n    temp = array[start]; \n    array[start] = array[end]; \n    array[end] = temp; \n    start++; \n    end--; \n   } \n   s = new String(array); \n  } \n  return s; \n \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the simple code in Python which does the purpose: \n \ndef ZigZagReverse(input_string): \n    lst = input_string.split(' ') \n \n    start_index = len(lst) - 2 \n     \n    for index in range(start_index, -1, -2): \n        lst[index] = lst[index][::-1] \n \n    print \" \".join(lst) \n     \n \nif __name__ == '__main__': \n    input_string = \"I am a software programmer\" \n    ZigZagReverse(input_string"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include void main() {  char str[100],new[100];  int len,k=0;  printf(\"enter string\\n\");  scanf(\"%[^\\n]s\",str);  len=strlen(str);  int i,j,prev=len-1,flag=0;  for(i=prev;i>=0;i--)  {   if(str[i]==' '|| i==0)   {    if(flag==0)    {     for(j=prev;j>=i;j--)     {      new[k++]=str[j];     }     flag=1;    }    else    {     if(i==0) i--;     for(j=i+1;j<=prev+1;j++)     {      new[k++]=str[j];     }     flag=0;    }    prev=i-1;   }  }  for(i=0;i  printf(\"%c\",new[i]); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we have to use extra space, right? Can we do without it, by not introducing much complications?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's some code that works perfectly, and doesn't touch StringBuilder nor StringBuffer:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"C#"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void reverseString(char str[]) { int len =strlen(str); int i = 0, j = len -1; while (ichar temp = str[i]; str[i] = str[j]; str[j] = temp; } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #include int main() {   int nf,i,j;   char str[]={\"I am a software programmer\"},temp;    strrev(str); printf(\"%s\\n\",str);     nf=0;///next front   while(str[nf]!='\\0')   {   i=nf;   j=i;     while((str[j]!=' ')&&(str[j]!='\\0'))   j++;      nf=j+1;   j--;   printf(\"i=%c j=%c nf=%c\\n\",str[i],str[j],str[nf]);   getch();   while(i   {      temp=str[i];      str[i]=str[j];      str[j]=temp;      i++;      j--;    }      } printf(\"%s\",str);     getch(); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"voide Reverse(char sen[]); int main() { Char sen[20]; gets(sen); Reverse(sen); printf(??the recersed sentence is:???); puts(sen); return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void ReverseZigZag(char str[]) \n{ \n int len=strlen(str),i=0,j=-1,temp,k; \n bool toggle=1; \n i=0,j=len-1; \n while(i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"namespace ZigZagReverseString \n{ \n    class Program \n    { \n        public static void ZigZagReverse(string str) \n        { \n            char[] charArray = str.ToCharArray(); \n \n            int j = 0; \n            for(int i = 0, k=-1; i< charArray.Length; i++) \n            { \n                if(charArray[i] != ' ') \n                { \n                    i++; \n                } \n                else if (charArray[i] == ' ' && ++k % 2 == 0) \n                { \n                    ReverseHelper(charArray, j, i - 1); \n                    j = i + 1; \n                } \n                else \n                { \n                    j = i + 1; \n                } \n            } \n \n            string strng = new string(charArray); \n        } \n \n        public static void ReverseHelper(char[] chrArray, int start, int end) \n        { \n            while (start < end) \n            { \n                char tmp = chrArray[end]; \n                chrArray[end] = chrArray[start]; \n                chrArray[start] = tmp; \n                start++; \n                end--; \n            } \n        } \n        static void Main(string[] args) \n        { \n            ZigZagReverse(\"this string should be reversed zigzag\"); \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi guys!, here another simple solution for this problem"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"namespace ZigZag {     class Program     {         static void Main(string[] args)         {             String s = \"I Am a Software Programmer\";             String[] sp = s.Split(' ');             Console.WriteLine(s);             for (int i = sp.Length -1; i >= 0; i--)             {                 if (i % 2 == 0)                 {                                        Console.Write(sp[i].ToString() + \" \");                 }                 else                 {                     for (int j = sp[i].Length - 1; j >= 0; j--)                     {                         Console.Write(sp[i].ToString()[j]);                     }                     Console.Write(\" \");                 }             }          }     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"namespace ZigZag {     class Program     {         static void Main(string[] args)         {             String s = \"I Am a Software Programmer\";             String[] sp = s.Split(' ');             Console.WriteLine(s);             for (int i = sp.Length -1; i >= 0; i--)             {                 if (i % 2 == 0)                 {                                        Console.Write(sp[i].ToString() + \" \");                 }                 else                 {                     for (int j = sp[i].Length - 1; j >= 0; j--)                     {                         Console.Write(sp[i].ToString()[j]);                     }                     Console.Write(\" \");                 }             }          }     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Like suggested by many it will be good to keep a boolean value to track alternate reversals. Here is a working code in java: public static String Reverse(String words) {   char[] letters = words.toCharArray();   letters = ReverseLetters(letters, 0, letters.length - 1);    String l = new String(letters);   System.out.println(l + \"\\n\");   int start = 0;   int end = 0;   boolean isReversed = true;   while (end < letters.length) {    if ((letters[end] == ' ' || letters[end] == letters.length - 1)) {     if (isReversed) {      letters = ReverseLetters(letters, start, end - 1);      start = end + 1;      isReversed = false;     } else {      start = end + 1;      isReversed = true;     }     }    end++;   }   if (isReversed) {    letters = ReverseLetters(letters, start, end - 1);   }       return new String(letters);  }  private static char[] ReverseLetters(char[] letters, int start, int end) {   while (start < end) {    char temp = letters[end];    letters[end] = letters[start];    letters[start] = temp;    start++;    end--;   }   return letters;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nchar * reverse(char s[],int ,int); \nvoid swap(char *a,char *b) \n{ \n    char t=*a; \n    *a=*b; \n    *b=t; \n} \nint main() \n{ \n    char str[]=\"I am a software programmer\"; \n    int len=strlen(str); \n    int prev=0; \n    int i; \n \n    char *s=reverse(str,0,len); \n    printf(\"%s\",s); \n    int b=1; \n    for(i=0;i<=len;i++) \n    { \n        if((str[i]==' '||str[i]=='\\0')&&(b==1)) \n        { \n            reverse(s,prev,i); \n            prev=i+1; \n            b=!b; \n \n        } \n    } \n     printf(\"\\n%s\",s); \n    return 0; \n} \nchar * reverse(char str[],int s,int e) \n{ \n    int i=s; \n    int j=e-1; \n    while(i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"What if the input is:  I am a software programmer too  Should the output be:  oot programmer erawtfos a ma I  Or should it be:  too remmargorp software a am I  aka's solution produces the latter."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Can you give one more example ? not able to understand what is zig zag here?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=19114694","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"29","title":"Find the first non repeating character in a given string. You may assume that the string contains any character from any language in the world, for e.g. an Arabic  or Greek character even.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"use bit vector of 95000. He was looking for bit array at that time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I answered the question with below code and the interviewer was happy with the solution, he also said that using an array with arr[95000] as in the code below is not an efficient way. I was not sure how else can I accommodate a UNICODE character set? And he did not tell me what's an efficient way when the interview got over."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I was not sure if the interviewer was just trying to test my approach or if we really have a way to represent the unicode char set without using an array of size 95000. But if you folks know a way to use the unicode character set without using a large array of size 95000, please do let me know as well."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the more efficient way is that you can use hash table instead of a long array.You can set the count that the character appears as the value of the hash table.And the hash table size is corresponding to the length of the string. I don't know about Java so,I give a pseudocode."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about using bool array instead of int array, it will save a lot of space, e.g. (p.s. not good at JAVA)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void FirstNonRepeatedCharacter(String s){ \n  List candidates = new ArrayList<>(); \n  HashSet alreadyExisted = new HashSet<>(); \n   \n  for (int i = 0; i < s.length(); i++) { \n   if(!alreadyExisted.contains(s.charAt(i))){ \n    if(candidates.contains(s.charAt(i))){ \n     Character c = new Character(s.charAt(i)); \n     candidates.remove(c); \n     alreadyExisted.add(c); \n    } \n      \n    else \n     candidates.add(s.charAt(i)); \n   } \n  } \n  System.out.println(candidates.get(0)); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#!/usr/bin/perl  \n \n#Date: 06.10.2013 \n \nuse strict; \n \nmy $string = qw(wcaowaor); \nmy @tempArray = split \"\",$string; \nmy @values = qw(0); \nmy %hashtable ; \nmy $count = 0; \n \nforeach (@tempArray) \n  { \n $values[ord($_)] +=1; \n  } \n \nfor(my $i=0;$i<$#values;$i++) \n  { \n $hashtable{$count++} = chr($i) if $values[$i] == 1; \n  } \n \nforeach my $key(sort keys%hashtable) \n  { \n if(defined $hashtable{$key}) \n   { \n  print \"the first none reapeating item is :\",\"$hashtable{$key}\\n\"; \n  last; \n   } \n  } \n \n#END"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"string sentence = \"am a?? software programmer\"; \n \n            char character; \n \n            for (int i = 0; i < sentence.Length; i++) \n            { \n                character = sentence[i]; \n                string restOfSentence = sentence.Substring(i + 1); \n \n                if (!restOfSentence.Contains(character)) \n                { \n                    break; \n                } \n            }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sites.google.com/site/spaceofjameschen/home/string/find-the-first-non-repeating-character-in-a-given-string----microsoft"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this is to the guy who hs put the question ..... m nt sure but i dont think ur code uld give the first non repeating character what if the string is: abcdeabcdegabcf now g and f both appear once but ur code i think does not check which comes first... i ve run the following code but not sure of the efficiency #include #include #include int main() {     char str[25];     int i,j,length = 0;     gets(str);     i=0;     while(str[i]!='\\0')     {                        length = length+1;                        i=i+1;     }     for(i=0;i    {                          if(str[i]!=7)                          {                                         for(j=i+1;j                                        {                                                                if(str[i]==str[j])                                                                {                                                                                  str[j]=7;//ascii for bell                                                                                  break;                                                                }                                         }                                         if(j==length)                                         {                                                      printf(\"\\n%c\",str[i]);                                                      break;                                         }                          }     }     getch();     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"namespace FirstNonRepeatedCharacter \n{ \n    class Program \n    { \n        public static char FirstNonRepeatedChar(string str) \n        { \n            char ch = ' '; \n \n            char[] charArray = str.ToCharArray(); \n            Dictionary chrHash = new Dictionary(); \n \n            foreach (char chr in charArray) \n            { \n                if (!chrHash.ContainsKey(chr)) \n                { \n                    chrHash[chr] = 0; \n                } \n                else \n                { \n                    chrHash[chr]++; \n                } \n            } \n \n            foreach (KeyValuePair kvp in chrHash) \n            { \n                if (kvp.Value == 1) \n                { \n                    ch = kvp.Key; \n                    break; \n                } \n            } \n \n            return ch; \n        } \n        static void Main(string[] args) \n        { \n            FirstNonRepeatedChar(\"siadjtlsrpqjkrp\"); \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"python:    map = {}   i =\"dsjiodsjdeurenreieiekjkejnmenr\"   for j in i:     if not j in map:         map[j] = 1     else:         map[j] +=1   for key in i:     if map[key] ==1:         print key"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"char check(string s) {     set myset;     unsigned int i=0;     while(i    {         if(myset.insert(s[i]).second == 0)             myset.erase(s[i]);         i++;     }     if(myset.size() > 0)         return *(myset.begin());     return '\\n'; // you can send any character which represents non-existant of non-repeating character in the string }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  #include  #include   using namespace std;  int main(int argc, char *argv) {     mapinput;      string s;     cout<<\"Enter the String:\";     cin>>s;      for(int i=0; i< s.length(); i++)          input[s[i]]++;      map::const_iterator iter;     for(iter=input.begin(); iter!=input.end();iter++)         if(iter->second == 1)         {cout<first; break;}          getch(); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static int firstnonrepeat(String target) {   char original =target.charAt(0);      for (int i=1; i< target.length(); i++)   {    if(original==target.charAt(i))    {     return i;    }    original = target.charAt(i);       }   return 0;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution With two Bitsets:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static Character noRepeat(String s) { \n \n//The linked hash set preserves insertion order. \n  LinkedHashSet chMap = new LinkedHashSet<>(); \n \n  char[] str = s.toCharArray(); \n \n  for (int i = 0; i < s.length(); i++) { \n \n   if (chMap.contains(str[i])) \n    chMap.remove(str[i]); \n   else \n    chMap.add(str[i]); \n \n  } \n \n  Iterator i = chMap.iterator(); \n \n  if (i.hasNext()) \n   return i.next(); \n  else \n   return null; \n \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void FirstNonRepeatedCharacter(String str){ \n  HashSet hs=new HashSet(); \n  boolean bool=false; \n  for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use below to get 1st unique value in O(n) \n \n        public char FirstDistinctCharacter(string str) \n        { \n            Hashtable ht = new Hashtable(); \n            List val = new List(); \n            foreach (char c in str.ToCharArray()) \n            { \n                try \n                { \n                    ht.Add(c, 1); \n                    val.Add(c); \n                } \n                catch (Exception) {  \n                    if(val.Contains(c)) \n                    val.Remove(c); \n                } \n            } \n            return (val.Count!=0)? val[0] : new char(); \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Nice"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=19332669","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"30","title":"write a sample code to find no of 'a' words in a sentence? Eg: If a sentence is given as \"I found an apple in a tree.\" The output is : 1 (not 2) We have to count no of words.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In python"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#!/usr/bin/perl -w  use strict;  my $sentence = <>;  my @words = split / /,$sentence; my $count = 0; foreach(@words) {  $count++ if(/^a$/); }  print \"The output is:\",\"$count\\n\";"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think we can just take the string as the input..... using String.split(\" a \") , we get an array of size n, then there are (n-1)  occurrences of \"a\""},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sites.google.com/site/spaceofjameschen/home/sort-and-search/find-no-of-a-words-in-a-sentence----microsoft"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int NumA(char *s) \n{ \nchar *length=s+strlen(s); \nint flag=0,count=0,len=0; \nchar *b; \nwhile(s2) \n{count++; \nflag=0; \nlen=0; \n} \nelse if(flag==1) \n{ \nflag=0; \n} \n} \n} \nreturn count; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"String str=\"I found an apple in a tree\";   String[] articles={\"a\",\"an\",\"the\"};   String[] inputString=str.split(\" \");   char inputChar='a';   int wordCnt=0;   for(String s: inputString){    if(!s.equalsIgnoreCase(articles[0])&&      !s.equalsIgnoreCase(articles[1])&&      !s.equalsIgnoreCase(articles[2])){     if(s.length()>1){      for(int i=0;i      if(inputChar==s.charAt(i)){        wordCnt+=1;        break;       }      }     }    }   }   System.out.println(\"word count:\"+wordCnt);  This works."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"String str=\"I found an apple in a tree\";   String[] articles={\"a\",\"an\",\"the\"};   String[] inputString=str.split(\" \");   char inputChar='a';   int wordCnt=0;   for(String s: inputString){    if(!s.equalsIgnoreCase(articles[0])&&      !s.equalsIgnoreCase(articles[1])&&      !s.equalsIgnoreCase(articles[2])){     if(s.length()>1){      for(int i=0;i      if(inputChar==s.charAt(i)){        wordCnt+=1;        break;       }      }     }    }   }   System.out.println(\"word count:\"+wordCnt);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import math  s = raw_input()  words = s.split() res=0 for i in range(0,len(words)):  if words[i]==\"a\":   res+=1 print res"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would suggest to use a window to processing the sentence plus a running count.  1. define 3 variable for the window and a pointer, say c0, c1, c2 and p. initialize them to -1. 2. start 1st character, p=1 and assign c2=s[p] and c1=s[p-1] and c0 = s[p-2] make sure the indexes are greater than zero before assignment. 3. if c1 equal to \"a\" and c0 = -1 or non-character and c2= -1 or non-charater, then add 1 to running count, and increase p by 3 and go back step 2. 4. if c1 not equal to \"a\" and c1 is character  a. and if c2 is non-character, then increase p by 2 and go back step 2.  b. otherwise, increase p by 3 and go back step 2. 5. do this until end of the sentence  please share and help to verify my solution. thx."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Aside from the normal case \" a \", you also need to check for the boundary cases which include when the \"a\" is in the beginning of the string, the only letter in the string and at the end. This is a possible solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int countOfCharInString(const char str[], char aChar) {   int count = 0;   const char *p = str;   while (*p) {     if (*p == aChar ) {       if ((p == str || *(p-1) == ' ') && (!*(p+1) || *(p+1)==' ')) {         count++;       }     }     p++;   }   return count; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I wrote this in 10 seconds max. Sharing it via CodeBunk codebunk.com/bunk#-Ix32gaWuvvRpliFmpeA"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class Program \n    { \n        public static int FindWordsContainingLetter(string sentence, char chr) \n        { \n            char[] sentArray = sentence.ToCharArray(); \n \n            int j =0; \n            int cnt = 0; \n            for (int i = 0; i < sentArray.Length; i++) \n            { \n                if (sentArray[i] != ' ') \n                { \n                    i++; \n                } \n                else if (sentArray[i] == ' ' && i - j > 1) //ignore single letters \n                { \n                    if (FindCharHelper(sentArray, j, i - 1, chr)) //i is sitting at space so decrement before passing \n                    { \n                        cnt++; \n                    } \n                } \n            } \n \n            return cnt; \n        } \n \n        public static bool FindCharHelper(char[] wordArray, int strt, int end, char chr) \n        { \n            bool found = false; \n            for (int i = strt; i < end; i++) \n            { \n                if (wordArray[i] == chr) \n                { \n                    found = true; \n                    break; \n                } \n            } \n \n            return found; \n        } \n \n        static void Main(string[] args) \n        { \n            FindWordsContainingLetter(\"Does this string contain words with letter i\", 'i'); \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int countAWords(String st) {   String[] strarr=st.split(\"\\\\s\");   int count=0;   for(int i=0;i   if(strarr[i].equalsIgnoreCase(\"a\")) {     count++;    }    else {     continue;    }   }   return count;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can separate the words and then check if its an 'a' word. We will have to parse the sentence atleast once. public static String CountAs(String words) {   char[] letters = words.toCharArray();   int start = 0;   int end = 0;   int count = 0;   while (end < letters.length) {    if ((letters[end] == ' ' || letters[end] == letters.length - 1)) {     if (chkForA(letters,start,end-1)) {      count++;      start = end + 1;           } else {      start = end + 1;           }     }    end++;   }      if (chkForA(letters,start,end-1)) {    count++;   }   return count;  }   private static boolean chkForA(char[] letters, int start, int i) {   if((start == i) && letters[start] == 'a')   return true;   else     return false;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Takes the sentence and the searched word (key) and returns the count of the key."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"private static int HowManyA(string text) \n        { \n            if (String.IsNullOrEmpty(text)) \n                return 0; \n \n            var word = \"\"; \n            var count = 0; \n            foreach (var t in text) \n            { \n                if (t != ' ')                \n                    word += t;               \n                else  \n                { \n                    if (word == \"a\") \n                        count++; \n                    word = \"\"; \n                } \n            } \n            return count;"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=19079665","download_status":"DOWNLOAD_DONE","votes":"4","answersCount":"25","title":"If a linkedlist is having loop, how to find the last node of the loop .","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"Its easy take two pointers increment one pointer by one and the other pointer by two and then 1.First find the meeting point of these two pointers. 2.After finding the meeting point take the first pointer to the start that is head and then increment n1 and n2 both by one until they point to the same value  Here is the code LinkedListNode FindBeginning(LinkedListNode head) {   LinkedListNode n1 = head;   LinkedListNode n2 = head;      // Find meeting point   while (n2.next != null) {    n1 = n1.next;    n2 = n2.next.next;    if (n1 == n2) {     break;    }   }   // Error check - there is no meeting point, and therefore no loop   if (n2.next == null) {    return null;   }   /* Move n1 to Head. Keep n2 at Meeting Point. Each are k steps   /* from the Loop Start. If they move at the same pace, they must   * meet at Loop Start. */   n1 = head;   while (n1 != n2) {    n1 = n1.next;    n2 = n2.next;   }   // Now n2 points to the start of the loop.   return n2; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@zammer: care to give an example?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@Zammer but as its a linked list and you dont have index so the very next node of the 10th can also hold the same value as of 4th so how will you distinguish as if its the repeated one or the new one?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If you know at which node the loop originates then you can easily find the last node in the loop.  To find where the loop starts, apply the tortoise and hare concept of fast and slow pointer. When you run two pointers from the head with speed 1 and 2, they both meet at a certain node say X.  Now this node X will be at the same distance from the origin of loop as distance between head and origin of loop.  In your case above, the two pointers meet at node 8.  8->9->10->4 1->2->3->4  These lengths will always be same. Try any case you like.  Cheers"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ListNode* loopLastNode(ListNode *head) {  ListNode *snode = head;  ListNode *qnode = head->next;  int scount = 1;   while (qnode && snode && qnode!=snode) {   ++scount;   snode = snode->next;   qnode = qnode->next;   if (!qnode)    break;   qnode = qnode->next;  }   if (!qnode || !snode)   return NULL;    int qcount = 1;  qnode = qnode->next;  while (qnode != snode) {   ++qcount;   qnode = qnode->next;  }   int maxcount = max(qcount,scount);   qnode = snode->next;  for (int i=0; i  qnode = qnode->next;    snode = head;  for (int i=0; i  snode = snode->next;   while (qnode->next != snode->next) {   qnode = qnode->next;   snode = snode->next;  }   return qnode; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorry for my poor english  1) find the loop and the specific node 2) find the intersection of the loop list and the orginal list     1.scount Nodes from orginal list head to the specific node     2.qcount Nodes from loop list head to the specific node     3.forward snode or qnode until snode and qnode have same count of nodes to the specifice node     4.forward snode and qnode until the intersection"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is my solution. I use a implicit HashTable."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a way that came to my mind. -Start traversal. -Keep track of current pointers in the process, Lets say a hash set allHashsets. -if allHashsets contains next pointer. current element is the last element  in the example: 1-->2-->3-->4-->5-->7-->8-->9-->10--> check if next pointer is in the hashset? the pointer for 1 will not be in the hash set so this means 1 is not the last element. add the pointer for 1 in the hashset. when the traversal reaches 10, the next pointer will be in the hashset. this means the last element is the current one."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"amarendra"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think it is very simple.Just find out the intersection point in this case.  in the process of finding intersection point we should just keep track of previous node whose next node is the intersection point. here is the code.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a simple approach that is not cryptic at all and everybody should be able to understand.  1. One slow 1x and one fast pointer 2x. For instance, start slow one from first and fast one from second node.  2. When they meet, that has to be inside the loop. Say, they meet at node X.  3. Starting from X go to next until you come back to X again. Keep a count of number of other nodes you hit. Say, that's N. N is the number of nodes in the loop minus 1(X).  4. Take 2 pointers p1 = StartNodeOfLinkedList and p2 = StartNodeOfLinkedList.next().next()...N times.  5. Increment p1 an p2 until p2.next() == p1. p2 is the last node of the loop."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"Run two pointers from the head of the Linked List. One pointer traverses one node at a time and the other pointer traverses two nodes at a time. If the two pointers meet at a particular node in the linked list, suggests that the Linked list is circular."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=19128663","download_status":"DOWNLOAD_DONE","votes":"-3","answersCount":"15","title":"A large character array is there in which there are spaces in between the character like ab   c      d ...etc  Write a method to search any character in the above array in O(n).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Linear search, complexity O(N). Is the array sorted, except the spaces? If, yes binary search, and at each step check if you found a space, in which case move one position to the left, or to the right."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@zammer: what does element refer here?Does it mean character?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What is unique about this problem? just matching one character at a time and stopping when match is found is simple solution but doesn't it sound too simple?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I agree with Sumit"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This array should be sorted, not characters array, but strings array.  The solution can be found sites.google.com/site/spaceofjameschen/home/sort-and-search/find-string-in-a-sorted-array-interspersing-with-spaces"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please Explain Question With an example ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question would make more sense if it is sorted and requires better than O(n), for O(n) it's too simple"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If the array is sorted, then may be binary search is fine"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int findIndex(char[] A, char ch){ \n \nint low=0; \nint high=A.lengh()-1; \n \nwhile(low<=high) \n{ \nint mid=(high-low)/2 -low; \n \nif(A[mid]==ch){ \nreturn mid;} \n \nelse if (A[mid]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using Binary Search"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=18781674","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"14","title":"Given a list of n points in 2D space. Lets call them (X1,Y1), (X2,Y2) .... (Xn,Yn). Find the optimal way to retrieve the result of following query.  SELECT min(X) FROM (2D Points) WHERE Y between Ymin and Ymax.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"This problem can be solved by  segment tree and ST(dynamic programming solution)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Hint : Convert Y's in to 1...N ( or Maybe 1.....n , n < N , in case of duplicate Y's ) indexes And Use segment trees !"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Am just confused, why is this not the problem equal to finding minimum value of x in the set? If we have a set of records with say 2 columns, then between ymin and y max every entry should come. So simply finding x min should give us the answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"make a binary tree (inverted, child pointing to parent) with y's in leaf nodes in increasing order left to right, starting with leaf nodes build the tree with node values = min(x) between node leftmost desendent and right most decendent."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution was on the lines of Balanced BST. Each Node in BST will hold following values"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Be A the list of points \nXmin = A[0].x \nfoundOne = false \nfor each point p in A \n               if p.Y>= Ymin && p.Y <= Ymax  \n                        foundOne = true     \n                        if p.X < Xmin \n                                Xmin=p.X \nif !foundOne throw \"No points in the given interval\" \nreturn Xmin"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use a sweep line across the Y-axis. Sort the points by Y coordinate and then while moving the sweep line, keep inserting the x-coodinate into a BST. At any time, the minimum in the BST is the required point."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"The solution is pretty easy, unless there is a typo in the question: The condition in the SELECT clause is \"Y BETWEEN MIN(Y) AND MAX(Y)\", i.e. any X regardless of Y, because all the Y values are between Ymin and Ymax inclusive. Then the problem becomes finding the MIN(X) coordinates. Note that SQL BETWEEN condition is inclusive of the boundary values.  Then you can find the Xmin in O(n) time, just linearly search through the values and then save the Xmin,Y pairs. The problems mentions the duplicates, so instead of a single Xmin,Y coordinate, we need to save all of them. Here is the code in C++11:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17243670","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"5","title":"Given a pattern P and a text T, WAP to return all indices from T where P matches.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Standard pattern matching problem. Use Rabin Karp or KMP algorithm."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use kmp"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Naive implementation. When in doubt just brute"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"List IsMatch ( char[] Text, char[] P) {     List indicesList = new List<>;     a = Text.Length;      b = P.Length;     int checkSumTemp = 0;     int checkSumP = 0;       for(int i = 0; i< b; i++)     {     checkSumTemp += (int)Text[i];           checkSumP +=  (int)P[i];     }     for(int i = 0; i<=a-b;i++)     {          if(checkSumTemp == checkSumP)          {                  for(int j = i; j               {                   if(Text[j]!=P[j-i]) break;                 }                if ( j==i+b )                       {                      indicesList.Add(i);                  }          }         checkSumTemp -= Text[i];         checkSumTemp += Text[i+b];     }   return indicesList; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"String pattern = \"AAB\"; \n  String text = \"AACBAABDJHAAB AAB\"; \n \n  int patternLength = pattern.length(); \n  int startIndex = 0; \n \n  for (int textIndex = 0; textIndex < text.length(); textIndex++) { \n \n   if (textIndex + patternLength <= text.length()) { \n    String subString = text.substring(textIndex, textIndex \n      + patternLength); \n    if (pattern.equalsIgnoreCase(subString)) { \n     System.out.println(textIndex); \n    } \n   } \n  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=17338665","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"22","title":"Position of Knight is given on a chessboard. Return me something (adjacency matrix or list or anything) which shows all the positions the knight can reach upto from a given position. I must be able to tell, from what is returned, if the position is reachable or not and if reachable I must be able to trace the path from given position to target position   <> For example if 4 cells are reachable from a cell A, then these 4 cells become children of A. Then from a cell, say B, out of these 4 cells, you can reach 2 more cells: C and D. Then C and D become children of B. Likewise program need to return me a DS. I have given a valuable hint with this follow-up. I hope this will help","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A knight can move in 8 directions from the current position 2 in front, 4 sideways and 2 backwards. Thus we can easily calculate the position using recursion from the current position where a knight can move.  Here is a algo that I have thought void KnightMove(int **a, int m, int n, int currx, curry) {  if(currx<0 || curry <0)   return;  if(currx >= n || curry >=m)    return;  if(a[currx][curry] == VISITED)   return;  else  {   a[currx][curry] == VISITED;    //move forward   KnightMove(a, m, n, currx-1, curry+2);   KnightMove(a, m, n, currx+1, curry+2);    //move sideways   KnightMove(a, m, n, currx-2, curry+1);   KnightMove(a, m, n, currx-2, curry-1);   KnightMove(a, m, n, currx+2, curry+1);   KnightMove(a, m, n, currx+2, curry-1);    //move backward   KnightMove(a, m, n, currx-1, curry-2);   KnightMove(a, m, n, currx+1, curry-2);     } }  Please do let me know If I am missing something here"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do you need all the places that the knight can eventually reach, or all the places the knight can reach in one move? A knight can eventually reach any square on a standard chessboard."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@aka: Trust me this will eventually stop :). And it will stop when u reach invalid cells .  Invalid cell means something like: (-1, -2) or (8, 8)  or (-1, 2) etc etc... I hope this makes it clear."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This problem reduces to the standard BFS algorithm with the only difference being the edges are not present! Instead of going out from the source square following the adjacent edges we need to follow the knight move pattern and find the adjacent squares that are reachable from any square by the knight."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static bool FindAllPos(int x, in y, int[,] reachTable) {    //x= 1,...,8; y= 1,...,8    if(x<1||x>8||y<1||y>8) return false;    if( reachTable[x-1,y-1] !=0) return false;    bool flag = false;    for( int i =-2;i<=2;++)    {        for(int j = -2; j<=2; ++j)      {         if( (i*i)+(j*j) != 5 ) continue; //Knight always jump this distance. Total 8 cases.          if( FindAllPos(x+i, y+j, reachTable) )         {  //reach table element remember the previous position             reachTable[x+i,y+j] = x + (y-1)*8; // To identify 8*8 tatal 1,2,3,...,64 possible positions              flag = true;          }         }   }   return flag; }  public static main() {  int x = 2; int y =3;    int[8,8] reach_table = new int[8,8]{0};    FindAllPos(x,y, reach_table); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Use BFS to compute all the positions that are reachable from the knight. \n2) For each position, store it in a Hash \n3) Compute a trie structure when doing BFS, basically is you can reach positions Y and Z from X, then X has two children Y and Z; and also maintain parent pointer for Y and Z which point to X"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's my solution. I gave in interview adjacency Iist based solution.  Here I am giving both, adjacency-list and adjacency-matrix based solution for your reference:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16898662","download_status":"DOWNLOAD_DONE","votes":"-2","answersCount":"13","title":"find a pattern in byte array and change that pattern in place (do not use temp array or variable) for example, find pattern 0,0,3 in an byte array and replace it with 0,0 should be o(n) my solutions :","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"this is O(n*m): for each character in input string you are making LengthOfPattern comparisons. Probably they wanted to see you implementing KMP but that would be too much for an interview?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"yeah,,, but can u change all appearance of 0,0,3 with complexity O(n).... its above this complexity"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my version.   Output:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"array {a1, a2, .... an}, if ak, ak+1, ak+2 is the pattern, replace ak, ak+1 with your wanted number, set ak+2=' ' (space). This is the first iterate. During the second iterate, once meet space element, move the next element backward one step and so on.  O(n) for each iterate."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is my take."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"while (i{  if (arr[i]==0 && arr[++i]==0 && arr[++i]==3) arr[i]=0 }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16634662","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"7","title":"Write a method that can sort an array of items that can be compared with each others.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I think, the question was about to find a sorting method which can sort items having non-trivial comparison method. Thats why question says that \"tems can be compared with each others.\" Hence any sorting technique can be used with the tweak that now instead of assuming the trivial comparison (by way of > , < ), the sorting method must take a function (or function pointer) which does the comparison on the items being sorted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Any comparison sort will do. Heap or quick sort will be good."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"question seems to be wrong ......... otherwise bubble sort will be suitable for ur queiry........"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"One should prefer stable sort in such questions, i think."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"is it asking to implement the compare function used in qsort()?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question is more open ended, you can use any kind of sorting method on it but the best complexity with true in place sort will be done using Quick sort with complexity of O(nlogn)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int main() {   int array[100], n, c, d, swap;     printf(\"Enter number of elements\\n\");   scanf(\"%d\", &n);     printf(\"Enter %d integers\\n\", n);     for (c = 0; c < n; c++)     scanf(\"%d\", &array[c]);     for (c = 0 ; c < ( n - 1 ); c++)   {     for (d = 0 ; d < n - c - 1; d++)     {       if (array[d] > array[d+1]) /* For decreasing order use < */       {         swap       = array[d];         array[d]   = array[d+1];         array[d+1] = swap;       }     }   }     printf(\"Sorted list in ascending order:\\n\");     for ( c = 0 ; c < n ; c++ )      printf(\"%d\\n\", array[c]);     return 0; }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16632662","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"2","title":"Design and code a way to suggest predictions for your query as you type in real time (such as Google Instant).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I'd base it on a trie structure, and to every trie node attach a measure of how often the node is visited. Then you could for example convert this measure to percentages, and visit the paths with the highest percentages until you've reached a set percentage or found a set number of paths, then display those paths as suggestions.  For example, if the user types auto, then the path for 'm' might look like this:  (16) m    (6)o (6)b (6)i (6)l (6)e   (10)a        (10)t            (3)i (3)c           (5)e (5)d  It includes automobile automatic and automated; each branch branches into further options, all of which are added up to form the percentage of queries.  Not fully thought out yet, but something along those lines."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I think we can use edit distance algorithm, so it find the distances between the typed words and the most researched words."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16628663","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"7","title":"Design and code a way that Facebook could use to suggest new friends you might know.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I would start with friends of friends as potential suggestions. These can all be retrieved by a breadth-first search restricted to a depth of 2. In that same breadth-first search, I would also calculate how many of the user's friends know each potential suggestion and rank the suggestions by this number. Simply put, if you're not friends with someone who is friends with 30 of your friends, that's usually a better person to recommend to you than someone who is friends with only one person you know.   We could modify the approach above to be more likely to recommend people that are friends with people you interact with a lot. The BFS would be the same, but the ranking algorithm could, instead of giving each potential suggestion 1 ranking point per mutual friend, vary the points based on how much you interact with the mutual friend.  We might consider being less likely to recommend friends that have been recommended recently and were not added by the user. We might also throw in some element of chance to give lower-ranked recommendations the possibility of showing up occasionally.  We might also consider removing from recommendations people you've un-friended in the past. People that you've blocked definitely shouldn't show up.  I'm sure Facebook's recommendation system is a lot more complicated than that and probably considers tens or hundreds of factors. It might even use machine learning to learn the factors that are most likely to make users add the people recommended to them. These are just some starting thoughts."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"We could use Graph Transitive closure property. Which says if A is friends with B and B is friends with C, then A is friends with C. C would be our suggestion to the user. We can come u with a Connection Adjecency Matrix which can be written as  Connec[i][j] = Connection[i][j] | (Connect[i][k] && Connect[k][j])  For a user I we can suggest all the connections J which are already not in its list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Fixed indention  in above post!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"We can use graph and and BFS to suggest friends."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16592696","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"14","title":"Is this code working fine ? if yes/no give reason ? #include using namespace std; struct node {     int a;     int b; }; typedef struct node Node; void swap(void *a,void *b) {     void *temp;     temp=a;     a=b;     b=temp; } int main() {     Node *a1,*b1;     a1=(Node*)malloc(sizeof(Node));     b1=(Node*)malloc(sizeof(Node));     a1->a=10;     a1->b=20;     b1->a=30;     b1->b=40;     cout<a<<\"   \"<b<    cout<a<<\"   \"<b<    swap(a1,b1);     cout<a<<\"   \"<b<    cout<a<<\"   \"<b;  } I surprised to see the ans after compiling this code ... i think u enjoy this code... :)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"This is because you are doing a using namespace std, which I believe makes the code use std::swap, rather than the swap you defined.  Try this:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"This code is not working you forgot to add header file for malloc. You will have to add  #include in the starting of code. after that code is working fine. Complete running code at my terminal.  #include #include using namespace std; struct node{     int a,b; }; typedef struct node Node; void swap(void *a,void *b){     void *temp;     temp=a;     a=b;     b=temp; } int main() {     Node *a1,*b1;     a1=(Node*)malloc(sizeof(Node));     b1=(Node*)malloc(sizeof(Node));     a1->a=10;     a1->b=20;     b1->a=30;     b1->b=40;     cout<a<<\" \"<b<    cout<a<<\" \"<b<    swap(a1,b1);     cout<a<<\" \"<b<    cout<a<<\" \"<b;     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Your swap code doesn't work. Actually, the parameter passed through the function is passed by value, instead of refence, even if it's a pointer. As a result, what your code does is just to swap the two temporary pointers, which are destroyed when they're out of function scope."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think because of void pointer. No Type casting done."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What worked for me 1.Explicitly calling swap using swap((void *)a,(void *)b); 2.Using memcpy to physically change contents of the objects. Code below. Tested on c++ in codepad.com"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Perfect. Interesting problem, it used std's swap and gives proper output. But actual intension of writing swap function is not being used.   Thanks for posting this problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"C++ std::swap function gets called, so values are swapped because std::swap function actually swaps these pointers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this is just the issue of right using pointers. Just change the relative code to:    void swap(void **a,void **b){     void *temp;     temp=*a;     *a=*b;     *b=temp;    }  And then use. swap(&a1,&b1);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-4","title":"In your swap function pass parameter by ref or in C pass pointer to pointer to get the correct result."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16484670","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"28","title":"How to check if a binary tree is a binary search tree?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"You simply take the inorder traversal of the binary tree and check if it is sorted. If yes it is a binary search tree else no."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Here is an intelligent algo I have seen somewhere in the net.  As you navigate down the tree, narrow the min and max conditions based on current node. Left should be always less than current node. And right should be greater."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool IsTreeBST(TreeNode * root) \n{ \nif (NULL != root->left)  \n{ \nif (root->left->value > root->value) \nreturn false; \n \nreturn IsTreeBST(root->left); \n} \n \nif (NULL != root->right)  \n{ \nif (root->right->value <= root->value) \nreturn false; \n \nreturn IsTreeBST(root->right); \n} \n \nreturn true; \n} \n  \nclass TreeNode \n{ \npublic: \nint value; \nTreeNode * left; \nTreeNode * right; \n};"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"do inorderraversal and check if it is sorted or not"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static bool IsItBST(Node root) \n        { \n            if (root == null) return true; \n            if (root.left == null) \n            { \n                if (root.right == null) return true; \n                else if (root.right.data < root.data) return false; \n            } \n            else \n            { \n                if (root.left.data > root.data) return false; \n                if (root.right == null) return true; \n                if (root.right.data < root.data) return false; \n            } \n \n            if (!IsItBST(root.left)) return false; \n            if (!IsItBST(root.right)) return false; \n            return true; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool isValidBST(TreeNode *root) {         // Start typing your C/C++ solution below         // DO NOT write int main() function   //if (root == NULL) return true;   return isValid(root, -1*INT_MAX, INT_MAX);                         }   bool isValid(TreeNode *root, int min, int max){    if (root == NULL) return true;   if (root->val <= min || root->val >= max) return false;   if (root->left) {    if (root->val < root->left->val) return false;        }   if (root->right) {    if (root->val > root->right->val) return false;        }   bool ret = true;    ret &= isValid(root->left, min, root->val);   ret &= isValid(root->right, root->val, max);    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// took from leetcode"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If you do this recursively, this only need one line, and time complexity is O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nusing namespace std; \n/* \nHow to check if a binary tree is a binary search tree \n*/ \n \ntypedef struct node_s { \n int value; \n struct node_s *left; \n struct node_s *right; \n}BSTNode, *BSTree; \n \nint tree_search(BSTree T, int value, BSTNode **p, BSTNode *f) { \n if(!T) { \n  *p = f; \n  return 0; \n } else { \n  if(T->value == value) { \n   *p = T; \n   return 1; \n  } else if(value < T->value) { \n   return tree_search(T->left, value, p, T); \n  } else { \n   return tree_search(T->right, value, p, T); \n  } \n } \n} \n \nint tree_insert(BSTree *T, int value) { \n BSTNode *p = NULL; \n if(!tree_search(*T, value, &p, NULL)) { \n  BSTNode *s = (BSTNode*)malloc(sizeof(BSTNode)); \n  s->value = value; \n  s->left = NULL; \n  s->right = NULL; \n  if(!(*T)) \n   *T = s; \n  else if(value < p->value) \n   p->left = s; \n  else \n   p->right = s; \n  return 1; \n } \n return 0; \n} \n \nbool is_bst = true; \nvoid check_tree_is_bst(BSTree T) { \n if(T) { \n  check_tree_is_bst(T->left); \n  if(T->left) { \n   if(T->left->value > T->value) { \n    is_bst = false; \n    return; \n   } \n  } \n  if(T->right) { \n   if(T->right->value < T->value) { \n    is_bst = false; \n    return; \n   } \n  } \n  check_tree_is_bst(T->right); \n } \n} \n \nint main(int argc, char *argv[]) { \n int a[] = {5, 9, 13, 4, 6, 7, 34, 12, 25, 16}; \n int len = sizeof(a) / sizeof(int); \n int i; \n BSTree T = NULL; \n for(i = 0; i < len; i++) \n  tree_insert(&T, a[i]); \n check_tree_is_bst(T); \n if(is_bst) \n  cout << \"yes\" << endl; \n else \n  cout << \"no\" << endl; \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nstruct bst \n{ \n int data; \n struct bst *left; \n struct bst *right; \n}; \ntypedef struct bst node; \nnode *buildtree(int val,node *parent,int flag) \n{ \n node *ptr=(node*)malloc(sizeof(node)); \n ptr->data=val; \n ptr->left=NULL; \n ptr->right=NULL; \n if(flag==1) \n { \n  parent->left=ptr; \n } \n else if(flag==2) \n { \n  parent->right=ptr; \n } \n return ptr; \n} \nnode *inorder(node *ptr) \n{ \n node *ptr1=ptr; \n if(ptr1==NULL) \n  return NULL; \n \n     inorder(ptr1->left); \n  printf(\"%d   \",ptr1->data); \n  inorder(ptr1->right); \n} \nint isbst(node *hptr) \n{ \nint max=0; \n \nmax=hptr->data; \n \nif(hptr==NULL) \nreturn 0; \n \nif(hptr->left==NULL) \nreturn 0; \n \nif(hptr->right==NULL) \nreturn 0; \n \n \n \nelse if(max>hptr->left->data && maxright->data); \n { \nisbst(hptr->left); \nisbst(hptr->right); \n } \n \nelse \n return 0; \n \n \n} \nint main() \n { \nint x; \n node *a1,*b1,*e1,*f1,*c1,*d1,*a,*b,*c,*d,*e,*f,*ptr,*ptr1,*root1,*ptr2; \n node *root=(node*)malloc(sizeof(node)); \n root1=(node*)malloc(sizeof(node)); \n ptr=root; \n root->data=10; \n root->left=NULL; \n root->right=NULL; \n a=buildtree(200,root,1); \n b=buildtree(300,root,2); \n c=buildtree(250,a,1); \n d=buildtree(310,a,2); \n e=buildtree(410,b,1); \n f=buildtree(450,b,2); \n printf(\"first tree:\"); \n //inorder(ptr); \n x=isbst(ptr); \n if(x) \n printf(\"yes\"); \n else \n       printf(\"no\"); \n       }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n \nstruct node \n{ \nint data; \nstruct node *left; \nstruct node *right; \n}; \n \nstruct node* createnode(int ch,struct node *parent,int flag) \n{ \n struct node *nptr; \n nptr=(struct node*)malloc(sizeof(struct node)); \n nptr->data=ch; \n nptr->left=nptr->right=NULL; \n  if(flag==1) \n { \n  parent->left=nptr; \n } \n else \n  parent->right=nptr; \n return nptr; \n} \nvoid inorder( struct node * root) \n{//printf(\"hiihihi\"); \n if(root==NULL) \n  return; \n inorder(root->left); \n printf(\"%d\\n\",root->data); \n inorder(root->right); \n} \nint isBSTHelper(struct node  *p, int low, int high) { \n  \n printf(\"max :%d min:%d\\n\",high,low); \n  if(p==NULL) \n   return 1; \n \n  if (low < p->data && p->data < high) \n    return (isBSTHelper(p->left, low, p->data) && \n           isBSTHelper(p->right, p->data, high)); \n  else \n    return 0; \n} \n  \nint isBST(struct node *root) { \n   \n  return isBSTHelper(root, -1, 999999); \n} \nint main() \n{   int m; \n struct node *root,*p1,*p2,*p3,*p4,*p5,*p6,*p7,*p8,*p9,*p10,*p11; \n struct node *iptr,*j,*d; \n root=(struct node*)malloc(sizeof(struct node)); \n root->data=5; \n root->left=root->right=NULL; \n p1=createnode(2,root,1); \n p8=createnode(15,root,2); \n   p2=createnode(1,p1,1); \n   p3=createnode(4,p1,2); \n p4=createnode(14,p8,1); \n p5=createnode(17,p8,2); \n      j=root; \n        iptr=root; \n  inorder(iptr); \n  m=isBST(j); \n  if(m) \n  printf(\"it is bst\"); \n  else \n printf(\"it is not bst\"); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"o(1) space and O(n) time complexity. Every node visited once."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is another recursive approach but does not use any min max variables.   The approach is 1. Figure out if the current node is following BST rule which is left.data <= root.data <= right.data 2. Now do this for left child and right child and return the result of steps 1 & 2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool isBST(struct node* root) { \n \n if(root == NULL) \n  return true; \n \n if(root->left && root->data < max(root->left)) { \n  return false; \n } \n \n if(root->right && root->data >= min(root->right)) { \n  return false; \n } \n \n return isBST(root->left) && isBST(root->right); \n} \n \nint max(struct node* root) { \n \n if(root == NULL) { \n  return -1; \n } \n \n while(root->right) { \n  root = root->right; \n } \n return root->data; \n} \n \nint min(struct node* root) { \n \n if(root == NULL) { \n  return -1; \n } \n \n while(root->left) { \n  root = root->left; \n } \n return root->data; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int isbst (struct tree *root) { \n    if (root == NULL)  \n        return 1; \n    if (root->left == NULL &&  \n        root->right == NULL) \n        return 1; \n    else if (root->left == NULL) { \n        if (root->data < root->right->data)  \n            return isbst(root->right); \n        else  \n            return 0;     \n    } else if (root->right == NULL) { \n        if (root->data >= root->left->data) \n            return isbst(root->left); \n        else \n            return 0;     \n    } else { \n        if (root->data < root->right->data && \n                root->data >= root->left->data)  \n            return (isbst(root->left &&  \n                    isbst(root->right)); \n        else  \n            return 0; \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this is simple, just use the defination of bst that the data of the root is smaller than the data stored in its left child if there is left child, and the same the data store in its rigth child is larger than the data of root, then check this recursively and finally you will get the result, here are my codes, if there is anything wrong, please let me know, thank you!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"bool ifbtreeisbst(treenode* root, int & flag)  {   if(!root)    return false;    if((root->left && (root->left->data > root->data)) || (root->right && (root->right->data < root->data)))    flag=1;    if(flag==1)   {    return false;   }   else   {    ifbtreeisbst(root->left,flag);    ifbtreeisbst(root->right, flag);   }   return true;     }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16274733","download_status":"DOWNLOAD_DONE","votes":"4","answersCount":"16","title":"waf to rotate array by k unit size of array n=6 1 2 3 4 5 6 k=2 output 5  6 1 2 3 4","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"20","title":"1. reverse the array will become 654321 2. reverse first k numbers in this array will become 564321 3. reverse n-k numbers in above array becomes 561234  run time O(n) space complexity O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"9","title":"check this out .. codingskills4u.com/2013/01/rotate-array-by-k-elements.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"My Idea is that: 1> If the k is the relative prime of len, you just keep move the element to its next place one by one, after len times, all elements are in place. 2> If the k is not relative prime of len, find the gcd of k and len, divide the array into gcd number of sub virtual arrays, in which sub array i is in the form of array[i+k*p], where i is in [0, gcd-1], representing the sub array, while  p is in [0, len/gcd-1], the index inside the subarray. For each sub array[i], the rotate happens only in 1 increase its index p, so you can use the same logic in 1> to rotate each sub array.  Here is my uCode:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Test result: orig 1234567890 ==>  0123456789 in 1 right shift orig 1234567890 ==>  9012345678 in 2 right shift orig 1234567890 ==>  8901234567 in 3 right shift orig 1234567890 ==>  7890123456 in 4 right shift orig 1234567890 ==>  6789012345 in 5 right shift orig 1234567890 ==>  5678901234 in 6 right shift orig 1234567890 ==>  4567890123 in 7 right shift orig 1234567890 ==>  3456789012 in 8 right shift orig 1234567890 ==>  2345678901 in 9 right shift"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include int reverse_elements(int a[20],int first,int last) {     int temp;     while(first    {         temp=a[first];         a[first]=a[last];         a[last]=temp;         first++;last--;     }     return 0; } int main() {     int a[20],len,i,k;     printf(\"enter the length of the array:\\n\");     scanf(\"%d\",&len);     printf(\"enter the kth element:\\n\");     scanf(\"%d\",&k);     printf(\"enter the array elements:\\n\");     for(i=0;i    scanf(\"%d\",&a[i]);     reverse_elements(a,0,len-1);     reverse_elements(a,0,k-1);     reverse_elements(a,k,len-1);     printf(\"result array:\\n\");     for(i=0;i    printf(\"%d\\t\",a[i]);     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nusing namespace std; \n \n \nvoid swp(int * begin, int * end) { \n int temp; \n while(begin < end) { \n  temp = *begin; \n  *begin++ = *end; \n  *end-- = temp; \n } \n} \n \nvoid rotate(int * array,int k, int length) { \n cout<<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class Program \n    { \n        static void Main(string[] args) \n        { \n \n            int[] arr, newarr; \n            int k = 4; \n            arr = new int[7] { 10, 12, 25, 12, 56, 17, 20 }; \n            newarr = new int [7] {0,0,0,0,0,0,0}; \n            int p = k % arr.Length; \n            for (int i = 0; i < arr.Length; i++) \n            { \n                newarr[i] = arr[p]; \n                p++; \n                if (p == arr.Length-1) \n                    p = 0; \n            } \n            Console.WriteLine(arr); \n            Console.WriteLine(newarr); \n \n        } \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def rotate(a, k):     \n    return [ a[(i-k)%len(a)] for i in range(len(a))]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this swaps the data alone not the node.... #include #include using namespace std; struct list {     int data;     struct list *next; }*head=NULL; struct list *insert(struct list *head,int n) {     struct list *temp,*t;     if(!head)     {         head=new list;         head->data=n;         head->next=NULL;     }     else     {         temp=head;         while(temp->next)temp=temp->next;         t=new list;         t->data=n;         t->next=NULL;         temp->next=t;     }     return head; } int replace(struct list *head,int n) {     int temp=0;     struct list *ptr=head,*ptr1=head,*t,*tt;     while(ptr1->next)     {         if(++temp>=n)         ptr=ptr->next;         ptr1=ptr1->next;     }temp=n;ptr1=head;     while(--temp)     ptr1=ptr1->next;     temp=ptr1->data;     ptr1->data=ptr->data;     ptr->data=temp;     return 0; } int display(struct list *head) {     struct list *temp=head;     while(temp)     {         printf(\"%d\\t\",temp->data);         temp=temp->next;     }     return 0; } int main() {     int i,n,d;     printf(\"enter the number of elements in the linked list:\\n\");     scanf(\"%d\",&n);     for(i=0;i    {         scanf(\"%d\",&d);         head=insert(head,d);     }     printf(\"enter the kth element to be replaced:\\n\");     scanf(\"%d\",&d);     replace(head,d);     printf(\"thus the resultant linked list is:\\n\");     display(head);     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n \nint main() { \n \n    int arr[] = {1,2,3,4,5,6}; \n    int n = 6; \n \n    int *result = new int[6]; \n    int resultIndex = 0; \n    for(int i = 0; i < 6; i++) { \n        resultIndex = (i+5) % 6; \n        result[resultIndex] = arr[i]; \n    } \n \n    for(int i = 0; i < 6; i++) { \n        std::cout << result[i] << \" \"; \n    } \n \n    std::cout << std::endl; \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int j = totalCnt - noOfRotations; \nint i = 0; \nwhile (i < j) \n{ \nswap ( A[i], A[j]); \ni++; \nj++; \nif(j == totalCnt) \n j = totalCnt - noOfRotations; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16392679","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"19","title":"In an interview I was asked a question on strings. The problem is given a string s1= \"ABCDBCCDABCD\". and a pattern \"BC\". we have to replace this pattern with other string (\"UVW\" or \"U\"or \"uv\"). Do this without creating new string. Take the case to   replace \"BC\" with  following   a) \"uvw\"   s1=AUVWDUVWCDAUVWD .  b)  \"U\"    s1=AUDUCDAUD .  c)  \"UV\"   s1=AUVDUVCDAUVD .   This was my first question and I was stuck on this. :(","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Question is similar to one of question of Cracking The Code Interview book Replace all the space in string with \"%20\" without using extra string ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Pre-calculate the space required with a first pass: O(N). Lets say the extra space required is X. (X can be +ve, -ve or 0)  Pseudo Algorithm:  Case a (X is positive):  Allocate X additional memory (or N+X new memory, as per interviewers feedback).   Have two pointers one at the end of the memory and another at the end of the actual text   i.e."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//str is given string and word is string to be replaced with. \npublic void replaceStringPattern(char[] str,char[] word){ \n int count=0,length=str.length,lengthOfWord=word.length; \n //count how many times pattern is repeated. \n for(int i=0;i=1;i--){ \n  if(str[i]=='C' && str[i-1]=='B'){ \n   int k=lengthOfWord-1; \n   while(k>=0){ \n    s[newLengh-1]=word[k]; \n    k--; \n    newLength--; \n   } \n  i--; \n  } \n  else{ \n   s[newLength-1]=s[i]; \n   newLength--; \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This could be the possible solution : (Assumption: Original string size 'N') 1) Calculate total no of BC 's in the given string s1 and store it in count variable. 2) -replace with 2 'u' or 1 'uv' if the count=1 => Size is s1  is still N -replace with 'uv' if the count=2=> Size of s1 is still N -replace with 3 'u' or 1 'uv'+1 'u' or 1 'uvw' if the count=3 => Size of s1 is still N. . . .  So on.  An algorithm on similar lines would work."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here goes the algorithm : 1) Count the total no of BC 's  in string s1 and store in count variable.  2)Let the string size be 'N' 3)Effective size change upon replacement with  -'u' is -1 as 2 characters 'B' and 'C' in 'BC' are replaced by only one charachter 'u' -'uv' is 0 -'uvw' is +1 4)Algorithm : if(N is even) { replace all 'BC' s with 'uv' s  } else if(N is odd) { replace one 'BC' with 'uv' , remaining half 'BC' with 'u' , remaining half 'BC' with 'uvw' }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I use kmp to make it, and I think first you should compute the length of target like 'BC' and then length of repalce strings like 'U', 'UV', 'UVW' and compare them to decide when find the target string, whether copy the string forward or backword, here is my program, time complexity is near to O(n) and space complexity is using by kmp of O(targe), and there is anything wrong, please let me know, thanks."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"As he clearly mentioned  not 2 create extra string, In Java we can use StringBuffer.  if(string.charAt[i] == B)    string.charAt[i] = \"uvw\";"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"char* replace_string(char* dst, char* tmpl, char *str) \n{ \n char* p1 = dst; \n char* p2 = tmpl; \n int count = 0; \n while(*p1) \n { \n  if (*p2 == 0) \n  { \n   count++; \n   p2 = tmpl; \n  } \n  if (*p1 != *p2) \n  { \n   p2 = tmpl; \n   p1++; \n  } \n  else \n  { \n   p1++; \n   p2++; \n  } \n } \n \n int tmpl_size = (int)strlen(tmpl); \n int src_size = (int)strlen(str); \n int dst_size = strlen(dst); \n int value = abs(tmpl_size - src_size); \n dst = (char*)realloc(dst, sizeof(char) * value * count + dst_size+1); \n \n p1 = dst; \n p2 = tmpl; \n while(*p1) \n { \n  if (*p2 == 0) \n  { \n   p2 = tmpl; \n   int location = (p1 - dst); \n   memcpy(p1 + value, p1, sizeof(value) * abs(dst_size - location)); \n   memcpy(p1 - tmpl_size, str, sizeof(char)* src_size); \n   p1 += value; \n  } \n  if (*p1 != *p2) \n  { \n   p2 = tmpl; \n   p1++; \n  } \n  else \n  { \n   p1++; \n   p2++; \n  } \n } \n return dst; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In C# string is immutable and you cannot modify existing string. So you have to use StringBuilder to do that. I am not sure if below answer is acceptable or not. Please provide your feedback."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \"stdafx.h\" \n#include  \n \nusing namespace std; \n \nvoid s_replace(char* s, const char* pattern, const char* replacement) \n{ \n int pattern_len = -1; \n while (pattern[++pattern_len] != '\\0') ; \n \n int replacement_len = -1; \n while (replacement[++replacement_len] != '\\0') ; \n \n int delta = replacement_len - pattern_len; \n \n int length = -1; \n while (s[++length] != '\\0') ; \n \n int i = -1; \n int j = 0; \n while (++i < length) { \n  if (s[i] == pattern[j]) { \n   if (j == pattern_len - 1) { \n    if (delta != 0) { \n     int start = length - 1; \n     int step = -1; \n     int end = (length + delta) - (i + 1); \n \n     if (delta < 0) { \n      start = i + 1; \n      step = 1; \n      end += i + 1; \n     } \n \n     length += delta; \n \n     int k = -1; \n     while (++k < end) { \n      s[start + delta] = s[start]; \n      start += step; \n     } \n    } \n \n    j = -1; \n    while (++j < replacement_len) \n     s[i - pattern_len + 1 + j] = replacement[j]; \n \n    j = 0; \n    i += delta; \n   } else \n    j++; \n  } \n } \n s[length] = '\\0'; \n} \n \nint _tmain(int argc, _TCHAR* argv[]) \n{ \n char* tmpl = \"ABCDBCCDABCD\"; \n char* pattern = \"BC\"; \n char* replacement = \"00\"; // \"UVW\"; \n \n char s[20]; \n strcpy_s(s, tmpl); \n \n cout << s << endl; \n \n s_replace(s, pattern, replacement); \n \n cout << s << endl; \n \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Can use regular expression to solve this. Below is Perl version -"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"spojsolutionsimple.blogspot.in"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16293680","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"10","title":"5. There Are N Coins On A Table. There Are Two Players A&B. You Can Take 1 Or 2 Coins At A Time. The Person Who Takes The Last Coin Is The Loser. A Always Starts First. 1. If N=7, Then A) A Can Always Win By Taking Two Coins In His First Chance. B) B Can Win Only If A Takes Two Coins In His First Chance. C) B Can Always Win By Proper Play. D) None of the Above. 2. A Can Win By Proper Play If N Is Equal To A) 13 B) 37 C) 22 D) 34 E) 48 3. B Can Win By Proper Play If N Is Equal To A) 25 B) 26 C) 32 D) 41 E) None 4. If N<4, Can A Win by Proper Play Always?Answer: Yes.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"B always wins.  B responds with the opposite play of A, so that after B's first turn there are 4 coins, then after B's second turn there is 1 coin.  B's strategy is the same for 10, 13, 16, etc.  A wins the variations on N=8 and N=9 by leaving 7 coins on the table after the first turn."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"1.C 2.E 3.A"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"CEA Let me explain this. The key is to understand N%3. Because everyone wants to get the status that there are 1 coins left, and the other one plays the next move. In this status, \"I\" can always win.  a)If the other played 1, I can play 2  b)If the other played 2, I can play 1. And I can esure that everystep could be divided by 3,because i can always play \"1+2\" no matter you play 1, or you play 2. So  a) IF N%3 = 0, i will play 2 first->(means n-2%3 = 1), and ensure all of next steps can be divided by 3  b)IF N%3 = 1, i can never win because i'm the first to play and b will ensure the each step could be divided by 3. c)IF N%3 = 2 , i will play 1 and rest steps are exactly the same as a described."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what do you exactly mean by \"proper play\"??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A player needs to make sure that after her move number of remaining coins is 1+3*N"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The loser sequence would be as bellow by proper play, if A plays first: ABBABBABBABBA A would be loser, only if its two predecessors are all Bs. Because whatever A takes 1 or 2,  B now becomes the first player for the rest of the coins, and according the definition of the list, it would be its next player as the loser."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I usually tend to ignore questions from India Microsoft as either they are totally out of scope for interview or too vauge"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how could the answer to the question \"if N<4, Can A Win by Proper Play Always?\" is Yes , for N=1 , there is no way that A can win."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Let us assume Both are intelligent players.  If the coins count is 1+3n ... the B can definitely win the game with proper play..  In this case b has to draw coins based on coin selection of A  if(A selects 1coin)  b has to take 2 coins  else   b has to take 1 coin Scenario 2 Coins count=1+3n+1 or 1+3n +2 A will win with proper play. A need to offer round figure of 1+3n back to B to win the game.  if"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16288668","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"30","title":"from given array of n elements find the maximum element for each consecutive sub-array of k elements. eg. array=[6,5,4,3,2,1] k=3 ans=6 5 4 3 explanation:- 6 from array [6,5,4] 5 from array[5,4,3]","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"This can be done in O(n) using a deque whose front will always hold maximum in current window. Space Complexity - O(k) ------------------------------------------------------------------------------------------------------------"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"def findMaxinK(a,k): \n    max_ = a[0] \n    for i in range(len(a)): \n        if max_"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The complexity of DashDash's solution is O(nlog(k)), Jack's complexity is O(nk). Is there solution with complexity O(n)?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class test{ \n  public static void main(String[] args){ \n// ArrayList a=new ArrayList(); \n   int max=Integer.MIN_VALUE, index=-1; \n int[] a={6,5,2,3,1,0}; \n int k=2; \n System.out.println(a.length-k); \n for (int i=0; imax){ \n     max=a[i+j]; \n     index=(i+j); \n    } \n  } \n  else \n   if(a[i+k]>a[index]){ \n    max=a[i+k]; \n    index=i+k; \n   } \n System.out.println(max); \n } \n//  System.out.println(); \n  } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void Main(string[] args) \n        { \n            int[] parentArray = new int[] {11, 12, 13, 14, 15, 80, 90, 100, 70, 60, 6, 7, 8, 9, 10}; \n            int subArraySize = 0; \n            Console.Write(\"Enter the sub array size: \"); \n            bool result = int.TryParse(Console.ReadLine(), out subArraySize); \n \n            if (subArraySize <= 0 || subArraySize >= parentArray.Length) \n            { \n                Console.WriteLine(\"Size out of bounds\"); \n                return; \n            } \n \n            for (int i = 0; i < (parentArray.Length - subArraySize + 1); i++) \n            { \n                int temp = parentArray[i]; \n                for (int j = 0; j <= subArraySize-1; j++) \n                { \n                    temp = Math.Max(parentArray[j+i], temp); \n                } \n                Console.Write(temp.ToString() + \" \"); \n            } \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def findMaxinK(a,k): \n    max_ = a[0] \n    for i in range(len(a)): \n        if max_"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include   int main() {         int n,k,i,j;         scanf(\"%d %d\",&n,&k);         int max;         int arr[n];         for(i=0;i        {             scanf(\"%d\",&arr[i]);         }         for(i=0;i        {             max=-1;             for(j=i;j            {                 if(arr[j]>max)                 {                     max=arr[j];                     printf(\"max %d \\n\",max);                 }             }             printf(\"%d\",max);         }         return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include   int main() {         int n,k,i,j;         scanf(\"%d %d\",&n,&k);         int max;         int arr[n];         for(i=0;i        {             scanf(\"%d\",&arr[i]);         }         for(i=0;i        {             max=-1;             for(j=i;j            {                 if(arr[j]>max)                 {                     max=arr[j];                     printf(\"max %d \\n\",max);                 }             }             printf(\"%d\",max);         }         return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"wi this could be the better soln for this???? #include struct list {     int data;     struct list *next; }*root=NULL; int sorted_insertion(int n) {     struct list *node=root,*temp;     if(root==NULL){         node=new list;         node->data=n;         node->next=NULL;         root=node;}     else     {         if(n>root->data)         {             node=new list;             node->data=n;             node->next=root;             root=node;         }         else         {             temp=root;             while((temp->next!=NULL)&&(temp->next->data>n))temp=temp->next;             if(temp->next==NULL){             node=new list;             node->data=n;             node->next=NULL;             temp->next=node;}             else             {                 node=new list;                 node->data=n;                 node->next=temp->next;                 temp->next=node;             }         }     }     return 0; } int display() {     struct list *temp=root;     int count=0;     while(temp&&count<3)     {         printf(\"\\t%d\",temp->data);         temp=temp->next;         count++;     }     return 0; } int main() {     int a[10],n,m,b[10],k=0,i,j,temp;     printf(\"enter the number of elements in the array\");     scanf(\"%d %d\",&n,&m);     printf(\"\\nenter the array elements:\\n\");     for(i=0;i        scanf(\"%d\",&a[i]);         if(a[i]<=m)         sorted_insertion(a[i]);         }         printf(\"thus the nearest elements are:\\n\");         display();     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void maxOfSubArray(int mainArr[],int k) {     for(int i=0;i+(k-1)<=mainArr.length-1;i++) {    int max=-1;    for(int j=0;j    if(mainArr[i+j]>max)      max = mainArr[i+j];            }    System.out.println(max+\" \");      }  }  Time complexity would be O(nk) where n is size of array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is an O(nk) solution. But this is obvious solution. I am looking for more efficient solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \nint findmax(int a[], int start, int end); \n \nint main() \n{ \n int arr[] = {8,9,2,5,0,8,1,3,5};  \n int n = sizeof(arr)/sizeof(arr[0]);   \n int i, j, k, max; \n i = 0; \n  \n printf (\"Enter k\\n\"); \n scanf (\"%d\", &k);         \n  \n j = i + k; \n  \n while (j <= n) \n { \n  //printf (\"\\ni : %d\\nj : %d\\n\", i, j); \n  max = findmax(arr, i, j);       \n  printf (\"%d \", max); \n  i++; \n  j++; \n } \n return 0; \n} \n \nint findmax(int a[], int start, int end) \n{ \n int i; \n int max = a[start]; \n for (i = start + 1; i < end; i++) \n { \n  if (a[i] > max) \n  { \n   max = a[i]; \n  } \n } \n return max; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \nint findmax(int a[], int start, int end); \n \nint main() \n{ \n int arr[] = {8,9,2,5,0,8,1,3,5};  \n int n = sizeof(arr)/sizeof(arr[0]);   \n int i, j, k, max; \n i = 0; \n  \n printf (\"Enter k\\n\"); \n scanf (\"%d\", &k);         \n  \n j = i + k; \n  \n while (j <= n) \n { \n  max = findmax(arr, i, j);       \n  printf (\"%d \", max); \n  i++; \n  j++; \n } \n return 0; \n} \n \nint findmax(int a[], int start, int end) \n{ \n int i; \n int max = a[start]; \n \n for (i = start + 1; i < end; i++) \n { \n  if (a[i] > max) \n  { \n   max = a[i]; \n  } \n } \n return max; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Use a max heap of size 3. Add the next element to the position where the first element is and then call heapify"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"The complexity of DashDash's solution is O(nlog(k)), Jack's complexity is O(nk). Is there solution with complexity O(n)?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16204676","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"22","title":"Write a program in C to read all the characters from standard input and output the reverse when the user presses enter key.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"#include  \n#include  \n#include  \n \nstruct node_t { \n   int c; \n   struct node_t *next; \n}; \n \nstruct node_t *create_node(char c) { \n    struct node_t* node = (struct node_t*) malloc(sizeof(struct node_t)); \n    node->c = c; \n    node->next = NULL; \n    return node; \n} \n \nvoid print(struct node_t *head) { \n   struct node_t *p = head; \n   while (p != NULL) { \n     printf(\"%c\", p->c); \n     p = p->next; \n   } \n   printf(\"\\n\"); \n} \n \nint main() { \n   int x; \n   struct node_t *head = NULL;    \n   struct node_t *node; \n   while ( (x = getchar()) != 10 ) { \n     node = create_node(x); \n     node->next = head; \n     head = node; \n   } \n   print(head);    \n  \n   return 0;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"#include int main(){     char c;     scanf(\"%c\",&c);     if(c!=10)        main();     printf(\"%c\",c); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Keep on pushing all characters to a stack When user presses Enter key, just start popping the characters out of stack and display."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int _tmain(int argc, _TCHAR* argv[]) {  std::string str;  std::getline(std::cin, str);   const unsigned int length = str.length();   for (unsigned int i = length; i > 0; --i)  {   std::cout << str[i - 1];  }   return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"--------------------------------------written in C-----------------------------------------------   #include #include int main() { char a[100],b[100]; printf(\"enter the string:\"); gets(a); strrev(a); printf(\"%s\",a); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use recursion.while taking the input call the funtion recursively and once input is done print the value.recursion can be easily used to solve the problem. :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include int main(){     char c;     scanf(\"%c\",&c);     if(c!=10)        main();     printf(\"%c\",c); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can't we use a stack? push every char to the stack, and pop them out upon enter."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I believe this question is about recursion:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"#include using namespace std; int main(){ char c[100]; int d; cout<<\"Enter the string\"; for(int i=0;i<100;i++){ cin>>c[i]; d=i; if(c[i]=='/n') break; } for(int d;d>=0;d--;) cout<}  I am not sure if I am getting the ques right. I have assumed that you keep on reading till an enter key is pressed and then you print the reverse string. If you want to store the reversed string and then print, maintain two pointers, one at beginning and the other at last and keep swapping. If I am wrong, please explain the ques properly."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16018673","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"8","title":"Write a program in C to do run length encoding of an string in place. Desired space complexity O(1).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what is \"run length encoding of an string\"?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This should be the problem 1.5 in the book \"Cracking the Coding Interview (5th Edition)???. The full solution could be found on my blog here: codesays.com/unofficial-c-solutions-to-cracking-the-coding-interview/ Any comment is welcome! The core code would be:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include int main() {     char str[20];     int count=0,i,j=0;     printf(\"enter the string for run length encoding:\\n\");     scanf(\"%s\",str);     for(i=0;str[i];i++)     {         count++;         if(str[i]!=str[i+1])         {         if(count>1)         {             str[j++]=str[i];             str[j++]=count+48;         }         else         str[j++]=str[i];         count=0;         }     }     str[j]='\\0';     printf(\"\\nthus the resultant string is:%s\",str);     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What will we do when input is like abcd then out put should be a1b1c1d1. In this case we would require to expand the existing array. If we choose not to compress such strings then following should work:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int main() { \n    char array[] = {'a','b','c','d'}; \n    runlength (array,4); \n    return 1; \n} \n \n \nvoid runlength (char array[], int length) { \n    int temp_count = 1,i=0; \n    for(i = 0;i"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16230693","download_status":"DOWNLOAD_DONE","votes":"3","answersCount":"52","title":"given an int array with no duplicate numbers, write a function to return number of ways to calculate a target number.  example: given {2,4,6,8} Target = 12 2 + 4 + 6 = 12, 4 + 8 = 12, 6 + 8 - 2 = 12, 2 - 4 + 6 + 8 = 12,  return 4","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This can be solved very easily via recursion"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Manoj's answer does not account for patterns that can be solved using negative of the element. Here is the correct algorithm"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This seems like a classic Knapsack problem:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \nusing namespace std; \nint n; \nint target = 12; \n \nint * solution; \nint sol_nums = 0; \nint part_sum = 0; \nvoid Solve(int * a, int n, int cur) \n{ \n    if (cur == n) \n    { \n        if (part_sum == target) \n        { \n            sol_nums ++; \n        } \n        return; \n    } \n    solution[cur] = -1; \n    part_sum -= a[cur]; \n    Solve(a, n, cur + 1); \n    part_sum += a[cur]; \n \n    solution[cur] = 0; \n    Solve(a, n, cur + 1); \n \n    solution[cur] = 1; \n    part_sum += a[cur]; \n    Solve(a, n, cur + 1); \n    part_sum -= a[cur]; \n     \n} \n \nint main() \n{ \n    int a[] = {2,4,6,8}; \n    int n = sizeof(a) / sizeof(int); \n    solution = new int[n]; \n    Solve(a, n, 0); \n    cout << sol_nums << endl; \n    delete solution; \n    return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution can be based od dynamic programming: three dimensional table, where on pozition i, j, is boolean value, whethrer numbers on positions from i to j can sum to s. This is O(n^2 *S), so pseudopolynomial algorithm."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Works well."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class NumWays {  public static int numOfper(int[] num,int target,int low,int high){   int count=0;   if(low>high)    return 0;   if(num[low]==target)     count++;    int zero=numOfper(num,target,low+1,high);   int add=numOfper(num,target-num[low],low+1,high);   int minu=numOfper(num,num[low]+target,low+1,high);   return zero+add+minu+count;   }    public static void main(String[] args) {   // TODO Auto-generated method stub   int[] num={2,4,6,8};   //System.out.println(getNoOfWays(num,0,12));   System.out.println(numOfper(num,12,0,2));  } } this return 4,but problem is time complexity: O(3^n) anyone has better algorithms?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"are the operations limited to \"+\" and \"-\" can we use other operations like \"*\", \"/\", \"%\" etc..,"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I originally downvoted this question, because it's pretty poorly specified, but I upvoted it back.  The author doesn't really make it clear what constitutes a \"distinct\" solution.  For example, why is 6 + 8 - 2 = 12 considered a solution, but 8 + 6 - 2 = 12 isn't?  Are we allowed to use a negative sign in front of the first element?  How about other operators?  If the target number is 0, then can we say that our solution is to add up none of the numbers?  My inference is that the problem boils down to this.  For each number, it can either contribute itself to the sum, its negative to the sum, or nothing to the sum.  So there are 3^N possibilities to consider.  I would do simple recursion with these pseudo-coded relationships:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a java version. Use and subtract the digit from the target and recursively call the array for rest of items that adds upto target - digit."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(2^N), no recursion, no caching"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be seen as a variation of knapsack problem. Find an article about this problem in the wiki: Subset sum problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int dp[W+1]; \nmemset(dp, 0, sizeof(dp));  \ndp[0] = 1; \nfor (int i=0; i < n; i++) \n     for (int j=W; j>=a[i]; j--) \n               dp[j] += dp[j-a[i]]; \nreturn dp[W];"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"a bottomup solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"one possible solution i found using \"sum of subset\" with little modification to this, probably there will be better solution in terms of time complexity then let me know... \n \nmy code is  \n#include  \n \nvoid countPossibleSolution(int *source, int length, int sumupto, int target, int i, int *count ) \n{ \n if(sumupto == target ) \n  (*count)++; \n \n  if( i < length && ( sumupto + source[i] ) <= target  ) \n { \n  countPossibleSolution(source, length, sumupto+source[i], target, i+1, count); \n   \n  countPossibleSolution(source, length, sumupto- source[i], target, i+1, count);   \n } \n  if (i < length && sumupto != target) \n  countPossibleSolution(source, length, sumupto, target, i+1, count); \n} \n \nint main() \n{ \n int arr[]={1,2,3,4,5,6,9,10}; \n //int arr[]={2,4,6,8}; \n int len = sizeof(arr)/sizeof(arr[0]); \n int solution[len]; \n int target = 12, count=0; \n countPossibleSolution(arr, len, 0, target, 0,  &count); \n \n printf(\"No of possible sum is %d\\n \", count); \n \nreturn 0; \n} \n You can see the o/p here \nh+t+t+p://ideone.com/FCyWuj#view_edit_box"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"done it for only addition for(i=0;i{   int sum =0 ;    for(j=i+1;j   {     if(a[i]+a[j] == 12)      count++;    if(a[j] + sum == 12)    count++;  sum += a[i]  + a[j]; }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"A upbottom solution?  int f(int *a, int n, int tar) {  if(n==1)   return abs(a[0]) == abs(tar) || tar == 0 ? 1 : 0;   return f(a, n-1, tar) + f(a, n-1, tar+a[n-1]) + f(a, n-1, tar-a[n-1]); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"just add the negative values to the original array to become subset sum problem and avoid possible duplicate solutions"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15847667","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"3","title":"difference between hashtable and hashmap in C#? when to use hashtable, list, hashmap and dictionary.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hashtable is thread safe, while Dictionary doesn't provide thread safety."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"c-sharpcorner.com/Blogs/9782/differences-between-hashtable-and-dictionary.aspx"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"There is no hashmap in c#. hashmaps can have null keys. Dictionary is a hashtable but its generic. So dictionary offers more typesafety than hashtable."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16139666","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"29","title":"Given coordinates (X[i],Y[i]) of all the cities in the world(for simplicity lets consider we have 2D world map). You are given a user's location (x,y), find out the closest city to the user. Write code for it.  Update:  Time complexity of the solution should be better than O(n) as there will be multiple lookup queries with different input points. You can preprocess the data in any way you like, but you need to minimize the query execution time complexity.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"If need faster than O(n) then need to look at tree search: for example Kd-tree's search gives O(logn) --> en.wikipedia. org/wiki/Kd-tree or try to divide into hemisphere zones on binary tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I think this question is similar to the closest pair in a given set of point. Instead of taking the mid point we consider the given point p(x,y) and compute the points based on x co-ordinate which are closest. Repeat for the closest point with the y - co ordinate. I think this will give the answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I wrote code for this problem using KDTree, you can read the theory of KD Tree in wikipedia. Here is the implementation:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I almost got this, but not quite. You can see that (4, 4) throws my approach due to hits at both x=4 and y=4, neither of which are the true nearest neighbor. Basically, I'm using a balanced BST for x-coords and y-coords, with the intuition being that we always want to minimize sqrt(x-delta^2 + y-delta^2), which means we want to only compare those cities which are closest in x and y:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can someone summarize the preprocessing options here? couldn't you sort based on distance to the user location?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Anyone with the solution to this? I can't seem to be able to do it in better than O(N)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Something like a quadtree (en.wikipedia.org/wiki/Quadtree) would probably work very well.   A simpler solution would be to split the world up into an arbitrary number of 'squares' and keep track of which cities each square contains. Depending on the size of the 'square' the solution would be faster than O(N). The solution of assigning one 'square' to every kilometer or so would obviously have time complexity of about O(1) but also very significant space complexity, so you'd probably want to trade that off to some extent. Not as good as a quadtree in terms of space, but simpler to implement."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the cities can be categorized on the basis of countries and the max and min (x,y) coordinates of the countries can be stored. There might be an overlap, but will definitely reduce the no of countries and thus to be searched for."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My first thought is that if you're taking \"You can preprocess the data in any way you like\" literally, and generally assuming the horse is a sphere, its trivial to do this in constant time.  Make a hash map with every possible coordinate pair as a key to the closest city.  This is probably not practical, but you could easily use some sort of rounding rule to group coordinates into reasonably sized block that act as Hashkeys to a list of cities.  Thus reducing the search space by a few orders of magnitude with a constant time operation."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why can't I preprocess and put in hash table key is x-y. e.g.  x=100, y=200 then key is \"100-200\" and value is city name."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"kd-tree is the answer and can guarantee O(lg(n)) complexity for queries. However I think it takes O(nlg(n)) pre-computation  complexity.   Another option is: as the input data is location of cities we may be able to assume they're spreading normally through the whole grid (usually its not!). in this case a simple O(n) clustering works with less than O(n) search complexity. At least one can test this approach for the input data and see if this type of clustering works or not! (this will be a good thing to mention in interview!)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If you're allowed massive preprocessing, you might want to connect your cities in a graph, roughly analogous to a highway system.  Start by taking each city, and find its closest three neighbors and make highways between them.   This will create a forest of highways (sorry to mix analogies).  You may have isolated foursomes of cities that are only connected to each other (e.g. four cities in Alaska).  For isolated foursomes, connect each of the cities to its next closest neighbor.  After this step, you may still have an isolated cluster of eight cities; if so, repeat the process.  After your preprocessing, you'll eventually have a highway system that connects all cities, but your highways will have the property that a trip between two cities always takes one time unit, no matter the actual distance.  Now imagine you're the traveler trying to get closest to home on the highway system.  Start at any city, and look at the map to find neighboring cities.  There will be at least three cities reachable by highway.  Whichever city is closer to your destination, then go to that city next.  If you're already in the closest city, then you're done.  There are edge cases where this approach won't produce the optimal solution, but it will always be pretty close.  Consider continental U.S. geography and the top 50 US cities.  Imagine creating a relatively minimal highway system between those 50 cities and think about your route."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why do we need K-D tree here? simple binary tree will work. Cant we use heap here?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We go by tree, We consider a tree in which each node can have at max 4 children. and each children contain a range in \"x\" and \"y\", which decide weather the value lies in this node or someone else.we go upon the point where each child get only a single point. and we know that here linear case does not exist, always search, delete,insert complexities goes down to O(logn)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"QR-Quadtree"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First sort all the cities by their x coordinate. Then do a binary search for the input point's x coordinate. Say, city x coordinates were 3 6 8 9 23 and user's x was 12. The O(log n) binary search will give that user lies between 9 and 23. At this point all we need to choose between 9 and 23 by comparing the y coordinates O(1). Overall O(log n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"get difference between co ordinates i.e. x and y and calculate distance by Pythagoras theorem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Python like psuedo code (don't remember exact syntax for *args)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15807692","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"10","title":"Implement memcpy function which accepts num of bits as argument as oppose to number of bytes.  memcpy (src, dst, num_bits)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"divide by 8 ..store in bytes_copied  mod by 8 ...store in leftover_bits  perform normal memcpy using bytes at dest_address  new_dest_address = dest_address + bytes_copied ; new_src_Address = src_address + bytes_copied ; uint8 mask = (1 << (leftover_bits + 1) - 1; uint8 maskComplement = ~(mask);  new_dest_address = (*new_src_address & mask ) |  (*new_dest_address & maskComplement);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"void memcpy(char *src, char *dst, size_t nbit){   while( nbit / 8 > 0 ){     *dst++ = *src++;   // Multiples of bytes, so copy byte level      nbit -= 8;                // Decrement 1 byte    }   // Take care of the remaining bits   *dst = (*src) & (-1 >>(8-nbit));// Do a bitwise and of the src and left bits }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if we just do a bitwise \"or\" operation that is similar to copy right ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how to check the \"dst\" do not locate at the end of memory? or if \"dst\" locates at somewhere that should be protect?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"oid memcpy(char *src, char *dst, size_t nbit){  while( nbit / 8 > 0 ){  *dst++ = *src++; // Multiples of bytes, so copy byte level  nbit -= 8; // Decrement 1 byte  }  // Take care of the remaining bits  *dst = (*src) & (1 >>(8-nbit)-1);// Do a bitwise and of the src and left bits  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15807691","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"11","title":"Arrange 1 to N in random order with no duplication.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"knuth (Fisher-Yates) algorithm: initialize array of size n with integers from 0 to n-1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Generate array contains 1 to N, then sort by random value Time/Space O(N)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Create an array of size N, (index being 0), and initialize all elements with 0. Generate a random number less than N and if arr[index]=0 put it in arr[index]. If it is already occupied, generate another no. Continue doing this till the array is completely filled."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Create an array int p[N], and set its value p[i]=i+1 for i=0 to N-1. write a for loop as bellow:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void genRandom( int N ){   int flag[N] = {0}; int count = 0;int x;   while( count < N ){     do{       x = rand() % N;     }while(flag[x]);     flag[x] = 1;     count++;     printf(\"%d\",x+1);// Required range is 1 to N   } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"To initialize an array a of n elements to a randomly shuffled copy of source, both 0-based:   a[0] ?? source[0]   for i from 1 to n ? 1 do       j ?? random integer with 0 ?? j ?? i       a[i] ?? a[j]       a[j] ?? source[i]   search for Fisher-Yates_shuffle on wikipedia"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assume you have N bytes of storage and a function that can randomly pick an integer element from a range from 1 to x.  Populate an array A with 1 to N.  Use your random integer function to choose an index between 1 and N.  Use A[] as your next value.  Replace A[] with A[N] and decrement N.  Repeat until N == 1, and then just return A[1] and you're done.  By virtue of setting A[n] to be A[] after each iterations, there will be no collision/repeat detection, so you can pick each element in constant time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{public int[] getRandomArray2(int N)         {             int[] returnArray = new int[N];             Random rm = new Random();             int iRandomPosition = 0;             int iTemp = 0;             //we don't initialize the array               for (int i = 1; i <= N; i++)             {                 iRandomPosition = rm.Next(0, i);                 iTemp = returnArray[iRandomPosition];                 returnArray[iRandomPosition] = i;                 returnArray[i - 1] = iTemp;             }             for (int j = 0; j < N; j++)                 Console.WriteLine(returnArray[j]);             return returnArray;          } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int [] randomize(int n){  \n  int [] array = new int[n];  \n  for(int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package array;   /*  *   * The period of a general LCG is at most m, and for some choices of factor a much less than that. Provided that the offset c is nonzero, the LCG will have a full period for all seed values if and only if:[2] \\,c and \\,m are relatively prime, \\,a - 1 is divisible by all prime factors of \\,m, \\,a - 1 is a multiple of 4 if \\,m is a multiple of 4.  *   */  public class Arithmetic implements Generator{   private int intialvalue;    private int seed1;    private int seed2;    public Arithmetic(int intialvalue, int seed1, int seed2) {   super();   this.intialvalue = intialvalue;   this.seed1 = seed1;   this.seed2 = seed2;  }    @Override  public int[] GenerateRandom(int n) {      int[] output = new int[n];      int x = intialvalue;      for (int i = 0; i < n; i++) {    x = (seed1 * x + seed2) % n;     output[i] = x;   }      return output;  }   @Override  public void setInitialValue(int n) {   intialvalue = n;  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int real_user_input = 5; \n            int user_input = real_user_input+1; \n \n            Random r = new Random(); \n            int nextRan = 0; \n             \n            StringBuilder sb = new StringBuilder(); \n            int count = 0; \n \n            List usedList = new List(); \n \n            nextRan = r.Next(user_input); \n            while (usedList.Count < real_user_input ) \n            { \n                if (nextRan == 0) \n                { \n                    nextRan = r.Next(user_input); \n                    continue; \n                } \n \n                if (count == 0) \n                { \n                    usedList.Add(nextRan); \n                    Console.WriteLine(\"Added \" + nextRan); \n                } \n                else \n                { \n                    if (!usedList.Contains(nextRan)) \n                    { \n                        usedList.Add(nextRan); \n                        Console.WriteLine(\"Adding \" + nextRan); \n                    } \n                    else \n                        Console.WriteLine(\"NOT adding \" + nextRan); \n \n \n                } \n \n                count++; \n                nextRan = r.Next(user_input); \n                if ((count % 6) == 0) \n                { \n                    Console.WriteLine(); \n                    Console.ReadKey(); \n                    Console.WriteLine(); \n                } \n            } \n \n            Console.WriteLine(\"Here's the list of 1 to \" + real_user_input); \n            foreach (var i in usedList) \n                Console.Write(i + \",\"); \n \n            Console.ReadKey();"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15886674","download_status":"DOWNLOAD_DONE","votes":"3","answersCount":"24","title":"Given an array of 0s and 1s, find out: 1. all the subsequences where number of 0s = number of 1s 2. max length subsequence where number of 0s = number of 1s  Update:  We need to find subarrays, not subsequences. Sorry for the confusion.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"Assuming by subsequence you actually meant _subarray_, an O(n) time algorithm is possible.   Traverse the array from left to right, and maintain a running sum of number of ones - number of zeroes.   You also have a hashtable keyed on the running sum, and which contains information regarding the number of times that running sum appears, and also the leftmost index for which that sum appears.  Note: Even though the code uses hashtable below, as Eugene pointed out, since the running_sum is between -n and n, we can always use an array, guaranteeing O(1) lookups.  Using this structure, we can compute the answers for both 1 and 2.  For instance, to compute the number, we check if the running sum appeared before. If it appeared k times before, then we get k new sub-arrays with equal number of zeroes and ones.  The max length uses the left most such idx. Here is sample code in python (with random test cases). The O(n) method is named equal_count."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Well for the second part, replace all 0s by -1, now this problem reduced to finding the longest size subarray with sum=0. We can use a hashmap to keep track of cumulative sums and easily find that in O(n) time. However we can't do better than O(n^2) for solving first part because in worst number of subarrays with equal no of 0s and 1s could be proportional to n^2. Consider this test case: 0101010101."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Sounds like a typical DP problem. Let sums[i][j] be the accumulated sum from position i to j inclusive in the given sequence where for '0' we add -1 to the sum and for '1' we add 1. The problem can be degraded to find all the accumulated sum in sums array that equals 0. While printing out all possible solutions we can find the maximum. Program runs in O(n^2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.*; public class Maxlen01 {   public static void main(String[] args) {   boolean b=false;   int a[]=new int[20];   int n,nof1=0,nof0=0;   int max=0,equal=0,c=0;   Scanner sc=new Scanner(System.in);   System.out.print(\"enter the length of the 0s and 1s\");   n=sc.nextInt();   System.out.print(\"enter the oreder of the 0s and 1s\");   for(int i=0;i  {    a[i]=sc.nextInt();   }   if(a[0]==0)    nof0++;   else    nof1++;   System.out.print(\"entry1\");   for(int i=1;i  {     if(a[i]==0)      nof0++;     else      nof1++;    if(nof0==nof1)    {     b=true;      equal++;      if(max      max=nof0;    }    if(a[i]!=a[i+1])     c++;    if(b || c==2)    { b=false;     nof0=0;     nof1=0;     c=0;    }   }    System.out.println(\"no of equal lent 0s and 1s:\"+equal);   System.out.println(\"max lent 0s and 1s:\"+max);  }  } sample o/p:enter the length of the 0s and 1s6 enter the oreder of the 0s and 1s0 1 0 0 1 1 entry1no of equal lent 0s and 1s:2 max lent 0s and 1s:2 o/p2:enter the length of the 0s and 1s14 enter the oreder of the 0s and 1s1 1 0 0 1 1 1 0 0 0 1 1 0 0 entry1no of equal lent 0s and 1s:3 max lent 0s and 1s:3"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If it is subsequence the solution is simple as suggested by loler in his comment but if u meant subarray then i think u can use Kadane's algo with little modification.Add 1 to the sum if u find a 1 and substract 1 if u find a zero.Maintain a count and left index of current sum for the length of subarray and keep checking if the sum is zero."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Memoization can be used, time and space complexity O(n^2), n= len(sequnce)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. all the subsequences where number of 0s = number of 1s  2. max length subsequence where number of 0s = number of 1s  example : 0 1 1 1 0 1 0 1 1 0 1 0 0 1 1 0 0 0 1   these are  the steps  of dry running  1]  0 1 1 1 0 1 0 1 1 0 1 0 0 1 1 0 0 0 1   01,  011101011010011000  2] 1 1 0 1 0 1 1 0 1 0 0 1 1 0 0 0 1   nil  3]1 1 0 1 0 1 1 0 1 0 0 1 1 0 0 0 1  1 1 0 1 0 1 1 0 1 0 0 1 1 0 0 0  4] 1 0 1 0 1 1 0 1 0 0 1 1 0 0 0 1  1 0 1 0 1 1 0 1 0 0 1 0 1 0 1 1 0 1 0 0 1 1 0 0 1 0 1 0 1 1 0 1 0 0 1 1 0 0 0 1   5] 0 1 0 1 1 0 1 0 0 1 1 0 0 0 1   0 1 0 1 1 0 0 1 0 1 1 0 1 0 0 1 0 1 0 1 1 0 1 0 0 1 1 0  6] 1 0 1 1 0 1 0 0 1 1 0 0 0 1   1 0 1 1 0 1 0 0 1 0 1 1 0 1 0 0 1 1 0  void findtheLargestSequence() {  int a[] = {0, 1, 1, 1, 0, 1, 0 ,1, 1, 0 ,1, 0, 0 ,1, 1, 0, 0 ,0 ,1 };  int length = sizeof(a)/sizeof(a[0]);  int maxcount = 0,Zeros_count,OnesCount,start = 0,end = 0;  for(int i = 0; i < length; i ++)  {   Zeros_count = 0; OnesCount= 0;      for(int j = i ; j < length; j++)   {    if(a[j]== 0) Zeros_count++;    if(a[j]==1) OnesCount++;    if(Zeros_count== OnesCount)    {     int count = j-i ;     if(count>maxcount)     {      maxcount = count; start = i; end = j;     }     }    }       } printf(\"the longest o's and 1's sequence is :\" ); for(int i = start ; i < end ; i++) { printf(\"%d\",a[i]); } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"for the second part I think we can do following  traverse from left to right: and store the longest,second longest,third longest lengths of zeros and one in an array...if required we can store start and end index of all the lengths. Then we can compare the arrays and determine the max sub sequence of zeros and ones  Please correct me if I am wrong"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"for second part,count the no of 0s and 1s. length of longest subsequence with equal number of 0s and 1s will be  2*min(no of 0s, no of 1s)."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15555796","download_status":"DOWNLOAD_DONE","votes":"7","answersCount":"63","title":"Given a string, find whether it has any permutation of another string. For example, given \"abcdefg\" and \"ba\", it shuold return true, because \"abcdefg\" has substring \"ab\", which is a permutation of \"ba\".","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"9","title":"Given an input string A and the template string B, first use quicksort to sort B into B', and first |B| elements in A denoted as C; dynamically move C along A, each time the 1st element in C is removed and the next char is appended into C, just like insertion sort to sort C into C' and match C' == B'"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"The problem is same as finding the smallest window containing all the characters of a given string (here its 'ab'). If such a window is there return 'true'. Provide any alternate soln if there."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Here is my thought: For the permutation of string, its simplified represents is the number of each character existed in the string.  If you want to check if A's permutation is sub string of the B string, you only need to be sure that the number of each kind of character in A is less the number of the same character in the string B.  So you can build a histogram of characters in A by going through A, then going through B, decrease the count of character histogram of A when it find the one in B. Return true when all histogram reach zero during the going through B, otherwise return false."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"here is the code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"- take each character in smaller string and add its position in larger string into sorted array - if all chars are there in larger string, check if all the position is in sequence  Eg String a = abcdefghij String = dcfe  Sorted positions will be 3 4 5 6 so will return true"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am assuming it should return false for above case since lookalike question is a specific permutation of smaller string must be sub string of larger string"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"yaker no that question is different"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static bool isubstring(string S1, string S2)         {             int sumS1 = 0;             int sumS2 = 0;              for (int i = 0; i < S2.Length; i++)             {                 sumS2 += (int)S2[i];             }             for (int i = 0; i < S1.Length - S2.Length + 1; i++)             {                 int index = i;                 sumS1 = 0;                 for (int j = 0; j < S2.Length; j++)                 {                     sumS1 += (int)S1[index];                     index++;                 }                 if (sumS1 == sumS2)                     return true;             }             return false;          }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Compute all the permutations of the smaller string(easily done recursively). For each permutation, check if it is a substring of bigger string."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"get a element from string A, search for that in string B1(Copy of second string B),If  we dont find it go to next element in A. If we find element at position 'i' in B1, replace that element with 0 in B1(we did not modify anything in B).  search for the next element in A in B1 and replace  that element with 0 in B1 till we could not find the a .elements of A in B1 or all elements in B1 are 0. if all elements in B are 0.result is success.  if we could not find a element at position k of A in B1. get refresh B1 i.e copy from B. now find for that element in B(the original string) if we could not find it in B, Continue to repeate the same steps from position k+1 . if you find it in B,repeate steps from position i+1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"To solve this problem.. First find the maximum window in which all the character of given pattern is present. If max window length is equal to pattern length than it is going to be the permutation of given string other wise not.Code is given below let me know if it fails in any scenario it is working for me for test cases i think of.  int FindpatLen(char *str,char *pat) {  if(!*str)   return 0;  int len1=strlen(str),len2=strlen(pat),count=0;  int hasfound[26]={0},needtofound[26]={0};  int i=0,begin=0,max=999;  for(i=0;i  needtofound[pat[i]-97]++;  i=0;  for(;i {   if(needtofound[str[i]-97]==0)    continue;   hasfound[str[i]-97]++;   if(hasfound[str[i]-97]<=needtofound[str[i]-97])    count++;   if(count==len2)   {    while((needtofound[str[begin]-97]==0) || (hasfound[str[begin]-97]>needtofound[str[begin]-97]))    {     if(hasfound[str[begin]-97]>needtofound[str[begin]-97])      hasfound[str[begin]-97]--;     begin++;    }    if(max>(i-begin))    max=i-begin+1;   }  }  return max; } bool Ispermutation(char *str,char *pat) {  int len=strlen(pat);  if(len==FindpatLen(str,pat))   return true;  return false; } int main() {  char str[]=\"abcabcabc\";  char pat[]=\"cab\";  bool res=Ispermutation(str,pat);  getchar();  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.Create a temporary bitMap of  initialize them with character and bit value 0 2. Scan through the big array when you find a character in the small array update the bit map with the char and set it to 1 if the character bit has 0.  public static boolean checkPresence(char[] arr, char[] temp) {    int track = 0;   Map tempMap = new HashMap();   for (char c : temp) {    tempMap.put(c, 0);   }   int prev = 0;   for (int i = 0; i < arr.length; i++) {    char c = arr[i];    if (tempMap.get(c) != null && tempMap.get(c) == 0      && (prev == 0 || prev == i - 1)) {     tempMap.put(c, 1);     track++;     prev = i;    }   }   return track == temp.length ? true : false;  }    Let me know if i miss any case"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If long string has length n and the short has length m Best complexity I reached: -Assuming no repeated characters in either string >> O(n) -Allow repeated characters in the long string >> O(n) too -Allow repeated characters in either string >> O(n*log m)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Firstly, Sort the string and substring separately??Time complexity is  O(sqrt(n)) Secondly, use match algorithm on the ordered string??Time complexity is O(n) so the total complexity is O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package com.santosh.career; \n \nimport java.util.HashMap; \nimport java.util.Map; \n \npublic class Career15555796 { \n \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n  char[] small = { 'c', 'b' }; \n  char[] big = { 'g', 'b', 'a', 'c', 'd', 'e' }; \n  Map charMap = new HashMap(26); \n  Map fixedCharMap = new HashMap( \n    26); \n  resetCharMap(small, charMap); \n  resetCharMap(small, fixedCharMap); \n  int smallCount = small.length; \n  int flag = 0; \n  for (char c : big) { \n   if (charMap.get(c) != null) { \n    charMap.put(c, charMap.get(c) - 1); \n    flag = 1; \n    smallCount--; \n   } \n   if(smallCount==0){ \n    System.out.println(\"Found a match\"); \n    break; \n   } \n   if (flag == 1 && charMap.get(c) == null) { \n    charMap = fixedCharMap; \n    flag = 0; \n    smallCount = small.length; \n   } \n  } \n } \n \n private static void resetCharMap(char[] small, \n   Map charMap) { \n  for (char c : small) { \n   if (charMap.get(c) == null) { \n    charMap.put(c, 1); \n   } else { \n    charMap.put(c, charMap.get(c)); \n   } \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The Algorithm i posted above its O(n) and i am using two constant size arrays. I handled all cases i suppose let me know if it fails in any case"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"HI i think this can be easily solved by Hash maps. Create a hash map for the second string and keep incrementing for a new instance found for a letter. ex: abdds: a(1),b(1),d(2),s(1). Then for the second string, keep decrementing if the same letter is found. if the first string ends and all the letters have the values associtaed to them as zeroes: return TRUE. The complexity is m+n, 1.e. of O(m)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package questions; \n \nimport java.util.Arrays; \n \npublic class HasPerm { \n public static void main(String[] args) { \n  System.out.println(hasPerm(\"abcdefg\", \"ba\")); \n  System.out.println(hasPerm(\"abcdefg\", \"gf\")); \n  System.out.println(hasPerm(\"abcdefg\", \"dc\")); \n } \n \n public static boolean hasPerm(String source, String find) { \n  String k = key(find); \n  for (int i = 0; (i + find.length()) <= source.length(); ++i) { \n   String sub = source.substring(i, i + find.length()); \n   if (key(sub).equals(k)) \n    return true; \n  } \n \n  return false; \n } \n \n private static String key(String s) { \n  char[] ary = s.toCharArray(); \n  Arrays.sort(ary); \n  return new String(ary); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this, you just sort both the strings and then compare the index of the smaller string in the larger string. If it is -1, then the smaller string is not a part of the larger string."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sort is not required, i think"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"reverse the second string and use kmp search will be better. and also we can use suffix tree or suffix array, but they are too complicated. here is my program, and it will take O(n) time complexity(n: the length of first string) and O(m) space complexity(m: the length of second string):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int[] count = new int[256];   for(char c: str1.toCharArray())    ++count[c];   for(char c: str2.toCharArray())   {    if(count[c]==0)     return false;   }   return true;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think of hashing all the characters into the hashtable and maintain the count. Then, for every character in S2, check if it exists in the hashtable. if so, then result is true. it takes o(n) where n is the size of the longest string.   This idea is not based on the order and it depends whether there exists every character of a string exists in the original string. When it exists, the permutation is possible (obviously)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"will this idea work pls correct me if I am wrong:) 1.create two hash tables one for string 1 and another for string 2 2.if the hash values of string 2 if it is contained within string 1 then string is accepted...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this:   p1 = &Array1;  strcpy(Array3, Array2);  while (*p1 != '\\0')  {   for (i = (p1 - Array1); i < ((p1-Array1) + strlen(Array2)); i++)   {    for (j = 0; j < strlen(Array2); j++)    {     if (Array1[i] == Array2[j])     {      Array2[j] = 'x';      count++;      break;     }    }   }   if(count == strlen(Array2))   {    success = 1;    break;   }   else   {    p1++;    strcpy(Array2, Array3);    count = 0;   }  }   if (success == 1)  {   printf(\"Success\");  }  else  {   printf(\"Failure\");  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Check if a substring permutation exists in a string \n \nCheck if a substring permutation exists in a string. Ex. A = ??most random??? B = ??mod??? \n \nSo the function should return true since ??mod??? a permutation of ??dom??? exists in string A \n \n????????????????????????????????????????????????????????????????????????????C \n \n// Have this as class field to expose to multiple methods \nprivate Hashtable mTable;public bool SubStringExistsAsPermutation(string A, string B) \n \n{ \nif (String.IsNullOrEmpty(A)) \n{ \nthrow new ArgumentException(??A cannot be null???); \n} \nif (String.IsNullOrEmpty(B)) \n{ \nthrow new ArgumentException(??B cannot be null???); \n} \n \nmTable = new Hashtable(); \n \n// Fill hashtable with B string \nforeach (char ch in B) \n{ \nmTable[ch] = Convert.ToInt32(mTable[ch]) + 1; \n} \n \n// Read each character from String A. Keep comparing it with hashtable characters \n// If character in A is not found in hashtable, keep moving A pointer \n// If character in A is found in hashtable, Set a flag LookForConsecutiveCharacter = true \n// If you find LookForConsecutiveCharacter = true, and next character is not found Then ??C \n// Set LookForConsecutiveCharacter = false and reset hashmap to its initial state to look for next pattern ahead \n \nbool LookForConsecutiveCharacter = false; \nint count = 0; \n \nforeach(char ch in A) \n{ \n \nif (count == B.Length) \n \n{ \nbreak; \n} \n \nif (Convert.ToInt32(mTable[ch]) >= 1) \n{ \nmTable[ch] = Convert.ToInt32(mTable[ch]) ??C 1; \nLookForConsecutiveCharacter = true; \ncount++; \n} \nelse \n{ \n// If we expected consecutive characters for permutation and its not found, reset hashtable \nif (LookForConsecutiveCharacter) \n{ \nResetHashTableToDefault(B); \nLookForConsecutiveCharacter = false; \ncount = 0; \n} \n} \n} \n \n// Verify if we found permutation \nbool permutationFound = true; \nforeach (char key in mTable.Keys) \n{ \nif (Convert.ToInt32(mTable[key]) != 0) \n{ \npermutationFound = true; \nbreak; \n} \n} \nreturn permutationFound; \n} \n \nprivate void ResetHashTableToDefault(string B) \n{ \nmTable.Clear(); \nforeach (char key in B) \n{ \nmTable[key] = Convert.ToInt32(mTable[key]) + 1; \n} \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool find_permutation(const string& str, const string& other) \n{ \n string sorted; \n sort(other, sorted); //O(nlogn) \n  \n for(int i = 0; i < str.length(); ++i) \n { \n  if(i + sorted.length() < str.length()) \n  { \n   string subs = str.substr(i, sorted.length()); \n   string sortedSub; \n   sort(subs, sortedSub); //O(klogk) \n   if(sortedSub == sorted) return true; \n  }  \n }  \n  \n return false; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can do this in O(n).  The algorithm is simple, we move a window of |p| from left to right, and keep a counter of characters passed. We also update a counter d whenever a match between the moving counter and histogram of p happens or otherwise."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Guys we need to find a substring of string 1 which consists of only characters of string2 and has same length as string 2, once while iterating you find such a substring then compare the count of each character in the substring and string 2 , if string 2 has all unique characters this problem becomes simply finding the longest substring in string 1 that consists of all unique characters , characters here being those of string 2 , then if the length of this longest substring equals length of string 2 , then this is the code  i m posting the c code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"cracking the coding interview has the same question in chapter 1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"convert two arrays to numbers   S1 : abcdefg -------> 01234567 S2 : ba          -------> 10 int sumS1 = 0; int sumS2 = 0;  for(int i = 0;i{      sumS2+=S2[i]; }  for(int i = 0;i{        if(S1[i] + S1[i+1] == sumS2)             return true; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public static void main(String[] args) throws Exception \n { \n  String one = \"abcdefg\"; \n  \n  String two = \"ba\"; \n   \n \n  System.out.println(findifsubperumuation(one, two)); \n \n  \n } \n  \n  \n //Assumes one is longer than 2 \n public static boolean findifsubperumuation(String one, String two) \n { \n   \n   \n   \n  int k = two.length(); \n   \n  ArrayList all; \n  for(int i=0; i permutation(String s) \n { \n   \n \n  if(s.length()==1) \n  { \n \n   ArrayList perms = new ArrayList(); \n   perms.add(s); \n   return perms; \n  } \n   \n   \n   \n  ArrayList permsother = permutation(s.substring(1)); \n    \n  ArrayList perms = new ArrayList(); \n  \n  \n  String firstletter = s.substring(0,1); \n   \n  for(String current : permsother) \n  { \n   for(int i=0; i<=current.length(); i++) \n   { \n    \n    String Firstpart = current.substring(0,i); \n    String Secondpart = current.substring(i); \n    String together = Firstpart.concat(firstletter); \n    together=together.concat(Secondpart); \n    perms.add(together); \n     \n   \n   } \n    \n    \n  } \n   \n   \n   \n  return perms; \n   \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"Sort both string and then do substring search."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15519899","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"19","title":"Write a script to compare two files.  One is primary file and other is secondary.  I need to check if secondary file contains each line of primary (may be in different order) and should not contain any extra data.   exmaple:  cat primary  abc  lmn  xyz   cat secondary:  cat secondary  xyz  abc  lmn   then in this case compare function should give true.   Note: file contains may be any thing like html or xml code or other.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"sort and diff might work..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use suffix tree build suffix tree for 1st file and then search every string from second file..if not found return"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Read one line at a time from file called \"primary\" 2. Grep for the line in the file called \"secondary\" 3. Print line if missing."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"create a dictionary Read every line from secondary and get hashcode and add to dict then read primary , get one line hash code , if(dict.containskey(hashcode)) dict[hashcode] = true;  at last , check dict has false value."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/home/gkhurana> cat > primary abc lmn xyz /home/gkhurana> cat > secondary xyz abc lmn  /home/gkhurana> perl # The logic is , we will read first line of secondary and then compare with each line of primary # if there is a match its fine that means that line exist in primary, # similary you will proceed for each line of secondary # # Suppose the line is not there in primary, then it will se # #   open fh,\"secondary\"; $count=1; foreach $sec () {     open fh1,\"primary\";      $found = 1;     print \"\\nsecondary line=$sec\";         print \"\\nStarting Matching in primary file\\n\";         foreach $pr ()     {         print \"primary line=$pr\";         if($sec eq $pr)    #checking if secondary line is present in primary         {             print \"Match found for line $count in primary\\n\";             $found = 0;         }     }     close(fh1);      if($found eq '1') #if a line is in secondary and not found in primary just exit, no need to check further     {         print \"\\n There is content that is present in secondary but not in primary\\n.\";         exit(0);     }         $count++; } close(fh);          if($found eq '0')     {         print \"\\n  Whatever is there in secondary is present in primary.\\n \";      } ^D secondary line=xyz  Starting Matching in primary file primary line=abc primary line=lmn primary line=xyz Match found for line 1 in primary  secondary line=abc  Starting Matching in primary file primary line=abc Match found for line 2 in primary primary line=lmn primary line=xyz  secondary line=lmn  Starting Matching in primary file primary line=abc primary line=lmn Match found for line 3 in primary primary line=xyz   ------------------------- when the files dont match, we have added def in secondary file which is not there in primary  home/gkhurana> cat > secondary abc lmn xyz def /home/gkhurana>  secondary line=abc  Starting Matching in primary file primary line=abc Match found for line 1 in primary primary line=lmn primary line=xyz  secondary line=lmn  Starting Matching in primary file primary line=abc primary line=lmn Match found for line 2 in primary primary line=xyz  secondary line=xyz  Starting Matching in primary file primary line=abc primary line=lmn primary line=xyz Match found for line 3 in primary  secondary line=def  Starting Matching in primary file primary line=abc primary line=lmn primary line=xyz   There is content that is present in secondary but not in primary   /home/gkhurana>  i hope it helps"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"create a take the hashtable of first 4 words or less of each line in primary. now read lines from the secondary if it exists match the rest of the line. O(n+m)*l....where l  if the length of a line ...n & m are the number of lines"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the code for the file comparison  #! /usr/bin/perl use strict; use warnings;  print(\"Enter Primary File path\\n\"); my $p_file = ; chomp($p_file); if(!-e $p_file){   print(\"Input Primary file does not exist\\n\"); }  print(\"Enter Secondary File path\\n\"); my $s_file = <>; chomp($s_file); if(!-e $s_file){   print(\"Input Secondary File does not exist\\n\"); }  open (FILE1, $p_file) || die (\"Can't open file $p_file for reading\\n\"); open (FILE2, $s_file) || die (\"Can't open file $s_file for reading\\n\");  my @file1 = ; my @file2 = ;  foreach my $line (@file2) {   if(grep(/$line/,@file1)) {     next;   } else {     print(\"Files are different.\\n\");     exit;   } }  foreach my $line (@file1) {   if(grep(/$line/,@file2)) {     next;   } else {     print(\"Files are different.\\n\");     exit;   } }  print(\"Both the input files are same\\n\"); close (FILE1) || die (\"Can't close file $p_file for reading\\n\"); close (FILE2) || die (\"Can't close file $s_file for reading\\n\");"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is the code for the file comparison  #! /usr/bin/perl use strict; use warnings;  print(\"Enter Primary File path\\n\"); my $p_file = ; chomp($p_file); if(!-e $p_file){ print(\"Input Primary file does not exist\\n\"); }  print(\"Enter Secondary File path\\n\"); my $s_file = <>; chomp($s_file); if(!-e $s_file){ print(\"Input Secondary File does not exist\\n\"); }  open (FILE1, $p_file) || die (\"Can't open file $p_file for reading\\n\"); open (FILE2, $s_file) || die (\"Can't open file $s_file for reading\\n\");  my @file1 = ; my @file2 = ;  foreach my $line (@file2) { if(grep(/$line/,@file1)) { next; } else { print(\"Files are different.\\n\"); exit; } }  foreach my $line (@file1) { if(grep(/$line/,@file2)) { next; } else { print(\"Files are different.\\n\"); exit; } }  print(\"Both the input files are same\\n\"); close (FILE1) || die (\"Can't close file $p_file for reading\\n\"); close (FILE2) || die (\"Can't close file $s_file for reading\\n\");"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#!/usr/bin/perl \n# author: fructu \n# v0.01 \n# \n# description: \n# \n#  1) i use read_file_primary_to_hash to load the primary file \n#     into a hash if the line is repited the hash has \n#     the number of repetitions. \n# \n#  2) i use read_file_secondary_to_hash to read the secondary file \n#     for each line i searh it in the hash and chek if the hash is \n#     defined if not -> return error; \n#     if the hash is defined for that line i check have more than 0 \n#     lines and substract 1 in order to mach the line of the primary \n#     file. \n#     Then in the same function i check all hash entries are 0 if \n#     not i return 0.  \n# \n \nuse warnings; \nuse strict; \n \nsub read_file_primary_to_hash($ $) \n{ \n  my $file_name = shift; \n  my $hash      = shift; \n \n  open file_in, \"<$file_name\" or die \"$!\\n\"; \n \n  while(){ \n    chomp(); \n    $hash->{$_}++; \n  } \n \n  close file_in; \n} \n \nsub read_file_secondary_to_hash($ $) \n{ \n  my $file_name = shift; \n  my $hash      = shift; \n \n  open file_in, \"<$file_name\" or die \"$!\\n\"; \n \n  while(){ \n    chomp(); \n    if(defined $hash->{$_}){ \n      if($hash->{$_} <= 0){ \n        print \"line not found [$_]\\n\"; \n        return 0; \n      } \n      $hash->{$_}--; \n    }else{ \n      print \"line not found [$_]\\n\"; \n      return 0; \n    } \n  } \n \n  foreach my $k (keys %$hash){ \n    if( 0 != $hash->{$k} ){ \n      print \"line count bad [$k] : [$hash->{$k}]\\n\";  \n      return 0; \n    } \n  } \n \n  close file_in; \n  return 1; \n} \n \nsub main \n{ \n  my $h1 = {}; \n  my $result = 0; \n \n  read_file_primary_to_hash('e_2_primary.txt', $h1); \n  $result = read_file_secondary_to_hash('e_2_secundary.txt', $h1); \n \n  if(1 == $result){ \n    print \"the files have the same lines\\n\"; \n  }else{ \n    print \"the files do not have the same lines\\n\"; \n  } \n} \n \nmain();"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I dont know why everyone is make it so complicated. Its just a simple shell script"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I tried this and worked for me, please review:  use strict; use warnings;  use Tie::File;  my @array; tie @array, 'Tie::File',\"input.txt\" or die \"Not able to tie file: $! \\n\";  print join (\"\\n\",@array), \"\\n\";  my @array2; tie @array2, 'Tie::File', \"output.txt\" or die \"Not able to read output file : $! \\n\";  foreach my $element (@array2) {     if ($element ~~ @array)     {         print \"found $element \\n\";     }     else     {         print \"Element $element not found \\n\";     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"just XORing two files won't help?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15556745","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"12","title":"Implement print function given an integer without using the built-in print function","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Something like this? #include   int main(void) {     const char hello[] = \"Hello World!\\n\";     const size_t hello_size = sizeof(hello);     ssize_t ret;     asm volatile     (         \"movl $1, %%eax\\n\\t\"         \"movl $1, %%edi\\n\\t\"         \"movq %1, %%rsi\\n\\t\"         \"movl %2, %%edx\\n\\t\"         \"syscall\"         : \"=a\"(ret)         : \"g\"(hello), \"g\"(hello_size)         : \"%rdi\", \"%rsi\", \"%rdx\", \"%rcx\", \"%r11\"     );     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"basically, it's just print(int x)  {  int i, j;   stack s;   for(; i != 0; )  {   r = x/10     i = i mod 10;    s.push(r);   }  for(char c = ' '; !s.isEmpty(); ){   c = integer to character(s.pop());   print(c);    }  } This was the direction that he directed me.   At first, I was thinking of bits because I was quite taken aback of the question since it was like asking, write a text editor without using a text editor you know. It was the first interview!!!! Anyways, I didn't ask about system calls and such because he mentioned during the interview writing it in python because he wanted to introduce his programming language lisp to me. Just a word of advice, don't expect that you'll know the topic. If you are interested in compilers, just make sure to be clear that you are interested in it, not actually started implementing it in your room or something!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Could you provide some context? How low level should it be? Is it possible to use putc or it has to be a system call?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"By using the outputstream(or)dataoutputstream we direct o/p to VDU"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can you use the stdout fd?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In linux you can use system call. write(1, \"hello world\\n\", 4); or else try using recursion"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Thanks for answering guys. I seriously didn't know how to approach the problem cause it wasn't the classical interview question I was used to, aka - data structures, sorting, complexity, etc... I didn't think that if I were to talk a little bit about my side research on compilers and program analysis that I'm just beginning, he would then throw me a compilers question . Be clear about your strengths and what you've actually done so that they expect to give you a question that will show your full capabilities.  But at least I got to talk to my interviewee about compilers and reminisce about his college life even though, I couldn't understand what he was asking me."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hey . guyz i have a new idea. cant i copy and pest the exact body of printf function from the stdio.h . i have seen it works fine ;)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"And i have a question ..how the in-built functions work? is their any system call made implicitly when we call this functions"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"lets say. our print method takes a byte and uses character map to print character corresponding to given byte. Now, we can represent 0-9 digit easily in byte an their corresponding character will be '0','1'...'9'.  So. if can covert given integer to array of digit and send each digit to print method. we can print that digit without using inbuilt print method."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how wud it be if we can use an inline assembler  i mean.... void main() { int i=10; _asm { lea dx,i mov ah,09h int 21h } }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15500840","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"7","title":"There is an machine which can process any kind of fruit and produce packaged boxes ?? write test cases for that","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"1.Shape of the fruits(Dimension of the fruit).  2.If the fruit is in the spherical shape measure the Diameter.  3.If the fruit is in the vertical or Horizontal shape measure the heigt and width.  4.If more than one type of the fruits are in the same box.Then the dimension of the box is not be less than  the maximum size of the fruit.  5.If the weight of the fruit is maximum then the Grade-A Box is used."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. size of fruit 2.capacity of machine to process fruit at a time 3.package a large no of same type of fruits 4.package a large no of different types of fruit"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15495877","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"9","title":"You come to office install the latest build of internet explorer and find out that instead of the expected page explorer loaded a blank screen .. before discussing with developer what test you will like to conduct so that he can pin point the problem from your observation","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"-Check the default page settings in the option menu and try to change and reload again -Try to reload IE multiple times and check the count of occurrences. -Empty the cache and reload again  -Type in the URL and search might be there is problem with navigation bar -Move my mouse all over the browser and check the status bar...might be page is hidden behind white browser screen (I am not sure whether this could be the case ever still a good test case)  -Check the scroll bar might be page is auto scrolled    -Check whether I am on private browsing...on some browser page is blank in that case -Right click to select the page source code and check if it is showing blank   -Try to re-install IE"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Apart from above verifications also check the below.  - Try close Fiddler and open IE - Check the internet options - Look at the event logs - Try open the same page in other browser  - Try open the same page on previous version of IE"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"launch IE in a debugger  ( windbg/cdb) and see if you can pick up any first chance exceptions."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"* Load the same page on other browsers, including old browsers it's trying to upgrade from * Install on a clean machine instead of upgrade  * Check any settings not enabled * Run in debugger"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"---> Check internet connection in network settings,may be network cable got detached ---> Check if any proxy settings ,, will set it to all defaults ---> Will try some LAN sites if they are working"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.check internet connection 2.try to reload page 3. check same page on other browser. 4.try to find logs 5.try to open page in old version of Brwoser."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"test"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"use google chrome"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15499844","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"12","title":"'K' number of char arrays of different length are given, find Cartesian product of them in optimal way & give complexity. I used divide & conquer.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Here is my code for the odoMeter. You only need to map the odoValue to the cartesian product  you want."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Still Use Odometer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//*a[] = k diff arrays. char * cart(char *a[], int start, int end) {      int mid;      if(start==end)      {            return a[start];                    }      else      {   mid=(start+end)/2;          char *a1=cart(a, start, mid);          char *b1=cart(a, mid+1, end);          return(product(a1,b1));      }  }  char * product(char *a1, char *b1)  {       // return cartesian product of a1,b1 in a char *product;    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Python recursive solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Python Odometer Solution:  Using an odometer-based approach is arguably overkill for this problem, but it's a good technique to have in your bag of tricks.  An odometer function yields the cartesian product of a bunch of integer ranges.  It comes up in other problems.  For example, suppose you have a prime factorization for a number, and you want to generate all the composite factors of the number.  You can use an odometer to generate all the combinations of exponents."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think. If there are k arrays of different lengths (l1,l2...lk) then best case complexcity can not be less than O(l1*l2...lk), because we need to generate all at least such results. lets say if we have 3 char arrays of size 2,3,4 then result should contain 2*3*4=24 strings. so here we can use bottom to top approach. algo should be: 1- mutliply k & k-1 char arrays  2- multiply results of step 1 to k-2 3-and so on till k=1.  As per our example. k= 3, l1= 2, l2=3;l3 =4 l3(3)*l(4)      \\     /  l(12)*l(2)            \\         /              l(24)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15501689","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"41","title":"we have given a char array like ??a1b2c3?? we have to convert this array to array like this ??abbccc??? .This has to be done in place as we have given that array has just enough space to hold the expanded array.  example:  1)input: a1b1c1  output:abc  length of array will be shortened.  2)input: a2b2c2  output:aabbcc  length of array will be equal to given array.  3)input: a3b4  output:aaabbbb  length of array will be greater than given array.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"This problem can be of two type :  First : all integer in given input are lies between 0 to 9. Here is the algo :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Approach: shift elements to make enough space for copying."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This is o(n2) problem  my algo tested and working"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"It is possible to do it in place, using a small buffer to handle overflows. I assumed that the input array is already resized to the final size and free space is filled by '\\0' as it mentioned in the question. however finding the final size is easy and others talked about it. (the tricky part is how to fill the array in place)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Lets start from the end. This way we can easily do it without shifts."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Find sum of all the numbers ... which would be the size of o/p array  Now start from array+size and come backwards by filling all the elements ....  i/p array = a1b2 size = 1+2 = 3  array+(size-1) = b array+(size-2) = b array+(size-3) = a"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my C# implementation. To convert it to java or c is trivial..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It makes quite a time to find out the algorithm.  1> In the begging of the processing, if the decode will result in shrinking or the space in the left is enough to contain the expansion, do it using two pointers,  one write and one read. 2> Once you got a word pair you can not expand to the left, which means your write pointer will collide your read pointer, the algorithm change to second stage, it will start to counting the number of the extra space on the right until it reach the end of the array or the extra space needed is zero. After you got this, you decode your char array using another two pointers, this time write pointer is bigger than read pointer until.  3> Goto 1> if there are still some bytes left."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \nvoid chardecode(char* pInput,  \n                unsigned int len, \n                unsigned int prefix, \n                unsigned int second) \n{ \n  char  *pTemp, *pTemp2; \n  unsigned int shrinked; \n  int count,count2, count3; \n  if(NULL==pInput) \n    return; \n  //First round shrink here \n  printf(\"prefix is %d second is %d len %d for %s\\n\", prefix, second, len, pInput); \n  if(second) \n  { \n    //that means we are in the second state of the algorithm \n    //we try to find the first zero expand area \n    pTemp=pInput; \n    pTemp2=pTemp; \n    for(count=-prefix, count2=0;count2'0' && *pTemp<='9') \n      { \n        count+=*pTemp-'2'; \n        if(count==0) \n        { \n          count2++; \n          break; \n        } \n      }else \n      { \n        return; \n      } \n      pTemp++; \n    } \n    //Here we are doing the normal expand \n    printf(\"count is %d count2 is %d\\n\", count, count2); \n    pTemp=pInput+(count2<<1)-2; \n    pTemp2=pTemp+count+1; \n    pInput=pTemp2+1; \n    len=len-count2; \n \n    for(;count2;count2--) \n    { \n      for(count=*(pTemp+1)-'0';count;count--) \n      { \n        *pTemp2=*pTemp; \n        pTemp2--; \n      } \n      pTemp-=2; \n    } \n    //now we are going to perform the left part if existed; \n    printf(\"len is %d\\n\", len); \n    if(!len) \n    { \n      *pInput='\\0'; \n      return; \n    } \n  } \n     \n  pTemp=pInput; \n  pTemp2=pTemp; \n  for(count=0, count2=0, shrinked=0;count2'0' && *pTemp<='9') \n      { \n        count+=*pTemp-'2'; \n        if(count<=0) \n        { \n          shrinked=1; \n          for(count3=*pTemp-'0';count3;count3--) \n          { \n            *pTemp2++=*(pTemp-1); \n          } \n        }else \n        { \n          //in this case we enter the state mahine second state: \n          { \n            //we found that we are in the middle of the array  \n            //and we can not shrink anymore \n            chardecode(pTemp-1, len-count2, *pTemp-'2'-count, 1); \n            return; \n          } \n        } \n      }else \n      { \n        return; \n      } \n      pTemp++; \n    } \n  *pTemp2='\\0'; \n} \n \n \nint main() \n{ \n    char  p[]=\"a1b1c1\"; \n    char  p2[]=\"a2b2c2\"; \n    char  p3[]=\"a3b4     \"; \n    char  p4[256]=\"a1b4c4d1e5f4\"; \n     \n    chardecode(p, 3, 0,0); \n    printf(\"p is %s\\n\", p); \n    chardecode(p2,3, 0, 0); \n    chardecode(p3, 2,0,0); \n    printf(\"p2 is %s\\n\", p2); \n    printf(\"p3 is %s\\n\", p3); \n    printf(\"p4 is %s\\n\", p4); \n    chardecode(p4,6, 0,0); \n    printf(\"p4 is %s\\n\", p4); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for(int i=1;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's the in-place solution in Python, with tests.  It's done in constant space.  There's no recursion and the array never grows larger than the final result."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void ExpandStr(char* str) \n{ \n        size_t len = strlen(str) + 1; \n        // count ints \n        size_t count = 0; \n        size_t sum = 0; \n        for (size_t i=0; i= '1' and str[i] <= '9') { \n                        count++; \n                        sum += (size_t (str[i] - '0')) -1; \n                } \n \n        } \n \n        size_t finalLen = len + sum - count; \n        size_t currentIdx = finalLen - 1; \n        str[finalLen] = '\\0'; \n        for (size_t i=len-1; i>0; i--){ \n                if (str[i] >= '1' and str[i] <= '9') { \n                        size_t cnt = (size_t(str[i] - '0')) - 1; \n                        char c = str[i-1]; \n                        while (cnt != 0) { \n                                str[currentIdx--] = c; \n                                cnt--; \n                        } \n                } else { \n                        str[currentIdx--] = str[i]; \n                } \n        } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a straightforward solution :    Shift all the elements to the end of the array and then trace the part where the info is. keep the read char in temp char and keep the number that comes after in temp amount. Then in a loop add the amount of chars starting from the beginning of the array. Do that until you read and processed all the chars. Keep a global counter so you know where you left when proicessing for the next character .."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Working solution in java. I am assuming the entire array is passed,and the end elements are filled with spaces I calculate the number of pairs,and I start at the last pair and work my way to the first pair"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"All test cases provided by author succeeds."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"var arr = ['a','1','b','2','c','3','d','1','1','','','','','','','','','','','','','','']; \nvar p = arr.length - 1; \nfor(var i=p;i>=0;i--){ \n //getNumber \n var n = 0; \n var nlen = 0; \n while(arr[i] != '' && arr[i] < 'a' && i >=0){ \n  if(nlen>0) n+= Math.pow(10,nlen); \n  else n += parseInt(arr[i]); \n  arr[i]=''; \n  i--; \n  nlen++; \n } \n if(n==0) continue; \n var c = arr[i]; \n arr[i] = ''; \n console.log(n); \n console.log(c); \n \n for(var j=0;j"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's the approach. 1. calculate the length of the pattern and the required length 2. There will be two cases which we need to handle    case 1:   the pattern length >= required length                     e.q. a1b2   (pat length =4) , required length = 3                      or  a2b2   (pat length =4) , required length = 4                    In this case iterate over the pattern and shrink '1' and repeat last char for '2'     case 2:              pattern length < required length              e.g. a1b2c4                  a) shrink all the 1's , so a1b2c4 becomes ab2c4             b) now start filling from the back   Here's the code for the same"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(N),first pass we just deal 1 to make the string shorter from the start to the end, second pass we deal others to make the string longer from the end to the start."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) { \n        SimpleReader in = new SimpleReader1L(); \n        SimpleWriter out = new SimpleWriter1L(); \n \n        String array = in.nextLine(); \n \n        int startIndex = 0; \n        int endIndex = 2; \n        String expandedStr = \"\"; \n \n        while (endIndex <= array.length()) { \n            String subStr = array.substring(startIndex, endIndex); \n \n            char alphabet = subStr.charAt(0); \n            int number = Integer.parseInt(subStr.charAt(1) + \"\"); \n \n            int count = 0; \n            while (count < number) { \n                expandedStr += alphabet; \n                count++; \n            } \n            startIndex += 2; \n            endIndex += 2; \n        } \n \n        char[] newArray = expandedStr.toCharArray(); \n \n        out.println(expandedStr); \n        in.close(); \n        out.close();"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//give a1b2c3 \n //return abbccc \n String tostring(String s){ \n  char [] array = new char[20]; \n  TreeMap map = new TreeMap<>(); \n  for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n/*Assumptions: \n char string given in format -- char [] \n number may be any positive integer \n always single alphabet, anything other than number is considered alphabet \n all inputs correct. E.g. no incorrect inputs like 22a2 or abc4-->written as a1b1c4 \n*/ \nusing namespace std; \n \nvoid fix(char *all_s, char *all_e, char *in_s, char *in_e) \n/* \nall_s,all_e : mark the start and ending of complete space under consideration \nin_s,in_e : mark where to start reading from when running backwards \n \nAlg: \nMove backwards \n-Get num \nMark position Pos from where to start copying later, save char to copy \nRecursively call itself with new space under consideration and where to start reading input \nUpon return, from Pos,copy saved character num times \n*/ \n{ \n  \n if((in_s>=in_e)||(all_s>=all_e)) return; \n  \n //Moving backwards get num \n int num = 0, count = -1; \n while(*in_e>='0'&&*in_e<='9')  \n { \n  count++; \n  num = (( *in_e- '0' ) * int(pow((double)10,(double)count))) + num; \n  in_e--; \n } \n  \n char *pos = all_e-num+1; \n char c = *in_e; \n  \n fix(all_s,all_e-num,in_s,in_e-1); \n  \n for(int i = 0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My algo is: 1st, traverse the string and get the total length of the result string, assuming len = N. 2nd, traverse the string from tail, and then parse and write the new string also from the tail, a[N-1].  In this solution, time complexity is O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"first iterate from back.First check the sum of the all numbers which is the length of the array.And in the next iteration expand the digits if the expansion is going to overwrite the string then do it at that place else do it at the right place.For the next iteration remove the spaces.--O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Should be relatively easy like this:  1) Remove all \"1\"s by shifting chars to the left.  2) Start expanding from the end of the array to the end of the expanded array and move towards the beginning from there. Since all \"1\"s have been removed the space will always be enough to not overwrite characters."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"def expandchar(s):     letters, digits = s[0::2], s[1::2]     for i in range(len(letters)):         sys.stdout.write(letters[i] * int(digits[i]))"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15487664","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"19","title":"Consider a system of n nodes numbered 1 to n. Each node has its id(1 to n) and a value associated with it say val. Now Every node has a send method send(int to , int val) and receive method int receive(int from).  So if node 1 wants to send value , it does like this . send(1,val).  Using these two methods, write a distributed algorithm. Such that when the algorithm finishes, every node in the system knows the sum of the values of all the nodes in the system.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"Let the nodes form a binary tree.  Every node has 0 or 1 parents and between 0 and 2 children.  Nodes with children wait for them to report their values and pass a partial sum up to their parents, then wait for the parents to report the eventual sums.  For parallel nodes this runs in O(logN) time.  The synchronous simulation below runs in linear time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Just a thought: If each node knows its own node ID, and how many nodes are in the system, you might handle the problem this way: Imagine the nodes arranged in a circle. Part A: Node 1 starts by sending its val to node 2. Node 2 sends the val it receives, plus its own val, to node 3. Node n sends the total of vals to node 1.   Part B: Node 1 receives a message from node n, which contains the sum of the vals. It passes this sum to node 2, which resends the message around the circle. Each node (except node 1) knows that the *second* message it receives will be the total sum. Node 1 knows that the *first* message it receives is the total sum, and the *second* message it receives means that all nodes have been informed of the sum. So each node has essentially the same code, and the algorithm is linear; it sends twice as many messages as there are nodes."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"we can do it like many to one mapping.in a loop we get value from each node and add that value in a specific node.at the end of loop we have the sum of all the node in 1 single node.then we can flood this value again to the other node..its like many to 1 mapping.is it right ??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"It's a Observer Design pattern. (i.e. Publisher- subscriber pattern) ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think we can arrange all nodes in a circular single linked list. While traversing, in send(id,val), each time add previous value to val(just like we calculate sum for array of numbers) and in next node retrieve it using receive method. at the end val contains total sum. Now again reiterate list. this time val contains only total sum that occurred at last node in list. In this way all nodes can know sum of others. since traversing a list take O(n), time complexity is O(n)+O(n)=O(n).  Any suggestions for improvement is appreciated."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"As this is a parallel algorithm, we often assume the processors are multiples of 2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#define TOTAL_NODE N   \n \nint  distributeSUM() \n  { \n         \n     int i        = MyId; \n     int totalSum = MyVal; \n     int temp=1; \n \n      for (;temp < MyId; temp++) \n        totalSum += receive(temp); \n \n      send(MyId, MyVal) \n \n      for (temp++; temp <= N; temp++) \n        totalSum += receive(temp); \n              \n      return(totalSum);       \n \n \n  }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15420945","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"31","title":"Find an ancestor of given two node from a tree in O(n) time. The tree is binary tree.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"I guess the tree is not BST, because if it is, the problem becomes finding the first node in BST which is in the middle of two nodes, this is O(log N)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"This can be done in O(n), the same question I hv done in Amz .  Algo here. 1> Trace the path of node one from the root to child and store all the values in an array1. O(n). 2> Trance the path of node two from the root to child and store all the values in array 2. O (n).  Now U gotto check Index by Index in array 1 and array 2. Just before first index that mismatched is the common ancestor.   Total Time is . O(n)+O(n)+ O(n) = 3*O(n) ~O(n).. Remember assuming the tree is completely unordered we requires O(n) coz we are assuming its flat out. else if we hv any pattern we can utilize the same.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"if we have access to the parent of each node .. we can go up in the tree and then see where the 2 arrays of parents intersect. Instead of an array we will use hashmaps to store the parents. O(n) complexity"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"struct Node *Ancestor(struct Node *node,struct Node *p,struct Node *q) {  if(!node)   return NULL;  if(node==p || node==q)   return node;  struct Node *left=Ancestor(node->left,p,q);  struct Node *right=Ancestor(node->right,p,q);  if(left && right)   return node;  return(left?left:right); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Class Solution{  public TreeNode LCA(TreeNode root, TreeNode a, TreeNode b){   if(root == null){    return null;   }   if(root == a || root == b){    return root;   }   TreeNode leftSide = LCA(root.left, a, b);   TreeNode rightSide = LCA(root.right, a, b);   if(leftSide!=null && rightSide!=null){    return root;   }   return leftSide==null?rightSide:leftSide;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Find out whether the two nodes are in the left of root, right of root or one in left and other in right.  If (on left)------ call the same function for (root->l) if(on right)----- call the same function for (root->r) if(on different)--return root.  This will take O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Class Solution{  public TreeNode LCA(TreeNode root, TreeNode a, TreeNode b){   if(root == null){    return null;   }   if(root == a || root == b){    return root;   }   TreeNode leftSide = LCA(root.left, a, b);   TreeNode rightSide = LCA(root.right, a, b);   if(leftSide!=null && rightSide!=null){    return root;   }   return leftSide==null?rightSide:leftSide;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think it is a classic problem in career cup. The solution is: (assumption is we have the parent pointer) 1. keep move up both nodes by using parent pointer, and keep 2 counters.     after both of them reach the root. Then we have the two counters that     stores the steps which the node need to move to root. 2. By this we can get the difference between two counters. then move up the         larger-counter node only with the different steps. Finally, move both nodes    step by step, when they meet, that is the common ancestor.  Any problem with this method? or the time complexity is bad?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think it is possible to solve the problem with O(lgn) with extra memory and parent pointer. Here is the solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Following is a solution in O(n) running time.  1. If Node A is a parent of Node B, return Node A regardless if Node B exists, and visa-versa. 2. If node A/B not found, return null. 3.  Else, do LCS.  Disclaimer: this is rather tricky to do in an in-person interview without a debugger ;o)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Stupid method:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"answer = root. Bear in mind: the question didn't ask for the *closest* common ancestor. Just: an ancestor."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if you are sure that the numbers(data) exists in tree, then the following algorithm works in short time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Is that LCA and BST ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"If the tree is BST, we may use Breath-first search approach.  Here is JavaScript solution:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15430972","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"5","title":"Let assume you have access full heap memory. Now design & write code malloc and free operation.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"hi hprem991, can you please answer or give the link to old answer ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"in the heap, we have a hash table which includes the size of this new address space. So when we free this space, we will know how many space do we need to free."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Wow, this is an undergrad project they turned into an interview!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use buddy system"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"This is age old question .. Please somebody duplicate this.. I only hv responded for this"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15430836","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"50","title":"Given an infinite sequence of integers which are repeated many times. WAP to print \"beep\" if an integer appears ODDth time else print \"no beep\". example: input: a[] = { 1,4,2,4,3,2,4} output: beep, beep, beep, no beep, beep, no beep, beep Space complexity - O(1)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"I gave the following solution using bit vector:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"void main() \n{ \n for (i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"byte[] a = new byte[10]; \n             int[] num; \n            Console.WriteLine(\"Number of integers to enter\"); \n            int n = Convert.ToInt32(Console.ReadLine()); \n            num = new Int32[n]; \n            Console.WriteLine(\"Entet array of integers\"); \n            for (int i = 0; i < n; i++) \n            { \n                num[i] = Convert.ToInt32(Console.ReadLine()); \n            } \n            for (int i = 0; i < n; i++) \n            { \n                if (a[num[i]] == 0) \n                { \n                    Console.Write(\"beep \"); \n                    a[num[i]] = 1; \n                } \n                else if (a[num[i]] == 1) \n                { \n                    Console.Write(\"NoBeep \"); \n                    a[num[i]] = 0; \n                } \n            } \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"class Program \n    { \n        public byte[] a = new byte[10]; \n        public int[] num; \n \n        static void Main(string[] args) \n        { \n            Program obj = new Program(); \n            obj.beep(); \n            Console.ReadLine(); \n        } \n \n        public void beep() \n        { \n            byte[] a = new byte[10]; \n             int[] num; \n            Console.WriteLine(\"Number of integers to enter\"); \n            int n = Convert.ToInt32(Console.ReadLine()); \n            num = new Int32[n]; \n            Console.WriteLine(\"Entet array of integers\"); \n            for (int i = 0; i < n; i++) \n            { \n                num[i] = Convert.ToInt32(Console.ReadLine()); \n            } \n            for (int i = 0; i < n; i++) \n            { \n                if (a[num[i]] == 0) \n                { \n                    Console.Write(\"beep \"); \n                    a[num[i]] = 1; \n                } \n                else if (a[num[i]] == 1) \n                { \n                    Console.Write(\"NoBeep \"); \n                    a[num[i]] = 0; \n                } \n            } \n        } \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"most important question to ask the interviewer here is the range of numbers and whether the numbers are positive or negative.Only then can it be decided whether O(1) space is actually feasible."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int main() \n{ \n int arr[]={1,4,2,4,3,2,4,4,5,3,3,2}; \n int size=sizeof(arr)/sizeof(arr[0]); \n int index=1; \n for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i dont find any wrong in it... there is no time complexity asked for this question. hence only time complex  matters"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Space complexity O(1)?   I presume you are given constraints on the size of the numbers. Otherwise O(1) space is impossible...  And if you are given bounds, you can just use a bitvector and be done with."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for infinite sequence of array with poitive integers... code should be"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"probably some set of the math formulas can be used for the O(1) solution and wide range of integers, subscribing to the thread"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is an algorithm with a BitSet, not O(1) space as well. Not sure if we can do better (in O(1) space complexity)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Does infinite sequence here, mean we are given a stream of integers to be taken one by one..if its given in the form of an array as assumed in the above answers, it doesn't really match the problem descriptions. Please clarify."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void func() { int xor=0,x; //x is the input  While(true) {  if((xor & x) == x) { printf(\"beep\\n\"); } else printf(\"not beep\\n\"); xor = xor^x; } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void beep_unbeep (int num) \n{ \n static int save = 0; \n int temp = 0; \n  \n temp = num; \n temp = temp ^ save; \n \n if (temp) printf(\"\\nno_beep\"); \n else printf(\"\\nbeep\"); \n  \n save = save ^ num; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void Beep2(int a[]) \n{ \n map map; \n for(int i = 0; i < 9; i++) \n { \n  if(map[a[i]] = 1){ \n   cout<<\"no beep\\n\"; \n   map[a[i]] = 0; \n  } \n  else{ \n   cout<<\"beep\\n\"; \n   map[a[i]] = 1; \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#define CHECKBIT(var, pos) ((var)&(1<<(pos))) \nmain() \n{ \nint a[]={1,2,4,2,3,4,5,4,1,6,7}; \nint checkvector = 0; \nint n=sizeof(a)/sizeof(int); \nint i; \nfor (i=1;i<=n;i++) \n { \n        if(CHECKBIT(checkvector,a[i-1])) \n        { \n                printf(\"NoBeep \"); \n                checkvector&=~(0x1<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why not just sort the array first? Then we can easily keep track of how many of a particular number there are. The bit vector solution doesn't seem to work too well if we can have values between -(2^32 -1) to 2^31-1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Questions that we need to ask interviewer. 1. What is the range of integer? 2. Could the number be positive or negative? 3. How many memory do we have? 4. What does O(1) mean? Does it include input space?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if the range of the number is between 0 and 9 then this too could be an optimal soln: #include int main() {     int a[10],i,m,n;     static int b[10];     printf(\"enter the number of elements of the array:\\n\");     scanf(\"%d\",&n);     for(i=0;i        scanf(\"%d\",&a[i]);         for(i=0;i        if(++b[a[i]]>1)printf(\"\\nno beep\");         else printf(\"\\n beep\");     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void main() { int n,a[20],b[20],count[20]; printf(\"enter the value of n\"); scanf(\"%d\",&n); printf(\"enter the elements\"); for(i=0;i<=n;i++) { count[i]=0; scanf(\"%d\",&a[i]); } b[0]=a[0]; count[0]=1;printf(\"beep\"); for(i=0;i<=n,i++) { for(j=0;j<=n;j++) { if(a[j]==b[j]) {{count[j]++;} if(count[j]%2==0) printf(\"no beep\"); else printf(\"beep\"); } else { b[j]=a[i]; count[j]=1; printf(\"beep\"); } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this might work. Not sure though but it has O(n) time complexity and O(1) space complexity. The earlier posted solutions with bit-vectors still have O(n) complexity.   The strategy is simple. Define a function f(n) which produces a unique prime number for n. I believe there are a few functions available which can do this for very large n. Now all you have to do is keep a count variable of sorts. In the sequence, every time you see a number x, you check if count%f(x) is zero, and if so, print 'not beep' and set count to count/f(x). Else, print 'beep' and set count to count*f(x).   This should work as the prime factors of any number are unique. You may run into overflow problems with large number of variables but these are issues with programming and not the actual algorithm. It will still be O(1)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this might work. Not sure though but it has O(n) time complexity and O(1) space complexity. The earlier posted solutions with bit-vectors still have O(n) complexity.   The strategy is simple. Define a function f(n) which produces a unique prime number for n. I believe there are a few functions available which can do this for very large n. Now all you have to do is keep a count variable of sorts. In the sequence, every time you see a number x, you check if count%f(x) is zero, and if so, print 'not beep' and set count to count/f(x). Else, print 'beep' and set count to count*f(x).   This should work as the prime factors of any number are unique. You may run into overflow problems with large number of variables but these are issues with programming and not the actual algorithm. It will still be O(1)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"better to use the HashMap and insert value if not exists and print \"beap\" otherwise print \"no beap\""}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15435724","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"16","title":"swap alternate bits of a given number  eg: n=5 (0101)  output: 10(1010)  n=8(1000) output:4(0100)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"9","title":"Mask all odd bits with 10101010 in binary (which is 0xAA), then shift them left to put them in the even bits. Then, perform a similar operation for even bits. This takes a total 5 instructions."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"{ var  = (((var & 0xAAAAAAAA) > 1) | ((var & 0x55555555) < 1)) }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"val = ((val & ULONG_MAX / 3) << 1) | ((val & (ULONG_MAX/3)*2) >> 1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"# include  \n \nunsigned int swap_bits(unsigned int v)  \n{ \n \n    // swap odd and even bits \n    v = ((v >> 1) & 0x55555555) | ((v & 0x55555555) << 1); \n    return v; \n} \n \nint main() \n{ \n   printf(\" Before swapping %d\" , 5); \n   printf(\" After swapping %d\" , swap_bits(5)); \n   printf(\" Before swapping %d\" , swap_bits(swap_bits(5))); \n   return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi, We can also solve this with the following approach:  If you will see closely, then you will find...You have to take care of the following conditions: Start from MSB.  Take one variable, temp = 0..Which will store the result.   if( Bit is '1' and at Odd position) {              Using this, we have to add the result i.e. temp with the (2 raise to position of bit, by starting the position from 1 for MSB)   }   else if( Bit is '1' and at Even position.) {              Using this, we have to add the result with the (2 raise to position of bit and divide by 2) } else { for '0' at even or odd, will not help}  At the end return the final result i.e. temp.  Please correct me, If you finding it wrong.  Thanks.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  int bit_swap(int); int power(int); int main() { int a=15; printf(\"%d\",bit_swap(a)); } int bit_swap(int a) { int k=3,op1,op2,out=0; while(k>0)  {  op1=(a&power(k))>>k;  op2=(a&power(k-1))>>k-1;   out|=op1*power(k-1);   out|=op2*power(k);   k-=2;  }  return out;  } int power(int a) {  if(a==0)   return 1;  else   return 2*power(a-1); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"var swapBits = function (binNum) { \n var mask1 = parseInt('1010', 2); \n var mask2 = parseInt('0101', 2); \n return ((binNum << 1) & mask1) | ((binNum >> 1) & mask2) \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//use two arrays. \n  //binArr will hold bit pattern \n  int[] bitArr = {8,4,2,1}; \n  int[] binArr = new int[4]; \n   \n  int num=8; \n  //create bit pattern \n  for (int i = 0; i < bitArr.length; i++) { \n    \n   if(bitArr[i]<=num && num>=0){ \n    num=num-bitArr[i]; \n    binArr[i]=1; \n   }else{ \n    binArr[i]=0; \n    //i++; \n   } \n  } \n   \n   \n   \n  //reverse bit \n   \n   \n  int temp=binArr[0]; \n  binArr[0]=binArr[1]; \n  binArr[1]=temp; \n  temp=binArr[2]; \n  binArr[2]=binArr[3]; \n  binArr[3]=temp; \n   \n   \n   \n   \n   \n  int revNum=0; \n  for (int i = 0; i < binArr.length; i++) { \n   \n   if(binArr[i]==1) \n    revNum=revNum+bitArr[i]; \n    \n  } \n \n   \n  System.out.println(\"rev num:\"+revNum);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Even this method helps, if we aren't allowed to use and hex-numbers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"simple question:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void main() \n{ \n int a=1,b,k,l,t,i; \n printf(\"Enter number\"); \n scanf(\"%d\",&b); \n \n for(i=0;i<4;i++) \n { \n  t=a; \n  k=a&b; \n  a=a*2; \n  l=a&b; \n  if(k!=l) \n  { \n   b=b^t; \n   b=b^a; \n  } \n  a=a*2; \n \n } \n \n printf(\"Number is %d\",b); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include int main() { int n; printf(\"enter the n value\"); scanf(\"%d\",&n); printf(\"%d\",(((n&0xaaaaaaaa)>>1)|((n&55555555)<<1)))); return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void PrintSwapAlternateBitsofGivenNumber(int t)         {             int remainder = 0;             int divided = t;             int count = 0;             int digit = 1;             Stack q = new Stack();                          while (divided > 0)             {                 remainder = divided % 2;                 q.Push(remainder);                 divided = divided / 2;                 if (divided == 0)                 {                     q.Push(divided);                 }                 count++;             }              int sum = 0;             while (count >= 0)             {                 sum = sum + q.Pop() * digit;                 digit = digit * 2;                 count--;             }              Console.WriteLine(sum);         }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15424726","download_status":"DOWNLOAD_DONE","votes":"3","answersCount":"45","title":"Given  a binary tree return the level with maximum number of nodes","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"int maxLevel(node *root) { \n        int max, curr_level, max_level; \n        if (root == NULL) \n                return 0; \n        queue currentLevel, nextLevel; \n        currentLevel.push(root); \n        max = curr_level  = 1; \n        while (!currentLevel.empty()) { \n                node *curr = currentLevel.front(); \n                currentLevel.pop(); \n                if (curr->left != NULL) \n                        nextLevel.push(curr->left); \n                if (curr->right != NULL) \n                        nextLevel.push(curr->right); \n                if (currentLevel.empty()) { \n                        queue temp = currentLevel; \n                        currentLevel = nextLevel; \n                        nextLevel = temp; \n                        curr_level ++; \n                        if (currentLevel.size() > max) { \n                                max = currentLevel.size(); \n                                max_level = curr_level; \n                        } \n                } \n        } \n        return max_level; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"how about this: if we can change the tree, its quite easy I guess. In the first traversal every node.value gets value 1 more than its parent. Second traversal we sum how many times each value occurs: consider tree structure: value, right, left step 1: traverse(by changing) step 2 : count occurrences of same level public static void traverse(node root) { if(root ==null)return; if(root.left!=null) root.left.value = root.value+1; if(root.right!=null) root.right.value = root.value+1; traverse(root.right); traverse(root.left); } arraylist arr = new arraylist public void countmax(node root, arraylist arr) { if(root ==null)return; arr[root.value]++; countmax(root.left); countmax(root.right); }  finally return index of max of arr"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the output of the above question should be 3"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i  think  something is missing from the question....?????????????? Given a binary tree return the level with maximum number of nodes i think it should return alway 1.. please correct me.????????????"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//============================================================================ \n// Name        : levelFind.cpp \n// Author      :  \n// Version     : \n// Copyright   : Your copyright notice \n// Description : Hello World in C++, Ansi-style \n//============================================================================ \n \n#include  \n#include \nusing namespace std; \n \nint findLevelWidth(int arr[], int sz, int lvl) { \n cout << \"Level \" << lvl <<\": \"; \n int width=0; \n for (int i = ((1< 0) { width++;} \n  cout << arr[i] << \",\"; \n } \n cout << endl; \n return width; \n} \n \nint main() { \n cout << \"!!!Hello World!!!\" << endl; // prints !!!Hello World!!! \n int arr[] = {1,2,3,4,5,6,7,8,9,10,11,12}; \n \n int size = sizeof(arr)/sizeof(arr[0]); \n int lvlWdt=0; \n \n for(int i = 0; i < log2(size); i++) { \n  int width = findLevelWidth(arr,size, i); \n  if (width > lvlWdt) { lvlWdt = width;} \n } \n  \n cout << \"Max width is in level: \" << lvlWdt << endl; \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think below algorithm should do -   1. Run a BFS, starting from root node.  2. Keep track of levels and no. of nodes in each level.  3. Update max_nodes_in_level and level_number, with no. of nodes in current level and current level number, IF no.of nodesin current level > max_nodes_in_level. 4. Return level_number."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int LevelwithMaxNumNodes(struct Node *node) \n{ \n if(!node) \n  return 0; \n map mymap; \n map :: iterator it; \n int level=0; \n queue myqueue; \n myqueue.push(node); \n myqueue.push(NULL); \n while(!myqueue.empty()) \n { \n  struct Node *current=myqueue.front(); \n  myqueue.pop(); \n  if(current!=NULL) \n  { \n   it=mymap.find(level); \n   if(it==mymap.end()) \n    mymap.insert(pair(level,1)); \n   else \n   { \n    int count=it->second; \n    mymap.erase(level); \n    mymap.insert(pair(level,++count)); \n   } \n   if(current->left) \n    myqueue.push(current->left); \n   if(current->right) \n    myqueue.push(current->right); \n  } \n  else \n  { \n   if(!myqueue.empty()) \n   { \n    level++; \n    myqueue.push(NULL); \n   } \n   else \n    break; \n  } \n } \n int max=-1,count=-1; \n while(!mymap.empty()) \n { \n  if(mymap.begin()->second>=count) \n  { \n   count=mymap.begin()->second; \n   max=mymap.begin()->first; \n  } \n  mymap.erase(mymap.begin()); \n } \n return max; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Global variable MAX;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I also have in mind the BFS method but it would require extra space. can this problem be solved without using extra space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static int getLevel(NodeT root) {   int h = getHeight(root);   int []level = new int[h];   getLevel(root,level,1);   int max = level[0];   int iMax = 0;   for(int i = 1;i   if(max     max = level[i];     iMax = i;    }   }   return iMax+1;  }   private static void getLevel(NodeT node, int[] level, int i) {   if(node == null)    return;   else{    level[i-1]++;    getLevel(node.left,level,i+1);    getLevel(node.right,level,i+1);   }  }   private static int getHeight(NodeT root) {   if(root == null)    return 0;   else    return 1+Math.max(getHeight(root.left),getHeight(root.right));  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int MaxLevel(Node root){    if(root==null)        return -1;    //search the entire tree level by level    Queue cur = new Queue();    cur.offer(root);    int max = 0;    while((int size = cur.size())!=0){        max = size>max?size:max;        Queue parent = cur;        cur = new Queue();        while(parent.peek()!=null){           Node temp = parent.poll();           if(temp.left!=null)              cur.offer(temp.left);           if(temp.right!=null)              cur.offer(temp.right);              }    }         return max; }  //recursion public int getDepth(Node root){     if(root==null)        return 0;     else return max(getDepth(root->left), getDepth(root->right))+1; }  public void getLevelInfo(Node root, int[] levelcount, int level){     if(root==null)        return;          levelcount[level]++;     getlevelInfo(root->left, levelcount, level++);     getlevelInfo(root->right, levelcount, level++);     return;    }  public int findMax(int[] array){    int max = INT_MIN;     for(int i=0;i      max = array[i]>max?arry[i]:max;   return max; }  public int main(Node root){    int[] levelcount = new int[getDepth(root)];    getLevelInfo(root,levelcount,0);    print(findMax(levelcount));    return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int levelWithMaxNodes(Node root) {     return levelWithMaxNodes(root, 0, new HashMap(), 0);   }    private static int levelWithMaxNodes(Node root, int level, HashMap map,       int maxLevel) {     if(root == null)       return 0;      Integer value = map.get(level);     if(value == null) {       map.put(level, 1);     }     else {       if(value > maxLevel) {         maxLevel = value;       }       map.put(level, value + 1);     }     if(root.getLeft() != null) {       maxLevel = levelWithMaxNodes(root.left, level + 1, map, maxLevel);     }     if(root.getRight() != null) {       maxLevel = levelWithMaxNodes(root.right, level + 1, map, maxLevel);     }     return maxLevel;   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for(int i =1;i<=height(root); i++) { int nodes = getcountnodes(root,i); if( nodes > max) { max = nodes; max_level = i; } }   int getcountnodes(node * node , int level) {if(node == NULL) return 0; if(level == 1) { return 1; } else  if (level > 1) { return getcountnode(root->left,leve-1) + getcountnodes(root->right,level-1); } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We have to return level with maximum number of node. In other words we have to find width of the tree. Traverse the tree in pre-order fashion."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"make a marker node to detect level end, now check the counter value , if its greater then max, update max to counter value and make counter =0 again and push marker node again to the qeue"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"make a marker node to detect level end, now check the counter value , if its greater then max, update max to counter value and make counter =0 again and push marker node again to the qeue"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int \nmaxLevel(TreeNode const *node) \n{ \n    if (node == NULL) return 0; \n    int maxLevelNodes = 0; \n    int currLevelNodes = 1; \n    int nextLevelNodes = 0; \n    int currLevelNotNULL = 1; \n    int nextLevelNotNULL = 0; \n    deque queue; \n    queue.push_back(node); \n    while (!queue.empty()) { \n        TreeNode const *curr_node = queue.front(); \n        queue.pop_front(); \n        currLevelNodes -= 1; \n        if (curr_node != NULL) { \n            queue.push_back(curr_node->left_); \n            queue.push_back(curr_node->right_); \n            nextLevelNodes += 2; \n            if (curr_node->left_ != NULL) nextLevelNotNULL += 1; \n            if (curr_node->right_ != NULL) nextLevelNotNULL += 1; \n        } \n        if (currLevelNodes == 0 && nextLevelNodes > 0) { \n            // end of current level \n            if (currLevelNotNULL > maxLevelNodes) \n                maxLevelNodes = currLevelNotNULL; \n            currLevelNotNULL = nextLevelNotNULL; \n            nextLevelNotNULL = 0; \n            currLevelNodes = nextLevelNodes; \n            nextLevelNodes = 0; \n        } \n    } \n    return maxLevelNodes; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void MaxNodesLevel(BNode root)  \n { \n  Queue Currentqueue = new Queue(); \n  Queue NextlevelQueue; \n \n  BNode temp; \n  int MaxNodeslevel = 0; \n  int prevLevelCount_Nodes = 0; \n  int MaxNodes = 0; \n  int CurrentlevelCount_Nodes = 0; \n \n  Currentqueue.queueNode(root); \n \n  while (!Currentqueue.empty())  \n  { \n   NextlevelQueue = new Queue(); \n \n   while ((temp = Currentqueue.dequeNode()) != null)  \n   { \n    if (temp.LChild != null) { \n     NextlevelQueue.queueNode(temp.LChild); \n    } \n    if (temp.RChild != null) { \n     NextlevelQueue.queueNode(temp.RChild); \n    } \n   } \n \n   CurrentlevelCount_Nodes = NextlevelQueue.size(); \n   MaxNodes = prevLevelCount_Nodes > CurrentlevelCount_Nodes ? prevLevelCount_Nodes: CurrentlevelCount_Nodes; \n \n   prevLevelCount_Nodes = MaxNodes; \n   MaxNodeslevel += (MaxNodes == CurrentlevelCount_Nodes) ? 1 : 0; \n \n   Currentqueue = NextlevelQueue; \n \n  } \n   \n  System.out.println(\"Level with highest(\" + MaxNodes + \") nodes=\"+ MaxNodeslevel); \n \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algorithm: I used BFS Build a tree and supply the root node to the method.  Let me know if any case fails :)  public static void levelNodes(BinaryTreeNode root) {   Queue main = new ConcurrentLinkedQueue();   Queue childs = new ConcurrentLinkedQueue();   int max = 0;   int newMax = 0;   main.add(root);   max = 0;   do {    while (main.size() > 0 && main.element() != null) {     BinaryTreeNode node = (BinaryTreeNode) main.remove();     if (node.getLeft() != null) {      childs.add(node.getLeft());      newMax++;     }     if (node.getRight() != null) {      childs.add(node.getRight());      newMax++;     }     if (main.size() == 0 && childs.size() > 0) {      System.out.println();      main.addAll(childs);      childs.removeAll(childs);      if (newMax > max) {       max = newMax;       newMax = 0;      }     }    }    } while (main.size() > 0);   System.out.println(\"Max number of nodes in a level:\" + max);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Perfect solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we can use Level order to scan the tree, and update 2 counters, 1 for current level and the second is for the next level. in each push into the queue do: if node level == current level+1 -> counter2 ++ if node level != current level+1 -> store the Max between counter1 & counter2 , swap between them ' end initialize counter2 to 0.  when pushing is over return the max. i'm using the fact that in the queue there at most 2 levels..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"getMaxWidth(tree) \nmaxWdth = 0 \nfor i = 1 to height(tree) \n  width =   getWidth(tree, i); \n  if(width > maxWdth)  \n      maxWdth  = width \nreturn width \n/*Function to get width of a given level */ \ngetWidth(tree, level) \nif tree is NULL then return 0; \nif level is 1, then return 1;   \nelse if level greater than 1, then \n    return getWidth(tree->left, level-1) +  \n    getWidth(tree->right, level-1);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Def maxNodesLevel(root): \n If root == null: \nreturn 0 \nQ = Queue() \ncurLevelCount = 1 \nnextLevelCount = 0 \nQ.enqueue(root) \nWhile not Q.empty(): \n V = Q.deque() \n For n in V.getNeighbors(): \n  nextLevelCount += 1 \n curLevelCount -= 1 \n if curLevelCount == 0: \n  curLevelCount = nextLevelCount \n  nextLevelCount = 0 \nreturn nextLevelCount"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int levelWithMostNodes(TreeNode *node) \n{ \n    int currentLevel = 0; \n    int levelMostNodes = 0; \n    int maxNodes = 0; \n    int nodeCount = 0; \n     \n    if(node == nullptr) \n    { \n        return 0; \n    } \n     \n    queue nodeQueue; \n    queue children; \n     \n    nodeQueue.push(node); \n \n    do { \n        do \n        { \n            TreeNode* node = nodeQueue.front(); \n             \n            if(node->leftChild != nullptr) \n            { \n                children.push(node->leftChild); \n            } \n            if(node->rightChild != nullptr) \n            { \n                children.push(node->rightChild); \n            } \n \n            nodeQueue.pop(); \n             \n            nodeCount += 1; \n             \n        } while (!nodeQueue.empty()); \n         \n        if( nodeCount > maxNodes ) \n        { \n            levelMostNodes = currentLevel; \n            maxNodes = nodeCount; \n        } \n         \n        currentLevel++; \n         \n        while (!children.empty()) \n        { \n            nodeQueue.push(children.front()); \n            children.pop(); \n        } \n         \n        nodeCount = 0; \n         \n    } while (!nodeQueue.empty()); \n     \n    return levelMostNodes; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; \nimport java.util.Queue; \nimport java.util.LinkedList; \n \n \npublic class ModifiedBFS { \n \n Queue q; \n public int method(BinaryTreeNode root) \n { \n  ArrayList l = new ArrayList(); \n  //int[] count = new count[]; \n   \n  q.add(root); \n  int level =0; \n  int intems = 1; \n  l.add(level, intems); \n   \n  while(q.isEmpty() != true) \n  { \n   BinaryTreeNode p = q.remove(); \n   level++; \n    \n   if(p.left != null) \n   { \n    q.add(p.left); \n    intems++; \n   } \n   if(p.right != null) \n   { \n    q.add(p.right); \n    intems++; \n   } \n   l.add(level, intems); \n    \n   \n  } \n   \n  Integer max = l.get(0); \n  for(int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Keep track of levels using a marker."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int LevelWithMaxNodes(Node* root) \n{ \n  if(!root) \n    return -1; \n   \n  int maxNodes = 1; \n  int runningMaxNodes = 1; \n  int level = 1; \n  int runningLevel = 1; \n  Queue myQ = new Queue(); \n  Node* DELIMITER = null; \n   \n  myQ.push(root); \n  myQ.push(DELIMITER); \n   \n  while(!myQ.IsEmpty()) \n  { \n    Node* current = myQ.dequeue(); \n     \n    if(current) \n    { \n      ++runningMaxNodes; \n      // The below condition returns the first Level with max nodes, >= will give the last level with maxNodes \n      if(runningMaxNodes > maxNodes)  \n      { \n        maxNodes = runningMaxNodes; \n        level = runningLevel; \n      } \n       \n      if(current->left) \n        myQ.enqueue(current->left); \n      if(current->right) \n        myQ.enqueue(current->right); \n    } \n    else if(current == DELIMITER) \n    { \n      ++runningLevel; \n      myQ.enqueue(DELIMITER); \n    } \n  } \n   \n  return level; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why not do a level order traversal using a queue,as it is done, and keep checking the size of the queue for every level, and storing the maximum size in variable max and level i .. ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Apply BFS with the root as the source and in BFS, you can obtain the distance of each node from the source. Now, maintain a separate linked list/array in which you can update number of nodes at distance 'x' which gives you the number of nodes in level-x."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15422727","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"23","title":"Print the last n lines of a file in one iteration","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"10","title":"We can also think this problem similar to find the nth element from a singly linked list. We can have two variables:  - one for start point of file.  - one for end point of file,  first time by moving 'l' lines ahead. (As we do not know the no of lines in a file, so to keep track of the size of buffer we are interested in, Like we used to do for finding nth element) After this, move end point one line ahead and check is EOF? If not, then also increase the start point one line ahead and so on...  When you will hot EOF with the end point, then you have the point from the start. you then just have to print the lines on the way till end.  Hope this is what, we are exactly supposed to do.  Please add, If required.  Thank you..!!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"9","title":"Use circular buffer of length n, where each node stores one line. At the end of file. Print data in buffer line by line"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"class PrintLastN     {         public void PrintLastNLinesOfFile(string fileName, int numberOfLines)         {             try             {                 if (numberOfLines <= 0)                     throw new Exception(\"Invalid Number of Lines: Number of lines have to be greater than 0\");                 int i = 0;                 StreamReader streamReaderPointer1 = new StreamReader(File.Open(fileName, FileMode.Open, FileAccess.Read, FileShare.Read));                 StreamReader streamReaderPointer2 = null;                  while (streamReaderPointer1.ReadLine() != null)                 {                     i++;                     if (i == numberOfLines)                     {                         streamReaderPointer2 = new StreamReader(File.Open(fileName, FileMode.Open, FileAccess.Read, FileShare.Read));                     }                     else if (i > numberOfLines)                     {                         streamReaderPointer2.ReadLine();                     }                 }                  if (streamReaderPointer2 != null)                 {                     string line = string.Empty;                     while ((line = streamReaderPointer2.ReadLine()) != null)                     {                         Console.WriteLine(line);                     }                 }                 else                 {                     Console.WriteLine(\"Invalid Number of Lines: Number of lines are less than expected\");                 }             }             catch (Exception ex)             {                 Console.WriteLine(ex.ToString());             }             finally             {                 Console.WriteLine(\"Press key to end...\");                 Console.ReadLine();             }         }     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Build a queue of length n with first n lines. At each iteration enqueue the element read, and dequeue. Once the file end has been reached, dequeue and print lines, unless queue is empty."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use two index/pointers, one lets say P1 & P2, Now enhance P1 to n lines, if it already reaches to end of file and then print the file with 2nd pointer. If not then  start both pointer, enhance both one by one, means enhance P2 by one line and then enhance P1 by one line(starting with first line),  when we P2 reaches to end of file, then we print lines with the help of P1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#define N 33 \n \nvoid printfile(FILE *file,long offset,int line){ \n \nif(line > N ){ \nreturn; \n} \n \nif(fseek(file,-1*offset,SEEK_END)!=-1){ \n        char ch=fgetc(file); \n        if(ch == '\\n'){ \n        line++; \n        } \n        printfile(file,offset+1,line); \n        printf(\"%c\",ch); \n        } \n} \n \n \nvoid main(){ \nFILE *file = fopen(\"file.txt\",\"r\"); \nif(file == NULL){ \n//printf(\"file not found \\n\"); \nperror(\"Error\"); \n} \nprintfile(file,0,1); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"can solve this using Min Heap or priority queue and size of heap equal n and insert index of each line."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"can solve this using Min Heap or priority queue and size of heap equal n and insert index of each line."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15434720","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"31","title":"Append the last n nodes of a linked list to the beginning of the list  eg: 1->2->3->4->5->6  if n=2  5->6->1->2->3->4","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"start traversing till you traverse n elements.    start another traverse in same loop after meeting above condition       (there will be always gap of n nodes between these to pointers ) when first pointer reach to end of linked list second pointer will be n node behind. just change the pointer ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just use a simple ring buffer that is n items long to find the nth position from the end, then rearrange your pointers."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node *prepend(node * root, int k) \n{ \n        node *prev, *curr; \n        curr = root; \n        for (int i = 0; i < k; i++) { \n                curr = curr->next; \n                if (curr == NULL) \n                        return NULL; \n        } \n        prev = root; \n        while (curr->next != NULL) { \n                curr = curr->next; \n                prev = prev->next; \n        } \n        curr->next = root; \n        root = prev->next; \n        prev->next = NULL; \n        return root; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct Node *ListArrange(struct Node *node,int n) {  if(!node || n==0)   return node;  struct Node *head=node;  struct Node *first=node,*second=node;  int count=n;  while(first && count--)   first=first->next;  while(first && first->next)  {   first=first->next;;   second=second->next;  }  if(!first)   return head;  struct Node *temp=second->next;  first->next=head;  second->next=NULL;  head=temp;  return head; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This problem is of the type \"nth to last element of Linked List\". Question 2.2 of Cracking the Coding Interview book which uses a slow runner/fast runner approach."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct node* change(struct node* start,int items) {  struct node* item = start;  struct node* st = start;  struct node* last = NULL;  int move=0;     while (start != NULL)  {   if(start->next != NULL)    {    start = start->next;    move++;    if(move > items)    {     item = item->next;    }   }   else    break;  }   struct node* temp= item->next;  item->next = NULL;  start->next = st;  return temp; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static Node moveNodesToBeginning(Node root, int n) {   Node current = root;   Node slowCurrent = root;   while(current.next != null){    if(n<=0)     slowCurrent = slowCurrent.next;    current = current.next;    n--;   }   if(n>0){    current.next = root;    root = slowCurrent.next;    slowCurrent.next = null;   }   return root;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public Node rotate(Node root, int n){    Node slow = root;    Node fast = root;    for(int i=n;i>0;i--){       fast = fast.next;       if(fast==null)         return null;    }     while(fast->next!=null){        fast=fast->next;        slow=slow->next;    }               fast->next = root;    root = slow->next;    slow->next = null;    return root;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public LinkedListNode appendNodes(LinkedListNode root, int k) {   int nodeCount = 0;   LinkedListNode temp = root;   LinkedListNode lastNode = null;   while (temp != null) {    nodeCount++;    lastNode = temp;    temp = temp.getNext();   }   temp = root;   System.out.println(lastNode.getValue());   while ((nodeCount - k) != 1) {    temp = temp.getNext();    nodeCount--;   }   lastNode.setNext(root);   root = temp.getNext();   temp.setNext(null);   return root;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this solution is correct. Please test it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is using the standard Tortoise & Hare approach."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void append(node p, int n) \n{  \n  node *temp[n]; \n  temp[0]=p; \n   for(I=1;Ilink; \n    while(temp[n]->link!=null) \n          { \n           for(I=0;Ilink; \n           }  \n     temp[0]->link=null; \n      temp[n]->link=p; \n     p=temp[1]; \n   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void  appendrearTofront(int n) \n { \n  Node2 slowpointer,fastpointer; \n  slowpointer=front; \n  fastpointer=front; \n   \n  while(fastpointer!=null) \n  { \n   while((n+1)!=0) \n   { \n    fastpointer=fastpointer.nextlink; \n    n--; \n   } \n   fastpointer=fastpointer.nextlink; \n   slowpointer=slowpointer.nextlink; \n  } \n  rear.nextlink=front; \n  front=slowpointer.nextlink; \n     \n  slowpointer.nextlink=null; \n  slowpointer=rear; \n   \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void appen_n_at_beg(node* head, int n) {  if(!head)  return;  int count=1;node* p=head,*q=head;  while(p->next!=0)  {   count++;p=p->next;  }    if(count<=n)  printf(\"nodes less than or equal to n\");  for(int i=1;i  q=q->next;   p->next=head; head=q->next;root=head; q->next=0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void AppandLastnNode(Node head, int n) \n{ \n if (n<= 0 ) return; \n if (head == null) return; \n if (head.next == null) return; \n Node tmp1 = new Node(); \n Node tmp2 = new Node(); \n tmp1 = tmp2 = head ; \n for (int i = 1 ; i <= n ; i++) \n { \n  tmp2 = tmp2.next; \n } \n while (tmp2.next != null) \n { \n  tmp1 = tmp1 .next; \n  tmp2 = tmp2. next; \n } \n \n tmp2.next = head; \n head = tmp1.next; \n tmp1.next = null; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void AppendNthElementsFromEndToStart(stIntList* pRoot,stIntList*& pNew, int n) {  if(NULL == pRoot)   return;   stIntList* pCurr = NULL;  stIntList* pKthElem = pRoot;  stIntList* pPrev = NULL;  stIntList* pCurPrev = NULL;  int count = 1;  while(pKthElem != NULL)  {   pPrev = pKthElem;   pCurPrev = pCurr;   if(count < n)   {    if(NULL == pKthElem)     break;    pKthElem = pKthElem->pNList;    count++;    continue;   }   if(count == n)   {    pCurr = pRoot;    pKthElem = pKthElem->pNList;    count++;    continue;   }   pCurr = pCurr->pNList;   pKthElem = pKthElem->pNList;  }  //Now Current Node is the Nth node from reverse.  pCurPrev->pNList = NULL;  pNew = pCurr;  pPrev->pNList = pRoot; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void Ques(int k) \n{ \n//First,count the number of the elements in the linked list \n   temp=p; \n   prev=p; \n \n   int n=0; \n \n   while(temp!=NULL) \n   { \n    n++; \n \n    temp=temp->link; \n   } \n   temp=p; \n   int i; \n   for(i=0;ilink; \n    if(i!=0) \n      {//here prev has been pointing to one node before the \n      //temp since it is stopped once by putting the if condition. \n    prev=prev->link; \n \n      } \n    } \n    \n   prev->link=NULL; \n   //now the complete chain will be appended to the start of the original \n   xy=temp; \n  for(int j=i;jlink; \n  } \n  temp->link=p; \n  p=xy; \n   \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You need to keep two pointers and find the last and (n-1)th to last node. Now its simple, set the (n-1)th last node's next pointer to NULL and the last node's next pointer to point to head."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void swap_nth(node*& head, int n) \n{ \n if(head == NULL) return; \n \n node* second = head; \n for(int i = 0; i < n - 1; ++i) \n { \n  if(second->next == NULL) //still in loop and haven't iterated n-1 places \n  { \n   return; \n  } \n  second = second->next; \n } \n \n node* first = head; \n while(second->next != NULL) \n { \n  second = second->next; \n  first = first->next; \n } \n \n //now swap \n first->next = NULL; \n second->next = head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Scanner; class Node { int data; Node next; } public class LinkList { Node start=null; void addLast(int data) { Node n1=new Node(); n1.data=data; n1.next=null; if(start==null) { start=n1; } else { Node temp1=start; while(temp1.next!=null) { temp1=temp1.next; } temp1.next=n1; } } void printList() { int count=0; Node temp2=start; while(temp2!=null) { System.out.println(temp2.data); temp2=temp2.next; count++; } System.out.println(\"total no of node:\"+count); }  void append() { int c=0; Node temp3=start; while(temp3!=null) { temp3=temp3.next; c++;//no of node count. } Scanner s=new Scanner(System.in); System.out.println(\"how many node u want 2 append\"); int n=s.nextInt(); Node temp5=start; int i; for(i=1;i<=c-n;i++) { temp5=temp5.next; } while(i<=c)//first print that node u append. { System.out.println(temp5.data); temp5=temp5.next; i++; }  int p=c-n; Node temp4=start; for( i=1;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void append() { int c=0; Node temp3=start; while(temp3!=null) { temp3=temp3.next; c++; } Scanner s=new Scanner(System.in); System.out.println(\"how many node u want 2 append\"); int n=s.nextInt(); Node temp5=start; int i; for(i=1;i<=c-n;i++) { temp5=temp5.next; } while(i<=c)//first print that node u append. { System.out.println(temp5.data); temp5=temp5.next; i++; } int p=c-n; Node temp4=start; for( i=1;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void LinkedList::Prepend(int n) \n{ \n Node* fast = new Node; \n fast = this->list; \n Node* slow = new Node; \n slow = this->list; \n \n int delta = n; \n while(delta >0) \n { \n  fast = fast->next; \n  delta = delta-1; \n } \n delta = n-delta; \n while(fast->next != NULL) \n { \n  slow = slow->next; \n  fast = fast->next; \n } \n \n //slow points the target node now, point it to the start \n fast->next = this->list; \n this->list = slow->next; \n slow->next = NULL; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.Traverse the list till the end using pointer p,meanwhile update counter till p->next =NULL; 2. When p->next = null, create circular link list by p->next = head; 3.calculate diff = counter-n; 4.iterate from head till diff. 5.r= p->next 6.p->next=NULL; 7.r=head;  simple!!!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here is how I implemented this:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private void appendLastNodesToStartOfList(LinkedList linkedList, int noOfNodesToAppend){ \n  LinkedListNode lowerPtr = linkedList.getFirstLinkedListNode(); \n  LinkedListNodehigherPtr = linkedList.getFirstLinkedListNode(); \n   \n  for(int i=0;i tempNode = lowerPtr.getNextNode(); \n  lowerPtr.setNextNode(null); \n  higherPtr.setNextNode(linkedList.getFirstLinkedListNode()); \n  linkedList.setFirstLinkedListNode(tempNode);"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15388668","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"16","title":"Write a code to extract individual blocks from a given matrix.... Eg: if we have a 4x4 matrix you need to extract 2x2 independent matrices and store them in 4 different arrays... Given matrix:  1 2 3 4  5 6 7 8  9 10 11 12 13 14 15 16 For the above matrix the output should be as follows.. Array1: 1 2 5 6  Array2: 3 4 7 8 Array3: 9 10 13 14 Array4: 11 12 15 16","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Python: Can be improved though"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include using namespace std;  void MatrixToArrayFun(int arr[][4],int iCol,int iRow){  if(iCol!=iRow){  cout<<\"sorry row and column must be same\"< return;  }  int lNumber = iRow/2;    int lRound =0;  while(lNumber){   for(int i=lRound;i  for(int j=lRound;j   cout<  cout<  for(int i=lRound;i  for(int j=(2-lRound);j<(4-lRound);j++)    cout< cout<  lNumber --;  lRound+=2;  } }  int main(){ cout<<\"hello\"<int arr[4][4]={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16}; cout<MatrixToArrayFun(arr,4,4);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Pseudocode -"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Generic code when no of independent arrays = (ROW*COL/row*col) is an integer.  #include #include  void matrixToArray(int arr[][6],int ROW,int COL,int row,int col) {  if((ROW*COL)%(row*col)!=0)  {   printf(\"No splitting possible\\n\");   return;  }   int noArrays=ROW/row;  int rowBound=0;  int colBound=0;  while(noArrays--)  {   int i=0,j=0;   for(i=rowBound;i   for(j=colBound;j    printf(\"%2d \",arr[i][j]);    printf(\"\\n\");    for(i=rowBound;i   for(j=(col-colBound);j<(COL-colBound);j++)     printf(\"%2d \",arr[i][j]);    printf(\"\\n\");    rowBound+=row;  } }  int main() {  int A[4][6]={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24};  matrixToArray(A,4,6,2,3);  getchar();  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#define R 4 #define C 4 void CreateArr(int arr[R][C],int start1,int end1,int start2,int end2,int output[]) {  int local=0;  for(int i=start1;i  for(int j=start2;j   output[local++]=arr[i][j]; } int main() {  int arr[R][C]={{1,2,3,4},  {5,6,7,8},  {9,10,11,12},  {13,14,15,16}};  int size=2;  int *out=(int *)malloc(sizeof(int)*size*size);  for(int i=0;(i+size)<=R;i=i+size)  {   for(int j=0;(j+size)<=C;j=j+size)   {    memset(out,0,sizeof(int)*size*size);    CreateArr(arr,i,i+size,j,j+size,out);    for(int k=0;k<(size*size);k++)    printf(\"%d \",out[k]);    printf(\"\\n\");   }  }  getchar();  return 0; };"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can anyone please provide the code in matlab...though for loops in matlab have an advantage..i cant figure out how to create the arrays...please help me.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Test {  public static void main(String args[]) {   int arr[][] = new int[][]{{1,2,3,4,5,6},{7,8,9,10,11,12},{13,14,15,16,17,18},{19,20,21,22,23,24},{25,26,27,28,29,30},{31,32,33,34,35,36}};   int resetpos = 0, matrixsize = 6, submatrix = 2;   boolean terminate = false;         for (int i=0;i<=matrixsize && !terminate;) {    for (int j=0;j<=matrixsize && !terminate;j++)    {     if (j!=0 && j%submatrix == 0) {      i++;      j=resetpos;     }           if (i!=0 && i%matrixsize == 0) {      i=0;      resetpos += submatrix;      j=resetpos;     }          System.out.println(arr[i][j]);          if (i+1 == matrixsize && j+1 == matrixsize)      terminate = true;         }   }     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n#include  \n \nint N=8; // N*N matrix \n \nint main() { \n    int i,j; \n    int b[4][(N*N)/4]; \n    int c[2*N][4]; \n    int a[N][N]; \n    int dev=N/2; \n    srand(time(NULL)); \n \n//creating and printing input \n    for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{{ const int SIZE=4; int matrix[SIZE][SIZE]; void print(int , int , int ,int); int main() {  int size;  printf(\"Entering  %d*%d matrix using rand() \\n\",SIZE,SIZE);  for(int i=0;i {   for(int j=0;j  {    matrix[i][j]=rand();   }  }    printf(\"Enter the sub matrix size you want to print:\");  scanf_s(\"%d\",&size);    if(SIZE%size==0)  {   print(0,0,size,SIZE);  }  return 0; }  void print(int i, int j, int size, int SIZE) {  int row=i, column=j;  for(;i {   for(j=column;j  {    printf(\"%-7d\",matrix[i][j]);   }  }  printf(\"\\n\\n\");    if(j {   i-=size;   print(i,j,size,SIZE);  }  else  {   if(i  {    j=0;    print(i,j,size,SIZE);   }  } } }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/*1 2 3 4      5 6 7 8      3 5 0 8      9 2 1 5*/      /*the output must be      1 2 5 6      3 4 7 8      3 5 9 2      0 8 1 5*/ #include int a[10][10]; int main() {     int m,i,j;      printf(\"enter the value of m:\\n\");     scanf(\"%d\",&m);     printf(\"enter the matrix elements:\\n\");     for(i=0;i    for(j=0;j    scanf(\"%d\",&a[i][j]);     print(m);     return 0; } int print(int m) {     int aa[(m*m)/2][4],k=0,i=0,j=0;     i=0;j=0;     while(i    {         aa[k][0]=a[i][j];         aa[k][1]=a[i][j+1];         aa[k][2]=a[i+1][j];         aa[k][3]=a[i+1][j+1];         k++;         if(j+2        j+=2;         else{         j=0;i+=2;}     }     for(i=0;i        printf(\"\\nthe elements of array%d is:\",i+1);         for(j=0;j<4;j++)         printf(\"\\n%d:\",aa[i][j]);}     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList; \n \npublic class SubMatrix { \n int[][] matrix; \n int M; \n \n public SubMatrix(int m) { \n  super(); \n  M = m; \n  matrix = new int[M][M]; \n  for (int i = 0; i < M; i++) { \n   for (int j = 0; j < M; j++) { \n    matrix[i][j] = (int) (Math.random() * 10 + 1); \n   } \n  } \n } \n \n public void subMatrix(int subNum) { \n  if (subNum <= 0 || M % subNum != 0) { \n   System.out.println(\"cannot extract individal blocks\"); \n   return; \n  } \n  int blockSize = M / subNum; \n  ArrayList[] lists = new ArrayList[blockSize * blockSize]; \n  for (int i = 0; i < blockSize * blockSize; i++) { \n   lists[i] = new ArrayList(); \n  } \n \n  for (int index = 0; index < blockSize * blockSize; index++) { \n   for (int k = 0; k < subNum * subNum; k++) { \n    int row = index / blockSize * subNum + k / subNum; \n    int column = index % blockSize * subNum + k % subNum; \n    lists[index].add(k, matrix[row][column]); \n   } \n  } \n \n  for (int index = 0; index < blockSize * blockSize; index++) { \n   System.out.println(lists[index]); \n  } \n } \n \n public void print() { \n  for (int i = 0; i < M; i++) { \n   for (int j = 0; j < M; j++) { \n    System.out.print(matrix[i][j] + \"\\t\"); \n   } \n   System.out.println(); \n  } \n } \n \n public static void main(String[] args) { \n  SubMatrix sm = new SubMatrix(6); \n  sm.print(); \n  sm.subMatrix(3); \n \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I supposed R and C be the number rows and columns respectively of the Array from where data is to be extracted. r and c be the number rows and columns respectively of the new array;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include   int main() {  int arry[4][4] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};  int i,j,m,n;  int count = 1;   for(i=0;i<3;i+=2)  {    for(j=0;j<3;j+=2)    {      printf(\"Array %d = \",count);      for(m=i;m     {        for(n=j;n       {          printf(\"%d\\t\",arry[m][n]);        }      }      count++;      printf(\"\\n\\n\");     }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void exactindividualblock() {  int a[][4]={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};  int size=4;  for(int i=0;i for(int j=0;j {  for(int m=i;m {   for(int k=j;k    }  } }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15443694","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"11","title":"Implement Queue using stacks","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"11","title":"Keep 2 stacks, let's call them inbox and outbox.  Queue: - Push the new element onto inbox  Dequeue: - If outbox is empty, refill it by popping each element from inbox and pushing it onto outbox - Pop and return the top element from outbox  Using this method, each element will be in each stack exactly once - meaning each element will be pushed twice and popped twice, giving amortized constant time operations.  Here's an implementation in Java: public class Queue {      private Stack inbox = new Stack();     private Stack outbox = new Stack();      public void queue(E item) {         inbox.push(item);     }      public E dequeue() {         if (outbox.isEmpty()) {             while (!inbox.isEmpty()) {                outbox.push(inbox.pop());             }         }         return outbox.pop();     }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Suppose you want to make queue of length n Take two stacks, Stack1 and Stack2 of length n each ----------------------------------------------------------- 1) Push - Bottomline - Always push in Stack1.  IF Stack1 is full and Stack2 is not empty - Print Queue overflow IF Stack1 is full and Stack2 is empty - Pop every item from Stack1 and push it in Stack2, till Stack1 is empty.  After that push new element on Stack1  2) Pop -  Bottomline - Always pop from Stack2  IF Stack2 is empty and Stack1 is empty - Print Queue Underflow. IF Stack2 is empty and Stack1 is not empty- Pop every item from Stack1 and push it in Stack2.  Pop from Stack2."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It's the Tower of Hanoi algorithm."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Enqueue: push onto Stack A. 2. Dequeue: push all elements from (1) onto Stack B. Pop top-element from Stack B until empty. If Enqueue is necessary, push onto Stack A while Stack B is not empty. 3. When stack B is empty, push elements from stack A to Stack B. 4. and so on..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public E dequeue() { //generic - not syncronized \n if (outbox.isEmpty()) { // Asymptotic condition - When it goes empty O(n) \n  while (!inbox.isEmpty()) { \n   outbox.push(inbox.pop()); \n  } \n } \nreturn outbox.pop(); // O(1) \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class Queue \n    { \n        Stack enQueueStack = new Stack(); \n        const int size = 10;  \n        public void Enqueue(int n) \n        { \n            if (size > deQueueStack.Lenght) \n            { \n                while (deQueueStack.Lenght > 0) \n                { \n                    enQueueStack.Push(deQueueStack.Pop()); \n                } \n                enQueueStack.Push(n); \n            } \n        } \n \n        Stack deQueueStack = new Stack(); \n        public int Dequeue() \n        { \n            while (deQueueStack.Lenght > 0) \n            { \n                deQueueStack.Push(enQueueStack.Pop()); \n            } \n            return deQueueStack.Pop(); \n        } \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Will maintain size variable separately, so that we don't need to bother about which stack is empty/full.  Enqueue:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15339673","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"9","title":"Write some functions in c/c++ and then re-write the same function that can improve performance(cpu/memory etc) and explain why?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Any c++ function which are using inline function will have more memory when they are being called in loops because it the code will expand at compile time and hence it will increase the memory size .instead of that if we have normal function only once the object code will be generated therefore it will take less memory .  Second - we can optimize c++ program by seeing when we are returning from function by value it created temporary variable for that they call constructor and destructor which also can be avoided ..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In C++ the register keyword has no effect at all."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"one complement to comments above. 1. Cache consider a big array long ar[100][100].   a) for (int i = 0; i < 100; ++i)   for (int j = 0; j < 100; ++j)  b) for (int j = 0; j < 100; ++j)   for (int i = 0; i < 100; ++i) a) is better and faster, most-of-the-time, than b). Because a)'s traversal is smooth and using cache, while b) makes big jumps and cachemiss occurs. This also tells us to use vectors as a default container. As Stroustrup mentioned in GoNative2012, it has been tested that vectors run faster that lists even in heavy use of insertion and deletion."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"we can create register variable instead of auto variable like(register int i=0;i<128;i++)  it increase the performance i m not sour but hopeful :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"class A { ... }; class B { ... }; class C {  A a;  B b;  C(A &a1, B &b1)  {      a = a1;       b = b1;  } };   Good code:class A { ... }; class B { ... }; class C {  A a;  B b;  C(A &a1, B &b1): a(a1),b(b1)  {  } };"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"Hopefull you wouldn't be hired..."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15366664","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"25","title":"Write  a function that gets a number n and prints out a random list   of numbers 1..n to the screen. For example:       randlist(5) : 1 5 3 2 4     randlist(6) : 4 6 1 5 3 2    This should be truly random (uniformly spread) and with a O(n) complexity.  Every number should appear only once. Random(n) is given as a tool you can use to generate a single random number between 1-n","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"public static void shuffleArray(int[] a) {      int n = a.length;      Random random = new Random();      //random.nextInt();      for (int i = 0; i < n; i++) {        int change = i + random.nextInt(n - i);        swap(a, i, change);      }    }     private static void swap(int[] a, int i, int change) {      int helper = a[i];      a[i] = a[change];      a[change] = helper;    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Here I implemented Knuth Shuffle Algorithm in C++ for this problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"#include \n#include \n \nTime -- O(n) Space O(n) \n \nProbability of rand genarating index i == 1/n. \nfor the function to take O(n2) time -- probability = (1/n)**n; \n \nSo for smaller n it will take about n2 but for large n it is O(n).. \n \nYou could remove the inner do while loop. But then it won't be truly random. \n \nvoid c15366664RandSequenc() { \n    srand(time(NULL)); \n    int a[10], n = 10; \n    for (int i = 0; i < n; i++) \n        a[i] = i; \n    int sI = 0, swapper; \n    for (int i = 0; i < n; i++) { \n        do { \n            sI = rand() % n; \n        } while (sI == i); \n        swapper = a[sI]; \n        a[sI] = a[i]; \n        a[i] = swapper; \n    } \n    for (int i = 0; i < n; i++) \n        cout << a[i] << \" \"; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"package Tricky; \n \nimport java.util.Random; \n \npublic class RandomShuffle { \n \n int[] arr = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20}; \n  \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n  RandomShuffle shuffle = new RandomShuffle(); \n  shuffle.shuffleArray(); \n   \n } \n \n private void shuffleArray() { \n  Random random = new Random(); \n   \n  for(int i =0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void randlist(int x) \n{ \n  \n ArrayList buffer = new ArrayList(); \n int random_integer; \n  for(int i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution is Java based   Create a  HashSet   in a for loop generate the numbers Random(n) function, and check if it exists in HashSet or not, if it doesn't then print it else try again.  HashSet will give you read operations in O(1) time, hence the running time is O(n).  If you want you can use HashMapas well, with the key as the number generated and use value as null (or 1 for morbidly curious minds :) ) since we are only checking if the key exists or not."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  #include  #include  #include   using namespace std; static int rand_int(int n) {   int limit = RAND_MAX - RAND_MAX % n;   int rnd;    do {     rnd = rand();   } while (rnd >= limit);   return rnd % n; } void shuffle(int *array, int n) {   int i, j, tmp;    for (i = n - 1; i > 0; i--) {     j = rand_int(i + 1);     tmp = array[j];     array[j] = array[i];     array[i] = tmp;   } } int main(int argc, char *argv[]) {  long *nullptr=NULL;   srand(time(nullptr));   int arr[]={1,2,3,4,5,6,7,8};   int length=sizeof(arr)/sizeof(arr[0]);   shuffle(arr,length);   for(int k=0;k   {    cout<  }   return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bgfjnsmrdrbbzrzxnqumoanmijmzun"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this is the easiest question I have ever seen  void printRandom(int n){  vector numbers; for(int i=1;i<=n;i++)     numbers.push_back(i);  for(int i=n;i>0;i--) {     int rand = rand()%i;     printf(\"%d \", numbers[rand]);     numbers.erase(numbers.begin()+rand); }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void printNRandomNumbers(int n) {     int a[] = new int[n];     for(int i = 0; i < n; i++) {       a[i] = i + 1;     }     for(int i = 0; i < n; i++) {       int no = (int) (Math.random() * (n - i)) + i;       int tmp = a[i];       a[i] = a[no];       a[no] = tmp;     }     for(int i : a) {       System.out.print(i + \" \");     }   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class RandList { \n private static int Random(int n) { \n  return (int) (Math.random() * n + 1); \n } \n \n public static void printRandList(int n) { \n  int[] array = new int[n]; \n  for (int i = 0; i < n; i++) { \n   array[i] = i; \n   ; \n  } \n  // shuffle array \n  for (int i = 0; i < n; i++) { \n   int index = (Random(n) + i) % n; \n   int tmp = array[i]; \n   array[i] = array[index]; \n   array[index] = tmp; \n  } \n  for (int i : array) { \n   System.out.print(i + \"\\t\"); \n  } \n  System.out.println(); \n } \n \n public static void main(String[] args) { \n  printRandList(5); \n } \n \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15317844","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"22","title":"Given a binary tree, find a binary search tree which is a subtree of the given binary tree and has the largest size?  Note : Here size means the no. of nodes and the binary tree can have more than one B.S.T. as its subtree.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"leetcode .  com / 2010 / 11 / largest-binary-search-tree-bst-in.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can divide the problem into several small problems:  1) For each node p, is the subtree with p as its root a binary search tree? 2) If it is a binary search tree, what is the size of the tree?  We can use recursion to do this: Step1. for each node p, compute the minimum and maximum element of the subtree that rooted in p, as well as the size of the subtree. Step 2. for each node p, check the maximum element of its left subtree and the minimum element of its right subtree to see if it is a BST, and if it is, sum up the size of the left right subtree and itself to get the size. Step 3. Traversal the tree to find out the maximum BST as its subtree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* Its difficult to understand what's going on in the code --  \nIt is a divide an conquer.. \nWhere we find the largest subtree in left. \nAnd largest subtree in right. \nand if root satisfies the BST property ..  \nTake max of (3,Union(root, left, right)) .. \n \nUnion means joining the subtree's to the root if their heads are the children. \nHere is the algo \nTraverse Post Order. \nAt each Node  \n    Base case -- if leaf  ----- return 1; \nIf BST property is satisfied at this node then..  \n     Add set the value to 3; \n     if left is positive add it and subtract 1. \n     if right is positive add it and subtract 1. \n     Take max of left, right and current value. and return that. \nelse  \n     Take absolute of left and right values. Then take the max between them. \n      return the negative of this number. \n \nIn the end return the absolute of this answer. \n \nThe code only gives the size of the max tree. but easily we can augment this code  \nto find out the tree. by keeping track of the current max tree and discarding the other. \n \nWe will have to destroy the tree. Other wise it will take exponential space. \nBut since one node can be a part of only one such candidate tree. Time complexity still remains O(n). \n \nI have not written that code. because of lack of time. \n \ntypedef struct SearchTree { \n    int val; \n    struct SearchTree *l; \n    struct SearchTree *r; \n} bst; \n \n \nint largestBSTIn(bst *head) { \n    int l = 0, r = 0, h = 0; \n    if (head->l == NULL && head->r == NULL) \n        return 1; \n    if (head->l) \n        l = largestBSTIn(head->l); \n    if (head->r) \n        r = largestBSTIn(head->r); \n    cout << \"\\n\" << head->val << \" \" << l << \" \" << r; \n    if ((head->l == NULL || head->l->val < head->val) && ((head->r == NULL) || head->val < head->r->val)) { \n        h = (l > 0) ? (h + l) : h; \n        h = (r > 0) ? (h + r) : h; \n        h++; \n        if (l < 0) { \n            h++; \n            l = -l; \n            h = (h > l) ? h : -l; \n        } \n        if (r < 0) { \n            h++; \n            r = -r; \n            h = (h > r) ? h : -r; \n        } \n    } else { \n        if (l < 0) l = -l; \n        if (r < 0) r = -r; \n        h = -(l > r ? l : r); \n    } \n    return h; \n} \nint largestBST(bst *head) { \n    int ans = largestBSTIn(head); \n    return (ans > 0 ? ans : (-ans)); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The idea here is traverse tree in inorder fashion and count the node and update the tree if it is BST. Checking for BST and counting the node can be done in same recursion for in order. It happens in one scan of tree and time complexity is O(n). Here is the code."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I posted the isBST function. Sorry, I passed a parameter node_count that is not even used and ignore that while going through code."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can we do a inorder travelsal of the tree - return as an array and the longest sorted portion of the array would be the largest BST in the binary tree"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bottom up recursion  int min,max,no,tempmin,tempmax,largestno=-1; node largest; int largest(node root){ if(root==null) return 0;  int l=largest(root.left); if(l!=-1&&l!=0){ tempmin=min;if(root.data<=max) return -1;} else if(l==0) tempmin=root.data; else return -1;  int r=largest(root.right); if(r!=-1&&r!=0){ tempmax=max;if(root.data>=min) return -1;} else if(r==0) tempmax=root.data; else return -1;  min=tempmin; max=tempmax; no=1+l+r; if(no>largestno) largest=root; return no; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if the subtree doesn't require containing all the subnodes  int no=0,max=-1; node largest; node largest(node root,int min,int max){ if(root==null){ no=0; return null;}  node l=largest(root.left,min,root.data); node x=new node(root); int tmp=no; x.left=l; x.right=largest(root.right,root.data,max);  if(root.datamin){ no=tmp+no+1; if(no>max) largest=x; return x;}  no=0; return null; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int maxCount = 0; \nTreeNode1* maxTree = NULL; \n \nint LargestBSTSubtree(TreeNode1* root) \n{ \n // If empty node, return 0 \n if(!root) \n  return 0; \n \n // find the largest BST in left tree \n int left =  LargestBSTSubtree(root->left); \n  \n // find the largest BST in left tree \n int right =  LargestBSTSubtree(root->right); \n \n // if either child is not a BST, this can be a BST \n if(left==-1 || right==-1) \n  return -1; \n \n // verify if current node, holds BST properties \n if((root->left) && root->left->val > root->val) \n  return -1; \n \n if((root->right) && root->right->val < root->val) \n  return -1; \n \n // if all good, check if this is the largest \n if(maxCount"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* Returns size of the largest BST subtree in a Binary Tree \n  (efficient version). */ \nint largestBST(struct node* node) \n{ \n  // Set the initial values for calling largestBSTUtil() \n  int min = INT_MAX;  // For minimum value in right subtree \n  int max = INT_MIN;  // For maximum value in left subtree \n  \n  int max_size = 0;  // For size of the largest BST \n  bool is_bst = 0; \n  \n  largestBSTUtil(node, &min, &max, &max_size, &is_bst); \n  \n  return max_size; \n} \n  \n/* largestBSTUtil() updates *max_size_ref for the size of the largest BST \n   subtree.   Also, if the tree rooted with node is non-empty and a BST, \n   then returns size of the tree. Otherwise returns 0.*/ \nint largestBSTUtil(struct node* node, int *min_ref, int *max_ref, \n                            int *max_size_ref, bool *is_bst_ref) \n{ \n  \n  /* Base Case */ \n  if (node == NULL) \n  { \n     *is_bst_ref = 1; // An empty tree is BST \n     return 0;    // Size of the BST is 0 \n  } \n  \n  int min = INT_MAX; \n  \n  /* A flag variable for left subtree property \n     i.e., max(root->left) < root->data */ \n  bool left_flag = false; \n  \n  /* A flag variable for right subtree property \n     i.e., min(root->right) > root->data */ \n  bool right_flag = false; \n  \n  int ls, rs; // To store sizes of left and right subtrees \n  \n  /* Following tasks are done by recursive call for left subtree \n    a) Get the maximum value in left subtree (Stored in *max_ref) \n    b) Check whether Left Subtree is BST or not (Stored in *is_bst_ref) \n    c) Get the size of maximum size BST in left subtree (updates *max_size) */ \n  *max_ref = INT_MIN; \n  ls = largestBSTUtil(node->left, min_ref, max_ref, max_size_ref, is_bst_ref); \n  if (*is_bst_ref == 1 && node->data > *max_ref) \n     left_flag = true; \n  \n  /* Before updating *min_ref, store the min value in left subtree. So that we \n     have the correct minimum value for this subtree */ \n  min = *min_ref; \n  \n  /* The following recursive call does similar (similar to left subtree) \n    task for right subtree */ \n  *min_ref =  INT_MAX; \n  rs = largestBSTUtil(node->right, min_ref, max_ref, max_size_ref, is_bst_ref); \n  if (*is_bst_ref == 1 && node->data < *min_ref) \n     right_flag = true; \n  \n  // Update min and max values for the parent recursive calls \n  if (min < *min_ref) \n     *min_ref = min; \n  if (node->data < *min_ref) // For leaf nodes \n     *min_ref = node->data; \n  if (node->data > *max_ref) \n     *max_ref = node->data; \n  \n  /* If both left and right subtrees are BST. And left and right \n     subtree properties hold for this node, then this tree is BST. \n     So return the size of this tree */ \n  if(left_flag && right_flag) \n  { \n     if (ls + rs + 1 > *max_size_ref) \n         *max_size_ref = ls + rs + 1; \n     return ls + rs + 1; \n  } \n  else \n  { \n    //Since this subtree is not BST, set is_bst flag for parent calls \n     *is_bst_ref = 0; \n     return 0; \n  } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the following one is the optimum solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class LargestBSTSubTree { \n class BinaryTree { \n  int data; \n  BinaryTree left; \n  BinaryTree right; \n } \n \n public BinaryTree findLagestSubTree(BinaryTree root) { \n  BinaryTree largestBST = null; \n  Integer min = Integer.MAX_VALUE; \n  Integer max = Integer.MIN_VALUE; \n  Integer maxNodes = Integer.MIN_VALUE; \n  findLargestBSTSubTreeUtil(root, min, max, maxNodes, largestBST); \n  return largestBST; \n } \n \n private int findLargestBSTSubTreeUtil(BinaryTree root, Integer min, \n   Integer max, Integer maxNodes, BinaryTree largestBST) { \n  if (root == null) { \n   return 0; \n  } \n  boolean isBST = true; \n   \n  int leftBSTNodes = findLargestBSTSubTreeUtil(root.left, min, max, \n    maxNodes, largestBST); \n  int currMin = (leftBSTNodes == 0) ? root.data : min; \n  if (leftBSTNodes == -1 || (leftBSTNodes != 0 && root.data <= max)) { \n   isBST = false; \n  } \n \n  int rightBSTNodes = findLargestBSTSubTreeUtil(root.right, min, max, \n    maxNodes, largestBST); \n  int currMax = (rightBSTNodes == 0) ? root.data : max; \n  if (rightBSTNodes == -1 || (rightBSTNodes != 0 && root.data >= min)) { \n   isBST = false; \n  } \n   \n  if (isBST) { \n   min = currMin; \n   max = currMax; \n   int totalNodes = leftBSTNodes + rightBSTNodes + 1; \n   if (totalNodes > maxNodes) { \n    maxNodes = totalNodes; \n    largestBST = root; \n   } \n   return totalNodes; \n  } else { \n   return -1; \n  } \n } \n \n public static void main(String[] args) { \n \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"int largest(struct node*root){  int left,right;  if(root==NULL) return 0;  else if(root->left==NULL && root->right==NULL) return 1;  else{   left=largest(root->left);   right=largest(root->right);   if(root->left==NULL)    if(root->dataright->data)     return right+1+left;    else      return right;   else if(root->right==NULL)    if(root->data>root->left->data)     return left+1+right;    else     return left;   else if(root->data>root->left->data && root->dataright->data)    return left+right+1;   else return left>right?left:right;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"int FindBST(struct Node *node,int min,int max,int &maxnodes,struct Node *& root,struct Node *& child) {  if(node==NULL)   return 0;  if(node->data>min && node->data {   int leftnodes=FindBST(node->left,min,node->data,maxnodes,root,child);   struct Node *left=(leftnodes?child:NULL);   int rightnodes=FindBST(node->right,node->data,max,maxnodes,root,child);   struct Node *right=(rightnodes?child:NULL);    struct Node *parent=NewNode(node->data);   parent->left=left;   parent->right=right;    child=parent;    int count=leftnodes+rightnodes+1;   if(count>maxnodes)   {    maxnodes=count;    root=parent;   }   return count;  }  else  {   FindBST(node,-999,999,maxnodes,root,child);   return 0;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Can we do a inorder travelsal of the tree - return as an array and the longest sorted portion of the array would be the largest BST in the binary tree"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"found the drawback in the algo"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15321836","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"34","title":"Given two linked lists combine them in a way such that the resultant must contain the elements alternatively from one list and the other list?  For ex.  LL1 : 1->2->3->4 LL2 : 5->6->7  Result : 1->5->2->6->3->7->4  Also provide test cases for the algorithm ?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"struct Node *MergeOnebyOne(struct Node *a,struct Node *b) {  if(!a)   return b;  if(!b)   return a;  struct Node *head=a,*res=a,*prev=NULL;  while(a && b)  {   struct Node *t=a->next;   struct Node *q=b->next;   res->next=b;   res=res->next;   res->next=t;   prev=res;   res=res->next;   a=t;   b=q;  }  if(a)   prev->next=a;  else if(b)   prev->next=b;  return head; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Look at below method in java. This method accept 2 areguments, both are first node of two different list which we want to merge one by one. Any suggestion is appreciated."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void joinLL(LL ll1,LL ll2){ \n  joinLL(ll1.first,ll2.first); \n} \npublic static void joinLL(Node first1,Node first2){ \n  if(first1==null || first2==null)return; \n  Node temp1=first1.next; \n  Node temp2=first2.next; \n  first1.next=first2; \n  if(temp1!=null)first2.next=temp1; \n  joinLL(temp1,temp2);  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Did any one think about the test cases for this question?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"start = a = firstList; \nb = a->next;  \nc = secondList; \nd = c->next; \nwhile(firstList ->next != NULL && a!=NULL && b!=NULL && c!=NULL) \n{ \na->next = c; \nc->next = b; \na = b; \nc = d; \nb = b->next;  \nd = d == NULL? NULL: d->next; \nfirstList = firstList->next ->next; \n} \nPrintResult(start);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"_linkList* combine(_linkList* head1, _linkList* head2) {  if(head1 == NULL && head2 == NULL)   return NULL;  if(head1 == NULL)   return head2;  else if(head2 == NULL)   return head1;   _linkList* curr1 = head1->next;   _linkList* curr2 = head2->next;  head1->next = head2;  head2->next = combine(curr1, curr2);  return head1; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class CombineTwoList {  public static LinkedList CombineList(LinkedList l1,    LinkedList l2) {   if (l1.isEmpty() && l2.isEmpty()) {    return null;   }   if (l1.isEmpty())    return l2;   if (l2.isEmpty())    return l1;    int FirstListLength = l1.size();   int SecondListLength = l2.size();   if (l1.size() < l2.size()) {    for (int i = 0; i < FirstListLength; i++) {     Integer tempInt = (Integer) l1.remove(0);     l2.add((i + i + 1), tempInt);    }    return l2;   } else {    for (int i = 0; i < SecondListLength; i++) {     Integer tempInt = (Integer) l2.remove(0);      l1.add((i + i + 1), tempInt);    }    return l1;   }   }   public static void main(String[] args) {   LinkedList list1 = new LinkedList();   LinkedList list2 = new LinkedList();   list1.add(1);   list1.add(2);   list1.add(3);   list1.add(4);   list2.add(5);   list2.add(6);   list2.add(7);   LinkedList output = CombineList(list1, list2);   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"When I was being interviewed by microsoft, the guy told me to give a 4 line recursive solution to above question, this was my solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here what I came up with the solution and test cases so far...Assuming I have two lists list1 and list2 Code.. { Node curr1 = list1.head;             Node curr2 = list2.head;             if (curr1 == null || curr2 == null) //Checking if any of the list is empty                 return;             //Counting the nodes or lenght of both the lists              while (curr1 != null)             {                 count1++;                 curr1 = curr1.next;             }             while (curr2 != null)             {                 count2++;                 curr2 = curr2.next;             }             //Logic of joining is to create a new node and appned in the middle of two elements of list1. The data in the new node is coming from List2. That way adding elemts of list2 alternatively in the middle of two elemnts of list1             if (count1 < count2 || count1 == count2)                 count = count1 - 1;             else                 count = count2;             curr1 = list1.head;             curr2 = list2.head;             while (count != 0)             {                 {                     Node newnode = new Node();                     newnode.data = curr2.data;                      newnode.next = curr1.next;                     curr1.next = newnode;                     curr1 = curr1.next.next;                     curr2 = curr2.next;                 }                 count--;             }             if (count1 < count2 || count1 == count2) //If List1 is smaller than list2 then appending the remaining nodes of list2 to the last elemnt of list1.                 curr1.next = curr2;              curr1 = list1.head;             Console.WriteLine(\"Conected list is:\");             while (curr1 != null)             {                 Console.WriteLine(curr1.data);                 curr1 = curr1.next;             }             /*              * TEST CASES              * 1 What if both lists are empty or any one lost is empty              * Is it joining the lists with alternative elements              * Is it handling the situation where 1 list is smaller than the other.              * It is working if both the lists are of same length.              * Whats the complexity?              * */         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node* alternate(node* L1, node* L2) { \n   if(L1 == null) \n      return L2; \n   else if(L2 == null) \n      return L1; \n \n   node* result = L1; \n \n   while(L2) { \n       node* t = L1->next; \n       L1->next = L2; \n       L2 = t; \n       L1 = L1->next; \n   } \n \n   return result; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node* join(node* head1, node* head2) \n{ \n  node* temp1=head1; \n  node* temp2=head2; \n \n  while(temp1!=NULL&&temp2!=NULL) \n  { \n \n    head2=head2->next; \n \n    temp2->next=temp1->next; \n    temp1->next=temp2; \n    temp1=temp2->next; \n \n    if(temp2->next!=NULL) \n     temp2=head2; \n    else \n     temp2->next=head2; \n \n  } \n \n  return head1!=NULL?head1:head2;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.LinkedList; \n \npublic class CombineLinkedList { \n \n public static LinkedList combine(LinkedList l1, \n   LinkedList l2) { \n  if (l1 == null && l2 == null) { \n   return null; \n  } else if (l1 == null) { \n   return l2; \n  } else if (l2 == null) { \n   return l1; \n  } \n  // handle common cases \n  LinkedList result = new LinkedList(); \n  int size1 = l1.size(); \n  int size2 = l2.size(); \n  int size = size1 < size2 ? size1 : size2; \n  for (int i = 0; i < size; i++) { \n   result.add(l1.get(i)); \n   result.add(l2.get(i)); \n  } \n  if (size1 < size2) { \n   for (int i = size1; i < size2; i++) { \n    result.add(l2.get(i)); \n   } \n  } else if (size1 > size2) { \n   for (int i = size2; i < size1; i++) { \n    result.add(l1.get(i)); \n   } \n  } else { \n   ; \n  } \n  return result; \n } \n \n public static void main(String[] args) { \n  LinkedList list1 = new LinkedList(); \n  list1.add(1); \n  list1.add(2); \n  list1.add(3); \n  list1.add(4); \n  LinkedList list2 = new LinkedList(); \n  list2.add(5); \n  list2.add(6); \n  list2.add(7); \n  LinkedList list = combine(list1, list2); \n  System.out.println(list); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is solution in C#.net   public MyNode MergeOneByOne(MyNode node1, MyNode node2)         {              MyNode cur, head;             if (node1 != null && node2 != null)             {                 cur = head = node1;                 node1 = node1.next;             }             else                 return null;             while (node1 != null || node2 != null)             {                 if (node2 != null)                 {                   cur = cur.next = node2;                    node2 = node2.next;                 }                 if (node1 != null)                 {                     cur = cur.next = node1;                     node1 = node1.next;                 }             }             return head;         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//If Both Node are in same size Node *MergeOnebyOne(Node *n1,Node *n2) {  Node *res = new Node;  if(n1 != NULL)  {   res = new Node();   res->data = n1->data;   res->next = NULL;  }  if(n2 != NULL)  {   Node * tmp = new Node;   tmp->data = n2->data;   tmp->next = NULL;   res->next = tmp;       }  if((n1->next != NULL) && (n2->next != NULL))  {   Node *more = MergeOnebyOne(n1->next,n2->next);   res->next->next = more;  }   return res; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this works for all cases, any suggestion will be appreciated."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node* alternate(Node* p,Node* q) {     int flag1=flag2=1;  if(p == NULL)   return q;  if(q == NULL)   return p;     node *head,*p1,*p2;  p1 = p;  p2 = q;  while(p1 != NULL && p2 != NULL)  {   if(flag1)   {          head->next = p1;          p1= p1->next;       flag1 = 0;       flag2 =1;   }       if(flag2)     {         head->next = p2;         p2 = p2->next;      falg2 = 0;      flag1 =1;     }       }  //when one of them go to the end ,flag1 = flag2 =0  if(flag1 == 0 && flag2 ==0)     {         if(p1 != NULL)       head->next = p1;      if(q2 != NULL)       head->next = p2;     }     return head; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void Main(string[] args) \n        { \n            int[] a = new int[] {1,2,3,4 }; \n            Node root0 = CreateAList(a); \n \n            int[] b = new int[] { 5, 6, 7 }; \n            Node root1 = CreateAList(b); \n \n            Node c = CrossCombineTwoLinkList(root0, root1); \n        } \n \n        static Node CrossCombineTwoLinkList(Node a, Node b) \n        { \n            Node root = a; \n            Node aPre = null; \n            Node bPre = null; \n            while (a != null & b != null) \n            { \n                aPre = a; \n                a = a.Next; \n                bPre = b; \n                b = b.Next; \n \n                aPre.Next = bPre; \n                bPre.Next = a; \n            } \n \n            if (b != null) \n            { \n                aPre.Next = b; \n            } \n \n            return root; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void merge_one_by_one(struct node* *start1,struct node* *start2){ \n struct node *p=*start1,*q=*start2,*r,*s; \n while(p && q) \n { \n  r=p->next; \n  s=q->next; \n  p->next=q; \n  q->next=r; \n  p=r; \n  q=s; \n  if(!p->next) \n  { \n   p->next=q; \n   return; \n  } \n  p=p->next; \n  q=q->next; \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void MergeListAlternatively(stIntList* pList1,stIntList* pList2,stIntList*& pSorted) {  bool bFirstIncremented = false;  stIntList* pTemp1 = pList1;  stIntList* pTemp2 = pList2;  stIntList* pCurr = NULL;  while(pTemp1 != NULL || pTemp2 != NULL)  {   if(!bFirstIncremented)   {    if(pTemp1 != NULL)    {     if(pSorted == NULL)     {      pSorted = new stIntList;      pSorted->data = pTemp1->data;      pSorted->pNList = NULL;      pCurr = pSorted;     }     else     {      stIntList* pNew = new stIntList;      pNew->data = pTemp1->data;      pNew->pNList = NULL;      stIntList* pTemp = pCurr;      pTemp->pNList = pNew;      pCurr = pNew;     }     pTemp1 = pTemp1->pNList;    }    bFirstIncremented = true;   }   if(bFirstIncremented)   {    if(pTemp2 != NULL)    {     stIntList* pNew = new stIntList;     pNew->data = pTemp2->data;     pNew->pNList = NULL;     stIntList* pTemp = pCurr;     pTemp->pNList = pNew;     pCurr = pNew;     bFirstIncremented = false;     pTemp2 = pTemp2->pNList;    }    bFirstIncremented = false;   }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this?  While end of second list is not reached just insert Each node from second between two noded of first list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void merge_lists(node*& head1, node*& head2) \n{ \n if(head1 == NULL) \n { \n  head1 = head2; \n  return; \n } \n \n if(head2 == NULL) return; \n \n node* ptr1 = head1, ptr2 = head2; \n while(ptr1->next != NULL && ptr2->next != NULL) \n { \n  ptr2->next = ptr1->next; \n  ptr1->next = ptr2; \n \n  ptr1 = ptr1->next; \n  ptr2 = ptr2->next \n } \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15321835","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"20","title":"Give an algorithm which removes the occurrence of A and I from string ? The algorithm must be in-place.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"14","title":"void c15321835RemoeAI(char s[]) { \n    int p = 0, i = 0; \n    for (i = 0; s[i]!=0; i++) { \n        if (s[i] == 'a' || s[i] == 'i') \n            p++; \n        else \n            s[i - p] = s[i]; \n    } \n    s[i - p] = 0; \n    cout << s; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"static void RemoveChars(ref string s, char c) \n{ \n int index; \n while (( index = s.IndexOf(c)) >= 0) \n { \n  s = s.Substring(0, index) + s.Substring(index + 1); \n }    \n} \nstatic void ModifyString(string s) \n{ \n RemoveChars(ref s, 'A'); \n RemoveChars(ref s, 'L'); \n Console.WriteLine(s); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"import java.util.HashSet; \nimport java.util.Set; \n \npublic class RemoveChar { \n \n public static void remove(char[] string, Set set) { \n  int currPtr = 0; \n  int ptr = 0; \n  for(currPtr = 0;currPtr < string.length;currPtr++){ \n   if(set.contains(string[currPtr])){ \n    ptr++; \n   }else{ \n    string[currPtr - ptr] = string[currPtr]; \n   } \n  } \n  while(ptr > 1){ \n   string[currPtr - ptr] = 0; \n   ptr--; \n  } \n  string[currPtr - ptr] = 0; \n } \n \n public static void main(String[] args) { \n  Set set = new HashSet(); \n  set.add('a'); \n  set.add('i'); \n//  char[] string = { 'a', 'b', 'c', 'i', 'a', 'b', 'c' }; \n  char[] string = { 'a', 'i', 'a'}; \n  remove(string, set); \n  for (char c : string) { \n   System.out.print(c + \" \"); \n  } \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public String removeOccurence(String word, char[] letters){ \n        int pivot1 = 0; \n        int pivot2 = 0; \n        char[]  words = word.toCharArray(); \n        int length = words.length-1; \n        while (pivot1 <= length){ \n            while (pivot1 <= length && (!isContainsLetter(words[pivot1], letters))){ \n                words[pivot2] = words[pivot1]; \n                pivot2++; \n                pivot1++; \n            } \n            while (pivot1 <= length && (isContainsLetter(words[pivot1],letters))){ \n                pivot1++; \n            } \n        } \n        String result =  String.copyValueOf(words); \n        return result.substring(0,pivot2); \n    } \n \n    public boolean isContainsLetter(char letter, char[] letters){ \n        int i = 0; \n        while (i <= letters.length - 1){ \n            if (letters[i] == letter){ \n                return true; \n            } \n            i++; \n        } \n        return false;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algorithm: Keep two pointers for this work While(string != '\\0') { 1. \"GOING\" is the string.Initially both will point to 'G'. 2. Move first pointer if it 'a' or 'i'.If it is not then don't move first pointer. 3. Copy first pointer data in second pointer and increment second pointer. return second pointer. }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int main() {  char str[]=\"vhjabsaaiibnca\";  int len=strlen(str);  int start=0;  for(int i=0;i {   if(str[i]=='a' || str[i]=='i')    i++;   else    swap(str[i++],str[start++]);  }  memset(str+start,'\\0',len-start);  getchar();  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"char* remove_ai_occurence(char* str) {  unsigned int len = strlen(str);  char* nextHolePtr = NULL;  for (unsigned int i = 0; i < len; i++) {   if (str[i] == 'i' || str[i] == 'a') {    if (!nextHolePtr)     nextHolePtr = str + i;   } else if (nextHolePtr) {    //if the nextHolePtr is non-null, fill the whole    nextHolePtr[0] = str[i];    nextHolePtr++;   }  }  if (nextHolePtr)   *nextHolePtr = '\\0';  return str; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void Replaces(char* str) \n{ \n int it =0; \n int in=0; \n while( str[it] != '\\0') \n { \n  if((str[it] != 'A')&&(str[it] != 'L')) \n  { \n   if( it != in) \n    str[in] = str[it]; \n   in++;it++; \n  } \n  else \n  { \n   it++; \n  } \n } \n str[in] = '\\0'; \n  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class RemoveLetters {    public static void main(String[] args)   {     String s = null ;     System.out.println(\"Enter the first string\\n\");     try     {     BufferedReader br = new BufferedReader(new InputStreamReader(System.in));     s = br.readLine();    }   catch(Exception e){}     char arr[] = s.toCharArray();     int len = s.length();     int index1 = 0;    for (int i=0; i   {       if(arr[i] != 'i' && arr[i] != 'l')       {         arr[index1] = arr[i];         index1++;    }   }    arr[index1] = 0;    for (int i=0; arr[i] != 0 ; i++)     System.out.print(arr[i]);  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"pls suggest some method to reduce its complexity....... #include int main() {     char str[100];     int i=0,j;     printf(\"enter the string:\\n\");     scanf(\"%s\",str);     while(str[i++])     {         if(str[i]=='A'||str[i]=='I'||str[i]=='a'||str[i]=='i')         {             j=i;             while(str[j]){             str[j]=str[j+1];j++;}             i--;         }     }     printf(\"thus the resultant string is:%s\",str);     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void removeA(char* str) {     for(int i=0, j=0; str[i]; i++, j++)     {         while (str[j] == 'A') j ++;         str[i] = str[j];     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void removeAI(char s[]) { char *p = s;         for(int i=0;i        {                 if(*p=='A'|| *p=='I')                 {                         p++;                 }                 else {                         s[i]=*p;                         p++;                         i++;                 }         } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void remove_chars(char* str) \n{ \n int freq = 0; \n for(int i = 0; str[i] !' ='\\0'; ++i) \n { \n  if(str[i] == 'a' || str[i] == 'A' || str[i] == 'i' || str[i] == 'I') \n  { \n   ++freq; \n  } \n  else \n  { \n   str[i - freq] = str[i]; \n  }  \n } \n \n str[i - freq] = '\\'0'; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void RemoveAandI(char [] s)         {             int index = 0;             for (int i = 0; i < s.Length; i++)             {                 if (s[i] != 'a' && s[i] != 'i')                 {                     if (i > index)                     {                         s[index++] = s[i];                     }                 }              }             if (index == 0 && (s[index] == 'a' || s[index] == 'i'))             {                 throw new Exception(\"Unable to find char other then 'a' and 'i'\");             }                           Console.WriteLine(s);         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int removeCharInPlace(char[] str){ \n  int lo = 0, hi = str.length - 1, len = str.length; \n  while(lo < hi){ \n   while(lo < len && (str[lo] != 'A' && str[lo] != 'I')){ \n    lo ++; \n   } \n    \n   if(lo >= len || lo > hi){ \n    break; \n   } \n    \n   while(hi >= 0 && (str[hi] == 'A' || str[hi] == 'I')){ \n    len --; \n    hi --; \n   } \n    \n   if(lo >= len || lo > hi){ \n    break; \n   } \n    \n   swapTwoChar(str, lo, hi); \n  } \n  return len; \n } \n  \n public static void swapTwoChar(char[] str, int from, int to){ \n  char tmpChar = str[from]; \n  str[from] = str[to]; \n  str[to] = tmpChar; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public string CharRemovalForString(string inputString, Char removalChar) \n        { \n            int p = 0; \n            Char[] inputCharArray = inputString.ToCharArray(); \n            for (int i = 0; i < inputCharArray.Length; i++) \n            { \n                if (inputCharArray[i] == removalChar) \n                { \n                    p++; \n                } \n                else \n                { \n                    inputCharArray[i - p] = inputCharArray[i]; \n                } \n            } \n \n            for (int j = inputCharArray.Length - 1; j > inputCharArray.Length - p - 1; j--) \n            { \n                inputCharArray[j] = ' '; \n            } \n            return new string(inputCharArray); \n        }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15315788","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"21","title":"implement your own sizeof() operator..","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"Assuming size of char is one byte this can be implemented as following macro.  #define mysizeof(data)  (char *)(&data+1)-(char *)(&data)   U can also make it function , but C doesnt support fn overloading"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"In case of C++ this can be implemented with a template function, and it can work for object and type as well.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Any Idea how to implement in JAVA"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Good solution.. Can you explain how this is working for an array? I thought for int a[]={4,5,6}; would give me 4 instead of 12. but it does correctly give me 12;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"one complicate way to implement this is to use RTTI, using typeid and calculate the size of certain data."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why do we have to cast it with (char *) can anybody please explain?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what is the code for getting the size of structure??  for eg:  struct node{ char c; int i; };"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Here is an implementation.   #define my_sizeof(type) (char *)(&type+1)-(char*)(&type) int main() {     double x;     printf(\"%d\", my_sizeof(x));     getchar();     return 0; } You can also implement using function instead of macro, but function implementation cannot be done in C as C doesn??t support function overloading and sizeof() is supposed to receive parameters of all data types.  Note that above implementation assumes that size of character is one byte.  Time Complexity: O(1) Space Complexity: O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"#define MYSIZEOF(X) ((X*)0 +1) int main() {         printf (\"%d\", MYSIZEOF(int));         return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"Microsoft india has idiots."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15320697","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"7","title":"How OS decide how much memory is needed as virtual memory ? Max % of memory which can be available as virtual memory?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Total Virtual memory depends on the number of processes.   Older OS would alloy 3 times memory as Virtual available there is no restriction."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"It depends upon process, If OS does not find enough space in internal memory then it use external memory for that process, or other process, to run that process. as all blocks are not needed at anytime, so OS uses lest required external memory to run that process. but there is no restriction on size. It depends upon OS performance, and and in some sense on processing speed.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"In Some OS the size of virtual memory allocated to all the processes cumulative is equal to the total physical memory and the swap space configured. (e.g. Solaris). But in some OS according to the word size 32 bit or 64 bit address spaces are given to each and every process. When the process try to lock or map the virtual address to real or physical address, then if the mapping can be done, It is done otherwise a run time exception occurs. This concept is called memory overcommit. So the total virtual address given to all the processes is all the address range either 32 bits or 64 bits accordingly. But some address range is reserved for either kernel space or treated as a hole."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The maximum virtual memory that can be allocated depends on the address space that's available. Say you are running a 32 bit processor and have 2GB RAM, then the maximum you can allocate is 2GB."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15208941","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"20","title":"Given a two dimensional matrix of booleans, there is a function that returns the number of \"true regions\".   A region is a group of True values aligned vertically or horizontally.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"task: connected components solution: flood fill"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Hint : Use BFS here. Here is algo"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"bool  isTraversed[][] = {False}; \n \nint extendRegion(bool matrix[][], int x, int y) \n{ \n      if(X >N or Y> N ) return ; \n      if (Matrix[x][y] == True & isTraversed[x][y] = False) \n      { \n            isTraversed[x][y] = True; \n            extendRegion(x+1, y) ; (x-1, y) ; (x, y-1) (x ,  y+1) \n      } \n} \n \nint findRegion(bool matrix[][], int N) \n{ \n    count = 0 \n    while( canfind  True and  not traversed) \n    { \n          find a True,  not traversed;  \n          count ++;  \n          extendRegion(x, y ); \n    } \nreturn count \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"A dynamic programming approach..  public static int count(boolean[][] T) {         if (T == null || T[0] == null)             return 0;         int m = T.length;         int n = T[0].length;         int[][] C = new int[m][n];          // set up initial conditions                                                     C[0][0] = T[0][0] ? 1 : 0;         for (int i = 1; i < m; i++) {             C[i][0] = C[i-1][0];             if (T[i][0] && !T[i-1][0])                 C[i][0] += 1;         }         for (int j = 1; j < n; j++) {             C[0][j] = C[0][j-1];             if (T[0][j] && !T[0][j-1])                 C[0][j] += 1;         }          // iterations                                                                    for (int i = 1; i < m; i++) {             for (int j = 1; j < n; j++) {                 int up = C[i-1][j];                 int left = C[i][j-1];                 C[i][j] = up > left ? up : left;                 if (!T[i-1][j] && !T[i][j-1])                     C[i][j] += 1;             }         }         return C[m-1][n-1]; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"import java.util.Stack; \n \npublic class BoolMatrix { \n int M; \n int N; \n Square matrix[][]; \n  \n class Square{ \n  boolean bool; \n  int x; \n  int y; \n  boolean isVisited; \n  public Square(boolean bool, int x, int y) { \n   super(); \n   this.bool = bool; \n   this.x = x; \n   this.y = y; \n   this.isVisited = false; \n  } \n  @Override \n  public String toString(){ \n   if(bool){ \n    return \"T\"; \n   }else{ \n    return \"F\"; \n   } \n  } \n } \n  \n public BoolMatrix(int m, int n) { \n  super(); \n  M = m; \n  N = n; \n  matrix = new Square[M][N]; \n  for (int i = 0; i < M; i++) { \n   for (int j = 0; j < N; j++) { \n    if (Math.random() < 0.5) { \n     matrix[i][j] = new Square(true,i,j); \n    } else { \n     matrix[i][j] = new Square(false,i,j); \n    } \n   } \n  } \n } \n \n public void print() { \n  for (int i = 0; i < M; i++) { \n   for (int j = 0; j < N; j++) { \n    System.out.print(matrix[i][j] + \"\\t\"); \n   } \n   System.out.println(); \n  } \n } \n \n public int countRegion() { \n  int count = 0; \n  for (int i = 0; i < M; i++) { \n   for (int j = 0; j < N; j++) { \n    if(!matrix[i][j].isVisited){ \n     if(matrix[i][j].bool){ \n      count++; \n      Stack stack = new Stack(); \n      stack.push(matrix[i][j]); \n      while(!stack.isEmpty()){ \n       Square s = stack.pop(); \n       Square[] neighbors = getNeighbors(s); \n       for(Square squ:neighbors){ \n        if(squ != null && !squ.isVisited){ \n         stack.push(squ); \n         squ.isVisited = true; \n        } \n       } \n      } \n     }else{ \n      matrix[i][j].isVisited = true; \n     } \n    } \n   } \n  } \n  System.out.println(count); \n  return count; \n } \n \n private Square[] getNeighbors(Square s) { \n  Square[] neighbors = new Square[4]; \n  for (int k = 0; k < 4; k++) { \n   neighbors[k] = null; \n  } \n  if (s.x - 1 >= 0 && matrix[s.x - 1][s.y].bool) { \n   //top \n   neighbors[0] = matrix[s.x - 1][s.y]; \n  } \n  if (s.x + 1 < M && matrix[s.x + 1][s.y].bool) { \n   //bottom \n   neighbors[1] = matrix[s.x +1][s.y]; \n  } \n  if (s.y - 1 >= 0 && matrix[s.x][s.y - 1].bool) { \n   //left \n   neighbors[2] = matrix[s.x][s.y - 1]; \n  } \n  if (s.y + 1 < N && matrix[s.x][s.y + 1].bool) { \n   //left \n   neighbors[3] = matrix[s.x][s.y + 1]; \n  } \n  return neighbors; \n } \n  \n \n public static void main(String[] args) { \n  BoolMatrix bm = new BoolMatrix(4, 5); \n  bm.print(); \n  bm.countRegion(); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Could you plz explain more ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can you explain the Question"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int nRegion(char[][] A){   int x1=A.length, x2=A[0].length;   int nr=0,x,y,flag;   for(int i=0;i   for(int j=0;j    flag=0;     if(A[i][j]=='T'||A[i][j]=='B'){      nr++;      if(A[i][j]=='B'){ flag=1; }      x=i; y=j+1;      while(y      if(A[x][y]=='B'){ flag=1; }       A[x][y]='B';       y++;      }      x=i+1; y=j;      while(x      if(A[x][y]=='B'){ flag=1; }       A[x][y]='B';       x++;      }     }     if(flag==1){ nr--; }    }   }   return nr;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int nRegion(char[][] A){ \n  int x1=A.length, x2=A[0].length; \n  int nr=0,x,y,flag; \n  for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"excellent resource for this"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int A[MAX_N][MAX_N]; \nint W, H; \nint di[] = {1, 0}; \nint dj[] = {0, 1}; \n \nint countRegions() { \n int cnt = 0; \n for (int i = 0; i < H; ++i) { \n for (int j = 0; j < W; ++j) { \n  if (A[i][j] == 1) ++cnt; \n  for (int k = 0; k < 2; ++k) {  \n   int ii = i + di[k], jj = j + dj[k]; \n   if (ii < H && jj < W && A[ii][jj] == 1) \n    A[ii][jj] = 2; \n  } \n }} \n return cnt; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Answer can be found here: careercup question?id=12451676"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15210893","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"33","title":"Given a string, find the start position of the largest block of repeated charactes.  After the solution, I was asked to write down as many test cases I could to test the function as if it was created by someone else.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"11","title":"case1: null (return -1) case2: \"\"(empty) (return -1) case3: \"aaabbbbbbcddccc\" (return 3) case4: \"vfdaaafgggbbb\" (same largest block, return start position of first block)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public int indexOfRepeatedBlock(char[] word){ \n        if(word == null || word.length == 0){ \n            return -1; \n        } \n        int length = word.length -1; \n        int finalIndex = 0; \n        int maxCount = 0; \n        int startIndex = 0; \n        int iterator = 1; \n        while (iterator <= length){ \n            int count = 1; \n            startIndex = iterator-1; \n            while (iterator <= length && (word[iterator-1] == word[iterator])){ \n                iterator++; \n                count++; \n            } \n            if(count > maxCount){ \n                maxCount = count; \n                finalIndex = startIndex; \n            } \n            iterator++; \n        } \n        return finalIndex; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int LargeBlock(String str) \n{ \n    if(str==null || str.length()==0) \n        return null; \n    int start=0,i,largecount,count,length=str.length(); \n    i=1,largecount=1,count=1,temp=str.charAt(0); \n    while(i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class LargestBlockRepeated { \n \n    public static int repeated(String str) { \n        int count = 0; \n        int largeCount = 0; \n        int position = 0; \n        int repeatedStartPosition = 0; \n        int runner = 1; \n \n        while (runner"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int GetRep( char *s)  {   char c = *s;   int n =0;   while ( c == *s)   {    s++; n++;   }   return n;  }   pairLargestBlock( char * s)  {   int nTmpPos = 0;    int nTmpSize = GetRep( s+nTmpPos);;   int nLPos = nTmpPos;   int nLSize = nTmpSize;    while(true)   {    nTmpPos += nTmpSize;     nTmpSize = GetRep( s+nTmpPos);     if (nTmpSize > nLSize)    {     nLPos = nTmpPos ;     nLSize = nTmpSize;    }    if (!s[nTmpPos + nTmpSize])    {     pair pRtn;     pRtn.first = nLPos;     pRtn.second = nTmpSize;     return pRtn;    }   };"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"char * p = \"aaaaabbbbbbbbbbbbbbefxsscc\";   int len = strlen(p);  cout << len << endl;   int idx = 0;  int maxRep = 0;  int maxIdx = 0;  while (idx < len)  {   int nRep = 1;   int idx2 = idx + 1;   while (idx2 < len && p[idx2] == p[idx])   {    idx2 ++;    nRep ++;   }   if (nRep > maxRep)   {    maxRep = nRep;    maxIdx = idx;   }   idx = idx2;  }  cout << \"maxRep:\" << maxRep << \" maxIdx:\" << maxIdx << endl;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"char * p = \"aaaaabbbbbbbbbbbbbbefxsscc\"; \nint len = strlen(p); \ncout << len << endl; \n \nint idx = 0; \nint maxRep = 0; \nint maxIdx = 0; \nwhile (idx < len) \n{ \n int nRep = 1; \n int idx2 = idx + 1; \n while (idx2 < len && p[idx2] == p[idx]) \n { \n  idx2 ++; \n  nRep ++; \n } \n if (nRep > maxRep) \n { \n  maxRep = nRep; \n  maxIdx = idx; \n } \n idx = idx2; \n} \ncout << \"maxRep:\" << maxRep << \" maxIdx:\" << maxIdx << endl;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In Java :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class LargestBlock {    public static void main(String[] args){           String target = \"abcdddddddddddeeeeeefsddeeeeeeeeeeee\";                   int max = 0;        int maxindex = 0;        int index=0;                while(index < target.length()-1){         int counter = 0;          int subindex = index +1;          while(target.charAt(index)==target.charAt(subindex)){           counter++;           subindex++;           if(subindex == target.length()){            break;           }          }          if(counter > max){         // compare the counter with the previous max              max = counter;               maxindex = index;          }          index++;        }              System.out.println(maxindex);    } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int get_max_sequential_start_index(const char *c) {   if (NULL == c) return -1;   int current_start = 0;  int max_start     = 0;   int current_len = 0;  int max_len     = 0;   int i = 0;  int len = strlen(c);   for (i = 1; i < len; i++) {    if (c[current_start] == c[i]) {     current_len++;     if (current_len > max_len) {     max_start = current_start;     max_len   = current_len;    }    } else {    current_start = i;    current_len   = 1;   }  }   return max_start; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Scanner; \n \n \n \n \n//given a string, find the start position of the largest block of repeated \n//chars \n// \n \npublic class LargestCharBlocks{ \n \n \n    public static int getStart(String s){ \n        //never forget to check the null... \n        if(s == null || s.length() == 0) \n            return -1; \n         \n        int tempStartRecord = 0; \n        int startRecord = 0; \n        char previousChar; \n        int maxLength = 0; \n        int tempLength = 0; \n        char[] string = s.toCharArray(); \n \n        previousChar = string[0]; \n        startRecord = 0; \n        maxLength = 1; \n        tempLength = 1; \n        for(int i = 1; i < string.length; i ++){ \n            if(string[i] == previousChar){ \n                tempLength ++; \n            } \n            else if(string[i] != previousChar){ \n                if(tempLength > maxLength){ \n                    maxLength = tempLength; \n                    startRecord = tempStartRecord; \n                } \n                tempStartRecord = i; \n                tempLength = 1; \n                previousChar = string[i]; \n            } \n        } \n        return startRecord; \n    } \n \n \n    public static void main(String[] args){ \n         \n        Scanner s = new Scanner(System.in); \n         \n        String string = s.next(); \n \n        System.out.println(LargestCharBlocks.getStart(string)); \n        return; \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int LargestBlockOfrepeatedCharacters(String s)         {             int length = s.Length;              int largest = 0, Count=1,  i=0;              if (s.Length == 0 || s == null)             {                 Console.WriteLine(\"Invalid string\");                              }              else             {                  while (i < s.Length-1)                 {                      if (s[i] == s[i + 1])                     {                         Count++;                                              }                      else                     {                         if (Count > largest)                         {                             largest = Count;                         }                     }                     i++;                 }                              }             return largest;         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def maxRepeatStrIndex(data): \n     \n    if (len(data)<1 or (data==\" \")): \n        print(\"Blank string\") \n        return -1 \n    maxVal = 1 \n    chStart=0 \n    i = 0 \n    cnt=1 \n         \n    while(i maxVal)): \n                maxVal=cnt \n                chStart = i-maxVal+1 \n             \n        else: \n            if (maxVal"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \n \nint main(int charc, char **argv) \n{ \n        char *string = argv[1]; \n \n        int i = 0, mcount = 0, count = 0, start = 0; \n        char prevch, currch; \n \n        while(string[i] != '\\0') \n        { \n                currch = string[i]; \n                if(i == 0) \n                { \n                        prevch = currch; \n                        i++; \n                        count++; \n                        if(count > mcount) \n                        { \n                                mcount = count; \n                                start = i - count; \n                        } \n                        continue; \n                } \n \n                if(prevch == currch) \n                { \n                        i++;count++; \n                        if(count > mcount) \n                        { \n                                mcount = count; \n                                start = i - count; \n                        } \n                        prevch = currch; \n                        continue; \n                }else{ \n                        i++;count = 1; \n                        if(count > mcount) \n                        { \n                                mcount = count; \n                                start = i - count; \n                        } \n                        prevch = currch; \n                        continue; \n                } \n        } \n \n        if(count > mcount) \n        { \n                mcount = count; \n                start = i - count; \n        } \n \n        printf(\"largest block of repeating chars starts at %d and has %d chars\\n\", start, mcount); \n \n        return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  void block_Size(char *); void main() {     char *str=\"dhdhdhddddhdhdhdhdhegeegeev\";     block_Size(str); } void block_Size(char *a) {     int c=1,pos=-1,j=0,count=0;     char ch;     ch=a[j];     j++;     while(a[j]!='\\0')     {         if(ch==a[j])         {         c++;         }         else         {             if(c>count)             {                 count=c;                  pos=j-c;             }                 ch=a[j];                 c=1;         }         j++;     } if(c>count)             {                 count=c;                  pos=j-c;             }  printf(\"character=%c\\tposition=%d\",a[pos],pos); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int LargestRepeatedBlock(const std::string& str) {  if (str.length() == 0)   return -1;   unsigned int largestIndex = 0;  bool inBlock = false;  unsigned int largestBlockCount = 1;   unsigned int index = 0;  unsigned int blockCount = 1;   for (unsigned int i = 0; i < str.length() - 1; ++i)  {   if (str[i] == str[i + 1])   {    if (!inBlock)    {     inBlock = true;     index = i;    }     ++blockCount;   }   else   {    if (inBlock)    {     if (blockCount > largestBlockCount)     {      largestIndex = index;      largestBlockCount = blockCount;     }      blockCount = 1;     index = 0;     inBlock = false;    }   }  }   if (blockCount > largestBlockCount)  {   largestIndex = index;   largestBlockCount = blockCount;  }   return largestIndex;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static string GetLongestSubString(string input)         {             if (string.IsNullOrEmpty(input))                 return string.Empty;              //Return the sub string             string retstring = string.Empty;             //Max Length of dup chars             int stringLength = 0;             //Start Position             int startIndex = 0;              for (int i = 0; i < input.Length; i++)             {                 int repeatLength = 1;                 for (int j = i + 1; j < input.Length; j++)                 {                     if (input[j] == input[i])                         repeatLength++;                     else                         break;                 }                  if (repeatLength > stringLength)                 {                     stringLength = repeatLength;                     startIndex = i;                 }             }              retstring = new string(input.ToCharArray(), startIndex, stringLength);              return retstring;         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int GetStartPosOfLargestRepChar(string str) \n        { \n            Dictionary dic = new Dictionary(); \n            int max = 0; \n            char maxChar = ' '; \n            int pos = -1; \n            for (int i = 0; i < str.Length; i++) \n            { \n                if (dic.ContainsKey(str[i])) \n                { \n                    dic[str[i]]++; \n                    if (dic[str[i]] > max) \n                    { \n                        max = dic[str[i]]; \n                        maxChar = str[i]; \n                        pos = i; \n                    } \n                } \n                else \n                    dic.Add(str[i], 1); \n            } \n \n            for (int k = 0; k < str.Length; k++) \n                if (str[k] == maxChar) \n                { \n                    pos = k; \n                    break; \n                } \n            return pos; \n \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"main() {  char str[] = \"aavvvvbbbbbsdsssssssssdrrrrrrrrrrrr\"; int current=0,largest=0; char *p = str; char a;         while(*p!='\\0')         {                 if(*p!=(*(p+1)))                 {                         if(current>largest)                         {                          a = *p;                         largest = current;                         }                         current = 0;                 }                  else {current++;}                 p++;                          } cout << largest<< \" \" << a;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"main() \n{ \n \nchar str[] = \"aavvvvbbbbbsdsssssssssdrrrrrrrrrrrr\"; \nint current=0,largest=0; \nchar *p = str; \nchar a; \n        while(*p!='\\0') \n        { \n                if(*p!=(*(p+1))) \n                { \n                        if(current>largest) \n                        { \n                         a = *p; \n                        largest = current; \n                        } \n                        current = 0; \n                }  \n                else {current++;} \n                p++; \n                 \n        } \ncout << largest<< \" \" << a;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void highest_occurence(const string& str) \n{ \n int max = INT_MIN; \n char maxChar = 0; \n int count = 0; \n char ch = 0; \n \n for(int i = 0; i < str.length(); ++i) \n { \n  if(i == str.length() - 1 || str[i] != str[i + 1]) \n  { \n   if(count > max) \n   { \n    max = count; \n    maxChar = ch; \n   } \n \n   count = 0; \n   ch = str[i + 1]; \n  } \n  else \n  { \n   ++count; \n  } \n } \n \n cout << \"Max occurence char is \" << maxChar; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static void largest(String string) { \n  //null check \n  if(string.length()==0) \n   System.out.println(-1); \n   \n   \n   \n  //works with left, right and center largest repeat letters \n  int counter =1; \n  int largest =1; \n  char letter = ' ';  \n  for(int i =0 ; i< string.length()-1; i++) \n  { \n   if(string.charAt(i+1)==string.charAt(i)) \n   { \n    counter++; \n    if(largest < counter) \n    { \n     largest = counter; \n     letter = string.charAt(i+1); \n      \n    } \n   } \n   else  \n   { \n    counter=1; \n   }   \n    \n  } \n  if (largest!=1) \n  {  \n   System.out.println(letter + \" \" + largest); \n  } \n   \n    \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static void largest(String string) { \n  //null check \n  if(string.length()==0) \n   System.out.println(-1); \n   \n   \n   \n  //works with left, right and center largest repeat letters \n  int counter =1; \n  int largest =1; \n  char letter = ' ';  \n  for(int i =0 ; i< string.length()-1; i++) \n  { \n   if(string.charAt(i+1)==string.charAt(i)) \n   { \n    counter++; \n    if(largest < counter) \n    { \n     largest = counter; \n     letter = string.charAt(i+1); \n      \n    } \n   } \n   else  \n   { \n    counter=1; \n   }   \n    \n  } \n  if (largest!=1) \n  {  \n   System.out.println(letter + \" \" + largest); \n  } \n   \n    \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static int RepeatedChar(char[] a, int length) \n        { \n            int count = 1, max = 1, pos = 0; \n \n            for (int i = 0; i < length; i++) \n            { \n                if (i == length - 1) \n                { \n                    if (a[i] == a[i - 1]) \n                    { \n                        if (max < count) \n                        { \n                            max = count; \n                            pos = i - count + 1;  \n                        } \n                         \n                        count = 1; \n                    } \n                } \n                else if (a[i] != a[i + 1]) \n                { \n                    if (max < count) \n                    { \n                        max = count; \n                        pos = i - count + 1;  \n                    } \n                     \n                    count = 1; \n                } \n                else \n                { \n                    count++; \n                } \n            } \n \n \n            return pos; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Hi,  Was the question to return the starting point of a  largest block of single repeated character? meaning...in following string: \"abcdddeeeeeefsddeee\" , the return location should be : 6 (0 start index)..as \"eeeeee\" is the largest set of repeated character \"e\" or  they want to return positon \"3\" because from that position..the largest set of repeated characters d and e i.e \"dddeeeeeee\" begins? The second set of repeate ddeee is smaller compared to first one."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This is the code I have ..   My understanding is: in a string aaeeeddbddddda  ... The biggest block is ddddd so answer is 5."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15202933","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"15","title":"Given two arrays of ints that are sets, create a function to merge them to create a new set.  A set must pass on these three conditions: - All values are positive - Sorted - Non-duplicates","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Say the two arrays are: a[] of size n and b[] of size m. Declare another array c[] of size m+n  Compare a[i] with b[j], put the smaller value into c[k] keep incrementing the index of the array whose element is smaller and put it into c[k++] keep continuing this unless one of the arrays is used. Now since the other array is sorted already, simply copy all the remaining elements into c[]. Our merged array is ready!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"void Merge(int * a, int m, int * b, int n, vector& c) \n{ \n int p = 0; int q = 0; \n while (p < m && q < n) \n { \n  if (a[p] < b[q]) \n  { \n   c.push_back(a[p++]); \n  } \n  else if (a[p] > b[q]) \n  { \n   c.push_back(b[q++]); \n  }else \n  { \n   c.push_back(a[p++]); \n   q++; \n  } \n } \n while (p < m) \n { \n  c.push_back(a[p++]); \n } \n while (q < n) \n { \n  c.push_back(b[q++]); \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Use binary search tree is the most efficient way to solve this problem. In Java, we have TreeSet.  You could also implement your own binary tree and add data into this tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This question is a complement of this one: 15273751"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Somewhat similar to 15290749"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is the runtime for this O(n) ? n being size of the larger of the two sorted lists?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15273751","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"17","title":"Tell me if a array of integers is a set.  A set must pass on these three conditions: - All values are positive - Sorted - Non-duplicates  After the first solution, I was asked about time and space complexity and to create 5 test cases for my function.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"bool IsSet(int * a, int n) \n{ \n    int t = 0; \n    while (t < n) \n    { \n     if (a[t] <= 0) \n         return false; \n     if (t == 0) \n         continue; \n     if (a[t] <= a[t - 1]) \n         return false; \n     t++; \n    } \n    return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the problem can be solved using a bit vector. public static boolean isUnique(int[] a){   int prev = 0;   int res;   for(int i=0; i   res = prev ^ (1<   if(res   prev=res;   }   return true;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Let n = array size; int i = 1; bool    ifArrayIsSet(int* arr, int n ) {      int i = 1;  while( i < n && arr[i] > 0 && arr[i] > arr[i-1] && i++);    if(i == n)       return true;  return false; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n \n \n \nvoid main() \n{ \n int a[10],i,k=1,l; \n printf(\"\\nenter elements\"); \n for(i=0;i<10;i++) \n  scanf(\"%d\",&a[i]); \n i=0; \n if(a[i]>=0) \n  for(i=0;i<9;i++) \n   if(a[i]>a[i+1]) \n   { \n    k=0; \n    break; \n   } \n   else \n    k=1; \n else \n  printf(\"Not a set\"); \n if(k==0) \n  printf(\"it is not a set\"); \n else \n  printf(\"SET\"); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. sort direction is not an issue, cause if descending, just traverse the array from tail. 2. only check <= is fine, it will cover the duplicate case. here is the c# code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I think this problem can be solved by Balanced binary search tree. Case 1: when we scan the array simple check it is positive or not. Case 2: When you create the BST inorder traversal will automatically gives you element in sorted order. Case 3: For searching complexity will be log(n) which also for inserting the element."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15204665","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"26","title":"write a pseudo code to calculate func(n) = 2*(func(n-1)+func(n-2)) in log(n) complexity. Given:.func(1) = 1;func(2) = 3. What is initial matrix because of factor 2.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Use this : | f(n-1) | | 2 2 |   =      |   f(n)   | | f(n-2) | | 1 0 |            | f(n-1)  |  Matrix exponentiation over it will give f(n) in O(log(n))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"The Theorem which used in calculate Fibonacci number - cost O(lgn). you can search it on google, basically it's [[F(n+1),F(n)],[F(n),F(n-1)]] = [[1,1],[1,0]]^n."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can some1 please explain me this que !!! and also the answer that is posted for this que !!:("},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Are you sure func(2) is 3?  If func(1) = 1 then if func(0) = 0 func(2) becomes 2 and if func(0) = 1 then func(2) becomes 4. How do you arrive at the value 3?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What are f(0) and f(1)?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"(f(n+2)) = (2 1) x  f(n+1) \n(f(n+1))    (1 0)     f(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void Multipy(int a[4], int b[4], int c[4]) \n{ \n c[0] = a[0] * b[0] + a[1] * b[2]; \n c[1] = a[0] * b[1] + a[1] * b[3]; \n c[2] = a[2] * b[0] + a[3] * b[2]; \n c[3] = a[2] * b[1] + a[3] * b[3]; \n} \nvoid Exp(int a[4], int b[4], int n) \n{ \n if (n == 1) \n { \n  memcpy(b, a, sizeof(int) * 4); \n  return; \n } \n if (n == 0) \n { \n  b[0] = b[3] = 1; \n  b[1] = b[2] = 0; \n  return; \n } \n int half_n = int(n / 2); \n int c[4]; \n Exp(a, c, half_n); \n \n int c2[4]; \n Multipy(c, c, c2); \n \n if (n % 2 == 1) \n { \n  Multipy(c2, a, b); \n } \n else{ \n  for (int i = 0; i < 4; i++) \n   b[i] = c2[i]; \n } \n \n} \nint main(int argc, char ** argv) \n{ \n if (argc < 2) \n  return 0; \n int n  = atoi(argv[1]); \n int a[4] = {2, 2, 1, 0}; \n int b[4]; \n Exp(a, b , n - 1); \n int fn = b[0] + b1 / 2; // b1 must be even number, cause fn is a integer \n cout << fn << endl; \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"geeksforgeeks.org/  program-for-nth-fibonacci-number  /"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15294742","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"30","title":"You have a link list with the following structure: struct Node{ Node*next; Node*other; }  next pointer points to next node, but \"other\" pointer points to any node in the list, it can be itself or null.  you receive the header of a list with this structure.  you have to copy it(allocate new memory) , you cannot modify the structure, you can not modify the list you are given.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"We can do this without modifying the list in a single pass using the hashmap where we save the reference of visited node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"www[dot]geeksforgeeks[dot]org/a-linked-list-with-next-and-arbit-pointer/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Here is my approach:   loop1: temp = smallNode = head; while(temp != null) {  if(temp->data < smallNode.data)   {smallNode = temp;}  newNode = getNewNode();  newNode->data = temp->data;  nextNode =  temp->next;  temp->next = newNode;  newNode->next = nextNode;  temp = nextNode; }  loop2: temp = smallNode; while(temp->random != null) {  temp->next->random = temp->random->next;  temp = temp->random; } temp->next->random = null;  loop3: replicateHead = head->next; temp = head; replicate = replicateHead; while(temp != null) {  temp->next = replicate->next;  if(temp->next != null)   {replicate->next = temp->next->next;}  else   {replicate->next = null;}  temp = temp->next;  replicate = replicate->next;    }  Complexity: O(3N), O(1) space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can we not just traverse the linked list and create a new node for each node traversed and assign all the values (data, next pointer and random pointer) to the new node ...  the random pointer that points to the successor has also got to be just assigned"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It can be done in O(n) & O(1) even though random pointer is pointing to anywhere in the list. I am not considering the space which you'll need for new list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assumption : Every element is unique. 1) Traverse through the linked list and create the new linked list with same data and next values and keep random pointer as NULL. For every element, save the address of current node to hash(data of current node). e.g. 1->8->3->6->81->2 hash(1) = address of node 1 hash(8) = address of node 8 ...  2) Again run the loop, and from the initial linked list; get the data value at address pointed by random pointer. Use this data as an input to hash() function to get the address in newly created linked list and assign that address in random pointer of newly created linked list.  The linked list is traversed twice, so time complexity is O(2N) = ~ O(N) Space complexity : O(N)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Given List  = 1->2->3->4->5->NULL (I am only showing next pointer here, but you will get the idea)  Step 1 - Push a new node after every node  List - 1->1->2->2->3->3->4->4->5->5->->NULL (Here first 1 is from old list, second 1 is new node we appended)  Step 2 - Do as following for each node. node->next->random = node->random->next;  Step 3 - At the end just pop out newly added nodes. and make old list's last node's next as NULL  Comments Welcome"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node copy(node root){ HashMap old=new HashMap(); HashMap now=new HashMap(); int i=0,j=0; oldfirst=root; while(root!=null){ old.put(root,i); root=root.next; i++;} node head=new node(); node first=head; now.put(j,head); while(jnode tmp=new node(); head.next=tmp; head=tmp; j++; now.put(j,head);} head.next=null; head=first; root=oldfirst; while(head!=null){ head.other=now.get(old.get(root)); head=head.next; root=root.next;} return first;}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"List A node1.next = node2; node1.other = node3;  node2.next = node3; node2.other = node4;  //loop the la as ListA //lb is our new copy ListB  Node* curLa = la.begin(); Node* curLb = new Node();  // the first is the address be referred // the second is the real address of node // we will know second->other = first // just consider first is single referred by one node; // otherwise map map_ref change to map< Node*, vector > map map_ref; map::Iterator it; while(curLa) {  Node* p = new Node();  curLb->next = p;  it = map_ref.find(curLa);  if(it != map_ref.end());  {   it->first->other = p;  }   map_ref[curLa->other] = p;  curLa = curLa->next;  curLb = curLb->next; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I dont see what the problem is here ... we just have to make a copy right ? we can traverse through the list using node->next;  So we start a new list and copy the contents just like copying an array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Isint this a Graph? I can use DFS search algorithm and on every node traversal, I create a node and add corresponding links. Will update with code soon."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n \nstruct node \n{ \nint data; \nstruct node * next; \nstruct node * other; \n \n}; \n \n \nstruct node * newnode(int data) \n{ \nstruct node * newnode=(struct node *)malloc(sizeof(struct node)); \nnewnode->next=NULL; \nnewnode->other=NULL; \nnewnode->data=data; \nreturn newnode; \n} \n \n \n \nvoid func(struct node * head1,struct node **head2) \n{ \nstatic struct node * temp=NULL; \nif (head1!=NULL) \n{ \nfunc(head1->next,head2); \nstruct node * newn= newnode(head1->data); \nnewn->next=temp; \n*head2=newn; \ntemp=newn; \n} \n} \n \n \nvoid fun(struct node * head1, struct node **head2) \n{ \nstruct node *resultlist=*head2; \nstruct node *head1temp=head1->next; \n \nwhile(head1!=NULL) \n{ \nhead1->next=(*head2); \n \n(*head2)->other=head1; \n(*head2)=(*head2)->next; \n \nhead1=head1temp; \n \nif(head1temp) \n  head1temp=head1temp->next; \n \n \n} \n \n \n*head2=resultlist; \n \nwhile((*head2)!=NULL) \n{ \n(*head2)->other=(*head2)->other->other->next; \n(*head2)=(*head2)->next; \n} \n \n \n*head2=resultlist; \n \n} \n \nvoid printlist(struct node * root) \n{ \nwhile(root!=NULL) \n{ \nprintf(\"\\n data of node is :%d\",root->data); \nprintf(\"\\n other of this node is :%d\",(root->other)->data); \nif(root->next) \nprintf(\"\\n next of this node is :%d\",(root->next)->data); \nprintf(\"\\n\\n\"); \nroot=root->next; \n} \n \n} \n \n \nint main() \n{ \n \nstruct node* head2=NULL; \n \nstruct node * head1=newnode(1); \nhead1->next=newnode(2); \nhead1->next->next=newnode(3); \nhead1->other=head1->next->next; \nhead1->next->other=head1; \nhead1->next->next->other=head1->next; \n \nprintf(\"\\n\\noriginal list is :\\n \\n\"); \nprintlist(head1); \n \nfunc(head1,&head2); \n \nfun(head1,&head2); \n \nprintf(\"\\n\\n copy list is :\\n \\n\"); \nprintlist(head2); \n \nreturn 0; \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The key here is that if a node in the original list has an other pointer which is not NULL, you have to allocate the node pointed to by other as well and all other nodes along the chain to that node, in a cascading manner. This is non trivial but we might be able to leverage recursion to do this. I was too lazy to finish the code, but here's a basic outline. I'm sure there are edge cases I haven't handled."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"Do it in two loops. In first loop, copy node and set only next pointer. In second loop, copy other pointer.."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15192912","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"0","title":"Tell me about another project you have done, how did you do it? what are de difficult parts of it?, tell me everything"}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15294741","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"8","title":"Test a program that receives 3 inputs (the size of each edge of a triangle). the program should return : 1 for equilateral 2 for isoceles 3 for scaleno 0 for not triangle  you have to give several test cases for the program","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"if(a+b <= c || b+c<=a || a+c<=b ) \n  return 0; \n else if(a == b && b== c) \n  return 1; \n else if(a==b || b==c || c==a) \n  return 2; \n else \n  return 3;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Input : a , b, c :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int test(int a, int b, int c){ \n if(a < 0 || b < 0 || c < 0) \n  return 0; \n if(a+b <= c || a+c <= b|| b+c <= a) \n  return 0; \n if(a == b && b == c){ \n  return 1; \n }else if(a == b || b == c){ \n  return 2; \n }else{ \n  return 3; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"After this code ... I was asked to provide the inputs to test if this code is working or note.  main stress was on conditions for Isoceles triangle."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Provide negative values then conditions like (a+b <= c) will fail to check  2) Provide floating values also a=2.3,b=2.8 then if you took as integer then a==b, but logically wrong"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15207869","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"15","title":"You receive a string with the following characters: '{' '(' '[' ']' ')' '}' the string can be any size, any number of each character. You have to decide if the string is balanced, for examplo {()[]} - correct (({)}) - incorrect {()) - incorrect","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"You can use a stack."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Use stack to solve it.  When ever an opening bracket encountered push it into stack and when a closing bracket is encountered pop the top element from stack. perform a check to match opening and corresponding closing bracket.  in the end there stack should be empty for a correct string"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Create 3 arrays for keeping the count of 3 different brackets.  Scan from left to right and increment count by 1 for { bracket and decrement by 1 for }. In the end all three arrays should have 0 value."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class StringCompiler {   /**   * @param args   */  public static void main(String[] args) {        System.out.println(\"Valid Pattern :\" +check());  }    private static boolean check(){   Stack s = new Stack();         String pattern = \"{{}}{}{}{}{}}\";      for(int i=0;i      if( pattern.charAt(i)=='(' || pattern.charAt(i)=='{' || pattern.charAt(i)=='[' ){ // Check All Possible language patterns        s.push(pattern.charAt(i));        System.out.println(\"Pushing \"+i+\":\"+pattern.charAt(i));       }else{        if(!s.empty()){        char c = (Character) s.pop();              if((c == '(' && pattern.charAt(i)==')') ||          (c == '[' && pattern.charAt(i)==']') ||       (c == '{' && pattern.charAt(i)=='}')   ){       System.out.println(\"Poping \"+i+\":\"+pattern.charAt(i));        }else{         return false;        }        }else {          return false;        }               }             }      if(s.empty())       return true;    return false;  }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool Match(const string& str) \n{ \n stack s; \n for (string::const_iterator it = str.begin(); \n      it != str.end(); it++) \n { \n  if (s.empty()) \n  { \n   s.push(*it); \n   continue; \n  } \n  char c = s.top(); \n  if ((*it == ']' && c == '[') || \n      (*it == '}' && c == '{') || \n      (*it == ')' && c == '(')) \n  { \n   s.pop(); \n  } \n  else{ \n   s.push(*it); \n  } \n } \n return s.empty(); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if the example is '}'']''[''{', is it balance"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how about '}''{''['']'"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how about '}''{''['']'"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Stack; \n \npublic class CheckBalance { \n \n public static boolean check(String str) { \n  if (str == null || str.length() == 0) { \n   return true; \n  } \n  char[] strs = str.toCharArray(); \n  Stack stack = new Stack(); \n  for (char c : strs) { \n   if(!check(c)){ \n    return false; \n   } \n   if(checkOpeningSymbol(c)){ \n    stack.push(c); \n   } \n   if(checkEndingSymbol(c)){ \n    stack.push(c); \n    if(stack.size() < 2) \n     return false; \n    char right = stack.pop(); \n    char left = stack.pop(); \n    if(!match(right,left)){ \n     return false; \n    } \n   } \n  } \n  if(stack.isEmpty()){ \n   return true; \n  } \n  return false; \n } \n \n private static boolean match(char right, char left) { \n  if(right == ')' && left == '(' ){ \n   return true; \n  } \n  if(right == '}' && left == '{' ){ \n   return true; \n  } \n  if(right == ']' && left == '[' ){ \n   return true; \n  } \n  return false; \n } \n \n private static boolean check(char c) { \n  if (c == ')' || c == '}' || c == ']' || c == '{' || c == '[' \n    || c == '(') { \n   return true; \n  } \n  return false; \n } \n \n private static boolean checkEndingSymbol(Character peek) { \n  if (peek == ')' || peek == '}' || peek == ']') { \n   return true; \n  } \n  return false; \n } \n \n private static boolean checkOpeningSymbol(Character peek) { \n  if (peek == '{' || peek == '[' || peek == '(') { \n   return true; \n  } \n  return false; \n } \n \n public static void main(String[] args) { \n//  String str = \"{()[]}\"; \n//  String str = \"(({)})\"; \n  String str = \"{())\"; \n  System.out.println(check(str)); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include using namespace std; struct list {     char ch;     struct list *next; }*head=NULL; char top() {     if(!head)return '\\0';     return head->ch; } struct list *pop(struct list *head) {     head=head->next;     return head; } struct list *push(struct list *head,char ch) {     struct list *temp;     char cc=top(),cd;     switch(ch)     {         case ']':         cd='[';         break;         case '}':         cd='{';         break;         case ')':         cd='(';         break;         default:         cd='a';         break;     }     if(cc==cd)     head=pop(head);     else{     if(!head)     {         head=new list;         head->ch=ch;         head->next=NULL;     }     else     {         temp=new list;         temp->ch=ch;         temp->next=head;         head=temp;     }     }     return head; } int main() {     char str[100];     int i=0;     printf(\"enter the string:\\n\");     scanf(\"%s\",str);     while(str[i]){head=push(head,str[i]);i++;}     if(!top())printf(\"\\ncorrect\");     else printf(\"\\nincorrect\");     return 0; }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15259799","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"1","title":"Microsoft recruiting final round: Interview 1-Question 4: Tell me about any software you like, how would you improve it? what bugs have you found?, how would you solve those bugs?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You will have to the most innovative while answerin this.If it was asked to me ,i would say my favourite software is winrar and tell about the encryptions and all those about winrar and finally tell that the bug i found is about cracking it.as its simple enough to create a keygen to it ..i would follow the MS windows 8 security as its the best security system for a s/w given.so as it impress him also and tell him about the KMS(key management system) used in windows 8 eventhough ther are flaws in it.atleast he'll know that you know lot about microsoft."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15206865","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"Microsoft recruiting final round: Interview 1-Question 3: Tell me about your projects what problems have you had and how did you solve them","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is much personal, or some general principle?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what if the interviewee is student? they do not have much experience"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15259798","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"3","title":"Microsoft recruiting final round: Interview 1-Question 2: How would you test an elevator","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"First ask  \"Let me ask you about this elevator we are designing\"  \"Who will use it? Children at a school? Cleaners at a hotel? Fans at a stadium?\"  \"What will they use it for? Deliver? Faster access over stairs?\"  \"Where is the elevator being installed? 2 story building? 50 story skyscraper?\"  Basically you will probably find out this is an elevator on a bus for disabled folk that will take 1 guy in a wheel chair and bring him onto the bus. Then just list the use cases, try to structure them a bit into functional/negative/load/stress/boundary etc"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming its an elevator used in malls,airport,public places  1)When no person is there on elevator,check the speed 2)When there are average nbr of perons, 3) When more than the specified limit 4)Check the emergency stop functionality 5)Working for both the directions(upward,downward) equally 6)What if stopped by power failure"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Maximum capacity 2.No of buttons are present equals to number of floors 3.elevator stops to that particular floor after pressing button.4 4.chreck open and close door button is working 5.check emergancy stop functionality"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15289733","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"15","title":"Microsoft recruiting final round: Interview 1-Question 1: Insert  node in a sorted singly linked list","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"public static void Insert(Node first, int n) \n{ \n    Node temp=new Node(n); \n    if(first==null || first.value>n) \n    { \n        temp.next=first; \n        first=temp; \n        return; \n    } \n    while(first.next!=null && first.next.value"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public class SortedLinkedList { \n Node head; \n  \n class Node{ \n  int value; \n  Node next; \n  public Node(int value) { \n   super(); \n   this.value = value; \n   this.next = null; \n  } \n   \n } \n  \n public void add(int value){ \n  Node newnode = new Node(value); \n  if(head == null){ \n   head = newnode; \n   return; \n  } \n  Node ptr = head; \n  Node prev = null; \n  while(ptr != null && value > ptr.value){ \n   prev = ptr; \n   ptr = ptr.next; \n  } \n  if(ptr == head){ \n   newnode.next = head; \n   head = newnode; \n   return; \n  } \n  if(ptr == null){ \n   prev.next = newnode; \n   return; \n  } \n  newnode.next = ptr; \n  prev.next = newnode; \n } \n  \n public void print(){ \n  Node ptr = head; \n  if(ptr == null){ \n   return; \n  } \n  while(ptr != null){ \n   System.out.print(ptr.value); \n   ptr = ptr.next; \n  } \n } \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n  SortedLinkedList ll = new SortedLinkedList(); \n  ll.add(3); \n  ll.add(9); \n  ll.add(6); \n  ll.add(7); \n  ll.add(3); \n   \n  ll.print(); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void insert(node* &root, int x) \n{ \n    node *start = root; \n    node *n = new node(x); \n    if (!root) \n    { \n        root = n; \n        return; \n    } \n    if (root->info > x) \n    { \n        n->next = root; \n        root = n; \n        return; \n    } \n    while ((start->next) && (start->next->info < x)) \n    { \n        start = start->next; \n    } \n    n->next = start->next; \n    start->next = n; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Javascript, assuming we have LinkedList class with head property:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Whenever we have to insert a node into a sorted single linked list we have to take care of these cases: 1. the node we want to insert is null? 2. the list is empty (==null)? 3. the node to be inserted will fit before the head of the linked list? 4. and ask the interviewer what to do if the linked list contains values == node.value    after checking the 3 things :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Not the best code ever, but I think it works!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void InsertToSortedList(stIntList* pSorted, int data) {  stIntList* pTemp = pSorted;  stIntList* pPrev = NULL;   while(pTemp != NULL)  {   pPrev = pTemp;    if(pTemp->data >= data)   {    stIntList* pNew = new stIntList;    pNew->data = data;    pNew->pNList = pTemp->pNList;    pPrev->pNList = pNew;    std::cout<<\"\\nInseted Succesfully \"<<<\" at \"<   break;   }   pTemp = pTemp->pNList;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void InsertToSortedList(stIntList* pSorted, int data) {  stIntList* pTemp = pSorted;  stIntList* pPrev = NULL;   while(pTemp != NULL)  {   pPrev = pTemp;    if(pTemp->data >= data)   {    stIntList* pNew = new stIntList;    pNew->data = data;    pNew->pNList = pTemp->pNList;    pPrev->pNList = pNew;    std::cout<<\"\\nInseted Succesfully \"<<<\" at \"<   break;   }   pTemp = pTemp->pNList;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void insert(node **head,int data) \n{ \n \nif(!head) \nreturn; \n \nstruct node *temp=head; \nstruct node * newnode=(struct node *)(malloc(sizeof(struct node))); \nnewnode->next=NULL; \n \nwhile(temp) \n{ \nif(temp->datanext; \n} \nelse \n{ \nnewnode->next=temp->next; \ntemp->next=newnode; \nbreak; \n} \n \n} \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"temp = head \nNode newNode = new Node(); \nwhile(temp.key < newNode.value) \n{ \n     temp = temp.next \n} \n \nnewNode.next = temp.next; \ntemp.next = newNode;"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15203729","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"46","title":"Given a BST, how would you return the nth smallest element. The code had to cover all the edge cases and was expected to write a logn solution","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"Solution does not exist. For a log(n) solution, you need to visit each level a constant number of times without traversing all the nodes, effectively eliminating as you go. Elimination is not possible in this case.   At the beginning, you are at the root and you can't have any idea where to go. You pick left or right. Without traversing all the nodes in that subtree, you can't even know if you are in the correct subtree. Getting the number of nodes there is already O(n). That's why Log(N) is impossible.  I think this question was meant to be asked for a complete BST."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Viable solution , I gurantee, is augmenting the BST in such a way that each node stores the nodes in it's left subtree and right subtree. Then it is possilbe for lgn time for subsequent  order statistics related query ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"so, for example BST has 8 nodes and it is unbalanced(node \"1\" in the root, root.right = 2, root.right.right=3, etc..).  the algorithm should find the kth smallest element(i.e. 6th smallest element which is 6) for logN steps(for 3 steps). Mission seems to be impossible..if the nodes are repeated then it become even more difficult..Does the solution even exist?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public void traverseToNThSmallest(Node root) { \n   if (root.left != null) { \n    traverseToNThSmallest(root.left); \n   } \n   counter++; \n   if(counter ==nthElement) \n   { \n    System.out.println(nthElement+\"th element: \"+ root.val); \n    return; \n   } \n   if (root.right != null) { \n    traverseToNThSmallest(root.right); \n   } \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public static int findKthElementinBSTInTimeOfLogN(treeNode root,int k){      int[] arr = BSTintoArray(root);      if(k>arr.length) return -1;      return arr[k-1];     }  public static int[] BSTintoArray(treeNode root){      if(root==null) return null;      int[] left = BSTintoArray(root.left);   int[] right = BSTintoArray(root.right);      int l_length = 0;   int r_length = 0;      if(left!=null) l_length = left.length;   if(right!=null)r_length = right.length;      int[] left_new = new int[l_length+1+r_length];   left_new[l_length]=root.data;   if(left!=null){    System.arraycopy(left, 0, left_new, 0, l_length);   }   if(right!=null){    System.arraycopy(right, 0, left_new, l_length+1, r_length);   }   return left_new;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"number of nodes in the BST is known or unknown ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"find number of elements in left and right subtree. If n lies in left subtree then recursively search for (n - noOfElementsInRightSubtree). Same for right side if n lies in right subtree. The base case would be:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Isn't the Nth smallest mean the 1th highest ? :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The approach that I'd use will be recusively go to the smallest node of BST (Left most node) and the recursively backtrack. While backtracking, keep the nodes in a stack. If the size of stack is n then the top element of stack is the result"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node temp; \npublic Node getNthMin(int target){ \n  if(target==1) return getMin(); \n  else{ \n   int counter=1; \n   temp=getMin(); \n   while(true){    \n   temp=temp.parent; \n   counter++; \n   if(counter==target) return temp; \n   if(temp.right!=null) {counter++;} \n   if(counter==target) return temp.right; \n   } \n  } \n } \n  \n public Node getMin(){ \n  temp=root; \n  while(true){ \n   if(temp.left==null) return temp; \n   else temp=temp.left; \n  } \n   \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node temp; \npublic Node getNthMin(int target){ \n  if(target==1) return getMin(); \n  else{ \n   int counter=1; \n   temp=getMin(); \n   while(true){    \n   temp=temp.parent; \n   counter++; \n   if(counter==target) return temp; \n   if(temp.right!=null) {counter++;} \n   if(counter==target) return temp.right; \n   } \n  } \n } \n  \n public Node getMin(){ \n  temp=root; \n  while(true){ \n   if(temp.left==null) return temp; \n   else temp=temp.left; \n  } \n   \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"nth smallest would be the nth InOrder successor ryt ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In worst case you can't (say tree that looks like linked list) but on average you can probably do this. start searching for the smallest with pointer1. After n steps start searching for the smallest in parallel with both pointer1 and new pointer 2. Once pointer1 reached the smallest pointer2 points to the nth smallest."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"reach upto the leftmost node and the print tree in inorder upto count=6... tell me if this will work or not???"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Actually if traveling BST in-order, we will get the number by ascend, but most of us just do not realize this feature. \nSo this question will be changed into getting the kth element of BST in-order traverse. \n \nvoid findK(Node* p, int& k) { \n  if(!p || k < 0) return; \n  findK(p->left, k); \n  --k; \n  if(k == 0) {  \n    print p->data; \n    return;   \n  }  \n  findK(p->right, k);  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why don't we convert this BST into an AVL tree in O(logn) time and then search for the kth element in O(k) time?  Is there a better solution?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int BinaryTree::nthSmallestItem(int nth){ \n Stack parent, rightChild; \n \n NodePtr ptr = root; \n int counter = nth; \n parent.push(ptr); \n while(!parent.empty() && counter > 0){ \n  while(ptr != 0){ \n   parent.push(ptr); \n   if(ptr->right != 0) \n    rightChild.push(ptr->right); \n   ptr = ptr->left; \n  } \n  ptr = parent.topElement(); \n  parent.pop(); \n  counter--; \n  if(counter == 0) break; \n  if(ptr->right != 0){ \n   ptr  = rightChild.topElement(); \n   rightChild.pop(); \n  } else{ \n   // important to make ptr null else above while loop will probe same node and code goes into infinite loop \n   ptr = 0; \n  } \n } \n return ptr->data; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this would do the preorder of the tree which would give the nth smallest element in O(log n)complexity: #include #include #include using namespace std; struct node {     int data;     struct node *right;     struct node *left; }*root=NULL; struct node *bst_ins(struct node *root,int n) {     struct node *temp=root,*temp1;     if(!root)     {         root=new node;         root->data=n;         root->right=NULL;         root->left=NULL;     }     else     {         temp=root;         while(temp)         {             temp1=temp;             if(n>temp->data)             temp=temp->right;             else             temp=temp->left;         }         temp=new node;         temp->data=n;         temp->right=NULL;         temp->left=NULL;         if(n>temp1->data)         temp1->right=temp;         else         temp1->left=temp;     }     return root; } int nth_smallest(struct node *root,int n,int count) {     if(root->left)     count=nth_smallest(root->left,n,count);     count++;     if(count==n)printf(\"%d\",root->data);     if(root->right)     count=nth_smallest(root->right,n,count);     return count; } int del_tree(struct node *root) {     if(root)     {         del_tree(root->right);         del_tree(root->left);     }     delete root;     return 0; } int main() {     int i,n,d;     printf(\"enter the number of elements to be inserted into the tree:\\n\");     scanf(\"%d\",&n);     printf(\"enter the elements of the tree:\\n\");     for(i=0;i    {         scanf(\"%d\",&d);         root=bst_ins(root,d);     }     printf(\"enter the nth smallest number to be searched:\\n\");     scanf(\"%d\",&n);     nth_smallest(root,n,0);     del_tree(root);     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I also support that O(lgn) solution is not existing, but I try O(k) algorithm and I think I made it, here is my program in c, if there is anything wrong, please let me know about, thanks."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how about this?  Check for a balanced tree. if not balanced it?? or say cant do in log in  IF it is a balanced tree Use log N steps to reach the minimum value where N is number of elements and iteratively find successors  till we get the nth smallest element. This will take log N steps, n times so O(logN) + O(nlogN) where n is a constant = O(logN)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"first, start pre-order traversal of tree, when you visit node decrement count by 1,if count==0 return that element,,,,,initialize count by 'n'."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"traverse the tree... while traversing every node increment flag by 1.. for n th smallest element n==flag tht node is nth smallest element"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assumption: each node holds the number of nodes present within its subtree rooted at that node. If not for this assumption log N is not possible"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"it can be find in exact O(lon(n)+r) in worst case. and obviously it will be O(n) if bst is growing in only one way.  where n is total no of node in bst & r is the r'th element."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"can't we solve it by run in order traversal and return on nth step, something like"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"maybe the solution only exist for balanced bst where number of nodes = 2^(h+1) - 1 where h is the tree height. the height can be found for log N time by traversing to the left until null node.  then we found the subtree which has nth smallest elem( if n <= h+1 then it is in the left subtree we go in order to the left and stop on (h+1 - n) step. the performance is O(lgN + (h + 1 - n)) = O (lg N * 2 - n) = O(lg N)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"What if we do below:  1. Get the number of elements in left subtree in O(log n) time 2. if n < noOfElementInLeftSubtree then recurse in left sub tree 3. if n == noOfElementsInLeftSubtree + 1 then return root 4. else it has to be in right subtree so recurse in right subtree"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15139685","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"10","title":"You have a vending machine with some inventory. write a program to help vending machine tender exact change to the customer.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Seems like a linear programming problem to me. Let x1,x2...xn be the no of coins of each type required to make the given sum. So, we have to minimize x1+x2+...+xn with the constraints, k1x1+k2x2+.....knxn=sum, k1..kn being the exchange values x1, x2..xn are positive integers x1<=m1, m1 is the no of available coins of 1st type..and so on x2<=m2 .... xn<=mn"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Assumption is that its possible to provide change. (For that we can assume that there is unit coin available) We will have to define one objective for dispensing the coins.  \"Machine would like to dispense as few coins as possible\"  Then this problem can be either solved by Greedy approach or dynamic programming approach.   Greedy approach :  At any given stage, use the highest valued coin possible. Lets suppose you have to make change for 98 units and you have two 50 unit coins, one 20 unit coin and four 10 unit coins and unlimited 1 unit coins.  1st Stage : Use one 50 unit. (we can not use 2 as that would exceed the given amount) 2nd Stage : We could have used two 20 unit ones but we have only one. Use one. Remaining amount is 28.  3rd Stage : Use two 10 unit ones. 4th Stage : Use 8 one unit coins.   Another approach is Dynamic Programming.   Assume that the coins are of the value v1, v2, vn. We have to make change for value j.  MinNoOfCoins(j) =  min{for all v in [v1-vn]  calculate MinNoOfCoins{ j - v} } + 1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if m1,m2......mn b d max no of coins available of each type of x1,x2....xn coins respectively. bill amount =amt, amount given by d customer = tot. so change to b given = x i.e. tot-amt k1x1+k2x2....knxn=x where k1,k2...kn b d no of each coins required . initially k1=k2=.....kn=0 if x1,x2....xn are sorted (assuming x1 is highest and xn is least)then while(x>x1) { if(k1<=m1) { x=x-x1; k1++; } } while(x>x2) { if(k2<=m2) { x=x-x2; k2++; } } . . . . . .while(x>xn) { if(kn<=mn) { x=x-xn; kn++; } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is COIN CHANGE PROBLEM. (well know)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"You could change denomination array as you want. Please test it. Thank you:)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"public static void Change() \n        { \n            double[] change = new double[] {10.00, 5.00, 1.00, 0.50, 0.25, 0.01 }; \n            double ItemPrice = 8.25; \n            double Quantity = 2.00; \n            double CustomerAmnt = 20.00; \n            double Amount = CustomerAmnt - (ItemPrice * Quantity); \n            for (int i = 0; i < change.Length; i++) \n            { \n                if (Amount >= change[i]) \n                { \n                    double remainder = (Amount % change[i]); \n                    double times = (Amount / change[i])-(remainder/change[i]); \n                    Console.WriteLine(\"{0} * {1} = {2}\", change[i], times, change[i]*times); \n                    Amount = Amount- (change[i] * times); \n                } \n            } \n        }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15147678","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"12","title":"Find successor in a BST with duplicate values allowed.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I think having duplicate values wouldn't change the algorithm for finding successor without duplicate values."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"#include  \n#include  \nusing namespace std; \n \nclass TreeNode \n{ \n    public: \n        TreeNode(int _v, TreeNode * _left, TreeNode * _right) \n        { \n            v = _v; \n            left = _left; \n            right = _right; \n        } \n        int v; \n        TreeNode * left; \n        TreeNode * right; \n}; \n \nclass BST \n{ \n    public: \n        BST() \n        { \n            root = NULL; \n        } \n        BST(int * a, int n); \n        ~BST(); \n        TreeNode * Insert(int v); \n        TreeNode * Search(int v); \n        TreeNode * Successor(TreeNode * node); \n        void Print(); \n        bool Find(TreeNode * node, vector& ancestors); \n    private: \n        void Release(TreeNode *node); \n        void Print(TreeNode * node); \n        TreeNode * root; \n}; \n \n \nbool BST::Find(TreeNode * node, vector& ancestors) \n{ \n    if (node == NULL) \n        return false; \n    int v = node->v; \n    ancestors.clear(); \n    if (root == NULL) \n        return false; \n     \n    TreeNode * cur = root; \n    while (cur != NULL) \n    { \n        if (v < cur->v) \n        { \n            ancestors.push_back(cur); \n            cur = cur->left; \n            continue; \n        } \n        if (v > cur->v) \n        { \n            ancestors.push_back(cur); \n            cur = cur->right; \n            continue; \n        } \n        // v == cur->v \n        if (cur == node) \n            break; \n        ancestors.push_back(cur); \n        cur = cur->right; \n    } \n    return cur == node; \n \n} \nTreeNode * BST::Search(int v) \n{ \n    TreeNode * cur = root; \n    while (cur != NULL && cur->v != v) \n    { \n        if (v < cur->v) \n            cur = cur->left; \n        else if (v > cur->v) \n            cur = cur->right; \n    } \n    //cur == NULL or cur->v == v \n    return cur; \n} \nTreeNode * BST::Successor(TreeNode * node) \n{ \n    TreeNode * successor = NULL; \n    if (node == NULL) \n        return NULL; \n    // if node has right child \n    // then successor is its leftmost descendent \n    if (node->right != NULL) \n    { \n        successor = node->right; \n        TreeNode * cur = node->right->left; \n        while (cur != NULL) \n        { \n            successor = cur; \n            cur = cur->left; \n        } \n        return successor; \n    } \n \n    //if node has no right child \n    vector ancestor; \n    bool bSuc = Find(node, ancestor); \n    if (!bSuc) \n        return NULL; \n     \n    ancestor.push_back(node); \n    int n = ancestor.size(); \n    for (int i = n - 2; i >= 0; i--) \n    { \n        if (ancestor[i]->left == ancestor[i + 1]) \n        { \n            successor = ancestor[i]; \n            break; \n        } \n    } \n    return successor; \n} \nBST::BST(int *a, int n) \n{ \n    root = NULL; \n    for (int i = 0; i < n; i++) \n    { \n        Insert(a[i]); \n    } \n} \nBST::~BST() \n{ \n    Release(root); \n} \nvoid BST::Release(TreeNode * node) \n{ \n    if (node == NULL) \n        return; \n \n    Release(node->left); \n    Release(node->right); \n    delete node; \n} \n/* \n left: less than \n right: great than or equal to \n middle: equal to \n*/ \nTreeNode * BST::Insert(int v) \n{ \n    //if the tree is empty \n    if (root == NULL) \n    {  \n        root = new TreeNode(v, NULL, NULL); \n        return root; \n    } \n    TreeNode * parent = NULL; \n    TreeNode * cur = root; \n    while (cur != NULL) \n    { \n        if (v < cur->v) \n        { \n            parent = cur; \n            cur = cur->left; \n            continue; \n        } \n \n        if (v >= cur->v) \n        { \n            parent = cur; \n            cur = cur->right; \n            continue; \n        } \n    } \n \n    //now cur is NULL, its parent is parent \n    TreeNode * node = new TreeNode(v, NULL, NULL); \n    if (v < parent->v) \n        parent->left = node; \n    if (v >= parent->v) \n        parent->right = node; \n    return node; \n} \nvoid BST::Print() \n{ \n    Print(root); \n} \n \nvoid BST::Print(TreeNode * node) \n{ \n    if (node == NULL) \n        return; \n \n    Print (node->left); \n    cout << node->v << \" \"; \n    Print (node->right); \n} \n \nint main(int argc, char ** argv) \n{ \n    int a[] = {2, 4, 6, 7, 5, 9, 10, 9, 8, 8, 2}; \n    // 2 2 4 5 6 7 8 8 9 9 10 \n    BST tree(a, sizeof(a) / sizeof(int)); \n    tree.Print(); \n    cout << endl; \n     \n    TreeNode * node = tree.Search(2); \n     \n    while (node != NULL) \n    { \n        cout << node->v << \" \"; \n        node = tree.Successor(node); \n    } \n    cout << endl; \n    //TreeNode * sucNode = tree.Successor(node); \n    //cout << sucNode->v << endl; \n \n     \n    return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I think my solution works for no duplicates. It takes O(depth) time and O(1) space. The basic idea is to store the most possible succ till now, which means the node with a value bigger than target but smaller than all the nodes we have checked. Here is the code, if you find any bugs plz comment. : )"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"FndSuccessor( givenNode *g) { node *n; n = g -> right; if (n ->left == NULL) return n; while(n-> left!= NULL)  n = n->left; return n;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In case of no successor found, returns the same number. O(n) in time and space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"do inorder traversal until we get node which is greater than input node. Will work for the duplicate as well."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"One solution is :- display the tree in order, then search fro successor. requires O(n) space, O(n) time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"My idea is : use a hashtable.  Key                :     Value: Node.Value       Node.address  Do in-order traverse. At the same time, we store corresponding key and value pair into hashtable.  After that: we have a list L like 123455555(6)6677 We have known the address of that Node N, we want its successor.  We compare the address in  L until we find it, then we return the next one."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15138683","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"30","title":"Reverse Linked list in parts iteratively. ex 1->2->3->4->5->6->7->8 and if 'parts' is 3. o/p = 3->2->1->6->5->4->8->7.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"I was asked same Q at microsoft 2 years back. Few imp thing to keep in mind in Q like these: 1. Make no assumptions... ask wherever u have doubt before coding 2. Enumerate all cases and handle them when u write code like in this case inp could be of length 0,1,2,3n,3n+1,3n+2 3. Remember the head will change after this reversing so either use ptr to ptr while passing head or return the new head... as i have done in example below."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"You could try using a Stack"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"import java.util.Stack; \n \npublic class ReverseLinkedListInParts { \n Node head; \n int size; \n \n class Node { \n  int value; \n  Node next; \n \n  public Node(int value) { \n   super(); \n   this.value = value; \n   this.next = null; \n  } \n } \n \n public ReverseLinkedListInParts() { \n  super(); \n  head = null; \n  size = 0; \n } \n \n public void add(int e) { \n  Node newnode = new Node(e); \n  if (head == null) { \n   head = newnode; \n   size++; \n   return; \n  } \n  Node ptr = head; \n  while (ptr.next != null) { \n   ptr = ptr.next; \n  } \n  ptr.next = newnode; \n  size++; \n } \n \n public void reverseInPart(int parts) { \n  if (parts > size || parts < 1) { \n   System.out.println(\"The part is out of range. Cannot reverse\"); \n   return; \n  } \n  Node headPtr = head; \n  while (headPtr != null) { \n   int n = parts; \n   Node tailPtr = headPtr; \n   while (n > 1 && tailPtr.next != null) { \n    tailPtr = tailPtr.next; \n    n--; \n   } \n   reverse(headPtr,tailPtr); \n   headPtr = tailPtr.next; \n  } \n } \n \n private void reverse(Node headPtr, Node tailPtr) { \n  Stack stack = new Stack(); \n  Node ptr = headPtr; \n  while(ptr != tailPtr){ \n   stack.push(ptr.value); \n   ptr = ptr.next; \n  } \n  stack.push(tailPtr.value); \n   \n  ptr = headPtr; \n  while(ptr != tailPtr){ \n   ptr.value = stack.pop(); \n   ptr = ptr.next; \n  } \n  tailPtr.value = stack.pop();; \n } \n \n public void print() { \n  Node ptr = head; \n  while (ptr != null) { \n   System.out.print(ptr.value + \"\\t\"); \n   ptr = ptr.next; \n  } \n  System.out.println(); \n } \n \n public static void main(String[] args) { \n  ReverseLinkedListInParts ll = new ReverseLinkedListInParts(); \n  ll.add(3); \n  ll.add(1); \n  ll.add(5); \n  ll.add(7); \n  ll.add(2); \n  ll.add(4); \n  ll.add(6); \n  ll.print(); \n  ll.reverseInPart(8); \n  ll.print(); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public Node reverseN(Node first, int N, Node zero) {                                         \n    Node current = first;                                                           \n    Node previous = null;                                                           \n                                                                                    \n    for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct Node {  int data;  struct Node *next; }; struct Node *NewNode(int data) {  struct Node *temp=(struct Node *)malloc(sizeof(struct Node));  temp->data=data;  temp->next=NULL;  return temp; } struct Node *Reverse(struct Node *node,int k) {  if(!node)   return NULL;  struct Node *temp=node;  struct Node *p=node,*r=NULL,*q;  int len=k;  while(len-- && p)  {   q=r;   r=p;   p=p->next;   r->next=q;  }  node->next=Reverse(p,k);  return r; } int main() {  struct Node *node=NewNode(1);  node->next=NewNode(2);  node->next->next=NewNode(3);  node->next->next->next=NewNode(4);  node->next->next->next->next=NewNode(5);  node->next->next->next->next->next=NewNode(6);  node->next->next->next->next->next->next=NewNode(7);  node->next->next->next->next->next->next->next=NewNode(8);  int k=3;  struct Node *res=Reverse(node,k);  getchar();  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Would recommend you to draw the linked list example given and understand."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"So I see everyone doing pointer manipulations (setting the next of one to the next of another), but I figured that if you have access to the Node (and its parts), why not leave the list intact and instead move the values around?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \ntypedef struct NODE \n{ \n int data; \n struct NODE *next; \n \n}*PNODE,NODE; \n \nvoid printList(PNODE head) \n{ \n printf(\"\\nLinked List \"); \n while(head) \n { \n  printf(\" -> %d\", head->data); \n  head = head -> next; \n } \n} \n \nPNODE getNode(int data) \n{ \n PNODE node = (PNODE)malloc(sizeof(NODE)); \n node -> data = data; \n node -> next = NULL; \n return node; \n} \n \nvoid delNode(PNODE node) \n{ \n free(node); \n node = NULL; \n} \n \nvoid createList(PNODE head) \n{ \n int i = 0; \n \n for(i = 1; i< 10; i++) \n { \n  head -> next = getNode(i); \n  head = head->next; \n } \n} \n \nPNODE revList(PNODE head, int len) \n{ \n PNODE current = head; \n PNODE next = NULL; \n PNODE newHead = NULL; \n int i = 0; \n \n while(current && i < len) \n { \n  next = current->next; \n  current->next = newHead; \n  newHead = current; \n  current = next; \n  i++; \n } \n \n next = newHead; \n while(next -> next) \n { \n  next = next -> next; \n } \n next->next = current; \n \n return newHead; \n} \n \nint main() \n{ \n PNODE head = getNode(0); \n PNODE newHead = NULL; \n clrscr(); \n createList(head); \n printList(head); \n newHead = revList(head, 3); \n printList(newHead); \n getch(); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public Items ReverseLinkedListInParts(int n) \n        { \n            Items start = Head; \n            Items temp; \n            Items previous = null; \n            Items current = null; \n            int count = 0; \n            while (start != null) \n            { \n                if (count < n) \n                { \n                    temp = start.next; \n                    start.next = previous; \n                    previous = start; \n                    start = temp; \n                    count++; \n                    if (start == null) \n                    { \n                        current = AddNext(current, previous); \n                    } \n                     \n                } \n                else \n                { \n                     \n                    current = AddNext(current, previous); \n                    previous = null; \n                    count = 0; \n                } \n \n            } \n \n            \n            return current; \n        } \n \npublic Items AddNext(Items previous,Items newItem) \n        { \n            Items current = previous; \n            if (previous == null) \n            { \n                return newItem; \n            } \n \n            while (previous.next != null) \n            { \n                previous = previous.next; \n            } \n \n            previous.next = newItem; \n \n            return current ; \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nusing namespace std; \n \nstruct Node { \n int data; \n    Node* next; \n}; \n \nNode* BuildLinkedList(); \nvoid PrintResult(Node*); \n \nint main() \n{ \n Node* root = BuildLinkedList(); \n Node* result = NULL; \n Node* start = NULL; \n \n int stack[3]; \n int stackPointer = 0; \n \n for(int i=1; root != NULL; i++, root = root ->next) \n { \n   stack[stackPointer ++] = root -> data; \n \n  if(( i % 3 == 0) || (root -> next == NULL)) \n  {  \n   stackPointer = 0; \n      for(int i= 3-1; i>= 0; i--) \n   { \n    if(stack[i] != 1366047854) \n    { \n    Node* node = new Node(); \n    node -> data = stack[i]; \n    node -> next = NULL; \n    if(start==NULL) \n    { \n    start = node; \n    result = start; \n    } \n    else \n    start->next = node; \n \n    start  = node; \n    stack[i] = 1366047854; //assigning some unique to mark stack bottom \n    } \n   } \n  } \n } \n PrintResult(result); \n} \n \nvoid PrintResult(Node* root) \n{ \n for(Node* i = root; i != NULL; i= i->next) \n  cout << i -> data << \" \"; \n  \n} \nNode* BuildLinkedList() \n{ \n \n Node* start = NULL; \n Node* root = NULL; \n  \n int i = 1; \n while(i <= 8) \n { \n  Node* node = new Node(); \n     node->data = i; \n  node->next = NULL; \n  if(start==NULL) \n  { \n  start = node; \n  root = start; \n  } \n  else \n  start->next = node; \n \n  start  = node; \n i++; \n } \n return root; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void List :: reverse(int c) \n{ \n     List *prev = NULL,*temp = first,*ptr = NULL,*tail = NULL,*tempVar = temp;  \n     int count = 0; \n      \n    while(tempVar != NULL) \n    {  \n         ptr = temp -> next;       \n         temp -> next = prev; \n         prev =  temp; \n         ++count; \n         temp = ptr; \n     if (count == c || (temp == NULL && count < c)) \n     { \n      first = prev; \n     } \n     if (count % c == 0 || temp == NULL) \n     { \n               if (tail != NULL) \n               { \n                        tail -> next = prev; \n               } \n            tail = tempVar; \n            tempVar = temp; \n            prev = NULL;              \n     }           \n    } \n} \n \n:)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \ntypedef struct NODE \n{ \n int data; \n struct NODE *next; \n \n}*PNODE,NODE; \n \nvoid printList(PNODE head) \n{ \n printf(\"\\nLinked List \"); \n while(head) \n { \n  printf(\" -> %d\", head->data); \n  head = head -> next; \n } \n} \n \nPNODE getNode(int data) \n{ \n PNODE node = (PNODE)malloc(sizeof(NODE)); \n node -> data = data; \n node -> next = NULL; \n return node; \n} \n \nvoid delNode(PNODE node) \n{ \n free(node); \n node = NULL; \n} \n \nvoid createList(PNODE head) \n{ \n int i = 0; \n \n for(i = 1; i< 10; i++) \n { \n  head -> next = getNode(i); \n  head = head->next; \n } \n} \n \nPNODE revList(PNODE head, int len) \n{ \n PNODE current = head; \n PNODE next; \n PNODE prev = NULL; \n PNODE newHead = NULL; \n PNODE newTail = NULL; \n \n int i = 0; \n \n while(current) \n { \n  i = 0; \n  prev = NULL; \n \n  while(current && i < len) \n  { \n   next = current -> next; \n   current -> next = prev; \n   prev = current; \n   current = next; \n   i++; \n  } \n \n  if(newHead == NULL) \n  { \n   newHead = prev; \n  } \n  else \n  { \n   newTail = newHead; \n   while(newTail -> next) \n    newTail = newTail -> next; \n   newTail -> next = prev; \n  } \n } \n \n return newHead; \n} \n \nint main() \n{ \n PNODE head = getNode(0); \n PNODE newHead = NULL; \n clrscr(); \n createList(head); \n printList(head); \n newHead = revList(head, 4); \n printList(newHead); \n getch(); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"use a recursive solution. I think it will be much easier in way of thinking. import java.util.Scanner;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// list will be reversed by subPart, \n // eg. if list is as follow and subPart is 3 then \n // head -> A -> B -> C -> D -> E -> F -> G -> H \n // head -> C -> B -> A -> F -> E -> D -> H -> G \n void Reverse_Partial(int subPart) \n { \n  if (m_head == 0 || m_size == 1 || subPart == 1) \n   return; \n \n  List_Node_Ptr cur = m_head;  // current node \n  List_Node_Ptr prev = 0;   // will maintain prev node \n  List_Node_Ptr next = 0;   // will maintain next node \n  List_Node_Ptr lastTail = 0;  // will maintain last tail node \n \n  int numIter = m_size/subPart; // will maintain how many sub part of given array will be made. \n  int ni = 0; \n  int i = 0; \n  bool firstTime = true;   // will use only once to set the m_head \n \n  // we will proceed as follow \n  // 1. will iterate over each sub part \n  // 2. reverse the sub partial list \n  // 3. will change lastTail node pointer of previos reversed linked list, \n  // 4. if we are reversing first sub part linked list then change m_head node \n  // 5. reset the variables \n \n  // step 1 \n  while (ni <= numIter) { \n   // step 2 \n   while (cur != 0 && i < subPart) { \n    next = cur->next; \n    cur->next = prev; \n    prev = cur; \n    cur = next; \n    ++i; \n   } \n \n   // step 3 \n   if (lastTail == 0) { \n    lastTail = m_head; \n   } \n   else { \n    lastTail->next = prev; \n    // make sure Tail->next pointer will be null, so that we can add next reversed partial list \n    while(lastTail->next != 0) { \n     lastTail = lastTail->next; \n    } \n   } \n \n   // step 4 \n   if (firstTime) { \n    firstTime = false; \n    m_head = prev; \n   } \n \n   // step 5 \n   i = 0; \n   ++ni; \n   prev = 0; \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static Node reverseALinkedList(Node root, int k) {   Node current = root;   Node prev = null;   Node next = null;   int i = 0;   while(current != null && i != k){    next = current.next;    current.next = prev;    prev = current;    current = next;    i++;   }   if(next != null){    root.next = reverseALinkedList(next, k);   }   return prev;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I also use stack, and write in java. The code is short and pass the example above. I wonder if there are bugs. Plz comment if you find some."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static Node ReverseBlocksLinkedList(Node root, int portion) \n        { \n            int i = 1; \n            Node preRoot = null; \n            Node preNode = null; \n            Node curNode = root; \n            Node curRoot = null; \n \n            while (curNode != null) \n            { \n                curRoot = curNode; \n                while (i <= portion && curNode != null) \n                { \n                    preNode = curNode; \n                    curNode = curNode.Next; \n                    i++; \n                } \n \n                preNode.Next = preRoot; \n                preRoot = curRoot; \n                i = 1; \n            } \n            return curRoot; \n        } \n \n        static Node ReverseWholeLinkedList(Node root) \n        { \n            Node cur = root; \n            Node next = null; \n            Node pre = null; \n            while (cur != null) \n            { \n                //Set the next to point to item next to current \n                next = cur.Next; \n                //reset the cur next to point to pre node \n                cur.Next = pre; \n                //make cur to be pre; \n                pre = cur; \n                //make cur node to be next \n                cur = next; \n            } \n \n            return pre;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/*C# implementation*/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/*C# implementation*/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node* reverseByParts(node *head, int N) \n{ \n    if (head == NULL) \n        return head; \n    bool firstPart = true; \n    node* newHead = NULL; \n    node* cur = head; \n    node* pre = NULL; \n    node* first1 = head; \n    node* first2 = NULL; \n    node* next = NULL; \n    int i; \n    while (cur != NULL) { \n        first2 = first1; \n        first1 = cur; \n        //cout<<\"##\"<val<val<next; \n            if (cur != first1) { \n                cur->next = pre; \n                //cout<val<<\" to \"<val<val<<\" to \"<val<next = pre; \n        } \n        pre = first1; \n    } \n    pre->next = NULL; \n    return newHead; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A solution in Java with test cases. I use two while loops. Each time I reverse the next n nodes. I do not use stack to save space, because we can always reverse a list by inserting the next node after the new head node. Time O(n), Space O(1)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"hope this is easier to read and/or correct  Update: Found bug, looking into it"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15072765","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"24","title":"Write a program that reverses alternate elements in a given linked list input: a->b->c->d->e, output should be b->a->d->c->e","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"12","title":"Node reverseAlterante ( Node head) { \nif ( head == null || head.next == null ) \n        return head; \nNode r = reverseAlternate(head.next.next); \nNode t = head.next ; \nt.next = head; \nhead.next = r; \nreturn t ; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"public LinkedListNode reverseAlternate(LinkedListNode fHead) \n        { \n            if (fHead.Next == null) \n            { \n                return fHead; \n            } \n            else \n            { \n                LinkedListNode temp1 = fHead; \n                LinkedListNode temp2 = fHead.Next; \n \n                temp1.Next = reverseAlternate(temp2.Next); \n                temp2.Next = temp1; \n \n                return temp2; \n            } \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"while(p && p->next ) \n{ \n    temp = p->data; \n    p->data = p->next->data; \n    p->next->data = temp; \n    p = p->next->next; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Reverse(Node n) \n{ \nNode before = null; \nNode after = null; \nNode curr = null; \n \nif(n->next == null || n == null) \nreturn n; \n \ncurr = n; \nNode n = n->next; \n \nwhile(curr->next!= null) \n{ \nafter = curr->next->next; \ncurr->next->next = curr; \nif(before!= null) \nbefore->next = curr->next; \ncurr->next = after; \nbefore=curr; \ncurr = curr->next; \n} \n \nreturn n; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n#include  \n \ntemplate  \nstruct ListNode \n{ \n  ListNode(T val):data_(val),next_(NULL),prev_(NULL) \n  { \n  } \n  std::shared_ptr  next_; \n  std::shared_ptr  prev_; \n  T                          data_; \n}; \n \ntemplate  \nclass LinkedList  \n{ \npublic: \n  void Print(); \n  void SwapNeighbours(); \n  void Insert(T val); \nprivate: \n  std::shared_ptr< ListNode > head_; \n  std::shared_ptr< ListNode > tail_; \n \n}; \n \ntemplate    \nvoid LinkedList::Insert(T val) \n{ \n  if(head_ == NULL) \n    { \n      head_ = std::make_shared< ListNode >(val); \n      tail_ = head_; \n    } \n  else \n    { \n      assert(tail_!=NULL); \n      tail_->next_ = std::make_shared< ListNode >(val); \n      tail_ = tail_->next_; \n    } \n} \ntemplate  \nvoid swap(std::shared_ptr< ListNode > l1, std::shared_ptr< ListNode > l2) \n{ \n  if(!l1 || !l2) \n    { \n      return; \n    } \n  auto val  = l1->data_; \n  l1->data_ = l2->data_; \n  l2->data_ = val;  \n} \ntemplate  \nvoid LinkedList::SwapNeighbours() \n{ \n  auto temp = head_; \n  if(!temp) \n    { \n      return; \n    } \n  while(temp && temp->next_) \n    { \n      swap(temp,temp->next_); \n      temp = temp->next_->next_; \n    } \n} \n \ntemplate  \nvoid LinkedList::Print() \n{ \n  if(!head_) \n    { \n      return; \n    } \n  auto temp = head_; \n  while(temp) \n    { \n      std::cout<<\"[\"<data_<<\"]->\"; \n      temp = temp->next_; \n    } \n  std::cout<<\"[NULL]\"< llist; \n  for(int i=0; i<10; i++)   \n    { \n      llist.Insert(i); \n    } \n  llist.SwapNeighbours(); \n  llist.Print(); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void LinkList::swap() \n{ \n Node *node, *after, *before; \n int i=1; \n node = before = root; \n \n while(node && node->next) \n {   \n  after = node->next;   \n \n  node->next = after->next; \n \n  after->next = node; \n \n  if (i==1) \n  { \n   root = after; \n  } \n  else \n  { \n   before->next = after; \n  } \n   \n  i++; \n \n  before = node; \n  node = node->next;   \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static Node swapAlternateNodes(Node head) \n { \n  if(head == null || head.next == null) \n   return head; \n \n   \n  Node temp = head; \n  head = head.next; \n \n  Node current = temp;  \n  Node prev = null; \n   \n \n  while(current != null && current.next != null) \n  { \n   Node nextCurrent = current.next.next; \n   temp = current.next;  \n   current.next = nextCurrent; \n   temp.next = current; \n    \n   if(prev != null) \n    prev.next = temp; \n   prev = current; \n   current = nextCurrent; \n    \n  } \n   \n  return head; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the question has not been phrased properly. It should be \"swap\" adjacent elements of a linked list. That's probably what you meant."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \nstruct link \n{ \n int data; \n struct link *next; \n}; \n  \n//struct link *global_ptr = NULL;  \n  \nvoid insert_node(struct link **ptr,int value) \n{ \n //global_ptr = *ptr; \n struct link *temp = (struct link*)malloc(sizeof(struct link)); \n struct link *temp_ptr = NULL; \n temp->data = value; \n temp->next = NULL; \n if(*ptr == NULL) \n { \n  *ptr = temp; \n } \n else \n { \n  temp_ptr = (*ptr); \n  while(temp_ptr->next != NULL) \n  { \n   temp_ptr = temp_ptr->next; \n  } \n  temp_ptr->next = temp; \n } \n} \n \nvoid display_list(struct link *disp_list) \n{ \n while(disp_list != NULL) \n { \n  printf(\"The value in the list %d\\n\",disp_list->data); \n  disp_list = disp_list->next; \n } \n} \n \nvoid display_swap_nodes(struct link **root_node) \n{ \n struct link *test_ptr=NULL; \n test_ptr = *root_node; \n struct link *temp_node1=NULL; \n struct link *temp_node2=NULL; \n while(test_ptr->next != NULL) \n { \n   \n  temp_node1 = test_ptr->next; \n  if(temp_node1->next != NULL) \n  { \n   temp_node2 = temp_node1->next; \n  } \n  else \n  { \n   temp_node2 = temp_node1->next; \n   temp_node2->next = NULL; \n   break; \n  } \n  test_ptr = temp_node1->next; \n  if(temp_node2->next != NULL) \n  { \n   test_ptr->next = temp_node2->next; \n  } \n  else \n  { \n   test_ptr->next = temp_node2; \n  } \n  test_ptr = temp_node2; \n } \n} \n \nint main() \n{ \n struct link *link_ptr = NULL; \n int count; \n int value; \n  \n for(count =0 ; count<8; count++) \n { \n  scanf(\"%d\",&value); \n  insert_node(&link_ptr,value); \n } \n display_swap_nodes(&link_ptr); \n display_list(link_ptr); \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Quickest and easiest way to swap the alternate nodes will be to swap the data of alternate nodes, you can also swap nodes by using pointers, The only overhead swapping nodes using pointer will be to actually have one additional pointer. Below is the function which will swap data for alternate nodes."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void rev2(node *start) \n{ \nwhile(start->next && start ) \n{ \nstart->data=start->data + (start->next)->data; \n(start->next)->data=start->data -  (start->next)->data; \nstart->data=start->data - (start->next)->data; \nstart=start->next; \n} \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for(i 0 to n, i+2){ \n   a[i] = a[i]+a[i+1] \n   delete(a[i+1]) \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void swap (struct list **list1) \n{ \n    struct list *cur, *tmp, *next; \n    cur = *list1; \n    if (cur && cur->next) \n        *list1 = cur->next; \n \n    //To make sure that we have at least two more elements to be swapped. \n    while (cur && cur->next) \n    { \n        next = cur->next; \n        tmp = next->next; \n        next->next = cur; \n        //We have to make 1->next as 4 in above example (figure). \n \n  if(tmp) \n    if (tmp->next) \n        cur->next = tmp->next; \n    else \n        cur->next = tmp;    // take care of an add number of nodes \nelse \n    cur->next = NULL;  \n    } \n    return; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node* swapAlt(Node* head) \n{ \n Node* temp = head; \n while (temp != NULL) \n { \n  int n = temp->val; \n  if( temp->next == NULL ) \n   break; \n  temp->val = temp->next->val; \n  temp->next->val = n; \n  if( temp->next->next != NULL ) \n   temp = temp->next->next;  \n } \n return head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ansewr in C# - This answer does not use recursion which makes it better for large lists. The first prev instance is created so we will not have to check for null every iteration."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15066782","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"15","title":"Given two strings find if they are anagrams or not.  eg. \"tom marvolo riddle\" and \"i am lord voldemort\".  (The example added the other constraint that the whitespaces donot matter.)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"int isAnagram(char *s1,char *s2) \n{ \nchar characterCounter[256]={0}; \nint i; \nfor(;*s1;s1++) \n{ \n if(*s1==' ') continue; \n characterCounter[*s1]+=1; \n} \nfor(;*s2;s2++) \n{ \n if(*s2==' ') continue; \n   characterCounter[*s2]-=1; \n   if(  characterCounter[*s2] <0) \n      return 0; //false \n} \nfor(i=0;i<256;i++) \n    if(characterCounter[0]!=0) \n      return 0; //false \n \nreturn 1; // True, as both are anagram \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"solution 1: use sorting and compare the sorted strings solution 2: Use buckets and then pop elements from buckets"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"public static boolean isAnagrams(String str1, String str2) \n { \n \n  if(str1 == null && str2 == null) \n   return true; \n \n  if(str1 == null || str2 == null) \n   return false; \n \n  char[] charArray1 = str1.toCharArray(); \n  char[] charArray2 = str2.toCharArray(); \n \n  Map charCount1 = new HashMap(); \n \n  for(int i = 0; i < charArray1.length; i++) \n  { \n   if(charArray1[i] != ' ') \n   { \n    Integer value = charCount1.get(charArray1[i]);  \n    if(value == null) \n     value = 0; \n    charCount1.put(charArray1[i], ++value);  \n   } \n  } \n \n  Map charCount2 = new HashMap(); \n  for(int i = 0; i < charArray2.length; i++) \n  { \n   if(charArray2[i] != ' ') \n   { \n    Integer value = charCount2.get(charArray2[i]);  \n    if(value == null) \n     value = 0; \n    charCount2.put(charArray2[i], ++value);  \n   } \n  } \n   \n  int len1 = charCount1.keySet().size(); \n  int len2 = charCount2.keySet().size(); \n  if(len1 != len2) \n   return false; \n  Iterator it = charCount1.keySet().iterator(); \n  while(it.hasNext()) \n  { \n   Character current = it.next(); \n   Integer count1 = charCount1.get(current); \n   Integer count2 = charCount2.get(current); \n    \n   if(count1 != count2)  \n    return false; \n  } \n \n  return true; \n \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"this is a solution for this question  #include #include main() { char str1[20],str2[20]; printf(\"enter 2 strings..\\n\"); gets(str1); gets(str2); if(strlen(str1)==strlen(str2)) { char ch; int i=0; for(i=0;str1[i];i++) { int j=0,k=0,l=0; ch=str1[i]; for(j=0;str1[j];j++) if(ch==str1[j]) k++; for(j=0;str2[j];j++) if(str2[j]==ch) l++; if(k!=l) break; } if(i==strlen(str1)) printf(\"both strings are with same alphabets..\\n\"); } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Possible solution in python:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include   int main() {  int i=0,j=0;  char *first = (char*)malloc(sizeof(50));  char *second = (char*)malloc(sizeof(50));  scanf(\"%[^\\n]s\\n\",first);  scanf(\"%[^\\n]s\\n\",second);  while(*first != '\\0')  {   if(*first != ' ')   {    i = i + *first;   }   first++;  }  while(*second != '\\0')  {   if(*second != ' ')   {    j = j + *second;   }   second++;  }  if(i == j)  {   printf(\"Anagram\");  }  else  {   printf(\"not anagram\");  }  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include main() { char str1[20],str2[20]; printf(\"enter 2 strings..\\n\"); gets(str1); gets(str2); if(strlen(str1)==strlen(str2)) { char ch; int i=0; for(i=0;str1[i];i++) { int j=0,k=0,l=0; ch=str1[i]; for(j=0;str1[j];j++) if(ch==str1[j]) k++; for(j=0;str2[j];j++) if(str2[j]==ch) l++; if(k!=l) break; } if(i==strlen(str1)) printf(\"both strings are with same alphabets..\\n\"); } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include main() { char str1[20],str2[20]; printf(\"enter 2 strings..\\n\"); gets(str1); gets(str2); if(strlen(str1)==strlen(str2)) { char ch; int i=0; for(i=0;str1[i];i++) { int j=0,k=0,l=0; ch=str1[i]; for(j=0;str1[j];j++) if(ch==str1[j]) k++; for(j=0;str2[j];j++) if(str2[j]==ch) l++; if(k!=l) break; } if(i==strlen(str1)) printf(\"both strings are with same alphabets..\\n\"); } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"short arr[26] = {0}; \nbool isAnagram(const char * str1, const char* str2){ \n bool retVal = true; \n for(int ii = 0; ii < strlen(str1); ii++){ \n  if(str1[ii] == ' ') continue; \n  arr[str1[ii] - 'a']++; \n } \n for(int ii = 0; ii < strlen(str2); ii++){ \n  if(str2[ii] == ' ') continue; \n  arr[str2[ii] - 'a']--; \n } \n for(int ii = 0; ii < 26; ii++){ \n  if(arr[ii]) { \n   retVal = false; \n   break; \n  } \n } \n return retVal; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \nbool IsAnagram(string inString1, string inString2) \n{  \n //remove whitespace \n inString1.erase(remove(inString1.begin(), inString1.end(), ' '), inString1.end()); \n inString2.erase(remove(inString2.begin(), inString2.end(), ' '), inString2.end()); \n  \n //sort \n sort(inString1.begin(), inString1.end()); \n sort(inString2.begin(), inString2.end()); \n  \n return(inString1 == inString2); \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15072737","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"16","title":"Round 3 :  Q 6 :  You are given a ternary tree (a tree with 3 children at max with left, middle, right pointer at each node), create a singly linked list from it without using extra space ?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Solution by Stanford professor -"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"I think this might work."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Java code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Any order in which the linked list has to be formed ??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class Ternary { \n \n int data; \n Ternary left = new Ternary(); \n Ternary right = new Ternary(); \n Ternary child = new Ternary(); \n  \n public Ternary convert(Ternary root, Ternary tail){ \n  Ternary currNode; \n   \n  currNode = root; \n  while(currNode.right!=null){ \n   if(currNode.child!=null){ \n    currNode.child.left = tail; \n    while(currNode.child.right!=null){ \n     currNode = currNode.right; \n    } \n    tail = currNode.right; \n   } \n   currNode = currNode.right; \n  } \n  return currNode; \n          }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include  struct node {  int data;  struct node *left,*middle,*right; };  struct node *newNode(int data) {  struct node *temp=(struct node *)malloc(sizeof(struct node));  temp->data=data;  temp->left=temp->middle=temp->right=NULL;  return temp; }  void ternaryTreetoLL(struct node *root,struct node **prev) {  if(root==NULL)   return;  ternaryTreetoLL(root->left,prev);  root->left=*prev;  (*prev)=root;  ternaryTreetoLL(root->middle,prev);  ternaryTreetoLL(root->right,prev); }  void printList(struct node *head) {  if(head==NULL)   return;  while(head!=NULL)  {   printf(\"%d \",head->data);   head=head->left;  } }  int main() {  struct node *root=newNode(10),*prev=NULL;  root->left=newNode(6);  root->middle=newNode(9);  root->right=newNode(13);  root->left->left=newNode(7);  root->left->middle=newNode(8);  root->left->right=newNode(5);  ternaryTreetoLL(root,&prev);  printList(prev);  getchar();  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Run a BFS and on popping each node from the queue, add it to the linked list.  BFS can run either in recursive or explicit queue."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static TernaryTreeNode toList(TernaryTreeNode head) { \n  if (head == null) \n   return null; \n   \n  head.left = toList(head.left); \n  head.middle = toList(head.middle); \n  head.right = toList(head.right); \n   \n  TernaryTreeNode newHead; \n   \n  if (head.left != null) { \n   head.left = join(head.left, head.middle); \n   newHead = head.left; \n  } else { \n   newHead = head.middle; \n  } \n   \n  if (head.middle != null) { \n   head.middle = join(head.middle, head.right); \n  } else if(head.left != null) { \n   head.left = join(head.left, head.right); \n  } else { \n   newHead = head.right; \n  } \n   \n  if(head.right != null) { \n   head.right = join(head.right, head); \n  } else if (head.middle != null) { \n   head.middle = join(head.middle, head); \n  } else if (head.left != null) { \n   head.left = join(head.left, head); \n  } else { \n   newHead = head; \n  } \n   \n  head.left = null; \n   \n  return newHead; \n   \n } \n \n private static TernaryTreeNode join(TernaryTreeNode node1, TernaryTreeNode node2) { \n  if (node1 == null) return null; \n   \n  if(node1.left != null) { \n   node1.left = join(node1.left, node2); \n  } else { \n   node1.left = node2; \n  } \n   \n  return node1; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/*  \n Might be easier to consider 'left' as the 'next' in the tree and just \n move middle and right to left most node while traversing left one at a time. \n Algo:  \n  Traverse left and find the left most leaf \n  current node = root \n  Till there are no nodes left on the leftside \n    do this for both middle and right \n   Add middle to the left most leaf \n   Add right to the left most leaf \n    move current one node left \n*/ \n \n// Adds a given node to the left most  \nNODE *AddToLeftEnd(NODE *root, NODE *node) \n{ \n while (root->left) \n { \n  root = root->left; \n } \n root->left = node; \n \n return root; \n} \n \n// root becomes 'head' with list linked via 'left' when function returns \nvoid TernaryToList(NODE *root) \n{ \n NODE *end = root, *curr = root; \n \n while (curr) \n { \n  if (curr->middle) { \n   end = AddToLeftEnd(end, curr->middle); \n  } \n  if (curr->right) { \n   end = AddToLeftEnd(end, curr->right); \n  } \n \n  // Move to next node on left \n  curr = curr->left; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15062738","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"41","title":"Round 3 :  Q 5 : You are given a binary search tree, and a value(data item), you need to tell the left most right cousin in as minimum time and as minimum space ?(need to minimize actual time complexity, he need minimum order of complexity as well as number of node access should be minimum)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Carry out a Level Order Traversal and once you get the node that is given, the very next node would be the left most right cousin."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Just traverse till left most node,when you hit null,go to the root node of the current node and then go for its right child."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"once you traverse down those are not cousin those are child so cousin should be in the same level but left most right cousin dint make any sense please help me to understand the question"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"is it leftmost right cousin in same level ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi!  What about a BFS?   I would mark the empty nodes with some standard value. And than do a BFS : when I reach the level with the given data , I will check for the left most right position which should be the cousin .. and if it is a standard value of mine then return null else return the data from the node. (Correct. I mean BFS)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I may not be sure, but the following part worked with one example at least. I didn't have time to testit with other examples. It is basically BFS.  Structure of the binary search tree used modified for BFS"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a question for Binary Search Tree. So, we should make use of this fact.  Pseudocode::  **Do a binary Search to find the given node. **Keep Track of a previous ancestor which has a right child and its level. **If given node was a left child, its parent's right child will be its immediate right sibling,  **otherwise, its ancestor's right_child's leftmost node at the level of the given node will be its immediate right sibling.  Max Time: O(2*logn) Space: O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Find the root of the given \"node\" [ long n]. While doing so keep a track of the parent node.  2. Once found. Run a In-order traversal from the parent node found in step 1. 3. The first leaf node in the in-order traversal would be left-most right cousin.  time-complexity [ O(logN)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@ Sonesh,can we modify the node structure? Can we add one extra sibling pointer?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(N) worst case. O(N) space.   1. BFS (left to right), using a queue and inserting empty node marker in the queue when a node is missing a child and a level marker when we hit a new level.  2. If we find the value, its cousin must be behind it in the queue and be before the next level marker. If it's an even node (counting from left) its first cousin is at least two nodes way. Otherwise its next node is at least one node away.  3. Pop off the queue until we find the next non empty cousin (return it) or we hit the level marker (return null).  This is somewhat complex and probably not optimal but it's the best I can come up with."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my implementation using Java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private static Node nextRight(Node root, int i) { \n        Queue q1=new ArrayDeque(); \n        Queue q2=new ArrayDeque(); \n        q1.add(root); \n        while(!q1.isEmpty()){ \n \n            Node value=q1.remove(); \n            if(value.data==i){ \n                return q1.remove(); \n            } \n            else{ \n                if(value.left!=null) q2.add(value.left); \n                if(value.right!=null) q2.add(value.right); \n            } \n            if(q1.isEmpty()){ \n                q1=q2; \n                q2=new ArrayDeque(); \n            } \n \n        } \n        return null; \n \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Keep a pointer to grand parent of the node being searched. 2. After that easy to find the sibling of the parent and if they have any child nodes."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Find the node with the searched value for using the regular BST node lookup. Also look for the first time the branching happens for the left and start counting the nodes thereafter. (If there is no branching, there can't be any next sibling) 2. If branching occurs again, keep a note of the node and reset count 3. The count is the distance b/w the LCA (at the location where branching occurred) of the sibling and the searched value.  4. Knowing the LCA node, start DFS until the depth traversed == count (from last step)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Find the node, and keep track of level (say target node is found on level L)- time log N \n2) Push each traversed node into a stack \n3) When node is found \n  a) Pop the stack to remove the parent of the target node \n  b) If stack is empty then given node does not have a cousin; return \n  c) Do DFS from the right child of the current top of the stack (which is the grand-parent of the target node) and return the first node at Level L"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"he said he already gave a BST, He obviously gives it in an array..!!Confirm from the interviewer that its accepted in In-order only  1.)Search for the Required node in the Array (which if found say is at i  ), 2.)Nodes From (i+1---till---2i) are its Cousins  Hopefully im right!!!!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"for this question, do we need a binary search tree, or just a binary tree?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15073732","download_status":"DOWNLOAD_DONE","votes":"-3","answersCount":"0","title":"Round 3 :  Q 1 : How are you ? Q 2 : Do you want to go for MS or PHD ? Q 3 : What type of branch is yours ?(actually my branch name is mathematics and computing, and after 3 year Microsoft allowed our branch to appear for placement, so they ask this question) Q 4 : One question is from my project ??Garbage cleaner Robot??? ?"}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15067745","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"29","title":"Round 2 :  Q 3 : you are given some nodes, and for each node a probability is given which will tell its importance, you need to design an efficient  data structure such that the expected search time as minimum as possible. (Hint : Use dynamic programming + binary tree).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"I think a Huffman tree should be an ideal choice if we know the priority of the nodes"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Construction of Optimal BST's using DP. h t t p://en.wikipedia.org/wiki/Binary_search_tree#Optimal_binary_search_trees"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"maybe we can use a sorted array with gallop search"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sort the nodes with according to the probabilities in descending order - O( n Log n) Loop over them starting from the highest probability node. This becomes the root. Likewise keep inserting into the tree. With this logic your highest probability node is the root. Generalizing, higher the node probability closer it is to the root while lesser the node probability farther it is from the root"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can anybody explain this question.... m not getting wot exactly \"importance\" is....plz somebody thro some light on this q..... thanks"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Did the following analysis: (I am taking an example without any loss of generality) Suppose the nodes given to you are 0.4, 0.3,0.2 and 0.1. Sort it in descending order and save in an array( or any other linear data structure for that matter) the expected time is proportional to 0.4*1(memory access)+ 0.3*2 + 0.2*3 +0.1*4=2 Time Units. Now with little playing around you can find out that if you gor for a special hierarchical data structure which stores the highest element as the root, the second highest as the right element, and the the rest in the same order then we get a expected search time of 1.5 TU The tree is:             0.4     0.2        0.3 0.1  The complexity is 0.4*1 + 0.2*2+0.3*2+0.1*3=1.7TU This is the solution I came to after a bit of analysis. Let me know your thoughts."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can use priority queue using balanced tree data structure. Insertion operation will take O(logn), Search operation will take O(logn), if you want to use importance information, we can design extra variable to maintain maximum probability node. This help us to have FindMaxProbability with O(1)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Treap will be suitable?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Any better solution than O(n^2)?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Trick question?  Storing the values in a hash set gives O(1) lookup time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"You could use a Min/Max Heap which will give the most important node in O(1) time"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Not sure if the interviewer himself gave the hint as a binary tree ...  Here is an attempt ...What about using a linked list and maintaining the nodes in descending order of importance so that the most important node is at the beginning of the linked list ... if a node gets retrieved its importance can be updated and based on the updated value of the importance, a comparison with neighbouring nodes can be done and the node can be moved to a position based on the new value of importance ... using a binary tree may allow retrieval in log(N) time but updation of the tree may be time consuming"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15066748","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"7","title":"Round 2 :  Q 2 : You are given finitely many intervals in 1D, you have to design a data structure an efficient data structure which can answer queries of the form ??In how many intervals the point P belong ????, P is an input point, and all intervals are closed.  I answer B tree(think why) which is most efficient.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Interval Trees implemented using red black trees."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Interval tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can use a derivative of RMQ. There are known algos for preprocessing in O(N) and O(1) search time. Here, instead of finding the min of the given range we pre-process for finding the given number for the given range. So, overall, answer would be O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can any one give the example with input and output"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think binary indexed tree should do, keep updating the intervals (each unique interval by 1) and read at the input point.( Please point out if there is any mistake or I have understood the question incorrectly.)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Lets say the points are (a1,b1) (a2,b2) (a3,b3) (a4,b4) (a5,b5), Construct Bindary Tree Either on min values(a1,a2,a3,a4,a5) or max values( b1,b2,b3,b4,b5), and add another field range which will be ri = bi-ai, Insert this in each tree node, Now compare given point's min value in the Binray tree."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15065754","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"3","title":"Round 2 :  Q 1 : You are the supervisor of an airport. What happens is that visitors are not visit your airport, instead they go to another one, which means your airport become unpopular nowadays, Now as a supervisor you need to find out what has happens ?, What went wrong ?,How do you find out ?, What is correct ?, How do you find correct one and at what cost ?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I will try to find out what all CATEGORIES of reasons could be causing this... And all that falls under that category...  For example If People Are Having Better/cheaper Alternatives then of what? Low fares/better quality or what??   And then they could be mis informed..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i would launch a survey targeting visitors of the other airport and analyze the causes for the unpopularity of mine"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would rather go myself or send someone to the other airport, not as a supervisor of any airport but as a normal visitor and would analyse things so as to why I should prefer my own airport rather than the other one. Because you need to be more informed about the other airport's (read rival) informations in order to succeed or rather stay alive in a competition."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15065753","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"Round 1 :  Q 3 : What do you think, how the posts in Facebook are shown, to your page, as there are thousands of posts, likes, videos, images, links etc. shared by your friends, but not all are shown to you ? (Data mining question, have to tell appropriate solution which can work ?)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"If I had to guess, I would say that there is a threshold function that calculates some parameters. If the calculation goes over a certain threshold, the post is revealed to the user.  Possible parameters, to my opinion, could be: 1. Proximity: Closer friends' statuses will have a higher rating (=result in the threshold function). Proximity can be measured by the number of conversation friends have, wall-to-wall communication, joined friends, etc. 2. Popularity: I would guess that popular poss will have a higher rating. Popularity can be measured by the number of likes, comments and shares. 3. Similar posts: If there are keyword that also show in other, popular posts, that will (maybe) also increase the rating.  Just a hunch..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Facebook uses an algorithm called EdgeRank to decide which posts show up on your News Feed....  Just google 'edgerank techcrunch'. The algorithm was explained in an article on TechCrunch."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15074748","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"25","title":"Round 1 : Q 2 : longest palindrome in a string ? (Need to tell in O(n) time complexity + O(1) space complexity)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"It is called Manacher algorithm. For excellent explanation of Manacher algorithm see,  leetcode.com/2011/11/longest-palindromic-substring-part-ii.html  Also visit wiki page,  en.wikipedia.org/wiki/Longest_palindromic_substring"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static int pal(String s) { \n    char[] array = s.toCharArray(); \n    int maxCounter = 1; \n    for (int i = 1; i < array.length - 1; i++) { \n        int counter = 1; \n        int l = i - 1; \n        int r = i + 1; \n        while ( l > 0 && r < array.length - 1 ) { \n            if (array[l] == array[r]) { \n                counter++; \n                r++; \n                l--; \n            } else { \n                break; \n            } \n        } \n        if (counter > maxCounter) { \n            maxCounter = counter; \n        } \n    } \nreturn maxCounter; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I fixed a few bugs in panos' answer. It wasn't handling cases such as \"madamyracecarxzyjj\" correctly. Also, pal() was returning a counter instead of the number of characters in the palindrome.  Finally, I adapted it to C++."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"you sure it can be done in O(n)? basically you don't know the start point and end point of the palindrome, so I think you need at least O(n^2). Let me know if I was wrong."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can use this recursion formulae  P(crawlerFromBeginning,crawlerFromEnd) = if(word[crawlerFromBeginning]== word[crawlerFromEnd]){ 2 + P(crawlerFromBeginning+1,crawlerFromEnd-1)  // if the characters at the position  are equal } else{ max(P(crawlerFromBeginning+1,crawlerFromEnd) ,P(crawlerFromBeginning,crawlerFromEnd-1) ) }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorry for previous comment ...the above code is right."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I realize above algo doesn't taking care of Even cases (like: cdeedc, aaaa ) & what about string length 2 (aa) . So i am fixing the code now.  public int pal(String s) {   // null pointer check for s and length of s if 0   if (s == null)    return 0;    int len = s.length();    if (len < 2) {    return len;   }    char[] array = s.toCharArray();    // the algorithm will fail for strings of length 2    if (len == 2) {    if (array[0] == array[1])     return len;    else     return 0;   }    int maxCount = 1;    for (int center = 1; center < len - 1; center++) {    int palinLen = 1;    int l = center - 1;    int r = center + 1;    // Even Case handled here    // in case of aaa center + 2 (where center=1) = 3 < 3  means this case will not land in     // Even case;    if (array[center] == array[center + 1] && (center + 2 < len)) {     r = center + 2;     palinLen++;    }     while (l >= 0 && r <= len - 1) {     if (array[l] == array[r]) {      r++;      l--;      palinLen += 2;     }     }    if (l < 0 || r == len) {     if (palinLen > maxCount) {      maxCount = palinLen;     }    }   }   return maxCount;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I fixed panos's code a little bit. But it's still not O(n). C# code."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"leetcode.com/2011/11/longest-palindromic-substring-part-ii.html  Thanks! This is extremely helpful! good link!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question is incorrect - Manacher's algorithm uses O(n) space, not constant space.  So the best solution takes O(n) time and O(n) space."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"string longest_around(const string& str, int i, int j) \n{ \n string longest; \n int left = i, right = j; \n while(str[left] == str[right]) \n { \n  longest = str[left] + longest + str[right]; \n  ++left; ++right; \n } \n   \n return longest; \n} \n \nstring longest_palindrome(const string& str) \n{ \n string result; \n for(int i = 0; i < str.length() - 1; ++i) \n { \n  string pal = longest_around(str, i, i); \n  if(pal.length() > result.length()) \n  { \n   result = pal; \n  } \n \n  pal = longest_around(str, i, i + 1); \n  if(pal.length() > result.length()) \n  { \n   result = pal; \n  } \n } \n  \n return result; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class LongestPalindrome { \n \n    public static void main(String[] args){ \n \n        System.out.println(\"Enter the string\"); \n        String str1=new String(); \n        //String str1=new String(); \n        Scanner s=new Scanner(System.in); \n        str1=s.nextLine(); \n        char[] s1 = str1.toCharArray(); \n        char [] s2 = new char[2*str1.length()+1]; \n        int l,r,count,maxcount=1; \n        for(int j=0;j<2*str1.length()+1;j++) \n        { \n \n            if(j%2==0) { \n \n                s2[j]='#' ; \n \n            } \n \n            else{ \n \n                s2[j] = s1[j/2]; \n \n \n \n            } \n \n \n \n        } \n \n       /* for(int k=0;k<2*str1.length()+1;k++) \n                   System.out.print(s2[k]);  */ \n \n     for(int i=1;i<2*str1.length()+1;i++){ \n          count=0; \n          l=i-1; \n          r=i+1; \n \n           while(l>=0 && r<=2*str1.length() && s2[l]==s2[r]) \n           { \n              count++; \n              l--; \n              r++; \n \n          } \n \n           if(count>maxcount){ \n \n               maxcount=count; \n \n           } \n \n \n        } \n \n        System.out.println(\"\"); \n \n        System.out.println(\"the maximum sized palindrome is  \" + maxcount); \n \n \n \n} \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I do not see any point in asking  such complex code for interview ..This is wrong method to select people who have just mugged up things ...This is not knowledge at all."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question makes no sense.   Please provide examples with your questions."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Hey All,  it should be r-- and l++ instead of r++ and l--"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15064732","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"13","title":"Round 1 :  Q 1 : When you visit on your friend??s Facebook profile, there is a mutual friend section where common friends are listed, now let??s assume that your friend do the same thing, he/she visit his/her friend other then you, now the people other than common are connected to you by distance of two. Similarly think you are given two people on Facebook, how do you find this connectivity?. (Please give appropriate solution),   Now let??s think that some important people are given some weight(any), now do the same thing ?  Now calculate the most influential person? (Not an easy question, because of weights) ?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"is BFS good?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think a simple Depth Bounded Search (BFS or DFS) should suffice for the 1st part.  If I understand the 2nd part correctly, we have to find the connectivity between 2 persons such that the people with most weight are included in the path. We can inverse the weights and then find the shortest weighted path using Dijstra's Algo.  For the 3rd question, Maintain a variable which keeps track of the max. value of weight while doing part2. OR my understanding of the question is wrong :D"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.  best possible connections could be identified as sum of weights of all paths (connections) form a candidate person to the target person divided by number of paths. a default weight of an edge may be assumed as one in this case, so for example- if a candidate vertices (person) is 2 vertices (person) away from target vertice then the sum of that connection is 2.  2. people with weight reduce the sum of each edge connected to them by a factor of their weights, ideally this would be a factor of weights of both sides of a given edge  3. influence of a person could be a function of sum strength of each connection (which may a function of frequency of contact, number of shared friends, duration of connection etc)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Hey..How many yrs of experience u have?? I am only 2 yrs experienced...and i kind of find these question difficult..do they ask this level of questions from 2 yrs exp also?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"just wanna subscribe the comments for this question."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15030878","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"19","title":"Given a board of snakes and ladders game, provide an algorithm to find the minimum number of dice rolls required from 1 to 50 and maximum number of dice rolls required from 51 to 100. Note:  Consider snake bite and ladder up condition from the board.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"This question seems wrong, or at least in one corner case... I think the second part of the question (the maximum from 51-100) might yield a value of infinity. Suppose 51 is an empty cell and 52 is a snake that leads to 51. If I land on 51 and the dice always shows 1 then I'll loop there forever..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"For 1 to 50 Using DP  1. Initialize dp[0] to dp[6] = 1 {Since these can be reached in 1 dice roll} and all dp[7] to dp[50] = INT_MAX (high number)   2. Ladders will have 2 endpoints : Starting Cell and Ending Cell of which obviously ending cell will be greater.  Sort all the ladders in ascending of their starting cell.  3. For i = 1 to 6     4.Check if there is a ladder with starting cell i. Say ending cell of such a ladder is e. If so make dp[e] = 1;  5. For i = 7 to 50     6. max = INT_MAX (some very high value)     7. For j = i to j = i-6          8. if max < dp[j]+1 then max = dp[j]+1;     9. if dp[i] > max dp[i] = max;     10. Check if there is a ladder with starting cell i. Say ending cell of such a ladder is e. If so make dp[e] = dp[i]+1; 11. dp[50] is the minimum number of dice rolls required to reach 50.  If there are ladders on top of another ladder, example: ladder1 from cell 9 to cell 12 and ladder2 from cell 12 to 25.  In this case repeat Step 4 and Step 10 till there are no more ladders.   Step 10:   10a. flag = 0, s = i;   10b. while flag == 0   10c. Check if there is a ladder with starting cell s. Say ending cell of such a ladder is e. If so make dp[e] = dp[s];    and set s = e;   10d. If there is no such ladder then flag = 1;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I thought about a recursive solution with complexity Nx(num of ladders).  Better solutions welcome:  int min_rolls(node * start) {    int arr[6] = {INT_MAX, INT_MAX, INT_MAX, INT_MAX, INT_MAX, INT_MAX}    int i = 0;    int j = 0;    for(int i = 1; i <= 6; i++)    {      // if its 50 then return 1;           if(*start+i == 50)        return 1;                // for each ladder climbup & recursive call min_roll      if(is_ladder(start+i) && ladder_top(start+i) < 50)        arr[i-1] = min_rolls(ladder_top(start+i));       else if(is_not_snake(start+i))      // keeping track of last non_ladder non_snake index        j = i;      }          // if all 6 indexes are not snakes & ladders then    // recursively call min_rolls with last non_ladder non_snake index.    if(j != 0)    {       arr[j-1] = min_rolls(start + j);    }       return ( MIN(arr[0-5]) +1 );    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"From 1 to 50 Let the coin be at the initial position and the number of steps moved  is zero      >>the next six step or cell(2,3,4,5,6,7) can be reached with minimum 1 dice roll       >>mark the cell with 1      >>if any of these six cell has lower point of ladder then mark upper point of ladder with 1      >>continue the above steps with MAXIMUM upper point of the ladder and mark the further cell with current weight(here it is 1) with 1    For 51 to 100     >> instead of ladder use snake!!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"let S[x] = number of steps to add at position x, for ladder S[x] is positive for snake its negative else its 0.  Let M[x] = min number of rolls to get to pos x so M[x] = min(min (i=1to6) (M[x-i] + 1), M[x])"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"every cell is a node. Path is an edge. for 0 < i < 50 and i < j <= 50 w[i,j] = 1 ; if j-i <= 6 w[i,j] = 1 ; if there's a ladder from i to j w[i,j] = -1 ; if there's a snake from i to j w[i,j] = infy ; otherwise run floyd warshall to find the minimum path from 1 to 50.   for 50 < i < 100 and i < j <= 100 invert the weights and find the minimum path from 51 to 100. I think this should work."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For 1 - 50 , give each ladder +1 weight and snake +1 and now apply Dijkstra Single Source Shortest path algorithm.  For 51-100, give each ladder a weight of (end point - starting point) and each snake a weight of -1, now apply Bellman Ford or Floyd Warshall algo, longest path can be infinite."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Only Microsoft can ask getMaxMoves. Crap!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For 1 to 50: Consider the board as directed graph. 1. k is linked to k + 1 k + 2, k + 3, k + 4, k + 5, k +6 because from k you can reach these nodes in one throw of dice. 2. If any of these neighbors of k has a ladder which takes you to j, then j becomes the neighbor instead of the base of the ladder. Lets say k + 3 node takes you to j node, then instead of k + 3, j is the neighbor of k. 3. Similarly if any of the neighbors of k has a snake which takes you to l, then l is a neighbor of k. 4. The value of each edge ranges from 1 to 6. For ex., k->k+1 has 1 weight, k->k+2 has 2 weight, and so on...... upto k->k+6 having 6 weight. Using these conditions, build the graph. Now this is transformed into a Shortest path between two nodes in a directed graph problem.  For 51 to 100 I agree with what anonymous said in the first post."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1-50: use BFS  51-100: infinity unless any constraints are placed  On a side note I think single linked list with random pointers (ladder, snake) might be a good DS to represent snake and ladder board."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15031895","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"14","title":"Suppose you have given a tree with N nodes and weights associated with each node and edges are given(present in the tree).You have to remove two edges such that the sum of weights of three trees created is maximum.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"We need to remove two edge with least weight. Here is how we can do this: Traverse the tree breadth wise (use queue). Keep two variable to store MinNode1 and MinNode2. At the end remove the two least weight edge. Pseudo code: 1. Queue.enqueue(root) 2. while (!queue.Empty()) 2.1   poppedNode = queue.dequeue(); 2.2. if(poppedNode->Left != null)   queue.enqueue(popped->left); 2.3. if(poppedNode->Right != null)   queue.enqueue(popped->Right); 2.4 if ( popped->Wt < = Max(minNode1->Wt, maxNode->Wt))       Swap (larger(minNode1, minNode2), popped);  At the end, remove the link : minnode1->parent and minnode1->parent"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Clearing Ambiguity and responding to this question here.  Certainly we need to assume that the tree Has to be Binary Tree to be possible. So the algo goes here.  We need to create a Binary Tree on the basis of edge weight value as node and do the following operation.  1> For Unorder Binary Tree,  we need to traverse the full tree to get the following values         a> Smallest Edge Node Value and Second Smallest Edge Node Value. As node is now edge.         b> Total Weight of the Tree      So the Max value will be Total minus the two smallest Node value and there will be three sub tree.       Time Complexity  will be O(n) and Space O(1). 2> For Ordered Binary Tree like BST the algo remain the same only the Time Complexity goes to O(log n) as searching for the two smallest edge will be easier."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please elaborate more with example."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This question is ambiguous. We can't always break a tree into three trees by removing two edges. Consider the following example:  A->B A->C A->D A->E A->F  In this case even after removing two edges, there will be only one and one tree"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Such questions are expected from Microsoft only. I hate them."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"max flow min cut theorem"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This question is very ambiguous. Can someone clarify this question.?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15032898","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"23","title":"Write a function to reverse the word order of String. Do this in-place. \"This is a cat\" -> \"cat a is This\". Spaces between words may not be consistent.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"Algorithm:  1> Reverse the string 2> Reverse each word in the reversed string"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Had Answer this Algo long time Back .. Responding again.  1> Read each word and put into the stack. use recursion for efficiency. 2> Read the Stack till get empty."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"#include  \n#include  \n \nvoid reverse(char*, char*); \n \nint main() { \n    char str[] = \"The cat in the hat\"; \n    char *pHead, *pTail, *pEnd, *temp; \n     \n    //First reverse the whole string \n    pHead = pTail = str; \n    while(*pTail != '\\0') \n        ++pTail; \n    pEnd = pTail--; \n    reverse(pHead, pTail); \n     \n    //Reverse the (reversed) string word by word \n    temp = str; \n    while(temp < pEnd) { \n        pHead = pTail = temp; \n        while(*pTail != ' ' && *pTail != '\\0') \n            ++pTail; \n        temp = pTail--; \n        ++temp; \n        reverse(pHead, pTail); \n    } \n    printf(\"%s\\n\",str); \n     \n    return 0; \n} \n \n//Reverses the string provided the head & tail of the string \nvoid reverse(char *pHead, char *pTail) { \n    char ch; \n     \n    while(pTail >= pHead) { \n        ch = *pTail; \n        *pTail-- = *pHead; \n        *pHead++ = ch; \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"#include \n#include \n#include \nusing namespace std; \n \nchar str[80]; \n \nvoid rev(int l, int r) \n{ \n    char temp; \n    while(l"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"string str = \"This is a cat\";             string[] ch=str.Split(' ');              for (int i = ch.Length-1; i >= 0; i--) {                  Console.Write(ch[i]+' ');             }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"\"Spaces between words may not be consistent.\"   Evan: Can you advise how inconcistent the spaces might be in between words."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void Reverse(char* ptr1, char* ptr2) \n{ \n while(ptr1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Read the character by character in string ,store the index of the first letter, if the character is empty space then do the reverse word from the starting index to current position-1 finally read the string from last character to first character"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Read the character and put into the stack if a empty space occures pop up all the character from stack add to output string. if space comes add directly to out put string keep on doing till it gets end of the string. finally read the string from back words"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Read the string put it in a array print it backwards"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.io.BufferedReader; \nimport java.io.IOException; \nimport java.io.InputStreamReader; \n \npublic class StringReversal { \n \n public static void main(String arg[]) throws IOException { \n  BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); \n  System.out.print(\"Enter the string to reverse :\"); \n  String str = br.readLine(); \n  char c, temp[] = str.toCharArray(); \n  for (int i = 0; i < (str.length() / 2); i++) { \n   c = temp[i]; \n   temp[i] = temp[str.length() - 1 - i]; \n   temp[str.length() - 1 - i] = c; \n  } \n  System.out.print(\"Reversed string is : \" + String.valueOf(temp)); \n \n  String words[] = String.valueOf(temp).split(\" \"); \n  str = \"\"; \n \n  for (int i = 0; i < words.length; i++) { \n   // System.out.print(words[i]); \n   temp = words[i].toCharArray(); \n   int length = temp.length; \n   for (int j = 0; j < (length / 2); j++) { \n    c = temp[j]; \n    temp[j] = temp[length - 1 - j]; \n    temp[length - 1 - j] = c; \n   } \n   str += String.valueOf(temp)+\" \"; \n  } \n  System.out.println(\"Reversed word order is  : \" + str); \n \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n \n#define TRUE 1 \n#define FALSE 0 \n \nint main() \n{ \n    char inp[100]; \n    int flag1=FALSE,flag2=FALSE,i=0,j=0,k=0,len; \n    char c='\\0'; \n    printf(\"Enter the input string = \"); \n    gets(inp); \n    len = strlen(inp); \n    for(i=0;i<=len;i++) \n    { \n          if((inp[i] == ' ') || (inp[i] == '\\0')) \n          { \n                  if(flag1) \n                  { \n                         //reverse(inp,j,k); \n                         //printf(\"\\n%d\\t%d\\t%s\",j,k,inp+j); \n                         k--; //This is needed as for 'hello' k=5 but we need it to k=4; \n                         while(j"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void Main(string[] args) \n        { \n            string s = \"This is Test\"; \n            string[] str = s.Split(' '); \n            int t = str.Length;             \n \n            string[] strr = new string[t]; \n             \n            foreach (string st in str) \n            { \n                strr[t-1] = st;                 \n                 \n                t--;                 \n            } \n \n            foreach (string a in strr) \n            { \n                Console.WriteLine(a); \n            } \n             \n            Console.ReadLine(); \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nusing namespace std; \nint main() \n{ \n int i=0,j=0,k=-1; \n string s1=\"this is a cat\"; \n string s[20]; \n for(k=0;k=0) \n { \n  cout<<\" \"<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"its just a pseudo code  function(String str) {       while(str[i]!=NULL)       {              if(str[i]!=' ')                  push(str[i] )  ///in stack              else              {                    while(stack is not empty)                       pop and store in some string               }       }  while(stack is not empty)                       pop and store in some string  reverse the some string and print it.   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include void reverse(char *); void main() {  int i;  char *s=\"sur is a good boy\";  char *p;  reverse(s);  p=strtok(s,\" \");  while(p)  {   reverse(p);   printf(\"%s \",p);   p=strtok(NULL,\" \");  }   } void reverse(char *org) {  char *s,temp;  s=org+strlen(org)-1;  while(*org && org {   temp=*s;   *s=*org;   *org=temp;   org++;   *s--;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is one of the interview question I met before. The interviewer needs me to implement an algo with O(1) space complexity. I think my solution is O(1) now; Yet it seems the time complexity is O(N)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I write this in Java. Plz feel free to comment."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15033826","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"11","title":"design Malloc Function which user can call and get the allocation. For example, there is a Byte array of byte[1000] so if use call getAllocation(3) then we will assign 3 bytes to user. and again if another user call getAllocation(100) then we will assign again,","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"char BYTE[1000] = {}; \n \nchar * getAllocation(unsigned int reqMemory) \n{ \n static unsigned int memCtr = 0; \n \n if(memCtr + reqMemory > 999) \n  return NULL; \n \n memCtr += reqMemory; \n return &BYTE[memCtr-reqMemory]; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"refer K&R. It has given implementation, plus exercises would add real fire to the answer.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think best fit algorithm can be used for simulating memory management. Segments of free memory spaces can be kept track of through a BST and for every new memory allocation request, BST can be used to get the best fit available for that request."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"char BYTE[1000] = {};  char * getAllocation(unsigned int reqMemory) {  static unsigned int memCtr = 0;   if(memCtr + reqMemory > 999)   return NULL;   memCtr += reqMemory;  return &BYTE[memCtr-reqMemory]; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{ char byte[1000];   char* alloc(int siz) { static int ctr =0; if(siz > 999-ctr) return NULL; ctr=999-siz; return ctr-siz; }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Buddy system"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-5","title":"void * malloc(int length) \n{ \n      return new byte[length]; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15025810","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"22","title":"Given the two arrays with integers, return the common elements","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Well actually hashtable is not pratical...because the key space can be very large. The most general 2 ideas are: 1. sort and check 2. build a binary search tree for one of the array, and go through the other."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"solution 1 sort the two arrays A[],B[],compare  every elements Ai,Bj. i=j=0; if Ai==Bj ,then add to the result else if Aielse j++"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"We can do better then O(max(n log n,m log m))  Put all the elements from A in a HashMap (key =  element, value = 1) for each element in B if exists in the HashMap (this check is done in O(1)) then added to the returned structure.  Complexity : time :O(max(n,m))  ; space: O(min(n,m)). // we assume ^_^ that A.length < B.length."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Algo:  Step1 : Sort the first array.(m log m) Step2 : Then for each elements of second array, do a binary search on the first array, if found print the value.(n log m).  No extra space is required."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"import java.util.HashMap; \n \npublic class Q1 { \n \n public static void main(String arg[]) { \n  HashMap h = new HashMap(); \n  int a[] = { 2, 3, 6, 42, 6, 43, 2, 3 }; \n  int b[] = { 42, 5, 7, 3, 8, 34, 2, 2}; \n \n  h.put(2, 2); \n  h.put(3, 2); \n  h.put(6, 2); \n  h.put(42, 1); \n  h.put(43, 1); \n \n  for (int i = 0; i < a.length; i++) { \n   int temp = b[i]; \n   if (h.containsKey(temp)) { \n    if (h.get(temp) > 0) { \n     System.out.print(temp + \", \"); \n     int count = h.get(temp) - 1; \n     h.put(temp, count); \n    } \n   } \n  } \n \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{  1.merge both the arrays  2.sort 3.return duplicate items }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int[] first = new int[] { 1, 4, 3, 2, 6, 5, 16, 7 }; \nint[] second = new int[] { 8, 3, 5, 4, 2, 1 }; \n \nHashtable result = new Hashtable(); \nforeach (int i in first) \n{ \nresult[i] = 1; \n} \nforeach (int i in second) \n{ \nif (!result.ContainsKey(i)) \n{ \nresult.Remove(i); \n} \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think we need to ask interviewer how to handle duplicate common element? Then we could use different methods to solve it!"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15027788","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"23","title":"For a string with uneven number of white spaces, what is best method or algorithm to trim the white spaces between characters, except special characters like !or, Also the beginning and end should not contain any white space","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"whitespacecount=0; string= given string; Step1: Iterate thro the string by each and every character.             If( string[i]==' ')             {                  If (IsNotSplCharacter(string[i-1]))                       whitespacecount++;             }            else                  string[i-whitespacecount]= string[i];   Complexity is O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"#include  #include  #include   #define MAX_STRING 100 #define NEW_LINE1 printf(\"\\n\"); #define NEW_LINE2 printf(\"\\n\\n\"); #define STR_LEN(x) printf(\"\\n\\nstrlen == %d\", strlen(x));  void remove_whitespace(char *str1);  int main(int argc, char *argv[]) {       char *str1 = calloc(1, MAX_STRING);   char *str2 = calloc(1, MAX_STRING);      str1 = \"    abcd efgh ijkl mnop    \";    remove_whitespace(str1);   system(\"PAUSE\");    return 0; }  void remove_whitespace(char *str1) {    char *str1_local = calloc(1, MAX_STRING);       char *str2_local = calloc(1, MAX_STRING);          char *str2_final = calloc(1, MAX_STRING);          int i = 0;     strcpy(str1_local, str1);    int length = 0;     printf(\"\\nstr1_local = %d, %s\", str1_local, str1_local);    printf(\"\\nstr2_local = %d, %s\", str2_local, str2_local);    printf(\"\\nstr2_final = %d, %s\", str2_final, str2_final);    NEW_LINE2;     NEW_LINE2;         do {           str2_local = strchr(str1_local, 32);                       if(str2_local) {            NEW_LINE1;                     strncat(str2_final , str1_local, str2_local - str1_local);            printf(\"\\nstr1_local = %d, %s\", str1_local, str1_local);            printf(\"\\nstr2_local = %d, %s\", str2_local, str2_local);            printf(\"\\nstr2_final = %d, %s\", str2_final, str2_final);            NEW_LINE1;             str1_local = str2_local + 1;        }        else {                        strncat(str2_final , str1_local, strlen(str1_local));        }               length++;     } while (str2_local);                 NEW_LINE2;                puts(str2_final);      STR_LEN(str2_final);       NEW_LINE2;        free (str1_local);    free (str2_local);    free (str2_final); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is it necessary to do it in place? Why not read the whole string char by char and output to new variable if its non extra whitespace or valid character. O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"One way of solving is given below :  - for every character in the string, check if it is a redundant space - If it is, then keep a count of the redundant spaces encountered so far and shift the position of the current character left by \"count\" times  pseudo code :   function adjust_spaces(char s[]) {      redundant_spaces_count = 0;     for(int i=0;i    {         if(redundant_space(s[i]))             redundant_spaces_deleted++;         else             s[i-redundant_spaces_deleted] = s[i];     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about using a linked list with O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here it is in c# using Regex  {  Console.Write(Regex.Replace(\" test  man , this is not ! Where   to go   lamp \",@\"\\s+\", \" \").Trim()) }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void Replaces(char* str) \n{ \n int it =0; \n int in=0; \n bool iswhite = false; \n while( str[it] != '\\0') \n { \n  if( str[it] == ' ' ) \n   it++; \n  else \n   break; \n } \n while( str[it] != '\\0') \n { \n  if(( iswhite) && (str[it] == ' ')) \n  { \n   it++; \n  } \n  else \n  { \n   str[in] = str[it]; \n   if( str[it] == ' ') \n    iswhite = true; \n   else \n    iswhite = false; \n   it++; \n   in++; \n  } \n } \n if( iswhite) \n  str[--in] = '\\0'; \n else \n  str[in] = '\\0'; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What's the time complexity time of my code?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"trim()"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I think you can also use str.replaceAll(\"  \",\" \") // replace all double spaces with one space. Check if it starts or ends with a space , and delete it,  if so."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"use  String str2=str.trim() -to remove leading and trailling white spaces now String str3=str2.replaceAll(\"\\\\s+\",\" \")"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"in above reply to the question replaceAll replaces uneven number of white spaces with single white space in order to remove them completely use replaceAll(\"\\\\s+\",\"\")"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15031779","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"13","title":"Given a 2D array of size m X n, containing either 1 or 0. As we traverse through, where ever we encounter 0, we need to convert the whole corresponding row and column to 0, where the original value may or may not be 0. Now devise an algorithm to solve the problem minimizing the time and space complexity.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"1. First record the number of 0's in rows and columns by initializing  rows[array.length] and columns[array[0].length] 2. Now,  for(r=0; rfor(c=0; cif(array[r][c] == 0)  columns[c] = 1; rows[r] = 1; 3. Next step; for(int r=0; rfor(int c=0; cif(rows[r] == 1 || columns[c] == 1)  array[r][c] = 0;  Time-complexity: Linear O(mn); two times sweep of the entire 2d array Space-Complexity: Num of column + Num of rows - O(m+n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What do you mean by traverse? Because you can traverse matrix in different ways. For example if you traverse it from top-left corner to down right going row by row you can do this by looking for first 0. Ones you meet it that is it, just fill all columns right to it with 0 and all rows below it with 0. I mean  if A[i][j] == 0 then A[k][l] = 0 if k>=i || l >=j"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"R-tree"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Find the first ZERO element in the matrix, then when we find, the make that row and column to ZERO's, then choose either the row or column, then make the rest ZERO's since we have already made the ZERO's, but finding the first ZERO is the catch !.  What do you say ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n#include \n \n#define MAX_ROW 5 \n#define MAX_COL 6 \nvoid print_matrix(int matrix[MAX_COL][MAX_ROW]) \n{ \n int i=0,j=0; \n for (i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Pseudo:  1. let M be a bits array of size of m 2. let N be a bits array of size of n 3. traverse through all of the matrix' cells: 3.1 for each cell[i, j] that its value is 0 do  3.1.1 set M[i] <- 1 3.1.2 set N[j] <- 1 4. traverse array M: 4.1 for each M[i] equals 1 do 4.1.1 set col i on matrix to 0 5. traverse array N: 5.1 for each N[j] equals 1 do 5.1.1 set row j on matrix to 0  running time := n*m + n + m + n*m + m*n = O(m*n) memory cost := 2 additional arrays = m + n"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Suppose m is row and n is column, add all the elems of each row, if the sum is less than m( that is the row contains atleast one 0), store the row nums, same with columns. Then make all the elements of the stored rows and columns can be made 0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Time complexity O(m*n) Space complexity O(1)  The basic idea is to use space inside the matrix itself to mark whether to set a column/row to zero, thus avoiding extra space cost."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how about swapping the zero with the first element of row or first element of column, and then traversing again and marking the rows and columns to zero."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void Matrix0s(int[,] A, int n, int m) \n        { \n            List r = new List(); \n            List c = new List(); \n            for (int i = 0; i < n; i++) \n            { \n                for (int j = 0; j < m; j++) \n                { \n                    if (A[i,j] == 0) \n                    { \n                        if (!r.Contains(i)) \n                            r.Add(i); \n                        if (!c.Contains(j)) \n                            c.Add(j); \n                    } \n                } \n            } \n            for (int i = 0; i < r.Count(); i++) \n            { \n                for (int j = 0; j < m; j++) \n                    A[r[i], j] = 0; \n            } \n            for (int i = 0; i < c.Count(); i++) \n            { \n                for (int j = 0; j < n; j++) \n                    A[j,c[i]] = 0; \n            } \n        }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15025702","download_status":"DOWNLOAD_DONE","votes":"2","answersCount":"9","title":"Given pointer to the bytes array on size N that represents big integer \"a\" and 2-bytes integer \"b\" implement mod (%) operation for them: a % b","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"The above algorithm is a good idea and can be modified to be correct.  short mod(byte[] a, short b) {     int result = 0;          /* start from the left (the higher digits), get two bytes (so as to match b) each time      * to mod b. The result should be less than b. Then add the result with the next two      * bytes to mod b, and the result should less than b again. And repeat. If the a.size()       * is an odd number, there will be one byte left at last. Then we handle that one byte       * after the loop.       */     for (int i = 0; i < a.size()-1; i+=2) {         result = (result * 256*256 + a[i] * 256 + a[i+1]) % b;     }     if(a.size()%2==1) {         result = (result * 256 + a[a.size()-1]) % b;    }      return static_cast(result); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My Solution: I still use 93,143,913 => (5,141,67,105) 93143913 = 5*2^24+141*2^16+67*2^8+105*2^0  we calculate 93,143,913 % 20 start from right(because we could reuse 2^8%20):  105%20 = 5  2^0%20 = 1, so for 105*2^0, the remainder should be 5*1 = 5 67%20 = 7 2^8%20 = 16, so for 67*2^8, the remainder should be (7*16)%20 = 12 141%20 = 1 2^16%20 = 16, so for 141*2^16, the remainder should be (1*16)%20 = 16 5%20 = 5 2^24%20 = 16, so for 5*2^24, the remainder should be (5*16)%20 = 0  at last, (0+16+12+5)%20 = 13 It is equal with original number modulo 20;  Please verify it!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Big int is 123456 is represented as a[0]=6, a[1]=5...a[5]=1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"void Main() {  var bigInt = new int[] {1,2,3,4,5,6,7,8,9,1,1,1,2,1,3,1,4,1,5,1,6,1,7};  var smallInt = 121;  var previousMod = 0;  foreach (var i in bigInt)  {   previousMod = (previousMod * 10 + i) % smallInt;  }  previousMod.Dump(); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I think, in this problem \"a\" is very big integer and given as a byte array. For example 93,143,913 will be { 5, 141, 67, 105 } (msb is 0th byte). This way you can represent arbitrarily large integers as it happens in crypto. The solution will be take each byte and multiply with 2^8 and the previous mod and then take the mod with \"b\". Here is the code:"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15015729","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"0","title":"Let's say you have to make changes to 1000 API's. For example, currently developers need to put a .then() just to write something to the screen; we want to remove this in simple cases, but also enable it in cases where you really do want to write something only AFTER some other action has taken place. These 1000 API's are split among 200 teams, and you're a product manager for one of those teams.  How do you go about pushing for this change, so that eventually all of them will be changed? How long would it take? What is the deadline? What if one team simply says they're far too busy? And once the dev teams are done with the changes, what more is there to do? What should the testing team do?"}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14990384","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"14","title":"Design algo for insertElement, deleteElement and getRandomElement, expected complexity for all the operations will be less than O(n).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"For operations like insert and delete an element we can use HashMap where T is the element that we need to insert or delete.Along with this we also need to use a random access structure such as an ArrayList.Now do we make it random ? because in the HashMap we store the location of the element in the ArrayList.Have a class variable such as count to keep track of the number of elements added. \n \nPseudo code: \n \nPrivate int index=0; \n \nvoid insertElement( Object element)  --Complexity"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"We can Achieve this, by using BST (Binary Search Tree)  search for Binary_search_tree Wiki page.  It will provide the following Time Complexity  Time complexity in big O notation  Average  Worst case Space  O(n)  O(n) Search  O(log n)  O(n) Insert  O(log n)  O(n) Delete  O(log n)  O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Binary Search tree can be used here as the Insert and Delete can be achieved in O(log n).For get random element,we could have a extra field in the tree size and populate the size of left+right childs + 1. So getting Kth smallest element can be achieved in O(log n).  Code for finding Kth element in log(n):"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hash table plus array will work. the hash is keyed on the number and contains the index of the array where the number is stored as its value."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"All three operations (insert, delete and getRandom) can be done in constant time O(1), if the order of the elements is irrelevant Data structure: Array, and HashTable which holds the value as key and index as value Insert (X):  - push X as the last element in the array, update hashTable - increment array size Delete (X):  - get index of X - swap it with last element in the array, say Y - update index of Y in hash table to index(X) - delete X from array and hash table - decrement array size getRandom: generate a random index less than array size, and return value in that index"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-7","title":"Tree.. Tree ... Make a Heap........ Very Easy.."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15013746","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"15","title":"I have one bag of bolts and another bag of nuts, need to find biggest Bolt. Condition is must not compare both bolts or both nuts. only comparison between bolt and nut allowed.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Here is the approach:  1) Take a Bolt B. 2) Take a Nut N. 3) while(more nuts && B >= N) {             Throw away this nut & take next Nut N;      }      if(no more nuts)          Print B. 4) while(N > B){            Throw away this Bolt and get next Bolt B;      }     go to Step 3.  Complexity: O(B + N). Assumption: There is only one Bolt which is > all nuts."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"-> Problem is we have two unsorted array, both array contains same and equal number of elements . -> We have to find the maximum element from array 1st.  -> Here condition is you can not do any comparision within same array.  Algorithm:  Step 1: Pick a element from array1.  Step 2: And compare it with element of array2 till we get the larger or equal number.  Step 3: If found larger element in step 2 then start comparision with array1 till get equal or larger number and repeat step2.         else return the equal number found in step 2."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"0.1) Assumption: We have empty spare bags to use (or memory) 0.2) Assumption: No two bolts should be bigger than biggest nut 0.3) Extra Assumption (not MUST): No two nuts should be bigger than biggest bolt 1) We can not sort bags as we can't compare the two bolts and two nuts 2) But there is a math law here: Nut1 < Bolt1 and Bolt1 < Nut2  implies Nut1 < Nut2.  We can divide any bag into two portions with a reference of a other bag item.   2.1) Have two spare bags, namely lowBag and highBag 3) Take a nut (randomly), for every bolt 3.1) compare the bolt with nut.  If bolt < nut, put it in lowBag; otherwise put it in high bag 3.2) Now we have emptied the original bolt bag and have two new bolt bags 3.3) If highBag has at least one item, throw away the lowBag items 3.4) If highBag is empty, nut is greater than all bolts - throw away the nut  3.5) Now we have only one bag 4) Repeat step (3) and sub-steps with a new nut 5) After finishing all nuts with steps (3) and (4), we will have highBag with few items 5.1) With assumption (0.1) - highBag should contain only one item (biggest bolt) 5.2) With assumption (0.2) - the first nut to be thrown away in step (3.4) is biggest nut  If no. of bolts is b and no. of nuts is n - The time complexity is O(n * b * log(b))  Thanks, Laxmi"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@havefun.. its a neat solution.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bolt getBigBolt(Bolts, Nuts) { \ntype op = NUT; \nif (bold.empty()) \n  return null; \nbolt = Bolts.get(); //get a bolt from the bag; \nnut = null; \nwhile(!Nuts.empty() || !Bolts.empty())  \n{ \n  if(op == NUT)  \n { \n   if (Nuts.empty()) break; \n   tempNut = Nuts.get(); \n   if (tempNut >= bolt) //continue until bigger nut than the current bold is found \n    { \n      nut = tempNut; \n      op = BOLT; // switch picking bolt \n     } \n  } \n  else // op == BOLT \n   { \n       if (Bolts.empty() break; \n       tempBolt = Bolts.get(); \n       if(tempBolt >= nut)   \n       { \n          bolt = tempBolt; \n          op = NUT; // switch picking nut \n        } \n   } \n } \n return bolt \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@havefun's solution is correct I think."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14995830","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"22","title":"Given the string of parentheses only, write the function to check if they are balanced. ((())) is balanced, )( is not.  Follow up: Now the string also contains curly and square braces. You already have boolean functions, isOpenBrace() , isCloseBrace() and bracesMatch(char brace1, char brace2) as required. How do you check if braces are balanced?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"9","title":"use a stack and push left brace (3 types ) whenever u encounter on to stack. for every right braces you encounter check if stack is empty or not matching the top of the stack , if so return false else pop the top.  continue. like this till you traverse the whole string.  Afterwards, just check if stack is empty or not and accordingly return true or false."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Add a 1 for startBracket and -1 for endBracket. As soon as number goes negative, you can declare string as unbalanced. One more condition is that at-last, sum should be 0."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Javascript code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int validate(char *str) {   char stack[100];   int top = 0;   while(*str != '\\0')   {     if(*str == '(' || *str == '{' || *str == '[')     {         stack[top++] = *str++;  //pushing the opening braces into the stack     }    else if(*str == ')' || *str == '}' || *str == ']')     {        if(top > 0)        {           if(match(stack[--top],*str) == 1)            {                str++;            }            else            {               printf(\"Braces mismatch $ %c %c $ top %d\\n\",*str,stack[++top],top);               return 0;            }        }        else        {            printf(\"Lesser closing braces: %c top %d\\n\",*str,top);            return 0;        }    }    else    {        printf(\"Invalid braces\\n\");        return 0;    }  }  if(top == 0)    return 1;  else  {   printf(\"Openings braces extra (top %d)\\n\",top);   return 0;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use 3 counter variables, sb, rb and cd for square braces, round braces and curly braces respectively; increment each when its an open brace and decrement when a close brace is encountered. At the end of string all counters have to be zero and reject a string if one of the counters becomes negative!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The thought here is to push the left bracket into stack and whenever we encounter a right bracket, pop the entry from stack and compare against the current one.  Time Complexity: O(n) Auxiliary Space: O(n) for stack"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"If there are more than 1 type of braces: Keep putting them like numbers as  1 => (  2=> { 3=> [ and -1,-2,-3 as their respective closing braces.  Keep summing up the stack while inserting an element. Keep checking that sum does not turn negative. -ve number means that its mismatch. Also, when you receive a closeBrace, pop one element from stack and sum that with new closeBrace, sum should be 0."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"0) Assume: we have const brace variables such as SQURE_BRACE, ROUND_BRACE, CURLY_BRACE 1) For every type of brace, have separate weightCounter 1.1) For curly braces \"{}\", curlyBraceWeight 1.2) For square braces \"[]\", squareBraceWeight 1.3) For round braces \"()\" - roundBracesWeight 2) Initialize all brace weights to zero 3) For every brace in the string 3.1) If it is left brace, set modVal to '+1\"; if it is right, set modVal to '-1' 3.2) Check the brace type (using the const brace vars), and add modVal to that brace type's weight 3.3) If this brace type's weight hits negative value - quit the loop and report 'unbalanced' 4) After finishing the string, if any weight is not zero - report 'unbalanced' 5) Otherwise, report 'balanced'.  Assume the following Extra Library API:   - MaxBraceTypes - Returns the max no. of brace types - GetBraceType() - Returns an integer less than MaxBraceTypes (i.e. type ids are continuous)  We could: - Have an array of MaxBraceTypes size (inited to zero) - Step (3.2) would be modifying the weight at that index in array of weights  Thanks, Laxmi"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14994669","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"15","title":"Tree with black and white nodes is given. Find a longest path of white nodes in the given tree.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"This is very similar to the tree diameter problem: at any node the longest path may belong to a subtree or go through the node itself if it's white. Just track recursively the longest path of each subtree and the length of white-path ending at current node:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This code will do find the path in one scan of the tree: Please correct me if I have got something wrong."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int whitenodes(node root, int max) { if(root == null) return 0; if(root.value == white) { int newmax =  max(1+ whitenodes(root.right, max), 1+whitenodes(root.left,max)); if(newmax>max) max = newmax; } else newmax = 0; return newmax; }  answer will be in max (not newmax)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int search(node,flag) {   val=val1=val2=0;   if(node.color=Black )  {    if(node->left != NULL)     val1=search(node->left,0);   if(node->right != NULL)    val2=search(node->right,0);   return max(val1,val2);   }  else  {    val=1;    if(node->left != NULL)   {     val+=search(node->left,1);     val1=search(node->left,0);    }   if(node->right != NULL)   {      val+=search(node->right,1);      val2=search(node->right,0);     }   if(flag=1)    {       return max(val1,val2);     }   else return max(val,val1,val2);   } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the final value in global variable max is the answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int Longesthpath(root, MaxPathInSubtree, MaxPathEndingAtNode)         {              MaxPathInSubtree = 0;              MaxPathEndingAtNode = 0;                if(root == null)              {                  return 0;              }                            LongethPath(root->left, MaxPathInSubtree1, MaxPathEndingAtNode1);              LongethPath(root->left, MaxPathInSubtree2, MaxPathEndingAtNode2);                if(x is white)              {                  MaxPathEndingAtNode = 1 + max( MaxPathEndingAtNode1, MaxPathEndingAtNode2);              }              else              {                  MaxPathEndingAtNode = 0;              }                MaxPathInSubtree = max (MaxPathEndingAtNode, MaxPathInSubtree1, MaxPathInSubtree2);                if(max_so_far < MaxPathInSubtree)                  max_so_far = MaxPathInSubtree;          }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Modification of well known graph problem of finding longest path in a directed acyclic graph (DAG):  - topologically sort the tree using dfs and throw away all black nodes  - perform linear backwards scan on the resulting list calculating max path of white nodes starting at particular vertex. Two nodes are considered adjacent in the list if they are adjacent in the original tree"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14996804","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"0","title":"Implement your own API and library for a synchronization OS problem.Write your own semaphore. Eg: Capacity of TAM is 5 .. Queue of people outside is 100. Synchronization reqd."}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14952616","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"66","title":"Given two singly linked list, find if they are intersecting. Do this in single iteration. Also find the intersecting node in O(n) time and O(1) space. By intersection I mean intersection by reference not by value","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"14","title":"here we have to parts ... 1)Given two singly linked list, find if they are intersecting. Do this in single iteration.      a) traverse list1 and find the last element      b) traverse list2 and find the last element      c) check if last element of list1 == last element of list2 , if equal intersecting else not    here we have parsed the list only once :-)  2) Also find the intersecting node in O(n) time and O(1) space      here they have asked to do it in O(1) space so we need to use only one variable :-)   a) create a variable(int) diff=0   b) parse list1 and increment diff for each node   c) parse list2 and decrement diff for each node   d)if diff is >  0 list1 is bigger so push the pointer of list1 by diff times      else list2 is bigger so push the pointer of list2 by mod(diff) times   e)Now check if both the pointers are equal till we reach end"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Count size of List A, B  If one list is larger than the other, move the root of the larger list until the remaining nodes are the same.  Now, while each list.next != null, compare RootA.Next with RootB.Next. If they are equal, return true, else move RootA = RootA.Next, RootB = RootB.Next"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"findIntersectoin(node *p, node *q) {  int d1=0,d2=0;  node* x=p;  while(x)  {   d1++;   x=x.next;  }  x=q;  while(x)  {   d2++;   x=x.next;  }  int d;  if(d1>d2)  {    d=d1-d2;   while(d>0)    p=p.next;     }  else  {   d=d2-d1;   while(d>0)    q=q.next;  }  while(p && q)  {   if(p.data==q.data)    return p;   p=p.next;   q=q.next;  }  return null; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hi,  I assume that it is a single linked list. Now If the two list is intersecting then they will have the single tail. so just go to boths tail and compare it.  How to find the point of interesection.  1) Find the length of both the list. let us say M and N. 2) now let us say M is bigger one. then find out the difference. d=M-N. 3) mow move d pointer on the bigger list.    now onward both this list has same length and they are going to merge also. So just move one node on both the list and compare nodes value. It will give u the node u are looking for.  thanks, DD>"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just to update, keep on moving one node at a time and keep on comparing it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hey can two linked lists intersect? Two nodes wont have the same memory rite??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"THANKX :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Destructive solution:  [1] Scan one list, say listA and point every node until end, listA(1..n)->next to a special node called nodeIntersect.  [2] Now scan listB and see if currentNode->next==nodeIntersect. If so, currentNode of listB is the intersection point  Much less destrcutive, requiring additional space:  [1] Scan listA and add the nodes (the pointer) to a hashtable [2] Scab listB and if any of the pointer is same in hashtable, that pointer (or the node) is the point of intersection  There must be a better solution though. I am not aware of one right now."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"just move till end on both the lists. compare the addresses of the last node. O(m+n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why is everyone assumming it's Y-shaped ? The question asks for intersection, not merging. And in that case, it could be X-shaped too."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"two link list A and B..if we can modify link list then it will become quite easy task add flag value to each node and when we traverse link list A then make flag =1 and second time when we traverse link list B if we already find flag =1 then that will be interaction point  correct me if wrong"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Lets call the  two lists a and b.Reverse the two lists.Continue iterating through list until a!=b.If the two lists are entirely different and they dont intersect then the return value would be false.  while(a==b){   commonNode = a;   a=a->next;   b=b->next;   count++; }  if(a!=b && count==0){ return false; }  else{   cout<<\"List intersects at \"<data;   return true; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node *temp, *prev; temp = list_a.head; while(temp != NULL) {  stack_a.push(temp);  temp = temp->next; } temp = list_b.head; while(temp != NULL) {  stack_b.push(temp)  temp = temp->next; } prev = NULL; temp = stack_a.pop(); while(temp == stack_b.pop()) {  prev = temp; } return(prev);  Pls correct me if I'm wrong."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"please factor in the presence of cycles too which could throw codes into infinite loops"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Say the input lists are A and B and 6 is the intersection node. Then the list looks like as below.  A==>  1->2->3->4->5->6->7->8->9->10->NULL B==> 15->13->12->11->6->7->8->9->10->NULL  Now if you will reverse the list B then the whole list architecture will looks like as below  A==>  1-->2-->3-->4-->5-->6<--7<--8<--9<--10 <==B         NULL<--15<--13<--12<--11<--6<--7<--8<--9<--10 <==B  Now if you will try to travers list A you will get something like below  A_New==> 1-->2-->3-->4-->5-->6-->11-->12-->13-->15-->NULL  So in this A_New list, if the last node will be the same of the first node of original B list (node value 15) then we can say that there is a intersection in between list A and list B.  ================================================================================  How to find the intersection node ?  say the length of list A is x, list B is y and list A_New is z. And say the length of common part of list A and B is k. (i.e k is the length from intersection node to last node).  Now we can say,  (x-k) + (y-k) = z or, k = (x+y-z)/2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Make two stacks, one while traversing each list. Then, compare the top two elements. If they're not the same, the lists do not intersect. If they are, keep popping off both stacks until they're no longer the same. The last node that was the same on both stacks is the intersecting node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* I m returning NULL for no common node and  next  node of *head1 or *head2  if common */ struct node  findcommon_node(struct node *head1,struct node *head2) {  if(*head1==NUL L&& *head2==NULL)  return NULL;  while(*head1!=NULL && *head2!=NULL)  {   if(*head1->next  != *head2->next)   {    Head1=head1->next;    Head2=head2->next; } elseif(*head1->next !=NULL  &&  *head2->next !=NULL) return *head1->next ; return NULL; } return NULL; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"disregard previous one"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If you want to do in a single scan you need to use stack. As you know 2 stack, you can use reccurssion [ correct me if I am worng ]. Following is the C++ version of the algo : Node* intersectionPoint( Node* L1, Node* L2) {      if( (L1 == NULL) || ( L2 == NULL))                return NULL;         Stack* stack1 = new Stack;      Stack* stack2 = new Stack;      while( (L1 != NULL) || (L2 != NULL) )   {   if( L1 != NULL )   {    stack1->push(L1);    L1 = L1->next;   }   if( L2 != NULL )   {       stack2->push(L2);    L2 = L2->next;   }      }   Node* node1, node2, prev = NULL;   while( !stack1->empty() && !stack2->empty())   {   node1 = stack1->pop();   node2 = stack2->pop();      if( node1 == node2 )   {    prev = node1; // you can keep node2 also   }   else    return prev;        }  return prev; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) To find if the lists intersects scan each one till last element. If last element of list1 equals last element of list2 then they intersect. Solution involves one scan of each list.  2) To find the intersection in O(n) and O(1) I would do the following: a) Count number of elements in each list. This can be done in O(n1+n2).  b) Traverse list#1 and while doing so - reverse it, i.e. each node now points to the previous node instead of next node. This can be done in O(n1). c) Traverse list #2. What will happen is that once it will reach the intersection it will not \"continue\" to the shared nodes but will \" go back\" to the beginning of list #1. This can be done in O(n1+n2). Count the number of elements encountered in this scan. Refer to it as n2*  Suppose list #1 has 100 independent nodes and 20 shared nodes. and suppose list #2 has 5 independent nodes and 20 shared nodes.  The values of n1, n2 and n2* in this case will be: n1 = 120 [ = 100 + 20] n2 = 25 [ = 5 + 20 ] n2' = 5 (the independent nodes) + 1 (the intersection) + 100 (the independent nodes of list 1)  What we're looking for is the number of shared nodes. We'll get this by calculating: (n1 + n2 - n2* -1) / 2 =  ((20 + 100) + (5 + 20) - (5 + 100 + 1) - 1) / 2 = (20 + 20) / 2 = 20  All we have to do now is to start again from the last node and go back 20 nodes. This will be the intersecting node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I hope you asked if the lists can be circular."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the question is not clear. Intersection does not mean inclusion. According to the question it does not have to be in \"Y\" shape it can be \">===<\" shape. E.g. list1 = [1,2,3,4] and list2 = [0,5,2,3,6,7] so [2,3] is the intersected part and neither they end with the same node nor they start with the diff. And in this case no one can solve the problem with O(n) time and O(1) space complexity. You need to give more constraints."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Count the number of elements in two lists. Take the difference of count. Traverse in longer list till the difference count. Start traversing both lists & check for common address"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int main() {      set < char >  set0;      cin >> s ;     cin >> t ;      cout << s << \" \" << t << endl;          for (int i=0; i        set0.insert(s[i]);     }     for (i=0; i        if (set0.find(t[i]) != set0.end())         {             cout << t[i] << endl;         }     }        return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if ( (t1->next == NULL ) || (t2->next == NULL ) )    return false;  while (t1->next != t2->next ) {    t1 = t1->next      t2 = t2->next } if ( (t1->next == NULL ) && (t2->next == NULL ) )    return false; else    return true"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If two singly linked lists are intersecting, the last nodes have to be the same. Just check the last nodes of both lists, you are done!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if(head1 == NULL || head2 == NULL) \n return NULL; \n \nwhile(true) \n{ \n if(head1 == head2) \n  return head1; \n  \n //reached end of both list \n if(head1->next == NULL && head2->next == NULL) \n  return NULL; \n   \n if(head1->next != NULL) \n  head1 = head1->next; \n  \n if(head2->next != NULL) \n  head2 = head2->next; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You could temporarily make one list a circular list and then do cycle detection on the other using either the tortoise and hare or Brent's algorithm. I don't see how it can be done in one iteration with constant space, unless each node already has e.g. a \"visited\" property but that is neither mentioned nor standard."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Make first list circular by connecting last->next = first, also remember first and last node and also remember total nodes in first list. \n2. Now iterate through second list and at iteration check whether last and first are matched. If at any point true then lists have an intersection point. Now this solves the problem in single iteration. \n3. Now problem is finding loop start point in second list. This is traditinal problem. \n4. After that remove loop from first list."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"boolean intersect(Node head1 , Node head2){ \n Node current1 = head1; \n Node current2 = head2; \n while (current1.next != null) \n  current1 = current1.next; \n while (current2.next != null) \n  current2 = current2.next; \n return (current1 == current2); \n} \n \nNode intersect(Node head1 , Node head2){ \n Node current1 = head1; \n Node current2 = head2; \n int d1 , d2; \n while (current1 != null){ \n  current1 = current1.next; \n  d1++;  \n } \n while (current2 != null){ \n  current2 = current2.next; \n  d2++; \n } \n current2 = head2; \n current1 = head1; \n while (d2 > d1){ \n  current2 = current2.next; \n  d2--; \n } \n while (d1 > d2){ \n  current1 = current1.next; \n  d1--; \n } \n while (current1 != null && current2 != null && current1 != current2){ \n  current1 = current1.next; \n  current2 = current2.next; \n } \n return current1; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{{ bool check(node *head, node *head1) { if(head == NULL && head1==NULL) return false; else if(head == NULL || head1==NULL) return false; else {  while(head->next !=head1->next)     {     if(head->next ==NULL || head1->next==NULL) return false;         else { head=head->next;                     head1=head1->next;                 }     } return true; } }  }}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14991213","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"7","title":"Implement queue using stacks.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Queue can be implemented using two stacks, but either Enqueue or Dequeue is expensive  Steps: 1. Create stacks s1 and s2 2. Enqueue operation - push data into s1 then pop all items from s1 and push it into s2 3. Dequeue operation - pop from s2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Stack; \n \n \npublic class QueueByStacks { \n Stack master; \n Stack slave; \n  \n  \n public QueueByStacks() { \n  super(); \n  master = new Stack(); \n  slave = new Stack(); \n } \n \n public void enque(int element){ \n  master.add(element); \n } \n  \n public Integer deque(){ \n  if(slave.isEmpty()){ \n   while(!master.isEmpty()){ \n    slave.add(master.pop()); \n   } \n  }else{ \n   return slave.pop(); \n  } \n  if(slave.isEmpty()){ \n   return null; \n  }else{ \n   return slave.pop(); \n  } \n } \n  \n public static void main(String[] args) { \n  QueueByStacks queue = new QueueByStacks(); \n  queue.enque(3); \n  queue.enque(4); \n  System.out.println(queue.deque()); \n  queue.enque(5); \n  System.out.println(queue.deque()); \n  System.out.println(queue.deque()); \n  System.out.println(queue.deque()); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"test"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"test"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=15011735","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"8","title":"Delete the nth last element from a singly linked list. Don't count number of nodes initially.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"1. Have two pointers ptr1 and ptr2 pointing to head of linked list 2. Traverse one pointer say ptr2 to distance n from head 3. Now, traverse both 4. When ptr2 reaches the tail, ptr1 is at distance \"n\" from the tail of linked list  Need to do validation like  1. null check,  2. n might be greater than the length of linked list, 3. loop check and etc.,"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void deleteNthfromLast(struct node **p) \n{ \n     struct node *start,*t1,*temp; \n     int n; \n     start = *p; \n     printf(\"Enter the nth element from end to be deleted = \"); \n     scanf(\"%d\",&n); \n     while(n && start) // \n     { \n            start = start->next; \n            n--; \n     }                 \n      \n     if(!start)  //if the input provided is less than the linklist size \n     { \n               printf(\"\\nWrong input provided\"); \n               return; \n     }                \n      \n     if(!start->next) //frist node to be deleted \n     { \n              temp = *p; \n              *p = (*p)->next; \n              free(temp); \n              return; \n     }               \n     start = start->next; //t1 should point to one node behind the actual node to delete \n     t1 = *p; \n      \n     while(start->next) \n     { \n           start = start->next; \n           t1 = t1->next; \n     } \n     temp = t1->next; \n     t1->next = t1->next->next; \n     free(temp); \n     return; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nusing namespace std; \n \nstruct node \n{ \n    int k; \n    node *next; \n}; \nnode *HEAD = NULL; \n \nnode* create(int v) \n{ \n    node *temp = new node; \n    temp->k = v; \n    temp->next = NULL; \n    return temp; \n} \n \nvoid insert(node *n) \n{ \n    if(HEAD == NULL) \n        HEAD = n; \n    else \n    { \n        node *m = HEAD; \n        while(m->next != NULL) \n        { \n            m = m->next; \n        } \n        m->next = n; \n    } \n} \n \nvoid show() \n{ \n    node *m = HEAD; \n    while(m != NULL) \n    { \n        cout<k<<\"->\"; \n        m = m->next; \n    } \n    cout<<\"NULL\"; \n} \n \nvoid delete_Nth(int v) \n{ \n    node *m = HEAD; \n    node *prev = HEAD; \n    bool continu = true; \n    while(continu && m!= NULL) \n    { \n        int i; \n        node *n = m; \n        for(i = 0; i < v && n != NULL ;) \n        { \n            i++; \n            n = n->next; \n        } \n \n        if((i == v) && (n == NULL)) \n        { \n            if(m == HEAD) \n                HEAD = m->next; \n            else \n                prev->next = m->next; \n \n            delete m; \n            continu = false; \n        } \n        else \n        { \n            prev = m; \n            m = m->next; \n        } \n    } \n    show(); \n} \n \nint main() \n{ \n    char ch = 'y'; \n    int v; \n    do \n    { \n        cout<<\"Enter new key : \"; \n            cin>>v; \n        insert(create(v)); \n        cout<<\"Enter more (y/n) ? : \"; \n        cin>>ch; \n    }while(ch == 'y'); \n \n    cout<<\"\\n\\nEnter the last nth node number to delete : \"; \n    cin>>v; \n    delete_Nth(v); \n    return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node* DeleteNthLast(Node* head, int n) \n{ \n Node* temp = head; \n Node* t = head; \n int m = 0; \n if( head== NULL ) \n  return head; \n while( temp != NULL ) \n { \n  temp = temp->next; \n  if( m >= n+1 ) \n   t = t->next; \n  m++; \n } \n if( m == n) \n  return head; \n \n temp = t->next; \n t->next = t->next->next; \n delete(temp); \n return head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nusing namespace std; \n \ntypedef struct node{ \n int data; \n struct node* next; \n}* Node; \n \nNode createSLL(const int& n){ \n if(n <= 0) \n  return NULL; \n  \n Node head = (Node) malloc(sizeof(struct node)); \n head->data = 1; \n head->next = NULL; \n  \n Node tempHead = head; \n for(int i = 2; i <= n; i++){ \n  Node tempNode = (Node) malloc(sizeof(struct node)); \n  tempNode->data = i; \n  tempNode->next = NULL; \n  tempHead->next = tempNode; \n  tempHead = tempNode; \n } \n return head; \n} \n \nvoid printSLL(Node head){ \n Node tempHead = head; \n while(tempHead){ \n  cout << tempHead->data << \" \"; \n  tempHead = tempHead->next; \n } \n cout << endl; \n return; \n} \n \nbool deleteNthElement(Node& head, const int& n){ \n if(head == NULL || n <= 0) \n  return false; \n  \n Node tempHead = head; \n int count = 0; \n Node p, q = tempHead; \n while(q != NULL && count++ < n) \n  q = q->next; \n \n if(count == n+1){ \n  p = tempHead; \n  while(q->next != NULL){ \n   p = p->next; \n   q = q->next; \n  } \n  p->next = p->next->next; \n  return true; \n }else if(count == n){ \n  head = head->next; \n  return true; \n }else{ \n  return false; \n } \n} \n \nint main(int argc, char* args[]){ \n Node head = createSLL(8); \n printSLL(head); \n  \n if(deleteNthElement(head, 8)){ \n  cout << \"delete success...\" << endl; \n  printSLL(head); \n }else{ \n  cout << \"fail to delete node...\" << endl; \n } \n return 0;"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14990334","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"8","title":"Implement a bus reservation system asume bus' seats are as follows  HHHHHH  HHHHHH  HHHHHH   . . . . . . . . you can assume 10 rows in bus.  Now if user enters 4 as required seat no then the prefrence order would be 4 3,1 2,2 2,1,1 1,1,1,1 and the function should return the seat number.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"We can convert this to a bin packing problem which can be solved using a Max Winner tree.  Complexity is O(log n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Hi, Can you please explain more about the question like, what do the numbers 4, (3,1) , (2,2) indicate?  Thanks in advance"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/*  * BusSeat.cpp  *  *  Created on: Dec 10, 2012  *      Author: Kevin Li  */   #include  #include  using namespace std; //This is the available seats in each row int seatRow[10]={3,1,2,2,1,1,2,1,2,1}; bool flag=false; //check if there is enough seat n for the request bool seatsAvailable(int n) {  for(int i =0; i< 10; i++)  {   if(seatRow[i]>=n)   {    seatRow[i]-=n;    return true;   }  }  return false; }  int getSeat(int total,int n) {  //check if request seat number available  if(seatsAvailable(n))  {   cout<<\"get seat number\"<<  if(total>n)   {    //if there is still more seat needed, search them    getSeat(total-n,total-n);   }   return 0;  }  else  {   int seat =getSeat(total,n-1);  }  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"naga-programming-concepts.blogspot.in/2012/12/bus-reseravation-httpwwwcareercupcomque.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This should work,although doing lot more than required."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14990323","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"54","title":"Given An Array with N integer with values ranging from 1 to N. there is only one duplicate in the Array. Find out Duplicate value. i.e.  A = { 10,6,3,4,7,5,2,4,9,1}  values from 1 to 10. in this example, Duplicate element is 4.  N could be quite large.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"//The important advantage of this algo is that the \"array is restored back to its original\" although it is modified.   //It also places the elements where it belongs i.e initial sublist is sorted.   //Run Time Complexity: 0(n) //Space Somplexity: 0(1)   //The important advantage of this algo is that the \"array is restored back to its original\" although it is modified.    //It also places the elements where it belongs i.e initial sublist is sorted.    //It also handles 0 case    #include     void swap(int *p,int *q) {      int temp;      temp=*p;      *p=*q;      *q=temp; }       void printRepeating(int arr[], int size) {    int i,j;       for(i=0;i       while(arr[i]!=i)           if(arr[i]!=arr[arr[i]])                swap(&arr[i],&arr[arr[i]]);           else                 break;     //Initial sublist is sorted     for(i=0;i       if(i==size-1)     {         printf(\"There are no repeating elements\\n\");         return;     }     else         printf(\"The repeating elements are: \");                      //Printing duplicates     for(i=i+1;i    {        if(arr[i]!=i && arr[arr[i]]>=0 && arr[i]==arr[arr[i]])        {           printf(\"%d \",arr[i]);           arr[arr[i]]=-1;        }     }     //Restoring to oirginal     for(i=0;i<=j;i++)        if(arr[i] == -1) arr[i]=i; }                                           void printArray(int a[],int size) {      int i;      for(i=0;i        printf(\"%d \",a[i]);      printf(\"\\n\"); }            int main() {     int arr[] = {1, 2, 3, 1, 3, 0, 6};     int arr_size = sizeof(arr)/sizeof(arr[0]);     printRepeating(arr, arr_size);     printf(\"\\nIt also places the elements where it belongs i.e initial sublist is sorted\\n\");     printArray(arr,arr_size);        getchar();     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"# An algorithm for solving the following (classic) hard interview problem: # # \"You are given an array of integers of length n, where each element ranges #  from 0 to n - 2, inclusive.  Prove that at least one  duplicate element must #  exist, and give an O(n)-time, O(1)-space algorithm for finding some #  duplicated element.  You must not modify the array elements during this  #  process.\" # # This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve # and I have only met one person (Keith Amling) who could solve it in less time # than this. # # The first part of this problem - proving that at least one duplicate element # must exist - is a straightforward application of the pigeonhole principle. # If the values range from 0 to n - 2, inclusive, then there are only n - 1 # different values.  If we have an array of n elements, one must necessarily be # duplicated. # # The second part of this problem - finding the duplicated element subject to # the given constraints - is much harder.  To solve this, we're going to need a # series of nonobvious insights that transform the problem into an instance of # something entirely different. # # The main trick we need to use to solve this problem is to notice that because # we have an array of n elements ranging from 0 to n - 2, we can think of the # array as defining a function f from the set {0, 1, ..., n - 1} onto itself. # This function is defined by f(i) = A[i].  Given this setup, a duplicated # value corresponds to a pair of indices i != j such that f(i) = f(j).  Our # challenge, therefore, is to find this pair (i, j).  Once we have it, we can # easily find the duplicated value by just picking f(i) = A[i]. # # But how are we to find this repeated value?  It turns out that this is a # well-studied problem in computer science called cycle detection.  The general # form of the problem is as follows.  We are given a function f.  Define the # sequence x_i as # #    x_0     = k       (for some k) #    x_1     = f(x_0) #    x_2     = f(f(x_0)) #    ... #    x_{n+1} = f(x_n) # # Assuming that f maps from a domain into itself, this function will have one # of three forms.  First, if the domain is infinite, then the sequence could be # infinitely long and nonrepeating.  For example, the function f(n) = n + 1 on # the integers has this property - no number is ever duplicated.  Second, the # sequence could be a closed loop, which means that there is some i so that # x_0 = x_i.  In this case, the sequence cycles through some fixed set of # values indefinitely.  Finally, the sequence could be \"rho-shaped.\"  In this # case, the sequence looks something like this: # #     x_0 -> x_1 -> ... x_k -> x_{k+1} ... -> x_{k+j} #                        ^                       | #                        |                       | #                        +-----------------------+ # # That is, the sequence begins with a chain of elements that enters a cycle, # then cycles around indefinitely.  We'll denote the first element of the cycle # that is reached in the sequence the \"entry\" of the cycle. # # For our particular problem of finding a duplicated element in the array, # consider the sequence formed by starting at position n - 1 and then # repeatedly applying f.  That is, we start at the last position in the array, # then go to the indicated index, repeating this process.  My claim is that # this sequence is rho-shaped.  To see this, note that it must contains a cycle # because the array is finite and after visiting n elements, we necessarily # must visit some element twice.  This is true no matter where we start off in # the array.  Moreover, note that since the array elements range from 0 to # n - 2 inclusive, there is no array index that contains n - 1 as a value. # Consequently, when we leave index n - 1 after applying the function f one # time, we can never get back there.  This means that n - 1 can't be part of a # cycle, but if we follow indices starting there we must eventually hit some # other node twice.  The concatenation of the chain starting at n - 1 with the # cycle it hits must be rho-shaped. # # Moreover, think about the node we encounter that starts at the entry of the # cycle.  Since this node is at the entry of the cycle, there must be two # inputs to the function f that both result in that index being generated.  For # this to be possible, it must be that there are indices i != j with # f(i) = f(j), meaning that A[i] = A[j].  Thus the index of the entry of the # cycle must be one of the values that is duplicated in the array. # # There is a famous algorithm due to Robert Floyd that, given a rho-shaped # sequence, finds the entry point of the cycle in linear time and using only # constant space.  This algorithm is often referred to as the \"tortoise and # hare\" algorithm, for reasons that will become clearer shortly. # # The idea behind the algorithm is to define two quantities.  First, let c be # the length of the chain that enters the cycle, and let l be the length of the # cycle.  Next, let l' be the smallest multiple of l that's larger than c. # I claim that for any rho-shaped sequence l' defined above, that # #    x_{l'} = x_{2l'} # # The proof is actually straightforward and very illustrative - it's one of my # favorite proofs in computer science.  The idea is that since l' is at least # c, it must be contained in the cycle.  Moreover, since l' is a multiple of # the length of the loop, we can write it as ml for some constant m.  If we # start at position x_{l'}, which is inside the loop, then take l' more steps # forward to get to x_{2l'}, then we will just walk around the loop m times, # ending up right back where we started. # # One key trick of Floyd's algorithm is that even if we don't explicitly know l # or c, we can still find the value l' in O(l') time.  The idea is as follows. # We begin by keeping track of two values \"slow\" and \"fast,\" both starting at # x_0.  We then iteratively compute # #    slow = f(slow) #    fast = f(f(fast)) # # We repeat this process until we find that slow and fast are equal to one # another.  When this happens, we know that slow = x_j for some j, and # fast = x_{2j} for that same j.  Since x_j = x_{2j}, we know that j must be at # least c, since it has to be contained in the cycle.  Moreover, we know that j # must be a multiple of l, since the fact that x_j = x_{2j} means that taking j # steps while in the cycle ends up producing the same result.  Finally, j must # be the smallest multiple of l greater than c, since if there were a smaller # multiple of l greater than c then we would have reached that multiple before # we reached j.  Consequently, we must have that j = l', meaning that we can # find l' without knowing anything about the length or shape of the cycle! # # To complete the construction, we need to show how to use our information # about l' to find the entry to the cycle (which is at position x_c).  To do # this, we start off one final variable, which we call \"finder,\" at x_0.  We # then iteratively repeat the following: # #   finder = f(finder) #   slow   = f(slow) # # until finder = slow.  We claim that (1) the two will eventually hit each # other, and (2) they will hit each other at the entry to the cycle.  To see # this, we remark that since slow is at position x_{l'}, if we take c steps # forward, then we have that slow will be at position x_{l' + c}.  Since l' is # a multiple of the loop length, this is equivalent to taking c steps forward, # then walking around the loop some number of times back to where you started. # In other words, x_{l' + c} = x_c.  Moreover, consider the position of the # finder variable after c steps.  It starts at x_0, so after c steps it will be # at position x_c.  This proves both (1) and (2), since we've shown that the # two must eventually hit each other, and when they do they hit at position x_c # at the entry to the cycle. # # The beauty of this algorithm is that it uses only O(1) external memory to # keep track of two different pointers - the slow pointer, and then the fast # pointer (for the first half) and the finder pointer (for the second half). # But on top of that, it runs in O(n) time.  To see this, note that the time # required for the slow pointer to hit the fast pointer is O(l').  Since l' is # the smallest multiple of l greater than c, we have two cases to consider. # First, if l > c, then this is l.  Otherwise, if l < c, then we have that # there must be some multiple of l between c and 2c.  To see this, note that # in the range c and 2c there are c different values, and since l < c at least # one of them must be equal to 0 mod l.  Finally, the time required to find the # start of the cycle from this point is O(c).  This gives a total runtime of at # most O(c + max{l, 2c}).  All of these values are at most n, so this algorithm # runs in time O(n).  def findArrayDuplicate(array):     assert len(array) > 0      # The \"tortoise and hare\" step.  We start at the end of the array and try     # to find an intersection point in the cycle.     slow = len(array) - 1     fast = len(array) - 1      # Keep advancing 'slow' by one step and 'fast' by two steps until they     # meet inside the loop.     while True:         slow = array[slow]         fast = array[array[fast]]          if slow == fast:             break      # Start up another pointer from the end of the array and march it forward     # until it hits the pointer inside the array.     finder = len(array) - 1     while True:         slow   = array[slow]         finder = array[finder]          # If the two hit, the intersection index is the duplicate element.         if slow == finder:             return slow"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"input: array A[1..n] The idea is to use the sum of inegers from 1 to n and the sum of squares of integers from 1 to n: sum1 = sum from k = 1 to n (k) = n(n+1)2 sum2 = sum from k = 1 to n (k^2) = n(2n+1)(n+1)/6 Then we are calculating s1 = sum1 - sum from k=1 to n (A[k]) s2 = sum2 - sum from k=1 to n (A[k]^2) Now we have the system of equations: a-b = s1 a^2-b^2 = s2 where a is missing value and b is duplicate.  The solution is: a = (s2 + s1^2)/(2 s1) b = (s2 - s1^2)/(2 s1)  The complexity of the algorith is O(n).  The code: void f(int n) {     int sum1 = n*(n+1)/2;  int sum2 = n*(2*n+1)*(n+1)/6;  for(int i=0; i {   int next = readnext(); // get next value   sum1 -= next;   sum2 -= next*next;  }  int a = (sum2+sum1*sum1)/(2*sum1);  int b = (sum2-sum1*sum1)/(2*sum1);          printf(\"Missing: %d\\nDuplicate: %d\\n\", a, b); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"1. Sum all elements in array 10 + 6 + 3 + 4 + 7 + 5 + 2 + 4 + 9 + 1 = 59  2. Sum all numbers from 1 to N here N is 10 = 55  3. Subtract 59-55 = 4  So 4 is duplicate number in array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Since the value in the array is restricted to 1--N, the array can be easily sort in the way: array[tmp-1] = tmp. For example, array[5]=6, array[9]=10... During sorting the array, the duplicate number can be checked if array[tmp-1]==tmp. If so, that means these two element array[i] and array[tmp-1] own the same value.  /*  * DuplicateNumber.cpp  *  *  Created on: Dec 10, 2012  *      Author: ewailli  */   #include  #include  using namespace std; // Time o(N)  Space o(1) int main() {  int array[]={10,6,3,4,7,5,2,7,9,1};  int tmp,i=0;  while(true)  {   tmp = array[i];   if(tmp == i+1)   {    i++;    continue;   }   if(i >=10)   {    return 0;   }   if(array[tmp-1]==tmp)   {    cout<<\"duplicate number is \"<   return 0;   }   array[i]=array[tmp-1];   array[tmp-1]=tmp;  }  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Sa - m + r = S, [where S = summation of all the numbers and Sa = n(n+1)/2]  r = S-Sa+m     - eq 1    Pa*r/m = P, [where P = product of all numbers and Pa = n!]  m = Pa*r/P      - eq 2       two equations, two unknowns,,,solve it O(n) time complexity"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"add the elements, one by one, into the set, for the duplicate element, you would get false."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"If possible to allocate another array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This comment has been deleted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"The below may solve this problem in good time/space/elegance.  {{ sum = 0; sum_normal=N*(N+1)/2; xored = -1; for(int i = 0; i < N; i++){ if(!i) xored = A[i]; else xored ^= A[i]; xored^=(i+1); sum+=A[i]; } int offset = sum-sum_normal; for(int i = 0; i < N; i++) //note: xored = duplicated_item ^ missed_item; at this point if(xored^(A[i]+offset) == A[i]) return A[i];  }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"int duplicate(int A[], int n) { for(int i = 0; i < n; i++) { while(A[i] - i != 1) { if(A[i] == A[A[i] - 1])  return A[i]; else  swap(A[i], A[A[i] - 1]); } } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"elements = [] \nfor ele in A: \n  if ele in elements: \n    print ele \n  else: \n    elements.append(ele)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why not sort the array first and then compare the elements...whichever is found to be equal to its last element is duplicate !"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Andi's Solution is good and O(n) but can be optimized.  This solution will change order of elements in array. Use value of an element as index in array. Number 5 should be stored in index-1 ie 5-1. We need to subtract 1 as array is 0-based.   If there is a duplicate, we will try to put number and its duplicate in the same location. If all elements are unique, we will be able to find one location in array for each number in array and no conflict. 1. Start with index i = 0; 2. Use value a[i] at index  i  to look up location a[a[i]-1]. If number is same, we found duplicate. if not, read a[a[i]] in tmp and store a[i] in a[a[i]] and now repeat for tmp in array untill we find a[i] again. 3. increment i and repeat step 2.  e.g.     0,1,2,3,4,5,6,7,8,9 10,6,3,4,7,5,2,4,9,1 - Start with i = 0. Since a[0] =10, look up a[10-1] which is 1, so tmp =1 and a[9] =10. tmp = i so stop and increment i to 1. -  i=1: a[1] is 6; tmp = 5 and a[5] = 6, ,   tmp = 7 and a[4] = 5,  tmp = 2 and a[6] = 7, i -1 == tmp so stop and increment i = 2. ... ... - i= 7 and a[7] is 4. When access a[3] , we find a[3] already have 4. Duplicate found."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Easy... O(n) time:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. If length of array = n, ActualSum = n*(n+1)/2 ; ActualProd = n! 2. We can obtain sum and prod of given array in linear time 3. We have two unknowns to solve: (1) the repeating element, (2) the missing element 4. We have two equations to solve  The following code returns the missing element:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Apply heap sort on input array and scan the array linealy to find duplicate complexity : o(nlogn)(heap sort) + o(n)(linear scan)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think a solution exists such that if we Xor each item with its (index+1)  eg.4,5,1,2,3,4 dupElement=0; ((( for(i=0;i{ duplicateElement ^=(a[i]^(i+1)); } }}}  should return 4."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def findduplicate(a_list): \n countlist=list(map(a_list.count, a_list)) \n i=0 \n for i in range(len(countlist)): \n  if countlist[i] > 1: \n   return a_list[i]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You may use one bit to represent the occurrence of a value. This requires to additional info, which we all have 1. minimum  or maximum of  possible value, 2. size of the subject array,  the LO bit of the int pointed by the bit field pointer will represent the occurrence of 1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Create the binary search tree and during creation we can identify the duplicate elements in the array. Time complexity will be O(nlogn).  any suggestions are welcomed!!!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algo  Use a bit vector to identify the range of number BitArray myBA1 = new BitArray( N); 4 billion integers represented at the Ith location in the Array will only consume around 512 mbz Scan through the Array and previously modified bit in the scan is  your resultant answer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think that we can use the principles of quicksort in this case.  In the first round, we select a value = N/2. We go through the whole array, put all elements < N/2 in the left, all elements > N/2 in the right, and can check if N/2 is the one duplicated.  Now we sum all elements in the left and see if the summed value is what we expect. Otherwise, there is a duplicate in the left. If it's not the case, the duplicate is in the right. It takes N for this round.   In the second round, repeat the same procedure for the part with the found duplicate. It takes N/2 for this round.  So finally we can find the duplicate with N + N/2 + N/4 +... = 2N. So it takes O(n) for time, and O(1) for space.  Hope it's correct :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"As he said only one element is duplicated, XOR all the elements of the array the remaining element after the Xor is the required duplicated element..!! :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I guess this question is similar to find first missing number in a array. If (data[index] != index)  swap (data, index, data[index]); Do this swap from 0 to len - 1. If index[A] is already occupied by number A, then A is the duplicate. The following is a implementation in Java.  {  public int findDuplicate(int[] data){   int len = data.length;   for (int index = 0; index < len; index++){    while(index != data[index]){     if (index != data[index] && data[index] != data[data[index]])      swap(data, index, data[index]);     else if (data[index] == data[data[index]])      return data[index];    }   }   return -1;  }  private void swap(int[] data, int src, int dest){   int tmp = data[src];   data[src] = data[dest];   data[dest] = tmp;  } }  Comment me if I got wrong, please"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I don't know if anyone will read this very late solution, but I think I have a very interesting one. : ) The basic idea is to mark the number we have found. If we find m, we will modify a[m-1]. BUT BUT, I don't modify the value of a[m-1], I change the signal (positive or negative).   If we find m, then point to a[m-1], but we find a[m-1] < 0 (I don't care the value in a[m-1], just the signal), then m is the duplicate!  Only assumption is that all numbers are positive, which is guaranteed by the description. Here is the code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nusing namespace std; \n \nint func(int sourceArray[], const int& length){ \n if(sourceArray == NULL || length <= 0) \n  return -1; \n  \n int target = -1; \n for(int i = 0; target == -1 && i < length; i++){ \n  while(sourceArray[i] != i+1){ \n   int temp = sourceArray[i]; \n   if(sourceArray[temp-1] == temp){ \n    target = temp; \n    break; \n   }else{ \n    sourceArray[i] = sourceArray[temp-1]; \n    sourceArray[temp-1] = temp; \n   } \n  } \n } \n return target; \n} \n \nint main(int argc, char* args[]){ \n int sourceArray[] = {10,6,3,4,7,5,2,4,9,1}, length = 10; \n  \n cout << func(sourceArray, length) << endl; \n  \n return 0;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"If n integers range from 1 to n-1 then:  take sum of n-1 integers: (n-1)n/2...O(1) take sum of the elements in the array: S....O(n)  the duplicate = S - (n-1)n/2  example: 7 9 8 1 4 3 5 6 8 2.........in this 9 elements array 8 is repeated so basically we have 9 unique elements with sum 9*10/2 = 45 sum of array S = 53 repeated = 53 - 45 = 8"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"Useful solution if there is possibility of overflow in adding arrray ... Start from A[0] step 1:check value if it is n. Put this value ant A[n] and original A[n] Value at A[0] .. keep on doing this.. it will end when A[0] has 0 ..Do it for A[1]  now repeat step 1;"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14928575","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"9","title":"Write a function that takes an array as an input and returns starting and ending indexes  within the array such that if we add elements from the starting and ending index we would get  maximum possible sum of any contiguous set of elements within that array.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"1. Just keep track of max_sum, max_start and max_end so far. 2. Keep storing new sum in temp_sum and new start in new_start new end will be \"i\". 3. If temp_sum is greater than max_sum update all max variables.  O(n) and done in place.... Here is an implementation in java...  docs.google.com/open?id=0Bw6L8Yy5eLJ3MUQxM3B2MVNEMkE"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"void MaxSubSeq(int array[],int length, int *start, int *end) \n \n{ \n//    long long max_sum = -(~((long long)0)); \n    long long max_sum = -(((long long)1)<<(8*sizeof(int))); \n    long long entire_sum=0; \n    int break_point = -1,i=0; \n \n    for(; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"void maxSum(int a[], int n) \n{ \n    int max=-9999, curr=0,start=0,end=0,currentstart=0; \n    for(int i=0;imax) \n        { \n            max = curr; \n            start=currentstart; \n            end = i; \n        } \n        else if(curr<0) \n        { \n            currentstart=i+1; \n            curr=0; \n        } \n    } \n    cout<<<\" \"<<<\" \"<<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this does the trick in O(N)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"qqq"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Read up on Kandane's Algo"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"KADANE ALGORITHM"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14968560","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"20","title":"A pxq size matrix is given, and a matrix of size axb is removed from top right corner. Find the total no. of paths from top left to bottom right, with only right and down movements allowed. No path should go into the removed matrix. eg-   _ |_|_ |_|_|  this is (2x2) matrix after removing (1x1) matrix from top right corner. no. of ways - 5.  The algorithm should be fast enough.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"we can solve this through recursion, function f(x,y) starts with f(p-1,q-1). each time we run with f(x-1, y) & f(x, y-1). we run it until x & y are zero, when both are zero we increase the count+1. to remove the matrix we check for is valid x & y.  pseudo code in java:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"A typical DP problem. Recursion will be slow as you will be traversing same path multiple times."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this is problem of a running contest."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"From any starting point, there are two points one can reach.  From each of those points, recurse. Invalid moves like going to the removed area or out of bounds should be skipped. Increment path counter everytime the point in consideration is the bottom right one. This should work, anyone on how to get the complexity of this recursive solution?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"dynamic programming with contraints: for each cell keep the number of paths from top left corner to that cell not violating contraints. The answer would be in the bottom right cell of dp table. Time/Space complexity O(pXq)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what if  use  a table storing the the number of ways to reach the bottom right in each cell.  this is what i think.  =>dp[p-1,q-1]=0 cause we are already there.  =>start from the bottom right most index i.e, i=p-1,j=q-2 and traverse to wards the top left. while(i>=0 && j>=0) {  //traversing in the invalid region  if(i>=p-1-a && j<=b)    { j--; continue;} //if traversing in the edge cells of matrix after removing axb matrix    if(i==p-1-a && j<=b)  {dp[i][j]=dp[i+1][j]+1; if(j==0){i--; j=q-1;}else{j--;} continue; } // if traversing in the non edge cells of matrix  if(i {dp[i][j]=dp[i+1][j+1]+2} // if traversing in the edge cells of the matrix  else if(i==p-1)  {dp[i][j]=dp[i][j+1]+1;}  else if(j==q-1)  { dp[i][j]=dp[i+1][j]+1;}    if(j==0){i--; j=q-1;}else{j--;}  }  } //dp[0][0] holds the possible number of paths to bottom right corner.   let me know if there is a better way..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"DP Solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This looks a problem from the Khan Academy where you need to add the left and top possibilities current node's paths = left node's path+top node's path   (with a slight modification of a constraint )  The same rule applies here that the such that neither of the left, the right and the current node should be from the constraint areas.  1)If current node is in constraint area make its total path's to zero and skip the loop to start at next row (since all other nodes to the right will also be in  restricted area) 2)Similarly if top node is in restricted area we should not add it, so an additional check on each of the current node's top child. 3)Lastly we need to check the left nodes for restricted area, or do we?From #1 we see that we will never have to encounter such a node. (Assuming that we have loops from i to p and j to q)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We divide rectangle to 4 parts.  12 34 Part 2 is the removed section. The paths consists of two parts: from top-left to the edge of part 1. And from edge of part 3 to bot-right. The total number should be sum (number of path in part 1 * corresponding number of path in part 2) Path number in each parts should be able to calculated by combination number. Then the time complexity will be roughly related to length of part 1 if factor calculation is cached."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Javascript DP solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For unsliced matrix you have (p+q)Cp or (p+q)Cq ways. But as there are some paths cut off due to slicing of a*b sub matrix, it will be (p+q)Cp - sum((m+n-x)C(m-x)) when x>0 + 1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"no of ways in original matrix P1: (p+q)!/(p!q!) [choosing from total p+q steps]  no of ways in sub matrix P2: (a+b)!(a!b!)  finally, in the reduced matrix: P1 - P2"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14948577","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"9","title":"Given a satellite picture with islands in ocean, how would you count the number of islands?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"Start traversing the picture  ----> If found an unfound land pixel  --------> DFS traverse all connected land pixels mark all of them found  Number of islands = Number of DFS traversals started for land pixels"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Any closed shape of sufficient area containing color other than blue as majority can be considered an island.  This is just a basic idea but can be helpful if a programming approach is to be used."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Perform image segmentation to get the number of islands."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"separate the picture into n by m grids, you shall know the resolution of the picture so make sure each tile is at least 4 times smaller than an minimum island. then count all connected tiles other than blue as one, sum them up to get the number of islands."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can do this by using the Connected Components algorithm that uses the Union-Find data structure. To account for different shades of same color we can define a function that will return true if difference between color attributes of neighbouring pixels are within some configurable threshold."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Perform a Fourier transform using polar coordinates and find the spikes of concentric radii that differ in phase using the color as a complex magnitude. They will be evident by the difference in continuity of the transform."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Connected components Algorithm or DFS/BFS can be applied once you convert the given satellite picture into a graph/tree which is practically not a good practice.  This is a Machine Learning question. You need sample data (if supervised learning is to be implemented)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You don't need machine learning for this. This is a popular image processing problem called blob counting.   Basic idea is to: Convert to gray-scale, low-pass filter to get rid of any noise, count blobs.  Search for \"image processing blob counting\" if you want something more concrete."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14990074","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"16","title":"You have a log file with start/end times of different functions. Find the total exclusive working time for a particular method foo().  E.g. Log:  (foo()_start, 10:01);   (foo2()_start, 10:03);     (foo()_start, 10:05);     (foo()_end, 10:08);   (foo2()_end, 10:12); (foo()_end, 10:20); Total time: (10:03-10:01) + (10:08-10:05) + (10:20-10:12) = 2 + 3 + 8 = 13  P.S. Recursion calls and inner calls of foo() are possible","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"use a stack to store the function not returned, if read a log entry that a function starts, push the entry. if read a log entry that a function ends, pop up an entry from the stack  when read an entry and the current running function is \"foo\" by checking whether the top element of the stack, add the time difference between the current entry and the previous one to the total   Time: O(n)  Pseudo Codes"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do you have an approach?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"my solution will use a stack, as long as start is found push into stack.when an end is encountered, pop  the first start line of the similar function"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what if under multi-thread ormulti process situation? like: (foo()_start, 10:01);  (foo2()_start, 10:03);  (foo()_start, 10:05);  (foo2()_end, 10:08);  (foo()_end, 10:12); (foo()_end, 10:20);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"BTW, ifenjoy9 already gave a wonderful solution here: careercup.com/question?id=14990939"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Given how the problem is stated, you have a log file with the format above. If you set it up to have a LogEntry object like described above, then you will have to iterate through the list twice, which is not bad but there is a more efficient way to do it. - Scan through the file, look for where the function first occur. - Set startFunct = 1, endFunct = 0; Setting it this way, startFunct will always lead endFunct unless the corresponding ending function matches with the originally calling function. - Create a variable to keep track of the time for even iteration count evenTime, and another one for odd iteration count oddTime. Time elapse is the difference between the even and the odd. - Iterate until startFunct == endFunct, increment them along the way. Add time into the evenTime and oddTime. Here is the code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.LinkedList; \nimport java.util.Stack; \n \npublic class Logs { \n LinkedList entries; \n \n public class LogEntry { \n  String funName; \n  int timestamp; \n  String type; \n \n  public LogEntry(String funName, int timestamp, String type) { \n   super(); \n   this.funName = funName; \n   this.timestamp = timestamp; \n   this.type = type; \n  } \n \n  @Override \n  public String toString() { \n   return funName + \" \" + timestamp + \" \" + type; \n  } \n \n } \n \n public Logs() { \n  super(); \n  entries = new LinkedList(); \n  LogEntry e1 = new LogEntry(\"foo\", 1, \"start\"); \n  LogEntry e2 = new LogEntry(\"foo2\", 3, \"start\"); \n  LogEntry e3 = new LogEntry(\"foo\", 5, \"start\"); \n  LogEntry e4 = new LogEntry(\"foo\", 8, \"end\"); \n  LogEntry e5 = new LogEntry(\"foo2\", 12, \"end\"); \n  LogEntry e6 = new LogEntry(\"foo\", 20, \"end\"); \n  entries.add(e1); \n  entries.add(e2); \n  entries.add(e3); \n  entries.add(e4); \n  entries.add(e5); \n  entries.add(e6); \n } \n \n public int calElapse(String functionName) { \n  int elapse = 0; \n  Stack stack = new Stack(); \n  for (int i = 0; i < entries.size(); i++) { \n   LogEntry entry = entries.get(i); \n   if (!stack.isEmpty() && stack.peek().funName.equals(functionName)) { \n    elapse += (entry.timestamp - entries.get(i - 1).timestamp); \n   } \n   if (entry.type.equals(\"end\") && stack.peek().type.equals(\"start\") \n     && entry.funName.equals(stack.peek().funName)) { \n    stack.pop(); \n   } else { \n    stack.push(entry); \n   } \n  } \n  return elapse; \n } \n \n public static void main(String[] args) { \n  Logs logs = new Logs(); \n  System.out.println(logs.calElapse(\"foo\")); \n } \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14968338","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"14","title":"write a function to check given string matches with given pattern Condition: only one wildcard used in the pattern, that is '*', but can be used in the pattern more than once. Example:  pattern: *abc*def*.doc* str: adsfabcxyzdefgh.docx  fucntion signature is like:  boolean isMatching(String str, String pattern);","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"This is O(n) solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"int isMatching(char *s,char *p) \n{ \n int si=0,pi=0,sl,pl; \n sl=strlen(s); \n pl=strlen(p); \n int star=-2; \n while(si"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can probably be optimized, here is my first attempt:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//   codes-to-problem.blogspot.in/2012/11/write-function-to-check-given-string.html \n \npublic class isMatchingWithWildcard { \n public static void main(String [] args){ \n  String pattern = \"*abc*def*.doc*\"; \n  String str = \"adsfabcxyzdefgh.do1docx\"; \n  if(isMatching(str, pattern)) \n   System.out.print(\"Matching\"); \n  else \n   System.out.print(\"Not Matching\"); \n } \n  \n public static Boolean isMatching(String str, String pattern){ \n  int l = pattern.length(); \n  if(pattern.lastIndexOf(\"*\") == l-1) \n   pattern= (String) pattern.subSequence(0, l-1); \n  if(pattern.charAt(0) == '*') \n   pattern= (String) pattern.subSequence(1, pattern.length()); \n  pattern = pattern.replace(\"*\", \"__\"); \n  String [] patternArray = pattern.split(\"__\"); \n  String sorttenString =str; \n  for(String aPattern:patternArray){ \n   String [] temp = sorttenString.split(aPattern); \n   if(temp.length==1 && (aPattern == patternArray[patternArray.length-1]  \n     && !sorttenString.toLowerCase().contains(aPattern.toLowerCase()))) \n    return false; \n   str.substring(temp[0].length()+aPattern.length()); \n  } \n  return true; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my solution. It is recursive-based. I believe this approach is more easy to understand. (* this is written in c#)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simplest way is to use split. Runtime: O(m+n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class StarPattern { \n \n public static boolean isMatch(String string, String pattern) { \n  boolean isMatch = true; \n  String[] patterns = pattern.split(\"\\\\*\"); \n  int index = 0; \n  int i; \n  for (i = 0; i < patterns.length; i++) { \n   if (string.substring(index).indexOf(patterns[i]) == -1) { \n    isMatch = false; \n    return isMatch; \n   } \n   index += string.substring(index).indexOf(patterns[i]) \n     + patterns[i].length(); \n  } \n  if (i != patterns.length) { \n   isMatch = false; \n  } \n  // corner case detection \n  if (pattern.charAt(0) != '*') { \n   isMatch = string.startsWith(patterns[i-1]); \n  } \n  if (pattern.charAt(pattern.length() - 1) != '*') { \n   isMatch = string.endsWith(patterns[i-1]); \n  } \n  return isMatch; \n } \n \n public static void main(String[] args) { \n  String string = \"adsfabcxyzdefgh.docx\"; \n//  String string = \"adsfabcxyzdefgh.do.docxyz\"; \n  String pattern = \"*abc*def*.doc*\"; \n//  String string = \"abcdeabchiabc\"; \n//  String pattern = \"*abc\"; \n  System.out.println(isMatch(string, pattern)); \n } \n \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14975150","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"45","title":"Given an array of positive and distinct integers, output all pythogrean triplets of them i.e They have to satisfy: a.a + b.b = c.c","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"Step 1 :- Square each element ( O(n) time ). This reduces the problem to check if an element is the sum of any other two elements.  Step 2 :- Sort this new array in ascending order( O(nlog(n)) time ).  Step 3 :- Now consider each element array[i] , For any array[i] = array[j] + array[k] , both k and j are strictly lesser than i (Question says all positive distinct integers) !  Step 4 :- Write a for loop where j increases from 0 to i and k decreases from i to 0 until j and k meet ,   If array[j] + array[k] < array[i]       j++;  else if array[j] + array[k] > array[i]       k--;  else (if equal)     print the square roots of array[i],array[j],array[k] !  So totally O(n) operations !!!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"codes-to-problem.blogspot.in/2012/11/finding-pythagorean-triplets-in-array.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"1. Save the square of numbers in an array. 2. For each number a, initiate two pointers(b&c) to the middle of the array, find b+c. if sum is greater than a, binary-decrement b and if sum is less than a, binary increment c 3. repeat step 2 until a=b+c or both pointers(b&c) go out of scope. if a=b+c, print a,b,c 4. complexity is O(N)*O(LogN)*O(LogN) and i think it is better than O(N)*O(N)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"# include # include # include # include int compare(const void*a,const void*b) {     return(*(int*)a-*(int*)b); }//end of compare used by qsort int find_triplet(int *a,int n) {     int i,k,j,m,sum,flag=1;     //first modify the array if it can not be modified then create its copy first     for(i=0;i    a[i]=a[i]*a[i];     qsort(a,n,sizeof(int),compare);     for(i=0;i    printf(\"%d\\n\",a[i]);     for(i=0;i    {                     k=a[i];                     j=0;                     m=n-1;                     while(j                    {                               sum=a[j]+a[m];                               if(sum==k&&j!=i&&m!=i)                               {                                         flag=0;                                         puts(\"found triplets\");                                         printf(\"%d %d %d\",(int)sqrt(k),(int)sqrt(a[j]),(int)sqrt(a[m]));                                         printf(\"\\n\");                                         j++;m--;                                         }                              else  if(sum>k)                               m--;                               else                               j++;                               }//end of while                     }//end of for loop if(flag==1) puts(\"no such triplet occurs\"); return 0; }  int main() {     int n,i,*a;     printf(\"enter the number of elements you want to enter in the array\");     scanf(\"%d\",&n);     a=(int*)malloc(sizeof(int)*n);     if(a==NULL)     {                puts(\"not enough  memory to store array elements\");                                }     else     {     for(i=0;i    {                     printf(\"Enter element:\");                     scanf(\"%d\",&a[i]);                     }//end of for loop                          find_triplet(a,n);     }     getch();     return 0; }//end of main"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"step1:   Square the array in place  and add square ie) a[i]*a[i] as key and value as a[i] in a dictionary for all elements of the array \nstep 2:  Sort the array in ascending order. \nStep 3: Traverse the array picking adjacent elements and sum them and see if it is in dictionary, if so print the corresponding values in dictionary as pythogorian triplets. \n \neg:- a[]={3,2,4,5} \nafter step 1: \na[]={9,4,16,25} \ndict = { 4:2, 9:3, 16:4, 25:5} \n \nafter step2: \na[]={4,9,16,25} \n \nstep 3:  \n \n4+9=13 not in dict \n9+16=25 in dict \n \noutput values dict[9],dict[15],dict[25] is 3,4,5 \n \nproceed till the end of the array"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include   #include #include #include #include   void merge(int *a,int p,int q,int r) {      int n1=q-p+1;      int n2=r-q;      int i,j,k;      long L[n1+1],R[n2+1];            for(i=0;i     L[i]=a[p+i];      L[n1]=1000000000;            for(i=0;i     R[i]=a[q+i+1];      R[n2]=1000000000;      i=0;      j=0;      for(k=p;k<=r;k++)      {         if(L[i]<=R[j])         {             a[k]=L[i];             i++;         }                  else         {             a[k]=R[j];             j++;         }      } }  void mergesort(int a[28],int p,int r) {      int q;      if(p     {          q=(p+r)/2;          mergesort(a,p,q);          mergesort(a,q+1,r);          merge(a,p,q,r);      } }  int main() { int a[28]={3,5,4,10,8,6,44,13,265,5,23,96,12,90,7,41,40,9,117,125,247,264,161,240,289,68,285,293}; int p=0,r=27,i; int *x,*y; mergesort(a,p,r);    for(i=27;i>=0;i--) {    x=&a[0];    y=&a[i-1];                   while(x!=y)    {       if((*x)*(*x)+(*y)*(*y)==a[i]*a[i] && (*x)!=(*y) && (*y)!=a[i] )       {          printf(\"\\n%d  %d  %d\",*x,*y,a[i]);           break;       }              if((*x)*(*x)+(*y)*(*y)>a[i]*a[i])        y--;              else       x++;    } }       getch();   return 0;        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"WORKING code in turbo c with  time O(n^2);just copy and run this code... \n#include \n#include \n#include \n#include \nvoid main() \n{ \nint n,i,j,m,flag;    float f; \nint *a,*hashtable; \nclrscr(); \nn=100;//scanf(\"%d\",&n); \na= (int*) malloc (n*(sizeof(n))); \nfor(i=0;i0.0) \n  continue; \n  if(hashtable[m]==flag) \n  { \n    printf(\"a=%d  b=%d  c=%d\\n\",a[i],a[j],m); \n    i=j=n; \n  } \n } \n} \n   free(hashtable); \n   free(a); \n   getch(); \n   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For the first solution,   You can start from i=2 and initialize j and k as j=0, k=i-1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For the first solution,   You can start from i=2 and initialize j and k as j=0, k=i-1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void FindPythagoreanTriples(int[] numbers) \n{ \n  int n = numbers.Length; \n   \n  //This would take O(N log N) \n  Sort(numbers); \n \n  int[] squares = new int[n]; \n \n  //This would take O(N) \n  for (int i = 0; i < n; i++) \n  { \n    squares[i] = numbers[i] * numbers[i]; \n  } \n \n  //Outer loop \n  for (int i = 0; i < n - 2; i++) \n  { \n    //Inner loop \n    for (int j = i+1; j < n - 1; j++) \n    { \n      int sum = squares[i] + squares[j]; \n       \n      //If the number corresponding to the hypotenuse * hypotenuse exists \n      //in the remaining array we have found a pythagorean triplet \n      //This would take O(log N) \n      int k = BinarySearch(squares, j+1, n); \n      if (k != -1) \n      { \n         Console.Writeline(\"{0}^2 + {1}^2 = {2}^2\", numbers[i], numbers[j], numbers[k]); \n      } \n    } \n  } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void FindPythagoreanTriples(int[] numbers) \n{ \n  int n = numbers.Length; \n   \n  //This would take O(N log N) \n  Sort(numbers); \n \n  int[] squares = new int[n]; \n \n  //This would take O(N) \n  for (int i = 0; i < n; i++) \n  { \n    squares[i] = numbers[i] * numbers[i]; \n  } \n \n  //Outer loop \n  for (int i = 0; i < n - 2; i++) \n  { \n    //Inner loop \n    for (int j = i+1; j < n - 1; j++) \n    { \n      int sum = squares[i] + squares[j]; \n       \n      //If the number corresponding to the hypotenuse * hypotenuse exists \n      //in the remaining array we have found a pythagorean triplet \n      //This would take O(log N) \n      int k = BinarySearch(squares, j+1, n); \n      if (k != -1) \n      { \n         Console.Writeline(\"{0}^2 + {1}^2 = {2}^2\", numbers[i], numbers[j], numbers[k]); \n      } \n    } \n  } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class pytho {              public static int numPythagoreanTriplets(int N) {                 int x = 0;                 for (int c = N; c > 1; c--) {                         int squarec = c*c;                         for (int b = c-1; b > 1; b--) {                                 int squareb = b*b;                                 int squarea = squarec - squareb;                                 if (squarea > squareb) continue;                                 double a = Math.sqrt(squarea);                                  if ( Math.abs(a - Math.floor(a)) ==0) {                                         x++;                                 }                         }                 }                 return x;                          }         public static void main(String[] args) {                 int v = numPythagoreanTriplets(1000);                                  System.out.println(v);          }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This code works for all test cases: int n;  cout<<\"Enter the size of array\";  cin>>n;  vector a;  for(int i=0;i  a.push_back(0);  cout<<\"Enter the array elements\";  for(int i= 0;i {   cin>>a[i];   a[i]*=a[i];//square each element  }  //Sort the array  sort(a.begin(),a.end());  // Main Logic  for(int k=n-1;k!=0;k--)  for( int i= 0, j=k-1; i!=j; )  {   if( a[i]+ a[j] == a[k])   {        cout<<\"array elements\"<   break;   }   else if( a[i]+ a[j] < a[k])    i++;   else    j--;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Time complexity O(n^2)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Euclid's formula is a fundamental formula for generating Pythagorean triples given an arbitrary pair of positive integers m and n with m > n. The formula states that the integers    a=m.m-n.n,b=2.m.n,c=m.m+n.n form a Pythagorean triple. example: if m = 5 and n = 7, n.n - m.m = 49 - 25 = 24, 2.m.n = 70, and  n.n + m.m = 49 + 25 = 74.   24, 70, 74 is a PT, because 24.24 + 70.70 = 74.74."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This comment has been deleted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Here is my algo :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"One of the ways is to do this is in O(N) as time complexity and O(N) as space complexity by putting the elements in Map, which is not difficult to implement. Another way to implement in O(N log N) as time complexity and O(1) as space complexity was something that interviewer was probably looking for. Here is the code for O(N logN) and O(1) for time and space respectively."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14990674","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"20","title":"Given an integer array, convert it into a  linked list with each node containing one sequence. Please reply on manish.89july@gmail.com","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"wat do you mean by containing one sequence??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Hi  If you observe the input there are some numbers followed by consecutive numbers. For eg:  1 does not have consecutive number 2. So, add 1 in Linked list  node. Add next element in input, i.e 3 to  another node of Linked List, then check in the input array for 3 consecutive, i.e 4, it is available. So, add 4 to the same node of Linked list. Like that 5 also to the same node of Linked List.  Now, the linked list contains the [1]->[3,4,5]  Next element in 8 not consecutive to 5. So, add 8 to another node of Linked list.  Like that will have to create Linked List.  Hope you understand the sequence.  Final Sequence is : [1 ]-> [3,4,5]-> [8,9] -> [11] -> [13,14,15,16] -> [20] -> [23] -> [30,31,32]."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"String[] sa = new String[] { \"A\", \"B\", \"C\" };   LinkedList ll = new LinkedList(Arrays.asList(sa));              // iterate over each element in LinkedList       Iterator iterator = ll.iterator();       while (iterator.hasNext()) {       // Print element to console       System.out.println((String) iterator.next());       }    Hoping that it will help you."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have a question. Does the code have to be in C# / Java or is C, C++ acceptable?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I didn't get the question. It is always a good idea to add an example use case with the question"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Integer[] sa ={1, 3, 4, 5, 8, 9,  11, 13, 14, 15, 16, 20, 23, 30,31,32}; LinkedList aa = new LinkedList();        aa.addFirst(sa[0]);       for(int i=1;i       if(sa[i-1]+1==sa[i]){         aa.removeLast();         String temp=\"\";         for(int j=i-1;j         int a=sa[j];          int b=sa[j+1];          if(a+1==b){           temp=temp+Integer.toString(sa[j])+\":\";           if(j==sa.length-2){            temp=temp+Integer.toString(sa[j+1]);            aa.addLast(temp);            i=j;            break;           }          }else{           temp=temp+Integer.toString(sa[j]);           aa.addLast(temp);           i=j;           break;          }         }        }else{         aa.addLast(sa[i]);        }       }           Iterator iterator = aa.iterator();         while (iterator.hasNext()) {          // Print element to console          System.out.print(iterator.next()+\" \");      }    It works."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is tested code in Java"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static List continousInt(int a[]){ \n   \n  if(a.length == 0) \n    return null; \n  List  l = new LinkedList(); \n   \n  int i = 0; \n  String s = \"\"+a[i]; \n  int last = a[i]; \n  i++; \n  while(i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) {   Integer[] input = {1,3,4,5,8,9,11,13,14,15,16,20,23,30,31,32};   LinkedList outputList = new LinkedList();   List nodes = new ArrayList();    for (int i = 1 ; i < input.length ; i++) {    nodes.add(input[i-1]);    if(input[i] == input[i-1] + 1 ) {           continue;    }    else {     int j = outputList.size();     outputList.add(j,nodes);     nodes = new ArrayList();        j--;    }        }   System.out.println(outputList);     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void main(String[] args) {   Integer[] input = {1,3,4,5,8,9,11,13,14,15,16,20,23,30,31,32};   LinkedList outputList = new LinkedList();   List nodes = new ArrayList();    for (int i = 1 ; i < input.length ; i++) {    nodes.add(input[i-1]);    if(input[i] == input[i-1] + 1 ) {           continue;    }    else {     int j = outputList.size();     outputList.add(j,nodes);     nodes = new ArrayList();        j--;    }        }   System.out.println(outputList);     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi please find the java code to convert the input array into a linkedlist each node containing a sequence.  Please reply if you find any mistakes ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include   #include #include #include #include  int a[]= {1, 3, 4, 5, 8, 9, 11, 13, 14, 15, 16, 20, 23, 30,31,32};  struct node {        char data[10];        struct node *next; };  struct node* createnode(int x) {    struct node* temp;    temp=(struct node*)malloc(sizeof(struct node));    char s[10];    itoa(x,s,10);    strcpy(temp->data,s);    temp->next=NULL;        return temp; }     void insert(struct node**p) {      int i;      struct node *temp,*link;      char s1[10];      for(i=0;i<16;i++)      {         if(a[i]+1!=a[i+1])         {            temp=createnode(a[i]);            if(*p==NULL)            {               *p=temp;               link=temp;            }                        else            {                link->next=temp;                link=link->next;            }         }                  else         {             temp=createnode(a[i]);              while(a[i]+1==a[i+1])             {                 itoa(a[i+1],s1,10);                 strcat(temp->data,\",\");                 strcat(temp->data,s1);                                 i++;             }                          link->next=temp;             link=link->next;         }      }                    }  void show(struct node *p) {      while(p!=NULL)      {         printf(\"\\n%s\",p->data);         p=p->next;      }     }       int main() { int i; struct node *p=NULL;  insert(&p); show(p);   getch();   return 0;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is tested code in C++, making use of the STL."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Try this one......Above code are not correct (posted by Rahul)....That's not printing last sequence of Numbers"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It Looks really simple and gud one."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14949205","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"16","title":"Given an integer array with sequence of numbers, come up with a way to compress the data without losing the information. Based on the compressed data, it should be possible to construct the original integer array. Please reply on manish.89july@gmail.com","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Another approach is to change from base 10 to larger base like base 67."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Each integer has 32 bits. So, it can accommodate at-least 9 digits.  The idea is club as many numbers as possible to a single number. While clubbing we have to maintain the number of digits of each number being clubbed. Hence, if input number is 'xyz', then in output we have to write 4xyz. While decoding, use these extra digits as delimiters. Example: If we have [1,2,3,4,5,20,123], we can convert into [11121314,152203123] . Initial memory required=7*4=28 bytes After compression, memory required=2*4=8 bytes."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"I dont think MS wants to test our Data Compression Skill set. I would go for Run Length Encoding which is the simplest."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This is my approach 1. Create a int array of size 10 +1 for separator. 2. Loop through each integer and update its frequency for [111,1923] => 0,4,1,1,0,0,0,0,0,1,1 3. Construct Huffman tree with these most frequently occurred near root. 4. Compress the data and return byte[]. 5. Do the inverse in uncompress take byte[] and return int[]."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"difference queue"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Are there any examples?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i consider most of these answers as over engineering. Almost all of them have missed the fact that the given list is a \"sequence\". All you need to do is write the first digit of each sequence and the actual sequence length and keep repeating. For e.g. 1, 2, 3 7, 8, 13, 17, 18, 19, 20 becomes 1,3,7,2,13,1,17,5"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think Raghu is 100% correct, this questions looks to be a follow up questions. And yes, person must clarify this with interviewer as to what he meant by sequence"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14952198","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"26","title":"Given an integer array, find the longest sequence and print it. Please reply on manish.89july@gmail.com","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"check my implementation here"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  #include  #include using namespace std; int max(int x,int y) { if(x>y) { return x;               }     else { return y;   }  }  int g=0,h=0,h1=0;  int longest_sequence(int arr[],int index,int length) {  if(length+1==index)  {  return 0;  }  if(arr[index+1]==arr[index]+1)  {                                                            g++;  h=1+longest_sequence(arr,index+1,length);  return h;  }  else  {    if(g>h1)    {    h1=g;            }   g=0;  return longest_sequence(arr,index+1,length);  } }  int main(int argc, char *argv[]) {      char * arr[5]={\"poi\",\"olk\",\"ert\",\"wer\",\"qwer\"};       // int y=rand()%4;      // cout<      int y1[16]={1, 3, 4, 5, 8, 9, 11, 13, 14, 15, 16, 17, 18, 30,31,32};       cout<      cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include int arr[100]; int max=0, max_in,count; int longest(int,int); int main() {  int i,n;  printf(\"no of elements = \");  scanf(\"%d\",&n);  for(i=0;i {  printf(\"\\nenter the elements = \");  scanf(\"%d\",&arr[i]);}  for(i=0;i {   count = 1;  longest(arr[i],n);}  for(i=0;i {  printf(\"%d\\t\",max_in);  max_in++;  }  getch();  return 0;  }   int longest(int in, int n) {  int i,in_1=in;  for(i=0;i {   if(arr[i]==in+1)   {    longest(in+1,n);    count=count+1;    break;     }   }     if(count>max)     {     max=count;       max_in = in_1;           }     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int start_pos, len=0; \nvoid long(int arr[], int n) \n{ \n   int count, s_p, i=0; \n   while(i < n) \n   { \n      count=1; \n      if(arr[i+1] == arr[i]+1) \n      { \n         s_p = i; \n         count++; \n         for(int j=i+2; j len) \n      { \n         len = count; \n         start_pos = s_p; \n      } \n      i = i+count; \n   } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I guess function should return set of numbers not the max number of elements in the list"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i=0; \nlength=0; \nstartindex=0; \nwhile(i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i=0; \nlength=0; \nstartindex=0; \nwhile(i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int _tmain(int argc, _TCHAR* argv[]) \n{ \n int num_list[] = {1, 3, 4, 5, 8, 9, 11, 13, 14, 15, 20, 23, 30, 31, 32, 33}; \n int max_seq_len = 0; \n int seq_len = 0; \n int num_list_len = sizeof(num_list) / sizeof(int); \n int start_index, longest_seq_start_index = 0; \n int longest_seq_end_index = 0; \n \n for (int i = 1; i < num_list_len + 1; i++) \n { \n  if (num_list[i] == num_list[i-1] + 1) \n  { \n   if (!seq_len) \n    start_index = i - 1; \n \n   seq_len++; \n  } \n  else \n  { \n   if (seq_len > max_seq_len) \n   { \n    max_seq_len = seq_len; \n    longest_seq_start_index = start_index; \n    longest_seq_end_index = i - 1; \n   } \n \n   seq_len = 0; \n  } \n } \n \n printf(\"longest sequence length is %d\\n\", max_seq_len+1); \n printf(\"longest sequence is: [\"); \n \n for (int i = longest_seq_start_index; i <= longest_seq_end_index; i++) \n { \n  printf(\"%d \", num_list[i]); \n } \n  \n printf(\"]\"); \n \n getchar(); \n \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void longestSeq(int arr[], int index, int size) \n{ \nint idx = 0, b = arr[0], sz = 0, mIdx = 0, mSize = 0; \nfor (int i = 0; i < size, i++) \n{ \nif(arr[i] == b+1) \n{ \nsz++; \n} \nelse{ \nidx = i; \nsz = 1; \n} \nif (mSize < sz) \n{ \nmIdx = idx; \nmSize = sz; \n} \n} \n \nfor(int j = mIdx ; j < mSize; j++) \ncout << arr[j] << ' ' ; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include int longest_sequence(int*, int); int main() { int arr[100], n, i; printf(\"no of element do u wnt to enter= \"); scanf(\"%d\",&n); for(i=0; i{   printf(\"\\nenter the value of a[%d] = \",i);         scanf(\"%d\",&arr[i]); } longest_sequence(arr,n); return 0; }  int longest_sequence(int *ptr, int total) { int max_size=1, temp_start, start, count=1, i; start = *ptr; for(i=0; i{  if(ptr[i] == (ptr[i+1]-1))  {  if(count  == 1)   temp_start = ptr[i];   count = count+1;  }  else  {  if(count > max_size)  {  max_size = count;  start = temp_start;  }   count = 1;  } } for(i=0; iprintf(\"%d\\t\",start++); printf(\"\\n\"); return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.LinkedHashSet; \nimport java.util.Set; \n \n \npublic class longestSequence { \n \n public static void main(String args[]) \n { \n  int arr[] ={1,2,6,3,4,5,1,2,3,7,8,13,14,15,16,23,1,4,6,7,9}; \n  Set mSet = new LinkedHashSet(); \n  mSet = longSequence(arr); \n  System.out.println(\" The longest sequence is as follows\"); \n  for(Integer elem: mSet) \n  { \n   System.out.print(elem+\"  \"); \n  } \n } \n  \n public static Set longSequence(int arr[]) \n { \n  Set returnSet = new LinkedHashSet(); \n  Set storeSet = new LinkedHashSet(); \n  int length=arr.length; \n   \n  for(int i=0;ireturnSet.size()) \n    {    \n    returnSet.clear(); \n    returnSet.addAll(storeSet); \n    } \n     \n    break; \n   } \n   } \n  } \n  return returnSet; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is same as previous question with little bit changed logic. Here is tested code in Java."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question is not very clear.. By longest sequence what does it mean.. If you are asking Longest Increasing Subsequence... U can use DP and solve in O(n^2) time and O(n) space complexity. :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void printLongestSequence(int[] arr) {   if(arr == null || arr.length == 0) {    System.out.println(\"Empty array\");    return;   }   String tempStr = arr[0] + \",\";   String maxStr = \"\";   for(int i =1; i< arr.length + 1; i++) {    if(i < arr.length && arr[i] == arr[i-1] + 1) {     tempStr += arr[i] + \",\";    } else {     if(tempStr.length() > maxStr.length()) {      maxStr = tempStr;      if(i < arr.length) {       tempStr = arr[i] + \",\";      }     }    }   }   System.out.println(maxStr.substring(0, maxStr.length() - 1));  }    public static void main(String[] args) {   printLongestSequence(new int[]{});   printLongestSequence(new int[]{1});   printLongestSequence(new int[]{1,2,3});   printLongestSequence(new int[]{1,2,3,7,8,9,10});   printLongestSequence(new int[]{1,2,3,7,8,9,10,13,14,15,16,17});  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int[] arr = new int[] { 2, 4, 6, 8, 9, 10, 11, 20, 22, 24, 25, 26 };             int start,end;             for (int j = 0; j < arr.Length-1; j++)             {                 if (arr[j + 1] == arr[j] + 1)                 {                     start = j; end = j;                     for (int t = start; (t <= end && t <= arr.Length-2); t++)                     {                         if (arr[t + 1] == arr[t]+1)                         {                             end = t + 1;                             j = end;                         }                     }                      Console.WriteLine(\"Sequences are\");                     for (int p = start; p <= end; p++)                     {                         Console.Write(arr[p]);                     }                     Console.ReadKey();                 }             }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static ArrayList findMaxSeq(ArrayList arr) {   if (arr.size() == 1)    return arr;      int maxlen = 1;   int max = 0;   int flag = 1;      int tmplen = 1;   int tmpmax = 0;   int tmpflag = 1;      int arrlen = arr.size();   int i;   for (i = 1; i < arrlen; ++i) {    if (java.lang.Math.abs(arr.get(i) - arr.get(i - 1)) == 1) {     tmpflag = arr.get(i) - arr.get(i - 1);     tmplen = tmplen + 1;;     tmpmax = arr.get(i);    } else if (tmplen > maxlen) {     flag = tmpflag;     maxlen = tmplen;     max = tmpmax;     tmplen = 0;    }   }      System.out.println(\"max:\" + max + \", maxlen: \" + maxlen);    ArrayList lst = new ArrayList();   for (i = maxlen; i >= 1; i--){    lst.add(max - (i - 1) * flag);   }      return lst;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/**   * @param args   */  public static void main(String[] args) {   /*Given an integer array, find the longest sequence and print it.*/   Integer[] input = {1,3,4,5,8,9,11,13,14,15,16,20,23,30,31,32};   List segment = new ArrayList();   int temp = segment.size();   List longestSegment = null;   for (int i = 1 ; i < input.length ; i++) {    segment.add(input[i-1]);    if(input[i] == input[i-1] + 1 ) {           continue;    }    else {         if(temp < segment.size()) {      temp = segment.size();      longestSegment = segment;     }          segment = new ArrayList();         }      }   System.out.println(longestSegment);      }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void LongestSequence() \n{ \n int arr[]={1,2,5,6,7,8,10,11,12,14,16,17,18,19,20}; \n int count=0,lastsize=0,head=0,lasthead=0; \n for(int i=1;ilastsize) \n   { \n    lastsize=count; \n    lasthead=head; \n   } \n   count=0; \n   head=i; \n  } \n } \n if(count>lastsize) \n { \n  lastsize=count; \n  lasthead=head; \n } \n for(int i=lasthead;i<=lastsize+lasthead;i++) \n  cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int[] arr = {1,2,3,4,4,5,6,7,8,9,20,11,12,4,7,10}; \n  int currsum = 0, sum = 1, end = 0; \n  for(int i = 0; i < arr.length; i++) \n  { \n   currsum = 1; \n   while(i != arr.length - 1 && (arr[i] + 1) == (arr[i+1])) \n   {     \n    currsum++; \n    i++; \n   } \n   if(currsum > sum) \n   { \n    sum = currsum; \n    end = i; \n   } \n  } \n  System.out.println(\"Max seq: \" + sum + \" start: \" + (end - sum + 1) + \" end: \" + end);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"# include \n \nvoid longseq(int *arr, int size) \n{ \n  int i; \n  int last= -1; /*The last element scanned from array */ \n  int max = 0;  /* Max sequence length */ \n  int pos;    /* For remmembering position where the longest sequence begins */ \n  int cnt; \n \n  for (i=0; i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n \nint main() \n{ \n int array[16] = {10,13,1,2,3,7,4,5,6,7,8,9,10,9,1,13},*ptr = array,count = 0,maxcount = 0,i,value = 0,index = 0; \n for(i =0 ; i<16;i++) { \n  count = 0; \n  if((array[i] +1) == array[i+1]) { \n   index = i; \n   while((array[i] + 1) == array[i+1]) { \n    count++; \n    i++; \n   } \n   if(count > maxcount) { \n    maxcount = count; \n    value = index; \n   } \n  } \n } \n for(i = value;i<=value +maxcount;i++)  \n  printf(\"value = %d\\n\",array[i]); \n return 0; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14942217","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"14","title":"Find the number of sequences in an integer array. A sequence is a list of numbers(more than one number) that comes in strict numerical order like [3, 4, 5, 6]. Please reply on manish.89july@gmail.com","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int compute(int arr[], int n) \n{ \n   int i=0, count; \n   while(i < n) \n   { \n      if(a[i+1] == a[i]+1) \n      { \n         count++; \n         while(a[i+1] == a[i])   i++; \n      } \n      else \n         i++; \n   } \n   return count; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"my understanding of the question is:  input: int[] a = {2,3,12,5,6,89,1,10,13,77,11,90} Output:  {1,2,3,} {5,6} {10,11,12,13} {89,90} am I correct?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sample Input   : [1, 3, 4, 5, 8, 9,  11, 13, 14, 15, 20, 23, 30,31,32,33] Sample Output: 4 sequences"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int compute(int a[],int n) \n { count=1;i=0; \n  while(i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If sorting is allowed than we can get the result in O(nlogn) time. Sample java code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int _tmain(int argc, _TCHAR* argv[]) \n{ \n int num_list[] = {1, 3, 4, 5, 8, 9, 11, 13, 14, 15, 20, 23, 30, 31, 32, 33}; \n int seq_count = 0; \n int seq_started = 0; \n \n for (int i = 0; i < sizeof(num_list) / sizeof(int) - 1; i++) \n { \n  if (num_list[i+1] == num_list[i] + 1) \n  { \n   if (seq_started == 0) \n   { \n    seq_count++; \n    seq_started = 1; \n   } \n  } \n  else \n  { \n   if (seq_started == 1) \n    seq_started = 0; \n  } \n } \n \n printf(\"%d sequences\", seq_count); \n  \n getchar(); \n \n return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void NumberOfSequences() \n{ \n int arr[]={1,2,5,6,7,8,10,11,12,14,16,17,18,19,20}; \n int count=0; \n bool IsSequence=false; \n for(int i=1;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int seq_in_array ( int* array, int size ) \n{ \n        // Initialize two begin and end pointers to the start of the array \n        int* begin_ptr = array; \n        int* end_ptr = array; \n \n        int  i,counter = 0; \n \n        if ( size == 0 || size == 1) \n        { \n                return size; \n        } \n         \n        else \n        { \n                for ( i = 0 ; i < size - 1; i++ ) \n                { \n                        if ( *(end_ptr+1) == *(end_ptr)+1 ) \n                        { \n                                end_ptr++; \n                        } \n                        else \n                        { \n                            if ( begin_ptr == end_ptr ) \n                            { \n                                begin_ptr++; \n                                end_ptr++; \n                            } \n                            else \n                            { \n                                end_ptr++; \n                                begin_ptr = end_ptr; \n                                counter++; \n                            } \n                        } \n                } \n            if ( begin_ptr != end_ptr ) \n                counter++; \n        } \n        return counter; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \nint main() \n{ \n int a[30],i=0,size,j=0,count=0,temp; \n cout<<\"enter the array size: \"; \n cin>>size; \n cout<<\"\\nenter the elements:\\n\"; \n while(i>a[i++]; \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int findseq(int a[],int size) { int count=0; while(--size) { if(a[i]==a[i+1]-1) continue; count++; } return count; }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14989772","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"2","title":"Test cases for finger print reader say in a laptop to login. Here you can swipe your finger to have a secured login. e.g. I will swipe my finger and the system will allow me to login.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Depends on the specs of the fingerprint reader, anyway here are some cases(can be valid or invalid based on what is allowed per spec)  1. Register any of your fingers(say thumb of your right hand). 2. Swipe with registered finger on log-in from locked screen. 3. Swipe with registered finger on log-in after restart. 4. Swipe registered hand in up-to-down, down-to-up, right-to-left, left-to-right, circular motion, wave it above without contact, with gloves on, with oily fingers etc. 5. Try with left thumb(counterpart of registered) with above scenarios. 6. Try with all other fingers of the hand. 7. Try with palm of hand. 8. Try with partial contact of registered finger - left portion up, right portion up, top portion up, bottom portion up 9. Try with back of the registered finger. 10. Try with registered composite keys(ex. more than one finger) this will spawn it's own set of scenarios. 11. Try swiping with registered or with unregistered fingers when user is logged in(not locked) 12. Try after screensaver locks the screen. 13. Try after installing updates for finger print reader software or other software. 14. Try with hardware updates. 15. Try with mold created from your registered finger. 16. Slow speed swipe, medium speed swipe, high speed swipe. 17. Try repeated locking and swiping to see if it stops working after a certain point. 18. Check in combination with other authentication options such as card reader. 19. Try when computer is in sleep mode. 20. Try after hitting ctrl + alt + del or without hitting those keys. 21. Try with power cord on or on battery mode"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Think in terms of code not use cases.!!!!! :P"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14952110","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"21","title":"Given an integer array, sort the integer array such that the concatenated integer of the result array is max. e.g. [4, 94, 9, 14, 1] will be sorted to [9,94,4,14,1] where the result integer is 9944141  Can we solve this in less than n square time?  n square algo is here  private bool isSwapNeeded(int i, int j)         {             int isum = i * (int)Math.Pow(10, NumberOfDigits(j)) + j;             int jsum = j * (int)Math.Pow(10, NumberOfDigits(i)) + i;              return isum > jsum;         }          private int NumberOfDigits(int i)         {             int noOfDigits = 0;                          if (i == 0)                 return 1;              while (i>0)             {                 noOfDigits++;                  i /= 10;             }              return noOfDigits;         }          public int[] MaximumConcatArray(int[] input)         {             int j;             for (int i = 1; i < input.Length; i++)             {                 j = i;                 while (j>=1 && isSwapNeeded(input[j],input[j-1]))                 {                     input[j] = input[j] ^ input[j - 1];                     input[j-1] = input[j] ^ input[j - 1];                     input[j] = input[j] ^ input[j - 1];                      j--;                 }             }              return input;         }","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"We can achieve O(n log n) time using a straight forward QuickSort or Merge Sort. The trick is with the comparison step of the sort. as detailed here: stackoverflow.com/questions/5037503/how-can-i-manipulate-an-array-to-make-the-largest-number  Its not as simple as comparing the elements of the array. When you comparing two integer elements x and y during the sort, compare the concatenation xy against the concatenation yx to figure out which is larger."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I did the following. Assuming the time complexity of sorting is O(n log n), the algorithm runs in O(n log n). However, it requires additional space for the string array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Here is the algorithm in which the numbers will be modified and then bring back to original. Consider an example. { 69, 8, 841, 89, 9, 941, 998, 854 }  Find the maximum - its 998.  Modify the numbers by making each number having same number of digits as the maximum is having. Repeat the last digit as many times required to convert it in a digit having same number of digits as the maximum. Here the array will become   { 699, 888, 841, 899, 999, 941, 998, 854 }  Sort the modified array. { 999, 998, 941, 899, 888, 854, 841, 699 }  Change the modified numbers back. { 9, 998, 941, 89, 8, 854, 841, 69 }  Concat from beginning to end. And you have the solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This soultion doesn't work properly, for example NumberOfDigits function will return 0 for the number 0 but we all know that every number contains at least one digit."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think you can use any comparison based sorting algorithm. The only thing needs to be changed is the comparison rule: for two integers a and b, a > b if ab > ba (here ab means concatenating a and b, eg. a = 9, b = 94, ab = 994).  Then we can use merge sort which achieves O(nlgn) time complexity."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Lets assume we have 'N' numbers and the largest one is some 'M' digits long. The following algorithm is inefficient but has a smaller time complexity in 'N'.  1- Go through the list once and separate the numbers based on first digit, which is 10 categories. C9 > C8 > ... > C1 > C0  2- For category Ci, the first digit is 'i'. Drop it and categorize again based on second digit. You get the categories Ci9 > Ci8 > ... > Ci0.  3- If the largest number is M digits, then you will at most have 10^M different categories. How ever, each time you do a sorting of at most \"N\" numbers, i.e., time complexity < O(N10^M ).  My point is you can do better than O(N log N) because this is not a generic sorting problem. For instance, lets assume all the numbers are single digit. Then the time complexity is obviously O(N). Just put all the 9's first, then 8's, ..., then 0's."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use Quick Sort instead of bubble sort. Also, Instead of concat and check , just check the significant digits and get the order !"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Doesn't for all cases"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Implemented along with a driver program in c++ at the link below.  stackoverflow.com/questions/5037503/how-can-i-manipulate-an-array-to-make-the-largest-number"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about storing the numbers in a trie ? The complexity would be o(n), but using some additional memory."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n#include \n#include \n#include \n \nusing namespace std; \n \nvoid reverseastring(char *s,int n) \n{ \n int l=0,r=n-1; \n while(latoi(strcat(s1,te))); \n \n   \n \n} \n \nmain() \n{ \n int n; \n cin >> n; \n int a[2010]; \n char s[2010]; \n int i; \n for(i=0;i> a[i]; \n } \n char s1[2010]; \n \n sort(a,a+n,compar); \n for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about just sorting the array , keep index where number of digits increase :   so : 4,94,9,14,1 -> 1,4,9,14,94 using quick\\merge sort ( nlogn )  set index \"2-digit\" to 3 , meaning in position 3 in the array , we start 2 digit's number and so on.  now - start concatenating number :biggest 1 digit with biggest 2 digit and so on.  continue with how many numbers you have."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. convert it into string. since a integer type has limited range. we can regard it to be O(n). 2. construct a trie tree. the internal order should be from 9 to 0. it takes n * avg-length, as stated above, we roughly consider it to be n 3. dfs trie tree. on a single path we print the node that terminated earlier first. the total number of nodes is no more than n * avg-length.  So we have O(3 * max-length * n)  = O(n) where max-length is 10 if int32"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Still Use QuickSort. The only difference is comparison condition."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14952108","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"0","title":"write the test cases for the Swiping Pad ....??"}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14922189","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"7","title":"Write positive test cases to test this function bool FileCopy(string source, string destination)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"(NULL, NULL) returns false  (NULL, Valid String) returns false  (Valid String, Valid String with dest already exists) returns false  (Valid String, Valid String with dest doesn't exist) returns true (Valid string with src doen't exist. *) returns false  (Empty src file, Non-existing dest file ) returns true (Large file, Non-existing dest file ) returns true (Source File with different format,  Non-existing dest file ) returns true"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here a case like:  (Large file, Non-existing dest file), should return false,  as destination will not have the copy space for the large src file  Few more test cases could be: (User doesn't have access right to the src, but only to the destination)  (Valid src access right, Valid Dest) - Returns True (Valid src with no access right, Valid Dest) - Returns false  -"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here a case like:  (Large file, Non-existing dest file), should return false,  as destination will not have the copy space for the large src file  Few more test cases could be: (User doesn't have access right to the src, but only to the destination)  (Valid src access right, Valid Dest) - Returns True (Valid src with no access right, Valid Dest) - Returns false"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Could we include a test case for verifying date/time of copy ?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14946831","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"23","title":"Write code using commands below for two rovers to meet. Two rovers are dropped on Mars. Imagine Mars to be a straight infinite plane. When the rovers are dropped on Mars they are dropped with parachute. So their initial position on Mars is on parachute.   Only commands possible to execute: 1. Go left 2. go right 3. NO OPERATION 3. If on parachute go to lablel.  Label can be a piece of code with a name where we can transfer execution  Using ONLY commands above write code for rovers to meet.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"The logic is that make the both the rover go in the same direction either left or right . Make its speed slow by putting a NOP after every left command. And whenever a rover reaches a parachute , it will know that the other rover is ahead of it.So in this rover dont execute the NOP making its speed faster .Hence the rover behind will get fast and meet up with the other rover."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"// Suppose meet is the function that will be executed on both rovers Void meet(){      bool reachedParachute = false;      while(true){              goto left              If on parachute go to label1              if(reachedParachute)                      goto right              else                      goto left              }  label1 :             reachedParachute = true;             No Operation"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the only condition under which this may not work is when both land at the exact same time (because then they'll execute the exact same thing at the exact same time and hence will never meet)  #define NOT_MET_YET 1 int i, steps; steps=0; while(1) {    If on parachute go to LABEL_START;    NO OPERATION; }  LABEL_START:  while(NOT_MET_YET) { // whats the check to see if they've met ??    for(i=0; i   for(i=0; i    for(i=0; i   for(i=0; i   i++; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You cant use for loops or any other variables. Only allowed commands are listed in my question. I got the logic right on this one, but i could not code it. Here is the logic \" Both rovers land. Then move both to left. Eventually one of them will land on the parachute of other. Then make the one on parachute stop (no operation) and move just the other to right.\" This is the logic he asked me to code, but i couldnt using just commands above."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Few questions: 1. Do both rovers land at the same time? 2. If i choose a command will both both rovers follow it simultaneously or is there turn pattern? Like if i choose to 'Go Left' then both will move to left at the same time?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"With no loops or counters, go back to your basic finite state machine coding:  Let the phrase LEFT expand to: go left; @label if on_parachute goto @label; go right; (that is: step left, stop if parachute, else go back) and LEFT(n) expand to: {go left; @label if on_parachute goto @label;} ^n {go right;} ^n (that is: step and test 'n' times to the left, then return) Define RIGHT(n) similarly.  since we cannot loop or keep state: program each rover as: LEFT(1); RIGHT(2); LEFT(4); RIGHT(8); ... up to diameter of Mars  (right, that was give as infinite, so impress your interviewer by reminding them that a finite state machine cannot search an infinite space; we do not have a turing machine or even a stack machine...)  What it does:  Each rover take increasingly longer excursions to left and then to right, but will stop when it find the parachute of the other rover (and wait there) eventually, the other rover will come back to its own parachute and meet the one waiting there. Note: the numbers 1,2,4 can be scaled to any arbitrarily large/ascending values.  @MJ:  if the rovers collide on landing, then the post-condition is immediately satisfied: the rovers meet."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If we have goto label then it'll be like this (r1:=rover1, r2:=rover2):  r1.goLeft r2.goLeft :loop if r1.onParachute goto r1p if r2.onParachute goto r2p r1.goLeft r2.goLeft goto loop :r1p r1.noOp r2.goRight if r2.onParachute goto end goto r1p :r2p r2.noOp r1.goRight if r1.onParachute goto end goto r2p :end  but if I can't use goto without if onParachute then it's problematic"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if(onParachute) goto label execute_code  execute_code : static int count; count++; if(count<3)  // on landing each rover visit the label therefore count =2 { while(1)    {        go left;       no operation;  //to make the rover slow     } } else if(count ==3) // one rover has reached others parachute { while(1) go left; } else ; //count can never be 4"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"GO LEFT IF(ON PARACHUTE) GO TO X  X: GO LEFT GO LEFT"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"main: GO LEFT IF(ON PARACHUTE)        GOTO X GOTO main X: GO LEFT GO LEFT GOTO X"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package test.command.test; \n \nimport test.command.ControlStation; \nimport test.command.Planet; \nimport test.command.model.Cell \n \npublic class TestKlass { \n  \n public static void main(String[] args) { \n \n  ControlStation station = new ControlStation(); \n   \n  String firstLine =\"5 5\"; \n   \n  String secLine =\"1 2 N\";   \n  String command = \"LMLMLMLMM\"; \n   \n  Planet planet = station.getData(firstLine, secLine); \n  Cell cell =station.processCommand(planet, command);  \n  System.out.println(\"[\"+cell.getX()+\", \"+ cell.getY()+\", \"+cell.getDir()+\"]\"); \n   \n  String secLine1 =\"3 3 E\";   \n  String command1 = \"MMRMMRMRRM\"; \n  Planet planet1 = station.getData(firstLine, secLine1); \n  cell =station.processCommand(planet1, command1);  \n  System.out.println(\"[\"+cell.getX()+\", \"+ cell.getY()+\", \"+cell.getDir()+\"]\"); \n   \n } \n} \npackage test.command.model; \n \npublic class Grid { \n private int[][] layout = null; \n private int xMax;  \n private int yMax;  \n public Grid(int xMax, int yMax) { \n  this.layout = new int[xMax][yMax];  \n  this.xMax = xMax; \n  this.yMax = yMax; \n } \n public int[][] getLayout() { \n  return layout; \n } \n public int getXMax() { \n  return xMax; \n } \n public int getYMax() { \n  return yMax; \n } \n public boolean xbound(int xx){ \n  if(xx >=0 && xx <= xMax){ \n   return true; \n  } \n  return false;   \n } \n public boolean ybound(int yy){ \n  if(yy >=0 && yy <= yMax){ \n   return true; \n  } \n  return false;   \n } \n} \npackage test.command.model; \n \npublic class Cell { \n private int x; \n private int y; \n private String dir; \n public Cell() {} \n public Cell(int x, int y,String dir) { \n  this.x=x;this.y=y;this.dir =dir;   \n } \n public int getX() { \n  return x; \n } \n public void setX(int x) { \n  this.x = x; \n } \n public int getY() { \n  return y; \n } \n public void setY(int y) { \n  this.y = y; \n } \n public String getDir() { \n  return dir; \n } \n public void setDir(String dir) { \n  this.dir = dir; \n } \n} \npackage test.command; \n \nimport test.command.model.Cell; \nimport test.command.model.Grid; \n \npublic interface RoverSignal { \n public Cell getPosition();  \n public void setPosition(Cell position); \n public Remote getRemote(); \n public void setRemote(Remote remote); \n public Grid getGrid(); \n public void setGrid(Grid grid); \n} \npackage test.command; \n \nimport test.command.model.Cell; \nimport test.command.model.Grid; \n \npublic class Rover implements RoverSignal{ \n private Cell position;  \n private Remote remote = null; \n private Grid grid = null; \n public Rover(){ \n  this.remote = new RemoteImpl(); \n } \n public Rover(Grid grid ){ \n  this.grid = grid; \n  this.remote = new RemoteImpl(); \n }  \n private class RemoteImpl extends RemoteConfig implements Remote { \n   \n  public RemoteImpl() { \n   super(); \n  } \n  @Override \n  public void leftRotate(Cell cell) { \n   String dir = cell.getDir();    \n   cell.setDir(leftRotateMap.get(dir)); \n   setPosition(cell); \n  } \n  @Override \n  public void move(Cell cell) { \n   String dir = cell.getDir(); \n   if(dir.equals(\"N\")){ \n    if(grid.ybound(cell.getY()+1)) \n     cell.setY(cell.getY()+1);      \n   }else if(dir.equals(\"S\")){ \n    if(grid.ybound(cell.getY()-1)) \n     cell.setY(cell.getY()-1); \n   }else if(dir.equals(\"E\")){ \n    if(grid.xbound(cell.getX()+1)) \n     cell.setX(cell.getX()+1); \n   }else if(dir.equals(\"W\")){ \n    if(grid.xbound(cell.getX()-1)) \n     cell.setX(cell.getX()-1); \n   } \n   setPosition(cell);return; \n  } \n  @Override \n  public void rightRotate(Cell cell) { \n   String dir = cell.getDir();    \n   cell.setDir(rightRotateMap.get(dir)); \n   setPosition(cell); \n  } \n \n } \n \n public Cell getPosition() { \n  return position; \n } \n public void setPosition(Cell position) { \n  this.position = position; \n } \n public Remote getRemote() { \n  return remote; \n } \n \n public void setRemote(Remote remote) { \n  this.remote = remote; \n } \n \n public Grid getGrid() { \n  return grid; \n } \n \n public void setGrid(Grid grid) { \n  this.grid = grid; \n } \n} \npackage test.command; \n \nimport java.util.HashMap; \nimport java.util.Map; \n \npublic class RemoteConfig { \n protected Map leftRotateMap = null; \n { \n  leftRotateMap = new HashMap(); \n  leftRotateMap.put(\"N\", \"W\"); \n  leftRotateMap.put(\"W\", \"S\"); \n  leftRotateMap.put(\"S\", \"E\"); \n  leftRotateMap.put(\"E\", \"N\"); \n \n } \n protected Map rightRotateMap = null; \n { \n  rightRotateMap = new HashMap(); \n  rightRotateMap.put(\"N\", \"E\"); \n  rightRotateMap.put(\"E\", \"S\"); \n  rightRotateMap.put(\"S\", \"W\"); \n  rightRotateMap.put(\"W\", \"N\"); \n \n } \n public RemoteConfig() { \n  // TODO Auto-generated constructor stub \n } \n \n} \npackage test.command; \n \nimport test.command.model.Cell; \n \npublic interface Remote { \n public void move(Cell cell); \n public void leftRotate(Cell cell); \n public void rightRotate(Cell cell); \n \n} \npackage test.command; \n \nimport test.command.model.Grid; \n \npublic class Planet { \n private Grid grid; \n private Rover rover; \n private Grid[] grids; \n private Rover[] rovers; \n public Planet() {   \n } \n public Planet(Grid[] grids, Rover[] rovers) { \n  this.grids = grids; \n  this.rovers = rovers; \n } \n public Planet(Grid grid, Rover rover) { \n  this.grid = grid; \n  this.rover = rover; \n } \n public Grid getGrid() { \n  return grid; \n } \n public void setGrid(Grid grid) { \n  this.grid = grid; \n } \n public Rover getRover() { \n  return rover; \n } \n public void setRover(Rover rover) { \n  this.rover = rover; \n } \n public Grid[] getGrids() { \n  return grids; \n } \n public void setGrids(Grid[] grids) { \n  this.grids = grids; \n } \n public Rover[] getRovers() { \n  return rovers; \n } \n public void setRovers(Rover[] rovers) { \n  this.rovers = rovers; \n }  \n} \npackage test.command; \n \nimport test.command.model.Cell; \nimport test.command.model.Grid; \n \npublic class ControlStation { \n private Planet planet; \n private String[] commands; \n private Grid grid; \n public Cell processCommand(Planet planet, String command){ \n  if(null == command || null == planet)return null; \n  Cell cell = null; \n  RoverSignal roverSignal = planet.getRover(); \n  Remote remote = roverSignal.getRemote(); \n  cell = roverSignal.getPosition(); \n  char[] comArray = command.toCharArray(); \n  for (char c : comArray) { \n   if('L' == c){ \n    remote.leftRotate(cell); \n   }else if('R' == c){ \n    remote.rightRotate(cell); \n   }else if('M'==c){ \n    remote.move(cell); \n   } \n  } \n  return cell; \n } \n public Planet getData(String firstLine, String secLine){ \n  Cell cell = getCell(secLine); \n  Grid grid = getGrid(firstLine); \n  Rover rover = new Rover(); \n  rover.setGrid(grid); \n  rover.setPosition(cell);   \n  return new Planet(grid,rover); \n   \n } \n private Cell getCell(String secLine){ \n  String[] arr = secLine.split(\"\\\\s+\"); \n  int xx= Integer.parseInt(arr[0]); \n  int yy= Integer.parseInt(arr[1]);   \n  return new Cell(xx, yy, arr[2]); \n } \n private Grid getGrid(String firstLine){ \n  String[] arr = firstLine.split(\"\\\\s+\"); \n  int xMax= Integer.parseInt(arr[0]); \n  int yMax= Integer.parseInt(arr[1]); \n  return  new Grid(xMax, yMax); \n } \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14954737","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"57","title":"Given an array, find all maximal sub-arrays in which all pairs have their sum greater than k. DP would give us a O(n^2) algorithm. Can we do better.  suppose k = 4  -4 9 10 4 -3 8 9 -2  Answer is: -4 9 10 9 10 4 -3 8 9 8 9 -2","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"10","title":"This can be done in O(N*log(N)) time using a min-heap or O(N) using a dequeue.  Basically, the algorithm works like this: for each index i in the array computes the longest subarray that ends at position i and satisfies the requested condition.  Now, let's consider we're at index i, and [j ... i-1] is the longest subarray found in the previous iteration (for i-1). In order to compute the subarray for this iteration we need to find the smallest j' >= j such that min(a[j'], .., a[i-1]) + a[i] >= K.  Now, the trick is how to find j' efficiently. A first approach is to use a min-heap and start with j' = j and then increment j' and remove element a[j'] from heap until the condition holds (or you reach i). Since j is incremented at most N times => there are a total of N calls to heap.remove_element. Since i is incremented N times => there are N calls to heap.insert_element. => final complexity O(N*log(N)).  A second approach, which is a little bit trickier (I suggest getting a pen and paper for this) is using a deque instead of heap. The constructed deque will have these important properties: - in the front of the deque is index of the minimum element in seq [j..i-1] (just like the heap) - the second element is the index of the minimum element in the sequence that remains after removing the first minimum along with the elements in front of it;   - and so on. So basically if  dequeue = [m1, m2, ...] then the initial sequence looks like this [j ... m1 ... m2 ... i-1], and: - m1 is the index of minimum of sequence [j .. i-1],  - m2 is the index of minimum of sequence (m1 .. i-1] (please note that the interval is open at m1)  I won't explain how you perform the operations on the dequeue in order to prserve those properties (try to think them yourself or look at the code / if you have any questions feel free to ask). You have the implementation below for the time-optimal (dequeue) solution. The methods for updating the deque are push(i) - updates the deque by adding element a[i] and popBadMins() which removes minimums from dequeue and returns the new j'.  Friendly advice: If you're not familiar with dequeue trick, I suggest you try to understand it because it proved to be helpful in programming contests."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Also Palantir?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"And are you looking for a *maximum length* sub-array?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use two pointers with a min-heap. Everytime when inserting into heap, check if new element + min-element < k. If so, print from begin to end. Update begin to min-element position. Update end to new-element position. If not, add it to heap, update end position.  With code it should be more clear:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I still could not understand the problem. For the first example   suppose k = 4 -4 9 10 4 -3 8 9 -2  Answer should be: -4 9 10 4 --> -4+9, 9+10, 10+4 are all greater than k=4 -3 8 9 -2 --> -3+8, 8+9, 9+-2 are all greater than k=4  in my opinion. Am I correct?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Suppose A being a subarray which already holds the criteria, and p is the adjacent member to A, currently being checked.   if p+min1 >= k /*and p+min2 >= k*/ add p to the A,  update min1 /*and min2 values. */  where min1 is the smallest member of A /* min2 is the smallest member of A which is greater than or equal to min1. */  O(N)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Still it is not clear  [ -4,9 ] [9, 10]  [10,4]  [8,9] [9, -2]  why these sub arrays are not part of answers, is there any constraint on length of sub array ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Still it is not clear  [ -4,9 ] [9, 10]  [10,4]  [8,9] [9, -2]  why theses sub arrays are not part of answers, is there any constraint on length of sub array ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void PrintMax(int *a, int length, int k) \n{ \n int start = 0; \n int delta = k-a[start]; \n int end = 0; \n int i = 1; \n int maxend = 0; \n int counter=0; \n while(i < length) \n { \n  counter++; \n  int cur = a[i]; \n  if(cur >= delta ) \n  { \n   end = i; \n   int tempDelta = k-cur; \n   if(tempDelta > delta) \n    delta = tempDelta; \n   i++; \n  } \n  else \n  { \n   if(end > maxend) \n   { \n    cout<<\"\\n Sub array...\"; \n    for(int j = start;j<=end; j++) \n     cout<<\" \"< maxend) \n { \n  cout<<\"\\n Sub array...\"; \n  for(int j = start;j<=end; j++) \n   cout<<\" \"<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i made a code to work it out .. complexity is surely less than O(n^2) . Please prove my code wrong because i haven't used either min heap or dequeue to solve it . :)  #include   using namespace std; void display(int B[],int n) {      if(n>1)      {      for(int i=0;i     cout<     }      cout<<\"\\n\";        } int main() {     int A[12]= {1,2,3,4,5,-5,1,2,3,4,5,-5};     int B[10];     int k,i=1;     int check=1;     int min=0,count=1,flag=0;     cout<<\"Enter k\\n\";     cin>>k;     B[0]=A[0];    while(i<12) // 12 is harcoded .. take n instead    {                            if(A[min]+A[i]>k)   //to check if the condition satisfies              {              if(i>=check) flag=1;  //minimum index to counter(to exclude any minimal subset)              if(A[i]             min=i;              B[count]=A[i];              count++;          //total count in sub-array              i++;}                    else              { if(flag==1)  //if displayable ( new elements added)                {display(B,count);flag=0;check=i;} // it should not be displayed till the index i is rediscovered again                {min=min+1;B[0]=A[min];i=min+1;count=1;}              }                   }    if(flag==1)     display(B,count);    system(\"pause\");    return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This is a standard maximum sub array problem, running time O(nlogn): Algorithm: _ recurse on the left_array from low to mid _ recurse on the right_array from mid+1 to high _ Find maxArray recursively on the mid_array from low to high _ compare each of the value to k and see which one is bigger than k, return  findMaxArray for mid: start from mid to low find the largest sum start from mid + 1 to high find the largest sum return totalsum and the index of left and right.  Here is the concrete example written in python:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"o(n*logn) for contiguous sub-array:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"This comment has been deleted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"We can sort the array in n log(n) time and then for each element 'a' in the array we can use binary search to find 'k-a' in the array in log(n) time...even if we dont find the 'k-a' the elements on the right of the index at the end of the search would have sum greater than k....the order of the algo will be n log(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"If it's just to find \"one\" sub-array, it's easy. Just parse the array and find the two largest numbers. Then check if the sum of these two largest numbers is greater than k, return these two numbers if it does. o(N)  If it's to find the sub-array with most elements which satisfies this condition, it'll need slightly more work. o(NlogN) ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"Easy solution - Remember, you can only have one element in the sub-array be less than half of 'k,' and when that happens the other elements have to be big enough to accommodate.   The worst case for my solution is '2n', where 'n' is the length of the longest subarray. The worst case happens when the smallest element is at the tail of the subarray."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14922694","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"16","title":"Write a  program to swap odd and even bits of a 32-bit unsigned integer with as few instructions as possible. (bit-0 and bit-1 are swapped, bit-2 and bit-3 are swapped and so on)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"16","title":"N = (N & 0xAAAA)>>1 | (N & 0x5555)<<1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"With comments: \n \n                int x = 33;    \n  int res1 = (x & 0xAAAAAAAA) >> 1; // clear every even bit \n  res1 >>= 1; // shift right  \n   \n  int res2 = x & 0x55555555; // clear every odd bit \n  res2 <<= 1; // shift left \n   \n  int res = res1 | res2; \n   \n  System.out.println( Integer.toBinaryString(x) ); \n  System.out.println( Integer.toBinaryString(res) );"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can anyone explain how?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"With comments:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is one option  -  int Reverse(int Data) { int i,j; int res  = 0;       for(i = 0 ,j =0; i < 32;i++)       {           if((i%2) == 0) // even           {            j = i +1;           }           else            {             j = i -1 ;           }                    res |= (((Data >> i) & 0x01 ) << j);        }       return res; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int swapOddEven(int num) {     return (num&2863311530)/2 + (num&1431655765)*2; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"unsigned int Swap_Bits(unsigned int N) \n{ \n unsigned temp1,temp2; \n unsigned mask = 0x55555555; \n temp1 = ((N&mask)<<1);//Move bit 1,3,5...31 to 2,4,...32 \n temp2 = ((N&(mask<<1))>>1);//Move bit 2,4,6 ... 1,3,5... \n return (temp1 | temp2 ); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"unable to understand the logic.... can anyone of you explain???"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class SwapBit { \n //num is unsigned, 32 bit \n public static int swapBit(int num){ \n  int odds = (0xAAAAAAAA & num) >> 1; \n  int evens = (0x55555555 & num) << 1; \n  return odds | evens; \n } \n /** \n  * @param args \n  */ \n public static void main(String[] args) { \n  System.out.println(swapBit(5)); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What is the need of masking? We can simple left shift and right and finally do OR operation."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void main() { int n,i,j,r,s,m=0; printf(\"enter the 32 bit integer(i.e 8digits)\"); scanf(\"%d\",&n); r=n; while(r!=0) { r=r%10; s=r%10; m=m*100+s*10+r; r=r/10; } printf(\"%d\",m); }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14921674","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"10","title":"Design a game of Tic-Tac-Toe. Only instead of 3x3, this is a game on n x n board. Two manual players play the game. A player wins if there are all \"X\" or all \"O\" in either of n rows, n columns or 2 diagonals. What are the classes and data structure you will define? After each move/turn of a player, it is checked whether the player won the game. Minimize this time. Assume having no space constraint.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"Have an int double array (n x n) For every row and column, have three extra fields 1. Corrupted (If this row or column is filled by both players atleast once) 2. First move (Who filled the row/column first - 1 or 2) 3. No.of blocks filled (Count) All are initialized to zero. You have player1 and player2 When a player makes an entry, you have to check those 3 variables in corresponding row and column. Follow the following steps: 1.  If corrupted is true, you need not worry 2. If the person who made the move now !=  first person, corrupted = true and jump off 3. No.of blocks++ , If no.of blocks == N, this player has won. End of story :D"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Use NxN int matrix and 2N + 2 integers representing the sum of N cols, N rows and 2 diagonals. Player 1's choices will be marked as 1. Player 2's choices will be marked as -1. Add that mark (+-1) to the relevant row/col/diag counters. Player 1 wins if after adding the mark the row/col/diag is sum is N. Player 1 wins if after adding the mark the row/col/diag is sum is -N. They draw if matrix is full.  Calculating game result is immediate."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we can use 2D matrix intialised with zeros and then when ever a player plays make the corresponding entry to be equal to 1,..winning condition is class that does the job of row sum...it can store the row sum and use it later..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For every row/column, maintain a field called SUM. When player 1 marks, add 2 to the sum, when player2 marks, add 5 to the sum. If the sum ever reaches 2*N, then player 1 win, If the sum reachers 5*N, then player 2 wins. We only need to check/update the sum for the row/column where the last player has played.  Note: instead of 2,5 we can use any two numbers which are relatively prime."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14913670","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"30","title":"Given a positive integer, decode it into a string in following way :- 1 - a, 2 - b,3 - c,...26 - z, 27 - aa, 28 - ab........and so on.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"#include void convert( unsigned int ); int main() {   unsigned int num = 0;   printf(\"Enter number: \\n\");   scanf(\"%u\", &num);   convert(num);   printf(\"\\n\");   return 0; }  void convert(unsigned int num) {   int remainder;   if (num <= 26)     printf(\"%c\", num -1 + 'a');   else {     remainder = num % 26;     if(remainder == 0) {       convert(num/26-1);       printf(\"%c\", 'a');     }     else {       convert(num/26);       printf (\"%c\", remainder -1 + 'a');     }   }   return; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public static final byte OFFSET = 97; \n public static final byte ALPHA_SIZE = 26; \n  \n public static String encodeString(int n) \n { \n  StringBuilder builder = new StringBuilder(); \n   \n  while (n > 0) \n  { \n   char encodedChar = (char) (((n - 1) % ALPHA_SIZE) + OFFSET); \n   builder.append(encodedChar); \n   n = (n - 1) / ALPHA_SIZE; \n  } \n   \n  return builder.reverse().toString(); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A solution in Python 2."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Fixed solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hers is the java code:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How to differentiate between the two cases: Input : 27 Expected Output 1 = aa Expected Output 2 = bg (2->b, 7->g) ???"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Java based recursive solution:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  #include  #include   #define base 26  using namespace std; typedef map dictionary;  string notEdgeCase(int num, dictionary dict){      bool needReverse = false;     string output;     while( num > base && num % base != 0){         output.append(1, dict[num % base]);         num = num/base;         needReverse = true;     }      if(num % base !=0 && num < base){         output.append(1, dict[num]);     }      // Reverse the string and then return     if(needReverse){         int length = output.length() - 1;         int temp = 0;         char ch;          for(; temp            ch = output[temp];             output[temp++] = output[length];             output[length--] = ch;         }     }      return output; }   int main(){     int inputNumber = 707;     dictionary localDict;     int count = 1;     int temp = 1;;     string result;      // Initialize the dictionary     for(int i=97; i<=122; i++){         localDict[count++] = i;     }      if(inputNumber == 0){         result.append(\"Invalid Number passed\\n\");     }     else if(inputNumber <= base){         result.append(1, localDict[inputNumber]);     }     else if(inputNumber%base == 0 && inputNumber>0){         temp = inputNumber/base;         result = notEdgeCase(temp -1, localDict);         result.append(1, 'z');     }     else{         result = notEdgeCase(inputNumber, localDict);     }      cout << \"Output: \" << result << endl;      return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void decode(int n){  \n        char ch;  \n        if( n < 26) { \n                ch = 'A' + n; \n                cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.io.*;  class microsoftQ { public static void main(String args[]) throws IOException {  BufferedReader br=new BufferedReader(new InputStreamReader(System.in));  System.out.println(\"Enter the number \");  int i=Integer.parseInt(br.readLine());  int d=i/26;    int mod=i%26;  int l=d-1;  String s=\" \";  int c=0;   while(c<=l)  {  s+=\"a\";  c++;  }   switch(mod)  {  case 1:s+=\"a\";  break;  case 2:s+=\"b\";  break;  case 3:s+=\"c\";  break;  case 4:s+=\"d\";  break;  case 5:s+=\"e\";  break;  case 6:s+=\"f\";  break;  case 7:s+=\"g\";  break;  case 8:s+=\"h\";  break;  case 9:s+=\"i\";  break;  case 10:s+=\"j\";  break;  case 11:s+=\"k\";  break;  case 12:s+=\"l\";  break;  case 13:s+=\"m\";  break;  case 14:s+=\"n\";  break;  case 15:s+=\"o\";  break;  case 16:s+=\"p\";  break;  case 17:s+=\"q\";  break;  case 18:s+=\"r\";  break;  case 19:s+=\"s\";  break;  case 20:s+=\"t\";  break;  case 21:s+=\"u\";  break;  case 22:s+=\"v\";  break;  case 23:s+=\"w\";  break;  case 24:s+=\"x\";  break;  case 25:s+=\"y\";  break;  case 26:s+=\"z\";  break; }   System.out.println(\"the string to be printed is \"+s); } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Nearly all of these solutions are overcomplicated.  This should only require a division and a modulo operation."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import math \n \ndef computeString(n): \n    if not n: \n        return 'Invalid Input'; \n \n    result = '' \n    occurrences = int(n/27) \n    if occurrences: \n        result += 'a' * occurrences \n \n    last = n % 27 \n    if last: \n        result += chr(96 + last) \n    return result \n \ndef main(): \n    assert computeString(26) == 'z' \n    assert computeString(0) == 'Invalid Input' \n    assert computeString(1) == 'a' \n    assert computeString(53) == 'az' \n    assert computeString(54) == 'aa' \n \nif __name__ == '__main__': \n    main()"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Answer = convert(rank - 1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* Given a positive integer, decode it into a string in following way :- 1 - a, 2 - b,3 - c,...26 - z, 27 - aa, 28 - ab........and so on. */ #include using namespace std; int main() {     int n;     cin>>n;     char array[26];     for(int i=0;i<26;i++)     array[i]=97+i;     string x;     while(n!=0)     {         char c=array[n%26-1];         x=c+x;                 n/=26;     }         cout<<    system(\"pause\");     return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include   // Author : Jeevan B.Manoj, TKMCE \n#include \nusing namespace std; \nint main() \n{ \n    int x,flag=0; \n    char c=96,str[100]; \n    cout<<\"\\nEnter value of x  \"; \n    cin>>x; \n    int p=0; \n    str[0]=c; \n    str[1]='\\0'; \n    while(1) \n    { \n        for(int i=1;i<=26;i++) \n        { \n            flag=0; \n            c=str[p]; \n            c++; \n            str[p]=c; \n            str[p+1]='\\0'; \n            x--; \n            if(x==0) \n            { \n                flag=1; \n                break; \n            } \n        } \n        if(flag) \n            break; \n        str[p]=97; \n        p++; \n        str[p]=96; \n        str[p+1]='\\0'; \n    } \n    cout<<\"\\n\"<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \n \nusing namespace std; \n \nvoid convert(int a) \n{ \nif(a!=0) \n{ \n                 int n=a%26; \n                 if(n!=0) \n                 { \n                 convert(a/26); \n                 cout<<(char)(96+n); \n                 } \n                 else \n                 {convert((a/26)-1); \n                 cout<<\"z\"; \n                 } \n              \n}                \n} \nint main() \n \n{ \n     \n    int a; \n    cout<<\"Enter number\"; \n    cin>>a; \n    convert(a); \n    system(\"pause\"); \n    return 0; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include  \nusing namespace std; \n \nint convert(int num) \n{ \n        int t1=0,t2=0; \n        \n          \n        if (num <= 26) \n        { \n            cout<< char('a'+num-1); \n        } \n        else \n        { \n            t1=num%26; \n            t2=(num/26); \n             \n            if (t2 > 26) \n            { \n                t2=convert(num/26); \n            } \n             \n            cout<> num; \n    convert(num); \n return 0; \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void convert(int num) \n{ \n    if(num==0) \n        return; \n     int j = num % 26; \n    convert(num/26); \n    printf(\"%c\",j+96);     \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n \nusing namespace std; \nvoid convert(int n) \n{ \n if(n<=0) \n     return; \n if(n<=26) \n   printf(\"%c\",'a'+ n-1); \n else{ \n      convert(n/26); \n      convert(n%26); \n      } \n} \nint main() \n{ \n   int a; \n   while(1) \n   { \n   cout<<\"INPUT=>\"; \n   cin>>a; \n   if(a==0) \n      break; \n   convert(a); \n   cout<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class DecodeInteger { \n \n public static char[] array; \n \n static { \n  array = new char[27]; \n  array[0] = 0; \n  for (int i = 1; i < 27; i++) { \n   array[i] = (char) (i + 96); \n  } \n } \n \n public static void decodeInt(int num) { \n  int remainder; \n  if (num <= 26) { \n   System.out.print(array[num]); \n  } else { \n   remainder = num % 26; \n   if (remainder == 0) { \n    decodeInt(num / 26 - 1); \n    System.out.print(\"z\"); \n   } else { \n    decodeInt(num / 26); \n    System.out.print(array[remainder]); \n   } \n  } \n } \n \n public static void main(String[] args) { \n  decodeInt(26); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"what will be the  out put??  #include #define SQR(x) (x*x) int main(){     int a,b=3;     a= SQR(b+2);     printf(\"%d\",a);     return 0; }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14922673","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"8","title":"Given today is Thursday and 23rd August, 2012. Write a function to input a date (future or past) and tell which day it is:- int day_of_week(int dd, int mm, int yyyy) Mon -1, Tue - 2, Wed -3......Sun-7","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"you just have to calculate the number of days present between two dates. For example let the date be 10 dec 2013.No of days between two date is 474(do keep note of leap year :)).Then apply modulo 7 on number of days.In this case it will be 5.add 5 to to the thursday it will become tuesday.Similar will be logic fo past date"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"More concise way: just compute the number of days (relative to 0th year) for both the given date and the user-input date separately. Of course needs to take care of leap years in the computation, but that is easy. Then simply do a minus to find the difference in number of days from the given date. Then play around the difference mod 7  to map to a day of week."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using ashishanand's logic i made this code.Works fine :-"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the code is not concise"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.Calendar; \nimport java.util.GregorianCalendar; \n \npublic class ParseDate { \n \n /** \n  * Given today is Thursday and 23rd August, 2012. Write a function to input \n  * a date (future or past) and tell which day it is:- int day_of_week(int \n  * dd, int mm, int yyyy) Mon -1, Tue - 2, Wed -3......Sun-7 \n  */ \n \n public static int day_of_week(int dd, int mm, int yyyy) { \n  Calendar cal = new GregorianCalendar(); \n  cal.set(yyyy, mm, dd); \n   \n  Calendar today = new GregorianCalendar(); \n  today.set(2012, 7, 23); \n   \n  int diff = 4; \n  if (today.compareTo(cal) < 0) { \n   while (today.compareTo(cal) != 0) { \n    today.add(Calendar.DAY_OF_YEAR, 1); \n    diff = (diff + 1) % 7; \n    if (diff == 0) { \n     diff = 7; \n    } \n   } \n  } else if (today.compareTo(cal) > 0) { \n   while (today.compareTo(cal) != 0) { \n    today.add(Calendar.DAY_OF_YEAR, -1); \n    diff = (diff - 1) % 7; \n    if (diff == 0) { \n     diff = 7; \n    } \n   } \n  } else { \n   ; \n  } \n  System.out.println(diff); \n  return 0; \n } \n \n public static void main(String[] args) { \n  day_of_week(1, 6, 2012); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include   using namespace std;  /*  Harcoded Today's Given Date 27/08/2012  Day Monday  */ class date {       int dd,mm,yyyy;        public:              date(int d,int m,int y)       {dd=d;mm=m;yyyy=y;}              void compute_day();        };  void date :: compute_day() {      int count_year=0,count_days=0;      int year=yyyy,month=mm,d=dd;      cout<<\"Date is \"<<<\"/\"<<<\"/\"<<<\"\\n\";      while(year != 2012)                 {                                if(year>2012)    // if year is greater compute odd days                       {                         if(year%400==0||(year%4==0&&year%100!=0))                         count_year+=2;                         else                         count_year++;                         year-=1;                         }                                                   else // if year is less compute odd days                         {                                                  if(year%400==0||(year%4==0&&year%100!=0))                         count_year-=2;                         else                         count_year--;                         year+=1;                                                  }                 }            while(month != 8)                  {                       if(month>8)                       {                       if(month==1||month==3||month==5||month==7||month==8||month==10||month==12) // if month is greater compute odd days                       count_days+=3;                       else if(month==2)                       ;                       else                       count_days+=2;                       month--;                       }                                              else                       {                       if(month==1||month==3||month==5||month==7||month==8||month==10||month==12)                       count_days-=3;                       else if(month==2)                       ;                       else                       count_days-=2;                       month++;                       }                  }                             if(d>27) // if days are greater compute odd days          { count_days+=(d-27);}          else          { count_days-=(27-d);}                         int gap=(count_days+count_year)%7;          if(gap<0) gap+=7;  //mathematical modulo                           if(gap==0)           cout<<\"Tuesday\";           else if(gap==1)           cout<<\"wedday\";           else if(gap==2)           cout<<\"Thursday\";           else if(gap==3)           cout<<\"friday\";           else if(gap==4)           cout<<\"satday\";           else if(gap==5)           cout<<\"sunday\";           else if(gap==6)           cout<<\"monday\";           else ;                                                }               int main() {          date toCheck(19,9,2014);  // change it to any date you want to check     toCheck.compute_day();     return 0; }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14911668","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"26","title":"With a pointer to head node of a linked list as argument, write a function to swap the consecutive elements of the list and return the head node. (Do note change values of any node, only change the links.) Example :- 1->2->3->4->5->6->7 2->1->4->3->6->5->7","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Node* swap(Node* head) \n{ \n if (head == NULL || head -> next == NULL) \n  return head; \n   \n Node* temp = head; \n head = head -> next; \n Node* succ = head -> next; \n head -> next = temp; \n temp -> next = swap(succ); \n return head; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"An easy and iterative way....just keep on swapping nodes while you reach the end....  static ListNode swapAdjacentNodes(ListNode head) {      if(head==null || head.next==null) {    return head;   }else {    ListNode current=head;    head=current.next;    current.next=head.next;    head.next=current;    while(current.next!=null && current.next.next!=null) {     ListNode temp=current.next;     current.next=current.next.next;     temp.next=current.next.next;     current.next.next=temp;     current=current.next.next;    }    return head;   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"node* swap2(node* head) \n{ \nif( head == NULL || head->next == NULL) \nreturn head; \n \nnode* node1 = head; \nnode* node2 = node1->next; \nnode* node3 = head->next; \nnode* prev = NULL; \n \nwhile(node1 != NULL && node2 != NULL) \n{ \nif(prev) \nprev->next = node2; \n \nnode1->next = node2->next; \nnode2->next = node1; \nprev  = node1; \n \nnode1 = node1->next; \nif(node1) \nnode2 = node1->next; \n} \n \nreturn node3; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"My solution is in C#"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"...............[n11]->[n12]->[n13]->[n14]...............  lets have ptr(Node *ptr) pointer at [n11] and we have to swipe [n12] and [n13]  Node *temp; temp = ptr->next; ptr->next-= ptr->next->next ; temp->next = ptr->next->next; ptr->next->next  = temp;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node* swap(node *head) \n{ \n    if(head) { \n           nextNode = head->next; \n           newHead = head; \n           if(nextNode) { \n                      rest = nextNode->next; \n                     newHead = nextNode; \n                      nextNode->next = head;             \n                      assert(swapPair(rest, nextNode)) \n            }               \n           return newHead; \n \n} \n \n \nint swapPair(node *list, node *back) \n{ \n           if(list) { \n                      first = list; \n                      second = list->next; \n                      rest = null; \n                      if(second) { \n                                 rest = second->next; \n                                 second->next = first; \n                                 first->next = rest; \n                      } \n                      back->next = second; \n                                  \n                     swapPair(rest, ); \n           } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1->2->3->4->5->6->7 here current =1, next1= 2, next2=3 we change the links pairwise, first 1 and 2, then 3 and 4, then 5 and 6 when our current is 7 and its next is null we stop  below code will give 2->1->4->3->6->5->7"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void swapelements(struct list **l) { struct list *y = *l; struct list *x; if(NULL == y || NULL == y->next)     return; x = y->next; y->next = x->next; x->next = y; *l = x;  swapelements(&(x->next->next));       }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct Node *head=NULL; swap() {   struct Node *ptr;   ptr=head;    int count=0;   while(ptr->next!=NULL)   {     count++;      if(count%2!=0)      {         temp=ptr->data;         ptr->data=ptr->next->data;         ptr->next->data=ptr->data;       }    else     ptr=ptr->next; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node swapNodes(Node ptr) \n { \n   \n  if (ptr == null) \n  { \n   return null; \n  } \n   \n  if (ptr.next == null) \n  { \n   return  ptr; \n  } \n   \n  Node ptr1,startPtr = null; \n  int count=0; \n  ptr1= ptr; \n   \n     \n  while(ptr!= null && ptr.next!=null) \n  { \n   count++; \n   ptr1= ptr.next; \n   ptr.next=ptr1.next; \n   ptr1.next= ptr; \n    \n    \n   if (count==1) \n   { \n    startPtr = ptr1; \n   } \n    \n   ptr = ptr.next; \n   ptr1 = ptr1.next; \n    \n   if(ptr!=null && ptr.next!=null ) \n   { \n    ptr1.next=ptr.next;  \n   } \n    \n    \n   \n    \n  } \n  \n  return startPtr; \n  \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node *temp,*first,*second,*third; \nfirst=head; \nsecond=first->next; \ntemp=second; \nthird=second->next; \nwhile(first!=NULL) \n{ \nsecond->next=first; \nfirst->next=third->next; \nfirst=third; \nsecond=first->next; \nthird=second->next; \n} \n \nhead=temp;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"list * alternateSwap(list * node) \n { \n      if (node!=NULL&&node->next!=NULL) \n      {        \n      list *temp= new list; \n      temp->next=node->next->next;         //swap step 1   //save the next nodes link; \n      node->next->next=node;               //swap step 2   //break & update next nodes link \n      node=node->next;                     //swap step 3 update node \n      node->next->next=alternateSwap(temp->next);       //find next link of swapped node \n      delete temp; \n      } \n      return node; \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"take a look at this....  void swap(nd *start,nd *ptr1,nd *ptr2) { if(start->next==NULL) { return; }  else { nd *temp,*nt; nt=ptr2->next; temp=ptr1; start->next=ptr1->next; ptr2->next=temp; temp->next=nt; //temp->next=NULL; p(\"%d %d\",start->next->data,start->next->next->data); start=start->next->next;  if(start->next!=NULL&&start->next->next!=NULL) { //p(\"coe ejfodfodfo fo foufoifojldfjlf ljf ljfl \\n\"); swap(start,start->next,start->next->next); return; } } }  void print(node *pointer) { //pointer=pointer->next; if(pointer==NULL) { return; } //printf(\"elements are...\\n\");  printf(\"%d\\n\",pointer->data); print(pointer->next); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node* Swap(Node* node) \n{ \n if (node == NULL || node->next == NULL) \n return node; \n  \n Node* cur = node; \n Node* next = node->next; \n \n node->next = Swap (node->next->next); \n next->next = cur; \n \n return next; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void swapalternate(node * p) \n{ \n//p is the header of the original list and following it are temp1,temp2. \ntemp=p; \ntemp1=temp->link; \ntemp2=temp1->link; \np=temp1;//header changed here  \nwhile(temp!=NULL) \n{ \ntemp1->link=temp; \ntemp->link=temp2->link; \ntemp=temp2; \ntemp1=temp->link; \ntemp2=temp1->link; \n \n} \n \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14910674","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"25","title":"Given an array of integers, give the most efficient algorithm to find if the array has a majority element. If the array has a majority element, find this element. (Note : The majority element is the element that occurs more than half of the size of the array)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"Moore's Voting Algorithm"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Step 1: Moore's voting algorithm -> this will give one element as Majority element.  Step 2: Make one more pass on array. Count the element obtained above. If count >= len/2 then there is a majority element and that is the one obtained in step 1.  if count  \n   \n    \n   -  \n     Ragha \n     on October 29, 2012 Edit | Flag  \n    \n    \n   Reply"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Assumption : there EXISTS a majority element Logic : keep a record of majority element candidate and its count so far, if the next number matches, increase the count, else decrease the count, if count = 0, set candidate = current number Time Complexity : O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Just start pushing all the elements into hash map and increment the count on insertion. Store maximum count in a local variable.  Check this count at length /2 + 1 if its not greater than 1 - quit similarly check it at length / 2 + 1 if its not greater than 2 - quit  Perhaps this would be the most optimum with complexity O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"To add to the above code one more terminating condition would be when count reaches length / 2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use a stack buddy, use a stack :D"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"candidate = a[0]; count =1; for(int i=1;i{    if(candidate == a[i])       count++;    else    {       count--;       if(count == 0)        {            count =1;             candidate = a[i];         }    } } if(count > 1)   major element present  and \"candidate\" is major element."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If i am getting the question correctly then i think this approach can work- sort the array and check if a[n/2-1]==a[n/2] and a[n/2+1]==a[n/2] if n is even or a[n/2-1]==a[n/2] or a[n/2+1]==a[n/2] if n is odd  then its majority element else majority element doesn't exist.  its O(nlogn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.Create linklist having data part,count and link part;    data will store the value.     Count will store the no of duplicate of data.    next will link to next node.   e.g.  struct linklist{   int data;   int count;   struct node *next;  } 2.travers the linklist to find node having the maximun value of count;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class MajorityElement { \n  \n //Moore's Voting Algorithm \n public static Integer majorityEle(int[] array) { \n  if (array == null && array.length == 0) { \n   return null; \n  } \n  int candidate = 0; \n  int count = 1; \n  for (int i = 1; i < array.length; i++) { \n   if (array[i] == array[i - 1]) { \n    count++; \n   } else { \n    count--; \n   } \n   if (count == 0) { \n    candidate = i; \n   } \n  } \n  count = 0; \n  for (int i = 0; i < array.length; i++) { \n   if (array[i] == array[candidate]) { \n    count++; \n   } \n  } \n  if (count > array.length / 2) { \n   return array[candidate]; \n  } \n  return null; \n } \n \n public static void main(String[] args) { \n//  int[] array = {3,3,4,4,5,3,3,4}; \n  int[] array = {2,4,2,5,2,2,6,6,6}; \n  System.out.println(majorityEle(array)); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"jj"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static boolean CompareWithOtherElements(int [] S, int data, int start, int end ){     for(int i = start; i<= end; i++){         if(S[i] == data){          return true;         }     }      return false;     }  public static int FindMajorEl(int [] S , int start, int end){     boolean Found = false;          if(end - start == 0){return S[start];}     if(end - start == 1){         if(S[start] == S[start + 1]){         return S[start];}     }     int mid = ((end - start + 1) / 2);     int ret = FindMajorEl(S, start, start + mid - 1);     if(ret != -1){         Found = CompareWithOtherElements(S,ret,start+ mid, end );     }     if(Found == false){         ret = FindMajorEl(S, start + mid, end);         if(ret != -1){         Found = CompareWithOtherElements(S,ret,start,start + mid -1);         }     }     if(Found){ return ret;}     else {return -1;} }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Step 1 ) Just sort the array  Step 2 ) Compare the middle element with the first element , If equal majority number exists and return Mid. If not equal then majority element does not exist -> Time Complexity - O(nlogn)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14871841","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"A screen has different shapes of objects. The number f objects is large like million. We want to zoom into a region on the screen. How can we identify which objects should be displayed in the zoomed area? Give a data structure to store objects.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"you can use Quad-tree with certain depth level and each new zoom level  1- take objects in certain number of squares surrounding the center of screen (i.e. 7x7 squares). 2- scale objects and get down one level in tree."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14878835","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"25","title":"WAP to print the node values of a binary tree  - Even level starting from right to left - Odd level starting from left to right  Assume that level of root is 1.                    a              b         c          d      e   f      g    Output: a c b d e f g","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"12","title":"This can be solved with 2 stacks. 1. Read the root node and add it to the stack \"even\". 2. pop nodes out of the stack even. Now, read the right child first and then left, print it and push it to stack \"odd\". Do this until the stack even is empty. 3. Now, pop nodes out of stack odd. Read the left child first and then right, print it and push it to stack \"even\". Do this until the stack odd is empty. 4. repeat 2 and 3 until it was an empty stack to begin with - this means that we traversed the last level in the previous step"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"static void print(Node root)         {             Stack odd = new Stack();             Stack even = new Stack();             odd.Push(root);             while (odd.Count != 0 || even.Count != 0)             {                 while (odd.Count != 0)                 {                     Node node = odd.Pop();                     if(node.left!=null)                         even.Push(node.left);                     if(node.right!=null)                         even.Push(node.right);                     Console.Write(node.data+\" \");                 }                 Console.WriteLine();                 while (even.Count != 0)                 {                     Node node = even.Pop();                     if (node.right != null)                         odd.Push(node.right);                     if (node.left != null)                         odd.Push(node.left);                     Console.Write(node.data + \" \");                 }                 Console.WriteLine();             }         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Here is my solution in C#, using two lists."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I guess this requires printing the tree in spiral form.  1. Start with root. 2. Since root is at odd level (and next level will be even), add its children in reverse order to the queue, i.e. root.right and then root.left 3. Proceed similarly for other levels.  If we are adding children of a particular node, following rule should be considered a. if node at even level, add node.left then node.right b. if node at odd level, add node.right then node.left"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"but wouldn't that print 'a c b f g d e'"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think a Broad First Search with a stack can solve this problem. 1. Add the root node to the queue. 2. Get the head node  of  the queue and add its children to the queue. 3. If the node is in even level, print it. Otherwise, push it into the stack 4. When level of the head node has changed from odd to even,pop the stack and print the node 5. Repeat from 2 until all the node have been scaned"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"another solution to this is to use \"deque\"  1. odd levels - print the node value from the bottom and push the child nodes to the top  2. even levels - print the node value from the top end and push the child nodes to the bottom  always pop the node after printing its value  also we will have a couple of O(1) memory - one to track the number of elements to print  during the current print option and other one is for the number of elements in the next level.  Please correct me if I am wrong"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"vector< vector > v; \n  vectorx; \n  x.push_back(root); \n  v.push_back(x); \n  int i=0; \n  while(!v[i].empty()) \n  { \n   x.clear(); \n   if(i%2==0) \n   { \n    for(int j=v[i].size()-1;j>=0;j--) \n    { \n     if(v[i][j]->left) x.push_back(v[i][j]->left); \n     if(v[i][j]->right) x.push_back(v[i][j]->right); \n     cout<info<<\" \"; \n    } \n   } \n    if(i%2!=0) \n   { \n    for(int j=v[i].size()-1;j>=0;j--) \n    { \n     if(v[i][j]->right) x.push_back(v[i][j]->right); \n     if(v[i][j]->left) x.push_back(v[i][j]->left); \n     cout<info<<\" \"; \n    } \n   } \n   v.push_back(x); \n    i++; \n   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"vector print_odd_level(vector nodes) { \n  for (int i=0; ivalue << \" \"; \n  return next_level(nodes); \n} \nvector print_even_level(vector nodes) { \n  for (int i=nodes.size()-1; i>=0; i--) \n    cout << nodes[i] << \" \"; \n  return next_level(nodes); \n} \nvector next_level(vector nodes) { \n  vector next; \n  for (int i=0; ileft) \n      next.push_back(nodes[i]->left); \n    if (nodes[i]->right) \n      next.push_back(nodes[i]->right); \n  } \n  return next; \n} \n \nvoid print() { \n  if (!root) return; \n  vector nodes; \n  nodes.push_back(root); \n  int level = 1; \n  while (!nodes.empty()) { \n    if (level%2==1)  \n      nodes = print_odd_level(nodes); \n    else \n      nodes = print_even_level(nodes); \n  } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ans to Ques 1 :  Do a level order traversal using a queue. Pseudocode"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Code for Reverse Level Order for each Level procedure"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public NodeQueue bfs(Node traverseNode, int level) { \n  NodeQueue nodeQueue = new NodeQueue(); \n  NodeQueue resultQueue = new NodeQueue(); \n  traverseNode.setLevel(1); \n  nodeQueue.push(traverseNode); \n  resultQueue.push(traverseNode); \n          \n  while (!nodeQueue.isEmpty()) { \n     \n   traverseNode = nodeQueue.pop(); \n   level = traverseNode.getLevel(); \n   level++; \n   if (traverseNode.getLeft() != null) { \n    traverseNode.getLeft().setLevel(level); \n    nodeQueue.push(traverseNode.getLeft()); \n   // resultQueue.push(traverseNode.getLeft()); \n   } \n   if (traverseNode.getRight() != null) { \n    traverseNode.getRight().setLevel(level); \n    nodeQueue.push(traverseNode.getRight()); \n   // resultQueue.push(traverseNode.getRight()); \n   } \n    \n   if(level%2==0){ \n    if (traverseNode.getRight() != null) { \n     resultQueue.push(traverseNode.getRight()); \n    } \n    if (traverseNode.getLeft() != null) { \n     resultQueue.push(traverseNode.getLeft()); \n    } \n   } \n   else \n   { \n    if (traverseNode.getLeft() != null) { \n     resultQueue.push(traverseNode.getLeft()); \n    } \n    if (traverseNode.getRight() != null) { \n     resultQueue.push(traverseNode.getRight()); \n    } \n   } \n    \n  } \n  return resultQueue; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void LevelOrderTraval(BST *Node) {   std::queue QueueToHold;  QueueToHold.push(Node);   while(!QueueToHold.empty())  {   BST *tmp = QueueToHold.front();   QueueToHold.pop();   std::cout<< tmp->data <<\"\\n\";      if (tmp->lChild)    QueueToHold.push(tmp->lChild);   if (tmp->rChild)    QueueToHold.push(tmp->rChild);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. do an pre-oder and print values in an array also label then with their levels  a bdecfg 1233233  now just read appropiately  odd from tight and even from level .. level wise"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"queue q = new queue(); q.add(root) stack s = new stack(); while((isOdd && !q.empty())||(!isOdd && !s.empty()) {    if(isOdd)     {          whie(!q.isempty){Node n =e.dequeue; print(n);s.push(n.left);s.push(n.right);isodd=false;}      }    else     {       while(!s.empty){Node n = s.pop;print n;enque(n.left);n.enque(n.right);}     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It reverses order of all the nodes of tree after level 1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayDeque; \nimport java.util.Deque; \nimport java.util.Iterator; \nimport java.util.LinkedList; \nimport java.util.Queue; \n \npublic class BSTPrint { \n TreeNode root; \n \n class TreeNode { \n  double value; \n  TreeNode left; \n  TreeNode right; \n \n  public TreeNode(double value) { \n   super(); \n   this.value = value; \n   left = null; \n   right = null; \n  }; \n \n } \n \n public void insert(double value) { \n  root = insertT(root, value); \n } \n \n public TreeNode insertT(TreeNode root, double value) { \n  if (root == null) { \n   TreeNode r = new TreeNode(value); \n   return r; \n  } \n  if (value > root.value) { \n   // right \n   root.right = insertT(root.right, value); \n  } else if (value < root.value) { \n   root.left = insertT(root.left, value); \n  } \n  return root; \n } \n \n public void inorder() { \n  inorderT(root); \n  System.out.println(); \n } \n \n private void inorderT(TreeNode root) { \n  if (root == null) { \n   return; \n  } \n  inorderT(root.left); \n  System.out.print(root.value + \"\\t\"); \n  inorderT(root.right); \n } \n \n /** \n  * WAP to print the node values of a binary tree - Even level starting from \n  * right to left - Odd level starting from left to right Assume that level \n  * of root is 1. \n  */ \n public void levelPrint() { \n  if (root == null) { \n   return; \n  } \n  Deque deque = new ArrayDeque(); \n  deque.offerLast(root); \n  int level = 1; \n  while (!deque.isEmpty()) { \n   if (level % 2 == 1) { \n    for (Iterator iterator = deque.iterator(); iterator \n      .hasNext();) { \n     System.out.print(iterator.next().value + \" \"); \n    } \n   } else { \n    for (Iterator iterator = deque.descendingIterator(); iterator \n      .hasNext();) { \n     System.out.print(iterator.next().value + \" \"); \n    } \n   } \n   int size = deque.size(); \n   while (size > 0) { \n    TreeNode node = deque.pollFirst(); \n    if (node.left != null) \n     deque.addLast(node.left); \n    if (node.right != null) \n     deque.addLast(node.right); \n    size--; \n   } \n   level++; \n  } \n } \n \n public static void main(String[] args) { \n  BSTPrint bst = new BSTPrint(); \n  bst.insert(6); \n  bst.insert(5); \n  bst.insert(4); \n  bst.insert(2); \n  bst.insert(8); \n  bst.insert(7); \n  bst.insert(3); \n  bst.insert(9); \n  bst.levelPrint(); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Build a mapping between level and nodes: Do a BFS traverse, store following in a hashtable: key: level , value: list of nodes in level  do a foreach on hashtable print nodes for each level from first to last (or last to first) regarding odd (even) level.  Complexity: O(n)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14880812","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"25","title":"Assume you have a integer matrix (m x n) sorted over column wise & row wise. WAP to find the kth smallest element from the matrix. E.g. int[][] a =  2, 5, 8, 10 4, 7, 9, 12 6, 15, 20, 22  So 5th smallest element is: 7","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"I hope this will be helpful. It has time complexity O(k.num_rows) and space complexity O(num_cols)  Basically I find the minimum element k times. And for finding minimum element we just need to check the first (unscanned) element of each row. And then increment it accordingly. min stores the minimum element. minOfRows[i] stores the index (i.e column) of row i which is the first unscanned or rather minimum element of that row. For eg: a[3][4]={{2,5,6,10},{4,8,9,12},{7,15,20,22}}; minOfRows = 0 for all rows. For 1st iteration: min = 2 (1st element of the matrix is minimum and last element (bottom right) is the maximum) minOfRows[0] is incremented by 1; For 2nd iteration: We check minimum from among minOfRows[j] column element for each row j. and update min and minOfRows accordingly."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void getkthMin(int kth) \n{ \n int a[3][4] = {{2,5,8,10}, {4,7,9,12}, {6,15,20,22}}; \n \n // The smallest item is located at a[0][0] \n // For given a a[x][y], the succeding item will be in one of the following numbers: \n // a[x-1][y+1] if (a[x-1][y+1] < a[x][y]) then increase the column until a bigger number is reached. \n // a[x][y+1] \n // a[x+1][y] \n // a[x+1][y-1] if (a[x+1][y-1] < a[x][y]) then increase the row until a bigger number is reached. \n \n if (kth == 1) \n { \n  std::cout<<\"The \"<<<\"th smallest number is \"<= 0) \n   { \n    while (a[x1-1][y1+1] < a[x][y]) \n    { \n     y1++; \n    } \n    x1 = x1 - 1; \n    y1 = y1 + 1; \n    a1 = a[x1][y1]; \n   } \n \n   if (y2 + 1 < 4) \n   { \n    y2 = y2+1; \n    a2 = a[x2][y2]; \n   } \n \n   if (x3 + 1 < 3) \n   { \n    x3 = x3 + 1; \n    a3 = a[x3][y3]; \n   } \n \n   if (y - 1 >= 0) \n   { \n    while (a[x4+1][y4-1] < a[x][y]) \n    { \n     x4++; \n    } \n    x4 = x4 + 1; \n    y4 = y4 - 1; \n    a4 = a[x4][y4]; \n   } \n \n   if (a1 < a2 && a1 < a3 && a1 < a4) \n   { \n    // a1 is the succeding item \n    x = x1; \n    y = y1; \n   } \n   else if (a2 < a1 && a2 < a3 && a2 < a4) \n   { \n    x = x2; \n    y = y2; \n   } \n   else if (a3 < a1 && a3 < a2 && a3 < a4) \n   { \n    x = x3; \n    y = y3; \n   } \n   else \n   { \n    x = x4; \n    y = y4; \n   } \n \n   std::cout<<\"The \"<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"r1=0;c1=0;r2=0,c2=1; int element; while(ctr{  if(a[r1][c1]else {element =a[r2][c2];r2++;} if(r1==arr.length){r1=0;c1=c2+1;} if(r2==arr.length){r2=0;c2=c1+1;} ctr++ }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This method will print the matrix in order and it's easy to modify so it can print the nth element"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The following sorts the matrix. To find 'kth' element, the add a check to stop the while loop at ctr==k."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Something similar to 25 horses . Minimum number of steps to find to 3"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"find min at 0,0 then adjust the matrix by moving all the row elements or columns then repeat the same for k times."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First I sort the matrix merging each row. Then element at (k-1) of the sorted array is the answer. For this solution, it is enough that the matrix is sorted row wised. Or I couldn't make the use of column and row sorted matrix :("},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is called Young's Tableau. Perform k remove from this and maintain the state of Tableau. Remember to use INFINITY as a large number for elements which are no longer valid. Complexity O( max(M,N)+K)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void find(int nth) { \n  if (nth >= M * N) { \n   return; \n  } \n  int[] rows = new int[M]; \n  for (int i = 0; i < M; i++) { \n   rows[i] = 0; \n  } \n  int ptr = 0; \n  int min = Integer.MAX_VALUE; \n  for (int i = 0; i < nth; i++) { \n   min = Integer.MAX_VALUE; \n   int r = 0; \n   for (int k = 0; k <= ptr; k++) { \n    if (matrix[k][rows[k]] < min) { \n     min = matrix[k][rows[k]]; \n     r =k; \n    } \n   } \n   if(rows[r] == 0){ \n    ptr++; \n    if(ptr == M){ \n     ptr--; \n    } \n   } \n   rows[r]++; \n  } \n  System.out.println(min); \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A O(K log K) algorithm Logic: after ary[p][q], the next smallest element is either ary[p+1][q] or ary[p][q+1]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This comment has been deleted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Can we do better with this way?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"public static int findSmallest(int arr[][], int k) { \n  int row = 0; \n  int column = 0; \n  int m = arr.length; \n  int n = arr[0].length; \n    \n   \n  //k is out of range  \n  if(k > m * n) \n    return -1; \n   \n  //k is the max element \n  if(k == m * n) \n   return arr[m - 1][n -1]; \n   \n  if(k <=  m)  \n   column = 0; \n  else  \n   column = k / m; \n   \n   \n  row = ((k - (column * m)) - 1); \n   \n  return arr[row][column]; \n   \n }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14875828","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"19","title":"Write code to sort an integer array of size N which has only three unique values 0,1,2 duplicated & randomly placed over the entire array.  - Memory used should be O(1) - Run time should be O(N)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"Use counting sort: space is O(k) which is O(2) here so constant... or you can use 3 counters to count the number of occurrence of 0, 1, 2 in the given collection, then overwrite the array with those many 0s, 1s, and 2s... or you can use a hashmap to maintain the counts and basically do the same as above...  Constant space usage and O(N) runtime..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"Wiki Dutch National flag for another technique"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"#include \n#include \nusing namespace std; \nvoid swap(int *x ,int *y) \n{ \n int t=*x; \n *x=*y; \n *y=t; \n \n} \nint main() \n{ \n int n; \n cin>>n; \n int a[n]; \n for(int i=0;i>a[i]; \n \n int l=0,mid=0,h=n-1; \n for(;mid<=h;) \n { \n  if(a[mid]==0) \n  { \n   swap(&a[l++],&a[mid++]);  \n  } \n  else if(a[mid]==1) \n   ++mid; \n  else if(a[mid]==2) \n  { \n   swap(&a[mid], &a[h--]); \n  } \n } \n for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"sortarray(int arr, int size, int p, int h) \n{ \n    int h_index = size -1; \n    int p_index = 0; \n \n    for(int i = 0; i<=h_index;) \n    { \n        if(arr[i]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"DNF Algo for the question asked"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is my code to do in a single pass."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"yeah...simple count sort algorithm"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int A[N]; \nint l=0, r=N-1; \nfor (int i=0; i<=r; i++) { \n    while (A[i]!=1) { \n        if (A[i]==0) swap(i, l++); \n        if (A[i]==2) swap(i, r--); \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int ott[10]={0,1,0,0,1,2,2,1,0,2}; \n    int n=10; \n    int firstKnowIndexOftwo    = n-1; \n    int firstKnownIndexOfZeror = 0; \n    for(int i=0;i<=firstKnowIndexOftwo;i++){ \n        if(ott[i] == 0){ \n            int temp =  ott[i]; \n            ott[i] = ott[firstKnownIndexOfZeror]; \n            ott[firstKnownIndexOfZeror] = temp; \n            firstKnownIndexOfZeror++; \n        } \n        else if(ott[i] == 2){ \n            int temp =  ott[i]; \n            ott[i] = ott[firstKnowIndexOftwo]; \n            ott[firstKnowIndexOftwo] = temp; \n            firstKnowIndexOftwo--; \n            i--; \n        } \n    } \n    for(int j=0;j"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \n#include \nvoid swap(int *a,int *b) \n{ \n int tmp=(*a); \n (*a)=(*b); \n (*b)=tmp; \n} \nint main(int argc,char *argv[]) \n{ \n srand(time(NULL)); \n int A[10]={0,1,0,0,1,2,2,1,0,2}; \n int *Z,*T; \n Z=A; \n T=&A[9]; \n int i=0,flag=1; \n for(i;i<10;i++) \n { \n   \n  if((A[i])==2) \n  { \n   while((*T)==2) \n   T--; \n   if( T > (&A[i]) ) \n   swap(T,(&A[i])); \n    \n  } \n  if((A[i])==0) \n  { \n   while((*Z)==0) \n   { \n    Z++; \n   } \n   if(Z < (&A[i])) \n   swap((&A[i]),Z);  \n  } \n   \n } \n for(i=0;i<10;i++) \n printf(\"%d\",A[i]);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include     #include  int dem =0; void arrangements(int A[], int N) {    for(int i=0;i<=N;i++)      if(A[i]     {        A[i]=A[i]+A[i+1];        A[i+1]=A[i]-A[i+1];        A[i]=A[i]-A[i+1];        }        dem++;        if(dem>N) return;        else arrangements(A,N);   }    main() {  int N=12;  int A[30]={1,0,1,2,2,1,0,0,0,1,2,2};  arrangements(A,N);  for(int i=0;i printf(\"%d \", A[i]);  getch();  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public class DutchNantionalFlag { \n // in array, only 0,1,2 includes \n public static void DutchNationalSort(int[] array) { \n  int count0 = 0; \n  int count1 = 0; \n  int count2 = 0; \n  for (int i = 0; i < array.length; i++) { \n   if (array[i] == 0) \n    count0++; \n   if (array[i] == 1) \n    count1++; \n   if (array[i] == 2) \n    count2++; \n  } \n  for (int i = 0; i < count0; i++) { \n   array[i] = 0; \n  } \n  for (int i = count0; i < count0 + count1; i++) { \n   array[i] = 1; \n  } \n  for (int i = count0 + count1; i < count0 + count1 + count2; i++) { \n   array[i] = 2; \n  } \n  for (int i : array) { \n   System.out.print(i); \n  } \n } \n \n public static void dutchFlagSort(int[] arr, int p, int k) { \n  int head = 0; \n  int tail = arr.length - 1; \n  for (int i = 0; i <= tail;) { \n   if (arr[i] < p) { \n    swap(arr, i, head); \n    head++; \n    i++; \n   } else if (arr[i] >= k) { \n    swap(arr, i, tail); \n    tail--; \n   } else { \n    i++; \n   } \n  } \n  for (int i : arr) { \n   System.out.print(i); \n  } \n } \n \n public static void swap(int[] arr, int i, int j) { \n  int temp = arr[i]; \n  arr[i] = arr[j]; \n  arr[j] = temp; \n } \n \n public static void main(String[] args) { \n  int[] array = { 1, 2, 1, 2, 0, 1, 2, 0, 0, 2, 1, 0 }; \n  DutchNationalSort(array); \n  dutchFlagSort(array,1,2); \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please let me know what is the time complexity of this approach"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution O(n)  void Separation012(int *arr, int size) {    int i = 0;  int j = size - 1;   while(i < j)  {   if(arr[i] == 0)    i++;   else if(arr[j] > 0)    j--;   else   {    swap(&arr[i],&arr[j]);    i++;    j--;   }   }   j = size - 1;  while(i < j)  {   if(arr[i] == 1)    i++;   else if(arr[j] > 1)    j--;   else   {    swap(&arr[i],&arr[j]);    i++;    j--;   }   }    return; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void Separation012(int *arr, int size) \n{ \n  \n int i = 0; \n int j = size - 1; \n \n while(i < j) \n { \n  if(arr[i] == 0) \n   i++; \n  else if(arr[j] > 0) \n   j--; \n  else \n  { \n   swap(&arr[i],&arr[j]); \n   i++; \n   j--; \n  } \n \n } \n \n j = size - 1; \n while(i < j) \n { \n  if(arr[i] == 1) \n   i++; \n  else if(arr[j] > 1) \n   j--; \n  else \n  { \n   swap(&arr[i],&arr[j]); \n   i++; \n   j--; \n  } \n \n } \n  \n return; \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14879816","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"17","title":"Assume that a binary tree is drawn over a Cartesian coordinate system (with X & Y axis) where the leftmost node is placed at point (0,0). So, we need to traverse the nodes and print in following manner:  For e.g., for this tree                                           a                                     b         c                                 d     e   f     g Output should be: d,0,0 b,1,1 e,2,0 a,3,2 f,4,0 c,5,1 g,6,0","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"9","title":"You can easily note here that for any given node: the x-coordinate is its cardinal (order) in an inorder traversal; and the y coordinate is the number of levels in the tree rooted at that node;  Using these 2 pieces you can easily get the output shown above...  makes sense?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Here is my solution in C#. GetHeight method is used to calculate the height of the tree and called once before PrintXY method to calculate the height input."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"assuming the tree is perfectly balanced:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Initialize baseX, and baseY to -1 Do and inorder traversal, and when processing a node its X and Y co-ordinates are computed as:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"There is a recursive implementation 1.) get the root - in my case since I use a matrix it will be the most left-bottom Character 2.) recursively go inorder --> left (leftY = pY * 2), childX = pX - 1 then print the curr character then rightY = leftY + 1  Here is a java implementation:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Posting implementation for feedback"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14871813","download_status":"DOWNLOAD_DONE","votes":"-1","answersCount":"12","title":"Find the angle between the hands of a clock.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"9","title":"Minutes Angle = (360 * m) / 60 = 6 * m where m is the minutes. Hour Angle = ((360 * h) / 12) + (360 * m / 12 * 60) = 30 * h + m / 2 From the above two values get the difference by subtracting the bigger value from the smaller value. If the difference is more than 180 then 360 - diff will be the acute angle else diff itself is the acute angle."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"It was a pretty easy problem.. but what they were looking for is how you approach a problem. The first thing I did was ask about the format of the input. If its a string you'd need to parse it and convert into integer, if its in 24hr format.. you would need to convert it to 12 hr, and other things like that... Then, I asked about the format of the output, at which point the interviewer clarified she wanted the acute angle.  Also, while solving it out on the board, you should explain each step instead of just doing it all in your head and then writing the formula. Thats what they are looking for in a PM."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Minutes Angle = (360 * m) / 60 = 6m where m is the minutes. Hour Angle = ((360 * h) / 12) + (360 * m / 12 * 60)  Hour Angle - Minutes Angle = 30h - 11m/2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"difference between the minute and hour clock travel, so  (360/60) m - (360/12) h - (30/60)m which comes to   30 * h - 5.5 * m"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this problem needs lots of clarifying questions.   1) between which hands: hour-minute; minute-second; hour-second 2) how are we reading the input form the clock? 3) Does clock hand move contiguously or they tick? 4) Do we want to calculate the angles at each given time or we want to have program contiguously display the angles. 5) do want to store these angles? ..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Those are the questions you should ask the interviewer when presented with a vague problem."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hr_angle = 1/2(60*h+m) min_angle = 6m angle = hr_angle - min_angle."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"every 1 min diffference is carried by five and half degree...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Triangle"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14876820","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"1","title":"You are a startup trying to design a new mobile online music player.  (startup => you need to differentiate yourself from the existing music players)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question is very open ended. Its upto the candidate to decide the level of details he/she wants to cover. I would have started on a very high level. As a startup I will consider the following buckets: 1) In simple words what should the online music player do? what is the intent of this app? 2) Who will be the users? - are we going to target a demographic zone, an indusy - Bollywood/Hollywood or genre? 3) For which platforms do we want to build this for - android, mac, windows? 4)What will be the source for the songs - already existing websites - free or paid or create a repository of our own? 5) Feature set didvided into two buckets: essentials and specials. Essentials being the basic features any online player should have and special being the unique selling point for our app. 6) Revenue generation and success criteria."}]}}]