[{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14485702","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"80","title":"You are a hunter in the forest. A monkey is in the trees, but you don't know where and you can't see it. You can shoot at the trees, you have unlimited ammunition. Immediately after you shoot at a tree, if the monkey was in the tree, he falls and you win. If the monkey was not in the tree, he jumps (randomly) to an adjacent tree (he has to).  Find an algorithm to get the monkey in the fewest shots possible.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Though the aim of interviewee seems to encourage the candidate to ask more questions about the arrangement of the trees in the forest and other requirements.  Given the problem here there seems to be only one solution >  Start with the leftmost (if the trees are linear) or any (if the trees are in circle) tree. Shoot one  tree twice. If monkey is jumping to the left adjacent tree, it will be dead in the second shot. Otherwise if the monkey jumps to the right adjacent tree every time, it will be dead after sometime later. Even if the tree formation is circular, monkey will be dead."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"i think solution is possible only when all trees are in linear row"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for a tree , there are how many adjacent trees?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is there any cycles in the forest e.g. 1 is neighbor of 2, 2 is neighbor of 3, 3 is neighbor of 4 and 4 is neighbor of 1 forming a cycle?  We certainly can't know on which tree the monkey jumped after the shooting but can we know from which tree it jumped? e.g. I shoot tree 7 and the monkey jumps to some tree I don't know to which but I know it jumped from tree 5, I know the source of the jump is 5 but the destination can be any of 5's neighbors."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"for 5 trees below is working for all cases  2 4 3 2 4 3 2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"looks like there is solution only for up to 3 trees (shoot tree#2 two times monkey will fall).... if number of trees are more than 3 then there is no solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"if there is  a condition that the monkey will not come back to same tree(something like the tree being shot all together)....then we can attempt at a Binary Search order shoot?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"problem statement is unambigious"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I am assuming the trees are in linear configuration as other configurations does not seem to have solution. If there are n trees, keep shooting each tree twice starting from tree number 2 to tree number (n -1). So the number of shots required will be (2 * (n-2)) . It should work because, if the monkey is in tree 1 and you shoot tree 2 twice it should hit. If it is not in tree 1 then shooting tree 2 twice will make sure that it is not there in either 1 or 2. Similarly we can proceed till tree (n -1). May be we can reduce the number of shots required. That needs to be explored."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"first i thot eugene soln wud work ..but thanks to Glude... so it looks like the prob with above soln was .. that if are going shooting towards right ie ...2-3-3-4-4 etc.. nd if the clever monkey jumps onto 4th tree on our second shot to tree 4th tree.... then we wud continue shooting towards right nd monkey would fly around on left side... same can happen wen we go back towards left... So i think to avoid this .. we can do the following --- 2-1-3-2-4-3-5-4   (for 5 trees)  to explain the logic -- we want the monkey to b on our right side only nd not to cross to our left... so  if trees are p - q - r - s and we shoot at q .... to cross to our left ,... the monkey might b on q now ... ( and can jump to p or r .... so shoot p now ... ( this way monkey can never cross us)  shoot current(q) .. shoot prev(p) ... shoot next (r) .... shootprev(q)... shootnext(s) i hope its clear nd it works :)       ( yes i assumed its linear tree distribution )"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Maintain the state of monkey,who will be in one of the tree in the possible set. Try to reduce the number of elements in the set. Each shoot either kills the monkey or monkey changes its state.  for e.g. n= 6, initially monkey can be in one of the tree 1-6  State     shoot [123456]          2 [23456]   3 [13456]   4 [2456]   5 [135]   5 [24]           2 [35]           3 [46]           4 [5]    5"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"for n trees in linear configuration.... start from one end and shoot a tree twice and start moving to the other end example  for n = 10 shooting sequence will be 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 so for n trees we need 2*n shots to hit the monkey"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Lets assume we have n trees. we shoot from the left to right eg: 1 2 3 ... n then we shoot from right to left eg : n,n-1,n-2 ...1  Then we must hit the money somewhere. (Another example:  let n=7 1,2,3,4,5,6,7,7,6,5,4,3,2,1 )  If anyone can provide a counterexample. I would appreciate it"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"I think the Monkey can be killed in 2(n-2) shots.   start from the second tree. take 2 shots at each tree from 2nd till n-1 tree. (for n trees).  like for n = 6, 22334455"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"[edit: wrong solution, dont bother :)]  Its about combinations, so i think of binomial coefficients, use levels of pascal's triangle for each n > 2 and shoot from left to right or right to left like:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"for linear configuration of tree start from one end and shoot at tree twice and move to other end for n = 10 shooting sequence will be 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 we need 2*n shots for n trees"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"for linear configuration of tree start from one end and shoot at tree twice and move to other end for n = 10 shooting sequence will be 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 we need 2*n shots for n trees"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"what is the ultimate solution??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"I wrote a simulation of a forest of 20x20 trees always starting the monkey in tree 0,0.  I counted the times the monkey visted each tree during a million shots, using a random jump of 8 possible directions, ignoring any jump that would take it outside the forest.  Over about 20 or 30 runs of this program, it looks like on average the monkey will visit some edge tree more frequently than any interior tree, with trees within 2 to 4 of a corner but still on an edge getting the most hits.  But it also happens that some edge tree will be visited the least of all others, though that is a less frequent occurence and seems like it's either an exact corner or one of the trees closer to the middle of an edge.  So my strategy would be to pick an edge tree near a corner and shoot at it continuously."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Get a f*ing machine gun. spray them all."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-2","title":"Just show him f'king banana..."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=62565","download_status":"DOWNLOAD_DONE","votes":"6","answersCount":"54","title":"given a binary tree ,find the largest sub-tree which is a BST...(largest means subtree having largest no of nodes in it)...this is a wonderful question.....","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"//return true if BT with root=node is a BST \nint isBST(struct node* node, int min, int max,int *count)  \n{  \n  /* an empty tree is BST */ \n  if (node==NULL)  \n     return 1; \n        \n  /* false if this node violates the min/max constraint */  \n  if (node->data < min || node->data > max)  \n     return 0;  \n  \n  *count++; \n  /* otherwise check the subtrees recursively,  \n   tightening the min or max constraint */ \n  return \n   ( isBST(node->left, min, node->data-1) &&  // Allow only distinct values \n     isBST(node->right, node->data+1, max));  // Allow only distinct values \n}  \n \nstruct node* largestSubTree(struct node *root) \n{ \n  int count=0; \n  static int tmp_count=0; \n  static struct node *node=NULL; \n    \n  if(!root) return NULL; \n \n  if(isBST(root,INT_MIN,INT_MAX,&count)) \n   if(count>tmp_count) \n    { \n      tmp_count=count; \n      node=root; \n      return node; \n    }      \n  largestSubTree(R->left); \n  largestSubTree(R->right); \n \n  return node;  \n} \n \n//prints tree in pre order traversal \nvoid printTree(struct node *root) \n{ \n   if(!root) \n    return; \n    \n   cout<data<<\" \"; \n   printTree(root->left); \n   printTree(root->right); \n} \n \nvoid main() \n{ \n   struct node *root=NULL,temp; \n   root=createTree(root); //tree is created \n \n   if((temp=largestSubTree(root))!=NULL) \n   { \n     cout<<\"The largest sub-tree which is a binary tree is:\\n\"; \n     printTree(root); \n   } \n   else \n   { \n     cout<<\"Such subtree does not exist\"; \n   } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A subtree is one that goes all the way till the leaves... a simple non-decreasing sequence for an inorder traversal need not necessarily point out the actual largest subtree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"using a recursive call: which get number of node, min, max for BST and return bool if this tree is a BST.  Always rembmer the max number of node sub bst  tree and root.  Anyway, this is a good question."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use BFS technique and make a function which validate the BST property and return the MAX no of nodes in that BST"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int LBST(node* n) { if( (n->leftright) && (LBST(n->left) != -1)  && (LBST(n->right) != -1) )  return LBST(n->right) +  LBST(n->left);  if(n->left==NULL && n->right ==NULL)  return 1;  else   return -1;  }       int maxNodes=0; node* maxNode;  node* returnMaxBST(node* n) {   int i=0;  if(n->left==NULL && n->right==NULL) {  if(maxNodes==0)  {   maxNodes=1;   maxNode=n;  }     return n; }   if(LBST(n) > maxNodes ) {  maxNodes=LBST(n);  maxNode = m; }  returnMaxBST(n->left); returnMaxBST(n->right);   return maxNode;;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int LBST(node* n) { if( (n->leftright) && (LBST(n->left) != -1)  && (LBST(n->right) != -1) )  return LBST(n->right) +  LBST(n->left);  if(n->left==NULL && n->right ==NULL)  return 1;  else   return -1;  }     -----------------------------------------------------------------------------------------------------  int maxNodes=0; node* maxNode;   -----------------------------------------------------------------------------------------------------  node* returnMaxBST(node* n) {   int i=0;  if(n->left==NULL && n->right==NULL) {  if(maxNodes==0)  {   maxNodes=1;   maxNode=n;  }     return n; }   if(LBST(n) > maxNodes ) {  maxNodes=LBST(n);  maxNode = m; }  returnMaxBST(n->left); returnMaxBST(n->right);   return maxNode;;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int LBST(node* n) { if( (n->leftright) && (LBST(n->left) != -1) && (LBST(n->right) != -1) ) return LBST(n->right) + LBST(n->left);  if(n->left==NULL && n->right ==NULL) return 1;  else  return -1;  }  -----------------------------------------------------------------------------------------------------  int maxNodes=0; node* maxNode;  -----------------------------------------------------------------------------------------------------  node* returnMaxBST(node* n) {  int i=0;  if(n->left==NULL && n->right==NULL) { if(maxNodes==0) { maxNodes=1; maxNode=n; }  }  if(LBST(n) > maxNodes ) { maxNodes=LBST(n); maxNode = m; }  maxNode= returnMaxBST(n->left); maxNode= returnMaxBST(n->right);  return maxNode;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@giri none of the 3 solutions you posted is working. post a proper solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think the first answer itself gives a proper direction on solving this problem. People should read the responses before blindly providing crappy solutions."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Ok the first solution is partially right.change must be to find longest increasing sub string.Will longest increasing subseq work out???"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is this qsn asking for subgraph or subtree..  If subtree, then we can do a dynamic algorithm solution. We can write a recursive isBST function, which takes a node and returns true or false  Pseudo Code:  Init count to 0s  Null Case.   if(!node->left && !node->right)  return true; isBST(node->left, 2*i) and isBST(node->right, 2*i+1) and node->left->data < node->data <= node->right count[i] = count[2*i] + count[2*i+1]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I repeat the first approach does make sense. Have a look and make things clear to yourself  @Michael Jackson. Your argument is completely vacuous/illogical. First get your basics right. You seem to be loosing the basic definition/meaning of basic tree data structures. Brush up your basics and then come back here.  FYI: http://en.wikipedia.org/wiki/Binary_search_tree  HTH, Thank you.  I'm a big FAN of LOLer !"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Traverse the entire tree (using any traversal method) and pass each node (rather the binary subtree) to the following function isBST()."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Traverse the entire tree (using any traversal method) and pass each node (rather the binary subtree) to the following function isBST()."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here is what i think mostly will work. Not well tested but i am sure can be achieved with something like this -      take 2 buckets to store temp and max BST and 1 stack     1. start with current                 if(start == null)         return               push start to temp        if(start->left != null)      if start->left < start      push to temp bucket      go to step 1 with start = start->left      else push start->left to stack                if(start->right != null)      if start->right > start,      push to temp bucket      go to step 1 with start = start->right      else push start->right to stack           compare temp with max and if required, update max     assign start to stack.pop and start from beginning      //idea is to store captured BST from current node and compare it with Max  if you find BST from current node and its broken somewhere down the road, you can't find bigger BST from one of its child EXCEPT that BST starts from  or sub tree of broken node. so dont visit all child of start but only visit broken nodes so store them on stack.                     -------15----        |     |        ------16------    14         |            |          8            32          --------     -----            |      |     |          5      4     30   so here 16 and 14 both goes to stack on first run. Max = 15 pop 16, and you will end up with temp = 16,8,5,32,30 and 4 going on stack. update max. pop 14. temp = 14. no need to update max. pop 4. temp = 4. no need to update max.  Comments/working code welcome :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Example graph did not go through well."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{           }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In-order traversal of binary tree, and then find largest non-decreasing sequence, start index of this sub-sequence is the root of BST."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Call below method recursively for each left & right subtree of original tree. Return as soon as isBST returns true with root at the iteration  /*  Returns true if the given tree is a BST and its  values are >= min and <= max. */ int isBSTUtil(struct node* node, int min, int max) {   if (node==NULL) return(true);    // false if this node violates the min/max constraint   if (node->datadata>max) return(false);    // otherwise check the subtrees recursively,   // tightening the min or max constraint   return     isBSTUtil(node->left, min, node->data) &&     isBSTUtil(node->right, node->data+1, max)   ); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please comment on my solution...  As the first solution did half the work.  Do in order traversal of the tree .(Store the result  we need it again) Find the longest non-decreasing sequence . Now the starting element is the root. Now do inorder traversal on that tree if it again becomes non decreasing (i.e check isBST )then we arrived at the answer else go to next longest non-decresing substring and repeat the check for isBST?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int largestBST(node *root, int *min, int *max, node **sub, int *max_size) \n{ \n  if (root == NULL) \n  { \n    /* Initializing min and max if we hit a leaf node */ \n    *min = INT_MAX; \n    *max = INT_MIN; \n     return 0; \n  } \n \n  int isbst;  \n \n  /* l_size is the size of the left subtree */ \n  int l_size = largestBST(root->left, min, max, sub, max_size); \n   \n  /* If it is a leaf node we set currMin to root->data else \n     we set currMin to minimum of left subtree */  \n  int currMin = (l_size == 0) ? root->data : *min;  \n                                                     \n  if (root->data < *max ) \n     isbst = 0; \n \n  int r_size = largestBST(root->right, min, max, sub, max_size);  \n  int currMax = (r_size==0) ? root->data : *max; \n  \n  if (root->data > *min ) \n    isbst = 0; \n   \n  if (isbst) { \n    if (l_size + r_size  + 1 > *max_size ) { \n     *max_size = l_size + r_size  + 1; \n     *sub = root; \n    } \n    *min = currMin; \n    *max = currMax;  \n    return l_size + r_size +1; \n  } \n  return -1; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can do it by keeping track if every node in the tree is a valid BST root, and the number of children it has. We can do this by doing a Depth First Traversal in O(v) time and updating all of the counts and keeping track of a global max variable.  Assuming a nice node class,"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@LOLer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Lets divide this to sub problems. 1. Given a binary tree find out if its a BST. -- isTreeBST() 2. Given a tree find total number of nodes  -- getTotalObjects() 3. Finally find larget BST using recusrion - getLargestBST().  Code :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"In-order traversal of binary tree, and then find largest non-decreasing sequence, start index of this sub-sequence is the root of BST."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"use dynamic programming..."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=7349664","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"47","title":"A special type of tree is given, Where all leaf are marked with L and others are marked with N. every node can have 0 or at most 2 nodes. Trees preorder traversal is given give a algorithm to build tree from this traversal.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"//let preorder traversal of a tree be in a array t \n  for(i = t.length; i>-1; i--){ \n      \n     if(t(i) == L){ \n         stack.push(t[i]); \n     }else{ \n         leftChild = s.pop(); // will return null if stack is empty \n         rightChild = s.pop(); // will return null if stack is empty \n         node = new Node(leftChild, rightChild); \n         stack.push(node); \n     } \n      \n  } \n \n  root = stack.pop(); // get the root from the stack;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"from what the OP posted, there is no way to reconstruct a tree  from the preorder sequence because there is no one-to-one relationship. for example        N      and      N both have the preorder sequence N,N,L,L,     / \\             /      N  L           N    /              / \\        L              L   L  if the number of children of each node is given, it is another story"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"We have to provide a tree which gives the given preorder traversal. What is the problem if there are multiple trees, your solution tree should give the preorder traversal same as mentioned. Since their can be multiple approaches, hence multiple tree solutions. Initially 'CodeGeek' one solution which is correct according to his approach and he can create a tree which gives the same order as given in the ques. Then how this question arises that it will not work for right sided tree ??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"The algorithm works based on the concept that number of leaf nodes=number of internal nodes+1. (This is true only if internal node can have either 0 or 2 children, not 1).  Count from the beginning of the preorder array and when number of internal nodes==number of leaf node, that means, it is the end of the left subtree. Now recursively call the routine with the sub array containing the left subtree and with the sub array containing the right subtree. Finally join the left subtree and the right subtree with the root.  You can find the WORKING code here : cslabprograms.blogspot.com/2011/02/nl-tree.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"The algorithm works based on the concept that number of leaf nodes=number of internal nodes+1. (This is true only if internal node can have either 0 or 2 children, not 1).  Count from the beginning of the preorder array and when number of internal nodes==number of leaf node, that means, it is the end of the left subtree.  Now recursively call the routine with the sub array containing the left subtree and with the  sub array containing the right subtree. Finally join the left subtree and the right subtree with the root.  You can find a working program here: cslabprograms.blogspot.com/2011/02/nl-tree.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Very much straight forward.. you should be given either a (singly or doulbly) linked list of pre-order traversal i.e. (Root)N->N->N->N->N->N->L->L->N->N->N->N->L You need to trick the pointers for following 2 cases 1. N->L->L : this is the node with 2 childs..so N->left= 1st L and N->right= 2nd L 2. N->L->N : node has 1 child...so N->left/right = L ... if BST the check if(N>L) then N->left = L otherwise its a right child Note: By assuming BST to be desired tree, check for values to decide if left or right child..in case of just BT can be set to either of them."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Since the nodes are marked with leafs / nodes its possible to build a tree with this"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"chiragjain1989,  The above code will fail for below tree model: only right sided tree is there                 30                      40                            50"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@CodeGeek..i think it will not in the below tree       A    /  \\   B    C  /\\   / \\ D  E  F  G  pre-order traversal will be A->B->D->E->C->F->G..  how will u reconstruct tree for the above one.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A \n \\ \n  B \n \nand  \n  A \n / \nB \n \nboth are two different trees but with same post-order, even with the N L notation. \nwhat about such case ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"so it is true that it is not possible to generate tree from just one traversal given."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can reconstruct tree from preorder, if the tree is BST and every node in the left sub-tree less than pivot, every node in the right sub-tree greater than pivot"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Yes thats true. But in question it was not mentioned that tree is BST."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hi... from pre-order traversal v can construct a unique tree if N and L info given, provided the condition mentioned \"every node can have 0 or at most 2 nodes\" is actually \"every node can have 0 or 2 nodes\", i.e. a node is not allowed to have a single child, coz that will create confusion as to whr it will go, left or right... otherwise the first N next to an N in the list will go to left, which solves the problem.  @mail2maulish .. does a node allowed to have just 1 child ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"do we have to write executable code during phone interview"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{ //let preorder traversal of a tree be in a array t   for(i = t.length; i>-1; i--){            if(t(i) == L){          stack.push(t[i]);      }else{          leftChild = s.pop(); // will return null if stack is empty          rightChild = s.pop(); // will return null if stack is empty          node = new Node(leftChild, rightChild);          stack.push(node);      }         }    root = stack.pop(); // get the root from the stack; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@sudhir: Your code will not work."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A pre order traversal will loose the structure of the tree.If it shudnt a node should have both child or none.If this is de case then foll code shud work i assume the traversal is in an array"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Guys, I think the question is ambiguous.  suppose we have two trees:           N                        N        /    \\                    /      N      N                 N     /         \\               /  \\    L           L             L    N                                      \\                                       L The pre-order traversal of both trees is: N N L N L"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@sudhir,@verma.tech Can  you please provide asap......I tried it but not succeed  Reply asap."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is not possible to rebuild the tree from this. e.g. NNNLLL can be               N      N         L   N    L  L  or                N      N            N    L  L    L"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is given that the node will have 0 or 2 children. Let N be represented by 1 and L be represented by 0  , so the code is"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I just have a pseudocode of sort that would probably work.  static preIndex = 0 BuildTree(PreOrder[]) { Node *tNode = newNode(PreOrder[preIndex++]); if(tNode->val = \"L\") then return tNode; tNode->left = BuildTree(preOrder[]) tNode->right = BuildTree(preOrder[]) return tNode }  root = BuildTree(PreOrder[]) is the call to be made."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node *formTree(string& str) {     int n=str.length();          Stack mystack;     node *root=NULL;          for(int i=0;i        node *temp=new node;            temp->left=temp->right=NULL;                                if(str[i]=='N'){                           temp->data='N';                        }          else if(str[i]=='L')            temp->data='L';            //cout<<\"\\nNode constructed. Value is \"<data;                            //connect it to the tree              if(!root) root=temp;              else {              while(mystack.isNotEmpty()){                node *tos=mystack.peek();                if(tos->left==NULL){                        tos->left=temp;                        break;                }                       else if(tos->right==NULL){                            tos->right=temp;                            break;                }                          else mystack.pop();                 }  //end of while                            }           if(str[i]=='N') mystack.push(temp);               } //end of for-loop            //if(mystack.isNotEmpty()) cout<<\"\\nSome error\";       return root; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution : using a stack to reconstruct the tree( assumption: there is NO node which have only one child , in that case, tree's shape is not deterministic ) input is a integer array, positive number means ??£þNode???, negative number means ??£þLeaf??? 1 if current cell is N, push tp stack 2 if current cell is L, make it to top??s left child (if no left child yet), otherwise make it as right child 3 if top have two children already, then pop, and make it as new top??s left or right child( left have priority than right, because go through  left-right preorddr traversal ), then check the new top, if it have two children alreay, keep popping"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"String s = \"nnnlllnll\"; \n        LinkedList string = new LinkedList(); \n        for (int i = 0; i < s.length(); i++) { \n            string.add(s.charAt(i) + \"\"); \n        } \n \nprivate static Node conTree(LinkedList string) { \n        if (string.isEmpty()) return null; \n        String data = string.pop(); \n        Node node; \n        if (data.equals(\"n\")) { \n            node = new Node(data); \n            node.setLeft(conTree(string)); \n            node.setRight(conTree(string)); \n        } else { \n            node = new Node(data); \n        } \n        return node; \n    }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13382675","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"51","title":"Given a BST, convert it so that each node has value equal to sum of all the nodes (including itself) which are greater than that node in the whole tree.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"Tested for all edge cases -"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"1. Postorder travarsal. \n     2. currnode --> data += prevNode-->data"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"This means that each node will contain its data + sum of all node's data in right subtree. node->data = node->data + (sum of all nodes in right subtree). Reverse Inorder would do the work for us.  Code: int sum = 0; //global variable sum_max (node *root) {   if (root == NULL)        return;  sum_max (root->right); sum = sum + root->data; root->data = sum; sum_max (root->left); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"int fun(struct node *right) \n{ \n    if(!root->right) \n         return root->data; \n    root->data+=fun(root->right); \n    return (root->data +fun(root->left)); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"If we have performed the requisite algorithm (rollUp) on the right subtree of a node, and now we need to perform that on the current node, we can just consider the value of the right node.  But the issue here is that the right node had ignored it's left subtree for getting it's value(because at any node, all the nodes in the right subtree have value greater than it.)  But this neglected left subtree of the current node's right node is important for calculating the value of current node.  So what we can do is.. we can try to remember the left subtree's sum, at any node of the tree, while doing recursion."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do a Reverse Inorder.  First Right subtree, then root, then Left.  (Postorder is not right as root node will get sum of all its children!)  Probably something like this (note: not tested)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I guess it is the \"flipped\" in-order traversal, which is different from post-order."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if a node is left child of its parent ,it will be having its right subtree sum and its parent and parents right subtree also"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int inorder(struct node* root,int sum) {     static int sum1=0;     if(root != NULL)     {        inorder(root->right,sum1);        sum1+=root->data;        root->data= sum1;        printf(\"%d,\",root->data);        inorder(root->left,sum1);         return root->data;     }      else     return 0;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int inorder(struct node* root,int sum) {     static int sum1=0;     if(root != NULL)     {        inorder(root->right,sum1);        sum1+=root->data;        root->data= sum1;        printf(\"%d,\",root->data);        inorder(root->left,sum1);         return root->data;     }      else     return 0;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"addRight(NODEPTR node) \n{ \n   if(node==NULL) return 0; \n   if(node->right==NULL & node->left==NULL) //leaf node \n        return node->info; \n   node->info=node->info+addRight(node->right); \n   return node->info+addRight(node->left); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Every time the function should return the sum and this sum must be passed to every recursive call. We are thereby passing the maximum value of all the nodes to call and reverse inorder traversal does the trick.  int Func(Node* root,int sum){ int rsum,lsum; if(root==NULL)return sum;  rsum = func(root->right,sum); root->data= rsum+root->data; rsum=root->data; printf(\"\\t%d\",root->data); lsum=func(root->left,root->data); if(rsum>lsum)sum = rsum; else sum =lsum; return sum; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi Friends , can you please explain me how it differs weather i use reverse inorder traversal or post order traversal as long as right traversal is before the current node evaluaiton.  What i mean is    public void Traverser(Object node){      if(node.right != null) Traverser(node.right);                   node.value+ =  node.right.value;                  if(node.left !=null ) Traverse(node.left);              }   Or  public void Traverser(Object node){      if(node.right != null) Traverser(node.right);                    if(node.left !=null ) Traverse(node.left);                     node.value+ =  node.right.value;           }     Or   public void Traverser(Object node){                                  if(node.left !=null ) Traverse(node.left);    if(node.right != null) Traverser(node.right);                   node.value+ =  node.right.value;               }   all 3 functions should return me the same result is it not ? what am i missing ? please help"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sorry i could not understand your que.. greater than all nodes means value wise greater all node or.. anything else.can you please tell more detail."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sumGreaterNodes( Node node , int parentValue){             if(node==null){                 return 0;             }             int sumNodesRight = sumGreaterNodes(node.right, parentValue);             int temp = node.value;             node.value += (sumNodesRight + parentValue);             int sumNodesLeft = sumGreaterNodes(node.left, node.value);              return temp + sumNodesRight + sumNodesLeft;     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this tree is then no longer a BST.. Should that be done as well ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(n^2)  Algorithm  Go to each node and calculate right subtree sum. Top Down approach. 2 Recursive calls. Java code follows:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"What happens if the predecessor has the same value as the current node? Do you count it as a sum or replica? I think what may be best is if in addition to returning sum from recursive call, one also returns a predecessor having greater key."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Process right subtree and then left subtree  int sum_BST(Node* iter) {   if(iter==NULL) return 0;     iter->data = iter->data + sum_inorder(iter->rc);      return sum_inorder(iter->lc) + iter->data; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int sum_BST(Node* iter) {   if(iter==NULL) return 0;     iter->data = iter->data + sum_inorder(iter->rc);      return sum_inorder(iter->lc) + iter->data; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int SumofRightTree(Tree *tree, bool isRight) {  if(tree != NULL)  {   SumofRightTree(tree->left, false);   tree->data = tree->data + SumofRightTree(tree->right, true);   return tree->data;  }  else   return 0;  } int _tmain(int argc, _TCHAR* argv[]) {  int arr[] = {30,10,5,20,50,40,60};  Tree *root=  NULL;   for(int i=0;i<7; i++)   root = CreateTree(root, arr[i]);   SumofRightTree(root, true);  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int SumofRightTree(Tree *tree, bool isRight) {  if(tree != NULL)  {   SumofRightTree(tree->left, false);   tree->data = tree->data + SumofRightTree(tree->right, true);   return tree->data;  }  else   return 0;  } int _tmain(int argc, _TCHAR* argv[]) {  int arr[] = {30,10,5,20,50,40,60};  Tree *root=  NULL;   for(int i=0;i<7; i++)   root = CreateTree(root, arr[i]);   SumofRightTree(root, true);  return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int sum(NODE *T) { if (T==NULL)return 0;  sum(T->left);  //dont use return val int temp = T->data; T->data = temp + sum(T->right); return(temp);  }  Please suggest mistake in the code if any."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int convert(TREE root) \n{ \n    int sumval = 0; \n if(root==NULL)return 0; \n convert(root->left); \n convert(root->right); \n if(root->left!=NULL || root->right!=NULL) \n {       //        cout<<\"\\n poitning to \"<info; \n sum(root->left,root->info,&sumval); //important cz though it is a BST initially still it is possible that the left child becomes greater than root intdelf \n sum(root->right,root->info,&sumval); \n    root->info += sumval; \n //cout<info; \n sumval = 0; \n   } \n} \nint sum(TREE root,int val,int *sumval) \n{ \n //int sumval = 0; \n if(root==NULL) return 0; \n if(root->info > val) \n { \n    //cout<<\"\\n Found greater = \"<info<<\" than \"<info; \n     //cout<<\"\\n sumval = \"<<*sumval; \n     sum(root->left,val,sumval); \n     sum(root->right,val,sumval); \n      \n     } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int transform(struct Node* root, int sum) { \n  if (!root) return sum; \n \n  root->data += transform(root->right, sum); \n  return transform(root->left, root->data); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"As most of the people said...keep adding the right children to the curr node while doing rev inorder.Only gotcha was returning sum back when we hit null.This is because, when we hit null, we are essentially returning from right hand side back to parent node always.Even in the case , when we return from left side of child node back to childs parent."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sum(tree*root) {  static int sum ;  if(!root)  return ;  sum(root->right) ;  root.data=sum+root.data ;  sum=root.data ;  sum(root.left) ;"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=11146157","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"65","title":"Find if a binary tree is bst","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"It's a mix of c and pseudo code. The only problem is if the first element(root) is equal to MIN_INT. An extra if statement can overcome that condition but I think this should work otherwise."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Do an Inorder traversal of the tree and check if that is sorted. If in-order traversal is sorted then it is a BST"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Inorder traversal should give a sorted array if the tree is a BST."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"previous is also correct another possible solution is find(node*root) { if (root!=NULL&&root->left!=NULL&&root->right!=NULL) if(root->value>root->left->value)&&(root->valueright->value) return true find(root->left) find(roo->right) }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"ramu's solution won't work for a tree like    3  1   6     2 8"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"3 / \\ 1{ }6 {  }/\\ {  }2 8"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I guess the recursive code is as follows:  find (node *root) {     if (root != NULL)              // if the node is null return true     {         bool leftNode = find (root->left);         bool rightNode = find (root->right);         if (leftNode && rightNode)           //both the criteria should agree else return false         {             if (root->right == NULL && root->left == NULL)   //leaf node                 return true;             else if (root->right == NULL)         //When the right child is null             {                  if (root->data > root->left->data)                      return true;                  else                      return false;             }             else if (root->left == NULL)        //when left child is null             {                 if (root->info < root->right->info)                     return true;                 else                     return false;             }             else             {                 if (root->info > root->left->info && root->info < root->right->info)                      return true;                 else                      return false;             }         }         return false;     }     return true; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this way should be simple and clear, is there anything wrong? Hope to get your critiques.  public static boolean findIsBFS(Node root) {  if(root==NULL || (!root.leftchild && !root.rightchild))  {    return true;  }  if(root.leftchild.value>root.value || root.rightchild.value {   return false;  }  return findIsBFS(root.leftchild) && findIsBFS(root.rightchild); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"typedef struct tnode {     int i;  struct tnode* lt;  struct tnode* rt; } TreeNode;  bool IsValidBST(TreeNode *node, int min, int max) {  if ((node == NULL) || ((node->lt == NULL) && (node->rt == NULL)))  {   return true;  }  if ((node->i < max) &&    (node->i > min) &&    IsValidBST(node->lt, min , node->i) &&    IsValidBST(node->rt, node->i , max ))  {   return true;  } }The code is very straightforward. as you go down the tree, keep a track of the max and min values that a particular node can take.  you can call this method with MININT and MAXINT values for min and max.  Let me know your comments"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We should leverage properties of binary search tree: the left child value is less or equal to the node value and the right child value should be greater or equal than the node value. And check that property for each node. The code is using preorder traversal.  Assuming that null child is ok."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Take an in-order traversal of the tree and it should be sorted for a BST"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.find the max and min of the given tree, in BST its the right most and left most elements,so thorugh findmax() and findmin() we get the same 2.we increment  the minnode and decrement maxnode ,so that the checking we are doing won't fail at the leftmost and rightmost nodes 3.traverse through each node and check wheteher they lie in the suiatable range or not 4.revert back the change we made  typedef struct node         {                 int data;                 struct node *right;                 struct node *left;         }node; node* findmax(node *root); node* findmin(node *root); int check_BST(node *root, int min, int max);  int main()         {                 int min,max;                 node *root,*maxnode,*minnode;                 maxnode= findmax(root);                 minnode= findmin(root);                 if(maxnode == NULL || minnode ==NULL)                         return -1;                 min=min->data++;                 max-max->node--;                 if(check_BST(root,min,max));                         printf(\"\\n valid BST\");                 else                         printf(\"\\n non-valid BST\");                 min->data++;                 max->data--;         }  node* findmin(node *root)         {                 if(root== NULL)                         return NULL;                 node *temp1 = malloc(sizeof(node));                 if(!temp1)                         printf(\"\\n memmory not available\");                 while(root->left)                         root=root->left;                 temp1=root;                 return temp1;         } node* findmax(node *root)         {                 if(root== NULL)                         return NULL;                 node *temp2 = malloc(sizeof(node));                 if(!temp2)                         printf(\"\\n memmory not available\");                 while(root->right)                         root=root->right;                 temp2=root;                 return temp2;         }  int check_BST( node *root, int min, int max)         {                 if(root == NULL)                         return 1;                 if(root->data < max && root->data >min)                         {                                 return( check_bst(root->left,min,root->data) && check_BST(root->right,root->data, max));                         }                 else                         return 0;         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"here is simpler code to understand.  bool isThisABST(struct node* mynode) { if (mynode==NULL) return(true);  if (node->left!=NULL && mynode->left->info > mynode->data) return(false);  if (node->right!=NULL && mynode->right->info <= mynode->data) return(false);  if (!isThisABST(node->left) || !isThisABST(node->right)) return(false);  return(true); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this works. Have to check if the max of the left subtree is less than current node and min of the right subtree is always greater."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My recursive solution is as follow :  Bool IsBst ( Tree root ) {          if ( root == NULL )                   return true;           if ( ( root->left  == NULL && root->right == NULL ) ||   /* case 1 */               ( root->left == NULL &&  root->data < root->right->data ) ||    /* case 2 */               ( root->right == NULL && root->data > root->left->data )  ||    /* case 3 */               ( root->right != NULL && root->left != NULL && root->data > root->left->data && root->data < root->right->data) )     /* case 4 */          {                    return IsBst( root->left ) && IsBst( root->right ) ;  /* current node is OK, check children recursively */          }          else                    return false ;    /* current node is Bad, return false directly */  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int arr[10];  void check(tree*root) { if(root->left!=NULL)     check(root->left); arr[i++]=root->val; if(root->right!=NULL) check(root->right);   }    int main::  int found=0;  for(int i=0;i<=7; i++) {   cout<<\"\\n \"<if((arr[i]>arr[i+1])&&i!=7 )//7 elements     found=1; } if (found==0)     cout<<\"\\nBINARY SEARCH TREE IT IS:SORTED\";     else     cout<<\"NOT A BINARY SEARCH TREE\"; return 0;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int arr[10];  void check(tree*root) { if(root->left!=NULL)     check(root->left); arr[i++]=root->val; if(root->right!=NULL) check(root->right);   }    int main::  int found=0;  for(int i=0;i<=7; i++) {   cout<<\"\\n \"<if((arr[i]>arr[i+1])&&i!=7 )//7 elements     found=1; } if (found==0)     cout<<\"\\nBINARY SEARCH TREE IT IS:SORTED\";     else     cout<<\"NOT A BINARY SEARCH TREE\"; return 0;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int arr[10];  void check(tree*root) { if(root->left!=NULL)     check(root->left); arr[i++]=root->val; if(root->right!=NULL) check(root->right);   }    int main::  int found=0;  for(int i=0;i<=7; i++) {   cout<<\"\\n \"<if((arr[i]>arr[i+1])&&i!=7 )//7 elements     found=1; } if (found==0)     cout<<\"\\nBINARY SEARCH TREE IT IS:SORTED\";     else     cout<<\"NOT A BINARY SEARCH TREE\"; return 0;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int arr[10];  void check(tree*root) { if(root->left!=NULL)     check(root->left); arr[i++]=root->val; if(root->right!=NULL) check(root->right);   }    int main::  int found=0;  for(int i=0;i<=7; i++) {   cout<<\"\\n \"<if((arr[i]>arr[i+1])&&i!=7 )//7 elements     found=1; } if (found==0)     cout<<\"\\nBINARY SEARCH TREE IT IS:SORTED\";     else     cout<<\"NOT A BINARY SEARCH TREE\"; return 0;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int arr[10];  void check(tree*root) { if(root->left!=NULL)     check(root->left); arr[i++]=root->val; if(root->right!=NULL) check(root->right);   }    int main::  int found=0;  for(int i=0;i<=7; i++) {   cout<<\"\\n \"<if((arr[i]>arr[i+1])&&i!=7 )//7 elements     found=1; } if (found==0)     cout<<\"\\nBINARY SEARCH TREE IT IS:SORTED\";     else     cout<<\"NOT A BINARY SEARCH TREE\"; return 0;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int arr[10];  void check(tree*root) { if(root->left!=NULL)     check(root->left); arr[i++]=root->val; if(root->right!=NULL) check(root->right);   }    int main::  int found=0;  for(int i=0;i<=7; i++) {   cout<<\"\\n \"<if((arr[i]>arr[i+1])&&i!=7 )//7 elements     found=1; } if (found==0)     cout<<\"\\nBINARY SEARCH TREE IT IS:SORTED\";     else     cout<<\"NOT A BINARY SEARCH TREE\"; return 0;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int arr[10];  void check(tree*root) { if(root->left!=NULL)     check(root->left); arr[i++]=root->val; if(root->right!=NULL) check(root->right);   }    int main::  int found=0;  for(int i=0;i<=7; i++) {   cout<<\"\\n \"<if((arr[i]>arr[i+1])&&i!=7 )//7 elements     found=1; } if (found==0)     cout<<\"\\nBINARY SEARCH TREE IT IS:SORTED\";     else     cout<<\"NOT A BINARY SEARCH TREE\"; return 0;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int arr[10];  void check(tree*root) { if(root->left!=NULL)     check(root->left); arr[i++]=root->val; if(root->right!=NULL) check(root->right);   }    int main::  int found=0;  for(int i=0;i<=7; i++) {   cout<<\"\\n \"<if((arr[i]>arr[i+1])&&i!=7 )//7 elements     found=1; } if (found==0)     cout<<\"\\nBINARY SEARCH TREE IT IS:SORTED\";     else     cout<<\"NOT A BINARY SEARCH TREE\"; return 0;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int arr[10];  void check(tree*root) { if(root->left!=NULL)     check(root->left); arr[i++]=root->val; if(root->right!=NULL) check(root->right);   }    int main::  int found=0;  for(int i=0;i<=7; i++) {   cout<<\"\\n \"<if((arr[i]>arr[i+1])&&i!=7 )//7 elements     found=1; } if (found==0)     cout<<\"\\nBINARY SEARCH TREE IT IS:SORTED\";     else     cout<<\"NOT A BINARY SEARCH TREE\"; return 0;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int arr[10];  void check(tree*root) { if(root->left!=NULL)     check(root->left); arr[i++]=root->val; if(root->right!=NULL) check(root->right);   }    int main::  int found=0;  for(int i=0;i<=7; i++) {   cout<<\"\\n \"<if((arr[i]>arr[i+1])&&i!=7 )//7 elements     found=1; } if (found==0)     cout<<\"\\nBINARY SEARCH TREE IT IS:SORTED\";     else     cout<<\"NOT A BINARY SEARCH TREE\"; return 0;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int arr[10];  void check(tree*root) { if(root->left!=NULL)     check(root->left); arr[i++]=root->val; if(root->right!=NULL) check(root->right);   }    int main::  int found=0;  for(int i=0;i<=7; i++) {   cout<<\"\\n \"<if((arr[i]>arr[i+1])&&i!=7 )//7 elements     found=1; } if (found==0)     cout<<\"\\nBINARY SEARCH TREE IT IS:SORTED\";     else     cout<<\"NOT A BINARY SEARCH TREE\"; return 0;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//7 element  int arr[10];  void check(tree*root)   //inorder traverse { if(root->left!=NULL)     check(root->left); arr[i++]=root->val; if(root->right!=NULL) check(root->right);   }    int main::   check(root); int found=0;  for(int i=0;i<=7; i++) {   cout<<\"\\n \"<if((arr[i]>arr[i+1])&&i!=7 )//7 elements     found=1; } if (found==0)     cout<<\"\\nBINARY SEARCH TREE IT IS:SORTED\";     else     cout<<\"NOT A BINARY SEARCH TREE\"; return 0;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool isBinarySearchTree(node *root) { \n  return (!root->left || \n          (root->left && \n           root->left->data <= root->data && \n           isBinarySearchTree(root->left))) \n    && (!root->right || \n        (root->right && \n         root->right->data > root->data && \n         isBinarySearchTree(root->right))); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Approach   The solution is to check, for every node in the tree, the min and max key values of the nodes in its left sub tree is less than the value of its key and the min and max key values in its right sub tree is greater than the value of its key. This can be achieved by recursion.   The idea is to ??£þbubble up??? the min and max values of a node??s sub tree, after satisfying the conditions above, to its parent node, which will in turn repeat the same process. The algorithm is designed around pre-order tree traversal and solves the problem in O(n) (linear) time.   Algorithm   For the current node:   Step1: Get the min and max values for left sub tree if left child exists   Step2: If the min and max values are greater or equal to current node??s key, return ??£þNot BST???   Step 3: If there is no left child, set the min value to current node??s key value   Step 4: Get the min and max values for right sub tree if right child exists   Step 5: If the min and max values are lesser or equal to current node??s key, return ??£þNot BST???   Step 6: If there is no right sub tree, set the min value from step 1 and the max value to current node??s key value   Step 7: Return the min value from step 1 and max value from step 6  You can find the code and the explanation using a pictorial representation of the binary tree in my blog linearspacetime[dot]blogspot[dot]com"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool ifBst(node* p) {     return ((p==null) || (p->data < p->left->data && p->data >= p->right->data && ifBst(p->left) && ifBst(p->right)); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Another solution. While traversing inorder keep track of the prev node visited & ensure that every previous node visited has less [or equal] value than the current node value."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Solution should be Inplace..!!!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please verify this code....."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This calls for a recursive solution in which u would at each step check if the left subtree is a BST, right subtree is a BST and the root lies between max of left and min of right subtree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"similar question at: question?id=11146157"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Inorder traversal gives a sorted array if and only if tree is BST!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static boolean isBST(BinaryTree binaryTree, Integer lowerBoundExclusive, Integer upperBoundExclusive){   System.out.println(\"binaryTree: \" + binaryTree.getInfo());   BinaryTree binaryTreeLeft = binaryTree.getLeftChild();   if(binaryTreeLeft != null && (binaryTree.getInfo().compareTo(binaryTreeLeft.getInfo()) < 1 || (lowerBoundExclusive != null &&  lowerBoundExclusive.compareTo(binaryTreeLeft.getInfo()) > -1)))    return false;      BinaryTree binaryTreeRight = binaryTree.getRightChild();   if(binaryTreeRight != null && (binaryTree.getInfo().compareTo(binaryTreeRight.getInfo()) > -1 || (upperBoundExclusive != null &&  upperBoundExclusive.compareTo(binaryTreeRight.getInfo()) < 1)))    return false;   boolean isLeftSubTreeBST = binaryTreeLeft == null ? true : isBST(binaryTreeLeft, lowerBoundExclusive, binaryTree.getInfo());   if(!isLeftSubTreeBST)    return false;      boolean isRightSubTreeBST = binaryTreeRight == null ? true : isBST(binaryTreeRight, binaryTree.getInfo(), upperBoundExclusive);   if(!isRightSubTreeBST)    return false;   return true;     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool isBST(Node* root, int& previousValue) \n{ \n    if ( root ) \n    { \n        if ( !isBST(root->m_left,previousValue) ) \n        { \n            return false; \n        } \n        std::cout<<\"\\t\"<m_data<<\" prev :\"<m_data < previousValue ) \n        { \n            return false; \n        } \n        previousValue =  root->m_data; \n       if ( !isBST(root->m_right, previousValue) ) \n       { \n           return false; \n       } \n    } \n    return true; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This should work, even if MAX_INT or MIN_INT are in the tree -"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"/**  * Created by IntelliJ IDEA.  * User: andrey  * Date: 10/10/11  * Time: 10:50 AM  */ public class BinarySearchTreeOrNot {      public static void main(String[] args) {         BinarySearchTreeOrNot test = new BinarySearchTreeOrNot();         test.run();     }      void run() {          // test with binary search tree         Node bst = createBinarySearchTree();          boolean result = isBinarySearchTreeNode(bst);          System.out.println(result);          // test with binary tree         Node bt = createBinaryTree();          result = isBinarySearchTreeNode(bt);          System.out.println(result);      }      boolean isBinarySearchTreeNode(Node node){          if (node == null) return true;          if (node.left != null && node.left.value > node.value) return false;          if (node.right != null && node.right.value < node.value) return false;          return isBinarySearchTreeNode(node.left) && isBinarySearchTreeNode(node.right);      }      Node createBinarySearchTree(){         Node one = new Node(1);         Node four = new Node(4);         Node three = new Node(3);         three.left = one;         three.right = four;         Node five = new Node(5);         Node six = new Node(6);         Node seven = new Node(7);         Node nine = new Node(9);         five.left = three;         five.right = seven;         seven.left = six;         seven.right = nine;         return five;     }      Node createBinaryTree(){         Node five = new Node(5);         Node eight = new Node(8);         Node one = new Node(1);         Node sixteen = new Node(16);         Node three = new Node(3);         Node nine = new Node(9);         Node two = new Node(2);          five.left = eight;         five.right = three;         eight.left = one;         eight.right = sixteen;         three.left = nine;         three.right = two;          return five;     }       class Node {          int value;          Node right;         Node left;          Node(int value){             this.value = value;         }     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"boolean isBST(node root) { \n if ( root == null || (root.left == null && root.right == null )) { \n  return true; \n } \n if ( root.left == null && root.right == null ) { \n  return true; \n } \n if ( root.left > root.right ) { \n  return false; \n } \n return (isBST(root.left) && isBST(root.right)); \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13394663","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"63","title":"Given a dictionary of strings [ strings are in sorted order] you have to find the precedence of characters according to the dictionary.. eat bxy e is ranked above b according to the dictionary.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"9","title":"I presume the question gives you sorted strings.  Just form a graph(DAG) and do a topological sort."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Graph creation:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Thanks. I think DAG is the way to go. But as I see from here http://en.wikipedia.org/wiki/Topological_sorting after DAG, I think we can sort by DFS to find the sorted order as the solution by Topological Sort is not necessarily unique as it depends on random node u pick for the sorting. Correct if I am wrong."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This question has been asked many times before. I've already reported as duplicate.  1. Create a DAG from letters by comparing each word with the next. Since the word list is sorted, comparing the letters by location, gives which letter comes before the other. 2. Topological sort of the DAG will give you the order of the letters in the alphabet"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"\"precedence order on the alphabet set \" - can somebody please explain this.   and if the words are coming in sorted order what is the criterion  for the ordering of the words. if the ordering of words are Lexicographic order then final output of the algo by mpmaster doesn't look okay.   please correct me if i am wrong."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@Addy I think by precedence order we are asked to find the final sorted order of the set. For eg, we know A is greater than B, but in the given set we do not know the order. We have to find the order of the set based on a set of sorted words given to us. I am not clearly understanding Lexicographic order part and how this would fail.   It would be great if you can give more insight on this."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sorry the previous comment was by me!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i agree with LOLer's solution of using a DAG and topological sorting...that solves the problem...btw, nice question!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Yes, Loler is right. At least thats what I had in mind (when posting the question). To elaborate the sol.  Constructing the dag - {for now lets assume its english lang we are dealing with)  Consider a pair of words in the list with w1 < w2. We can draw a small edge between letters which come after common prefix. For eg. disgruntled < disinterested. Then g-->i.   This will form a dag. Top sort it.  Note that this graph may not be connected. In which case our dataset is insufficient to deduce complete order of the alphabetset from. Though you can have isolated pockets of letters with order defined."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Isn't it the Topological sorting of graphs ???"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"now the question is how to create that graph... here is my approach:  example:  given words: acd ab cbe de     every position in word gives a list of sort alphabets. so we have k (max number of characters in longest word given as input) so here k=3 while charplace..for all given words word[i] ....go through charater in word at position k and place this in already built graph remembering that it comes after the character in earlier words[0-i][k] at position k   so here is how it works. after first iteration: (a->c, c->d)=> a->c->d after 2nd iteration: a->c->d and a->c->b->e (cant wirte like graph here) after 3rd iteration: a->c->d->e and a->c->b->e  after topological sorting u will get: a c b/d e (2 answers)  if we had one more word like: bd then this wil give only one answer: a c b d e"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the topological sort goes with the assumption that there is atleast one character that occurs nowhere but as the first character of the list of words.   otherwise topological sort would fail as there arent any nodes with 0 in-degree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am still confused. Can someone help ?   \"You are then given a set of words coming from the language in the sorted order\" - List of word sorted ( acb,cba, bca) or word itself is sorted (abc,bc, c) or both (a, ab,bc, abc) ??? Case 1 : Traversing the array and create an edge between two alphabet with distance 1 or infinite(if unknown) Traversing the array would give you a acyclic traversal with covering all nodes., other there is no unique solution to the problem.  Case 2 Assuming words are sorted Then each word is a graph, clubbed together all the word to form a unified graph. Perform topological sort  Please help me understand the question and its probable solution.  Thanks Ankush"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this question has been asked before. topological  sort"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"-- > Construct a Graph . Check for cycles . In case of cycles , no solution exists . ---> Topological Sort of the DAG is the answer ."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static String sortBasedOnKey(String sort, String key)     {  String result = \"\";    int[] count = new int[key.length()];   for (char ch:sort.toCharArray())  {      boolean isKey = false;            for (int i=0;i     {   if (key.charAt(i) == ch)   {       count[i]++;       isKey = true;   }      }            if (!isKey)      {   result +=ch;      }  }   for (int i = count.length-1;i>=0;i--)  {      for (int j=0;j     {   result = key.charAt(i)+result;      }  }    return result;     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//====define the graph public class Node {  public char value;  public List ajacent;  public String color;    public Node(char value) {   this.value = value;   this.ajacent = new ArrayList();   this.color = \"white\";  } }  public Node buildG(String[] strings) {  Node root = null;  Node current = null;  for(int i=0;i  char[] charArr = strings.charArray();   if(i == 0) {    root = current;    }   addAjacent(root,charArr,current);   current = new Node(charArr[0]);     }  return root; }  public void addAjacent(Node root, char[] chars, Node current) {  if(root == null) {   return;  }    ArrayList nodelist = new ArrayList();  for(int i=0;i  Node oldNode = findNOde(chars[i],root);   if(oldNode != null) {    nodelist.add(oldNode);   } else {    Node newNode = new Node(chars[i]);    nodelist.add(newNode);      }    }  for(int i=0;i  List ajacent = new ArrayList();   for(int j=i+1;j   ajacent.add(nodelist.get(j));   }   nodelist.get(i).ajacent = ajacent;  }  if(current != null) {   current.ajacent.add(nodelist.get(0));  }  nodelist.clear(); }   public Node findNOde(char value,Node root) {  if(root.value == value) {   return root;  } else {   root.color = grey;  }  for(Node node:root.ajacent) {   if(node.color.equals(\"white\") {    return findNode(value,node);   }  }  root.color = \"black\";  refreshStatus(root);  return null; }  public void refreshStatus(Node root) {  for(Node node:root.ajacent) {   node.color = \"white\";   refreshStatus(node);  } }  //====find the precedence  public List findPrecedence(char value,Node root) {  List precedences = new ArrayList();  root.color = \"grey\";  for(Node node:root.ajacent) {   if(node.value == value) {    precedences.add(root.value);   } else {    if(node.color.equals(\"white\")){     List subpres = findPrecedence(value,node);     node.color = \"grey\";     precedences.copyAll(subpres);    }   }  }  return precedences; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// The idea is to build the precedence between alphabets to create a  // directed graph. If there is cycle, then training set is not correct - error out; // otherwise do topological sort for constructed DAG to return alphabet in partial order."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This comment has been deleted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is the following an accurate re-statement of the problem?  There exists an alphabet comprising some number of characters. The order of the alphabet, i.e. the full-ordering, is not known. You are given a list of \"words\" comprised of characters from the alphabet. The list of words is given to be sorted in lexicographical order. Write a program to deduce the order of the alphabet.  Bonus: 1. What is the space/time complexity of your algorithm? 2. Given the problem statement, is it possible to deduce the full (complete) order of the alphabet? Explain your answer in detail."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is a great problem. I really don't like (or perhaps don't fully comprehend) the answers given on this thread. Let's dig deeper on this one and explore:  Problem restatement: There exists an alphabet comprising some number of characters. The order of the alphabet, i.e. the full-ordering, is not known. You are given a list of \"words\" comprised of characters from the alphabet. The list of words is given to be sorted in lexicographical order. Write a program to deduce the order of the alphabet.  For the sake of example, let's assume that we're using an English alphabet (i.e. we know the full order). Now assume we have a set of words sorted in ascending lexicographical order:  aardvark ant bee cat cow dog horse llama sheep zebra  Given that we know the order of the English alphabet, it's easy to see that the list of animals comprising our input data is correctly sorted.  Now forget that you know anything at all about the English alphabet. Erase from your mind the fact that you know which characters comprise the alphabet (the problem statement doesn't bound the set of characters or make any guarantee that the set of words use all characters in the alphabet). Also, erase from your mind the fact that you know the order of the English alphabet.   Let's take the first word \"aardvark\". What does this tell us? It tells us that the characters \"a\", \"r\", \"d\", \"v\", and \"k\" are present in the alphabet. Does it provide any information that can be used to establish the order of these characters? NO! Remember that it's the order of the words in the list and thus comparisons between adjacent words in the list that provides clues about the order of the alphabet.  Okay, now let's look at the first and second words:  aardvark ant  What does this tell us? We see two new characters \"n\" and \"t\" by inspection of \"ant\". What's more we notice that the characters in the first column are both \"a\". So clearly the lexicographical ordering of these two words wasn't decided on the basis of the first column. Looking at the second column we note that the characters are different and correctly conclude that in our alphabet \"a\" proceeds \"n\".  How about the third column? Sorry, no more clues here. We know that the order of \"aardvark\" and \"ant\" was decided on the basis of the second column character and cannot deduce anything further by comparing the third column.  So on we go through the list of animal words... Below I've reproduced the lexicographically sorted list of words in the left column, and indicate the \"clues\" in the right column. For simplicity I'm not going to list new characters discovered in the alphabet but rather focus only on clues about the order of the characters in the alphabet.  Note that because you actually do know the order of the English alphabet, you can easily vet this information without doing insane mental gymnastics. Also note that by convention an order clue is indicated by an ordered pair representing an edge in a directed graph. For example (a,b) indicates a directed edge from tail vertex \"a\" to head vertex \"b\" indicating that \"a\" proceeds \"b\" in the alphabet.  aardvark       no order clues ant                (a,n) based on column 2 bee               (a,b) based on column 1 cat                (b,c) based on column 1 cow               (a,o) based on column 2 dog               (c,d) based on column 1 horse            (d,h) based on column 1 llama            (h,l) based on column 1 sheep           (l,s) based on column 1 zebra            (s,z) based on column 1    n   / a -> b -> c -> d -> h -> l -> s -> z   \\    o  Now remember that you know the order of the English alphabet and vet this graph. Makes sense right? For example we know that \"n\" comes after \"a\" as does \"b\" and \"o\". And clearly a -> b -> c -> d -> h -> l -> s -> z is correctly ordered.  Note that given our sorted list of animals we do not know the order of \"b\", \"n\" and \"o\". All we know is that they follow \"a\".  Also note that there are bunch of characters used in our list of animal words for which no clues were found. These are not show in the ASCII graph above. But these are really in the graph too (all with zero in-degree).  I seriously question the utility of doing a topological sort... It would produce a somewhat interesting result BUT is essentially meaningless except in the case that every vertex has out-degree one.  You could imagine a system that attempts to deduce ordering on an alphabet that exposes an interface DoesXProceedY(x, y) which returns YES, NO or KNOWN. Such a system could not (in general) use a topological sort of the graph to deduce the correct answer. Instead, it would need the graph topology.  Hope this helps."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Graph creation:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"why dont we use Tries here"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"c++ code here.. for constructing DAG from pair of consecutive two strings. And topological sort over constructed DAG."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node[] create_graph(String[] list){ \n HashSet set = new HashSet(); \n for (int i = 0 ; i < list.length ; i++) \n  for (int j = 0 ; j < list[i].length() ; j++) \n   if (!set.contains(list[i].charAt(j))) \n    set.add(list[i].charAt(j))); \n int char_size = set.size(); \n Node[] G = new Node[char_size]; \n HashMap map = new HashMap(); \n int index = 0; \n for (int i = 0 ; i < list.length ; i++) \n  for (int j = 0 ; j < list[i].length() ; j++){ \n   Node[index] = new Node(list[i].charAt(j)); \n   map.put(list[i].charAt(j) , Node[index]); \n  } \n for (char C : set){ \n  for (int i = 0 ; i < list.length ; i++){ \n   boolean seen = false; \n   for (int j = 0; j < list[i].length() ; j++){ \n    if (list[i].charAt(j) == C) \n     seen = true; \n    else if (seen == true){ \n     map.get(list[i].charAt(j)).following.add(list[i].charAt(j)); \n    } \n   } \n  } \n } \n //Now the graph is ready , we need to to DFS on it , to topoligically sort it  \n Topological-Sort(G); \n //output the list of node's characters \n} \nchar[] Topological-Sort(Node[] G){ \n int time = 0; \n for (int i = 0 ; i < G.length ; i++) \n  if (!G[i].visited) \n   DFS-Visit(G[i] , time); \n //sort in DECREASING ORDER based on each Node's FINISH_TIME \n //we can use counting sort , as there aren't many nodes and the integers (time values) are not very large \n \n int max = Integer.MIN_VALUE; \n for (int i = 0 ; i < G.length ; i++) \n  if (max < G[i].finish_time) \n   max = G[i].finish_time; \n int[] counter = new int[max + 1]; \n for (int i = 0 ; i < G.length ; i++) \n  counter[G[i].finish_time]++; \n for (int i = 1 ; i < counter.length ; i++) \n  counter[i] += counter[i-1]; \n Node[] helper = new Node[G.length]; \n for (int i = counter.length - 1 ; i>= 0 ; i--){ \n  helper[counter[G[i].finish_time]] = G[i]; \n  counter[G[i].finish_time]--; \n } \n for (int i = 0 ; i < helper.length ; i++) \n  Node[i] = helper[i]; \n int left = 0 ; \n int right = Node.length; \n while (left < right){ \n  Node temp = Node[left]; \n  Node[left] = Node[right]; \n  Node[right] = temp; \n  left++; \n  right--; \n } \n char[] result = new char[G.length]; \n for (int i = 0 ; i < G.length ; i++) \n  result[i] = G[i].c; \n return result; \n} \nvoid DFS-Visit(Node n , int time ){ \n n.visited = true; \n n.visit_time = time; \n time++; \n for (int i = 0 ; i < n.following.size() ; i++) \n  if (!n.following.get(i).visited) \n   DFS-Visit(n.following.get(i) , time); \n time++; \n n.finish_time = time; \n} \n \n \nclass Node{ \n int visit_time , finish_time; \n boolean visited; \n ArrayList following; \n char c; \n public Node(char c){ \n  following = new ArrayList(); \n  visited = false; \n  this.c = c; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"By the way, given sequence {fac, faa, aac} is not sufficient to determine the complete alphabet ordering. To be specific, the order of \"f\" and \"c\" can't be determined."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sites.google.com/site/spaceofjameschen/home/stl/find-dictionary-order----google hash_map s;     set> orderPair;      for(int i = 0; i < dict.size(); ++i)     {         for(int j = 0; j < dict[i].size(); ++j){             s.insert(make_pair(dict[i][j], 0));         }     }      for(int i = 0; i < dict.size() - 1; ++i){         string str1 = dict[i];         string str2 = dict[i + 1];          int j = 0;         while(str1[j] == str2[j]){             j ++;         }         orderPair.insert(make_pair(str1[j], str2[j]));     }      bool changed = true;     while(changed)     {         changed = false;         for(auto it = orderPair.begin(); it != orderPair.end(); ++it){             int ord1 = s[it->first];             int ord2 = s[it->second];              if(ord2 != max(ord1 + 1, ord2)){                 changed = true;                 s[it->second] = max(ord1 + 1, ord2);             }         }     }      cout << \"----------------------------\" << endl;     for(auto it = s.begin(); it != s.end(); ++ it){         order.push_back(make_pair(it->first, it->second));     }      sort(order.begin(), order.end(),          [=](pair i, pair j)->bool         {return i.second < j.second;});"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Let set be {$, !, &, *, %, #} set of words  $, * !, & *, # &, $, @ #, @  Final answer is there are n positions that needs to be filled up with n alphabets in ascending order. We can give weights to each alphabets, finally all weights shud be 1 to n.  As you encounter each alphabet, give weights in increasing order. If the alphabet already has a weight in the previous word, then in this word it should start with that word and the remaining alphabets should have weights above this number. Eventually when u finish they ll have corresponding weights. After first word: $ -1, *-2  2nd word: !(not present in first word so give 1)-1, &(not present in first word so give 2)-2 After second word :  $-1, *-2 !-1, &-2  3rd word: *-2, #-3   (*-present in first with 2, pick the maximum value in whichever word it was there) After third Word:  $ -1, *-2 !-1, &-2 *-2, #-3   (*-present in first with 2, pick the maximum value in whichever word it was there)  4th word:  & - 2 (it was present in 3rd word with this value) $ -3(But it is already present with value 1. So wherever it was present make it 3, and the others after it in that word should increase by 2(3-1)) After 4th word: (The key is after each instance, each symbol should have the same weight in all the words ie, if $ is 3 in first word, it should be 3 in every word) $-3, *-4 !-1, &-2 *-4, #-5 &-2, $-3, @-4  5th word #-5, @-6 After 5th word: $-3, *-4 !-1, &-2 *-4, #-5 &-2, $-3, @-6  Now each of them have unique positions and the precedence order is !, &, $, *, #, @ with values 1, 2, 3, 4, 5, 6.  This is the algorithm. Haven??t thought about data structures to implement this. But I think it should be fairly simple."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This comment has been deleted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"You can build a directed graph and traverse it in order to find the precedence of characters. in this case e--->b .. similarly do for all other words in dictionary .."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"We can traverse the Sorted Dictionary just concerning ourselves with the first letter. This we we can build a LinkedHashMap.Traversing which will give us the Precedence Order."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"1. Extract all relation couples from dictionary. Remove duplicates. E.g.: dictionary (and, ant, bet) will result in (a,b), (d,t). 2. Build a digraph with letters as nodes and relation couples as directed edges. Label all nodes with 0. This digraph has no cicles. 3. Traverse the graph BFS starting from first node (the first letter of the first dictionary word) and \"relax\" the nodes as we encounter them. Relaxing here means to replace the node label with the BFS step. In the end each node will be labeled with the longest path length from start node. 4. If two nodes have same label then there is no solution. Otherwise the label order gives the alphabet order."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=231668","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"46","title":"find LCA (lowest common ancestor) for non binary tree.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"for both the nodes, find path from the Root. Get the continuous common sequence of both the path starting from the Root. The last node of the above sequence is the Lowest common Ancestor."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"1)Find Path to both nodes and store sequence in two arrays. [O(logk)] 2)Compare array values at same index.Last common value is the LCA. [O(logk) as max length possible of array is O(logk)]"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hey anonymous..  how did you solve the lowest common ancestor problem for a binary tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can u write the description of the problem"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Count the number of possible binary trees given the n nodes contain the same data ....  is such a vague quesion"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"given an n nodes with the same data  , find the different ways by which it can be represented ex node1 -> right child  node 2 -> rightchild node3 or node1 -> leftchild node2 -> rightchild node 3"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//Each node can be the root of the binary tree int func(int n) { int sum=0; int i=0; if (n==0)||(n==1) return 1; for(i=0;i{   sum+=f(i)*f(n-1-i);   //f(i) is the possible number of left sub-tree   //f(n-1-i) is that of right sub-tree } return sum;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"seige how can u find both nodes in log k time its not bst."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the idea is, if a node knows its left subtree contains either ONE, and right subtree contains the OTHER, it must be the least common ancestor. Then we use recursion to solve it. Below is the code, assuming we use char to indicate the node, and no two nodes have the same value in the tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the idea is, if a node knows its left subtree contains either ONE, and right subtree contains the OTHER, it must be the least common ancestor. Then we use recursion to solve it. Below is the code, assuming we use char to indicate the node, and no two nodes have the same value in the tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"the idea is, if a node knows its left subtree contains either ONE, and right subtree contains the OTHER, it must be the least common ancestor. Then we use recursion to solve it. Below is the code, assuming we use char to indicate the node, and no two nodes have the same value in the tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@Anonymous, the Questions Poster. Just by answering this question you got placed in MS, very nice ? to me it sounds fishy. r u still there or been fired? i guess must have been fired in these times of slowdown.  BTW, how many people have been placed in BIGGIES  after visiting this site?  +1 here for our poster."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be done in O(log n).  1. Traverse the 1st node in the tree and put it in the hashtable. 2. Now when you are traversing the Node 'b' then lookup O(1) in the hashtable for the value (node->data) in the table.  3. If it matched then that is your ancestor.   Running time would be O(log n) + O( log n) = O(log n).  PS: I am considering that all the values in the tree are unique.   Correct me if I am wrong !!!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"anyone?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"To find LCA for nodes A and B:  O((logn)^2): 1. Find in A in left subtree, B in right subtree 2. If both not found, find in A in right subtree, B in left subtree 3. If both found, current node is the common LCA 4. If one found and not the other, make a recursive to call to that branch of the tree and start from 1.  O(nlogn) with O(n) space: 1. Traverse the tree until node A is found, store the path in an array a1. 2. Traverse the tree until node B is found, store the path in an array a2. 3. Compare a1 and a2, the last common element is the LCA.  But there are better, more complicated ways of doing this in constant time using RMQ.  http://www.topcoder.com/tc?module=Static&d1=tutorials&d2=lowestCommonAncestor#Lowest%20Common%20Ancestor%20%28LCA%29"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"JustDoIt & Siege's solutions are perfectly correct !! Thanks Guys .. Though Siege's solution will be a common thought for any one who try to crack this problem , its really something strange to come up with JustDoIt's solution ..I never thought in that line ( if i would not have checked this site or solutions to this problem )."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"let node1 and node2 be the two nodes. We have as an input, pointers to node1 and node2. Lets call the pointers as node1 and node2! Assume, we are not even provided with 'root' as an input. I am assuming we have parent pointers to the node, else we cannot solve it. The catch is that both node1 and node2 are at different levels in the binary tree. We need to somehow bring it on the same level. For that lets traverse from node1 to root. Lets have a count1=depth of node1. Initially count1=0,each time u traverse upwards, do count++. You can traverse upwards bcoz of parent pointer! Do the same for node2 to root. Now we have count1 and count2. if count1==count2...they are at the same level. If count1>count2, bring \"pointer to node1\" (count1-count2) times.  Else If count1 \n   \n    \n   -  \n     Anonymous \n     on January 06, 2010 Edit | Flag  \n    \n    \n   Reply"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node findLowestCommonAncestor(Node root, int value1, int value2) \n        { \n            while (root != null) \n            { \n                int value = root.Value; \n                if (value > value1 && value > value2) \n                { \n                    root = root.Left; \n                } \n                else if (value < value1 && value < value2) \n                { \n                    root = root.Right(); \n                } \n                else \n                { \n                    return root; \n                } \n            } \n            return null; // only if empty tree \n        } \n        // Overload it to handle nodes as well \n        Node findLowestCommonAncestor(Node root, Node child1, Node child2) \n        { \n            if (root == null || child1 == null || child2 == null) \n            { \n                return null; \n            } \n            return findLowestCommonAncestor(root, child1.Value, child2.Value); \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Dunno why are ppl wasting their time giving the solution for a binary tree. Question clearly states NON BINARY TREE."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Find the position of both nodes A and B, if A < B then divide B by 2 till its value is less A, then continue the same with A and repeat it again till A = B."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The code below should work for the cases:   - A and B are in the different subtrees  - A or B is LCA  - A and B the same  - there are several nodes with a given values (A and B)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Check out this solution, and please comment if you find any bug:- http : // goo.gl / gGR2V"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Get Preorder, InOrder and PostOrder of the tree.  Then follow the steps to get the LCA of the two nodes n1 and n2.  1. S1 = {List of nodes from Preorder that fall before before n1 and n2} 2. S2 = {List of nodes from Inorder that fall are between n1 and n2} 3. S3 = {List of nodes from Postorder that fall after n1 and n2}   LCA of n1 and n2 = Intersection(S1, S2, S3)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=87897","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"47","title":"Write a function to find the longest path of a tree","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If I remember correctly, one algorithm is to find the deepest node of the tree say D1, then assuming that D1 is the root, find the deepest node again, say D2.  D1 to D2 will be the longest path.  If your tree has both child/parent pointers, this should be O(n) time algorithm, where n is the number of nodes. (assuming the tree is connected)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"cant u use depth first search (dfs)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"cant u use depth first search (dfs)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"cant u use depth first search (dfs)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can have recursive function   int length(Node *root) {   if(root == 0)      return 0;   int right= length(root->right);   int left= length(root->left);   if( left > right )       return 1+ left;   else       return 1+right;    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We can have recursive function   int length(Node *root) {   if(root == 0)      return 0;   int right= length(root->right);   int left= length(root->left);   if( left > right )       return 1+ left;   else       return 1+right;    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think longest path is same as maximum depth except for the difference that path information need to provided like {A C E H I } constitutes a longest path.  Longest Path : Set of nodes in order, which will have maximum number of nodes. Maximum depth : Numerical value which tells about the height of the tree.  Please let me know if you don't agree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think longest path is same as maximum depth except for the difference that path information need to provided like {A C E H I } constitutes a longest path.  Longest Path : Set of nodes in order, which will have maximum number of nodes. Maximum depth : Numerical value which tells about the height of the tree.  Please let me know if you don't agree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think longest path is same as maximum depth except for the difference that path information need to provided like {A C E H I } constitutes a longest path.  Longest Path : Set of nodes in order, which will have maximum number of nodes. Maximum depth : Numerical value which tells about the height of the tree.  Please let me know if you don't agree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think longest path is same as maximum depth except for the difference that path information need to provided like {A C E H I } constitutes a longest path.  Longest Path : Set of nodes in order, which will have maximum number of nodes. Maximum depth : Numerical value which tells about the height of the tree.  Please let me know if you don't agree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Try proving that they are the same and you will realize yourself."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using a queue and not using recursion will be more clear."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"tree_height(mynode *p) {    if(p==NULL)return(-1);    h1=tree_height(p->left)+1;    h2=tree_height(p->right)+1;    return(max(h1,h2)); }    TESTED and WORKING"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about using a wrapper function around the function tree_height(mynode*p) which calls it for all the nodes as root one by one. The maximum length for a tree would be the one which gives us maximum depth. Though this looks to be really inefficient if the number of nodes in the tree is large, but it is a correct solution."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Path is different than height.  Assume that the tree data structure has an additional fields (int longestChildDepth). A node's longest path = sum of (node->left's, node->right's height, 1). The maximum of the sum is the longest path."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Path is different than height.  Assume that the tree data structure has an additional fields (int longestChildDepth). A node's longest path = sum of (node->left's, node->right's height, 1). The maximum of the sum is the longest path."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Path is different than height.  A node's longest path = sum of left childs height, right childs height and 1. The maximum of this number is the longest path."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming Longest Path of the tree is the diameter of the tree, the distance from the the root to its leaf.   Start from an arbitrary node and run a Bread First Search. Note the last node visited. From this node, run a BFS again. The distance from this node  to the last node visited is the diameter of the tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question, just mentioned a tree, is it right to assume that the tree is a binary tree and not an 'n'nary tree?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question, just mentioned a tree, is it right to assume that the tree is a binary tree and not just an 'n'nary tree?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question, just mentioned a tree, is it right to assume that the tree is a binary tree and not just an n-nary tree?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The question, just mentioned a tree, is it right to assume that the tree is a binary tree and not just an n-nary tree?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"length of the longest path is called tree diameter. diameter = max of ( height_of_left_child + 2 + height_of_right_child, diameter(left_child), diameter(right_child))"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It is the same as tree diameter.The following link might be helpful  http://www.cs.duke.edu/~ola/courses/cps100spr96/tree/trees.html"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"answer = dia of tree, my code[working] in CPP is posted below.  here \"depth\" and \"dia\" are passed as reference to collect the values, they are un-initialized."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int Diameter(node *start) \n{ \n    if(start == NULL) return -1; \n    int l = 1 + Diameter(start->left); \n    int r = 1 + Diameter(start->right); \n    if(maximum < l+r+1) \n       maximum = l+r+1; \n    cout << maximum<< endl; \n    return max(l,r); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int Diameter(node *start) \n{ \n    if(start == NULL) return -1; \n    int l = 1 + Diameter(start->left); \n    int r = 1 + Diameter(start->right); \n    if(maximum < l+r+1) \n       maximum = l+r+1; \n    cout << maximum<< endl; \n    return max(l,r); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int Diameter(node *start) \n{ \n    if(start == NULL) return -1; \n    int l = 1 + Diameter(start->left); \n    int r = 1 + Diameter(start->right); \n    if(maximum < l+r+1) \n       maximum = l+r+1; \n    cout << maximum<< endl; \n    return max(l,r); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int depth(node *start) {     if(start == NULL) return 0;     if(start->left == NULL)           int l = depth(start->left);     else         int l = 1 + depth(start->left);     if (start->right == NULL)         int r = depth(start->right);     else         int r = 1 + depth(start->right);     if(diameter< l+r)        diameter = l+r;     cout << diameter<< endl;     return max(l,r); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int depth(node *start) {     if(start == NULL) return 0;     if(start->left == NULL)           int l = depth(start->left);     else         int l = 1 + depth(start->left);     if (start->right == NULL)         int r = depth(start->right);     else         int r = 1 + depth(start->right);     if(diameter< l+r)        diameter = l+r;     cout << diameter<< endl;     return max(l,r); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void findDiameter( node root,int& diameter,int& depth) {     if (root->NULL)    {       depth = 0;       diameter = 0;       return 0;    }        findDiameter( root->left,diameterleft,depthleft);    findDiameter( root->right,diameterright,depthright);    diameter = max( depthleft+depthright+2, diameterleft,diameterright);    depth = max(depthleft+1,depthright+1); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void findDiameter( node root,int& diameter,int& depth) {     if (root->NULL)    {       depth = 0;       diameter = 0;       return 0;    }        findDiameter( root->left,diameterleft,depthleft);    findDiameter( root->right,diameterright,depthright);    diameter = max( depthleft+depthright+2, diameterleft,diameterright);    depth = max(depthleft+1,depthright+1); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Too much shit, very little corn."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int Dia(struct node * tree) {    if (tree == 0)      return 0;     int lheight = height(tree->left);     int leftD = Dia(tree->left);   int rightD = Dia(tree->right);     return max(lheight + rheight + 1, max(leftD, rightD)); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This looks pretty definitive to me:   h**p://crackinterviewtoday.wordpress.com/2010/03/11/diameter-of-a-binary-tree/  I saw this link somewhere on careercup, can't find it now though. One thing the above doesn't do is, find the actual path; just the length. I suppose it would be easy to modify it though, to associate the node responsible, with each length, in a pair (or tuple, or custom struct) and return /that/ instead of just the length. I haven't actually tried it though."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"... here; question id: 1767700  (It's not /quite/ a dup because that's asking only for the diameter, not the complete path.)   However, though the overall algorithm is right, I'm dubious that it's correct in some details."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=12868663","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"38","title":"Given a binary tree, every node has a int value, return the root node of subtree with the largest sum up value. Java is more preferable. Caution: the return should be a node, not a integer!","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"//Use two reference pointers to store the maximum sum and the node that exposes the maximum sum in max and maxNode respectively \nint maxSum(struct node *root, struct node **maxNode, int *max) \n{ \nif (!root) return 0; \n// If the node is leaf node, compare its value and return the value of that node \nif(!root->left && !root->right) \n{        \n      if (node->val > max) \n              { *max = root->value; max = &root; } \n      return root->val; \n} \n// Calculate the sum of the current node \nint cmax = root->value + max(root->left, maxNode, max) + max(root->right, maxNode, max); \nif (cmax > max) \n              { *max = root->value; max = &root; } //Update the reference pointers  \nreturn cmax; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"class A { \n   static class Result { \n      int value; \n      Node node; \n   }  \n    \n   int sumOfTree(Node root, Result max) { \n      if (root == null) { \n         return 0; \n      } \n      int leftR = sumOfTree(root.left, max); \n      int rightR = sumOfTree(root.right, max); \n      int sum = leftR + rightR + root.value; \n      if (sum > max.value) { \n         max.value = sum; \n         max.node = root; \n      }  \n      return sum; \n   } \n    \n   public static void main(String[] args) { \n      Node root = ...; //create a tree \n      Result max = new Result(Integer.MIN, root); \n      new A().sumOfTree(root, max); \n      max.value; //max value \n      max.node; //max node \n   } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Do post-order traversation(left-right-parent). During traversation save the parent bode with max sum (left sum + rigth sum). Time: O(N)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Do post-order traversation(left-right-parent). During traversation save the parent node with max sum (left sum + rigth sum). Time: O(N)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"The question says to return the Node itself while most solutions are returning the sum of this Node, so I guess the question was probably edited. Here is my recursive version to returning the Node.  The recursive method does 2 things: (1) set the sum of current node and (2) return the largest-sum Node under the current node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"start summing up value from leaf to root and while summing these value keep track of node largest sum up value. and passing this value to parents node.   int  Max (node *root) {    static node tmp=NULL ;  static int check=INT_MIN    if(!root)    return 0;     if(root->left ==NULL && root->right==NULL)    return root->data;    int L=Max(root->left);   int R =Max(root->right);    if( (root->data + L +R)  >check)   {      tmp=root;   //store the node with max value;    }      return (root->data +L +R) ; }  tmp node will have largest sum up value.   //tmp node can be pass as a reference node also       }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Scala version. Returns SearchResult with tree node and sum of its direct child values. Because it is binary tree there is no need to search on the left if the right node is present."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package SubTreeLargestSumUp; \n \npublic class BTNode { \n public BTNode left; \n public BTNode right; \n public int value; \n public int sumUp; \n  \n public BTNode(BTNode l, BTNode r, int v, int s){ \n  left = l; \n  right = r; \n  value = v; \n  sumUp = s; \n } \n} \npackage SubTreeLargestSumUp; \n \npublic class BTNode { \n public BTNode left; \n public BTNode right; \n public int value; \n public int sumUp; \n  \n public BTNode(BTNode l, BTNode r, int v, int s){ \n  left = l; \n  right = r; \n  value = v; \n  sumUp = s; \n } \n} \n \npackage SubTreeLargestSumUp; \n \npublic class DFS { \n BTNode r = new BTNode(null, null, 0, Integer.MIN_VALUE); \n  \n  \n  \n    public static void main(String [] args){ \n     BTNode a = new BTNode(null, null, 4, Integer.MIN_VALUE); \n     BTNode b = new BTNode(null, null, 5, Integer.MIN_VALUE); \n     BTNode c = new BTNode(null, null, -1, Integer.MIN_VALUE); \n     BTNode d = new BTNode(null, null, 7, Integer.MIN_VALUE); \n     BTNode e = new BTNode(c, d, 3, Integer.MIN_VALUE); \n     BTNode f = new BTNode(a, b, 2, Integer.MIN_VALUE); \n     BTNode g = new BTNode(e, f, 1, Integer.MIN_VALUE); \n     DFS dfs = new DFS(); \n     dfs.sumUp(g); \n     System.out.print(dfs.DFS(g).value); \n    } \n  \n  \n public int sumUp(BTNode n){ \n     if (n.left == null && n.right == null) \n      return n.sumUp = n.value; \n     else if (n.left == null) \n      return n.sumUp = n.value + sumUp(n.right); \n     else if (n.right == null) \n      return n.sumUp = n.value + sumUp(n.left); \n     else return n.sumUp = n.value + + sumUp(n.left) + + sumUp(n.right); \n    } \n  \n public BTNode DFS(BTNode n){ \n  if (n.left != null) \n   DFS(n.left); \n  if (n.right != null) \n   DFS(n.right); \n  if (n.sumUp > r.sumUp) r = n; \n  return r; \n } \n  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package SubTreeLargestSumUp; \n \npublic class BTNode { \n public BTNode left; \n public BTNode right; \n public int value; \n public int sumUp; \n  \n public BTNode(BTNode l, BTNode r, int v, int s){ \n  left = l; \n  right = r; \n  value = v; \n  sumUp = s; \n } \n} \npackage SubTreeLargestSumUp; \n \npublic class BTNode { \n public BTNode left; \n public BTNode right; \n public int value; \n public int sumUp; \n  \n public BTNode(BTNode l, BTNode r, int v, int s){ \n  left = l; \n  right = r; \n  value = v; \n  sumUp = s; \n } \n} \n \npackage SubTreeLargestSumUp; \n \npublic class DFS { \n BTNode r = new BTNode(null, null, 0, Integer.MIN_VALUE); \n  \n  \n  \n    public static void main(String [] args){ \n     BTNode a = new BTNode(null, null, 4, Integer.MIN_VALUE); \n     BTNode b = new BTNode(null, null, 5, Integer.MIN_VALUE); \n     BTNode c = new BTNode(null, null, -1, Integer.MIN_VALUE); \n     BTNode d = new BTNode(null, null, 7, Integer.MIN_VALUE); \n     BTNode e = new BTNode(c, d, 3, Integer.MIN_VALUE); \n     BTNode f = new BTNode(a, b, 2, Integer.MIN_VALUE); \n     BTNode g = new BTNode(e, f, 1, Integer.MIN_VALUE); \n     DFS dfs = new DFS(); \n     dfs.sumUp(g); \n     System.out.print(dfs.DFS(g).value); \n    } \n  \n  \n public int sumUp(BTNode n){ \n     if (n.left == null && n.right == null) \n      return n.sumUp = n.value; \n     else if (n.left == null) \n      return n.sumUp = n.value + sumUp(n.right); \n     else if (n.right == null) \n      return n.sumUp = n.value + sumUp(n.left); \n     else return n.sumUp = n.value + + sumUp(n.left) + + sumUp(n.right); \n    } \n  \n public BTNode DFS(BTNode n){ \n  if (n.left != null) \n   DFS(n.left); \n  if (n.right != null) \n   DFS(n.right); \n  if (n.sumUp > r.sumUp) r = n; \n  return r; \n } \n  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int largestvaluesum(struct node *root,struct node **maxvaluenode) \n{int maxsum; \nif(root==NULL) \nreturn 0; \nint lsum=largestvaluesum(root->left,maxvaluenode); \nint rsum=largestvaluesum(root->right,maxvaluenode); \nif(maxsum<=max(lsum,rsum)+root->data) \n{maxsum=max(lsum,rsum)+root->data; \n*maxvaluenode=root; \n} \nreturn maxsum; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This changes the data in a node to the recursive sum of its children's data."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int subTreeWithMaxSum(node *root) \n{ \n if(!root) \n  return 0; \n if(!root->left && !root->right) \n  return root->data; \n int lSum = subTreeWithMaxSum(root->left); \n int rSum = subTreeWithMaxSum(root->right); \n return max(root->data, max(root->data+lSum+rSum, max(root->data+lSum, root->data+rSum))); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Please have a look"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. breadth first traversal the tree, push nodes into a stack. 2. while stack is not NULL, pop the top element in the stack, and add it's value with values of its child nodes. update the max value as well as the result node.  Am I right?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static TreeNode FindMaxSubtree(TreeNode node,Hashtable sum) \n { \n  if(node == null) \n   return null; \n   \n  TreeNode leftMaxNode = FindMaxSubtree(node.LeftChild, sum); \n  TreeNode rightMaxNode = FindMaxSubtree(node.RightChild, sum); \n   \n  int nodeSum = node.Data + (node.LeftChild == null? 0 : sum.get(node.LeftChild))  \n       + (node.RightChild == null? 0 : sum.get(node.RightChild)) ;   \n  sum.put(node, nodeSum); \n   \n  TreeNode maxNode = node; \n  int max = nodeSum; \n   \n  if(leftMaxNode != null && sum.get(leftMaxNode) > max) \n  { \n   maxNode = leftMaxNode; \n   max = sum.get(leftMaxNode); \n  } \n   \n  if(rightMaxNode != null && sum.get(rightMaxNode) > max) \n  { \n   maxNode = rightMaxNode; \n   max = sum.get(rightMaxNode); \n  }   \n   \n  return maxNode; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct node * func(struct node *ptr) {  if(ptr==NULL)  return NULL;  else  {   struct node *le,*re;   le=(struct node *)func(ptr->left);   re=(struct node *)func(ptr->right);   if(le!=NULL&&re!=NULL)    ptr->info=le->info+re->info+ptr->info;    else if(re==NULL&??==NULL)      ptr->info=ptr->info;      else if(le==NULL)       ptr->info=re->info+ptr->info;       else if(re==NULL)        ptr->info=le->info+ptr->info;         return ptr;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// Store temp maxSumNode and initialize it to root // Also maintain an extra field sum in every Node apart from value and next  public Node largestSumNode( Node root ){   sumOfNode(maxSumNode = root);   return maxSumNode;  }     private int sumOfNode( Node node ){   if( node != null ){    node.sum = node.value + sumOfNode(node.left) + sumOfNode(node.right);    if( node.sum >= maxSumNode.sum )     maxSumNode = node;    return node.sum;   }   return 0;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct maxSumAndNode{ int maxSum ; struct node *maxNode ; };    struct maxSumAndNode rootNodeWithLargestSumUpValue(struct node *node, int maximum, struct node *ret) {     int tempSum ;     struct maxSumAndNode st1,st2;   if(node == NULL){     struct maxSumAndNode result;     result.maxSum = maximum ;     result.maxNode = ret;  return  result; }  else { if((tempSum = printSum(node) )> maximum) {     maximum = tempSum ;    st1 = rootNodeWithLargestSumUpValue(node->left , maximum, node);    st2 = rootNodeWithLargestSumUpValue(node->right ,  maximum , node);    if(st1.maxSum > st2.maxSum)    {        return st1;    }    else    {        return st2;    }  } else {     maximum = maximum ;    st1= rootNodeWithLargestSumUpValue(node->left , maximum, ret);     st2 = rootNodeWithLargestSumUpValue(node->right ,  maximum , ret);     if(st1.maxSum > st2.maxSum)    {        return st1;    }    else    {        return st2;    } }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct maxSumAndNode{ int maxSum ; struct node *maxNode ; };    struct maxSumAndNode rootNodeWithLargestSumUpValue(struct node *node, int maximum, struct node *ret) {     int tempSum ;     struct maxSumAndNode st1,st2;   if(node == NULL){     struct maxSumAndNode result;     result.maxSum = maximum ;     result.maxNode = ret;  return  result; }  else { if((tempSum = printSum(node) )> maximum) {     maximum = tempSum ;    st1 = rootNodeWithLargestSumUpValue(node->left , maximum, node);    st2 = rootNodeWithLargestSumUpValue(node->right ,  maximum , node);    if(st1.maxSum > st2.maxSum)    {        return st1;    }    else    {        return st2;    }  } else {     maximum = maximum ;    st1= rootNodeWithLargestSumUpValue(node->left , maximum, ret);     st2 = rootNodeWithLargestSumUpValue(node->right ,  maximum , ret);     if(st1.maxSum > st2.maxSum)    {        return st1;    }    else    {        return st2;    } }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can we return node without modifying the node values of without using a separate sum function.. this code is returning correct node but am modifying every node's value with its sum-up value.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"TREE isMax(TREE root) \n{ \n if(root==NULL)return 0; \n static int maxsum = 0;  \n static TREE newroot = NULL; \n int ls = sum(root->left); \n int rs = sum(root->right); \n if(ls + rs + root->info > maxsum) \n { \n  maxsum = ls + rs + root->info; \n  newroot = root; \n  cout<<\"\\n New max sum = \"<info; \n } \n  \nisMax(root->left); \nisMax(root->right); \n \nreturn newroot; \n} \nint sum(TREE root) \n{ \n if(root==NULL) \n return 0; \n else \n return (sum(root->left) + root->info + sum(root->right)); \n \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=254667","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"41","title":"Given a variation of a binary tree(not BST) in which each node has a parent, left and right pointer. The nodes do not have any key elements or any other data to identify itself. The root is the node that has a null parent pointer. You are given the pointers to two random nodes in the tree which may or may not be at the same level. Find the first common ancestor to the two random nodes given in the tree.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Let h1, h2 be the levels of the two nodes n1, n2 respectively in the tree(find the level by following the parent pointer) if (h1 > h2) then follow the parent pointer of node n1 move up (h1 - h2) nodes. else follow the parent pointer of n2 and move up (h2 - h1) nodes. Now compare both the nodes n1 and n2 and follow the parent pointers until the common ancestor is found."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This is exactly similar problem to \"Find the point of intersection of two linked lists\". Here the linked lists have the two nodes as heads and the next pointers are the parent pointers all the way to the root.   1. find length of path from node 1 to root via parent ptrs. 2. find length of path from node 2 to root via parent ptrs. 3. In the bigger path traverse difference (mod(len1 - len2)) number of nodes. 4. Traverse one node at a time in both lists till you get common point."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I was asked this same Q..I gave the hash table answer.. then he asked to to optimize it.. he expected  Find out the height of the two nodes in the binary tree. It would take O(n) time. Then, then make one of the pointers to come to the same level as that of the other in the tree. From this point onwards, start traversing the ancestor chain for both the subtrees simultaneously, comparing the parent pointer at each step. The moment the parent pointers come out to be the same, return that parent pointer as the LCA. There are a few edge cases that I am not elaborating here (root being the LCA, straight chain etc), but those can be handled easily.  Analysis: Constant extra space. O(n) worst case runtime."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"- Traverse to root and store path. O(log n) - Find first common point in path (which is the LCA). Can do it in O(n) using hash table."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Keep the pointer at one of the child's node.  Call it current pointer 2) While current-> data lies between child1->data and child2->data, current = current->parent 3) The moment condition #2 fails, you have stepped out of LCA (i.e you moved to LCA's parent). Keep another pointer to remember previous move and return that."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can always ask for to confirm. They mean BST when they say *tree*. LCA is specific to the BST."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"BTNode* FindingCommonAncestor::findCommonAncestor(BTNode* root, BTNode* a, BTNode* b) { \n    queue *q1 = new queue; \n    queue *q2 = new queue; \n \n    isDescendent(root, a, q1); \n    isDescendent(root, b, q2); \n \n    int sizeA = q1->size(); \n    int sizeB = q2->size(); \n \n    hash_set set; \n    for ( int i = 0; i < sizeA; i++ ) { \n        set.insert((BTNode*) q1->front()); \n        q1->pop(); \n    } \n     \n    for  ( int i = 0; i < sizeB; i++ ) { \n        BTNode* node = q2->front(); \n        if ( set.count(node) ) { \n            delete q1; \n            delete q2; \n            return node; \n        } \n        q2->pop(); \n    } \n \n    delete q1; \n    delete q2; \n    return NULL; \n} \n \nbool FindingCommonAncestor::isDescendent(BTNode* root, BTNode* node, queue *q) { \n if ( root == node ) { \n  q->push(node); \n  return true; \n } else if ( root->left && isDescendent(root->left, node, q) ) { \n        q->push(root); \n        return true; \n    } else if ( root->right && isDescendent(root->right, node, q) ) { \n        q->push(root); \n        return true; \n    } \n \n    return false; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You cant traverse tree. only children are pointing to their parents. There is no pointer from parent to child"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Yeo1 ..Can you please explain your logic?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"He is basically adding all the parent nodes of, say, first node to a hash table. Next he searches the hash table for parent nodes of the second node. The first match is the common ancestor. I am wondering if there is a more efficient solution. This solution has complexity of O(lg(n))."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"http://www.careercup.com/question?id=254667&form=comments"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First we need to have a list of leaf nodes in a queue. Extract node from queue and we move up to its parent and at each stage we compare the parent element with two given node values.If both are greater and if the node is not already visited then we move up to the parent and we mark the parent node as visited. If the parent node value is in between the two given node values then we found our ancestor.If the node is already visited or we reached the root node or both the node values are lesser than the current node when traversing from child to parent then we start the same traversal from the next leaf node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"from the two given node, traverse up to the root, when doing so:  1. reverse the child-parent pointer alone the path 2. record the depth of each node 3. then it problem becomes same as the other problem from amazon"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this problem is variant of \"linked list converge point problem\".  the two child nodes are head of the linked list and root is tail. we have to find out the 1st node at which they converge.  So, use the standard method, find length and ..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I don't think Thiyanesh solution will work......especially when both are at same level.....Just assume when one is at level n on left side of root and other is on level n on right side.............  I think good way to solve it is to traverse one side and put all the pointer in link list in order that we got it and then traverse another list and start comparing it and stop when you found a match. Maximum is that we have to (2logn) moves if lowest common ancestor is a root itself........  Since we have not given the keys also, so I don't think we can do it less than logn......Also, in any case worst case can be less than logn............"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think good way to solve it is to traverse one side till root from one node and put all the pointer in link list in order that we got it and then traverse another list and start comparing it and stop when you found a match. Maximum is that we have to (2logn) moves if lowest common ancestor is a root itself........  If we are not given the keys or tree is not BST, then I don't think we can do it less than logn......Also, in any case worst case it cannot be less than logn............  If we know the key then we can traverse the elements going towards the parents.   Suppose that n1 and n2 are two nodes and key1 and key2 are values at these nodes respectively. Step1: Get the largest of two. Now largest value be on right side of common ancestor and smaller value be on left side of common ancestor and both will be on either right side or left side of parent of common ancestor. So, we can use this property to find the common ancestor.  Step2: Start from smaller key and start moving towards root. If value at parent is less than value at current node then it cannot be common ancestor as smaller value lies on left side of common ancestor. So check next node. And if it is greater than node1, then node1 lies on left side of this ancestor of node1 so this ancestor can be a lowest common ancestor. Go to step 3 to check condition on parent of common ancestor.  Step3: For parent of common ancestor, Check that now both node1 and node2 either should lie on left side or on right side. If even one condition is true then you hit the parent node in step2, otherwise go up one step and repeat from step2. Code for it is as follows:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@Kunal If one of the node is on the left side of the root and other is on the right side of the root, then root will be the LCA as per my above post.  But if the question really meant, \"we can't compare two nodes(address)\", then i don't have an answer now.(\"The nodes do not have any key elements or any other data to identify itself.\" as per the question)  Please do correct if i am missing something."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I would prefer to traverse one path fully till root, everytime putting the value in a hash table. now,start traversing for 2nd node and stop as soon as you get the node's value in the hash table."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"2 ways: 1) Traverse to the root, following the parent chain of one node, and preserving each ancestor in a hashtable. In the second pass, traverse up the ancestor chain of the second node, looking for each ancestor of it in the ancestor map of the first node. The first ancestor in the ancestor chain of the second node that appears in the ancestor map of the first node, is the LCA. (same solution as given in the last post)  Not a very efficient process given the need for extra space to store the ancestor chain.   Analysis: O(n) worst case space and time complexity.  2) Find out the height of the two nodes in the binary tree. It would take O(n) time. Then, then make one of the pointers to come to the same level as that of the other in the tree. From this point onwards, start traversing the ancestor chain for both the subtrees simultaneously, comparing the parent pointer at each step. The moment the parent pointers come out to be the same, return that parent pointer as the LCA. There are a few edge cases that I am not elaborating here (root being the LCA, straight chain etc), but those can be handled easily.   Analysis: Constant extra space. O(n) worst case runtime."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int getLevel(node *ptr) \n{ \n int level = 0; \n while (ptr) \n { \n  level++; \n  ptr = ptr->parent; \n } \n return level; \n} \n \nnode *getCommonAncestor(node *ptr1, node *ptr2) \n{ \n int h1, h2, diff; \n h1 = getLevel(ptr1); \n h2 = getLevel(ptr2); \n if (h1>h2) \n { \n  diff = h1-h2; \n  while (diff-- && ptr1) \n   ptr1 = ptr1->parent; \n } \n else if (h2>h1) \n { \n  diff = h2-h1; \n  while (diff-- && ptr2) \n   ptr2 = ptr2->parent; \n } \n while (ptr1 && ptr2) \n { \n  if (ptr1->parent == ptr2->parent) \n   return ptr1->parent; \n  ptr1 = ptr1->parent; \n  ptr2 = ptr2->parent; \n } \n return NULL; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"find solution in my name"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can be slightly modified the node of tree if yes then i will add a flag to each node from first pointer move towards it's parent till root  while moving   set the flag value now start moving from second pointer to it's parent while moving chek the flag value if it's already set then return that value otherwise keep on moving towards root until u get a node with flag value has been set."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"typedef struct node_t \n{ \n node_t* parent; \n node_t* left; \n node_t* right; \n} NODE, *PNODE; \n \n \nPNODE FirstCommonAncestor(PNODE n1, PNODE n2) \n{ \n int n1Level = GetLevel(n1); \n int n2Level = GetLevel(n2); \n  \n while(n1Level < n2Level) \n { \n  n1 = n1->parent; \n  --n1Level; \n } \n  \n while(n2Level < n1Level) \n { \n  n2 = n2->parent; \n  --n2Level; \n } \n  \n while(n1 != n2) \n { \n  n1 = n1->parent; \n  n2 = n2->parent; \n } \n  \n return n1; \n} \n \nint GetLevel(PNODE n) \n{ \n int level = 0; \n while(n->parent) \n { \n  n = n->parent; \n  ++level; \n } \n return level; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"i THInk  it easy  because u have given the parent pointer to each node wo we can traverse up by chking pointer node  so if at ny time we got same parent it is the answer  CODE:   node*  sol(node*ch1,node*ch2) {     node*k1=ch1;     vectorv1;   while(k1!=NULL)   {     v1.push_back(k1);     k1=k1->parent;    }  vectorv2;   while(k2!=NULL)   {     v2.push_back(k2);     k2=k2->parent;    }  // now traverse form last  in both veotrs  the last node which is eqal is both is the answer reverse(v1.begin(),v1.end()); reverse(v2.begin(),v2.end()); for(int i=-1;i{   if(v1[i+1] !=v2[i+1] )return v1[i]; } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"No specification about extra space so I propose using a stack."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"famous LCA problem,   with O(NlogN) preprocessing, you can do O(log h) for each LCA query, where h is the max level of tree.  well, but I'm sure the interview is expecting something easier~"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"current=root. \nwhile(current!=NULL){ \nDo a BFS (or any tree traversal) on left node.(current->left)  \n  - if both children are in left node, then now current=root->left.  \n  - if left node has only one child, return root as ansector \n  - else, current=root->right \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14927926","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"41","title":"Give a BST and a number. we need to find next bigger number in BST.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"23","title":"this code will work for both case if n is present in BST and if n is not a part of BST int nextBigNum( struct node * root, int n) {     int nextBig =INT_MIN;          struct node * temp =root;            while(root!=NULL)      {         if(root->data > n)         {           nextBig=root->data;           root=root->left;         }         else         {             root=root->right;         }      }            return nextBig; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"1. Search for the number ( TC: O(h) ) 2. Find its in order successor ( TC: O(h) ) Total TC: O(h) but in two passes"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"int nextInBST(int num, Node root) \n{ \n    if(root == NULL) \n      return -999; \n    int n;   \n    n = nextIntBST(int num, Node root->left); \n     if(n != -999) \n      return n; \n      \n     if(root->info > num) \n       return root->info; \n    n = nextIntBST(int num, Node root->right);     \n    return n; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"We can do it in O(h) complexity by using the following method: 1. Search for the element 'n' in the BST, as you search add the elements in the path to a stack 2. If element is found and the element has a right subtree, the leftmost element in the right subtree will be the next biggest element. 3. If element is not found or the element is found but does not have right subtree, then pop elements from the stack until you find an element that is greater than 'n'. This will be the next biggest element.  Funda : by maintaining a stack we can traverse back and easily find the inorder successor with in O(h) time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Great book: Elements-Programming-Interviews by Adnan-Aziz"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do an inorder traversal of the BST. In place of print test whether node->data-number is negative. If yes print that number.Complexity O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int search_num( node *root, int num) \n{ \n    if(NULL == root) \n       return 0; \n    if(num == root->data) \n       return 1; \n    if(num > root->data && root->right) \n    { \n         // recursive call with right node \n         return(search_num(root->right, num)) \n    } \n    else if(num < root->data && root->left) \n    { \n         // recursive call with left node \n         return(search_num(root->left, num)) \n     } \n       \n     return 0 \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"search number recursively,  when found          check if it has right child .                if yes , this is the number         if no right child                 return         now the calls will start unwinding check number with data of root         if big this is the number."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"def inOrderSuccessorMain(root, node): \n    if root == None or node==None or (root.left==None and root.right): \n        return False \n    return inOrderSuccessorHelper(root, node) \n     \n \ndef inOrderSuccessorHelper(root, node): \n    found = False \n \n    if root == None:#node not found then return False \n        return found \n \n    elif node.data < root.data:#node less than root then search left subtree \n        found = inOrderSuccessor(root.left, node). \n        if found == None:#if found=None then root is the successor \n            return root \n             \n    elif node.data > root.data:#node less than root then search right subtree \n        found = inOrderSuccessor(root.right, node)#found can be False, None, or some node \n         \n    else: \n        if root.right != None:# Find left most node of right subtree \n            found = rightSubTree(root.right) \n        else \n            return None # return None if no right node exists \n \n    return found \n \ndef rightSubTree(root): \n    if root.left == None: \n        return root \n    else: \n        return rightSubTree(root.left)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Traverse the BST in order and keep track of the previous value. Since BST inorder traversal results in ascending order, if the previous node visited is the required number, then the current node is the next big number. Below is the pseudo code.   Node* prevNode; Search(Node* node,int n) {  if(node== NULL)   return;  Search(node->left,n);  if(prevNode->data == n)   Print(node->data);  prevNode= node;  Search(node->right,n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"findNextBiggernumber(tree *root,int num,int &next) {   if(!root)   return  -9999 ;    if(root->data>n&&root->data    {      next=root->data ;      findnextbiggernumber(root->left,num,next) ;     }    else     findnextbiggernumber(root->right,num,next) ;    return next ; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Traverse the tree inOrder, & set prev (when node with data 'num' found). If prev is already found, then return curr (i.e.- root) in recursion.  Handles all cases. Returns NULL if succ/num node doesn't exist"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int greater(Bt t, int n) { \n  int big = t.value; \n \n  while (t.value != n) { \n   if (n < t.value) { \n    big = t.value; \n    t = t.left; \n   } else { \n    t = t.right; \n   } \n  } \n \n  if (t.right == null) { \n   if (t.value > big) \n    return -1; \n   else \n    return big; \n  } else \n   return t.right.value; \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Break the problem into two steps: a) find its number b) find its successor.  To find a number in a BST, you look at the root value.  If you have match, you're done.  If your desired value is less than root, search the left subtree; otherwise, search the right subtree.  To find the successor of a BST's root note, find the minimum value of the right subtree.  To find the minimum value of a tree, determine if the root node has a left subtree.  If it does, recursively return the minimum value of the left subtree.  Otherwise, return the root's value."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14553750","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"42","title":"Given two trees, how do you find one of the tree is a subtree of other?","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Travel through tree A, and search for node B  if not found,  travel through Tree B and search for node A.   If you found in either case, compare the elements."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Check if inorder as well as preorder of A is contained in inorder or preorder of B."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public static boolean doesContainsSubTree(Node a, Node b)  {   if(a==null && b== null)    return true;   else if((a!= null && b==null)|| (a==null && b!= null))    return false;   else   {    if(a.data == b.data)     return isSameTree(a.left, b.left) && isSameTree(a.right, b.right);    else     return doesContainsSubTree(a.left, b) || doesContainsSubTree(a.right, b);   }  }  public static boolean isSameTree(Node rootA, Node rootB) {   if(rootA == null && rootB == null)    return true;   else if(rootA != null && rootB != null)     return rootA.data == rootB.data && isSameTree(rootA.left, rootB.left) && isSameTree(rootA.right, rootB.right);   else    return false;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"My Idea is get the length of both the trees and whoever is larger could surely be the Super tree and another will be subtree if they one of them is part of the other and to find whether the smaller tree is part of larger tree we will recursively check if the left and right subtrees are exactly same if the respective is not null in the smaller tree"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Are they labelled?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"check for a tree by traversing it, whether at some point it is equal to the root of other tree. if it is, it is the subtree else not."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"calling same function two times gives the desired result by interchanging the trees."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is binary tree a binary search tee?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is this a binary tree?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* A binary tree node has data, left child and right child */ \nstruct node \n{ \n    int data; \n    struct node* left; \n    struct node* right; \n}; \n  \n/* A utility function to check whether trees with roots as root1 and  root2 are identical or not */ \nbool areIdentical(struct node * root1, struct node *root2) \n{ \n \n    if(root1 == NULL && root2 == NULL) \n        return true; \n  \n    if(root1 == NULL || root2 == NULL) \n        return false; \n  \n    /* Check if the data of both roots is same and data of left and right \n       subtrees are also same */ \n    return (root1->data == root2->data   && \n            areIdentical(root1->left, root2->left) && \n            areIdentical(root1->right, root2->right) ); \n} \n  \n/* This function returns true if S is a subtree of T, otherwise false */ \nbool isSubtree(struct node *T, struct node *S) \n{    \n    if (S == NULL) \n        return true; \n  \n    if (T == NULL) \n        return false; \n  \n    /* Check the tree with root as current node */ \n    if (areIdentical(T, S)) \n        return true; \n  \n    /* If the tree with root as current node doesn't match then \n       try left and right subtrees one by one */ \n    return isSubtree(T->left, S) || \n           isSubtree(T->right, S); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If you're provided the root  R of the subtree, then R should have a parent reference to the supertree. If you can find this parent reference, then you're done."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this should work.  Suppose we need to find whether B is subtree of A or not. Then find whether root of B is in A. If no then its not a subtree. if you find it, then do an inorder traversal of the subtree and compare that with the inorder of B. if both are equal then B is subtree of A."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If both the trees have same Lowest Common Ancestor which is root of one of 'em itself."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about checking if value of root of Tree A is in Tree B and then checking their addresses? and vice-versa?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Baby approach :P ......... count the number of nodes in both trees say A and B ....the tree with greater number of nodes will by default ...by theory will be the parent tree and the other with less nodes will be sub tree(probably) . Now to check weather the sub tree really belongs to the parent tree search for root node of sub tree in parent tree and when found start traversing both the trees simultaneously and if the traversing ends up with sub tree it means you just traverse the sub tree in the parent tree.. BINGO!!! :)....please correct me if I m wrong!!!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public boolean hasSubTree(BTNode T1, BTNode T2){ \n  return isSubTree(T1,T2) || isSubTree(T2,T1); \n } \n \npublic boolean isSubTree(BTNode superTree, BTNode subTree){ \n  if(superTree == subTree) return true; \n  else if(superTree.left != null || superTree.right !=null) return (isSubTree(superTree.left,subTree) || isSubTree(superTree.right,subTree)); \n  else return false; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"DFS would find whether a tree is subtree or not.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"step 1: calculate the depth of both trees , d1 (depth of first tree)& d2(depth of second tree) step 2: if d1 > d2, then second tree could be subtree of first tree            if d2 > d1, then first tree could be subtree of second tree step 3: Do BFS traversal and search for subtree root node step 4: if root node of subtree is found on BFS traversal of main tree then its fine"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I've tried to decompose all the conditions in three separate functions because not all the conditions are applicable to all the nodes. This fact becomes more significant when # of nodes in given trees is in terms of thousands."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// Java solution to this problem. Assumes the tree is not necessarily a binary tree. It can  \n// have any number of children at any level. Also assume that the tree may or may not  \n// have duplicates. Final assumption is that a leaf node initializes it's children list as an array of length 0. \n \nclass Node { \n  public Node [] children; \n  public Object value; \n} \n \npublic static boolean isTreeEqual(Node treeA, Node treeB) \n{ \n  if( treeA.value.equals(treeB.value) && treeA.children.length == treeB.children.length ) { \n    if( treeA.children.length == 0 ) { \n      return true; \n    } \n    for( int i = 0; i < treeA.children.length ; i++ ) { \n      return isTreeEqual( treeA.children[i], treeB.children[i] ); \n    } \n  } \n  return false; \n} \n \n// Checks if \"subTree\" is a sub-tree of \"tree\" \npublic static boolean isSubTree (Node tree, Node subTree) \n{ \n  if( tree.value.equals(subTree.value)) { \n    if( isTreeEqual(tree, subTree) ) { \n      return true; \n    } \n  } else { \n    for( int i = 0; i < tree.children.length; i++ ) { \n      Node newTree = tree.children[i]; \n      if( isSubTree(newTree, subTree) ) { \n        return true; \n      } \n    } \n  } \n  return false; \n} \n \npublic static boolean isSubTreeEitherWay( Node treeA, Node treeB ) \n{ \n  if( isSubTree( treeA, treeB) ) \n    return true; \n  return isSubTree(treeB, treeA); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Do inorder traversal of the trees, if the inorder notation of one tree is contained in another 's inorder notation then it is a subtree else not"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=13730794","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"44","title":"Find the(two) nodes which are at maximum distance in a binary tree? This is not finding the distance but the nodes which are farthest.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"11","title":"\"http://www.cs.duke.edu/courses/spring00/cps100/assign/trees/diameter.html\""},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"for each node in a tree,{ store (height of left sub tree+height of right sub tree) and two childs which are the reason for these height (note: if one of the child is null then store node itself instead null) }  for the node which has highest sum, retrive its two childs stored in above procedures. those two nodes(childs) are situated at maximum distance."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"I think that the solution would be: 1) Find the next leaf node of the tree. Build the path(string) to the leaf node by adding \"0\" if move to the left node and adding \"1\" if move to the right node. I.e. in the sample of the tree in the comment above the path to N9 node is \"100\" 2) Check the leaf nodes buffer. If there are no items there, add the current leaf node. 3) If there are the nodes in the leaf buffer, for each of them: i=0 while(current leaf node path[i] == next buffer item[i])   i++ distance = current leaf node path.length - i + next buffer item.length - i; if(distance > max) max = distance. Example: In the comment above the path to N9 node is \"100\", the path to N6 node is 11; increase i until the characters at i position are the same. i is 1 after this operation; so the distance between these node is 3-1 + 2-1 = 3;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Don't know the exact solution but it should be something like that :- 1. The two nodes, which are farthest, must be a leaf. 2. Amongst the two leaves, one should be from from the left subtree of root and the other from the right subtree.  I would like to proceed this way - find the deepest leaf of left sub tree of root.  Do the same for right sub tree of root - i.e. deepest leaf The two nodes are our answer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Take a look at the second comment. The link to cs.duke.edu. Understand that code and thats all you need."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This is similar to finding the diameter of a tree: diameter = MAX(LDIAMETER , RDIAMETER , RHEIGHT+LHEIGHT+1);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"This is a variation of finding the diameter. Here is the code for the same."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Farthest is not very clear.       In below tree if we compare N7-N9 vs N7-N6 which pair is farthest?    \n                     N1 \n                    /   \\ \n                 N2    N3 \n                /       /\\ \n            N4          N5 N6 \n          /\\           /\\ \n       N7 N8         N9 N10"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Same as finding the diameter of a binary tree but in this case we have to return the nodes as well."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think there should be some restrictions in this problem where the distance between two nodes is no repeat node.so my solution is :  0 : there is only one path between two nodes in a tree.  1: travel the tree and transform the tree to the mapping mtrix .    2: use floyed algorithm to compute the distance between any two nodes.  3: record the farthest distance."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Find Deepest leaf in the left subtree of root and the deepest leaf of the right subtree and add their distances from the root.  This can be done in linear time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"guess this would work though i dint check completely"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"O(nlogn)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sample Tree:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"we can start from a leaf node and do a DFS so that we can get the distance of each node from the leaf node find the maximum of those."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Brief approach to the solution is, here any way its clear that farthest nodes will be the leaf nodes. so first traverse the tree using any of the tree traversal and keep the leaf nodes in list. Next step is for each leaf node, find the distance between other nodes in the leaf list and keep track of the max length. To find the length between two nodes, use the approach of finding the lowest common anscetor(LCA)  between these node and sum up the length to each node from the LCA."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Brief approach to the solution is, here any way its clear that farthest nodes will be the leaf nodes. so first traverse the tree using any of the tree traversal and keep the leaf nodes in list. Next step is for each leaf node, find the distance between other nodes in the leaf list and keep track of the max length. To find the length between two nodes, use the approach of finding the lowest common anscetor(LCA) between these node and sum up the length to each node from the LCA."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1.If root contains left and right child,diameter will be the max distance. 2.If root is having only one child,    a.get the max height from root    b.go to node which has left right child and get the diameter for this node.    max of a or b will be answer."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Its very simple, count the number of leaf nodes, say it n. Make a table n * n.  For each pair of node find the Lowest Common Ancestor and store it into the table. You just need to populate half the table ( either upper triangular matrix or lower). For e.g a cell in the table will contain the following string (LCA, depth of 1st leaf node from LCA, depth of second leaf node from LCA).  Once this table is populated you can just initialize max to 0. Iterate over the table and check the sum of depth1 and depth2 for each cell and appropriately modify the max variable if you find the sum > max. the answer is the in the cell from where the final value of the max comes from."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Firstly, we try to find the max distance by doing traversal. For each node Ni, max distance is max(1+heightOf(left(Ni))+heightOf(right(Ni))),  and the exact Ni node (say M) with left sub-tree height value and right sub-tree height which gets max distance can be recorded. Then we do traversal again starting from M and find the two leaf nodes."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Would these nodes be first and last in in-order traversal of the tree?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"two ends of inorder traversal of tree"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void findHeight(sTree * root, int* height,int max,sTree** node) {  if(root == NULL)   return;  max++;  //*height = max > *height?max:*height;  if(max > *height)  {   *height = max;   *node = root;  }  findHeight(root->lChild,height,max,node);  findHeight(root->rChild,height,max,node);   } void findDia(sTree *root,sTree ** end,sTree** toend) {  int Lheight = 0;  int Rheight = 0;  findHeight(root->lChild,&Lheight,0,end); // find height of left node  findHeight(root->rChild,&Rheight,0,toend);//height of right node  printf(\"dia = %d\",Lheight+Rheight);  }  int main() { // asumtion a tree is already present On complexcity  sTree *end,*toend;  findDia(root,&end,&toend); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"do a prefix take last element, a postfix and the first element of this is what you need,,"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can reuse the diameter method, but instead of returning int, you could return a custom class, say,"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"Do the level order traversal. Return 2 leaf nodes which are at min level & max level"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14241695","download_status":"DOWNLOAD_DONE","votes":"1","answersCount":"36","title":"Given an array which contains the parent  of the ith element in the n-ary tree.Parent[i] = -1 for root. Find the height of the tree. Gave O(n2) ,space O(1). Expected Complexity- Linear You can use extra space if you want. Example- {-1 0 1 6 6 0 0 2 7}   0  1 2 3 4 5 6 7 8 0 is the root here. 0 is the parent of 1 5 6  1 is parnt of 2 6 is parent of 3 4  2 is of 7 which is parent of 8.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"12","title":"#include \n#define max(a,b) (a>b?a:b) \n#define size 9 \nint a[size],b[size]; \nvoid level(int); \nint main() \n{    \n    int i,j=-1; \n    printf(\"Enter the elements(size = 9) :\\n\"); \n    for(i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"here is O(n) solution 1.for each entry in the array,     -> look up in hashmap for the value(parent)            if there is an entry add the child(index) to it and add child to hashmap           else                create one entry for the value(parent) and add child(index) to it and add both to                 hashmap  At the end you end up with n-ary tree. Now calculate depth of it O(n)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"PA (ParentArray) be the given Array.  TempArray = new int[PA.length];  Initialize TempArray elements to -1;   for( int i=0; i   populateTempArray(PA,i); }    function populateTempArray(PA,i){ if(PA[i] == -1){    tempArray[i] =0; } if(TempArray[i]!=-1){       return; } if(TempArray[PA[i]]==-1){  populateTempArray(PA,PA[i]); } TempArray[i] = TempArray[PA[i]]+1; }   Now loop Throgh TempArray to find the Max no, which corresponds to height."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Use DP. Say we want to calculate the height of a node p. So, its height is equal to the height of its parent plus 1. So, while calculating the height of a node, store it somewhere so that we do not need to calculate the height again once we fall in the same path.  Lets take an example of a BST: 1,2,3,4; For calculating the height of 3, we need height of 2. However its already stored[using DP] Hope its clear."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public int findDepth(int[] input) { \n  List[] children = new ArrayList[input.length]; \n \n  for (int i = 0; i < input.length; i++) { \n   int parent = input[i]; \n   if (parent == -1) \n    continue; \n   if (children[parent] == null) { \n    children[parent] = new ArrayList<>(); \n   } \n   children[parent].add(i); \n  } \n  return findDepth(0, children); \n } \n \n private int findDepth(int root, List[] children) { \n  List list = children[root]; \n  if (list == null) \n   return 0; \n  int depth = 0; \n  for (Integer child : list) { \n   depth = max(depth, findDepth(child, children)); \n  } \n  return depth + 1; \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Yoda coding not good. Yoda do pseudo code write."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package puzzles.twostacks;  public class TreeArrayHeight {   int getAndSetHeight(int[] array, int index) {    if (array[index] == -1) {    return 1;   }   if (array[index] >= 0) {    array[index] = -(getAndSetHeight(array, array[index]) + 1);   }   return -array[index];  }   public void getMaxHeight(int[] array) {   for (int i = 0; i < array.length; i++) {    getAndSetHeight(array, i);   }   int min = Integer.MAX_VALUE;   for (int i = 0; i < array.length; i++) {    min = Math.min(min, array[i]);   }   System.out.println(-min-1);  }    public static void main(String[] args) {   new TreeArrayHeight().getMaxHeight(new int[]{-1,0,1,2,3,4});  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Access to parent node is given i.e. parent(x) = array[x]. Sub-problem: Given any node and only parent pointer/references, find out its height from root. Cache the stuff to avoid re-calculation at each stage."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. O(n^2)  for(int i=0; i{  p=Parent[i];  while(p!=-1)  {   Height[p]=max(Height[p], Height[i]+1);   i=p;   p=Parent[i];  }  } return Height[root];  2. O(n) time, and O(n) space 1- build a n-ary tree based the parent array 2- traverse n-nary tree to compute height  void BuildTree() {    Tree[n];     for(i=0;i   {        if(Parent[i]!=-1)       {            Tree[Parent[i]]->nextChild = &Tree[i]; //add i to its parent's child list       }    }  int Height(node) {  if(!node->Child) //leaves   return 0;  int h=0;  while(!node->Child)  {   h=max(h,Height(node->Child));   node->Child = node->nextChild;  }   return h+1; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void create_hash(int parent[],int n) \n{ \n \n int i; \n for(i=0;i maxht) \n   maxht = ht; \n   \n  \n  \n }//end of for  \n \nreturn maxht;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just using a recursion with memoization so that we do not check the paths again. This will be O(n) time and space. Here is the Java code bellow:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.*;  class Test{   static int[] A = {-1,0,1,6,6,0,0,2,7,5,9,10,11,12};    public static void main(String[] str){   Test test = new Test();   System.out.println(test.height(0));   }   public int height(int e){   int depth = 0;   int eFound=find(e);   if(eFound == -1){    return 0;   }   else{    ArrayList aList = new ArrayList();    for( int k=eFound; k <14; k++)    {      if( e == A[k] ){      depth=height(k)+1;      //System.out.println(depth+\" \"+e);      aList.add(depth);     }    }    int max=((Integer)aList.get(0)).intValue();    for ( int h = 1; h    int temp = ((Integer)aList.get(h)).intValue();     if(max < temp)      max=temp;    }    return max;   }  }   public static int find(int e){   int flag = -1;   for(int i=0; i <14; i++ ){    if( A[i] == e ){     flag=i;      break;    }   }   return flag;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{{  }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"in java: \npublic int findHeight(int [] parents){ \n int len = parents.length; \n HashMap seen = new HashMap; \n int height = 0; \n for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void FindTreeHeight(int[] inputArray) \n{ \n \n int arrLen = inputArray.Length; \n        int[] tempArr = new int[arrLen]; \n        for(int i=0;i"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"if no additional memory is allowed, this is my solution with a while loop instead of recursion."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-3","title":"We only needs to find the height of the tree. So we can actually find the number of parents from a single swipe.  Thus height of the tree will be (n) or (n+1)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14952824","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"36","title":"Write an algorithm to print out how many extra duplicates there are in a binary search tree.  input 1:        2    / \\  1   2   output 1: 2 1     input 2:       3     / \\     2   3   / \\   \\  1   2   4         / \\        3   4             \\              5               \\                5  output 2:       2 1 3 2 4 1 5 1   Given: Node {   int value;   Node left;   Node right;  }","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"Easy since the input tree is BST. if we do inorder traversal we will get data in sorted order.  1. Do inorder traversal  2. Have 2 class member variable prevValue and valueCount 3. while traversing check if node.data == prevValue the increase the count  4. else print the value and count - 1  All set  ///  public void printExtraDups(Node root){   //int prev = 0;   if(root != null)   {     if (root.left != null )     printExtraDups(root.left);     if( prevData == root.data) count++;    else System.out.println(\"Prev: \"+prevData+\" count: \"+(count -1));     prevData = root.data;     if(root.right !=null )     printExtraDups(root.right);   }  } \\\\\\"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use a regular BST search but send parent value to children and keep a class level HashMap of current dups { HashMap  dupMap = HashMap();  //head will trying to compare with null  void findDups(BSTNode parent, BSTNode current)   {     if(current.data == parent.data)     {      //see if already in map, if not put it in with value 1, else pull out value, increment, insert again     }     parent = current     for(BSTNode child : current.getChildren)     {        findDup(child, parent)     }   }  }    Not the best pseudo code but you get the point"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"just use inorder tree traversal once and then traverse the array to find number of duplicates."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I just wonder is input2 tree a binary tree?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Could you please confirm that tree is Binary tree or BST ? If its BST then what is the duplicity rule in BST I mean \"left-key <= root-key < right-key\" or \"left-key <= root-key <= right-key\" or \"left-key < root-key <= right-key\" ??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.ArrayList;  public class amazon {  private static node root=new node();    void input(int value)  {   node temp=new node();   temp.value=value;   if(root==null)   {    root=temp;   }   else   {    setvalues(root, temp);   }     }      void setvalues(node root, node temp)  {   if(root.value>temp.value)   {    if(root.left==null)    {     root.left=temp;    }    else     setvalues(root.left, temp);   }      if(root.value<=temp.value)   {    if(root.right==null)    {     root.right=temp;    }    else     setvalues(root.right, temp);   }     }    static void printDuplicates(ArrayList tem1)  {   int pointer1=tem1.get(0), pointer2=0;   for(int x=1;x  {    if(pointer1==tem1.get(x))    {     pointer2++;    }    else    {     System.out.println(pointer1+\"hekllo\"+pointer2);     pointer1=tem1.get(x);     pointer2=0;    }       }  }    public static ArrayList display(node temp,ArrayList tem1)  {   if(temp!=null)   {    display(temp.left, tem1);    tem1.add(temp.value);    System.out.println(temp.value);    display(temp.right, tem1);       }   return tem1;  } }   class node {  int value;  node left;  node right;  node()  {   this.value=0;   this.left=null;   this.right=null;  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do inorder traversal and put each element in an array. Now traverse the array and have 2 vars.  count and lookingFor. Initialize count=1 and lookingFor=a[0] if a  is the obtained array. Now, int i=1; while(i{ if(a[i]==a[i-1]) count++; else { cout<<<\"is duplicated\"<<<\"times\\n\"; lookingFor = a[i+1]; count=1; i++; } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In the input 2 how can node 3 be on both side of root node 3??? Either it should be on left side or right side. If this is not the case then inorder traversals would fail and won't give result in a sorted manner. Hashing is the only solution in that case."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"As I feel, given example in question is not a BST. @sastry.soft: we can't keep BST according to definition. but if we don't have choice and we have to keep duplicates then either we should keep it as left child or right child but not both."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is the given tree a Binary Search tree?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.*;   class Node{  int value;  Node left=null;  Node right=null;   public Node(int value){   this.value=value;  }  public int get(){      return this.value;  }   public void set(int value){      this.value=value;  }   } class hashmapResult{  HashMap hm = new HashMap(); }  public class BST {   /**   * @param args   */       public static void main(String[] args) {   // TODO Auto-generated method stub   System.out.println(\"Starting...\");   System.out.println();      int bstHeight=5;   double totalnumofNode=Math.pow(2, bstHeight)-1;   LinkedList bst= new LinkedList();      constructBst(bst,bstHeight,totalnumofNode);      for(int i=0;i  {    if(bst.get(i).left==null||bst.get(i).right==null){     System.out.println(\"Node \" +i +\": \"+bst.get(i).value+\"  Left: NULL  Right: NULL\");     }    else{     System.out.println(\"Node \" +i +\": \"+bst.get(i).value+\"  Left: \"+bst.get(i).left.value+\"  Right: \"+bst.get(i).right.value);          }      }    printDups(bst);    }   private static void printDups(LinkedList bst){   hashmapResult hmR= new hashmapResult();   fillHashmap(bst.getFirst(),hmR);   Set entries = hmR.hm.entrySet();   Iterator it = entries.iterator();         while(it.hasNext()) {     Map.Entry me = (Map.Entry)it.next();     System.out.print(me.getKey() + \": \");     System.out.println(me.getValue());         }         System.out.println();     }    private static void fillHashmap(Node root,hashmapResult hmR){   if(root!=null&&root.value!=0){        if(root.left!=null&&root.left.value!=0)    {     fillHashmap(root.left, hmR);    }        Set keys = hmR.hm.keySet();    if(!keys.contains(root.value))    {     hmR.hm.put(root.value,0);    }    else    {     int count=(int)hmR.hm.get(root.value)+1;     hmR.hm.put(root.value,count);    }        if(root.right!=null&&root.right.value!=0)    {     fillHashmap(root.right, hmR);    }       }  }      private static void constructBst(LinkedList bst, int bstHeight,double totalnumofNode) {   // TODO Auto-generated method stub   Random randomGenerator = new Random();      for(int i=0;i   Node node=new Node(0);    bst.add(node);      }     for(int i=0;i   bst.get(i).left=bst.get(i*2+1);    bst.get(i).right=bst.get(i*2+2);   }       for(int i=0;i<10;i++){    int randomInt = randomGenerator.nextInt(5)+1;      insertNode(bst.get(0),randomInt);   }      }    private static void insertNode(Node root,int value){   if(root.value==0)   {    root.value=value;   }   else{    if(root.value>value)     insertNode(root.left,value);    if(root.value<=value)     insertNode(root.right,value);   }  }     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The given tree in input 2 is NOT a BST. A BST must maintain an invariant that given any node, all nodes in the sub-tree rooted at the given node must follow some kind of order, say all nodes in the left side of the root of the sub-tree must be less than the root (given node) and similarly all nodes from right side of the sub-tree must be greater than the root (given node). For a BT to become a BST this invariant must be true for all sub-trees rooted at all of its nodes. The tree in example 2 doesn??t follow this invariant as it has root 3 which has node 5 on its left. I think ??pradegup?? has already noticed this anomaly ??C kudos to him.  However the question can still be valid for either a BT or a BST. In both cases a traversal of tree along with comparing duplicate check and maintaining their count can be done in theta(n) time. In case of BT I think additional memory in the form of hash-table like data structure would be required in maintaining the duplicate key??s count. However for BST we don??t need any additional memory if we maintain a collection of values for duplicate keys ensuring even a duplicate key occurs only once in the tree (but they may have more than one value per duplicate key). Anyway the idea is that with actual implementation of a BST with duplicates the need for additional memory (Hash-table) may go away whereas for BT additional memory is essential."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int prev = -1; \nint count = 0; \n \nprint_dup (node *root) \n{ \n    if (root != NULL) \n    { \n        print_dup(root->left); \n        if (root->val == prev) \n            count++; \n        else \n        { \n            if (count > 0) \n            { \n                   printf (\" num:%d, count:%d\", prev, count); \n                   count = 0; \n             } \n        } \n        print_dup(root->right); \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void print_extra_duplicates(node *root) {  int count = 0;  node *tmp;     if(root == NULL) return;     print_extra_duplicates(root->left);     tmp = root->right;    while(tmp != NULL && root->data == tmp->data)    {     count++;    tmp = tmp->right;    }         if(count)     {     printf(\"\\n Data:%d Extra Duplicate:%d\\n\", root->data, count);     root = tmp;     if(root == NULL) return ;    }        print_extra_duplicates(root->right); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include typedef struct node {   node *left;   int data;   node *right; };  int inorder_array[20]; int index; node *insert(node *root, int data); void print_extra_duplicates(node *root); void inorder_traverse(node *);  int main() {  printf(\"\\n Welcome Pankaj....\\n\");  node *root = NULL;  int n1 =0, sum = 0;  int n,i;  int input[20];  printf(\"\\n Enter size of array=\");  scanf(\"%d\",&n);   for(i=0;i        scanf(\"%d\",&input[i]);   for(i=0;i {  root = insert(root, input[i]);  }   inorder_traverse(root);  print_extra_duplicates(root);   return 0; }  void inorder_traverse(node *root) {  if(root == NULL) return;   inorder_traverse(root->left);   inorder_array[index++] = root->data;   inorder_traverse(root->right); }  void print_extra_duplicates(node *root) {  int count = 0, i;  node *tmp;   for(i = 0; i {   while(inorder_array[i] == inorder_array[i+1])   {    i++;    count++;   }   if(count)    {    printf(\"\\n Data:%d Extra Duplicate:%d\\n\", inorder_array[i], count);   }   count =0;  } }  node *insert(node *root, int data) {  if(root == NULL)  {   root = (node *)malloc(sizeof(node));   root->data = data;   root->left = NULL;   root->right = NULL;   return root;  }   if(root->data > data) root->left = insert(root->left, data);  else root->right = insert(root->right, data);         return root; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int countDuplicates(Node node, int  value){ if(node == null) return 0; return countDuplicates(node.left, value) +             countDuplicates(node.right, node.data) +             node.data==value?1:0 }  Call: countDuplicates(root, -1); // Assuming -1 is not presesnt in the tree"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int countDuplicates(bnode node, int &prev) \n{     \n    if ( node == NULL) return 0; \n    int lcount = countDuplicates(node->left, prev); \n    prev = node->data;               \n    int rcount = countDuplicates(node->right, prev);  \n    return (prev == node->data)? lcount+rcount+1 : lcount+rcount;             \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Are you sure if its a BST..because the examples you have given are not BST.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Keeping totalCount as global variable"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simply use iterative in-order traversal :"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Can we have duplicates in BST?"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=11635902","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"37","title":"Given a Binary tree where nodes may have positive or negative value, store the sum of the left and right subtree in the nodes.  Eg-","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"int sumify(Node node){ \n   if(node == null) \n      return 0; \n  else{ \n   int tmp = node.data; \n   node.data = sumify(node.left)+sumify(node+right); \n   return node.data+tmp;  //corrected this \n  } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1)Traverse the tree from root to leaf and store the sum of left and right child in the node. 2)When leaf nodes are reached, set the leaf node values as 0 3)Repeat step 1."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. sum(root) 2. if leaf mark zero and return original value saved in temp 3. else root->value = sum(root->lc) + sum(root->rc); 4. return root->value;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"easy, a recursive function will do that."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"hi akshay.shetye, i think the code will be like this because when you store it parent node it will update parent own value also.which could not recieved by grandparent. and i think it will update all node of tree with '0' value.  plz correct me if am wrong..  int sum(struct node* root) {  if(root==null)return 0;  if(root->left==null) root->left->data=0; //correct me here if i am wrong  if(root->right==null) root->right->data=0;   root->data=root->left->data + root->right->data +sum(root->left)+sum(root->right);  return 0; // i think every node of binary tree has been modified. }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This has been posted before. The keypoint is to label every node with an index from left to right. void SumFromLeftToRight(TreeNode* root, hash_map& sums) {  if(root == NULL)   return;   stack s;  stack sIndex;  TreeNode* current = root;  int currentIndex = 0;   while(current != NULL || !s.empty())  {   if(current != NULL)   {      if(sums.find(currentIndex) == sums.end())     sums[currentIndex] = 0;     sums[currentIndex] += current->value;     s.push(current);    sIndex.push(currentIndex);     --currentIndex;    current = current->left;   }   else   {    current = s.top();    currentIndex = sIndex.top();    s.pop();    sIndex.pop();      if(current->right != NULL)    {     ++currentIndex;    }     current = current->right;   }  } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int sumTree(node* root) {     if(!root)      return 0;     int l = sumTree(root->left);     int r = sumTree(root->right);     int lv=0,rv = 0;     if(root->left)      lv = (root->left)->val;     if(root->right)      rv = (root->right)->val;           root->sum = l + r + lv + rv;          return root->sum;        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"class Sum {   public int childSum(Node root) {     if(root == null) {       return 0;     }     int returnVal = root.getData();     int lsum = sum(root.getLeft());     int rsum = sum(root.getRight());     root.setData(lsum + rsum);     return returnVal;   } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Why not write an iterative postorder. In visit instead of printing take the sum of left and right trees. any comments?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi, i attended the interview process last week, the same qns were asked... Where was your interview? Banglore or chennai?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Duplicate for qns 11635902"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int sumify(Node *root) \n{ \n if (root == NULL) \n { \n  root->sum = root->data; \n } \n else \n { \n  root->sum = sumify(root->left) + sumify(root->right) + root->data; \n } \n return root->sum; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int    cal_sum(struct node *root)    {        int l, r;              if(root==NULL)       return 0;              int t= cal_sum(root->l) + cal_sum(root->r);              printf(\" %d\", t);       return t+(root->val);    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"simple way to do this is, with out modifying the tree itself.  print_sum(node *root) {  if (root->left == NULL && root->right->==NULL){  cout<<  0;  sum = root->item; } else {  sum = print_sum(root->left)+ print_sum(root->right); cout << sum;  } return (sum);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"A post-fix traversal (left, right, root) should work.  root would contain the sum of left + right.  Is there anything more complexity involves that I'm missing."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void findSum(int n){ \n  if (a1[(2*n)] == 0 || a1[(2*n)+1] == 0 ){ \n   return ; \n  } \n  else \n  { \n   findSum(2*n); \n   findSum(2*n+1); \n    \n    \n   b1[n] = a1[2*n] + a1[2*n+1]; \n   int temp = a1[n]; \n   a1[n] = a1[2*n] + b1 [2*n] + a1 [2*n + 1] + b1 [2*n + 1]; \n   b1[n] = temp ; \n    \n  }  \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In the above solution , b1 is empty array with all the values 0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int sumsubtree(node* root, int prev) {     if(root==NULL)     {                   return 0;     }     else     {         int temp, sum;         temp= root->data;         root->data = sumsubtree(root->left, temp) + sumsubtree(root->right, temp);              return root->data + temp;     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void changenodeVal(node1 p)  {   int leftval=0,rightval=0;   if(p!=null)   {    if(p.left!=null)    {     leftval=p.left.val;    }    if(p.right!=null)    {     rightval=p.right.val;    }    changenodeVal(p.left);    changenodeVal(p.right);        if(p.left!=null&&p.right!=null)     p.val=leftval+rightval+p.left.val+p.right.val;    else     p.val=leftval+rightval;    }    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int NodeVal(struct Node *node) {     if(node == NULL)           return 0;     else     {        int lval=0;        int rval=0;        if(node->left != NULL) lval = node->left->data;        if(node->right != NULL) rval = node->right->data;        int sum = NodeVal(node->left)+NodeVal(node->right);        node->data = sum + lval + rval;     } } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what if we do postorder traversal....and add children...as we move up"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int getSum(struct node* root) {   if(root == NULL)return 0;   int lSum=getSum(root->left);   int rSum=getSum(root->right);   int curVal=root->data;   root->data=lSum+rSum;   return lSum+rSum+curVal; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=16126663","download_status":"DOWNLOAD_DONE","votes":"5","answersCount":"34","title":"Given a binary tree. Write a function that takes only root node as arguement and returns (sum of values at odd height)-(sum of values at even height).","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"19","title":"Solution with a some simplification: Call the function with the root of the tree The root is at height 0."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"Do a postorder also maintain a level, if level is odd then add the root->val otherwise subtract it."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Same can be achieved using BFS."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"int heightsum(node *root) \n{ \n if(!root) \n  return 0; \n \n static int sum, level; \n level++; \n \n heightsum(root->left); \n heightsum(root->right); \n  \n level--; \n \n if(level % 2) \n  return sum -= root->data; \n else \n  return sum += root->data; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"I think it will work...... It is just algorithm........ function SUM(root,level) {  if(root==NULL)  return(0);  if(level%2==0)  return(SUM(root->left,level+1)+SUM(root->right,level+1)-root->data);  return(SUM(root->left,level+1)+SUM(root->right,level+1)+root->data); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Working code:  public static int getDiffOfEvenOddLevel(Node root, boolean isLevelEven) {  if (root == null)   return 0;   if (isLevelEven)   return root.data + getDiffOfEvenOddLevel(root.left, false) + getDiffOfEvenOddLevel(root.right, false);  else   return -root.data + getDiffOfEvenOddLevel(root.left, true) +  getDiffOfEvenOddLevel(root.right, true); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"public class BinaryTreeExample { \n public static void main(String[] args) \n { \n  new BinaryTreeExample().run(); \n } \n \n static class Node \n { \n \n  Node left; \n  Node right; \n  int value; \n \n  public Node(int value)  \n  { \n   this.value = value; \n  } \n } \n \n public void run()  \n { \n  Node rootnode = new Node(25); \n  System.out.println(\"Building tree with rootvalue \" + rootnode.value); \n  System.out.println(\"=================================\"); \n  insert(rootnode, 11); \n  insert(rootnode, 35); \n  insert(rootnode, 8); \n  insert(rootnode, 12); \n  insert(rootnode, 30); \n  insert(rootnode, 40); \n  System.out.println(\"Traversing tree in order\"); \n  System.out.println(\"========================\"); \n \n  printInOrder(rootnode); \n  System.out.println(sum(rootnode)); \n \n } \n \n private int sum(Node rootnode) { \n   if(rootnode == null) \n    return 0; \n   else \n    return (rootnode.value + -sum(rootnode.left) +  -sum(rootnode.right)); \n } \n  \n \n public void insert(Node node, int value) \n { \n  if (value < node.value)  \n  { \n   if (node.left != null) \n   { \n    insert(node.left, value); \n   }  \n   else \n   { \n    System.out.println(\"  Inserted \" + value + \" to left of node \"+ node.value); \n    node.left = new Node(value); \n   } \n  } \n  else if (value > node.value)  \n  { \n   if (node.right != null) \n   { \n    insert(node.right, value); \n   } else { \n    System.out.println(\"  Inserted \" + value + \" to right of node \" \n      + node.value); \n    node.right = new Node(value); \n   } \n  } \n } \n \n public void printInOrder(Node node)  \n { \n  if (node != null) { \n   printInOrder(node.left); \n   System.out.println(\"  Traversed \" + node.value); \n   printInOrder(node.right); \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"level order traversal.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming root is at height '0' which is at even height."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int sum(struct node * root){ \nif(root == NULL) return 0; \nreturn (root->data - sum(root->left)-sum(root->right));}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"private void DifferenceSumatOoddandSumatEven(ref int sum, BinaryTreeNode node, int level)         {             if (node == null) return;                         if ((level & 1)==0)//if level is even                 sum+=node.item;             else                 sum += -1 *node.item;                         DifferenceSumatOoddandSumatEven(ref sum, node.Left, level + 1);             DifferenceSumatOoddandSumatEven(ref sum, node.Right, level + 1);         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Was asked in Flipkart phone round."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int sumOddMinusEven(struct node* root) { \n \n  if (root == NULL) return 0; \n   \n  int level = 1; \n   \n  queue< pair > q; \n   \n  q.push( make_pair(level, root) ); \n   \n  int oddSum = root->data; \n  int evenSum = 0; \n   \n  while(!q.empty()) { \n   \n    pair my_element = q.front(); \n    struct node* current = my_element.second; \n    int childLevel = my_element.first + 1; \n     \n    q.pop(); \n     \n    bool isEven = (childLevel % 2 == 0) ; \n     \n    if (current->left != NULL) { \n      q.push( make_pair( childLevel, current->left ) ); \n      if (isEven) { \n        evenSum += current->left->data; \n       } else { \n        oddSum += current->left->data; \n       } \n    } \n     \n    if (current->right != NULL) { \n      q.push( make_pair( childLevel, current->right ) ); \n      if (isEven) { \n        evenSum += current->right->data; \n       } else { \n        oddSum += current->right->data; \n       } \n    } \n   \n  }  \n \n  cout << \"Odd Sum \"<< oddSum<"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use BFS, use some counters and a flag to track odd or even levels. If count == 0, a new level starts and the flag needs to be reset. The program will stop when the linked list is empty. struct node{  int value;  struct node *l;  struct node *r;  struct node *next; } node; int getValue(node * root){   int count = 1; //Root   int values = 0;  int count1= 0;  int flag = 0;  node *head = (node *)calloc(sizeof(node), 1);  head->next = root;  p1 = head->next; //p tracks the tail of the list  while(head->next != NULL){   if(flag == 1)    values +=head->next->value;   count --; // Take out the next node    if(count == 0){    count = count1;    if(flag == 0) flag = 1;    else flag = 0;   }    if(head->next->l != NULL){    p->next = (node*)calloc(sizeof(node), 1);    p = p->next;    count1 ++;   }   if(head->next->r != NULL){    p->next = (node*)calloc(sizeof(node), 1);    p = p->next;    count1 ++;   }   node *p1 = head->next;   head->next = head->next->next;   free(p1);      }   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here is a BFS solution, using two Queues to store nodes and the level of nodes. then it can be easily solved."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using Bfs"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.LinkedList; \nimport java.util.Queue; \n \n/*Given a binary tree. Write a function that takes only root node as arguement and  \nreturns (sum of values at odd height)-(sum of values at even height).*/ \npublic class Odd_Even_Sum { \n \n public static void main(String[] args) { \n \n  TreeNode root = new TreeNode(1); \n  root.leftchild = new TreeNode(2); \n  root.rightchild = new TreeNode(3); \n  root.leftchild.leftchild = new TreeNode(4); \n  root.leftchild.rightchild = new TreeNode(5); \n  root.rightchild.leftchild = new TreeNode(6); \n  root.rightchild.rightchild = new TreeNode(7); \n  root.rightchild.leftchild.leftchild = new TreeNode(8); \n  root.rightchild.leftchild.rightchild = new TreeNode(10); \n  root.rightchild.rightchild.rightchild = new TreeNode(9); \n  System.out.println(utilFuction(root)); \n \n } \n \n \n public static int utilFuction(TreeNode root) \n { \n \n  Queue queue = new LinkedList(); \n  queue.add(root); \n  TreeNode current ; \n  boolean flag = true; \n  int sum =0; \n  Queue temp_queue = new LinkedList(); \n  while(!queue.isEmpty()) \n  { \n \n   current = queue.poll(); \n   if(flag) \n    sum =sum + current.data; \n   else \n    sum = sum - current.data; \n   if(current.leftchild!=null) \n    temp_queue.add(current.leftchild); \n   if(current.rightchild!=null) \n    temp_queue.add(current.rightchild); \n \n   if(queue.isEmpty()) \n   { \n    queue = temp_queue; \n    temp_queue = new LinkedList(); \n    flag = !flag; \n   } \n \n  } \n   \n  return sum; \n \n } \n \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14800891","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"34","title":"Print a binary tree in vertical.  e.g.,             1        /      \\     2           3    /           /  4          5               \\                             6  o/p: 4 2 1 5 3 6","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"I am assuming that we have to print going from the left lines to the right lines, and top to bottom on a given line.  Each node is on a vertical line and can be assigned a number. The line corresponding to the root being zero. If a node has the vertical line number v, then its left child has number v-1, and right child has v+1.  So we can do a breadth first search, collecting all nodes with the same vertical line in a list.  Once we are done, we can print the lists, in sorted order of the vertical number.  Pseudo code might look something like this"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"I suspect a lot of these questions posted here are posted by people that suck at math. Why? Because definitions are important. I can't reconcile any sensible definition of 'vertical' between the tree you drew up and the o/p you posted. So why not define what vertical means here for your nodes. Make sure it is rigorous too. There isn't anything interesting about wasting time trying to figure out what you are trying to say. Communication is important so don't kid yourself by thinking otherwise."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"sry abt the bad tree structure  Root Node: 1 Left Child of 1: 2 Right Child of 1: 3 Left Child of 2: 4 Left Child of 3: 5 Right Child of 5: 6"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"General algorithm:  You are going to iterate through a hashtable depending on what group the node belongs and then print it in order from top to bottom."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Assign 2D coordinates to nodes \n                                   1( 0,0 ) \n                                 /            \\ \n                             2(-1,1)      3 (1,1) \n                             /                  /      \\ \n                           4(-2,2)    5(0,2)  6(2,2)  \n2. Sort the coordinates \n-2,2 \n-1,1 \n0,0 \n0,2 \n1,1 \n2,2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi , What if the two nodes are at the same level .... do you want their sum to be printed .... ?? If yes, just create a Hash data structure and index using hash levels (-1,0,1) and iterate over the hash and print the sum"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"what if 2 had a right child. Then  its coordinates and coordinates of 5 would be the same (0,2). In that case what is the correct order ??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"printVertical(Node node){  if(node==null) return;  Stack stack = new Stack(); List queue = new ArrayList(); Node temp = node;  while(temp!=null){        stack.push(temp);        temp = temp.left; }  while(!stack.isEmpty()){       temp = stack.pop();      if(temp.right!=null){            queue.add(temp.right);      }      PRINT(temp.data); }  while(!list.isEmpty())      printVertical(list.remove(0));  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"package trees; \n \npublic class TreeNode { \n \n private int data; \n private TreeNode left; \n private TreeNode right; \n  \n public TreeNode(int d){ \n  this.data = d; \n } \n  \n public TreeNode appendRight(int d){ \n  this.right = new TreeNode(d); \n  return this.right; \n } \n \n public TreeNode appendLeft(int d){ \n  this.left = new TreeNode(d); \n  return this.left; \n } \n \n public int getData() { \n  return data; \n } \n \n public void setData(int data) { \n  this.data = data; \n } \n \n public TreeNode getLeft() { \n  return left; \n } \n \n public void setLeft(TreeNode left) { \n  this.left = left; \n } \n \n public TreeNode getRight() { \n  return right; \n } \n \n public void setRight(TreeNode right) { \n  this.right = right; \n } \n  \n public static void print(TreeNode node){   \n   \n  if(node!= null){ \n   print(node.left); \n   System.out.print(node.data+ \" \"); \n   print(node.right); \n  } \n } \n} \n \npackage trees; \n \n/** \n * Imagine a vertical line sweeping the tree from Left to right and we will print \n *  nodes at each vertical level in an ascending order of the depth of the node  \n *  from the root. \n */ \nimport java.util.ArrayList; \nimport java.util.Collections; \nimport java.util.HashMap; \nimport java.util.List; \nimport java.util.Map; \n \npublic class PrintTreeVertically { \n \n public static void main(String[] args) { \n  TreeNode root = new TreeNode(1); \n \n  root.appendLeft(2).appendLeft(4); \n  root.getLeft().appendRight(5).appendLeft(8); \n \n  root.appendRight(3).appendLeft(6); \n  root.getRight().appendRight(7); \n \n  Map> nodes = new HashMap>(); \n  organizeNodesVertically(root, 0, nodes); \n \n  List verticalIndices = new ArrayList(nodes.keySet()); \n  Collections.sort(verticalIndices); \n \n  for (Integer i : verticalIndices) { \n   ArrayList list = nodes.get(i); \n   for (TreeNode treeNode : list) { \n    System.out.print(treeNode.getData() + \" \"); \n   } \n  } \n \n } \n \n private static void organizeNodesVertically(TreeNode root, \n   int verticalIndex, Map> nodes) { \n  if (root == null) { \n   return; \n  } \n \n  if (nodes.get(verticalIndex) == null) { \n   nodes.put(verticalIndex, new ArrayList()); \n  } \n \n  nodes.get(verticalIndex).add(root); \n \n  organizeNodesVertically(root.getLeft(), verticalIndex - 1, nodes); \n  organizeNodesVertically(root.getRight(), verticalIndex + 1, nodes); \n \n } \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Algorithm: \n \nstack.push(root) \nwhile (!stack.empty()) \n{       while(stack.top().->leftchild!=NULL)  \n                    Stack.push(stack.top()->leftchild()); \n        temp=stack.pop(); \n        print(temp) \n        stack.push(temp->rightchild) \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void BST::printVertical(Node *root,int index,map>& list) { \n     \n    if ( root == NULL) \n        return; \n     \n    vector l = list[index]; \n    l.push_back(root->value); \n    list[index] = l; \n     \n    printVertical(root->leftChild,index-1,list); \n    printVertical(root->rightChild,index+1,list); \n     \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void BST::printVertical(Node *root,int index,map>& list) { \n     \n    if ( root == NULL) \n        return; \n     \n    vector l = list[index]; \n    l.push_back(root->value); \n    list[index] = l; \n     \n    printVertical(root->leftChild,index-1,list); \n    printVertical(root->rightChild,index+1,list); \n     \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"It's a simple in-order traversal of the tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"This comment has been deleted."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14453690","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"34","title":"Given the Pre-order of the BST .check if each non-leaf node has only one child.Linear Time is expected.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"7","title":"boolean checkOneChild(int[] preorder)  {   for(int i=0; i  {    int a = preorder[i]-preorder[i+1];    int b = preorder[i]-preorder[preorder.length-1];    if(a*b<0)     return false;    if(a*b==0)    {     if(a+b<0)      return false;    }   }  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"6","title":"bool checkSingleChild(int[] preOrder, int n) { \n        int min, max, i; \n        min = max = preOrder[n-1]; \n         \n        for ( i = n-2; i>=0; i-- ) { \n        int term = preOrder[i]; \n \n        if ( term > max )  max = term; \n        else if ( term < min )  min = term; \n        else return false; \n        } \n \n        return true; \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"The logic is simple. For a node, all successors are either less our greater than that node. Implementation may differ from person to person."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Theres also a NlogN solution for this problem.  Since its a BST and not a regular binary tree, we can reconstruct the binary tree from the pre-order traversal.  Algo:: a) First Element of the array is root. b) Scan the array till we encounter an element greater than the root. This element marks the beginning of the right subtree. c) Now, we have the elements of both the left and right tree. So, we recursively apply the  above algorithm.  This algorithm will take NLogN time.  Once the BST is constructed, we can do a tree traversal and determine the internal nodes with one/two children in linear time"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This comment has been deleted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include \n#include \nint main() \n{ \n  int count=0,*p; \n  scanf(\"%d\",&count); \n  int i=0; \n  p=(int *)malloc(sizeof(int)*count); \n  for(i=0;imax || p[i]p[i]) \n  { \n     min=p[i]; \n  } \n  else \n  { \n    max=p[i]; \n  } \n  } \n  if(i==count) \n   printf(\"true\"); \n  else \n   printf(\"false\"); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is almost same as what @LoocalVinci's logic is."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"rebuilt the bst. This is oN algorithm!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"check the array from end. each element should be greater than max or less than min for the rest of the array."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi Guys  I normally don't comment on these questions, but I feel everyone has it wrong here. In a Pre-Order traversal where all non-leaf nodes have two children, what property can on extract? The thing to look for is that if a node value decreases, then there must be an increase somewhere. In other words, if a parent node has a left child (a decrease in value), then there must also be an increase value (a right child) in order for that parent to have two children. In short, if you count the number of times a node increases, and the number of times a node decreases, then in a tree with each non-leaf node that has two children, it should balance out perfectly.  Here is the algorithm"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=12527666","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"34","title":"You are given a function printKDistanceNodes which takes in a root node of a binary tree, a start node and an integer K. Complete the function to print the value of all the nodes (one-per-line) which are a K distance from the given start node in sorted order. Distance can be upwards or downwards.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"We shall have to do breadth first scan For a normal binary tree (not BST), I think we shall to sort node by node value, explicitly by collecting them. Is there anyway to do it directly from in the tree?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"BFS to know the depth of all nodes in the tree and then consider those which comprise u + d = K. u = upward distance, d = downward distance from the start node. Ex:- K= 4, and start node is at depth 3.  The u and d can take values (0,4)(1,3)(2,2)(3,1)(4,0). Meaning consider the upward distance of 0 and downward distance of 4 from from start node => 3 + 4 = 7. Consider nodes beneith start node which are at level 3. Similarly for other combinations.  As and when fetching the nodes do an insertion sort."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void PrintKDepth(node *root, int depth) \n{ \n if (root == null) return; \n  \n if (depth == 0 ) \n { \n  Print the root; \n } \n PrintKDepth(root->left,depth-1); \n PrintKDepth(root->right,depth-1); \n} \nint PrintAllKthDistance(node *root, node *start, int depth K) \n{ \n if(root == null) return -1; \n if(root == start) \n { \n  PrintKDepth(root->left, k); \n  PrintKDepth(root->right, k); \n  return k-1; \n } \n int leftDepth = PrintAllKthDistance(root->left,start,found,K); \n if(leftDepth == 0) \n { \n  print the node; \n } \n else if (leftDepth > 0) \n { \n  PrintKDepth(root->right, leftDepth); \n  return leftDepth-1; \n } \n int rightDepth = PrintAllKthDistance(root->right, start, found, k); \n if(rightDepth == k) \n { \n  print the node \n } \n else if (rightDepth > 0) \n { \n  PrintKDepth(root->left, rightDetph); \n  return rightDepth-1; \n } \n return -1; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"is distance is like just height or depth or else it can be any distance (like hop) suppose k=2... so for this do we need to find the immediate sibling?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Is there any constraint on the space usage? if not, lets say that we're allowed to use extra space of O(n).  We can create an array, do a BFS on the binary tree and store the nodes encountered in our array. One we're done with the BFS, we can find the nodes with satisfy the distance property. For example, lets say our tree was:     4         /   \\        2     6              / \\     /   \\      1  3  5   7  Now if we did a BFS, we would get the array as: 4,2,6,1,3,5,7. Lets say the start node is root node (i.e. 4), the node to be searched is 3 and K = 2.  Now we know that we can find the children of a node at 2n+1, 2n+2 position (en.wikipedia.org/wiki/Binary_tree#Arrays)  Given this array, we can look for the index of node 3 (which happens to be 4 in our example). Now, we are looking for all nodes which are at a distance of k = 2 from node 3. We know that the parent of 3 (if it exists) must be at a distance = 1 from 3. This parent can be found at (index of node3 -1)/2. This node is at index = 1. Now node 3 can ask its parent to return all nodes which are at a distance (k-1) [such that k-1 ==0].Node 2 sees that there are only 2 nodes which satisfy this property: Node 4 and Node 1 (ignoring Node 3 itself). so these 2 nodes are printed. Node 3 also asks its children to  return all nodes which are at a distance of k.  Hence, recursively it looks possible to discover all the nodes (including siblings) which are at a distance of k from node 3.  This is just an initial idea. And requires O(n) extra space. Runs in O(n) time."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Start from root node.  Identify if start node is to left of root node or right of root node.   Start bfs:   label each node with the 'level' value     also label each node with flag '1', if nodes are on other side of 'start' node    if nodes have startnode as ancestor , label them as '2'   else label them with '0'.   Now, while printing, do in-order traversal,  and only print nodes that meet the following condition:  if ( node.side = '1' and  startnode.level + node.level == k ) print node if ( node.side = '2' and  node.level - startnode.leve == k ) print node if ( node.slide = '0' )  common ancestor between startnode and node is at  l =  abs(startnode.level - node.level) now if   l + node.level == k , then print."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use recursion to first find downwards distance  Signature is:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The Algorithm would be something like this(would post the code later) 1.Do a DFS traversal for the tree(Inorder) 2.In the Process node part call a sub routine find_distance between_two_nodes 3.Check if the return val of 2 is equal to k, if yes print it or store it in an array(for sorting)  find_distance between_two_nodes works as follows 1. Find LCA of the 2 nodes under discussion 2.from the LCA call get_node_distance_from_lca subroutine for both the nodes and add the result and return  get_node_distance_from_lca works as follows find the difference between the level of lca and the node(using BFS)  Space Complexity : S(n)--queue Time Complexity : O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think you can do it without recursion (assuming bst, otherwise sorted order does not make sense):  Find your node using binary search and note the path like LLR  start a stack based in order traversal and check whether the distance is less than or equal to K  The distance calculation: find the longest prefix of the two paths then add the tail length of both paths. So, distance between LLR and LR is 3 (L is common, dist: len(LR) + len(R) = 2+1)  Don't enter a subtree/ignore pop from the stack if already too far from the original node (limiting the number of visited nodes to K)  To speed up the distance calc a little bit, you can supply the parent result and add the child difference only.  Time complexity: O(logn) + O(k)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Would anyone make clear to me what it means by distance?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"2 Passes  1st Pass  1. Find the level at which startNode occurs using recursion to traverse the tree  2nd Pass  1. Print all nodes at  level- distance and level+distance using recursion to traverse nodes  Code follows in Java"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void printk(Node root, int k) \n{ \n \n        if(root!=NULL ) \n        { \n                if(k==0) cout<<\"@\"<data<<\"@\"<left, k-1); \n                        printk(root->right, k-1);} \n \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I hope following looks cleaner."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Initialize stack. 2. Start with the root and do a DFS. 3. Once node found,     3.1 Upward, pop the stack K times.    3.2 Downward,         3.2.1 Do DFS on node->lchild and on node->rchild K times"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node *arr[20]; void distup(node *root,node *start,int k) { while(root!=start) { arr[i++]=root; if(start->data > root->data) root=root->rightchild; else root=root->leftchild; } if(root==start) printf(\"%d\",arr[i-k]->data); }// will print K distance UP"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"steps: 1. get the distance of the start node in the tree. 2. make a function printk(node , distance) which prints all the nodes at a level of k from the given node passed as a paramenter. 3. Run the printk(start node , k)  with start node and k , it prints the nodes at level k  down from the start node. 4. let k=4 for eg. and the level of start is 6 , so 6-4 = 2 is the level upto which we need to print the nodes. these will be the node k distance from the start node  5. done"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"fun(node* root,node*start,int k) {        static int flag=0,level= 0;  if(n!=NULL)   {        if(root==start)  // start node found now proceed        { flag=1;        }    if( flag==1)      {        level++;      if(level==k)        cout<      return;      } fun(n->left);   if(level==k&&n!=start)       {    return;     }   else if(n==start)      {        level=0;      }  fun(n->rite)  if(n==start)     {  k=1;     } } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Going down was easy but once i hit the K nodes from bottom, i start returning the value 2*k-1 up along the path.This way , when we again hit the target node while backtracking, we are at (2k-1)/2 and as we move up, we will again be at 0 (or -k) value"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=1731689","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"33","title":"Algo to check if given binary tree is binary search tree or not. Code it and return true or false. Also it should find the number of nodes in the tree irrespective if the tree is BST or not.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"see prev threads ..solution using INT_MAX AND INT_MIN"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"make a inorder traversal of a given tree and if the traversal is in sorted form then the given tree is BST.        10       /  \\      5   15     /\\   /\\    3  8 13 18  Inorder: 3,5,8,10,13,15,18  output will always be sorted for inorder traversal of BST"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct node { \nnode *left; \nnode * right; \nint data; \n}; \nbool inorder(node * root) { \n  static bool isBST = 1; \n  static int count = 0; \n  if(root) { \n    inorder(root->left); \n    chk_BST(root,isBST); \n    count++; \n    inorder(root->right); \n  } \n  else{ \n   cout<<\"No. of nodes = \"<left) { \n     if(root->dataleft->data) { \n       isBST = 0; \n     } \n   } \n   if(root->right) { \n     if(root->data>root->right->data) { \n       isBST = 0; \n     } \n   } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Perform an inorder traversal of the tree and print all the node data. If the node data is in ascending order then it is a binary search tree. To count the number of nodes, keep a counter while traversing the tree inorder."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Detailed description for the above problem with two possible solutions is described here  crackinterviewtoday.wordpress.com/2010/03/12/check-whether-given-binary-tree-is-a-bst-or-not/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Using INT_MAX and INT_MIN only applicable if BST hold ints as data. If BST has elements that do not have natural ordering or, if they do, do not have min and max values (eg. strings), in-order traversal may work better (assuming BST elements have ordering/are comparable) save for the extra space requirement"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"template \nclass TreeNode \n{ \npublic: \n    TreeNode() {}; \n    ~TreeNode() {}; \n \n    TreeNode* left; \n    TreeNode* right; \n \n    T data; \n}; \n \ntemplate \nbool isBST(TreeNode* root) \n{ \n    static int count = 0; \n    static bool bIsBST = true;     \n    static TreeNode* pLastVisited = NULL; \n \n    if (root) \n    { \n        isBST(root->left); \n \n        cout++; \n        if (pLastVisited && pLastVisited->data > root->data) \n            bIsBST = false; \n        pLastVisited = root; \n \n        isBST(root->right); \n    } \n      \n    return bIsBST; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool isBST(node * root) { \n  bool isbst = true; \n  isbst &= root->left ? isBST(root->left) & (root->left->value < root->value):true; \n  isbst &= root->right ? isBST(root->right) & (root->right->value > root->value):true;   \n  return isbst;   \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int TreeCount = 0; bool IsBST(TreeNode root) {     return (NULL == root) ? true:                 (TreeCount++ , (!root->left || (root->left->info <= root->info)) &&                 (!root->right || (root->right->info <= root->info)) &&                 IsBST(root->left) &&                 IsBST(root->right));  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int inorder(struct node *cur, struct node *prev) {  int flag1, flag2;  if(cur==NULL) return 1;  flag1 = inorder(cur->left, prev);  if(prev==NULL) prev = cur;  else if(prev->data>cur->data) return 0;  flag2 = inorder(cur->right, cur);  return flag1 && flag2; }  if(inorder(root, NULL)) print BST else print not BST"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Correction - Question is to find if a given binary tree is a binary search tree or not."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public bool IsItBinarySearchTree(Node node, int data)         {             bool status = true;             if (node != null)             {                 if (data > node.data)                 {                     status = false;                 }                  if (node.left != null)                 {                     status = (node.left.data > node.data) ? false : true;                     if (status)                     {                         status = IsItBinarySearchTree(node.left, node.left.data);                     }                 }                  if (status && node.right != null)                 {                     status = IsItBinarySearchTree(node.right, node.data);                 }             }              return status;         }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"For invoking the above function, pass root & root.data  i.e. IsItBinarySearchTree(root, root.data);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do inorder traversal. It should be sorted."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"isbinarysearch(node*root) { if(root==NULL) return; if(root->left) {     if(root->left->data>root->data)          return false } if(root->right) { if(root->right->datadata) return false } return true"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"isbinarysearch(node*root) { if(root==NULL) return; if(root->left) {     if(root->left->data>root->data)          return false } if(root->right) { if(root->right->datadata) return false } return true isbinarysearch(root->left) isbinarysearch(root->right)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool isBST(Node *tree,int *nodeCount) \n{ \n    if(tree) \n    { \n        bool result=true; \n         \n        if(tree->left==NULL && tree->right==NULL) \n        { \n            (*nodeCount)++; \n            return true; \n        } \n        else \n        { \n            if(tree->left) \n            { \n                result=result && isBST(tree->left,nodeCount); \n            } \n             \n            if(tree->right) \n            { \n                result=result && isBST(tree->right,nodeCount); \n            } \n             \n            result=result && (tree->left && tree->left->value < tree->value) && (tree->right && tree->right->value >= tree->value); \n         \n            *nodeCount++; \n            return result; \n        } \n    } \n    else \n        return false; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Just Inorder traverse the tree and determine the preNode < currentNode is fine PNode IsBSTCore(PTree tree, PNode &pPreNode) {  if(tree)  {   PNode pNode = IsBSTCore(tree->left, pPreNode);   if(pNode) return pNode;   if(pPreNode && pPreNode->data > tree->data)    {    return tree;   }   printf(\"%d\\t%d\\t\", pPreNode? pPreNode->data : -1, tree->data);   pPreNode = tree;   pNode = IsBSTCore(tree->right, pPreNode);   return pNode;  }  return tree; } PNode IsBST(PTree tree) {  assert(tree != NULL);  PNode pNode = NULL;  return IsBSTCore(tree, pNode); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"this will return that binary tree is bst or not and also the no of nodes in the binary tree  int checkBST(struct node *r,int *count) { if(r==NULL) return 1; count++; if(r->left && r->left->data>r->data) k=0; if(r->right && r->right->datadata) k=0; return(k && checkBST(r->left)&&chackBST(r->right)); }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=183797","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"33","title":"How many binary tree can be formed if n number are given","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"5","title":"Catalan Number..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"(1/(n+1)) * (2n * (2n - 1) .... * (n + 1) / n!)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"total no of nodes in a tree with n height T = sum(i=1 to n) (n*2^(n-1)) no of binary trees: select n positions to fill out of these T places=T(P)n=T(C)n*n!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"boss, P: permutation  C: combination  u are right, answer is: T(C)n*n! = T!/(T-n)!   i know the way i have put answer, that makes question look very simple, may be i have misunderstood something, correct me in case i m wrong"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"how did u arrive at this solution. Can u explain please.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The solutions don't consider the fact that 2 trees with the same structure, but different values in different positions are actually different. Is that the intention of the question. If it is not the case, I think the solution is (n!)^2"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"@Somebody: The answer is pretty simple: the count is just a Catalan number which is C(2n, n)/(n+1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Well the purpose of this problem is not to use combinatorics. Say F(n)=no of different binary trees with n nodes. Fix one root node and now we will have n-1 nodes.These n-1 nodes need to be arranged around the pivotal root node. Sum of (F(i)*f(n-i-1)) for i=1 to n-1 might solve ur problem"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorry i =0 to n-1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Sorry i =0 to n-1"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I guess the question is pretty clear. How many different binary trees possible with n different numbers. It has to take in to account both the different possible configurations and different possible ordering of the numbers.   Different possible configurations = Catalan number = Cn = (2n)! / ( (n+1)! n!)  For each of the above configurations, #possible orderings = n!   Hence, total poss binary trees = Cn * n! = (2n)! / (n+1)!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"there are n^(n-2) trees possible with n vertices (Cayley formula). http: //en.wikipedia.org/wiki/Cayley%27s_formula  And for every tree there are n way to pick root. So in my opinion there are n^(n-1) ways possible.   Verify with lower values: n=2   then number of trees = 2 and also the formula gives 2^(2-1)=2 n=3    formula gives 3^(3-1) = 9 can you verify by manually drawing all possible tree with 3 node?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/*   For the key values 1...numKeys, how many structurally unique   binary search trees are possible that store those keys.   Strategy: consider that each value could be the root.   Recursively find the size of the left and right subtrees.  */   int CountTrees(int num) {  if(num <= 1)   return 1;   else  {   // there will be one value at the root, with whatever remains    // on the left and right each forming their own subtrees.    // Iterate through all the values that could be the root.    int sum = 0;   int left, right, root;    for(root=1 ; root<=num ; root++)   {    left = CountTrees(root - 1);    right = CountTrees(num - root);              // number of possible trees with this root == left*right     sum += left * right;   }   return sum;  } }  /** OUTPUT **/ No. of tree possible from : 0 nodes = 1 1 nodes = 1 2 nodes = 2 3 nodes = 5 4 nodes = 14 5 nodes = 42 6 nodes = 132 7 nodes = 429 8 nodes = 1430 9 nodes = 4862"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The max number of binary trees that can be formed from n nodes is given by the Catlan Number C(n).  C(n) = (2n)! / (n+1)!*n! for n>=0."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Simply, C(2n,n)/(n+1)  where n=number of nodes hope u guys know C(n,r) = nCr = n!/r!(n-r)!   :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"2^N - N"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi,  This is a pretty simple answer catalan number, but the questions asked is to write a program and when you write a program, the program dies after 30 or 35. So we use memoization in the code to improve it to run for a greater N.  After the memoization solution, the interviewer also asks if there is another way , then we go with DP as well.. I have documented all these into an article , hope this helps others techieme.in/techieme/count-binary-search-trees/"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"In case of Binary Trees- number of different non-isomorphic structures: (2^n - n ), n is number of nodes  In case of Binary Search Trees- number of different non-isomorphic structures = Catalan Numbers isomorphic structures are those where ordering ( left/right matters ) ( refer geeksforgeeks)"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=11983859","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"32","title":"Given the head of a Binary Search tree, trim the tree, so that all elements in the new tree returned are between the inputs A and B","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"8","title":"This is similar to checking whether tree is a BST or not, using min and max.  If root is in range keep root and run function on childs. If root else make left child as root and run function on it, free root and its right part"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"Node Trim(Node root, int A, int B) { \n   if(root==null) return null; \n    \n   if(root.data>B) return Trim(root.left,A,B); \n   else if(root.data"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do depth-first traversal, check value in each node and then call remove on that node if it's between A and B?  Or, we could go through each node, insert it into a new tree if value is between A and B"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"solutions above are not correct - in a BST if a node is within a range (A,B) it's not guaranteed that the parent of that node falls into that range as well. So just removing child nodes won't work."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Do the inorder traversal and delete what out of the range from the tree at the same time?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static void Trim(Tree root, int m, int n) \n        { \n            if (root == null) \n                return; \n \n            if (root.Left != null && root.Left.Value < m) \n            { \n                root.Left = root.Left.Right; \n            } \n            Trim(root.Left, m, n); \n            if (root.Right != null && root.Right.Value > n) \n            { \n                root.Right = root.Right.Left; \n            } \n            Trim(root.Right, m, n); \n \n        }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"{{  class Tree:     def __init__(self, data=None, left=None, right=None):         self.data = data         self.left = left         self.right = right              def preord(self):         print(self.data)         if self.left != None:             self.left.preord()         if self.right != None:             self.right.preord()      def inord(self):         if self.left != None:             self.left.inord()         print(self.data)         if self.right != None:             self.right.inord()      def postord(self):         if self.left != None:             self.left.postord()         if self.right != None:             self.right.postord()         print(self.data)          class BinaryTree(Tree):     def add(self, data):         if self.data == None:             self.data = data             return         if data<=self.data:             if self.left == None:                 self.left = BinaryTree(data)             else:                 self.left.add(data)         else:             if self.right == None:                 self.right = BinaryTree(data)             else:                 self.right.add(data)              def delete(self, data):         if self.data==data:             if self.left == None:                 self.data = self.right.data                 self.left = self.right.left                 self.right = self.right.right                 return             if self.right == None:                 self.data = self.left.data                 self.left = self.left.left                 self.right = self.left.right                 return             p1 = self.left             p2 = p1.right             while p2 != None and p2.right != None:                 p1 = p2.right             self.data = p2.data             p1.right = None             return         if data<=self.data:             self.left.delete(data)         else:             self.right.delete(data)                   class TrimBinaryTree(BinaryTree):     def add(self, data):         if self.data == None:             self.data = data             return         if data<=self.data:             if self.left == None:                 self.left = TrimBinaryTree(data)             else:                 self.left.add(data)         else:             if self.right == None:                 self.right = TrimBinaryTree(data)             else:                 self.right.add(data)      def trim(self, min, max):         if self.left != None:             if self.left.data < min:                 self.left = None             else:                 self.left.trim(min, max)         if self.right != None:             if self.right.data>max:                 self.right = None             else:                 self.right.trim(min, max)  #Tree(10, Tree('a'), Tree('cucu')).postord() x = TrimBinaryTree() x.add(20) x.add(5) x.add(3) x.add(2) x.add(4) x.add(7) x.add(9) x.add(30) x.add(25) x.add(35) x.add(11) x.trim(11, 30) x.inord() }}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"One can use Inorder traversal together with tree-delete which deletes the node. both this also are well known. so the code is:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node* TrimTree(node* T,int A,int B) \n   { \n       if( null==T )return; \n       if( A > B ) return TrimTree( T ,B , A ); \n        \n       if( T->info < B || T->info > A ) \n         { Trim(T);return null } \n        \n       else \n         { \n             T->left = TrimTree(T->left); \n             T->right = TrimTree(T->right); \n         } \n \n      return T ;     \n        \n   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assume A < B Standard error checks assumed. Here's pseudo code"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"post order traversal would work"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here I am just using the inorder traversal and blocking any values outside the range using a simple if condition. r1 - Lower Bound r2 - Upper Bound"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have a doubt regarding trimming of BST. the new trimmed tree should contain the node which are in the range of int A and B. if the code is 50 and you A and B is 10 and 30... so we will not consider this node as it is not in the range of A and B."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"One example is required"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"static BinaryNode trimTheTree(BinaryNode root,int min,int max){ \n  if(root == null) return null; \n   \n  if(root.value >= min && root.value <= max){ \n   root.left = trimTheTree(root.left, min, max); \n   root.right = trimTheTree(root.right, min, max); \n  }else{ \n   while(root != null && (root.value < min || root.value > max)){ \n    if(root.value < min) \n     root = root.right; \n    else \n     root = root.left; \n   } \n  } \n  return root; \n   \n } \n \nwith not cleaning the memory  \nit's java :)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node* trim_bst(node* root, int min, int max) \n{ \n \n    if(!root) { \n        return NULL; \n    } \n \n    if ( !root->left && !root->right) { \n        if (root->data < min || root->data > max) {         \n            free(root); \n            return NULL; \n        } else \n              return root; \n    } \n \n    if (min <= root->data  && root->data <= max) { \n \n        root->left = trim_bst(root->left, min, max); \n        root->right = trim_bst(root->right, min, max); \n \n        return root; \n    } \n \n    if (max < root->data) { \n              \n        trim_bst(root->right, min, max); \n        node* new_root = trim_bst(root->left, min,max); \n \n        if (root!= new_root) { \n            free(root); \n        } \n \n        return new_root; \n    } \n \n    if (root->data < min) { \n \n        trim_bst(root->left, min,max); \n        node* new_root = trim_bst(root->right, min, max); \n \n        if (root!= new_root) { \n            free(root); \n        } \n \n        return new_root; \n    } \n \n    return root; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void DeleteTree(struct node *root); \n \nstruct node * TrimTree(struct node **root, int min, int max) \n{ \n struct node *temp; \n  \n if((*root) == NULL) return NULL; \n  \n if(((*root)->value >= min) && ((*root)->value <= max)) \n { \n  ((*root)->leftTree) = TrimTree(&((*root)->leftTree), min, max); \n  ((*root)->rightTree) = TrimTree(&((*root)->rightTree), min, max); \n  return *root; \n } \n  \n if((*root)->value < min) \n { \n  DeleteTree((*root)->leftTree); \n  temp = TrimTree(&((*root)->rightTree), min, max);   \n } \n else \n { \n  DeleteTree((*root)->rightTree); \n  temp = TrimTree(&((*root)->leftTree), min, max);   \n }  \n  \n delete *root; \n *root = temp; \n return *root; \n} \n \n \n// Delete nodes in post order tree traversal \nvoid DeleteTree(struct node *root) \n{ \n if(root != NULL) \n { \n  DeleteTree(root->leftTree); \n  DeleteTree(root->rightTree); \n  delete root; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include #include #include struct node {        int data;        struct node*left;        struct node*right; };   void insert(struct node**q,int num) {      struct node *temp=NULL;      temp=(struct node*)malloc(sizeof(struct node));      if(*q==NULL)      {                  temp->data=num;                  temp->left=NULL;                  temp->right=NULL;                  *q=temp;                 // printf(\"%d\\n\",temp->data);      }      else      {          if(((*q)->data)>num)          insert(&((*q)->left),num);          else           insert(&((*q)->right),num);      } }  void trim(struct node**p,int m,int n) {      struct node*temp=*p;      if(*p==NULL)      return;      else      {          if(m>(*p)->data)          {           *p=(*p)->right;           temp->left=NULL;           temp->right=NULL;           free(temp);           trim(p,m,n);          }          else          {              if(n<(*p)->data)              {              *p=(*p)->left;               temp->left=NULL;               temp->right=NULL;               free(temp);              trim(p,m,n);;              }              else              {                  trim(&(*p)->left,m,(*p)->data);                  trim(&(*p)->right,(*p)->data,n);              }             }      } } void inorder(struct node*z) {      if(z!=NULL)      {                 inorder(z->left);                 printf(\"%d\\t\",z->data);                 inorder(z->right);      }      else return; } int main() {     struct node*p;     p=NULL;        insert(&p,17);       insert(&p,13);       insert(&p,21);       insert(&p,27);        insert(&p,19);       insert(&p,8);       insert(&p,15);       trim(&p,20,25);      inorder(p);       getch();       return 0;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct node* trim(struct node* root,int A,int B) \n{ \n        struct node* temp; \n        if(root) \n        { \n                if(root->data>=A && root->data<=B) \n                { \n                        root->left=trim(root->left,A,B); \n                        root->right=trim(root->right,A,B); \n                        return root; \n                } \n                else if(root->dataright; \n                        free(root); \n                        return trim(temp,A,B); \n                } \n                else if(root->data>B) \n                { \n                        temp=root->left; \n                        free(root); \n                        return trim(temp,A,B); \n                } \n        } \n        else \n                return NULL; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct node* trim(struct node* root,int A,int B) \n{ \n        struct node* temp; \n        if(root) \n        { \n                if(root->data>=A && root->data<=B) \n                { \n                        root->left=trim(root->left,A,B); \n                        root->right=trim(root->right,A,B); \n                        return root; \n                } \n                else if(root->dataright; \n                        free(root); \n                        return trim(temp,A,B); \n                } \n                else if(root->data>B) \n                { \n                        temp=root->left; \n                        free(root); \n                        return trim(temp,A,B); \n                } \n        } \n        else \n                return NULL; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's the complete code, this question is indeed similar to the one for checking if a tree is BST or not but the tricky part is avoiding memory leaks:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Seems easy... I work in JAVA/C++ AS3 so syntax would be eaten up!!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"If we remove the assumption that both A or B are for sure present than all that is needed to be changed is to add a FindNearestElementBST in the code above"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"If we remove the assumption that both A or B are for sure present than all that is needed to be changed is to replace searchBST by a FindNearestElementBST in the code above"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Yes Trim tree won't work, Make BST from this array 100 is root {100,80,10,5,11,90,85,95,120,110,108,115,150,145,170}, it resolves to a complete BST of height 4. Trim Tree for all values between 90 and 110 including 90 and 110 does not make sense. 80, and 120 will hang above 90 and 110. We can only return all values between two given numbers. So Question is ambiguous."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=10873016","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"32","title":"give a binary tree (not BST)where tree node, with extra pointer inorder-successor, initaliy all inorder-successor pointer set to NULL.  write a code to set all pointer to its inordersuccessor. struct Node { int data; Node *left, *right; Node *successor; };","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"void SetInorderChildren(BSTNode *pNode, BSTNode **lastPrint) {  if ( !pNode)   return;  SetInorderChildren(pNode->pLChild,lastPrint);  if (*lastPrint)   (*lastPrint)->pInorder = pNode;  (*lastPrint) = pNode;  SetInorderChildren(pNode->pRChild,lastPrint);  return;  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Good One. There is a small change needed in the program. We have to store BSTNode* lastPrint in global storage and update we cannot pass in the function. Because the stack will pop the lastPrint Value as you are using recursion."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void MakeInorder(Tree *tree) { \n    MakeInorderInternal(tree, NULL); \n} \n \n// Makes inorder of tree. \n// returns a pointer to node containing the smallest value. \n// max is the current candidate for the successor of the largest node \n// in the tree rooted at tree. \nTree *min MakeInorderInternal (Tree *tree, Tree *max) { \n    if (!tree) return NULL // or throw, depending on contract; \n    Tree *min; \n    if (tree->left) { \n        min = MakeInorderInternal(tree->left, tree);  \n               // tree is current candidate for max. \n    } else { \n        min = tree; \n    } \n    if (tree->right) { \n        tree->successor = MakeInorderInternal(tree->right, max);  \n                                         // max does not change. \n    } else { \n        tree->successor = max; \n    } \n    return min; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"call on root as: \ntraverse(root, NULL); \n \nint traverse(struct Node * n, struct Node * predecessor) \n{ \n    if (n != NULL) { \n \n        if (n->left != NULL) { \n            traverse(n->left, predecessor); \n        } \n \n        if (predecessor != NULL) { \n            predecessor->successor = n; \n        } \n \n        if (n->right != NULL) { \n            traverse(n->right, n); \n        } \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void MarkInorderSuccessor(TNode *root) {    if(root!=null && root->left!=null)   root->left->succesor = root;  MarkInorderSuccessor(root->left);  if(root!=null)   root->successor = LeftMostNode(root->right);  MarkInorderSuccessor(root->right); }  TNode* LeftMostNode(TNode* root) {  while(root->left!=null)     root = root->left;  return root; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Node** setInorder(Node* node, Node** inOrderNode) \n{ \n if(!node) return; \n \n \n if(node->left != NULL) \n { \n  leftInorder = setInorder(node->left, inOrderNode); \n  *leftInorder = node; \n } \n else \n { \nif(inOrderNode != NULL)  \n *inOrderNode = node; \n \n} \n \n if(node->right != NULL) \n { \n  rightInOrder = serInorder(node->right, &node->Inorder); \n \n} \n else \n  rightInOrder = &node->Inorder; \n \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"/* \n * assumeptions: isEmptyStack(), push() and pop() functions are already implemented \n */ \nvoid inorder(Node *head) \n{ \n struct Node *node = head \n struct Node *predecessor = null; \n while(!isStackEmpty || node!=null){ \n  if(node!=null){ \n   push(node); \n   node = node->left; \n  } \n  else{ \n   node = pop(); \n   if(predecessor != null) \n    predecessor->inordersuccessor = node; \n   predecessor = node; \n   printf(\"%d\",node->data); //only needed if you want to print \n   node = node->right; \n  } \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Void SetSucc(Tree *t) {     if(!t) return;     else     {         SetSucc(t->left);         SetSucc(t->right);         Tree * successor = SUCC(t)  //successor of Tree t's value in t's Child         Tree * predecessor = PRE(t) //predecessor of Tree t's value in t's child          t->succ = successor;         if(predecessor)             predecessor->succ = t;      }  }  /// PLS COMMENT ON ALGO"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"struct node { \nint data; \nstruct node *left,*right; \nstruct node *succ; \n} \n \ninordersucc(root,NULL); \n \nvoid inordersucc(struct node *node, struct node *prev) \n{ \nif(!node) \nreturn; \nif(node->left!= NULL){ \ninordersucc(node->left,node); \n} \nnode->succ = prev \nif(node->right != NULL){ \nstruct node *min = getMinNode(node->right); \nnode->succ = min; \ninordersucc(node->right,prev); \n} \n} \n \nstruct node * getMinNode(struct node *node) \n{ \n \nwhile(node->left != NULL){ \nnode = node->left; \n} \nreturn node; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi guys I am not clear why you all are assuming that its a BST or am I missing something ??"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void setInOrderSuccessor(Node *root) {        if (!root) {            return;        }            Stack   stack;        Node *curr = root;        boolean done = false;         while (!done) {              if (current) {                   // Push it on stack and move to left                   stack.push(curr);                   curr = curr->left;                 } else {                   if (stack.isEmpty()) {                        done = true;                   } else {                        curr = s.top();  // Get the top node                        s.pop();            // Remove it from stack                        if (curr->right == null) {                            curr->successor = s.top();    // current top is the successor                        } else {                            curr->successor = curr->right;  // right child is successor                        }                        // Move to the right side of the tree                        curr = curr->right ;                     }              }        } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"// C# // call FindSucc(head, null)  void FindSucc(Node head, Node Succ) {    if (head)    {        FindSucc(head.Right, Succ);        head.Succ = Succ;        Succ = head;        FindSucc(head.Left, Succ);    } }   // Please Comment"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void inorder(node *root,node *&pre) {     if(!root) return;     inorder(root->left,pre);     cout<data<<\" \";     if(pre) pre->successor=root;     pre=root;     inorder(root->right,pre); }  node *pre=NULL; inorder(root,pre);"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"isn't it simple: traverse the tree in any order (in pre or post) and for every node store the successor as the leftmost node in right subtree(if it exist) or the right child (if it has no left child) complexity: n(lgn)*lgn"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think this will work void succeed(NODEPTR p,NODEPTR *q) {   if(p!=NULL)   {    succeed(p->right,q);    p->successor=*q;    *q=p;    succeed(p->left,q);   } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"looks like right threaded binary tree... http: en wikipedia org / wiki / Threaded_binary_tree"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution :  2 pre-order traversals .  void AddSuccessor( Node root , Node node) {        if ( node == NULL )              return ;           Node succ = node;        FindSuccessor( root, node.data, succ );         if ( succ == node )     /* No successor */              node.successor = NULL;        else              node.successor = succ ;         AddSuccessor( root, node.left );        AddSuccessor( root, node.right ); }  void FindSuccessor( Node root, int x, Node &succ) {        if ( root == NULL )              return ;         if ( root.data > x && succ.data != x && root.data - x < succ.data - x )              succ = root ;        if ( root.data > x && succ.data == x )              succ = root ;         FindSuccessor( root.left, x, succ );        FindSuccessor( root.right, x, succ ); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"//reverse inorder will work   void setinrodersucc(node *root) {      if(!root)        return root;    node *prev = NULL;   return inorder(root, &prev) }    inorder(node *root, node**prev) {      if(!root)        return ;   inorder(root->right, prev);   root->next  =  *prev;  *prev = root;   inorder(root->left, prev) } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The logic is very simple...just do reverse inorder traversal!!!! sample code struct node *bst(struct node *root) { if(root==NULL) return null; else { temp=bst(root->right); q->in_su=temp; temp=bst(root->left); temp->in_su=q; } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"at last we need to return temp."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14560723","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"31","title":"Given a binary tree and 3 nodes x,y,z, write a function which returns true if y lies in the path between x and z and false otherwise. Its been posted couple of times in past in careercup blogs, still couldn't find an apt solution which considers corner cases like      y   /    \\ z       x","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"If parent pointer is not available we have to first traverse the tree and set parent pointers. First check if x,y,z lies in tree. Run a DFS from x to z and search for y."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"Find the LCA of x and z(takes O(n)+O(n) time). There are 2 possibilites: 1. LCA is either x or z, in the case traverse the nodes from LCA to non-LCA node and if y occurs in the path return TRUE.(O(n) time) 2. LCA is neither x nor z. In this case, traverse the nodes between LCA and x and LCA and y, if you found y in any of them, return TRUE. (O(n)+O(n)) time  Overall time complexity=O(n) Space complexity=O(1)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"please explain what is meant by path."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"First find Y. Now if you remove node Y from the tree, you have at most 3 trees. 1st tree with Y->left as root 2nd tree with Y->right as root 3rd tree is rest of the original tree Now check if X and Z lies in different trees. if yes, then Y lies between X and Z        a                                                                       /  \\                                                            x           z                 a     y    b             -> after removal of y ->        /              \\                  \\    / \\     \\                                                      d               e                  b   x  z     c                                                                                          \\  /     \\                                                                                                 c d      e  Of course before returning true, you have to re-attach the tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"bool _test(node *root, int x, int y, int z, int *count); \n \nbool test(node *root, int x, int y, int z) \n{ \n   int count = 0; \n   return _test(root,x,y,z,&count); \n} \n \nbool _test(node *root, int x, int y, int z, int *count) \n{ \n   if(root == NULL) \n   { \n   return false; \n   } \n   if(root->data == x) \n   { \n     (*count)++; \n   } \n   if((*count) == 1 && root->data == y) \n   { \n  (*count)++; \n   } \n   if((*count) == 2 && root->data == z) \n   { \n   return true; \n   } \n \n   bool left =  _test(root->left,x,y,z,count); \n   bool right = _test(root->right,x,y,z,count); \n \n   if(left == true || right == true) \n   { \n  return true; \n   } \n \n   if((*count) == 1 && root->data == x) \n   { \n     (*count)--; \n   } \n   if((*count) == 2 && root->data == y) \n   { \n  (*count)--; \n   } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be a simplest solution with complexity n(log n) call find_path function for every 'y' node.  int find_path(node * ptr) {    bool x_left = false, z_left = false;    bool x_right = false, z_right = false;    // search for x & z on left side    if(ptr->left)      find_xz(ptr->left, &x_left, &z_left);        // search for x & z on right side    if(ptr->right)      find_xz(ptr->left, &x_right, &z_right);     // if x found on left side and z on right then return true    // if x found on right side and z found on left side then return true    if((x_left && z_right)       ||(x_right && z_left))        return true;           return false;  }  find_xz(node * ptr, int * x, int * z) {    // if x or z found then mark corrosponding input parameter as true.    if(ptr->value == 'x')       *x = true;    if(ptr->value == 'z')       *z = true;     // if both x & z found then return    if(*x == true && *z == true)       return;        // search for x & z left side    if(ptr->left)      find_xz(ptr->left, x, z);        // search for x & z right side    if(ptr->right)      find_xz(ptr->right, x, z)      return; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"String x, y, z; // globals bool yconnect (node* head){   String path = \"\";   void helper(head, path);   int xlength,ylength,zlength;   xlength = x.length();   ylength = y.length();   zlength = z.length();   if(xlength < ylength && < zlength){       if(x == y.substr(0, xlength) && x == z.substr(0, xlength)){                return true;       }       else{                return false;       }   }   else if(ylength < zlength){       if(y = x.substr(0, ylength) && x = z.substr(0,xlength)){           return true;       }       else{           return false;       }   }   else{ //zlength < ylength       if(z = x.substr(0, zlength) && x = y.substr(0,xlength)){           return true;       }       else{           return false;       }   } }  void helper(node * head, String path){     if(head->data == 'x'){          x = path;     }     else if(head->data == 'y'){          y = path;     }     else if(head->data == 'z'){          z = path;     }     if (head->left != null){         helper(head->left, path.append(\"L\"));     }     if (head->right != null){         helper(head->right, path.append(\"L\"))     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"as it is a binary tree not binary search tree, \nwe have to do more work minimum time complexity will be O(n) \nsimply do inorder traversal of this tree,note the position of y wrt to x and z,it must be central if it is not then say false,else if it is central than one more test has to be performed to confirm , then perform post order traversal note the position of y with respect to x and z it must be after the x and z."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1) Find common ancestor, say w, of x and z. 2) Find whether y comes in path of w to x OR  w to z."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I guess just a preorder should do.. if y comes before atleast one of the other 2 nodes, then it means there is a path between x & z through y."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"create a path and also  check for Y, by doing breath first search with starting node as X & end node as Z, if y exist then return true. since BT is also a graph!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Use depth-first search because it's not a BST. BT simplifies the problem, since each node is part of a sub-linked list:  Two possibilities: X->...->Y...->...Z or Z->...-> Y -> ... -> X 1. Find X or Z first and mark as visited. If Y found first, return false.  2. Find Y and mark as visited; if X/Z found instead, return false. 3. Find X/Z as end of path, and mark as visited. If found, return true."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about this solution ...  There is three case :- 1. x-> y-> z     2.  z - > y ->x   3rd case in which (x or z)lies in left subtree  and (z or x) lies in right subtree.  int ispath(node *root,node *x,node *y,node *z){ if(root==Null) return 0; if(root==y){ yflag=1; if(xflag==1 || zflag==1) return ispath(root->left,x,y,z) || ispath(root->right,x,y,z); else return  ispath(root->left,x,y,z) && ispath(root->right,x,y,z); } elseif(root==x){ xflag=1; if(yflag==1) return 1; elseif(zflag==1) return 0; else return  ispath(root->left,x,y,z) || ispath(root->right,x,y,z); } elseif(root==z){ zflag=1; if(yflag==1) return 1; elseif(xflag==1) return 0; else return  ispath(root->left,x,y,z) || ispath(root->right,x,y,z); }.  else  return ispath(root->left,x,y,z) || ispath(root->right,x,y,z); }   Note:- xflag ,yflag and zflag global variables."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I have been thinking about this problem in-depth specifically to cover all the boundary cases and came up with the following. Please let me know if anyone can find an uncovered case. The algo is: 1. If either x is in subtree(y) OR z is in subtree(y) then return TRUE. 2. If both x is in subtree(y) AND z is in subtree(y) then If LCA(x, z) == y then return TRUE 3. Else all other conditions, return FALSE  The code is: private static boolean liesInPath(TreeNode root, TreeNode x, TreeNode y, TreeNode z) {         int countMatches = countMatchesPQ(y, x, z);         if(countMatches == 1) {             return true;         }         if(countMatches == 2) {             if(leastCommonAncestor(root, x, z) == y) {                 return true;             }         }         return false;     }  private static int countMatchesPQ(TreeNode root, TreeNode p, TreeNode q) {         if(root == null) {             return 0;         }         int matches = countMatchesPQ(root.left, p, q) + countMatchesPQ(root.right, p, q);         if(root == p || root == q) {             return matches + 1;         }         else {             return matches;         }     }  private static TreeNode leastCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {         if(root == null || p == null || q == null) {             return null;         }         if(root == p || root == q) {             return root;         }         int totalMatches = countMatchesPQ(root.left, p, q);         if(totalMatches == 1) {             return root;         }         else if(totalMatches == 2) {             return leastCommonAncestor(root.left, p, q);         }         else {             return leastCommonAncestor(root.right, p, q);         }     }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Flawless code ... Enjoy!!"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If each distinct route starting from the root to leaf node is considered as a path, we need to determine if there is a route from root to leaf which contains nodes x, y, z such that pathindex(y) > pathindex(x) and pathndex(y) < pathindex(z). The below code considers each path and determines if x,y,z exists satisfying the condition on their positions.  First defining the TreeNode class: ******"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"The solution requires to identify if Y lies in path.  Here is an approach back track tree to find the LCA of node X and Z . If it is Y then return True  else it is always false."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"-1","title":"Find the LCA of x and z. Let it be P. Traverse the tree from P to find x and store the path by    explicitly maintaining a stack. Check if y is in the stack or not. If yes return true, else do the same for the path between P and z. If y is present return true else return false."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=12746661","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"29","title":"Write a method to create new tree with same structure but the values of each node will be sum of their descendents (sub tree). The leaf nodes will become 0. So if the tree is 50 30 10 40 60 55 75 (PreOrder) then new tree should be 270 50 0 0 130 0 0(PreOrder)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"This is what I came up with the help of Interviewer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am not sure, if below solution is appropriate or not? Please correct me if anything wrong.  Steps: 1. First build BST with Preorder values. 2. Then do a Postorder traversal and update root as (root + (left + right)) and mark left and right as 0. 3. follow the step 2 till end of Post order."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I am not sure, if below solution is appropriate or not? Please correct me if anything wrong.  Steps: 1. First build BST with Preorder values. 2. Then do a Postorder traversal and update root as (root + (left + right)) and mark left and right as 0. 3. follow the step 2 till end of Post order."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int sumDescendant(struct node* Node) \n{ \n if(Node == NULL) \n  return 0; \n \n int cache = Node->data; \n Node->data = sumDescendant(Node->left) + sumDescendant(Node->right); \n return (cache + Node->data); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Seems like the focus should be on constructing the new tree and not on reconstructing the original tree from just the preorder traversal. It's just not possible to arrive at a unique tree with just that. Node[1] would hold the new root for a non-null tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"You can more form than one binary trees for a given preorder traversal. That means there could be more than one solution preorder sequences. For eg, for the given preorder traversal if you form a binary tree with all left pointers NULL, then the solution sequence is (320, 270, 240, 230, 190, 130, 0) not (270, 50, 0, 0, 130, 0, 0) as mentioned in the question . This is also is the easiest solution sequence that can be formed - cumulative sum.  Can the original poster confirm that he is not missing something?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Create a copy of original tree. 2. Do a postOrder Traversal with tree->data = tree->Left->data + tree->right->data . 3. Do a postOrder Traversal again passing the old and new tree as arguments and  now  newtree->data = newtree->data - oldtree->data;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Create a copy of original tree. 2. Do a postOrder Traversal with tree->data = tree->Left->data + tree->right->data . 3. Do a postOrder Traversal again passing the old and new tree as arguments and  now  newtree->data = newtree->data - oldtree->data;"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here in the same traversal new node is created using new left and right subtrees using post order recursive alg"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here in the same traversal new node is created using new left and right subtrees using post order recursive alg"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"simple function can do the work.. transverse through the original tree ..  node * func1(node *root) { node* root1=new node; root1->value=0; root1->value=sum(root); if (root->left!=NULL) root1->left=finc1(root->left); if (root->right!=NULL) root1->right=finc1(root->right); return(root1); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This is what I came up with the help of Interviewer"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming a trivial three element list-based representation of a BST tree, here is a complete example."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Assuming a trivial three element list-based representation of a BST tree, here is a complete example."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public int sumUpTree(BinaryTree root) \n { \n  if(root == null) \n  { \n   return 0; \n  } \n  else \n  { \n   int left = sumUpTree(root.left); \n   int right = sumUpTree(root.right); \n   int cacheData = root.data; \n   root.data = left + right; \n   return cacheData+left + right; \n  } \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int subtree_sum(NODEPTR root,int sum){ \n    if(root == NULL) \n        return 0; \n    sum = 0; \n    int temp; \n    sum += subtree_sum(root->left,sum); \n    sum += subtree_sum(root->right,sum); \n    temp = root->data; \n    root->data = sum; \n    return(temp + sum); \n    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"node* trees_programs::newtree(node* n) {     node*n1=0;      node*n2=0;  if(n==0)   return NULL;    n1=newtree(n->left);   n2=newtree(n->rite);  node* nd=new node(0);  if(n==root)  { root2=nd;   // root of new tree  }  nd->left=n1;  nd->rite=n2;  nd->data=0;  if(n->left==0&&n->rite==0)   {    nd->data=0;    nd->left=0;    nd->rite=0;      }  if(n->left!=0)   nd->data+=n->left->data;  if(n->rite!=0)   nd->data+=n->rite->data;  if(n1!=0)   nd->data+=n1->data;  if(n2!=0)   nd->data+=n2->data;  return nd;          }"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=9353717","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"29","title":"Maximum Sum path in a binary tree where the each node has a integer value associated to it.We have to print the ROOT TO LEAF path with maximum sum.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"My solution , verified ..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"its very similar to finding the longest sub sequence of an integer array. As the integer can be negative, we have to include the node under consideration into the sub optimal solution only even after adding it the solution remains positive.  Solution: start from root with dfs approach. keep on traversing towards the bottom till the point when adding the node value to the sum will yield non negative value. once this situation has arrived, it means we cannot add the new node to the solution and this is the max sum this traversal can yield from ROOT. compare this sum with the \"Global Maximum\" sum value and update it. if \"Global Maximum\" sum is less than the sum, \"Global maximum\" sum = the sum. No need to further traverse down the tree from the node(as the solution is required from the ROOT TO LEAF).  Do this for the dfs traversal and the solution will be the \"Global maximum\" sum. Time complexity: o(n) space complexity: o (1)   Another nice add on to show creativity. think about doing the same with multiple threads (parallel way). the whole tree can be divided equally among the present number of threads: if there are 4 threads, we can divide the tree into four subtrees. we can get four subtrees at second level (2^n subtrees at each level)."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public Linklist path = new LinkList();  int msp(Node root){ if(root == null)    return 0;  int leftSum = msp(root.left); int rightSum = msp(root.right);  if(leftSum > rightSum){   add left path into linklist; } else {   add right path into linklist; }  int sum = root.value + max(leftSum, rightSum);  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void pathWithMaxSum(node *root, int A[]){    static int index = 0, max = -1, path[10] ,sum = 0;   if(root == NULL) {     //printf(\"%d %d\\n\", sum , index);   path[index]=-1;   int i=0;   if(sum > max){    while(1){     A[i]=path[i];     if(path[i]==-1) break;     i++;    }    max = sum ;    return ;   }  }      else {       path[index] = root->data;    index++;    sum=sum+root->data;    pathWithMaxSum(root->left,A);    pathWithMaxSum(root->right,A);    index--;    sum=sum-root->data;   }    }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void maxSumPath (node* root, int* maxSum, int* path, int level, int curSum) \n{ \n int currPath[100]; \n if(root) \n { \n  currPath[level] = root->data; \n  curSum = curSum + root->data; \n  maxSumPath (root->left, maxSum, path, level+1, curSum); \n  maxSumPath (root->right, maxSum, path, level+1, curSum); \n } \n else \n { \n  int i; \n  if(*maxSum"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"1. Find the Maximum root to leaf node path while keeping the leaf node O(n). 2. Print the root to leaf node path using this leaf node. O(n)  It works for negative numbers also.  void findMaxSumLeaf(Node *root, Node ** leaf, int curSum, int *sum){  if(root == NULL)   return;  curSum = curSum + root->data;  if(root->left == NULL && root->right == NULL){   if(curSum > *sum){    *sum = curSum;    *leaf= root;   }  }  findMaxSumLeaf(root->left, leaf, curSum, sum);  findMaxSumLeaf(root->right, leaf, curSum, sum); }  void printRootToLeafHelper(Node* node, Node * leaf) {   int path[1000];   printRootToLeaf(node, leaf, path, 0); }  void printRootToLeaf(Node* node, Node * leaf, int path[], int pathLen) {   if (node==NULL) return;   path[pathLen++] = node->data;   if (node == leaf && node->left==NULL && node->right==NULL)     printArray(path, pathLen);   else {     printRootToLeaf(node->left, leaf, path, pathLen);     printRootToLeaf(node->right, leaf, path, pathLen);   } }  void printArray(int arr[], int len) {   int i;   for (i=0; i    printf(\"%d \", arr[i]); }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"since it satisfies optimal substructure & overlapping sub problem property. we can apply dynamic programming method.   \"if the given NODE is a leaf node, we just return the given nodes value, else MAX{msp(NODE.left), msp(NODE.right)}, where msp(NODE) returns the Maximum Sum path value of the given NODE as root."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"max_sum(node *n) {     int sum = 0, max = n->value;      if(n->left == NULL && n->right == NULL)         return max;     else if(n->left == NULL)         sum = max_sum(n->right);     else         sum = max_sum(n->left);     if(sum > 0)     {         if(max > 0)             max += sum;         else             max = sum;     }     return max; }  int find_max_sum(node *root) {     retutn max_sum(root);   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void findMaximumSumPath(Node root) {  if (root.left != null) {   findMaximumSumPath(root.left);  }     if (root.right != null) {   findMaximumSumPath(root.right);  }     if (root != null) {   root.maxSum = root.value;  }     if (root.left != null && root.right != null) {   root.maxSum += ((root.left.maxSum > root.right.maxSum) ?      root.left.maxSum : root.right.maxSum);  } else if (root.left != null) {   root.maxSum += root.left.maxSum;  } else if (root.right != null) {   root.maxSum += root.right.maxSum;  }   }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"vector calculateMaxSumPath(vector out, int& sum, TreeNode* root){    if(root->left == NULL && root->right == NULL){    sum+=root->data;    out.push_back(root->data);   return out;   }    sum += root->data;   int temp = sum;   out.push_back(root->data);    vector out1 = calculateMaxSumPath(out, sum, root->left);   int leftSum = sum;   vector out2 = calculateMaxSumPath(out, temp, root->right);   int rightSum = temp;    if(leftSum > rightSum)    return out1;    else    return out2;  }  int main(){  int sum = 0; vector temp; vector out = calculateMaxSumPath(temp, sum, root);  cout<<\"Printing maximum sum path\"< for(int i=0;i  cout< cout< return 0; }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int summax(node* root) \n{ \n \nif(root==NULL) \n return 0; \nelse \nif(summax(root->left)>summax(root->right) \nprintf(\"%d\",root->left->data); \nelse  \nprintf(\"%d\",root->right->data); \n \nreturn MAX(summax(root->left),summax(root->right))+root->data; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If we are allowed to change the structure of linked list (which very often we are not) we can store an extra char variable in the node which just stores 'L' if left is greater otherwise it stores 'R'. When traversing the calculateMaxSum() function we fill this char variable with respective values. After complete traversal we just start from root, printing the elements, go left if the char variable says L otherwise we'll go right. Time Complexity: O(n)  Space Complexity: O(n)  If we are not allowed to change the structure then we can create a new tree which just stores whether to go left or right while printing the sum. The program follows. Here also Time Complexity: O(n) Space Complexity: O(n)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"#include\"tree.cpp\"  struct path{     char where;     path *left;     path *right; };  struct node{                          int data;                          node *left;                          node *right; };  int printLargestSumPath(node *root,path **head);   int main() {    node *root=createTree();    cout<<\"\\nThe tree has been constructed\";    path *head=NULL;    int sum=printLargestSumPath(root,&head);        //Print the path with largest sum    cout<<\"\\nThe path with largest sum is:\\n\";    node *temp=root;    while(temp){      cout<data<<\" \";      if(head->where=='L'){         temp=temp->left;         head=head->left;       }         else{            temp=temp->right;            head=head->right;      }    }      cout<<\"\\nThe largest root to leaf sum is: \"<    cin.ignore(2);     return 0; }  int printLargestSumPath(node *root,path **head) {    if(!root) return 0;          path *pl,*pr;    pl=pr=NULL;    int lsum=printLargestSumPath(root->left,&pl);    int rsum=printLargestSumPath(root->right,&pr);        path *temp=new path;    temp->left=pl;     temp->right=pr;     *head=temp;         if(lsum>=rsum){                     temp->where='L';           return (lsum+root->data);     }     else{         temp->where='R';         return (rsum+root->data);     }      }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"int msp(node * root, llnode ** cur_path) \n{ \nint ls,rs,sum; \nllnode *l,*r; \nappend(cur_path, root); \nls=msp(root->left,&l); \nrs=msp(root->right,&r); \nif(ls>rs) \n{ \n      append(cur_path,l); \n      sum+=ls; \n      return sum; \n} \nelse \n{ \n      append(cur_path,r); \n      sum+=ls; \n      return sum; \n} \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"maxPathSum(TreeNode* root, int run_sum, list path, list& maxPath, int maxSum) \n{ \n      if (root == NULL) return NULL; \n      run_sum += root->val; \n      path.push_back(root); \n      if (root->left == NULL && root->right == NULL) \n      { \n                   if (run_sum > max_sum) \n                   { \n                                  minPath = path; \n                                  max_sum = run_sum; \n                    } \n      } \n      else \n      { \n                  maxPathSum(root->left, run_sum, path, maxSum, maxPath); \n                  maxPathSum(root->right,  run_sum, path, maxSum, maxPath); \n       } \n}"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=19574703","download_status":"DOWNLOAD_DONE","votes":"5","answersCount":"27","title":"Given a binary tree. Print nodes of extreme corners of each level but in alternate order.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Why not do a level order traversal?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"We can send an argument to indicate whether leftmost has to printed or the rightmost has to be printed. Nodes data will be printed if its lefts turn and the node is left most or if its not lefts turn and the node is right most node.    Also we need to handle a case where a node is leftMost node at that level but it doesnot have a left child, so the right child will become the leftmost, similarly for the rightMost case."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"it is same as printing the first nodes in zig zag order ....."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Shall we consider the root as one of the extremes ...if yes then left extreme or right extreme?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void alternative_traverse(Node root){ \n if (root == null) \n  return; \n System.out.println(root.content); \n Node right = current.right; \n Node left = current.left; \n boolean left_round = false; \n while (left != null && right != null){ \n  if (left_round){ \n   System.out.println(left.content); \n   left_round = false; \n   left = left.left; \n  }else{ \n   System.out.println(right.content); \n   left_round = true; \n   right = right.right; \n  } \n } \n while (right != null){ \n  System.out.println(right.content); \n  right = right.right; \n } \n while (left != null){ \n  System.out.println(left.content); \n  left = left.left; \n } \n return; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Hi..Here is my solution..but before using this function print the root node and then call its left child and right child in the main function"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"import java.util.*; \nimport java.io.*; \n \nclass Node { \n public int data; \n public Node left; \n public Node right; \n  \n Node(int data){ \n  this.data = data; \n } \n} \n \nclass LevelNode extends Node{ \n int level; \n  \n LevelNode(int data, int level) \n { \n  super(data); \n  this.level = level; \n } \n} \n \n \nclass BFS{ \n public Queue q; \n private Node root; \n  \n BFS(){ \n  this.buildTree(); \n  this.processBF(); \n } \n  \n public Iterable getPiers() \n { \n  LevelNode oldNode = null; \n  List list = new ArrayList(); \n  for(LevelNode node : this.q) \n  { \n   if (oldNode != null) \n   {  \n    if (node.level != oldNode.level){ \n     list.add(oldNode.data); \n     list.add(node.data); \n    } \n   } \n   oldNode = node; \n  } \n  list.add(oldNode.data); // The very last one is also a pier \n  return list; \n } \n  \n private void processBF() \n { \n  if (root == null) \n   return; \n   \n  q = new LinkedList(); \n  q.add(new LevelNode(root.data, 0)); \n  process(root, 1); \n } \n  \n private void process(Node node, int level) \n { \n  if (node == null) \n   return; \n   \n  if (node.left != null) \n   q.add(new LevelNode(node.left.data, level)); \n  if (node.right != null) \n   q.add(new LevelNode(node.right.data, level)); \n  process(node.left, level+1); \n  process(node.right, level+1); \n } \n  \n private void buildTree() \n { \n  root = new Node(0); \n  root.left = new Node(1); \n  root.right = new Node(2); \n  root.left.left = new Node(3); \n  root.left.right = new Node(4); \n  root.right.left = new Node(5); \n  root.right.right = new Node(6); \n   \n  root.right.left.left = new Node(7); \n  root.right.left.right = new Node(8); \n  root.right.right.left = new Node(9); \n  root.right.right.right = new Node(10); \n } \n  \n public static void main(){   \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"This can be easily solved using Zig-Zag level order traversal of the given tree.Use 2 stacks to do the zig zig level order traversal.  For More detail explanation just google \"leetcode : printing-binary-tree-in-zig-zag-level\".  Below is a small working code for the same. TreeNode represents our Tree."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"-Have an array to hold tree node pointers -copy root pointer at mid point of into array -------------10------------------------- -now replace existing tree node with its left and right if exists --------------5-11--------------------- -again replace existing tree node with its left and right  if exists --------------9-20-15------------------- --------------14-25---------------------- -----------------30------------------------ -at each steps we can print tree node info value alternately"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"can we do it in O(n) complexity and without using extra memory?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void PrintNodesInZipZag(Node root) \n{ \n if(root == null) \n  return; \n \n bool levelPrinted = false; \n int level = 1; \n Node levelBreak = new Node(); \n levelBreak.Value = null; \n Node temp = null; \n  \n Queue q = new Queue(); \n q.enqueue(root); \n q.enqueue(levelBreak); \n  \n while (q.Count > 0) \n { \n  temp = q.Dequeue(); \n  if(temp.Left != null) q.Enqueue(temp.Left); \n  if(temp.Right != null) q.Enqueue(temp.Right); \n   \n  if (level % 2 == 1 && !levelPrinted) \n  { \n   Console.Write(temp.Value); \n   levelPrinted = true; \n  } \n  else \n  { \n   if (temp.Value == null) \n   { \n    Console.Write(lastValue); \n    level++; \n    q.enqueue(levelBreak); \n   } \n  } \n   \n  lastValue = temp.Value; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Took me awhile to figure out that it was a Binary Tree and not a Binary Search Tree... irregardless, the solution works for both."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"I think it is better to think about it as BFS. I got the level in each iteration in a queue. I use alternating \"left\" variable to view the first element in the leve; queue one time(left most), and last element the other time ( right most)"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public void printAlternateCorners(Node root){ \n  //working phase \n  Node p,q; \n  p=root;   //traverses the left side  \n  q=root.right;  //traverse the right side  \n   \n  System.out.println(\"\"+p.info); \n  System.out.println(\"\"+q.info); \n   \n  while(p!=null || q != null){ \n    \n   //first traverse the left side  \n   if(p!=null){ \n    for(int i=0;i<2;i++){ \n     if(p.left != null){ \n      p=p.left; \n      i++; \n     }else if(p.right != null){ \n      p=p.right; \n     }else{ \n      p = null; \n      i=2;//terminate the loop  \n     }      \n    } \n   } \n    \n   if(p!=null) \n   System.out.println(\"\"+p.info); \n    \n   //first traverse the left side  \n   if(q!=null){ \n    for(int i=0;i<2;i++){ \n     if(q.right != null){ \n      q=q.right; \n      i++; \n     }else if(q.left != null){ \n      q=q.left; \n     }else{ \n      q = null; \n      i=2;//terminate the loop  \n     }      \n    } \n   } \n   System.out.println(\"\"+q.info); \n    \n  } \n   \n   \n }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void ZigZacTraversal(struct btree *root) {     struct btree *Stack1[20],*Stack2[20],*temp;     int top1=-1,top2=-1,LeftToRight=1;     int flag1=0,flag=0;           Stack1[++top1]=root;           while(top1>=0 || top2>=0)     {         if(LeftToRight)         {             while(top1>=0)             {                 temp=Stack1[top1--];                  if(flag==0){printf(\"%d \",temp->data); flag=1;}                                   if(temp->right)                     Stack2[++top2]=temp->right;                 if(temp->left)                  Stack2[++top2]=temp->left;                                                                         }             printf(\"|\");             flag=0;         }         else         {             while(top2>=0)             {                 temp=Stack2[top2--];                 if(flag1==0){printf(\"%d \",temp->data); flag1=1;}                                   if(temp->left)                     Stack1[++top1]=temp->left;                                       if(temp->right)                     Stack1[++top1]=temp->right;             }             printf(\"|\");             flag1=0;         }         LeftToRight=1-LeftToRight;     } }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void ZigZacTraversal(struct btree *root) \n{ \n    struct btree *Stack1[20],*Stack2[20],*temp; \n    int top1=-1,top2=-1,LeftToRight=1; \n    int flag1=0,flag=0; \n      \n    Stack1[++top1]=root; \n      \n    while(top1>=0 || top2>=0) \n    { \n        if(LeftToRight) \n        { \n            while(top1>=0) \n            { \n                temp=Stack1[top1--];  \n                if(flag==0){printf(\"%d \",temp->data); flag=1;} \n                  \n                if(temp->left) \n                    Stack2[++top2]=temp->left; \n                      \n                if(temp->right) \n                    Stack2[++top2]=temp->right; \n            } \n            printf(\"|\"); \n            flag=0; \n        } \n        else \n        { \n            while(top2>=0) \n            { \n                temp=Stack2[top2--]; \n                if(flag1==0){printf(\"%d \",temp->data); flag1=1;} \n                  \n                if(temp->right) \n                    Stack1[++top1]=temp->right; \n                      \n                if(temp->left) \n                    Stack1[++top1]=temp->left; \n            } \n            printf(\"|\"); \n            flag1=0; \n        } \n        LeftToRight=1-LeftToRight; \n    } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void print_alternate(node* root) \n{ \n queue nodes; \n nodes.enqueue(root); \n bool printLeft = true; \n \n while(!nodes.empty()) \n { \n  vector temp; \n  while(!nodes.empty()) \n  { \n   temp.push_back(nodes.dequeue()); \n  } \n  \n  if(printLeft) cout << temp[0]; \n  else cout << temp[temp.size() - 1]; \n  \n  printLeft = ~printLeft; \n \n  for(size_t i = 0; i < temp.size(); ++i) \n  { \n   const node*& front = nodes.dequeue(); \n   if(front->left != NULL) nodes.enqueue(front->left); \n   if(front->right != NULL) nodes.enqueue(front->right); \n  } \n }  \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"public static void printEdgesInAlternateOrder(Node root) { \n    printNode(root); \n    Node right = root.right(); \n    Node left = root.left(); \n    boolean printLeft = false; \n \n    while (right != null || left != null) { \n      if (right != null) { \n        if (!printLeft) { \n          printNode(right); \n        } \n        right = right.right() != null ? right.right() : right.left(); \n      } \n      if (left != null) { \n        if (printLeft) { \n          printNode(left); \n        } \n        left = left.left() != null ? left.left() : left.right(); \n      } \n \n      printLeft = !printLeft; \n    } \n  } \n \n  private static void printNode(Node root) { \n    System.out.print(root.value() + \" \"); \n  }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Recursive and iterative versions written in Groovy. Both are O(n), but iterative is more efficient because there is less overhead."}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=3190687","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"27","title":"Given a root and a node of a binary tree, write a function which finds all the nodes which are a 'k' distance from the given nodes. (distance can be upwards and downwards)","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Can you specify the function prototype and/or example input/output? What do you mean by given nodes?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"So this question is to find the number of nodes between root and a passed in node?  Why do you say distance can be upwards or downwards? What does that mean?  I would think root is at the top and you then traverse down to the other node, counting nodes you visit. Recursive depth first is easiest in this case, counting nodes. Am I way off guys?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"represent the tree using arrays. if the parent is at Ith node, the left children will be at 2i and the right one will be at 2i + 1, Using this representation you can traverse in both the directions without having parent pointers.  any comments ?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Okay, we're given a binary tree (presumed unbalanced and unsorted), a root node, a target node and a distance k.  The strategy is 3 part. 1.  Walk the tree using a stack pushing and popping until you find the target node.  This leaves you with a stack containing the parents of the target node.  Include the target node at the top of your stack. 2.  Create a function GetNodes(Node current, int distance) that adds the appropriate nodes to a list.  You'll use it in step 3 to call the left and right children recursively. 3.  Figure out which nodes to pump through your function GetNodes.  You want to send the target node, and the \"other child\" of the parent node only.  Thing is, you don't know whether you're the right or the left, so you have to keep a temp variable on hand to compare the children.  To do this, you need to start with the following initial values:    k = distance;    childNode = targetNode; In a while loop that exits when the stack is empty or k = 0, you do the following: a.  if curnode.left is not the childNode, then GetNodes(curnode.left, k-1) b.  repeat for right child. c.  decrement k d.  pop the stack to get new curnode.  Repeat."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Here's code for steps 2 and 3, and a stub for step 1.  Note that this implementation assumes that the tree implementation is abstracted and that each node only contains a left and a right but no parent.  If a node is parent-aware, the same strategy applies but step 1 is faster and easier to implement.  This implementation is O(n)  C#:"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My assumption of what the question states regarding going 'up or down' is represented in this example.  Say target node is C and distance 3. That should return the set { T, D, E }"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"explain a little more pls...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"explain a little more pls...."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Wont BFS solve the problem simply. BFS layers the tree interms of the distance from the root node. Given any node and given that we have already performed BFS, we know the level of the node from root say m. Getting the nodes of distance k (up or down) is just the matter of knowing nodes at the levels that are m-k and m+k. Am I Missing something here?"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"BFS can be used to find the distance between two nodes in a graph (or tree). Start BFS tree from node from which you have to find all nodes with distance 4.  In BFS as soon as you enqueue a child node 'N' of node 'R' at that point check distance array if((d[N] = d[R] + 1) == 4) output node 'N'"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"If we represent binary tree in the form of array. (2i - left node and 2i+1 - right) 1. From the given node (n) - (proceeding through 2n and 2n+1, find all child nodes which are at a distance k) 2. go to n/2, find all child nodes, which are at a distance k-1 3. go to n/4, find all child nodes which are at a distance k-2 proceed till n/2powx reaches root node."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"How about thinking the problem this way?  A binary tree is actually a graph right? Usually when we think about BT, the edge is unidirectional (parent->child). But in this case, apparent, travelling up is also okay. Say the node is A, it has two children B, C. If k = 1, then B and C should be also included as well.  So how about doing this  1. construct the tree as a graph with node as vertex and child links as bidirectional edges.  2. use Floyd Warshall algorithm to find out all the distance between any two nodes.  3. now all we need to do is to scan the distance matrix for the row and column correspnoding the target node A, and try to find all the other nodes B, where dist[a][b] or dist[b][a] == k."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Only slight addition to \"Someguy\" code and done in C++ \n \nvoid getNodes (Node *root, Node *target, int distance, Node **addNodes) \n{ \n    if (root == NULL || target == NULL || distance < 0) \n        return \n    Queue q; \n    bool isPresent = getparentQueue (Node *root, Node *target, Queue &q); \n    if (!isPresent) \n        return; \n    Node *child; \n    while (!q.isEmpty() && distance >= 0) \n    { \n        Node *current = q.deQueue (); \n        if (distance == 0) \n        { \n            addNodes.add (current); \n            break; \n        } \n        if (current->left != child) \n            findNodes (current->left, distance - 1,addNodes); \n        if (current->right != child) \n            findNodes (current->right, distance - 1, addNodes); \n        distance--; \n        child = current; \n    } \n} \n \nvoid findNodes (Node *root, int distance, Node **addNodes); \n{ \n    if (root == NULL) \n        return; \n    if (distance == 0) \n    { \n        addNodes.add (root); \n    } \n    else \n    { \n        findNodes (root->left, distance - 1, addNodes); \n        findNodes (root->right, distance -1, addNodes); \n    } \n} \n \nbool getParentQueue (Node *root, Node *target, Queue &q) \n{ \n    if (root == NULL) \n        return false; \n    bool leftNode = getParentQueue (root->left, target, q); \n    bool rightNode = getParentQueue (root->right, target, q); \n    if (root == target) \n    { \n        q.enqueue (root); \n        return true; \n    } \n    if (leftNode) \n    { \n        q.enqueue (root); \n        return true; \n    } \n    else if (rightNode) \n    { \n        q.enqueue (root) \n        return true; \n    } \n    else \n        return false; \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"NA"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"My solution : Traversal until find the node, search down first ,  then return back to root, at every node on the way back, check if the other subtree have some nodes with right distance"}]}},{"question":{"mm_name":"interview_question","location":"http://www.careercup.com/question?id=14656728","download_status":"DOWNLOAD_DONE","votes":"0","answersCount":"25","title":"Write a non-recursive function to delete an entire binary tree.","interview_question_comments":[{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"4","title":"This could be done with a level order traversal (or bfs tree traversal). if the interviewer didn't want that you could simulate a threaded bst using what is called Morris Traversal."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"3","title":"void DeleteTree(Node* root) \n{ \n std::stack nodes; \n nodes.push( root); \n while( ! nodes.empty()) \n { \n  Node* topNode = nodes.top(); \n  nodes.pop(); \n \n  if ( topNode->left ) \n   nodes.push(topNode->left); \n \n  if ( topNode->right ) \n   nodes.push(topNode->right); \n \n  delete topNode; \n } \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"2","title":"Post order traversal."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"1","title":"you don't have to use any storage actually. It's a postorder traversal that eliminates the leaves."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"check this O(1) implementation ..."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"Non recursive inorder traversal ....beacuse it will start from the leaves.."},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void deleteTree(TREE* head) \n{ \n if(head==NULL) \n  return ; \n \n deleteTree(head->left); \n deleteTree(head->right); \n free(head); \n}"},{"mm_name":"interview_question_comments","download_status":"UNPROCESSED","votes":"0","title":"void delete(Node root){ \n Stack S = new Stack(); \n Node current = root; \n while (current.leftChild != null){ \n  S.push(current); \n  current = current.leftChild; \n  current.Visited = false; \n } \n while (!S.isEmpty()){ \n  current = S.pop(); \n  if (!current.Visited){ \n   S.push(current); \n   current.Visited = true; \n   current = current.right; \n   while (current.leftChild != null){ \n    S.push(current); \n    current.Visited = false; \n    current = current.leftChild; \n   } \n  }else{ \n   delete(current); \n  } \n } \n return; \n}"}]}}]